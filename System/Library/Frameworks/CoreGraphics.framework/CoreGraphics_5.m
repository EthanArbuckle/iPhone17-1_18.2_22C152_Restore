uint64_t Wf_sample_W16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  unsigned int v43;
  unint64_t v44;
  unsigned __int16 *v45;
  unsigned __int16 *v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned __int16 *v51;
  unsigned int v52;
  unsigned __int16 *v53;
  unsigned __int16 *v54;
  unsigned int v55;
  unsigned __int16 *v56;
  unsigned int v57;
  uint64_t v58;
  unsigned __int16 *v59;
  unint64_t v60;
  unint64_t v61;
  unsigned __int16 *v62;
  unsigned __int16 *v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned __int16 *v71;
  unsigned int v72;
  unsigned __int16 *v73;
  int v74;
  unsigned __int16 *v75;
  unsigned int v76;
  unsigned __int16 *v77;
  uint64_t v78;
  uint64_t v79;
  float *v80;
  uint64_t v81;
  unint64_t v82;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  unsigned __int16 *v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;

  v4 = *(void *)(result + 32);
  v5 = *(void *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(void *)(result + 176);
  v89 = *(void *)(result + 80);
  v10 = *(void *)(result + 112);
  v9 = *(void *)(result + 120);
  v11 = *(void *)(result + 152) - 8;
  v91 = *(void *)(result + 88);
  v92 = *(void *)(result + 144) - 1;
  if (v5) {
    v12 = 0;
  }
  else {
    v12 = -65536;
  }
  v13 = *(_DWORD *)(result + 260) - 1;
  v14 = *(unsigned int *)(result + 256);
  v15 = v5 + (v13 * v7) + 2 * (v14 - 1);
  v16 = v4 + (v13 * v6) + 2 * v14 - 2;
  v87 = *(_DWORD *)(result + 188);
  v90 = *(void *)(result + 72);
  v88 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v90)
    {
      if (a3 <= v91)
      {
        v25 = ((unint64_t)a3 >> 22) & 0x3C0;
        v26 = 0x3FFFFFFF;
        v27 = a3;
        v28 = v88;
      }
      else
      {
        v21 = *(void *)(result + 216);
        v22 = *(void *)(result + 224) + v91;
        v23 = v22 - a3 + (v21 >> 1);
        if (v23 < 1) {
          goto LABEL_42;
        }
        if (v23 >= v21) {
          LODWORD(v24) = 0x3FFFFFFF;
        }
        else {
          v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
        }
        v28 = v88;
        v26 = v24 | v87;
        v27 = v22 - 0x1000000;
        v25 = 448;
      }
    }
    else
    {
      v17 = *(void *)(result + 216);
      v18 = v90 - *(void *)(result + 224);
      v19 = a3 - v18 + (v17 >> 1);
      if (v19 < 1) {
        goto LABEL_42;
      }
      if (v19 >= v17) {
        LODWORD(v20) = 0x3FFFFFFF;
      }
      else {
        v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
      }
      v28 = v88;
      v26 = v20 | v87;
      v27 = v18 + 0x1000000;
      v25 = 512;
    }
    if (a2 >= v28) {
      break;
    }
    v29 = *(void *)(result + 192);
    v30 = v28 - *(void *)(result + 200);
    v31 = a2 - v30 + (v29 >> 1);
    if (v31 >= 1)
    {
      if (v31 < v29) {
        v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v87;
      }
      v32 = v30 + 0x1000000;
      v33 = 32;
      goto LABEL_29;
    }
LABEL_42:
    --a4;
    a2 += v10;
    a3 += v9;
    v11 += 8;
    *(unsigned char *)++v92 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v89)
  {
    v33 = ((unint64_t)a2 >> 26) & 0x3C;
    v32 = a2;
    goto LABEL_29;
  }
  v34 = *(void *)(result + 192);
  v35 = *(void *)(result + 200) + v89;
  v36 = v35 - a2 + (v34 >> 1);
  if (v36 < 1) {
    goto LABEL_42;
  }
  if (v36 < v34) {
    v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v87;
  }
  v32 = v35 - 0x1000000;
  v33 = 28;
LABEL_29:
  if (v26 < 0x400000) {
    goto LABEL_42;
  }
  v37 = v27 >> 32;
  v38 = v4 + (int)v37 * (uint64_t)v6;
  v39 = (v32 >> 31) & 0xFFFFFFFFFFFFFFFELL;
  v40 = v38 + v39;
  v41 = *(unsigned __int16 **)(result + 32);
  if (v16 >= v38 + v39) {
    v42 = (unsigned __int16 *)(v38 + v39);
  }
  else {
    v42 = (unsigned __int16 *)v16;
  }
  if (v42 < v41) {
    v42 = *(unsigned __int16 **)(result + 32);
  }
  v43 = bswap32(*v42) >> 16;
  if (v5)
  {
    v44 = v5 + (int)v37 * (uint64_t)v7 + v39;
    v45 = *(unsigned __int16 **)(result + 40);
    if (v15 >= v44) {
      v46 = (unsigned __int16 *)v44;
    }
    else {
      v46 = (unsigned __int16 *)v15;
    }
    if (v46 >= v45) {
      v45 = v46;
    }
    v43 |= bswap32(*v45) & 0xFFFF0000;
  }
  else
  {
    v44 = 0;
  }
  v47 = v89;
  if (!v8) {
    goto LABEL_104;
  }
  v48 = *(_DWORD *)(v8 + (v33 | v25));
LABEL_48:
  v49 = v48 & 0xF;
  v50 = HIBYTE(v48) & 3;
  switch(v49)
  {
    case 1:
      v71 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 < (unint64_t)v71) {
        v71 = (unsigned __int16 *)v16;
      }
      if (v71 < v41) {
        v71 = v41;
      }
      v72 = bswap32(*v71) >> 16;
      if (v5)
      {
        v73 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        if (v15 < (unint64_t)v73) {
          v73 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v73 < *(void *)(result + 40)) {
          v73 = *(unsigned __int16 **)(result + 40);
        }
        v72 |= bswap32(*v73) & 0xFFFF0000;
      }
      v74 = interpolate_1616[v50];
      v69 = v43 - ((v74 & v43) >> (v50 + 1));
      v70 = (v74 & v72) >> (v50 + 1);
LABEL_91:
      v43 = v69 + v70;
      goto LABEL_103;
    case 2:
      v75 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v75) {
        v75 = (unsigned __int16 *)v16;
      }
      if (v75 < v41) {
        v75 = v41;
      }
      v76 = bswap32(*v75) >> 16;
      if (v5)
      {
        v77 = (unsigned __int16 *)(v44 + 2 * SBYTE2(v48));
        if (v15 < (unint64_t)v77) {
          v77 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v77 < *(void *)(result + 40)) {
          v77 = *(unsigned __int16 **)(result + 40);
        }
        v76 |= bswap32(*v77) & 0xFFFF0000;
      }
      v43 = v43
          - ((interpolate_1616[(v48 >> 28) & 3] & v43) >> (((v48 >> 28) & 3) + 1))
          + ((interpolate_1616[(v48 >> 28) & 3] & v76) >> (((v48 >> 28) & 3) + 1));
LABEL_103:
      v47 = v89;
      break;
    case 3:
      v86 = HIBYTE(v48) & 3;
      v51 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v51) {
        v51 = (unsigned __int16 *)v16;
      }
      if (v51 < v41) {
        v51 = v41;
      }
      v52 = bswap32(*v51) >> 16;
      v53 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 >= (unint64_t)v53) {
        v54 = v53;
      }
      else {
        v54 = (unsigned __int16 *)v16;
      }
      if (v54 < v41) {
        v54 = v41;
      }
      v55 = bswap32(*v54) >> 16;
      v56 = &v53[SBYTE2(v48)];
      if (v16 < (unint64_t)v56) {
        v56 = (unsigned __int16 *)v16;
      }
      if (v56 < v41) {
        v56 = v41;
      }
      v57 = bswap32(*v56) >> 16;
      if (v5)
      {
        v58 = 2 * SBYTE2(v48);
        v59 = (unsigned __int16 *)(v44 + v58);
        v60 = *(void *)(result + 40);
        if (v15 < v44 + v58) {
          v59 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v59 < v60) {
          v59 = *(unsigned __int16 **)(result + 40);
        }
        v52 |= bswap32(*v59) & 0xFFFF0000;
        v61 = v44 + SBYTE1(v48) * (uint64_t)v7;
        if (v15 >= v61) {
          v62 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        }
        else {
          v62 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v62 < v60) {
          v62 = *(unsigned __int16 **)(result + 40);
        }
        v55 |= bswap32(*v62) & 0xFFFF0000;
        v63 = (unsigned __int16 *)(v61 + v58);
        if (v15 < v61 + v58) {
          v63 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v63 < v60) {
          v63 = *(unsigned __int16 **)(result + 40);
        }
        v57 |= bswap32(*v63) & 0xFFFF0000;
      }
      v64 = interpolate_1616[v86];
      v65 = v43 - ((v64 & v43) >> (v86 + 1)) + ((v64 & v55) >> (v86 + 1));
      v66 = v52 - ((v64 & v52) >> (v86 + 1)) + ((v64 & v57) >> (v86 + 1));
      v67 = (v48 >> 28) & 3;
      v68 = interpolate_1616[v67];
      LOBYTE(v67) = v67 + 1;
      v69 = v65 - ((v65 & v68) >> v67);
      v70 = (v66 & v68) >> v67;
      goto LABEL_91;
  }
LABEL_104:
  v78 = 0;
  a2 += v10;
  v79 = v47 - a2;
  v80 = (float *)(v11 + 12);
  a3 += v9;
  v81 = v91 - a3;
  while (1)
  {
    *(v80 - 1) = *(float *)&_blt_float[v43 | 0x100] + *(float *)&_blt_float[BYTE1(v43) | 0x200];
    *v80 = *(float *)&_blt_float[((v43 | v12) >> 16) | 0x100]
         + *(float *)&_blt_float[((v43 | v12) >> 24) | 0x200];
    *(unsigned char *)(v92 + 1 + v78) = v26 >> 22;
    if (a4 - 1 == v78) {
      return result;
    }
    if ((v81 | v79 | (a3 - v90) | (a2 - v88)) < 0)
    {
      v92 += v78 + 1;
      v11 = (uint64_t)(v80 - 1);
      a4 += ~v78;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    v82 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    v40 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v82;
    v41 = *(unsigned __int16 **)(result + 32);
    if (v16 >= v40) {
      v83 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v82);
    }
    else {
      v83 = (unsigned __int16 *)v16;
    }
    if (v83 < v41) {
      v83 = *(unsigned __int16 **)(result + 32);
    }
    v43 = bswap32(*v83) >> 16;
    if (v5)
    {
      v44 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v82;
      v84 = *(unsigned __int16 **)(result + 40);
      if (v15 >= v44) {
        v85 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v82);
      }
      else {
        v85 = (unsigned __int16 *)v15;
      }
      if (v85 >= v84) {
        v84 = v85;
      }
      v43 |= bswap32(*v84) & 0xFFFF0000;
    }
    if (v8)
    {
      v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v48 & 0xF) != 0)
      {
        v92 += v78 + 1;
        v11 = (uint64_t)(v80 - 1);
        a4 += ~v78;
        v26 = -1;
        v47 = v89;
        goto LABEL_48;
      }
    }
    ++v78;
    v79 -= v10;
    v80 += 2;
    a3 += v9;
    v81 -= v9;
    a2 += v10;
    v26 = -1;
  }
}

uint64_t Wf_sample_w16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v89 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 8;
  uint64_t v91 = *(void *)(result + 88);
  uint64_t v92 = *(void *)(result + 144) - 1;
  if (v5) {
    int v12 = 0;
  }
  else {
    int v12 = -65536;
  }
  int v13 = *(_DWORD *)(result + 260) - 1;
  uint64_t v14 = *(unsigned int *)(result + 256);
  unint64_t v15 = v5 + (v13 * v7) + 2 * (v14 - 1);
  unint64_t v16 = v4 + (v13 * v6) + 2 * v14 - 2;
  int v87 = *(_DWORD *)(result + 188);
  uint64_t v90 = *(void *)(result + 72);
  uint64_t v88 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v90)
    {
      if (a3 <= v91)
      {
        uint64_t v25 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v26 = 0x3FFFFFFF;
        uint64_t v27 = a3;
        uint64_t v28 = v88;
      }
      else
      {
        uint64_t v21 = *(void *)(result + 216);
        uint64_t v22 = *(void *)(result + 224) + v91;
        uint64_t v23 = v22 - a3 + (v21 >> 1);
        if (v23 < 1) {
          goto LABEL_42;
        }
        if (v23 >= v21) {
          LODWORD(v24) = 0x3FFFFFFF;
        }
        else {
          unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
        }
        uint64_t v28 = v88;
        unsigned int v26 = v24 | v87;
        uint64_t v27 = v22 - 0x1000000;
        uint64_t v25 = 448;
      }
    }
    else
    {
      uint64_t v17 = *(void *)(result + 216);
      uint64_t v18 = v90 - *(void *)(result + 224);
      uint64_t v19 = a3 - v18 + (v17 >> 1);
      if (v19 < 1) {
        goto LABEL_42;
      }
      if (v19 >= v17) {
        LODWORD(v20) = 0x3FFFFFFF;
      }
      else {
        unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
      }
      uint64_t v28 = v88;
      unsigned int v26 = v20 | v87;
      uint64_t v27 = v18 + 0x1000000;
      uint64_t v25 = 512;
    }
    if (a2 >= v28) {
      break;
    }
    uint64_t v29 = *(void *)(result + 192);
    uint64_t v30 = v28 - *(void *)(result + 200);
    uint64_t v31 = a2 - v30 + (v29 >> 1);
    if (v31 >= 1)
    {
      if (v31 < v29) {
        unsigned int v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v87;
      }
      uint64_t v32 = v30 + 0x1000000;
      uint64_t v33 = 32;
      goto LABEL_29;
    }
LABEL_42:
    --a4;
    a2 += v10;
    a3 += v9;
    v11 += 8;
    *(unsigned char *)++uint64_t v92 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v89)
  {
    uint64_t v33 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v32 = a2;
    goto LABEL_29;
  }
  uint64_t v34 = *(void *)(result + 192);
  uint64_t v35 = *(void *)(result + 200) + v89;
  uint64_t v36 = v35 - a2 + (v34 >> 1);
  if (v36 < 1) {
    goto LABEL_42;
  }
  if (v36 < v34) {
    unsigned int v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v87;
  }
  uint64_t v32 = v35 - 0x1000000;
  uint64_t v33 = 28;
LABEL_29:
  if (v26 < 0x400000) {
    goto LABEL_42;
  }
  uint64_t v37 = v27 >> 32;
  uint64_t v38 = v4 + (int)v37 * (uint64_t)v6;
  unint64_t v39 = (v32 >> 31) & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v40 = v38 + v39;
  v41 = *(unsigned __int16 **)(result + 32);
  if (v16 >= v38 + v39) {
    v42 = (unsigned __int16 *)(v38 + v39);
  }
  else {
    v42 = (unsigned __int16 *)v16;
  }
  if (v42 < v41) {
    v42 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v43 = *v42;
  if (v5)
  {
    unint64_t v44 = v5 + (int)v37 * (uint64_t)v7 + v39;
    v45 = *(unsigned __int16 **)(result + 40);
    if (v15 >= v44) {
      v46 = (unsigned __int16 *)v44;
    }
    else {
      v46 = (unsigned __int16 *)v15;
    }
    if (v46 >= v45) {
      v45 = v46;
    }
    v43 |= *v45 << 16;
  }
  else
  {
    unint64_t v44 = 0;
  }
  uint64_t v47 = v89;
  if (!v8) {
    goto LABEL_104;
  }
  unsigned int v48 = *(_DWORD *)(v8 + (v33 | v25));
LABEL_48:
  int v49 = v48 & 0xF;
  int v50 = HIBYTE(v48) & 3;
  switch(v49)
  {
    case 1:
      v71 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 < (unint64_t)v71) {
        v71 = (unsigned __int16 *)v16;
      }
      if (v71 < v41) {
        v71 = v41;
      }
      unsigned int v72 = *v71;
      if (v5)
      {
        v73 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        if (v15 < (unint64_t)v73) {
          v73 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v73 < *(void *)(result + 40)) {
          v73 = *(unsigned __int16 **)(result + 40);
        }
        v72 |= *v73 << 16;
      }
      int v74 = interpolate_1616[v50];
      unsigned int v69 = v43 - ((v74 & v43) >> (v50 + 1));
      unsigned int v70 = (v74 & v72) >> (v50 + 1);
LABEL_91:
      unsigned int v43 = v69 + v70;
      goto LABEL_103;
    case 2:
      v75 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v75) {
        v75 = (unsigned __int16 *)v16;
      }
      if (v75 < v41) {
        v75 = v41;
      }
      unsigned int v76 = *v75;
      if (v5)
      {
        v77 = (unsigned __int16 *)(v44 + 2 * SBYTE2(v48));
        if (v15 < (unint64_t)v77) {
          v77 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v77 < *(void *)(result + 40)) {
          v77 = *(unsigned __int16 **)(result + 40);
        }
        v76 |= *v77 << 16;
      }
      unsigned int v43 = v43
          - ((interpolate_1616[(v48 >> 28) & 3] & v43) >> (((v48 >> 28) & 3) + 1))
          + ((interpolate_1616[(v48 >> 28) & 3] & v76) >> (((v48 >> 28) & 3) + 1));
LABEL_103:
      uint64_t v47 = v89;
      break;
    case 3:
      int v86 = HIBYTE(v48) & 3;
      v51 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v51) {
        v51 = (unsigned __int16 *)v16;
      }
      if (v51 < v41) {
        v51 = v41;
      }
      unsigned int v52 = *v51;
      v53 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 >= (unint64_t)v53) {
        v54 = v53;
      }
      else {
        v54 = (unsigned __int16 *)v16;
      }
      if (v54 < v41) {
        v54 = v41;
      }
      unsigned int v55 = *v54;
      v56 = &v53[SBYTE2(v48)];
      if (v16 < (unint64_t)v56) {
        v56 = (unsigned __int16 *)v16;
      }
      if (v56 < v41) {
        v56 = v41;
      }
      unsigned int v57 = *v56;
      if (v5)
      {
        uint64_t v58 = 2 * SBYTE2(v48);
        v59 = (unsigned __int16 *)(v44 + v58);
        unint64_t v60 = *(void *)(result + 40);
        if (v15 < v44 + v58) {
          v59 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v59 < v60) {
          v59 = *(unsigned __int16 **)(result + 40);
        }
        v52 |= *v59 << 16;
        unint64_t v61 = v44 + SBYTE1(v48) * (uint64_t)v7;
        if (v15 >= v61) {
          v62 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        }
        else {
          v62 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v62 < v60) {
          v62 = *(unsigned __int16 **)(result + 40);
        }
        v55 |= *v62 << 16;
        v63 = (unsigned __int16 *)(v61 + v58);
        if (v15 < v61 + v58) {
          v63 = (unsigned __int16 *)v15;
        }
        if ((unint64_t)v63 < v60) {
          v63 = *(unsigned __int16 **)(result + 40);
        }
        v57 |= *v63 << 16;
      }
      int v64 = interpolate_1616[v86];
      unsigned int v65 = v43 - ((v64 & v43) >> (v86 + 1)) + ((v64 & v55) >> (v86 + 1));
      unsigned int v66 = v52 - ((v64 & v52) >> (v86 + 1)) + ((v64 & v57) >> (v86 + 1));
      int v67 = (v48 >> 28) & 3;
      int v68 = interpolate_1616[v67];
      LOBYTE(v67) = v67 + 1;
      unsigned int v69 = v65 - ((v65 & v68) >> v67);
      unsigned int v70 = (v66 & v68) >> v67;
      goto LABEL_91;
  }
LABEL_104:
  uint64_t v78 = 0;
  a2 += v10;
  uint64_t v79 = v47 - a2;
  v80 = (float *)(v11 + 12);
  a3 += v9;
  uint64_t v81 = v91 - a3;
  while (1)
  {
    *(v80 - 1) = *(float *)&_blt_float[v43 | 0x100] + *(float *)&_blt_float[BYTE1(v43) | 0x200];
    float *v80 = *(float *)&_blt_float[((v43 | v12) >> 16) | 0x100]
         + *(float *)&_blt_float[((v43 | v12) >> 24) | 0x200];
    *(unsigned char *)(v92 + 1 + v78) = v26 >> 22;
    if (a4 - 1 == v78) {
      return result;
    }
    if ((v81 | v79 | (a3 - v90) | (a2 - v88)) < 0)
    {
      uint64_t v11 = (uint64_t)(v80 - 1);
      v92 += v78 + 1;
      a4 += ~v78;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v82 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v40 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v82;
    v41 = *(unsigned __int16 **)(result + 32);
    if (v16 >= v40) {
      v83 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v82);
    }
    else {
      v83 = (unsigned __int16 *)v16;
    }
    if (v83 < v41) {
      v83 = *(unsigned __int16 **)(result + 32);
    }
    unsigned int v43 = *v83;
    if (v5)
    {
      unint64_t v44 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v82;
      v84 = *(unsigned __int16 **)(result + 40);
      if (v15 >= v44) {
        v85 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v82);
      }
      else {
        v85 = (unsigned __int16 *)v15;
      }
      if (v85 >= v84) {
        v84 = v85;
      }
      v43 |= *v84 << 16;
    }
    if (v8)
    {
      unsigned int v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v48 & 0xF) != 0)
      {
        uint64_t v11 = (uint64_t)(v80 - 1);
        v92 += v78 + 1;
        a4 += ~v78;
        unsigned int v26 = -1;
        uint64_t v47 = v89;
        goto LABEL_48;
      }
    }
    v79 -= v10;
    v80 += 2;
    ++v78;
    a3 += v9;
    v81 -= v9;
    a2 += v10;
    unsigned int v26 = -1;
  }
}

uint64_t Wf_sample_WF_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v126 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v125 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v125 = v5 % v6;
    }
  }
  else
  {
    uint64_t v125 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v127 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v124 = v11;
  }
  else
  {
    uint64_t v124 = 0;
  }
  uint64_t v120 = *(void *)(result + 80);
  uint64_t v121 = *(void *)(result + 64);
  uint64_t v122 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 152) - 8;
  uint64_t v13 = *(void *)(result + 144) - 1;
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  unint64_t v16 = v9 + (v14 * v126) + 4 * (v15 - 1);
  int v119 = *(_DWORD *)(result + 188);
  unint64_t v17 = v127 + (v14 * v4) + 4 * v15 - 4;
  uint64_t v123 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 < v123)
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v123 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_57;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v28 = v119 | v21;
        uint64_t v29 = v19 + 0x1000000;
        uint64_t v26 = a3 - (v19 + 0x1000000);
        uint64_t v27 = 512;
        goto LABEL_22;
      }
      if (a3 <= v122)
      {
        uint64_t v26 = 0;
        uint64_t v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v28 = 0x3FFFFFFF;
        uint64_t v29 = a3;
LABEL_22:
        uint64_t v30 = v121;
        goto LABEL_25;
      }
      uint64_t v22 = *(void *)(result + 216);
      uint64_t v23 = *(void *)(result + 224) + v122;
      uint64_t v24 = v23 - a3 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_57;
      }
      if (v24 >= v22) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
      }
      uint64_t v30 = v121;
      unsigned int v28 = v119 | v25;
      uint64_t v29 = v23 - 0x1000000;
      uint64_t v26 = a3 - (v23 - 0x1000000);
      uint64_t v27 = 448;
LABEL_25:
      if (a2 >= v30) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v30 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v119;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = a2 - (v32 + 0x1000000);
        uint64_t v36 = 32;
        goto LABEL_36;
      }
LABEL_57:
      --a4;
      a2 += v5;
      a3 += v10;
      v12 += 8;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v120)
    {
      uint64_t v35 = 0;
      uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_36;
    }
    uint64_t v37 = *(void *)(result + 192);
    uint64_t v38 = *(void *)(result + 200) + v120;
    uint64_t v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1) {
      goto LABEL_57;
    }
    if (v39 < v37) {
      unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v119;
    }
    uint64_t v34 = v38 - 0x1000000;
    uint64_t v35 = a2 - (v38 - 0x1000000);
    uint64_t v36 = 28;
LABEL_36:
    if (v28 < 0x400000) {
      goto LABEL_57;
    }
    if (v6)
    {
      uint64_t v40 = (v7 & ((v29 % v7) >> 63)) + v29 % v7;
      uint64_t v41 = (v6 & ((v34 % v6) >> 63)) + v34 % v6;
      if (v40 >= v7) {
        uint64_t v42 = v7;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v29 = v40 - v42;
      if (v41 >= v6) {
        uint64_t v43 = v6;
      }
      else {
        uint64_t v43 = 0;
      }
      uint64_t v34 = v41 - v43;
      v26 += v29;
      v35 += v34;
    }
    uint64_t v44 = v29 >> 32;
    uint64_t v45 = v127 + SHIDWORD(v29) * (uint64_t)v4;
    unint64_t v46 = (v34 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v47 = v45 + v46;
    unsigned int v48 = *(unsigned int **)(result + 32);
    if (v17 >= v45 + v46) {
      int v49 = (unsigned int *)(v45 + v46);
    }
    else {
      int v49 = (unsigned int *)v17;
    }
    if (v49 < v48) {
      int v49 = *(unsigned int **)(result + 32);
    }
    if (v9)
    {
      unint64_t v50 = v9 + (int)v44 * (uint64_t)v126 + v46;
      v51 = *(unsigned int **)(result + 40);
      if (v16 >= v50) {
        unsigned int v52 = (unsigned int *)v50;
      }
      else {
        unsigned int v52 = (unsigned int *)v16;
      }
      if (v52 >= v51) {
        v51 = v52;
      }
      float v53 = COERCE_FLOAT(bswap32(*v51));
    }
    else
    {
      unint64_t v50 = 0;
      float v53 = 1.0;
    }
    float v54 = COERCE_FLOAT(bswap32(*v49));
    if (!v8) {
      goto LABEL_128;
    }
    unsigned int v55 = *(_DWORD *)(v8 + (v36 | v27));
LABEL_63:
    int v56 = v55 & 0xF;
    uint64_t v57 = v55 >> 8;
    unsigned int v58 = HIBYTE(v55) & 3;
    if (v56 == 1)
    {
      LODWORD(v83) = SBYTE1(v55);
      if (v6)
      {
        uint64_t v84 = v26 + ((uint64_t)SBYTE1(v55) << 32);
        uint64_t v85 = v7 & (v84 >> 63);
        if (v85 + v84 >= v7) {
          uint64_t v86 = v7;
        }
        else {
          uint64_t v86 = 0;
        }
        uint64_t v83 = (v85 + ((uint64_t)(char)v57 << 32) - v86) >> 32;
      }
      int v87 = (unsigned int *)(v47 + (int)v83 * (uint64_t)v4);
      if (v17 < (unint64_t)v87) {
        int v87 = (unsigned int *)v17;
      }
      if (v87 < v48) {
        int v87 = v48;
      }
      float v88 = COERCE_FLOAT(bswap32(*v87));
      float v89 = 1.0;
      if (v9)
      {
        uint64_t v90 = (unsigned int *)(v50 + (int)v83 * (uint64_t)v126);
        if (v16 < (unint64_t)v90) {
          uint64_t v90 = (unsigned int *)v16;
        }
        if ((unint64_t)v90 < *(void *)(result + 40)) {
          uint64_t v90 = *(unsigned int **)(result + 40);
        }
        float v89 = COERCE_FLOAT(bswap32(*v90));
      }
      uint64_t v91 = &interpolate_waf[2 * v58];
    }
    else
    {
      if (v56 != 2)
      {
        if (v56 == 3)
        {
          LODWORD(v59) = SBYTE1(v55);
          uint64_t v60 = SBYTE2(v55);
          if (v6)
          {
            uint64_t v61 = v57 << 56;
            int64_t v62 = (unint64_t)HIWORD(v55) << 56;
            uint64_t v63 = v26 + ((uint64_t)SBYTE1(v55) << 32);
            uint64_t v64 = v35 + (v62 >> 24);
            uint64_t v65 = v7 & (v63 >> 63);
            uint64_t v66 = v6 & (v64 >> 63);
            uint64_t v67 = v66 + v64;
            if (v65 + v63 >= v7) {
              uint64_t v68 = v7;
            }
            else {
              uint64_t v68 = 0;
            }
            if (v67 >= v6) {
              uint64_t v69 = v6;
            }
            else {
              uint64_t v69 = 0;
            }
            uint64_t v59 = (v65 + (v61 >> 24) - v68) >> 32;
            uint64_t v60 = (v66 + (v62 >> 24) - v69) >> 32;
          }
          unint64_t v70 = v47 + 4 * v60;
          if (v17 >= v70) {
            v71 = (unsigned int *)(v47 + 4 * v60);
          }
          else {
            v71 = (unsigned int *)v17;
          }
          if (v71 < v48) {
            v71 = v48;
          }
          float v72 = COERCE_FLOAT(bswap32(*v71));
          v73 = (unsigned int *)(v70 + (int)v59 * (uint64_t)v4);
          if (v17 < (unint64_t)v73) {
            v73 = (unsigned int *)v17;
          }
          if (v73 < v48) {
            v73 = v48;
          }
          float v74 = COERCE_FLOAT(bswap32(*v73));
          float v75 = 1.0;
          float v76 = 1.0;
          if (v9)
          {
            unint64_t v77 = v50 + 4 * v60;
            unint64_t v78 = *(void *)(result + 40);
            if (v16 >= v77) {
              uint64_t v79 = (unsigned int *)(v50 + 4 * v60);
            }
            else {
              uint64_t v79 = (unsigned int *)v16;
            }
            if ((unint64_t)v79 < v78) {
              uint64_t v79 = *(unsigned int **)(result + 40);
            }
            float v76 = COERCE_FLOAT(bswap32(*v79));
            v80 = (unsigned int *)(v77 + (int)v59 * (uint64_t)v126);
            if (v16 < (unint64_t)v80) {
              v80 = (unsigned int *)v16;
            }
            if ((unint64_t)v80 < v78) {
              v80 = *(unsigned int **)(result + 40);
            }
            float v75 = COERCE_FLOAT(bswap32(*v80));
          }
          float v81 = interpolate_waf[2 * v58 + 1];
          float v82 = interpolate_waf[2 * ((v55 >> 28) & 3) + 1];
          float v54 = (float)((float)((float)(v54 - (float)(v54 * v81)) + (float)(v72 * v81))
                      - (float)((float)((float)(v54 - (float)(v54 * v81)) + (float)(v72 * v81)) * v82))
              + (float)((float)((float)(v72 - (float)(v72 * v81)) + (float)(v74 * v81)) * v82);
          float v53 = (float)((float)((float)(v53 - (float)(v53 * v81)) + (float)(v76 * v81))
                      - (float)((float)((float)(v53 - (float)(v53 * v81)) + (float)(v76 * v81)) * v82))
              + (float)((float)((float)(v76 - (float)(v76 * v81)) + (float)(v75 * v81)) * v82);
        }
        goto LABEL_128;
      }
      uint64_t v92 = SBYTE2(v55);
      if (v6)
      {
        uint64_t v93 = v35 + ((uint64_t)SBYTE2(v55) << 32);
        uint64_t v94 = v6 & (v93 >> 63);
        if (v94 + v93 >= v6) {
          uint64_t v95 = v6;
        }
        else {
          uint64_t v95 = 0;
        }
        uint64_t v92 = (v94 + ((uint64_t)((unint64_t)HIWORD(v55) << 56) >> 24) - v95) >> 32;
      }
      v96 = (unsigned int *)(v47 + 4 * v92);
      if (v17 < (unint64_t)v96) {
        v96 = (unsigned int *)v17;
      }
      if (v96 < v48) {
        v96 = v48;
      }
      float v88 = COERCE_FLOAT(bswap32(*v96));
      float v89 = 1.0;
      if (v9)
      {
        v97 = (unsigned int *)(v50 + 4 * v92);
        if (v16 < (unint64_t)v97) {
          v97 = (unsigned int *)v16;
        }
        if ((unint64_t)v97 < *(void *)(result + 40)) {
          v97 = *(unsigned int **)(result + 40);
        }
        float v89 = COERCE_FLOAT(bswap32(*v97));
      }
      uint64_t v91 = &interpolate_waf[2 * ((v55 >> 28) & 3)];
    }
    float v98 = v91[1];
    float v54 = (float)(v54 - (float)(v54 * v98)) + (float)(v88 * v98);
    float v53 = (float)(v53 - (float)(v53 * v98)) + (float)(v89 * v98);
LABEL_128:
    *(float *)(v12 + 8) = v54;
    *(float *)(v12 + 12) = v53;
    *(unsigned char *)(v13 + 1) = v28 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v99 = 0;
    v100 = (float *)(v12 + 20);
    a2 += v5;
    uint64_t v101 = v120 - a2;
    a3 += v10;
    uint64_t v102 = v122 - a3;
    int v103 = --a4;
    while (1)
    {
      uint64_t v104 = v13 + v99 + 1;
      uint64_t v12 = (uint64_t)(v100 - 3);
      if ((v102 | v101 | (a3 - v123) | (a2 - v121)) < 0) {
        break;
      }
      if (v6)
      {
        uint64_t v105 = (v7 & ((v26 + v124) >> 63)) + v26 + v124;
        uint64_t v106 = (v6 & ((v35 + v125) >> 63)) + v35 + v125;
        if (v105 >= v7) {
          uint64_t v107 = v7;
        }
        else {
          uint64_t v107 = 0;
        }
        uint64_t v108 = v105 - v107;
        if (v106 >= v6) {
          uint64_t v109 = v6;
        }
        else {
          uint64_t v109 = 0;
        }
        uint64_t v110 = v106 - v109;
        uint64_t v35 = v110;
        uint64_t v26 = v108;
      }
      else
      {
        uint64_t v110 = a2;
        uint64_t v108 = a3;
      }
      uint64_t v111 = v108 >> 32;
      uint64_t v112 = v127 + SHIDWORD(v108) * (uint64_t)v4;
      unint64_t v113 = (v110 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v47 = v112 + v113;
      unsigned int v48 = *(unsigned int **)(result + 32);
      if (v17 >= v112 + v113) {
        v114 = (unsigned int *)(v112 + v113);
      }
      else {
        v114 = (unsigned int *)v17;
      }
      if (v114 < v48) {
        v114 = *(unsigned int **)(result + 32);
      }
      if (v9)
      {
        unint64_t v50 = v9 + (int)v111 * (uint64_t)v126 + v113;
        v115 = *(unsigned int **)(result + 40);
        if (v16 >= v50) {
          v116 = (unsigned int *)v50;
        }
        else {
          v116 = (unsigned int *)v16;
        }
        if (v116 >= v115) {
          v115 = v116;
        }
        float v53 = COERCE_FLOAT(bswap32(*v115));
      }
      else
      {
        float v53 = 1.0;
      }
      unsigned int v117 = bswap32(*v114);
      if (v8)
      {
        unsigned int v55 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v55 & 0xF) != 0)
        {
          float v54 = *(float *)&v117;
          unsigned int v28 = -1;
          uint64_t v13 = v104;
          goto LABEL_63;
        }
      }
      --a4;
      *((_DWORD *)v100 - 1) = v117;
      float *v100 = v53;
      v100 += 2;
      uint64_t v118 = v13 + v99++;
      a2 += v5;
      *(unsigned char *)(v118 + 2) = -1;
      v101 -= v5;
      a3 += v10;
      v102 -= v10;
      if (v103 == v99) {
        return result;
      }
    }
    v13 += v99 + 1;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_Wf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v125 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v124 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v124 = v5 % v6;
    }
  }
  else
  {
    uint64_t v124 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v10 = *(void *)(result + 32);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v11 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v12 = v11 % v7;
    if (v11 <= v7) {
      uint64_t v12 = *(void *)(result + 120);
    }
    uint64_t v123 = v12;
  }
  else
  {
    uint64_t v123 = 0;
  }
  uint64_t v119 = *(void *)(result + 80);
  uint64_t v120 = *(void *)(result + 64);
  uint64_t v121 = *(void *)(result + 88);
  uint64_t v13 = *(void *)(result + 152) - 8;
  uint64_t v14 = *(void *)(result + 144) - 1;
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  unint64_t v17 = v9 + (v15 * v125) + 4 * (v16 - 1);
  int v118 = *(_DWORD *)(result + 188);
  unint64_t v18 = v10 + (v15 * v4) + 4 * v16 - 4;
  uint64_t v122 = *(void *)(result + 72);
  while (1)
  {
    if (a3 < v122)
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v122 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      if (v21 < 1) {
        goto LABEL_57;
      }
      if (v21 >= v19) {
        LODWORD(v22) = 0x3FFFFFFF;
      }
      else {
        unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      unsigned int v29 = v118 | v22;
      uint64_t v30 = v20 + 0x1000000;
      uint64_t v27 = a3 - (v20 + 0x1000000);
      uint64_t v28 = 512;
      goto LABEL_22;
    }
    if (a3 <= v121)
    {
      uint64_t v27 = 0;
      uint64_t v28 = ((unint64_t)a3 >> 22) & 0x3C0;
      unsigned int v29 = 0x3FFFFFFF;
      uint64_t v30 = a3;
LABEL_22:
      uint64_t v31 = v120;
      goto LABEL_25;
    }
    uint64_t v23 = *(void *)(result + 216);
    uint64_t v24 = *(void *)(result + 224) + v121;
    uint64_t v25 = v24 - a3 + (v23 >> 1);
    if (v25 < 1) {
      goto LABEL_57;
    }
    if (v25 >= v23) {
      LODWORD(v26) = 0x3FFFFFFF;
    }
    else {
      unint64_t v26 = (unint64_t)(*(void *)(result + 232) * v25) >> 32;
    }
    uint64_t v31 = v120;
    unsigned int v29 = v118 | v26;
    uint64_t v30 = v24 - 0x1000000;
    uint64_t v27 = a3 - (v24 - 0x1000000);
    uint64_t v28 = 448;
LABEL_25:
    if (a2 >= v31) {
      break;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = v31 - *(void *)(result + 200);
    uint64_t v34 = a2 - v33 + (v32 >> 1);
    if (v34 >= 1)
    {
      if (v34 < v32) {
        unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v118;
      }
      uint64_t v35 = v33 + 0x1000000;
      uint64_t v36 = a2 - (v33 + 0x1000000);
      uint64_t v37 = 32;
      goto LABEL_36;
    }
LABEL_57:
    int v54 = a4 - 1;
    a2 += v5;
    a3 += v11;
    v13 += 8;
    *(unsigned char *)++uint64_t v14 = 0;
LABEL_58:
    a4 = v54;
    if (!v54) {
      return result;
    }
  }
  if (a2 <= v119)
  {
    uint64_t v36 = 0;
    uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v35 = a2;
    goto LABEL_36;
  }
  uint64_t v38 = *(void *)(result + 192);
  uint64_t v39 = *(void *)(result + 200) + v119;
  uint64_t v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1) {
    goto LABEL_57;
  }
  if (v40 < v38) {
    unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v118;
  }
  uint64_t v35 = v39 - 0x1000000;
  uint64_t v36 = a2 - (v39 - 0x1000000);
  uint64_t v37 = 28;
LABEL_36:
  if (v29 < 0x400000) {
    goto LABEL_57;
  }
  if (v6)
  {
    uint64_t v41 = (v7 & ((v30 % v7) >> 63)) + v30 % v7;
    uint64_t v42 = (v6 & ((v35 % v6) >> 63)) + v35 % v6;
    if (v41 >= v7) {
      uint64_t v43 = v7;
    }
    else {
      uint64_t v43 = 0;
    }
    uint64_t v30 = v41 - v43;
    if (v42 >= v6) {
      uint64_t v44 = v6;
    }
    else {
      uint64_t v44 = 0;
    }
    uint64_t v35 = v42 - v44;
    v27 += v30;
    v36 += v35;
  }
  uint64_t v45 = v30 >> 32;
  unint64_t v46 = (v35 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v47 = (float *)(v10 + SHIDWORD(v30) * (uint64_t)v4 + v46);
  unsigned int v48 = *(float **)(result + 32);
  if (v18 >= (unint64_t)v47) {
    int v49 = v47;
  }
  else {
    int v49 = (float *)v18;
  }
  if (v49 < v48) {
    int v49 = *(float **)(result + 32);
  }
  if (v9)
  {
    unint64_t v50 = v9 + (int)v45 * (uint64_t)v125 + v46;
    v51 = *(float **)(result + 40);
    if (v17 >= v50) {
      unsigned int v52 = (float *)v50;
    }
    else {
      unsigned int v52 = (float *)v17;
    }
    if (v52 >= v51) {
      v51 = v52;
    }
    float v53 = *v51;
  }
  else
  {
    unint64_t v50 = 0;
    float v53 = 1.0;
  }
  float v55 = *v49;
  if (v8)
  {
    unsigned int v56 = *(_DWORD *)(v8 + (v37 | v28));
LABEL_64:
    int v57 = v56 & 0xF;
    uint64_t v58 = v56 >> 8;
    int v59 = HIBYTE(v56) & 3;
    if (v57 == 1)
    {
      LODWORD(v84) = SBYTE1(v56);
      if (v6)
      {
        uint64_t v85 = v27 + ((uint64_t)SBYTE1(v56) << 32);
        uint64_t v86 = v7 & (v85 >> 63);
        if (v86 + v85 >= v7) {
          uint64_t v87 = v7;
        }
        else {
          uint64_t v87 = 0;
        }
        uint64_t v84 = (v86 + ((uint64_t)(char)v58 << 32) - v87) >> 32;
      }
      float v88 = (float *)((char *)v47 + (int)v84 * (uint64_t)v4);
      if (v18 < (unint64_t)v88) {
        float v88 = (float *)v18;
      }
      if (v88 < v48) {
        float v88 = v48;
      }
      float v89 = *v88;
      float v90 = 1.0;
      if (v9)
      {
        uint64_t v91 = (float *)(v50 + (int)v84 * (uint64_t)v125);
        if (v17 < (unint64_t)v91) {
          uint64_t v91 = (float *)v17;
        }
        if ((unint64_t)v91 < *(void *)(result + 40)) {
          uint64_t v91 = *(float **)(result + 40);
        }
        float v90 = *v91;
      }
      uint64_t v92 = &interpolate_waf[2 * v59];
    }
    else
    {
      if (v57 != 2)
      {
        if (v57 == 3)
        {
          LODWORD(v60) = SBYTE1(v56);
          uint64_t v61 = SBYTE2(v56);
          if (v6)
          {
            uint64_t v62 = v58 << 56;
            uint64_t v63 = v27 + ((uint64_t)SBYTE1(v56) << 32);
            uint64_t v64 = v36 + ((uint64_t)SBYTE2(v56) << 32);
            uint64_t v65 = v7 & (v63 >> 63);
            uint64_t v66 = v6 & (v64 >> 63);
            uint64_t v67 = v66 + v64;
            if (v65 + v63 >= v7) {
              uint64_t v68 = v7;
            }
            else {
              uint64_t v68 = 0;
            }
            if (v67 >= v6) {
              uint64_t v69 = v6;
            }
            else {
              uint64_t v69 = 0;
            }
            uint64_t v60 = (v65 + (v62 >> 24) - v68) >> 32;
            uint64_t v70 = v66 + ((uint64_t)((unint64_t)HIWORD(v56) << 56) >> 24) - v69;
            int v59 = HIBYTE(v56) & 3;
            uint64_t v61 = v70 >> 32;
          }
          unint64_t v71 = (unint64_t)&v47[v61];
          if (v18 >= v71) {
            float v72 = &v47[v61];
          }
          else {
            float v72 = (float *)v18;
          }
          if (v72 < v48) {
            float v72 = v48;
          }
          float v73 = *v72;
          float v74 = (float *)(v71 + (int)v60 * (uint64_t)v4);
          if (v18 < (unint64_t)v74) {
            float v74 = (float *)v18;
          }
          if (v74 < v48) {
            float v74 = v48;
          }
          float v75 = *v74;
          float v76 = 1.0;
          float v77 = 1.0;
          if (v9)
          {
            unint64_t v78 = (float *)(v50 + 4 * v61);
            unint64_t v79 = *(void *)(result + 40);
            if (v17 >= (unint64_t)v78) {
              v80 = v78;
            }
            else {
              v80 = (float *)v17;
            }
            if ((unint64_t)v80 < v79) {
              v80 = *(float **)(result + 40);
            }
            float v76 = *v80;
            float v81 = (float *)((char *)v78 + (int)v60 * (uint64_t)v125);
            if (v17 < (unint64_t)v81) {
              float v81 = (float *)v17;
            }
            if ((unint64_t)v81 < v79) {
              float v81 = *(float **)(result + 40);
            }
            float v77 = *v81;
          }
          float v82 = interpolate_waf[2 * v59 + 1];
          float v83 = interpolate_waf[2 * ((v56 >> 28) & 3) + 1];
          float v55 = (float)((float)((float)(v55 - (float)(v55 * v82)) + (float)(v73 * v82))
                      - (float)((float)((float)(v55 - (float)(v55 * v82)) + (float)(v73 * v82)) * v83))
              + (float)((float)((float)(v73 - (float)(v73 * v82)) + (float)(v75 * v82)) * v83);
          float v53 = (float)((float)((float)(v53 - (float)(v53 * v82)) + (float)(v76 * v82))
                      - (float)((float)((float)(v53 - (float)(v53 * v82)) + (float)(v76 * v82)) * v83))
              + (float)((float)((float)(v76 - (float)(v76 * v82)) + (float)(v77 * v82)) * v83);
        }
        goto LABEL_129;
      }
      uint64_t v93 = SBYTE2(v56);
      if (v6)
      {
        int64_t v94 = (unint64_t)HIWORD(v56) << 56;
        uint64_t v95 = v36 + (v94 >> 24);
        uint64_t v96 = v6 & (v95 >> 63);
        if (v96 + v95 >= v6) {
          uint64_t v97 = v6;
        }
        else {
          uint64_t v97 = 0;
        }
        uint64_t v93 = (v96 + (v94 >> 24) - v97) >> 32;
      }
      float v98 = &v47[v93];
      if (v18 < (unint64_t)v98) {
        float v98 = (float *)v18;
      }
      if (v98 < v48) {
        float v98 = v48;
      }
      float v89 = *v98;
      float v90 = 1.0;
      if (v9)
      {
        uint64_t v99 = (float *)(v50 + 4 * v93);
        if (v17 < (unint64_t)v99) {
          uint64_t v99 = (float *)v17;
        }
        if ((unint64_t)v99 < *(void *)(result + 40)) {
          uint64_t v99 = *(float **)(result + 40);
        }
        float v90 = *v99;
      }
      uint64_t v92 = &interpolate_waf[2 * ((v56 >> 28) & 3)];
    }
    float v100 = v92[1];
    float v55 = (float)(v55 - (float)(v55 * v100)) + (float)(v89 * v100);
    float v53 = (float)(v53 - (float)(v53 * v100)) + (float)(v90 * v100);
  }
LABEL_129:
  *(float *)(v13 + 8) = v55;
  *(float *)(v13 + 12) = v53;
  *(unsigned char *)(v14 + 1) = v29 >> 22;
  if (a4 != 1)
  {
    uint64_t v101 = 0;
    uint64_t v102 = (float *)(v13 + 20);
    a2 += v5;
    uint64_t v103 = v119 - a2;
    a3 += v11;
    uint64_t v104 = v121 - a3;
    while (((v104 | v103 | (a3 - v122) | (a2 - v120)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v105 = (v7 & ((v27 + v123) >> 63)) + v27 + v123;
        uint64_t v106 = (v6 & ((v36 + v124) >> 63)) + v36 + v124;
        if (v105 >= v7) {
          uint64_t v107 = v7;
        }
        else {
          uint64_t v107 = 0;
        }
        uint64_t v27 = v105 - v107;
        if (v106 >= v6) {
          uint64_t v108 = v6;
        }
        else {
          uint64_t v108 = 0;
        }
        uint64_t v36 = v106 - v108;
        uint64_t v109 = v27;
        uint64_t v110 = v36;
      }
      else
      {
        uint64_t v109 = a3;
        uint64_t v110 = a2;
      }
      uint64_t v111 = v109 >> 32;
      uint64_t v112 = v10 + (int)v111 * (uint64_t)v4;
      unint64_t v113 = (v110 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v47 = (float *)(v112 + v113);
      unsigned int v48 = *(float **)(result + 32);
      if (v18 >= v112 + v113) {
        v114 = (float *)(v112 + v113);
      }
      else {
        v114 = (float *)v18;
      }
      if (v114 < v48) {
        v114 = *(float **)(result + 32);
      }
      if (v9)
      {
        unint64_t v50 = v9 + (int)v111 * (uint64_t)v125 + v113;
        v115 = *(float **)(result + 40);
        if (v17 >= v50) {
          v116 = (float *)v50;
        }
        else {
          v116 = (float *)v17;
        }
        if (v116 >= v115) {
          v115 = v116;
        }
        float v53 = *v115;
      }
      else
      {
        float v53 = 1.0;
      }
      float v55 = *v114;
      if (v8)
      {
        unsigned int v56 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v56 & 0xF) != 0)
        {
          v14 += v101 + 1;
          uint64_t v13 = (uint64_t)(v102 - 3);
          a4 += ~v101;
          unsigned int v29 = -1;
          goto LABEL_64;
        }
      }
      *(v102 - 1) = v55;
      *uint64_t v102 = v53;
      uint64_t v117 = v14 + v101++;
      v102 += 2;
      a2 += v5;
      *(unsigned char *)(v117 + 2) = -1;
      v103 -= v5;
      a3 += v11;
      v104 -= v11;
      if (a4 - 1 == v101) {
        return result;
      }
    }
    v14 += v101 + 1;
    uint64_t v13 = (uint64_t)(v102 - 3);
    int v54 = ~v101 + a4;
    goto LABEL_58;
  }
  return result;
}

uint64_t Wf_sample_RGBF(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 32);
  int v15 = *(_DWORD *)(result + 24);
  uint64_t v16 = *(void *)(result + 176);
  uint64_t v17 = *(void *)(result + 64);
  uint64_t v18 = *(void *)(result + 72);
  uint64_t v19 = *(void *)(result + 80);
  uint64_t v20 = *(void *)(result + 88);
  uint64_t v21 = *(void *)(result + 112);
  uint64_t v22 = *(void *)(result + 120);
  int v72 = *(_DWORD *)(result + 188);
  uint64_t v23 = *(void *)(result + 152) - 8;
  uint64_t v24 = *(void *)(result + 144) - 1;
  unint64_t v25 = v14
      + ((*(_DWORD *)(result + 260) - 1) * v15)
      + 4 * (3 * *(_DWORD *)(result + 256))
      - 12;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v18)
      {
        if ((uint64_t)a3 <= v20)
        {
          uint64_t v34 = (a3 >> 22) & 0x3C0;
          unsigned int v35 = 0x3FFFFFFF;
          HIDWORD(v36) = HIDWORD(a3);
        }
        else
        {
          uint64_t v30 = *(void *)(result + 216);
          uint64_t v31 = *(void *)(result + 224) + v20;
          uint64_t v32 = v31 - a3 + (v30 >> 1);
          if (v32 < 1) {
            goto LABEL_34;
          }
          if (v32 >= v30) {
            LODWORD(v33) = 0x3FFFFFFF;
          }
          else {
            unint64_t v33 = (unint64_t)(*(void *)(result + 232) * v32) >> 32;
          }
          unsigned int v35 = v33 | v72;
          uint64_t v36 = v31 - 0x1000000;
          uint64_t v34 = 448;
        }
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = v18 - *(void *)(result + 224);
        uint64_t v28 = a3 - v27 + (v26 >> 1);
        if (v28 < 1) {
          goto LABEL_34;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        unsigned int v35 = v29 | v72;
        uint64_t v36 = v27 + 0x1000000;
        uint64_t v34 = 512;
      }
      if (a2 >= v17) {
        break;
      }
      uint64_t v37 = *(void *)(result + 192);
      uint64_t v38 = v17 - *(void *)(result + 200);
      uint64_t v39 = a2 - v38 + (v37 >> 1);
      if (v39 >= 1)
      {
        if (v39 < v37) {
          unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v72;
        }
        uint64_t v40 = v38 + 0x1000000;
        uint64_t v41 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v21;
      a3 += v22;
      v23 += 8;
      *(unsigned char *)++uint64_t v24 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v19)
    {
      uint64_t v41 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v40 = a2;
      goto LABEL_26;
    }
    uint64_t v42 = *(void *)(result + 192);
    uint64_t v43 = *(void *)(result + 200) + v19;
    uint64_t v44 = v43 - a2 + (v42 >> 1);
    if (v44 < 1) {
      goto LABEL_34;
    }
    if (v44 < v42) {
      unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v44) >> 32) >> 15)) | v72;
    }
    uint64_t v40 = v43 - 0x1000000;
    uint64_t v41 = 28;
LABEL_26:
    if (v35 < 0x400000) {
      goto LABEL_34;
    }
    uint64_t v45 = v40 >> 32;
    uint64_t v46 = v14 + SHIDWORD(v36) * (uint64_t)v15;
    unint64_t v47 = v46 + 12 * (int)v45;
    unsigned int v48 = *(int8x8_t **)(result + 32);
    if (v25 >= v47) {
      int v49 = (int8x8_t *)(v46 + 12 * (int)v45);
    }
    else {
      int v49 = (int8x8_t *)v25;
    }
    if (v49 < v48) {
      int v49 = *(int8x8_t **)(result + 32);
    }
    float32x2_t v50 = (float32x2_t)vrev32_s8(*v49);
    float v51 = COERCE_FLOAT(bswap32(v49[1].u32[0]));
    if (v16)
    {
      unsigned int v52 = *(_DWORD *)(v16 + (v41 | v34));
LABEL_38:
      int v54 = v52 & 0xF;
      unsigned int v55 = HIBYTE(v52) & 3;
      switch(v54)
      {
        case 1:
          uint64_t v62 = (int8x8_t *)(v47 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v62) {
            uint64_t v62 = (int8x8_t *)v25;
          }
          if (v62 < v48) {
            uint64_t v62 = v48;
          }
          float v63 = COERCE_FLOAT(bswap32(v62[1].u32[0]));
          break;
        case 2:
          uint64_t v62 = (int8x8_t *)(v47 + 12 * SBYTE2(v52));
          if (v25 < (unint64_t)v62) {
            uint64_t v62 = (int8x8_t *)v25;
          }
          if (v62 < v48) {
            uint64_t v62 = v48;
          }
          float v63 = COERCE_FLOAT(bswap32(v62[1].u32[0]));
          unsigned int v55 = (v52 >> 28) & 3;
          break;
        case 3:
          unint64_t v56 = v47 + 12 * SBYTE2(v52);
          if (v25 >= v56) {
            int v57 = (int8x8_t *)(v47 + 12 * SBYTE2(v52));
          }
          else {
            int v57 = (int8x8_t *)v25;
          }
          if (v57 < v48) {
            int v57 = v48;
          }
          float v58 = COERCE_FLOAT(bswap32(v57[1].u32[0]));
          int v59 = (int8x8_t *)(v56 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v59) {
            int v59 = (int8x8_t *)v25;
          }
          if (v59 < v48) {
            int v59 = v48;
          }
          v12.i32[0] = interpolate_rgbaf_21353[4 * v55 + 3];
          v13.i32[0] = interpolate_rgbaf_21353[4 * ((v52 >> 28) & 3) + 3];
          float v51 = (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v58 * v12.f32[0]))
                      - (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v58 * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v58 - (float)(v58 * v12.f32[0]))
                              + (float)(COERCE_FLOAT(bswap32(v59[1].u32[0])) * v12.f32[0]))
                      * v13.f32[0]);
          float32x2_t v60 = (float32x2_t)vrev32_s8(*v57);
          float32x2_t v61 = vmla_n_f32(vmls_lane_f32(v50, v50, v12, 0), v60, v12.f32[0]);
          a12 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(v60, v60, v12, 0), (float32x2_t)vrev32_s8(*v59), v12.f32[0]));
          float32x2_t v50 = vmla_n_f32(vmls_lane_f32(v61, v61, v13, 0), *(float32x2_t *)&a12, v13.f32[0]);
          float v53 = (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0]))
                      - (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]))
              + (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      LODWORD(a12) = interpolate_rgbaf_21353[4 * v55 + 3];
      float32x2_t v12 = (float32x2_t)vrev32_s8(*v62);
      float32x2_t v50 = vmla_n_f32(vmls_lane_f32(v50, v50, *(float32x2_t *)&a12, 0), v12, *(float *)&a12);
      float v51 = (float)(v51 - (float)(v51 * *(float *)&a12)) + (float)(v63 * *(float *)&a12);
      float v53 = *(float *)&a12 + (float)(1.0 - *(float *)&a12);
      goto LABEL_62;
    }
LABEL_36:
    float v53 = 1.0;
LABEL_62:
    *(float *)(v23 + 8) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v51 * 0.11);
    *(float *)(v23 + 12) = v53;
    *(unsigned char *)(v24 + 1) = v35 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v64 = 0;
    uint64_t v65 = (float *)(v23 + 20);
    a2 += v21;
    uint64_t v66 = v19 - a2;
    a3 += v22;
    uint64_t v67 = v20 - a3;
    while ((((a2 - v17) | v66 | (a3 - v18) | v67) & 0x8000000000000000) == 0)
    {
      uint64_t v68 = v14 + SHIDWORD(a3) * (uint64_t)v15;
      unint64_t v47 = v68 + 12 * SHIDWORD(a2);
      unsigned int v48 = *(int8x8_t **)(result + 32);
      if (v25 >= v47) {
        uint64_t v69 = (int8x8_t *)(v68 + 12 * SHIDWORD(a2));
      }
      else {
        uint64_t v69 = (int8x8_t *)v25;
      }
      if (v69 < v48) {
        uint64_t v69 = *(int8x8_t **)(result + 32);
      }
      float32x2_t v50 = (float32x2_t)vrev32_s8(*v69);
      float v70 = COERCE_FLOAT(bswap32(v69[1].u32[0]));
      float v51 = v70;
      if (v16)
      {
        unsigned int v52 = *(_DWORD *)(v16 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v52 & 0xF) != 0)
        {
          v24 += v64 + 1;
          uint64_t v23 = (uint64_t)(v65 - 3);
          a4 += ~v64;
          unsigned int v35 = -1;
          goto LABEL_38;
        }
      }
      *(v65 - 1) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v70 * 0.11);
      *uint64_t v65 = 1.0;
      v65 += 2;
      uint64_t v71 = v24 + v64++;
      a2 += v21;
      *(unsigned char *)(v71 + 2) = -1;
      v66 -= v21;
      a3 += v22;
      v67 -= v22;
      if (a4 - 1 == v64) {
        return result;
      }
    }
    v24 += v64 + 1;
    uint64_t v23 = (uint64_t)(v65 - 3);
    a4 += ~v64;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_RGBf(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 32);
  int v15 = *(_DWORD *)(result + 24);
  uint64_t v16 = *(void *)(result + 176);
  uint64_t v17 = *(void *)(result + 64);
  uint64_t v18 = *(void *)(result + 72);
  uint64_t v19 = *(void *)(result + 80);
  uint64_t v20 = *(void *)(result + 88);
  uint64_t v21 = *(void *)(result + 112);
  uint64_t v22 = *(void *)(result + 120);
  int v69 = *(_DWORD *)(result + 188);
  uint64_t v23 = *(void *)(result + 152) - 8;
  uint64_t v24 = *(void *)(result + 144) - 1;
  unint64_t v25 = v14
      + ((*(_DWORD *)(result + 260) - 1) * v15)
      + 4 * (3 * *(_DWORD *)(result + 256))
      - 12;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v18)
      {
        if ((uint64_t)a3 <= v20)
        {
          uint64_t v34 = (a3 >> 22) & 0x3C0;
          unsigned int v35 = 0x3FFFFFFF;
          HIDWORD(v36) = HIDWORD(a3);
        }
        else
        {
          uint64_t v30 = *(void *)(result + 216);
          uint64_t v31 = *(void *)(result + 224) + v20;
          uint64_t v32 = v31 - a3 + (v30 >> 1);
          if (v32 < 1) {
            goto LABEL_34;
          }
          if (v32 >= v30) {
            LODWORD(v33) = 0x3FFFFFFF;
          }
          else {
            unint64_t v33 = (unint64_t)(*(void *)(result + 232) * v32) >> 32;
          }
          unsigned int v35 = v33 | v69;
          uint64_t v36 = v31 - 0x1000000;
          uint64_t v34 = 448;
        }
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = v18 - *(void *)(result + 224);
        uint64_t v28 = a3 - v27 + (v26 >> 1);
        if (v28 < 1) {
          goto LABEL_34;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        unsigned int v35 = v29 | v69;
        uint64_t v36 = v27 + 0x1000000;
        uint64_t v34 = 512;
      }
      if (a2 >= v17) {
        break;
      }
      uint64_t v37 = *(void *)(result + 192);
      uint64_t v38 = v17 - *(void *)(result + 200);
      uint64_t v39 = a2 - v38 + (v37 >> 1);
      if (v39 >= 1)
      {
        if (v39 < v37) {
          unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v69;
        }
        uint64_t v40 = v38 + 0x1000000;
        uint64_t v41 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v21;
      a3 += v22;
      v23 += 8;
      *(unsigned char *)++uint64_t v24 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v19)
    {
      uint64_t v41 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v40 = a2;
      goto LABEL_26;
    }
    uint64_t v42 = *(void *)(result + 192);
    uint64_t v43 = *(void *)(result + 200) + v19;
    uint64_t v44 = v43 - a2 + (v42 >> 1);
    if (v44 < 1) {
      goto LABEL_34;
    }
    if (v44 < v42) {
      unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v44) >> 32) >> 15)) | v69;
    }
    uint64_t v40 = v43 - 0x1000000;
    uint64_t v41 = 28;
LABEL_26:
    if (v35 < 0x400000) {
      goto LABEL_34;
    }
    uint64_t v45 = v40 >> 32;
    uint64_t v46 = v14 + SHIDWORD(v36) * (uint64_t)v15;
    unint64_t v47 = v46 + 12 * (int)v45;
    unsigned int v48 = *(float32x2_t **)(result + 32);
    if (v25 >= v47) {
      int v49 = (float32x2_t *)(v46 + 12 * (int)v45);
    }
    else {
      int v49 = (float32x2_t *)v25;
    }
    if (v49 < v48) {
      int v49 = *(float32x2_t **)(result + 32);
    }
    float32x2_t v50 = *v49;
    float v51 = v49[1].f32[0];
    if (v16)
    {
      unsigned int v52 = *(_DWORD *)(v16 + (v41 | v34));
LABEL_38:
      int v54 = v52 & 0xF;
      int v55 = HIBYTE(v52) & 3;
      switch(v54)
      {
        case 1:
          float32x2_t v60 = (float32x2_t *)(v47 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v60) {
            float32x2_t v60 = (float32x2_t *)v25;
          }
          if (v60 < v48) {
            float32x2_t v60 = v48;
          }
          float v61 = v60[1].f32[0];
          LODWORD(a12) = interpolate_rgbaf_21353[4 * v55 + 3];
          float32x2_t v12 = *v60;
          break;
        case 2:
          uint64_t v62 = (float32x2_t *)(v47 + 12 * SBYTE2(v52));
          if (v25 < (unint64_t)v62) {
            uint64_t v62 = (float32x2_t *)v25;
          }
          if (v62 < v48) {
            uint64_t v62 = v48;
          }
          float v61 = v62[1].f32[0];
          LODWORD(a12) = interpolate_rgbaf_21353[4 * ((v52 >> 28) & 3) + 3];
          float32x2_t v12 = *v62;
          break;
        case 3:
          unint64_t v56 = v47 + 12 * SBYTE2(v52);
          if (v25 >= v56) {
            int v57 = (float32x2_t *)(v47 + 12 * SBYTE2(v52));
          }
          else {
            int v57 = (float32x2_t *)v25;
          }
          if (v57 < v48) {
            int v57 = v48;
          }
          float v58 = (float32x2_t *)(v56 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v58) {
            float v58 = (float32x2_t *)v25;
          }
          if (v58 < v48) {
            float v58 = v48;
          }
          v12.i32[0] = interpolate_rgbaf_21353[4 * v55 + 3];
          v13.i32[0] = interpolate_rgbaf_21353[4 * ((v52 >> 28) & 3) + 3];
          float v51 = (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v57[1].f32[0] * v12.f32[0]))
                      - (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v57[1].f32[0] * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v57[1].f32[0] - (float)(v57[1].f32[0] * v12.f32[0]))
                              + (float)(v58[1].f32[0] * v12.f32[0]))
                      * v13.f32[0]);
          float32x2_t v59 = vmla_n_f32(vmls_lane_f32(v50, v50, v12, 0), *v57, v12.f32[0]);
          a12 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(*v57, *v57, v12, 0), *v58, v12.f32[0]));
          float32x2_t v50 = vmla_n_f32(vmls_lane_f32(v59, v59, v13, 0), *(float32x2_t *)&a12, v13.f32[0]);
          float v53 = (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0]))
                      - (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]))
              + (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      float32x2_t v50 = vmla_n_f32(vmls_lane_f32(v50, v50, *(float32x2_t *)&a12, 0), v12, *(float *)&a12);
      float v51 = (float)(v51 - (float)(v51 * *(float *)&a12)) + (float)(v61 * *(float *)&a12);
      float v53 = *(float *)&a12 + (float)(1.0 - *(float *)&a12);
      goto LABEL_62;
    }
LABEL_36:
    float v53 = 1.0;
LABEL_62:
    *(float *)(v23 + 8) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v51 * 0.11);
    *(float *)(v23 + 12) = v53;
    *(unsigned char *)(v24 + 1) = v35 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v63 = 0;
    uint64_t v64 = (float *)(v23 + 20);
    a2 += v21;
    uint64_t v65 = v19 - a2;
    a3 += v22;
    uint64_t v66 = v20 - a3;
    while ((((a2 - v17) | v65 | (a3 - v18) | v66) & 0x8000000000000000) == 0)
    {
      unint64_t v47 = v14 + SHIDWORD(a3) * (uint64_t)v15 + 12 * SHIDWORD(a2);
      unsigned int v48 = *(float32x2_t **)(result + 32);
      if (v25 >= v47) {
        unint64_t v67 = v14 + SHIDWORD(a3) * (uint64_t)v15 + 12 * SHIDWORD(a2);
      }
      else {
        unint64_t v67 = v25;
      }
      if (v67 < (unint64_t)v48) {
        unint64_t v67 = *(void *)(result + 32);
      }
      float32x2_t v50 = *(float32x2_t *)v67;
      float v51 = *(float *)(v67 + 8);
      if (v16)
      {
        unsigned int v52 = *(_DWORD *)(v16 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v52 & 0xF) != 0)
        {
          v24 += v63 + 1;
          uint64_t v23 = (uint64_t)(v64 - 3);
          a4 += ~v63;
          unsigned int v35 = -1;
          goto LABEL_38;
        }
      }
      *(v64 - 1) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v51 * 0.11);
      *uint64_t v64 = 1.0;
      v64 += 2;
      uint64_t v68 = v24 + v63++;
      a2 += v21;
      *(unsigned char *)(v68 + 2) = -1;
      v65 -= v21;
      a3 += v22;
      v66 -= v22;
      if (a4 - 1 == v63) {
        return result;
      }
    }
    v24 += v63 + 1;
    uint64_t v23 = (uint64_t)(v64 - 3);
    a4 += ~v63;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_RGBAF(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v7 = *(_DWORD *)(result + 24);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 64);
  uint64_t v10 = *(void *)(result + 72);
  uint64_t v11 = *(void *)(result + 80);
  uint64_t v12 = *(void *)(result + 88);
  uint64_t v13 = *(void *)(result + 112);
  uint64_t v14 = *(void *)(result + 120);
  int v79 = *(_DWORD *)(result + 188);
  uint64_t v15 = *(void *)(result + 152) - 8;
  uint64_t v16 = *(void *)(result + 144) - 1;
  uint64_t v18 = *(void *)(result + 32);
  uint64_t v17 = *(void *)(result + 40);
  unint64_t v19 = v18
      + ((*(_DWORD *)(result + 260) - 1) * v7)
      + 4 * (4 * *(_DWORD *)(result + 256))
      - 16;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v10)
      {
        if ((uint64_t)a3 <= v12)
        {
          uint64_t v28 = (a3 >> 22) & 0x3C0;
          unsigned int v29 = 0x3FFFFFFF;
          HIDWORD(v30) = HIDWORD(a3);
        }
        else
        {
          uint64_t v24 = *(void *)(result + 216);
          uint64_t v25 = *(void *)(result + 224) + v12;
          uint64_t v26 = v25 - a3 + (v24 >> 1);
          if (v26 < 1) {
            goto LABEL_35;
          }
          if (v26 >= v24) {
            LODWORD(v27) = 0x3FFFFFFF;
          }
          else {
            unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
          }
          unsigned int v29 = v27 | v79;
          uint64_t v30 = v25 - 0x1000000;
          uint64_t v28 = 448;
        }
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = v10 - *(void *)(result + 224);
        uint64_t v22 = a3 - v21 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_35;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        unsigned int v29 = v23 | v79;
        uint64_t v30 = v21 + 0x1000000;
        uint64_t v28 = 512;
      }
      if (a2 >= v9) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v9 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v79;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = 32;
        goto LABEL_26;
      }
LABEL_35:
      --a4;
      a2 += v13;
      a3 += v14;
      v15 += 8;
      *(unsigned char *)++uint64_t v16 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v11)
    {
      uint64_t v35 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_26;
    }
    uint64_t v36 = *(void *)(result + 192);
    uint64_t v37 = *(void *)(result + 200) + v11;
    uint64_t v38 = v37 - a2 + (v36 >> 1);
    if (v38 < 1) {
      goto LABEL_35;
    }
    if (v38 < v36) {
      unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v38) >> 32) >> 15)) | v79;
    }
    uint64_t v34 = v37 - 0x1000000;
    uint64_t v35 = 28;
LABEL_26:
    if (v29 < 0x400000) {
      goto LABEL_35;
    }
    uint64_t v39 = v18 + SHIDWORD(v30) * (uint64_t)v7;
    uint64_t v40 = v34 >> 32;
    unint64_t v41 = v39 + 16 * v40;
    uint64_t v42 = *(int8x8_t **)(result + 32);
    if (v19 >= v41) {
      uint64_t v43 = (int8x8_t *)(v39 + 16 * v40);
    }
    else {
      uint64_t v43 = (int8x8_t *)v19;
    }
    if (v43 >= v42) {
      uint64_t v44 = v43;
    }
    else {
      uint64_t v44 = *(int8x8_t **)(result + 32);
    }
    if (v17) {
      float v45 = COERCE_FLOAT(bswap32(v44[1].u32[1]));
    }
    else {
      float v45 = 1.0;
    }
    float32x2_t v46 = (float32x2_t)vrev32_s8(*v44);
    float v47 = COERCE_FLOAT(bswap32(v44[1].u32[0]));
    if (v8)
    {
      unsigned int v48 = *(_DWORD *)(v8 + (v35 | v28));
LABEL_41:
      int v49 = v48 & 0xF;
      int v50 = HIBYTE(v48) & 3;
      if (v49 == 1)
      {
        uint64_t v62 = (int8x8_t *)(v41 + SBYTE1(v48) * (uint64_t)v7);
        if (v19 < (unint64_t)v62) {
          uint64_t v62 = (int8x8_t *)v19;
        }
        if (v62 >= v42) {
          uint64_t v63 = v62;
        }
        else {
          uint64_t v63 = v42;
        }
        float32x2_t v64 = (float32x2_t)vrev32_s8(*v63);
        float v65 = COERCE_FLOAT(bswap32(v63[1].u32[0]));
        float v66 = 1.0;
        if (v17) {
          float v66 = COERCE_FLOAT(bswap32(v63[1].u32[1]));
        }
        unint64_t v67 = &interpolate_rgbaf_21353[4 * v50];
      }
      else
      {
        if (v49 != 2)
        {
          if (v49 == 3)
          {
            float v51 = (int8x8_t *)(v41 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52));
            if (v19 < (unint64_t)v51) {
              float v51 = (int8x8_t *)v19;
            }
            if (v51 >= v42) {
              unsigned int v52 = v51;
            }
            else {
              unsigned int v52 = v42;
            }
            float32x2_t v53 = (float32x2_t)vrev32_s8(*v52);
            float v54 = COERCE_FLOAT(bswap32(v52[1].u32[0]));
            float v55 = 1.0;
            float v56 = 1.0;
            if (v17) {
              float v56 = COERCE_FLOAT(bswap32(v52[1].u32[1]));
            }
            unint64_t v57 = v41 + SBYTE1(v48) * (uint64_t)v7 + 16 * SBYTE2(v48);
            if (v19 < v57) {
              unint64_t v57 = v19;
            }
            if (v57 >= (unint64_t)v42) {
              float v58 = (int8x8_t *)v57;
            }
            else {
              float v58 = v42;
            }
            float32x2_t v59 = (float32x2_t)vrev32_s8(*v58);
            float v60 = COERCE_FLOAT(bswap32(v58[1].u32[0]));
            if (v17) {
              float v55 = COERCE_FLOAT(bswap32(v58[1].u32[1]));
            }
            v5.i32[0] = interpolate_rgbaf_21353[4 * v50 + 3];
            v6.i32[0] = interpolate_rgbaf_21353[4 * ((v48 >> 28) & 3) + 3];
            float v47 = (float)((float)((float)(v47 - (float)(v47 * v5.f32[0])) + (float)(v54 * v5.f32[0]))
                        - (float)((float)((float)(v47 - (float)(v47 * v5.f32[0])) + (float)(v54 * v5.f32[0])) * v6.f32[0]))
                + (float)((float)((float)(v54 - (float)(v54 * v5.f32[0])) + (float)(v60 * v5.f32[0])) * v6.f32[0]);
            float32x2_t v61 = vmla_n_f32(vmls_lane_f32(v46, v46, v5, 0), v53, v5.f32[0]);
            float32x2_t v46 = vmla_n_f32(vmls_lane_f32(v61, v61, v6, 0), vmla_n_f32(vmls_lane_f32(v53, v53, v5, 0), v59, v5.f32[0]), v6.f32[0]);
            float v45 = (float)((float)((float)(v45 - (float)(v45 * v5.f32[0])) + (float)(v56 * v5.f32[0]))
                        - (float)((float)((float)(v45 - (float)(v45 * v5.f32[0])) + (float)(v56 * v5.f32[0])) * v6.f32[0]))
                + (float)((float)((float)(v56 - (float)(v56 * v5.f32[0])) + (float)(v55 * v5.f32[0])) * v6.f32[0]);
          }
          goto LABEL_76;
        }
        uint64_t v68 = (int8x8_t *)(v41 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52));
        if (v19 < (unint64_t)v68) {
          uint64_t v68 = (int8x8_t *)v19;
        }
        if (v68 >= v42) {
          int v69 = v68;
        }
        else {
          int v69 = v42;
        }
        float32x2_t v64 = (float32x2_t)vrev32_s8(*v69);
        float v65 = COERCE_FLOAT(bswap32(v69[1].u32[0]));
        float v66 = 1.0;
        if (v17) {
          float v66 = COERCE_FLOAT(bswap32(v69[1].u32[1]));
        }
        unint64_t v67 = &interpolate_rgbaf_21353[4 * ((v48 >> 28) & 3)];
      }
      v4.i32[0] = v67[3];
      float32x2_t v46 = vmla_n_f32(vmls_lane_f32(v46, v46, v4, 0), v64, v4.f32[0]);
      float v47 = (float)(v47 - (float)(v47 * v4.f32[0])) + (float)(v65 * v4.f32[0]);
      float v45 = (float)(v45 - (float)(v45 * v4.f32[0])) + (float)(v66 * v4.f32[0]);
    }
LABEL_76:
    *(float *)(v15 + 8) = vmlas_n_f32(vmuls_lane_f32(0.59, v46, 1), 0.3, v46.f32[0]) + (float)(v47 * 0.11);
    *(float *)(v15 + 12) = v45;
    *(unsigned char *)(v16 + 1) = v29 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v70 = 0;
    uint64_t v71 = (float *)(v15 + 20);
    a2 += v13;
    uint64_t v72 = v11 - a2;
    a3 += v14;
    uint64_t v73 = v12 - a3;
    while ((((a2 - v9) | v72 | (a3 - v10) | v73) & 0x8000000000000000) == 0)
    {
      uint64_t v74 = v18 + SHIDWORD(a3) * (uint64_t)v7;
      unint64_t v41 = v74 + 16 * (a2 >> 32);
      uint64_t v42 = *(int8x8_t **)(result + 32);
      if (v19 >= v41) {
        float v75 = (int8x8_t *)(v74 + 16 * (a2 >> 32));
      }
      else {
        float v75 = (int8x8_t *)v19;
      }
      if (v75 >= v42) {
        float v76 = v75;
      }
      else {
        float v76 = *(int8x8_t **)(result + 32);
      }
      if (v17) {
        float v45 = COERCE_FLOAT(bswap32(v76[1].u32[1]));
      }
      else {
        float v45 = 1.0;
      }
      float32x2_t v46 = (float32x2_t)vrev32_s8(*v76);
      float v77 = COERCE_FLOAT(bswap32(v76[1].u32[0]));
      float v47 = v77;
      if (v8)
      {
        unsigned int v48 = *(_DWORD *)(v8 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v48 & 0xF) != 0)
        {
          v16 += v70 + 1;
          uint64_t v15 = (uint64_t)(v71 - 3);
          a4 += ~v70;
          unsigned int v29 = -1;
          goto LABEL_41;
        }
      }
      *(v71 - 1) = vmlas_n_f32(vmuls_lane_f32(0.59, v46, 1), 0.3, v46.f32[0]) + (float)(v77 * 0.11);
      float *v71 = v45;
      uint64_t v78 = v16 + v70++;
      v71 += 2;
      a2 += v13;
      *(unsigned char *)(v78 + 2) = -1;
      v72 -= v13;
      a3 += v14;
      v73 -= v14;
      if (a4 - 1 == v70) {
        return result;
      }
    }
    v16 += v70 + 1;
    uint64_t v15 = (uint64_t)(v71 - 3);
    a4 += ~v70;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_RGBAf(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v7 = *(_DWORD *)(result + 24);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 64);
  uint64_t v10 = *(void *)(result + 72);
  uint64_t v11 = *(void *)(result + 80);
  uint64_t v12 = *(void *)(result + 88);
  uint64_t v13 = *(void *)(result + 112);
  uint64_t v14 = *(void *)(result + 120);
  int v83 = *(_DWORD *)(result + 188);
  uint64_t v15 = *(void *)(result + 152) - 8;
  uint64_t v16 = *(void *)(result + 144) - 1;
  uint64_t v18 = *(void *)(result + 32);
  uint64_t v17 = *(void *)(result + 40);
  unint64_t v19 = v18
      + ((*(_DWORD *)(result + 260) - 1) * v7)
      + 4 * (4 * *(_DWORD *)(result + 256))
      - 16;
  _S2 = 1038174126;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v10)
      {
        if ((uint64_t)a3 <= v12)
        {
          uint64_t v29 = (a3 >> 22) & 0x3C0;
          unsigned int v30 = 0x3FFFFFFF;
          HIDWORD(v31) = HIDWORD(a3);
        }
        else
        {
          uint64_t v25 = *(void *)(result + 216);
          uint64_t v26 = *(void *)(result + 224) + v12;
          uint64_t v27 = v26 - a3 + (v25 >> 1);
          if (v27 < 1) {
            goto LABEL_35;
          }
          if (v27 >= v25) {
            LODWORD(v28) = 0x3FFFFFFF;
          }
          else {
            unint64_t v28 = (unint64_t)(*(void *)(result + 232) * v27) >> 32;
          }
          unsigned int v30 = v28 | v83;
          uint64_t v31 = v26 - 0x1000000;
          uint64_t v29 = 448;
        }
      }
      else
      {
        uint64_t v21 = *(void *)(result + 216);
        uint64_t v22 = v10 - *(void *)(result + 224);
        uint64_t v23 = a3 - v22 + (v21 >> 1);
        if (v23 < 1) {
          goto LABEL_35;
        }
        if (v23 >= v21) {
          LODWORD(v24) = 0x3FFFFFFF;
        }
        else {
          unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
        }
        unsigned int v30 = v24 | v83;
        uint64_t v31 = v22 + 0x1000000;
        uint64_t v29 = 512;
      }
      if (a2 >= v9) {
        break;
      }
      uint64_t v32 = *(void *)(result + 192);
      uint64_t v33 = v9 - *(void *)(result + 200);
      uint64_t v34 = a2 - v33 + (v32 >> 1);
      if (v34 >= 1)
      {
        if (v34 < v32) {
          unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v83;
        }
        uint64_t v35 = v33 + 0x1000000;
        uint64_t v36 = 32;
        goto LABEL_26;
      }
LABEL_35:
      --a4;
      a2 += v13;
      a3 += v14;
      v15 += 8;
      *(unsigned char *)++uint64_t v16 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v11)
    {
      uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v35 = a2;
      goto LABEL_26;
    }
    uint64_t v37 = *(void *)(result + 192);
    uint64_t v38 = *(void *)(result + 200) + v11;
    uint64_t v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1) {
      goto LABEL_35;
    }
    if (v39 < v37) {
      unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v83;
    }
    uint64_t v35 = v38 - 0x1000000;
    uint64_t v36 = 28;
LABEL_26:
    if (v30 < 0x400000) {
      goto LABEL_35;
    }
    uint64_t v40 = v18 + SHIDWORD(v31) * (uint64_t)v7;
    uint64_t v41 = v35 >> 32;
    unint64_t v42 = v40 + 16 * v41;
    unint64_t v43 = *(void *)(result + 32);
    if (v19 >= v42) {
      unint64_t v44 = v40 + 16 * v41;
    }
    else {
      unint64_t v44 = v19;
    }
    if (v44 >= v43) {
      unint64_t v45 = v44;
    }
    else {
      unint64_t v45 = *(void *)(result + 32);
    }
    if (v17) {
      float v46 = *(float *)(v45 + 12);
    }
    else {
      float v46 = 1.0;
    }
    _D3 = *(float32x2_t *)(v45 + 4);
    if (v8)
    {
      unsigned int v48 = *(_DWORD *)(v8 + (v36 | v29));
LABEL_41:
      int v49 = v48 & 0xF;
      int v50 = HIBYTE(v48) & 3;
      if (v49 == 1)
      {
        unint64_t v60 = v42 + SBYTE1(v48) * (uint64_t)v7;
        if (v19 < v60) {
          unint64_t v60 = v19;
        }
        if (v60 >= v43) {
          unint64_t v61 = v60;
        }
        else {
          unint64_t v61 = v43;
        }
        float32x2_t v62 = *(float32x2_t *)(v61 + 4);
        float v63 = 1.0;
        if (v17) {
          float v63 = *(float *)(v61 + 12);
        }
        float32x2_t v64 = &interpolate_rgbaf_21353[4 * v50];
      }
      else
      {
        if (v49 != 2)
        {
          if (v49 == 3)
          {
            uint64_t v51 = SBYTE1(v48) * (uint64_t)v7;
            uint64_t v52 = 16 * SBYTE2(v48);
            unint64_t v53 = v42 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52);
            if (v19 < v53) {
              unint64_t v53 = v19;
            }
            if (v53 >= v43) {
              unint64_t v54 = v53;
            }
            else {
              unint64_t v54 = v43;
            }
            float32x2_t v55 = *(float32x2_t *)(v54 + 4);
            if (v17)
            {
              float v56 = *(float *)(v54 + 12);
              unint64_t v57 = v42 + v51 + v52;
              if (v19 < v57) {
                unint64_t v57 = v19;
              }
              if (v57 >= v43) {
                unint64_t v58 = v57;
              }
              else {
                unint64_t v58 = v43;
              }
              float v59 = *(float *)(v58 + 12);
            }
            else
            {
              unint64_t v67 = v42 + v51 + v52;
              if (v19 < v67) {
                unint64_t v67 = v19;
              }
              if (v67 >= v43) {
                unint64_t v58 = v67;
              }
              else {
                unint64_t v58 = v43;
              }
              float v56 = 1.0;
              float v59 = 1.0;
            }
            v5.i32[0] = interpolate_rgbaf_21353[4 * v50 + 3];
            v6.i32[0] = interpolate_rgbaf_21353[4 * ((v48 >> 28) & 3) + 3];
            float32x2_t v68 = vmla_n_f32(vmls_lane_f32(_D3, _D3, v5, 0), v55, v5.f32[0]);
            _D3 = vmla_n_f32(vmls_lane_f32(v68, v68, v6, 0), vmla_n_f32(vmls_lane_f32(v55, v55, v5, 0), *(float32x2_t *)(v58 + 4), v5.f32[0]), v6.f32[0]);
            float v46 = (float)((float)((float)(v46 - (float)(v46 * v5.f32[0])) + (float)(v56 * v5.f32[0]))
                        - (float)((float)((float)(v46 - (float)(v46 * v5.f32[0])) + (float)(v56 * v5.f32[0])) * v6.f32[0]))
                + (float)((float)((float)(v56 - (float)(v56 * v5.f32[0])) + (float)(v59 * v5.f32[0])) * v6.f32[0]);
          }
          goto LABEL_80;
        }
        unint64_t v65 = v42 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52);
        if (v19 < v65) {
          unint64_t v65 = v19;
        }
        if (v65 >= v43) {
          unint64_t v66 = v65;
        }
        else {
          unint64_t v66 = v43;
        }
        float32x2_t v62 = *(float32x2_t *)(v66 + 4);
        float v63 = 1.0;
        if (v17) {
          float v63 = *(float *)(v66 + 12);
        }
        float32x2_t v64 = &interpolate_rgbaf_21353[4 * ((v48 >> 28) & 3)];
      }
      v4.i32[0] = v64[3];
      _D3 = vmla_n_f32(vmls_lane_f32(_D3, _D3, v4, 0), v62, v4.f32[0]);
      float v46 = (float)(v46 - (float)(v46 * v4.f32[0])) + (float)(v63 * v4.f32[0]);
    }
LABEL_80:
    __asm { FMLA            S5, S2, V3.S[1] }
    *(_DWORD *)(v15 + 8) = _S5;
    *(float *)(v15 + 12) = v46;
    *(unsigned char *)(v16 + 1) = v30 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v74 = 0;
    float v75 = (float *)(v15 + 20);
    a2 += v13;
    uint64_t v76 = v11 - a2;
    a3 += v14;
    uint64_t v77 = v12 - a3;
    while ((((a2 - v9) | v76 | (a3 - v10) | v77) & 0x8000000000000000) == 0)
    {
      uint64_t v78 = v18 + SHIDWORD(a3) * (uint64_t)v7;
      unint64_t v42 = v78 + 16 * (a2 >> 32);
      unint64_t v43 = *(void *)(result + 32);
      if (v19 >= v42) {
        unint64_t v79 = v78 + 16 * (a2 >> 32);
      }
      else {
        unint64_t v79 = v19;
      }
      if (v79 >= v43) {
        unint64_t v80 = v79;
      }
      else {
        unint64_t v80 = *(void *)(result + 32);
      }
      if (v17) {
        float v46 = *(float *)(v80 + 12);
      }
      else {
        float v46 = 1.0;
      }
      _D3 = *(float32x2_t *)(v80 + 4);
      if (v8)
      {
        unsigned int v48 = *(_DWORD *)(v8 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v48 & 0xF) != 0)
        {
          v16 += v74 + 1;
          uint64_t v15 = (uint64_t)(v75 - 3);
          a4 += ~v74;
          unsigned int v30 = -1;
          goto LABEL_41;
        }
      }
      __asm { FMLA            S5, S2, V3.S[1] }
      *((_DWORD *)v75 - 1) = _S5;
      float *v75 = v46;
      uint64_t v82 = v16 + v74++;
      v75 += 2;
      a2 += v13;
      *(unsigned char *)(v82 + 2) = -1;
      v76 -= v13;
      a3 += v14;
      v77 -= v14;
      if (a4 - 1 == v74) {
        return result;
      }
    }
    v16 += v74 + 1;
    uint64_t v15 = (uint64_t)(v75 - 3);
    a4 += ~v74;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 32);
  uint64_t v15 = *(void *)(result + 40);
  int v16 = *(_DWORD *)(result + 24);
  int v17 = *(_DWORD *)(result + 28);
  uint64_t v18 = *(void *)(result + 176);
  uint64_t v19 = *(void *)(result + 72);
  uint64_t v92 = *(void *)(result + 80);
  uint64_t v93 = *(void *)(result + 88);
  uint64_t v21 = *(void *)(result + 112);
  uint64_t v20 = *(void *)(result + 120);
  int v90 = *(_DWORD *)(result + 188);
  uint64_t v22 = *(void *)(result + 152) - 8;
  uint64_t v23 = *(void *)(result + 144) - 1;
  int v24 = *(_DWORD *)(result + 260) - 1;
  int v25 = *(_DWORD *)(result + 256);
  unint64_t v26 = v15 + (v24 * v17) + 4 * (v25 - 1);
  unint64_t v27 = v14 + (v24 * v16) + 4 * (4 * v25) - 16;
  uint64_t v91 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v19)
    {
      if (a3 <= v93)
      {
        uint64_t v36 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v37 = 0x3FFFFFFF;
        uint64_t v38 = a3;
        uint64_t v39 = v91;
      }
      else
      {
        uint64_t v32 = *(void *)(result + 216);
        uint64_t v33 = *(void *)(result + 224) + v93;
        uint64_t v34 = v33 - a3 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_39;
        }
        if (v34 >= v32) {
          LODWORD(v35) = 0x3FFFFFFF;
        }
        else {
          unint64_t v35 = (unint64_t)(*(void *)(result + 232) * v34) >> 32;
        }
        uint64_t v39 = v91;
        unsigned int v37 = v35 | v90;
        uint64_t v38 = v33 - 0x1000000;
        uint64_t v36 = 448;
      }
    }
    else
    {
      uint64_t v28 = *(void *)(result + 216);
      uint64_t v29 = v19 - *(void *)(result + 224);
      uint64_t v30 = a3 - v29 + (v28 >> 1);
      if (v30 < 1) {
        goto LABEL_39;
      }
      if (v30 >= v28) {
        LODWORD(v31) = 0x3FFFFFFF;
      }
      else {
        unint64_t v31 = (unint64_t)(*(void *)(result + 232) * v30) >> 32;
      }
      uint64_t v39 = v91;
      unsigned int v37 = v31 | v90;
      uint64_t v38 = v29 + 0x1000000;
      uint64_t v36 = 512;
    }
    if (a2 >= v39) {
      break;
    }
    uint64_t v40 = *(void *)(result + 192);
    uint64_t v41 = v39 - *(void *)(result + 200);
    uint64_t v42 = a2 - v41 + (v40 >> 1);
    if (v42 >= 1)
    {
      if (v42 < v40) {
        unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v90;
      }
      uint64_t v43 = v41 + 0x1000000;
      uint64_t v44 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v21;
    a3 += v20;
    v22 += 8;
    *(unsigned char *)++uint64_t v23 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v92)
  {
    uint64_t v44 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v43 = a2;
    goto LABEL_26;
  }
  uint64_t v45 = *(void *)(result + 192);
  uint64_t v46 = *(void *)(result + 200) + v92;
  uint64_t v47 = v46 - a2 + (v45 >> 1);
  if (v47 < 1) {
    goto LABEL_39;
  }
  if (v47 < v45) {
    unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v47) >> 32) >> 15)) | v90;
  }
  uint64_t v43 = v46 - 0x1000000;
  uint64_t v44 = 28;
LABEL_26:
  if (v37 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v48 = v38 >> 32;
  uint64_t v49 = v14 + SHIDWORD(v38) * (uint64_t)v16;
  unint64_t v50 = (v43 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v51 = v49 + 4 * v50;
  uint64_t v52 = *(int8x16_t **)(result + 32);
  if (v27 >= v51) {
    unint64_t v53 = (int8x16_t *)(v49 + 4 * v50);
  }
  else {
    unint64_t v53 = (int8x16_t *)v27;
  }
  if (v53 < v52) {
    unint64_t v53 = *(int8x16_t **)(result + 32);
  }
  if (v15)
  {
    unint64_t v54 = v15 + (int)v48 * (uint64_t)v17 + v50;
    float32x2_t v55 = *(unsigned int **)(result + 40);
    if (v26 >= v54) {
      float v56 = (unsigned int *)(v15 + (int)v48 * (uint64_t)v17 + v50);
    }
    else {
      float v56 = (unsigned int *)v26;
    }
    if (v56 >= v55) {
      float32x2_t v55 = v56;
    }
    float v57 = COERCE_FLOAT(bswap32(*v55));
  }
  else
  {
    unint64_t v54 = 0;
    float v57 = 1.0;
  }
  float32x4_t v58 = (float32x4_t)vrev32q_s8(*v53);
  if (v18)
  {
    unsigned int v59 = *(_DWORD *)(v18 + (v44 | v36));
LABEL_45:
    int v60 = v59 & 0xF;
    unsigned int v61 = HIBYTE(v59) & 3;
    if (v60 == 1)
    {
      float v75 = (int8x16_t *)(v51 + SBYTE1(v59) * (uint64_t)v16);
      if (v27 < (unint64_t)v75) {
        float v75 = (int8x16_t *)v27;
      }
      if (v75 < v52) {
        float v75 = v52;
      }
      float32x4_t v76 = (float32x4_t)vrev32q_s8(*v75);
      float v77 = 1.0;
      if (v15)
      {
        uint64_t v78 = (unsigned int *)(v54 + SBYTE1(v59) * (uint64_t)v17);
        if (v26 < (unint64_t)v78) {
          uint64_t v78 = (unsigned int *)v26;
        }
        if ((unint64_t)v78 < *(void *)(result + 40)) {
          uint64_t v78 = *(unsigned int **)(result + 40);
        }
        float v77 = COERCE_FLOAT(bswap32(*v78));
      }
    }
    else
    {
      if (v60 != 2)
      {
        if (v60 == 3)
        {
          int64_t v62 = (unint64_t)HIWORD(v59) << 56;
          unint64_t v63 = v51 + (v62 >> 52);
          if (v27 >= v63) {
            float32x2_t v64 = (int8x16_t *)(v51 + (v62 >> 52));
          }
          else {
            float32x2_t v64 = (int8x16_t *)v27;
          }
          if (v64 < v52) {
            float32x2_t v64 = v52;
          }
          unint64_t v65 = (int8x16_t *)(v63 + SBYTE1(v59) * (uint64_t)v16);
          if (v27 < (unint64_t)v65) {
            unint64_t v65 = (int8x16_t *)v27;
          }
          if (v65 < v52) {
            unint64_t v65 = v52;
          }
          float32x4_t v66 = (float32x4_t)vrev32q_s8(*v64);
          float32x4_t v67 = (float32x4_t)vrev32q_s8(*v65);
          float v68 = 1.0;
          float v69 = 1.0;
          if (v15)
          {
            uint64_t v70 = (unsigned int *)(v54 + (v62 >> 54));
            unint64_t v71 = *(void *)(result + 40);
            if (v26 >= (unint64_t)v70) {
              uint64_t v72 = v70;
            }
            else {
              uint64_t v72 = (unsigned int *)v26;
            }
            if ((unint64_t)v72 < v71) {
              uint64_t v72 = *(unsigned int **)(result + 40);
            }
            float v69 = COERCE_FLOAT(bswap32(*v72));
            uint64_t v73 = (unsigned int *)((char *)v70 + SBYTE1(v59) * (uint64_t)v17);
            if (v26 < (unint64_t)v73) {
              uint64_t v73 = (unsigned int *)v26;
            }
            if ((unint64_t)v73 < v71) {
              uint64_t v73 = *(unsigned int **)(result + 40);
            }
            float v68 = COERCE_FLOAT(bswap32(*v73));
          }
          v12.i32[0] = interpolate_cmykaf[5 * v61 + 4];
          v13.i32[0] = interpolate_cmykaf[5 * ((v59 >> 28) & 3) + 4];
          float32x4_t v74 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, v12, 0), v66, v12.f32[0]);
          float32x4_t v58 = vmlaq_n_f32(vmlsq_lane_f32(v74, v74, v13, 0), vmlaq_n_f32(vmlsq_lane_f32(v66, v66, v12, 0), v67, v12.f32[0]), v13.f32[0]);
          float v57 = (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v69 * v12.f32[0]))
                      - (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v69 * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v69 - (float)(v69 * v12.f32[0])) + (float)(v68 * v12.f32[0])) * v13.f32[0]);
        }
        goto LABEL_91;
      }
      int64_t v79 = (unint64_t)HIWORD(v59) << 56;
      unint64_t v80 = (int8x16_t *)(v51 + (v79 >> 52));
      if (v27 < (unint64_t)v80) {
        unint64_t v80 = (int8x16_t *)v27;
      }
      if (v80 < v52) {
        unint64_t v80 = v52;
      }
      float32x4_t v76 = (float32x4_t)vrev32q_s8(*v80);
      float v77 = 1.0;
      if (v15)
      {
        float v81 = (unsigned int *)(v54 + (v79 >> 54));
        if (v26 < (unint64_t)v81) {
          float v81 = (unsigned int *)v26;
        }
        if ((unint64_t)v81 < *(void *)(result + 40)) {
          float v81 = *(unsigned int **)(result + 40);
        }
        float v77 = COERCE_FLOAT(bswap32(*v81));
      }
      unsigned int v61 = (v59 >> 28) & 3;
    }
    LODWORD(a12) = interpolate_cmykaf[5 * v61 + 4];
    float32x4_t v58 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, *(float32x2_t *)&a12, 0), v76, *(float *)&a12);
    float v57 = (float)(v57 - (float)(v57 * *(float *)&a12)) + (float)(v77 * *(float *)&a12);
  }
LABEL_91:
  uint64_t v82 = 0;
  a2 += v21;
  uint64_t v83 = v92 - a2;
  uint64_t v84 = (float *)(v22 + 12);
  a3 += v20;
  uint64_t v85 = v93 - a3;
  while (1)
  {
    *(v84 - 1) = (float)((float)((float)((float)(v57 - v58.f32[1]) - v58.f32[3]) * 0.59)
                       + (float)((float)((float)(v57 - v58.f32[0]) - v58.f32[3]) * 0.3))
               + (float)((float)((float)(v57 - v58.f32[2]) - v58.f32[3]) * 0.11);
    float *v84 = v57;
    *(unsigned char *)(v23 + 1 + v82) = v37 >> 22;
    if (a4 - 1 == v82) {
      return result;
    }
    if ((v85 | v83 | (a3 - v19) | (a2 - v91)) < 0)
    {
      v23 += v82 + 1;
      uint64_t v22 = (uint64_t)(v84 - 1);
      a4 += ~v82;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v86 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v51 = v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86;
    uint64_t v52 = *(int8x16_t **)(result + 32);
    if (v27 >= v51) {
      uint64_t v87 = (int8x16_t *)(v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86);
    }
    else {
      uint64_t v87 = (int8x16_t *)v27;
    }
    if (v87 < v52) {
      uint64_t v87 = *(int8x16_t **)(result + 32);
    }
    if (v15)
    {
      unint64_t v54 = v15 + SHIDWORD(a3) * (uint64_t)v17 + v86;
      float v88 = *(unsigned int **)(result + 40);
      if (v26 >= v54) {
        float v89 = (unsigned int *)v54;
      }
      else {
        float v89 = (unsigned int *)v26;
      }
      if (v89 >= v88) {
        float v88 = v89;
      }
      float v57 = COERCE_FLOAT(bswap32(*v88));
    }
    else
    {
      float v57 = 1.0;
    }
    float32x4_t v58 = (float32x4_t)vrev32q_s8(*v87);
    if (v18)
    {
      unsigned int v59 = *(_DWORD *)(v18 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v59 & 0xF) != 0)
      {
        v23 += v82 + 1;
        uint64_t v22 = (uint64_t)(v84 - 1);
        a4 += ~v82;
        unsigned int v37 = -1;
        goto LABEL_45;
      }
    }
    ++v82;
    v83 -= v21;
    v84 += 2;
    a3 += v20;
    v85 -= v20;
    a2 += v21;
    unsigned int v37 = -1;
  }
}

uint64_t Wf_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 32);
  uint64_t v15 = *(void *)(result + 40);
  int v16 = *(_DWORD *)(result + 24);
  int v17 = *(_DWORD *)(result + 28);
  uint64_t v18 = *(void *)(result + 176);
  uint64_t v19 = *(void *)(result + 72);
  uint64_t v92 = *(void *)(result + 80);
  uint64_t v93 = *(void *)(result + 88);
  uint64_t v21 = *(void *)(result + 112);
  uint64_t v20 = *(void *)(result + 120);
  int v90 = *(_DWORD *)(result + 188);
  uint64_t v22 = *(void *)(result + 152) - 8;
  uint64_t v23 = *(void *)(result + 144) - 1;
  int v24 = *(_DWORD *)(result + 260) - 1;
  int v25 = *(_DWORD *)(result + 256);
  unint64_t v26 = v15 + (v24 * v17) + 4 * (v25 - 1);
  unint64_t v27 = v14 + (v24 * v16) + 4 * (4 * v25) - 16;
  uint64_t v91 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v19)
    {
      if (a3 <= v93)
      {
        uint64_t v36 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v37 = 0x3FFFFFFF;
        uint64_t v38 = a3;
        uint64_t v39 = v91;
      }
      else
      {
        uint64_t v32 = *(void *)(result + 216);
        uint64_t v33 = *(void *)(result + 224) + v93;
        uint64_t v34 = v33 - a3 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_39;
        }
        if (v34 >= v32) {
          LODWORD(v35) = 0x3FFFFFFF;
        }
        else {
          unint64_t v35 = (unint64_t)(*(void *)(result + 232) * v34) >> 32;
        }
        uint64_t v39 = v91;
        unsigned int v37 = v35 | v90;
        uint64_t v38 = v33 - 0x1000000;
        uint64_t v36 = 448;
      }
    }
    else
    {
      uint64_t v28 = *(void *)(result + 216);
      uint64_t v29 = v19 - *(void *)(result + 224);
      uint64_t v30 = a3 - v29 + (v28 >> 1);
      if (v30 < 1) {
        goto LABEL_39;
      }
      if (v30 >= v28) {
        LODWORD(v31) = 0x3FFFFFFF;
      }
      else {
        unint64_t v31 = (unint64_t)(*(void *)(result + 232) * v30) >> 32;
      }
      uint64_t v39 = v91;
      unsigned int v37 = v31 | v90;
      uint64_t v38 = v29 + 0x1000000;
      uint64_t v36 = 512;
    }
    if (a2 >= v39) {
      break;
    }
    uint64_t v40 = *(void *)(result + 192);
    uint64_t v41 = v39 - *(void *)(result + 200);
    uint64_t v42 = a2 - v41 + (v40 >> 1);
    if (v42 >= 1)
    {
      if (v42 < v40) {
        unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v90;
      }
      uint64_t v43 = v41 + 0x1000000;
      uint64_t v44 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v21;
    a3 += v20;
    v22 += 8;
    *(unsigned char *)++uint64_t v23 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v92)
  {
    uint64_t v44 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v43 = a2;
    goto LABEL_26;
  }
  uint64_t v45 = *(void *)(result + 192);
  uint64_t v46 = *(void *)(result + 200) + v92;
  uint64_t v47 = v46 - a2 + (v45 >> 1);
  if (v47 < 1) {
    goto LABEL_39;
  }
  if (v47 < v45) {
    unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v47) >> 32) >> 15)) | v90;
  }
  uint64_t v43 = v46 - 0x1000000;
  uint64_t v44 = 28;
LABEL_26:
  if (v37 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v48 = v38 >> 32;
  uint64_t v49 = v14 + SHIDWORD(v38) * (uint64_t)v16;
  unint64_t v50 = (v43 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v51 = v49 + 4 * v50;
  uint64_t v52 = *(float32x4_t **)(result + 32);
  if (v27 >= v51) {
    unint64_t v53 = (float32x4_t *)(v49 + 4 * v50);
  }
  else {
    unint64_t v53 = (float32x4_t *)v27;
  }
  if (v53 < v52) {
    unint64_t v53 = *(float32x4_t **)(result + 32);
  }
  if (v15)
  {
    unint64_t v54 = v15 + (int)v48 * (uint64_t)v17 + v50;
    float32x2_t v55 = *(float **)(result + 40);
    if (v26 >= v54) {
      float v56 = (float *)(v15 + (int)v48 * (uint64_t)v17 + v50);
    }
    else {
      float v56 = (float *)v26;
    }
    if (v56 >= v55) {
      float32x2_t v55 = v56;
    }
    float v57 = *v55;
  }
  else
  {
    unint64_t v54 = 0;
    float v57 = 1.0;
  }
  float32x4_t v58 = *v53;
  if (v18)
  {
    unsigned int v59 = *(_DWORD *)(v18 + (v44 | v36));
LABEL_45:
    int v60 = v59 & 0xF;
    int v61 = HIBYTE(v59) & 3;
    if (v60 == 1)
    {
      float v75 = (float32x4_t *)(v51 + SBYTE1(v59) * (uint64_t)v16);
      if (v27 < (unint64_t)v75) {
        float v75 = (float32x4_t *)v27;
      }
      if (v75 < v52) {
        float v75 = v52;
      }
      float32x4_t v76 = *v75;
      float v77 = 1.0;
      if (v15)
      {
        uint64_t v78 = (float *)(v54 + SBYTE1(v59) * (uint64_t)v17);
        if (v26 < (unint64_t)v78) {
          uint64_t v78 = (float *)v26;
        }
        if ((unint64_t)v78 < *(void *)(result + 40)) {
          uint64_t v78 = *(float **)(result + 40);
        }
        float v77 = *v78;
      }
    }
    else
    {
      if (v60 != 2)
      {
        if (v60 == 3)
        {
          int64_t v62 = (unint64_t)HIWORD(v59) << 56;
          unint64_t v63 = v51 + (v62 >> 52);
          if (v27 >= v63) {
            float32x2_t v64 = (float32x4_t *)(v51 + (v62 >> 52));
          }
          else {
            float32x2_t v64 = (float32x4_t *)v27;
          }
          if (v64 < v52) {
            float32x2_t v64 = v52;
          }
          unint64_t v65 = (float32x4_t *)(v63 + SBYTE1(v59) * (uint64_t)v16);
          if (v27 < (unint64_t)v65) {
            unint64_t v65 = (float32x4_t *)v27;
          }
          if (v65 < v52) {
            unint64_t v65 = v52;
          }
          float32x4_t v66 = *v64;
          float32x4_t v67 = *v65;
          float v68 = 1.0;
          float v69 = 1.0;
          if (v15)
          {
            uint64_t v70 = (float *)(v54 + (v62 >> 54));
            unint64_t v71 = *(void *)(result + 40);
            if (v26 >= (unint64_t)v70) {
              uint64_t v72 = v70;
            }
            else {
              uint64_t v72 = (float *)v26;
            }
            if ((unint64_t)v72 < v71) {
              uint64_t v72 = *(float **)(result + 40);
            }
            float v68 = *v72;
            uint64_t v73 = (float *)((char *)v70 + SBYTE1(v59) * (uint64_t)v17);
            if (v26 < (unint64_t)v73) {
              uint64_t v73 = (float *)v26;
            }
            if ((unint64_t)v73 < v71) {
              uint64_t v73 = *(float **)(result + 40);
            }
            float v69 = *v73;
          }
          v12.i32[0] = interpolate_cmykaf[5 * v61 + 4];
          v13.i32[0] = interpolate_cmykaf[5 * ((v59 >> 28) & 3) + 4];
          float32x4_t v74 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, v12, 0), v66, v12.f32[0]);
          float32x4_t v58 = vmlaq_n_f32(vmlsq_lane_f32(v74, v74, v13, 0), vmlaq_n_f32(vmlsq_lane_f32(v66, v66, v12, 0), v67, v12.f32[0]), v13.f32[0]);
          float v57 = (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v68 * v12.f32[0]))
                      - (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v68 * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v68 - (float)(v68 * v12.f32[0])) + (float)(v69 * v12.f32[0])) * v13.f32[0]);
        }
        goto LABEL_91;
      }
      int64_t v79 = (unint64_t)HIWORD(v59) << 56;
      unint64_t v80 = (float32x4_t *)(v51 + (v79 >> 52));
      if (v27 < (unint64_t)v80) {
        unint64_t v80 = (float32x4_t *)v27;
      }
      if (v80 < v52) {
        unint64_t v80 = v52;
      }
      float32x4_t v76 = *v80;
      float v77 = 1.0;
      if (v15)
      {
        float v81 = (float *)(v54 + (v79 >> 54));
        if (v26 < (unint64_t)v81) {
          float v81 = (float *)v26;
        }
        if ((unint64_t)v81 < *(void *)(result + 40)) {
          float v81 = *(float **)(result + 40);
        }
        float v77 = *v81;
      }
      int v61 = (v59 >> 28) & 3;
    }
    LODWORD(a12) = interpolate_cmykaf[5 * v61 + 4];
    float32x4_t v58 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, *(float32x2_t *)&a12, 0), v76, *(float *)&a12);
    float v57 = (float)(v57 - (float)(v57 * *(float *)&a12)) + (float)(v77 * *(float *)&a12);
  }
LABEL_91:
  uint64_t v82 = 0;
  a2 += v21;
  uint64_t v83 = v92 - a2;
  uint64_t v84 = (float *)(v22 + 12);
  a3 += v20;
  uint64_t v85 = v93 - a3;
  while (1)
  {
    *(v84 - 1) = (float)((float)((float)((float)(v57 - v58.f32[1]) - v58.f32[3]) * 0.59)
                       + (float)((float)((float)(v57 - v58.f32[0]) - v58.f32[3]) * 0.3))
               + (float)((float)((float)(v57 - v58.f32[2]) - v58.f32[3]) * 0.11);
    float *v84 = v57;
    *(unsigned char *)(v23 + 1 + v82) = v37 >> 22;
    if (a4 - 1 == v82) {
      return result;
    }
    if ((v85 | v83 | (a3 - v19) | (a2 - v91)) < 0)
    {
      v23 += v82 + 1;
      uint64_t v22 = (uint64_t)(v84 - 1);
      a4 += ~v82;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v86 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v51 = v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86;
    uint64_t v52 = *(float32x4_t **)(result + 32);
    if (v27 >= v51) {
      uint64_t v87 = (float32x4_t *)(v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86);
    }
    else {
      uint64_t v87 = (float32x4_t *)v27;
    }
    if (v87 < v52) {
      uint64_t v87 = *(float32x4_t **)(result + 32);
    }
    if (v15)
    {
      unint64_t v54 = v15 + SHIDWORD(a3) * (uint64_t)v17 + v86;
      float v88 = *(float **)(result + 40);
      if (v26 >= v54) {
        float v89 = (float *)v54;
      }
      else {
        float v89 = (float *)v26;
      }
      if (v89 >= v88) {
        float v88 = v89;
      }
      float v57 = *v88;
    }
    else
    {
      float v57 = 1.0;
    }
    float32x4_t v58 = *v87;
    if (v18)
    {
      unsigned int v59 = *(_DWORD *)(v18 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v59 & 0xF) != 0)
      {
        v23 += v82 + 1;
        uint64_t v22 = (uint64_t)(v84 - 1);
        a4 += ~v82;
        unsigned int v37 = -1;
        goto LABEL_45;
      }
    }
    ++v82;
    v83 -= v21;
    v84 += 2;
    a3 += v20;
    v85 -= v20;
    a2 += v21;
    unsigned int v37 = -1;
  }
}

_DWORD *Wf_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  uint64_t v9 = *(float **)(*(void *)a1 + 64);
  float v11 = *v9;
  float v10 = v9[1];
  if (!a2 || a3 <= 7)
  {
    a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL);
    if (!a2) {
      return a2;
    }
  }
  if (v11 <= a6) {
    float v12 = a6;
  }
  else {
    float v12 = v11;
  }
  if (v10 < a6) {
    float v12 = v10;
  }
  if (a5) {
    int v13 = a4;
  }
  else {
    int v13 = 0;
  }
  switch(v13)
  {
    case 1:
      float v14 = *a5;
      goto LABEL_18;
    case 4:
      float v14 = (float)(v10 - (float)((float)((float)(*a5 * v9[2]) + (float)(a5[1] * v9[3])) + (float)(a5[2] * v9[4])))
          - a5[3];
      goto LABEL_18;
    case 3:
      float v14 = (float)((float)(*a5 * v9[2]) + (float)(a5[1] * v9[3])) + (float)(a5[2] * v9[4]);
LABEL_18:
      float v11 = v12 * v14;
      break;
  }
  *(_OWORD *)a2 = xmmword_1850CDB00;
  a2[6] = 0;
  *((void *)a2 + 2) = 1;
  *((float *)a2 + 12) = v11;
  *((float *)a2 + 13) = v12;
  uint64_t v15 = (char *)(a2 + 13);
  if (v12 >= v10) {
    uint64_t v15 = 0;
  }
  *((void *)a2 + 4) = a2 + 12;
  *((void *)a2 + 5) = v15;
  return a2;
}

uint64_t Wf_mark(uint64_t a1, __n128 a2)
{
  return Wf_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

uint64_t Wf_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v705 = *MEMORY[0x1E4F143B8];
  int v7 = *(char **)(v3 + 96);
  uint64_t v8 = *(void *)(v3 + 48);
  int v9 = *(_DWORD *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v3;
  unint64_t v12 = *(unsigned int *)(v3 + 4);
  unsigned int v13 = v12 - 1;
  if ((int)v12 < 1) {
    return 0;
  }
  int v14 = *(_DWORD *)(v3 + 8);
  uint64_t v15 = (v14 - 1);
  if (v14 < 1) {
    return 0;
  }
  int v16 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v16)
  {
    int v18 = *(_DWORD *)v3 & 0xFF00;
    int v649 = *(_DWORD *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
    uint64_t v645 = v3;
    if (v18 == 1024)
    {
      v704[0] = *(_DWORD *)(v3 + 4);
      v694[0] = v14;
      float v19 = 1.0;
      if (v7) {
        float v19 = *(float *)v7;
      }
      uint64_t v20 = *(void *)(v3 + 40);
      unint64_t v21 = (unint64_t)*(int *)(v3 + 28) >> 2;
      uint64_t v23 = *(int *)(v3 + 12);
      uint64_t v22 = *(int *)(v3 + 16);
      if (v8)
      {
        unint64_t v687 = (unint64_t)*(int *)(v3 + 32) >> 2;
        uint64_t v684 = v8 + 4 * (v23 + v687 * v22);
        unsigned int v680 = 1;
      }
      else
      {
        uint64_t v684 = 0;
        unint64_t v687 = 0;
        unsigned int v680 = 0;
      }
      v6.i32[0] = **(_DWORD **)(v3 + 88);
      *(float *)v5.i32 = 1.0 - v19;
      unint64_t v36 = v20 + 4 * (v23 + v22 * v21);
      int32x2_t v689 = v5;
      int32x2_t v691 = v6;
      unint64_t v678 = (unint64_t)*(int *)(v3 + 28) >> 2;
      unint64_t v682 = v36;
      if (v16)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v16, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
        unint64_t v35 = v37;
        uint64_t v38 = v684;
        unint64_t v39 = v687;
        if (v37) {
          goto LABEL_1334;
        }
        return 1;
      }
      unint64_t v35 = 0;
      if (v8) {
        unint64_t v45 = v12;
      }
      else {
        unint64_t v45 = 0;
      }
      uint64_t v38 = v684;
      unint64_t v39 = v687 - v45;
      uint64_t v46 = (float32x4_t *)(v20 + 4 * (v23 + v22 * v21));
      unint64_t v47 = v12;
LABEL_977:
      unint64_t v36 = v21 - v47;
      int v496 = v12;
      switch(v9)
      {
        case 0:
          unint64_t v497 = v21;
          uint64_t v498 = v36 + (int)v12;
          unsigned int v499 = v694[0];
          int v500 = v12;
          uint64_t v501 = v694[0] - 1;
          v502 = &v46->i8[4 * ((v498 * v501) & (v498 >> 63))];
          if (v498 < 0) {
            uint64_t v498 = -v498;
          }
          CGBlt_fillBytes(4 * v500, v694[0], 0, v502, 4 * v498);
          if (v8)
          {
            uint64_t v503 = v39 + v500;
            v38 += 4 * ((v503 * v501) & (v503 >> 63));
            if (v503 >= 0) {
              v39 += v500;
            }
            else {
              unint64_t v39 = -v503;
            }
            CGBlt_fillBytes(4 * v500, v499, 0, (char *)v38, 4 * v39);
          }
          unint64_t v21 = v497;
          goto LABEL_1331;
        case 1:
          uint64_t v504 = v36 + (int)v12;
          if (v504 < 0)
          {
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v504 * (v694[0] - 1));
            uint64_t v504 = -v504;
          }
          int v505 = 0;
          v506 = *(int **)(v645 + 88);
          if (v506) {
            int v505 = *v506;
          }
          signed int v507 = v694[0];
          CGBlt_fillBytes(4 * v12, v694[0], v505, (char *)v46, 4 * v504);
          if (v8)
          {
            v508 = *(int **)(v645 + 96);
            if (!v508) {
              v508 = (int *)&_CMYK_float_alpha;
            }
            v38 += 4 * (((v39 + (int)v12) * (v507 - 1)) & ((uint64_t)(v39 + (int)v12) >> 63));
            if ((uint64_t)(v39 + (int)v12) >= 0) {
              v39 += (int)v12;
            }
            else {
              unint64_t v39 = -(uint64_t)(v39 + (int)v12);
            }
            CGBlt_fillBytes(4 * v12, v507, *v508, (char *)v38, 4 * v39);
          }
          int v9 = v649;
          goto LABEL_1331;
        case 2:
          int v509 = v694[0];
          unsigned int v510 = v12 >> 2;
          uint64_t v511 = 4 * v680;
          if (v8)
          {
            unsigned int v512 = v510 + 1;
            do
            {
              if ((int)v12 < 4)
              {
                int v514 = v12;
              }
              else
              {
                unsigned int v513 = v512;
                do
                {
                  v46->f32[0] = *(float *)v6.i32 + (float)(v46->f32[0] * *(float *)v5.i32);
                  *(float *)uint64_t v38 = v19 + (float)(*(float *)v38 * *(float *)v5.i32);
                  v46->f32[1] = *(float *)v6.i32 + (float)(v46->f32[1] * *(float *)v5.i32);
                  *(float *)(v38 + 4) = v19 + (float)(*(float *)(v38 + 4) * *(float *)v5.i32);
                  v46->f32[2] = *(float *)v6.i32 + (float)(v46->f32[2] * *(float *)v5.i32);
                  *(float *)(v38 + 8) = v19 + (float)(*(float *)(v38 + 8) * *(float *)v5.i32);
                  v46->f32[3] = *(float *)v6.i32 + (float)(v46->f32[3] * *(float *)v5.i32);
                  *(float *)(v38 + 12) = v19 + (float)(*(float *)(v38 + 12) * *(float *)v5.i32);
                  ++v46;
                  --v513;
                  v38 += 16 * v680;
                }
                while (v513 > 1);
                int v514 = v12 & 3;
              }
              if (v514 >= 1)
              {
                unsigned int v515 = v514 + 1;
                do
                {
                  v46->f32[0] = *(float *)v6.i32 + (float)(v46->f32[0] * *(float *)v5.i32);
                  uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                  *(float *)uint64_t v38 = v19 + (float)(*(float *)v38 * *(float *)v5.i32);
                  v38 += v511;
                  --v515;
                }
                while (v515 > 1);
              }
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v509;
            }
            while (v509);
          }
          else
          {
            float32x4_t v639 = (float32x4_t)vdupq_lane_s32(v5, 0);
            float32x4_t v640 = (float32x4_t)vdupq_lane_s32(v6, 0);
            unsigned int v641 = v510 + 1;
            do
            {
              if ((int)v12 < 4)
              {
                int v643 = v12;
              }
              else
              {
                unsigned int v642 = v641;
                do
                {
                  float32x4_t *v46 = vmlaq_f32(v640, v639, *v46);
                  ++v46;
                  --v642;
                  v38 += 16 * v680;
                }
                while (v642 > 1);
                int v643 = v12 & 3;
              }
              if (v643 >= 1)
              {
                unsigned int v644 = v643 + 1;
                do
                {
                  v46->f32[0] = *(float *)v6.i32 + (float)(v46->f32[0] * *(float *)v5.i32);
                  uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                  v38 += v511;
                  --v644;
                }
                while (v644 > 1);
              }
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v509;
            }
            while (v509);
          }
          goto LABEL_1330;
        case 3:
          int v516 = v694[0];
          do
          {
            int v517 = v12;
            do
            {
              float v518 = *(float *)v38;
              if (*(float *)v38 <= 0.0)
              {
                *(_DWORD *)uint64_t v38 = 0;
                v46->i32[0] = 0;
              }
              else if (v518 >= 1.0)
              {
                v46->i32[0] = v6.i32[0];
                *(float *)uint64_t v38 = v19;
              }
              else
              {
                v46->f32[0] = *(float *)v6.i32 * v518;
                *(float *)uint64_t v38 = v19 * v518;
              }
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v517;
            }
            while (v517);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            --v516;
          }
          while (v516);
          goto LABEL_1330;
        case 4:
          int v519 = v694[0];
          do
          {
            int v520 = v12;
            do
            {
              float v521 = 1.0 - *(float *)v38;
              if (v521 <= 0.0)
              {
                *(_DWORD *)uint64_t v38 = 0;
                v46->i32[0] = 0;
              }
              else if (v521 >= 1.0)
              {
                v46->i32[0] = v6.i32[0];
                *(float *)uint64_t v38 = v19;
              }
              else
              {
                v46->f32[0] = *(float *)v6.i32 * v521;
                *(float *)uint64_t v38 = v19 * v521;
              }
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v520;
            }
            while (v520);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            --v519;
          }
          while (v519);
          goto LABEL_1330;
        case 5:
          int v522 = v694[0];
          do
          {
            int v523 = v12;
            do
            {
              float v524 = *(float *)v38;
              v46->f32[0] = (float)(*(float *)v5.i32 * v46->f32[0]) + (float)(*(float *)v6.i32 * *(float *)v38);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              *(float *)uint64_t v38 = (float)(*(float *)v5.i32 * v524) + (float)(v19 * v524);
              v38 += 4 * v680;
              --v523;
            }
            while (v523);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            --v522;
          }
          while (v522);
          goto LABEL_1330;
        case 6:
          int v525 = v694[0];
          while (1)
          {
            int v526 = v12;
            do
            {
              float v527 = *(float *)v38;
              float v528 = 1.0 - *(float *)v38;
              if (v528 >= 1.0)
              {
                v46->i32[0] = v6.i32[0];
                float v529 = v19;
              }
              else
              {
                if (v528 <= 0.0) {
                  goto LABEL_1042;
                }
                v46->f32[0] = v46->f32[0] + (float)(*(float *)v6.i32 * v528);
                float v529 = v527 + (float)(v19 * v528);
              }
              *(float *)uint64_t v38 = v529;
LABEL_1042:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v526;
            }
            while (v526);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v525)
            {
LABEL_1330:
              v694[0] = 0;
LABEL_1331:
              unint64_t v36 = v682;
LABEL_1332:
              if (!v35) {
                return 1;
              }
              uint64_t v693 = 0;
LABEL_1334:
              if (!shape_enum_clip_next((uint64_t)v35, (int *)&v693 + 1, &v693, v704, v694)) {
                goto LABEL_65;
              }
              uint64_t v46 = (float32x4_t *)(v36 + 4 * v21 * (int)v693 + 4 * SHIDWORD(v693));
              unint64_t v47 = v704[0];
              if (v8)
              {
                uint64_t v38 = v684 + 4 * v687 * (int)v693 + 4 * SHIDWORD(v693);
                unint64_t v39 = v687 - v704[0];
              }
              LODWORD(v12) = v704[0];
              int32x2_t v5 = v689;
              int32x2_t v6 = v691;
              goto LABEL_977;
            }
          }
        case 7:
          int v530 = v694[0];
          uint64_t v531 = 4 * v680;
          if (v8)
          {
            do
            {
              int v532 = v12;
              do
              {
                v46->f32[0] = v19 * v46->f32[0];
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                *(float *)uint64_t v38 = v19 * *(float *)v38;
                v38 += v531;
                --v532;
              }
              while (v532);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v530;
            }
            while (v530);
          }
          else
          {
            do
            {
              int v533 = v12;
              do
              {
                v46->f32[0] = v19 * v46->f32[0];
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                v38 += v531;
                --v533;
              }
              while (v533);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v530;
            }
            while (v530);
          }
          goto LABEL_1330;
        case 8:
          int v534 = v694[0];
          uint64_t v535 = 4 * v680;
          if (v8)
          {
            do
            {
              int v536 = v12;
              do
              {
                v46->f32[0] = *(float *)v5.i32 * v46->f32[0];
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                *(float *)uint64_t v38 = *(float *)v5.i32 * *(float *)v38;
                v38 += v535;
                --v536;
              }
              while (v536);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v534;
            }
            while (v534);
          }
          else
          {
            do
            {
              int v537 = v12;
              do
              {
                v46->f32[0] = *(float *)v5.i32 * v46->f32[0];
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                v38 += v535;
                --v537;
              }
              while (v537);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v534;
            }
            while (v534);
          }
          goto LABEL_1330;
        case 9:
          int v538 = v694[0];
          do
          {
            int v539 = v12;
            do
            {
              float v540 = *(float *)v38;
              float v541 = 1.0 - *(float *)v38;
              v46->f32[0] = (float)(v19 * v46->f32[0]) + (float)(*(float *)v6.i32 * v541);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              *(float *)uint64_t v38 = (float)(v19 * v540) + (float)(v19 * v541);
              v38 += 4 * v680;
              --v539;
            }
            while (v539);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            --v538;
          }
          while (v538);
          goto LABEL_1330;
        case 10:
          int v542 = v694[0];
          do
          {
            int v543 = v12;
            do
            {
              float v544 = *(float *)v38;
              float v545 = 1.0 - *(float *)v38;
              v46->f32[0] = (float)(*(float *)v5.i32 * v46->f32[0]) + (float)(*(float *)v6.i32 * v545);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              *(float *)uint64_t v38 = (float)(*(float *)v5.i32 * v544) + (float)(v19 * v545);
              v38 += 4 * v680;
              --v543;
            }
            while (v543);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            --v542;
          }
          while (v542);
          goto LABEL_1330;
        case 11:
          float v546 = v19 - *(float *)v6.i32;
          int v547 = v694[0];
          uint64_t v548 = 4 * v680;
          if (v8)
          {
            do
            {
              int v549 = v12;
              do
              {
                float v550 = v19 + *(float *)v38;
                float v551 = v546 + (float)(*(float *)v38 - v46->f32[0]);
                if (v550 > 1.0) {
                  float v550 = 1.0;
                }
                *(float *)uint64_t v38 = v550;
                v46->f32[0] = v550 - v551;
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                v38 += v548;
                --v549;
              }
              while (v549);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v547;
            }
            while (v547);
          }
          else
          {
            do
            {
              int v552 = v12;
              do
              {
                v46->f32[0] = 1.0 - (float)(v546 + (float)(1.0 - v46->f32[0]));
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                v38 += v548;
                --v552;
              }
              while (v552);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v547;
            }
            while (v547);
          }
          goto LABEL_1330;
        case 12:
          int v553 = v694[0];
          uint64_t v554 = 4 * v680;
          if (v8)
          {
            do
            {
              int v555 = v12;
              do
              {
                float v556 = v19 + *(float *)v38;
                if (v556 > 1.0) {
                  float v556 = 1.0;
                }
                v46->f32[0] = *(float *)v6.i32 + v46->f32[0];
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                *(float *)uint64_t v38 = v556;
                v38 += v554;
                --v555;
              }
              while (v555);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v553;
            }
            while (v553);
          }
          else
          {
            do
            {
              int v557 = v12;
              do
              {
                v46->f32[0] = *(float *)v6.i32 + v46->f32[0];
                uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
                v38 += v554;
                --v557;
              }
              while (v557);
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v553;
            }
            while (v553);
          }
          goto LABEL_1330;
        case 13:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v558 = v694[0];
          while (1)
          {
            int v559 = v12;
            do
            {
              if (v8)
              {
                float v560 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                  goto LABEL_1108;
                }
              }
              else
              {
                float v560 = 1.0;
              }
              float v561 = (float)(*(float *)v6.i32 * v46->f32[0]) + (float)(v46->f32[0] * *(float *)v5.i32);
              if (v19 == 1.0) {
                float v561 = *(float *)v6.i32 * v46->f32[0];
              }
              if (v560 != 1.0) {
                float v561 = v561 + (float)(*(float *)v6.i32 * (float)(1.0 - v560));
              }
              v46->f32[0] = v561;
              if (v8) {
                *(float *)uint64_t v38 = (float)(v19 + v560) - (float)(v560 * v19);
              }
LABEL_1108:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v559;
            }
            while (v559);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v558) {
              goto LABEL_1330;
            }
          }
        case 14:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v562 = v694[0];
          do
          {
            int v563 = v12;
            do
            {
              if (v8)
              {
                float v564 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                }
                else
                {
                  v46->f32[0] = v46->f32[0] + (float)(*(float *)v6.i32 * (float)(1.0 - v46->f32[0]));
                  *(float *)uint64_t v38 = (float)(v19 + v564) - (float)(v564 * v19);
                }
              }
              else
              {
                v46->f32[0] = v46->f32[0] + (float)(*(float *)v6.i32 * (float)(1.0 - v46->f32[0]));
              }
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v563;
            }
            while (v563);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            --v562;
          }
          while (v562);
          goto LABEL_1330;
        case 15:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v565 = v694[0];
          float v566 = *(float *)v6.i32 + *(float *)v6.i32;
          float v567 = *(float *)v6.i32 * 0.0;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v38 <= 0.0)
              {
                v46->i32[0] = v6.i32[0];
                *(float *)uint64_t v38 = v19;
              }
              else
              {
                float v568 = PDAoverlayPDA(v46->f32[0], *(float *)v38, *(float *)v6.i32, v19);
                v5.i32[0] = v689.i32[0];
                v6.i32[0] = v691.i32[0];
                v46->f32[0] = v568;
                *(_DWORD *)uint64_t v38 = v569;
              }
            }
            else
            {
              float v570 = (float)(*(float *)v6.i32 * v46->f32[0]) + (float)(*(float *)v6.i32 * v46->f32[0]);
              float v571 = (float)(v567 + (float)(v46->f32[0] * *(float *)v5.i32)) + v570;
              if (v46->f32[0] >= 0.5) {
                float v571 = (float)((float)(v566 + (float)(v46->f32[0] * (float)(v19 + 1.0))) - v570) - v19;
              }
              v46->f32[0] = v571;
            }
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
            v38 += 4 * v680;
            LODWORD(v12) = v12 - 1;
            if (!v12)
            {
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v565;
              LODWORD(v12) = v496;
              if (!v565) {
                break;
              }
            }
          }
          goto LABEL_1227;
        case 16:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v572 = v694[0];
          while (1)
          {
            int v573 = v12;
            do
            {
              if (v8)
              {
                float v574 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                  goto LABEL_1149;
                }
              }
              else
              {
                float v574 = 1.0;
              }
              float v575 = v19 * v46->f32[0];
              if ((float)(*(float *)v6.i32 * v574) < v575) {
                float v575 = *(float *)v6.i32 * v574;
              }
              float v576 = v575 + (float)(v46->f32[0] * *(float *)v5.i32);
              if (v19 == 1.0) {
                float v576 = v575;
              }
              if (v574 != 1.0) {
                float v576 = v576 + (float)(*(float *)v6.i32 * (float)(1.0 - v574));
              }
              v46->f32[0] = v576;
              if (v8) {
                *(float *)uint64_t v38 = (float)(v19 + v574) - (float)(v574 * v19);
              }
LABEL_1149:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v573;
            }
            while (v573);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v572) {
              goto LABEL_1330;
            }
          }
        case 17:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v577 = v694[0];
          while (1)
          {
            int v578 = v12;
            do
            {
              if (v8)
              {
                float v579 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                  goto LABEL_1167;
                }
              }
              else
              {
                float v579 = 1.0;
              }
              float v580 = v19 * v46->f32[0];
              if ((float)(*(float *)v6.i32 * v579) > v580) {
                float v580 = *(float *)v6.i32 * v579;
              }
              float v581 = v580 + (float)(v46->f32[0] * *(float *)v5.i32);
              if (v19 == 1.0) {
                float v581 = v580;
              }
              if (v579 != 1.0) {
                float v581 = v581 + (float)(*(float *)v6.i32 * (float)(1.0 - v579));
              }
              v46->f32[0] = v581;
              if (v8) {
                *(float *)uint64_t v38 = (float)(v19 + v579) - (float)(v579 * v19);
              }
LABEL_1167:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v578;
            }
            while (v578);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v577) {
              goto LABEL_1330;
            }
          }
        case 18:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v582 = v694[0];
          float v583 = v19 - *(float *)v6.i32;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v38 <= 0.0)
              {
                v46->i32[0] = v6.i32[0];
                *(float *)uint64_t v38 = v19;
              }
              else
              {
                float v584 = PDAcolordodgePDA(v46->f32[0], *(float *)v38, *(float *)v6.i32, v19);
                v5.i32[0] = v689.i32[0];
                v6.i32[0] = v691.i32[0];
                v46->f32[0] = v584;
                *(_DWORD *)uint64_t v38 = v585;
              }
            }
            else
            {
              float v586 = v46->f32[0];
              if (v46->f32[0] == 0.0) {
                float v587 = 0.0;
              }
              else {
                float v587 = 1.0;
              }
              if (v46->f32[0] != 0.0 && *(float *)v6.i32 != v19) {
                float v587 = (float)((float)(v19 * v19) * v586) / v583;
              }
              float v589 = v587 + (float)(v586 * *(float *)v5.i32);
              if (v19 == 1.0) {
                float v589 = v587;
              }
              if (v589 > (float)((float)(v19 + 1.0) - v19)) {
                float v589 = (float)(v19 + 1.0) - v19;
              }
              v46->f32[0] = v589;
            }
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
            v38 += 4 * v680;
            LODWORD(v12) = v12 - 1;
            if (!v12)
            {
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v582;
              LODWORD(v12) = v496;
              if (!v582) {
                break;
              }
            }
          }
          goto LABEL_1227;
        case 19:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v590 = v694[0];
          while (1)
          {
            if (v8)
            {
              if (*(float *)v38 <= 0.0)
              {
                v46->i32[0] = v6.i32[0];
                *(float *)uint64_t v38 = v19;
              }
              else
              {
                double v591 = PDAcolorburnPDA(v46->f32[0], *(float *)v38, *(float *)v6.i32, v19);
                v6.i32[0] = v691.i32[0];
                v46->i32[0] = LODWORD(v591);
                *(_DWORD *)uint64_t v38 = v592;
              }
            }
            else
            {
              double v593 = PDAcolorburnPDA(v46->f32[0], 1.0, *(float *)v6.i32, v19);
              v6.i32[0] = v691.i32[0];
              v46->i32[0] = LODWORD(v593);
            }
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
            v38 += 4 * v680;
            LODWORD(v12) = v12 - 1;
            if (!v12)
            {
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v590;
              LODWORD(v12) = v496;
              if (!v590) {
                break;
              }
            }
          }
          goto LABEL_1227;
        case 20:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v594 = v694[0];
          float v595 = (float)(*(float *)v6.i32 + *(float *)v6.i32) - v19;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v38 <= 0.0)
              {
                v46->i32[0] = v6.i32[0];
                *(float *)uint64_t v38 = v19;
              }
              else
              {
                float v596 = PDAsoftlightPDA(v46->f32[0], *(float *)v38, *(float *)v6.i32, v19);
                v5.i32[0] = v689.i32[0];
                v6.i32[0] = v691.i32[0];
                v46->f32[0] = v596;
                *(_DWORD *)uint64_t v38 = v597;
              }
            }
            else
            {
              float v598 = v46->f32[0];
              float v599 = (float)((float)(*(float *)v6.i32 * v46->f32[0]) + (float)(*(float *)v6.i32 * v46->f32[0]))
                   - (float)(v595 * (float)(v598 * v598));
              if (v599 < 0.0) {
                float v599 = 0.0;
              }
              float v600 = v599 + (float)(v598 * *(float *)v5.i32);
              if (v19 == 1.0) {
                float v600 = v599;
              }
              v46->f32[0] = v600;
            }
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
            v38 += 4 * v680;
            LODWORD(v12) = v12 - 1;
            if (!v12)
            {
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v594;
              LODWORD(v12) = v496;
              if (!v594) {
                break;
              }
            }
          }
          goto LABEL_1227;
        case 21:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v601 = v694[0];
          float v602 = *(float *)v6.i32 * 0.0;
          float v603 = *(float *)v6.i32 + *(float *)v6.i32;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v38 <= 0.0)
              {
                v46->i32[0] = v6.i32[0];
                *(float *)uint64_t v38 = v19;
              }
              else
              {
                float v604 = PDAhardlightPDA(v46->f32[0], *(float *)v38, *(float *)v6.i32, v19);
                v5.i32[0] = v689.i32[0];
                v6.i32[0] = v691.i32[0];
                v46->f32[0] = v604;
                *(_DWORD *)uint64_t v38 = v605;
              }
            }
            else
            {
              float v606 = (float)(*(float *)v6.i32 * v46->f32[0]) + (float)(*(float *)v6.i32 * v46->f32[0]);
              float v607 = (float)((float)(v603 + (float)(v46->f32[0] * (float)(v19 + 1.0))) - v606) - v19;
              if (*(float *)v6.i32 <= (float)(v19 * 0.5)) {
                float v607 = (float)(v602 + (float)(v46->f32[0] * *(float *)v5.i32)) + v606;
              }
              v46->f32[0] = v607;
            }
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
            v38 += 4 * v680;
            LODWORD(v12) = v12 - 1;
            if (!v12)
            {
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
              v38 += 4 * v39;
              --v601;
              LODWORD(v12) = v496;
              if (!v601) {
                break;
              }
            }
          }
LABEL_1227:
          v694[0] = 0;
          int v9 = v649;
          unint64_t v21 = v678;
          goto LABEL_1331;
        case 22:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v608 = v694[0];
          while (1)
          {
            int v609 = v12;
            do
            {
              if (v8)
              {
                float v610 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                  goto LABEL_1239;
                }
              }
              else
              {
                float v610 = 1.0;
              }
              float v611 = v19 * v46->f32[0];
              float v612 = (float)(*(float *)v6.i32 + v46->f32[0]) - v611;
              float v613 = v611 - (float)(*(float *)v6.i32 * v610);
              float v614 = v612 - (float)(*(float *)v6.i32 * v610);
              if (v613 < 0.0) {
                float v613 = -v613;
              }
              v46->f32[0] = v614 + v613;
              if (v8) {
                *(float *)uint64_t v38 = (float)(v19 + v610) - (float)(v610 * v19);
              }
LABEL_1239:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v609;
            }
            while (v609);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v608) {
              goto LABEL_1330;
            }
          }
        case 23:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v615 = v694[0];
          do
          {
            int v616 = v12;
            do
            {
              if (v8)
              {
                float v617 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                }
                else
                {
                  v46->f32[0] = (float)(*(float *)v6.i32 + v46->f32[0])
                              + (float)((float)(*(float *)v6.i32 * v46->f32[0]) * -2.0);
                  *(float *)uint64_t v38 = (float)(v19 + v617) - (float)(v617 * v19);
                }
              }
              else
              {
                v46->f32[0] = (float)(*(float *)v6.i32 + v46->f32[0])
                            + (float)((float)(*(float *)v6.i32 * v46->f32[0]) * -2.0);
              }
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v616;
            }
            while (v616);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            --v615;
          }
          while (v615);
          goto LABEL_1330;
        case 24:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v618 = v694[0];
          while (1)
          {
            int v619 = v12;
            do
            {
              if (v8)
              {
                float v620 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                  goto LABEL_1267;
                }
              }
              else
              {
                float v620 = 1.0;
              }
              float v621 = v46->f32[0];
              if (v19 == 1.0)
              {
                float v622 = 0.0;
              }
              else
              {
                float v621 = v19 * v46->f32[0];
                float v622 = v46->f32[0] - v621;
              }
              if (v620 != 1.0) {
                float v622 = (float)(*(float *)v6.i32 + v622) - (float)(*(float *)v6.i32 * v620);
              }
              v46->f32[0] = v621 + v622;
              if (v8) {
                *(float *)uint64_t v38 = (float)(v19 + v620) - (float)(v19 * v620);
              }
LABEL_1267:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v619;
            }
            while (v619);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v618) {
              goto LABEL_1330;
            }
          }
        case 25:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v623 = v694[0];
          while (1)
          {
            int v624 = v12;
            do
            {
              if (v8)
              {
                float v625 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                  goto LABEL_1284;
                }
              }
              else
              {
                float v625 = 1.0;
              }
              float v626 = v46->f32[0];
              if (v19 == 1.0)
              {
                float v627 = 0.0;
              }
              else
              {
                float v626 = v19 * v46->f32[0];
                float v627 = v46->f32[0] - v626;
              }
              if (v625 != 1.0) {
                float v627 = (float)(*(float *)v6.i32 + v627) - (float)(*(float *)v6.i32 * v625);
              }
              v46->f32[0] = v626 + v627;
              if (v8) {
                *(float *)uint64_t v38 = (float)(v19 + v625) - (float)(v19 * v625);
              }
LABEL_1284:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v624;
            }
            while (v624);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v623) {
              goto LABEL_1330;
            }
          }
        case 26:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v628 = v694[0];
          while (1)
          {
            int v629 = v12;
            do
            {
              if (v8)
              {
                float v630 = *(float *)v38;
                if (*(float *)v38 <= 0.0)
                {
                  v46->i32[0] = v6.i32[0];
                  *(float *)uint64_t v38 = v19;
                  goto LABEL_1300;
                }
              }
              else
              {
                float v630 = 1.0;
              }
              float v631 = v46->f32[0];
              float v632 = *(float *)v6.i32 - (float)(*(float *)v6.i32 * v630);
              if (v630 == 1.0) {
                float v632 = 0.0;
              }
              float v633 = (float)(v631 + v632) - (float)(v19 * v631);
              if (v19 != 1.0)
              {
                float v631 = v19 * v631;
                float v632 = v633;
              }
              v46->f32[0] = v631 + v632;
              if (v8) {
                *(float *)uint64_t v38 = (float)(v19 + v630) - (float)(v19 * v630);
              }
LABEL_1300:
              uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
              v38 += 4 * v680;
              --v629;
            }
            while (v629);
            uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
            v38 += 4 * v39;
            if (!--v628) {
              goto LABEL_1330;
            }
          }
        case 27:
          if (v19 <= 0.0) {
            goto LABEL_1331;
          }
          int v634 = v694[0];
          break;
        default:
          goto LABEL_1332;
      }
LABEL_1305:
      int v635 = v12;
      while (v8)
      {
        float v636 = *(float *)v38;
        if (*(float *)v38 > 0.0) {
          goto LABEL_1310;
        }
        v46->i32[0] = v6.i32[0];
        *(float *)uint64_t v38 = v19;
LABEL_1317:
        uint64_t v46 = (float32x4_t *)((char *)v46 + 4);
        v38 += 4 * v680;
        if (!--v635)
        {
          uint64_t v46 = (float32x4_t *)((char *)v46 + 4 * v36);
          v38 += 4 * v39;
          if (!--v634) {
            goto LABEL_1330;
          }
          goto LABEL_1305;
        }
      }
      float v636 = 1.0;
LABEL_1310:
      float v637 = v46->f32[0] - (float)(v19 * v46->f32[0]);
      if (v19 == 1.0) {
        float v637 = 0.0;
      }
      float v638 = *(float *)v6.i32 * v636;
      if (v636 == 1.0) {
        float v638 = *(float *)v6.i32;
      }
      else {
        float v637 = (float)(*(float *)v6.i32 + v637) - (float)(*(float *)v6.i32 * v636);
      }
      v46->f32[0] = v638 + v637;
      if (v8) {
        *(float *)uint64_t v38 = (float)(v19 + v636) - (float)(v19 * v636);
      }
      goto LABEL_1317;
    }
    v704[0] = *(_DWORD *)(v3 + 4);
    v694[0] = v14;
    uint64_t v25 = *(int *)(v3 + 12);
    uint64_t v24 = *(int *)(v3 + 16);
    unint64_t v26 = (unint64_t)*(int *)(v3 + 28) >> 2;
    if (v8)
    {
      unint64_t v27 = (unint64_t)*(int *)(v3 + 32) >> 2;
      v654 = (char *)(v8 + 4 * (v25 + v27 * v24));
      uint64_t v28 = 0xFFFFFFFFLL;
    }
    else
    {
      v654 = 0;
      unint64_t v27 = 0;
      uint64_t v28 = 0;
    }
    uint64_t v40 = *(float **)(v3 + 88);
    unint64_t v653 = *(void *)(v3 + 40) + 4 * (v25 + v24 * v26);
    int v41 = *(_DWORD *)(v3 + 56);
    int v42 = *(_DWORD *)(v3 + 60);
    unint64_t v677 = (unint64_t)*(int *)(v3 + 76) >> 2;
    if (v18 == 256)
    {
      if (v7)
      {
        unint64_t v681 = (unint64_t)*(int *)(v3 + 80) >> 2;
        v7 += 4 * v41 + 4 * v681 * v42;
        uint64_t v43 = 0xFFFFFFFFLL;
      }
      else
      {
        unint64_t v681 = 0;
        uint64_t v43 = 0;
      }
      v40 += v41 + v42 * v677;
      if (v677 == v26 && (uint64_t)(v653 - (void)v40) >= 1)
      {
        if (v12 >= (v653 - (unint64_t)v40) >> 2)
        {
          v653 += 4 * v13;
          v40 += v13;
          v654 += 4 * (v28 & v13);
          int v55 = -1;
          unint64_t v677 = (unint64_t)*(int *)(v3 + 28) >> 2;
          v7 += 4 * (v43 & v13);
          goto LABEL_48;
        }
        unint64_t v54 = &v40[v26 * v15];
        if (v653 <= (unint64_t)&v54[v13])
        {
          v653 += 4 * v26 * v15;
          unint64_t v26 = -(uint64_t)v26;
          v654 += 4 * v27 * v15;
          unint64_t v27 = -(uint64_t)v27;
          v7 += 4 * v681 * v15;
          v28 &= 1u;
          unint64_t v681 = -(uint64_t)v681;
          v43 &= 1u;
          int v55 = 1;
          uint64_t v40 = v54;
          unint64_t v677 = v26;
          goto LABEL_48;
        }
      }
      v28 &= 1u;
      v43 &= 1u;
      int v55 = 1;
LABEL_48:
      int v650 = *(_DWORD *)(v3 + 56);
      int v651 = *(_DWORD *)(v3 + 60);
      if (v16)
      {
        uint64_t v690 = v43;
        uint64_t v692 = v28;
        v679 = 0;
        v676 = 0;
        unint64_t v56 = -1;
        unint64_t v44 = v677;
        int v656 = v681;
        goto LABEL_53;
      }
      unint64_t v61 = v55 * (int)v12;
      unint64_t v688 = v27 - (int)v28 * (int)v12;
      unint64_t v56 = -1;
      unint64_t v62 = v681;
      int v655 = v55;
      int v656 = v681;
      unint64_t v63 = v677;
      unint64_t v44 = v677;
LABEL_61:
      uint64_t v657 = 0;
      uint64_t v658 = (uint64_t)v40;
      v676 = 0;
      unint64_t v677 = v63 - v61;
      v679 = 0;
      unint64_t v681 = v62 - (int)v43 * (int)v12;
      uint64_t v683 = (uint64_t)v7;
      uint64_t v652 = (uint64_t)v7;
      float32x4_t v67 = (float *)v653;
      int v60 = v654;
      goto LABEL_66;
    }
    unint64_t v44 = *(unsigned int *)(v3 + 64);
    int v656 = *(_DWORD *)(v3 + 68);
    if (v7)
    {
      unint64_t v681 = (unint64_t)*(int *)(v3 + 80) >> 2;
      uint64_t v43 = 1;
    }
    else
    {
      unint64_t v681 = 0;
      uint64_t v43 = 0;
    }
    v676 = &v40[v677 * v656];
    v28 &= 1u;
    if (v16)
    {
      int v650 = *(_DWORD *)(v3 + 56);
      int v651 = *(_DWORD *)(v3 + 60);
      uint64_t v690 = v43;
      uint64_t v692 = v28;
      int v55 = 1;
      v679 = *(float **)(v3 + 88);
      unint64_t v56 = (unint64_t)v679;
LABEL_53:
      int v655 = v55;
      unint64_t v659 = v26;
      shape_enum_clip_alloc(v2, v3, (int *)v16, v55, v26, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
      uint64_t v58 = v57;
      unsigned int v59 = v7;
      uint64_t v652 = (uint64_t)v7;
      int v60 = v654;
      unint64_t v688 = v27;
      if (!v57) {
        return 1;
      }
      goto LABEL_925;
    }
    unint64_t v688 = v27 - (v28 * v12);
    if (!v40)
    {
      int v650 = *(_DWORD *)(v3 + 56);
      int v651 = *(_DWORD *)(v3 + 60);
      unint64_t v56 = 0;
      int v655 = 1;
      unint64_t v61 = v12;
      unint64_t v62 = v681;
      unint64_t v63 = (unint64_t)*(int *)(v3 + 76) >> 2;
      goto LABEL_61;
    }
    uint64_t v64 = v42 % v656;
    int v651 = v42 % v656;
    uint64_t v658 = *(void *)(v3 + 88);
    unint64_t v65 = &v40[v677 * v64];
    int v66 = v41 % (int)v44;
    uint64_t v40 = &v65[v66];
    unint64_t v56 = (unint64_t)&v65[(int)v44];
    int v650 = v66;
    v679 = v40;
    if (v7)
    {
      uint64_t v657 = 0;
      uint64_t v652 = (uint64_t)v7;
      v7 += 4 * v681 * v64 + 4 * v66;
      int v655 = 1;
      uint64_t v43 = 1;
      uint64_t v683 = (uint64_t)v7;
    }
    else
    {
      uint64_t v652 = 0;
      uint64_t v657 = 0;
      uint64_t v683 = 0;
      int v655 = 1;
    }
    float32x4_t v67 = (float *)v653;
    int v60 = v654;
    unint64_t v61 = v12;
LABEL_66:
    uint64_t v692 = v28;
    uint64_t v690 = v43;
    unint64_t v659 = v26;
    unint64_t v685 = v26 - v61;
    switch(v9)
    {
      case 0:
        unint64_t v660 = v56;
        uint64_t v69 = v685 - (int)v12;
        uint64_t v70 = &v67[-(int)v12 + 1];
        if (v655 >= 0)
        {
          uint64_t v70 = v67;
          uint64_t v69 = v685 + (int)v12;
        }
        unsigned int v71 = v694[0];
        uint64_t v72 = v694[0] - 1;
        uint64_t v73 = (char *)&v70[(v69 * v72) & (v69 >> 63)];
        if (v69 < 0) {
          uint64_t v69 = -v69;
        }
        CGBlt_fillBytes(4 * v12, v694[0], 0, v73, 4 * v69);
        if (v28)
        {
          if (v655 < 0)
          {
            uint64_t v74 = v688 - (int)v12;
            v60 += -4 * (int)v12 + 4;
          }
          else
          {
            uint64_t v74 = v688 + (int)v12;
          }
          v60 += 4 * ((v74 * v72) & (v74 >> 63));
          if (v74 < 0) {
            uint64_t v74 = -v74;
          }
          unint64_t v688 = v74;
          CGBlt_fillBytes(4 * v12, v71, 0, v60, 4 * v74);
        }
        uint64_t v40 = (float *)v658;
        goto LABEL_888;
      case 1:
        int v75 = *(unsigned __int8 *)(v11 + 1);
        if (v75 == 2)
        {
          if ((int)v12 >= 8 && (4 * v44) <= 0x40)
          {
            LODWORD(v4) = 4 * v44;
            uint8x8_t v441 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v4);
            v441.i16[0] = vaddlv_u8(v441);
            if (v441.i32[0] <= 1u)
            {
              unint64_t v660 = v56;
              unint64_t v442 = (unint64_t)v67;
              int v443 = v694[0];
              CGSFillDRAM64(v442, 4 * (v12 + v685), 4 * v12, v694[0], v658, 4 * v677, 4 * v44, v656, 4 * v650, v651);
              if (v28)
              {
                if (v690) {
                  CGSFillDRAM64((unint64_t)v60, 4 * (v12 + v688), 4 * v12, v443, v652, 4 * v681, 4 * v44, v656, 4 * v650, v651);
                }
                else {
                  CGBlt_fillBytes(4 * v12, v443, 1065353216, v60, 4 * (v12 + v688));
                }
              }
              goto LABEL_969;
            }
          }
        }
        else if (v75 == 1)
        {
          unint64_t v76 = v27;
          uint64_t v77 = (int)v12;
          unint64_t v647 = v76;
          unint64_t v660 = v56;
          if (v655 < 0)
          {
            uint64_t v78 = v677 - (int)v12;
            v40 += -(int)v12 + 1;
            uint64_t v79 = v685 - (int)v12;
            v67 += -(int)v12 + 1;
          }
          else
          {
            uint64_t v78 = v677 + (int)v12;
            uint64_t v79 = v685 + (int)v12;
          }
          int v479 = v12;
          uint64_t v480 = v694[0] - 1;
          v481 = (char *)&v40[(v78 * v480) & (v78 >> 63)];
          if (v78 >= 0) {
            unint64_t v482 = v78;
          }
          else {
            unint64_t v482 = -v78;
          }
          v483 = (char *)&v67[(v79 * v480) & (v79 >> 63)];
          if (v79 >= 0) {
            LODWORD(v484) = v79;
          }
          else {
            uint64_t v484 = -v79;
          }
          int v485 = v479;
          int v486 = 4 * v479;
          unint64_t v677 = v482;
          int v686 = v694[0];
          CGBlt_copyBytes(4 * v479, v694[0], v481, v483, 4 * v482, 4 * v484);
          if (v28)
          {
            uint64_t v40 = (float *)v658;
            if (v690)
            {
              uint64_t v487 = v681 - v77;
              v488 = &v7[-4 * v485 + 4];
              uint64_t v489 = v688 - v77;
              v490 = &v60[-4 * v485 + 4];
              if (v655 >= 0)
              {
                v488 = v7;
                v490 = v60;
                uint64_t v487 = v681 + v77;
                uint64_t v489 = v688 + v77;
              }
              int v7 = &v488[4 * ((v487 * v480) & (v487 >> 63))];
              if (v487 >= 0) {
                unint64_t v491 = v487;
              }
              else {
                unint64_t v491 = -v487;
              }
              int v60 = &v490[4 * ((v489 * v480) & (v489 >> 63))];
              if (v489 >= 0) {
                uint64_t v492 = v489;
              }
              else {
                uint64_t v492 = -v489;
              }
              unint64_t v681 = v491;
              unint64_t v688 = v492;
              CGBlt_copyBytes(v486, v686, v7, v60, 4 * v491, 4 * v492);
            }
            else
            {
              uint64_t v493 = v688 - v77;
              v494 = &v60[-4 * v485 + 4];
              if (v655 >= 0)
              {
                v494 = v60;
                uint64_t v493 = v688 + v77;
              }
              uint64_t v495 = (v493 * v480) & (v493 >> 63);
              int v60 = &v494[4 * v495];
              if (v493 < 0) {
                uint64_t v493 = -v493;
              }
              unint64_t v688 = v493;
              CGBlt_fillBytes(v486, v686, 1065353216, &v494[4 * v495], 4 * v493);
            }
            unint64_t v27 = v647;
            goto LABEL_888;
          }
          unint64_t v27 = v647;
LABEL_969:
          uint64_t v40 = (float *)v658;
LABEL_888:
          uint64_t v58 = v657;
          unint64_t v56 = v660;
          goto LABEL_734;
        }
        if (v28)
        {
          uint64_t v444 = 4 * (int)v28;
          uint64_t v445 = 4 * v655;
          if (v43)
          {
            uint64_t v446 = (int)v43;
            int v447 = v694[0];
            unsigned int v59 = (char *)v683;
            uint64_t v82 = v679;
            do
            {
              int v448 = v12;
              do
              {
                *float32x4_t v67 = *v40;
                *(_DWORD *)int v60 = *(_DWORD *)v7;
                v449 = &v40[v655];
                if ((unint64_t)v449 >= v56) {
                  uint64_t v450 = -(uint64_t)(int)v44;
                }
                else {
                  uint64_t v450 = 0;
                }
                v7 += 4 * v446 + 4 * v450;
                uint64_t v40 = &v449[v450];
                v60 += v444;
                float32x4_t v67 = (float *)((char *)v67 + v445);
                --v448;
              }
              while (v448);
              if (v676)
              {
                v451 = &v82[v677];
                if (v451 >= v676) {
                  uint64_t v452 = -(uint64_t)(v681 * v656);
                }
                else {
                  uint64_t v452 = 0;
                }
                v59 += 4 * v681 + 4 * v452;
                if (v451 >= v676) {
                  uint64_t v453 = -(uint64_t)(v677 * v656);
                }
                else {
                  uint64_t v453 = 0;
                }
                uint64_t v82 = &v451[v453];
                v56 += 4 * v453 + 4 * v677;
                int v7 = v59;
                uint64_t v40 = v82;
              }
              else
              {
                v40 += v677;
                v7 += 4 * v681;
              }
              v67 += v685;
              v60 += 4 * v688;
              --v447;
            }
            while (v447);
LABEL_882:
            v679 = v82;
            goto LABEL_923;
          }
          int v461 = v694[0];
          unsigned int v59 = (char *)v683;
          v388 = v679;
          do
          {
            int v462 = v12;
            do
            {
              *float32x4_t v67 = *v40;
              *(_DWORD *)int v60 = 1065353216;
              v463 = &v40[v655];
              if ((unint64_t)v463 >= v56) {
                uint64_t v464 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v464 = 0;
              }
              v7 += 4 * v464;
              uint64_t v40 = &v463[v464];
              v60 += v444;
              float32x4_t v67 = (float *)((char *)v67 + v445);
              --v462;
            }
            while (v462);
            if (v676)
            {
              v465 = &v388[v677];
              if (v465 >= v676) {
                uint64_t v466 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v466 = 0;
              }
              v59 += 4 * v681 + 4 * v466;
              if (v465 >= v676) {
                uint64_t v467 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v467 = 0;
              }
              v388 = &v465[v467];
              v56 += 4 * v467 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v388;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            --v461;
          }
          while (v461);
        }
        else
        {
          int v454 = v694[0];
          unsigned int v59 = (char *)v683;
          v388 = v679;
          do
          {
            int v455 = v12;
            do
            {
              *float32x4_t v67 = *v40;
              v456 = &v40[v655];
              if ((unint64_t)v456 >= v56) {
                uint64_t v457 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v457 = 0;
              }
              v7 += 4 * (int)v43 + 4 * v457;
              uint64_t v40 = &v456[v457];
              v67 += v655;
              --v455;
            }
            while (v455);
            if (v676)
            {
              v458 = &v388[v677];
              if (v458 >= v676) {
                uint64_t v459 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v459 = 0;
              }
              v59 += 4 * v681 + 4 * v459;
              if (v458 >= v676) {
                uint64_t v460 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v460 = 0;
              }
              v388 = &v458[v460];
              v56 += 4 * v460 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v388;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            --v454;
          }
          while (v454);
        }
LABEL_922:
        v679 = v388;
LABEL_923:
        v694[0] = 0;
        uint64_t v58 = v657;
        uint64_t v40 = (float *)v658;
        if (!v657) {
          return 1;
        }
        goto LABEL_924;
      case 2:
        uint64_t v80 = (int)v43;
        if (v28)
        {
          int v81 = v694[0];
          unsigned int v59 = (char *)v683;
          uint64_t v82 = v679;
          while (1)
          {
            int v83 = v12;
            do
            {
              float v84 = *(float *)v7;
              if (*(float *)v7 >= 1.0)
              {
                *float32x4_t v67 = *v40;
                float v85 = *(float *)v7;
              }
              else
              {
                if (v84 <= 0.0) {
                  goto LABEL_86;
                }
                *float32x4_t v67 = *v40 + (float)(*v67 * (float)(1.0 - v84));
                float v85 = v84 + (float)(*(float *)v60 * (float)(1.0 - v84));
              }
              *(float *)int v60 = v85;
LABEL_86:
              unint64_t v86 = &v40[v655];
              if ((unint64_t)v86 >= v56) {
                uint64_t v87 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v87 = 0;
              }
              v7 += 4 * v80 + 4 * v87;
              uint64_t v40 = &v86[v87];
              v60 += 4 * (int)v28;
              v67 += v655;
              --v83;
            }
            while (v83);
            if (v676)
            {
              float v88 = &v82[v677];
              if (v88 >= v676) {
                uint64_t v89 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v89 = 0;
              }
              v59 += 4 * v681 + 4 * v89;
              if (v88 >= v676) {
                uint64_t v90 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v90 = 0;
              }
              uint64_t v82 = &v88[v90];
              v56 += 4 * v90 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v82;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            if (!--v81) {
              goto LABEL_882;
            }
          }
        }
        int v387 = v694[0];
        unsigned int v59 = (char *)v683;
        v388 = v679;
LABEL_738:
        int v389 = v12;
        while (1)
        {
          float v390 = *(float *)v7;
          if (*(float *)v7 >= 1.0) {
            break;
          }
          if (v390 > 0.0)
          {
            float v391 = *v40 + (float)(*v67 * (float)(1.0 - v390));
LABEL_743:
            *float32x4_t v67 = v391;
          }
          v392 = &v40[v655];
          if ((unint64_t)v392 >= v56) {
            uint64_t v393 = -(uint64_t)(int)v44;
          }
          else {
            uint64_t v393 = 0;
          }
          v7 += 4 * (int)v43 + 4 * v393;
          uint64_t v40 = &v392[v393];
          v67 += v655;
          if (!--v389)
          {
            if (v676)
            {
              v394 = &v388[v677];
              if (v394 >= v676) {
                uint64_t v395 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v395 = 0;
              }
              v59 += 4 * v681 + 4 * v395;
              if (v394 >= v676) {
                uint64_t v396 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v396 = 0;
              }
              v388 = &v394[v396];
              v56 += 4 * v396 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v388;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            if (!--v387) {
              goto LABEL_922;
            }
            goto LABEL_738;
          }
        }
        float v391 = *v40;
        goto LABEL_743;
      case 3:
        if (v43)
        {
          uint64_t v91 = (int)v43;
          int v92 = v694[0];
          unsigned int v59 = (char *)v683;
          uint64_t v82 = v679;
          do
          {
            int v93 = v12;
            do
            {
              float v94 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *(_DWORD *)int v60 = 0;
                *float32x4_t v67 = 0.0;
              }
              else
              {
                float v95 = *v40;
                if (v94 >= 1.0)
                {
                  *float32x4_t v67 = v95;
                  float v96 = *(float *)v7;
                }
                else
                {
                  *float32x4_t v67 = v94 * v95;
                  float v96 = v94 * *(float *)v7;
                }
                *(float *)int v60 = v96;
              }
              uint64_t v97 = &v40[v655];
              if ((unint64_t)v97 >= v56) {
                uint64_t v98 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v98 = 0;
              }
              v7 += 4 * v91 + 4 * v98;
              uint64_t v40 = &v97[v98];
              v60 += 4 * (int)v28;
              v67 += v655;
              --v93;
            }
            while (v93);
            if (v676)
            {
              uint64_t v99 = &v82[v677];
              if (v99 >= v676) {
                uint64_t v100 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v100 = 0;
              }
              v59 += 4 * v681 + 4 * v100;
              if (v99 >= v676) {
                uint64_t v101 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v101 = 0;
              }
              uint64_t v82 = &v99[v101];
              v56 += 4 * v101 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v82;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            --v92;
          }
          while (v92);
          goto LABEL_882;
        }
        int v397 = v694[0];
        unsigned int v59 = (char *)v683;
        v114 = v679;
        do
        {
          int v398 = v12;
          do
          {
            float v399 = *(float *)v60;
            float v400 = 0.0;
            if (*(float *)v60 > 0.0)
            {
              float v400 = *v40;
              BOOL v401 = v399 < 1.0;
              float v402 = v399 * *v40;
              if (v401) {
                float v400 = v402;
              }
            }
            *float32x4_t v67 = v400;
            v403 = &v40[v655];
            if ((unint64_t)v403 >= v56) {
              uint64_t v404 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v404 = 0;
            }
            v7 += 4 * v404;
            uint64_t v40 = &v403[v404];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v398;
          }
          while (v398);
          if (v676)
          {
            v405 = &v114[v677];
            if (v405 >= v676) {
              uint64_t v406 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v406 = 0;
            }
            v59 += 4 * v681 + 4 * v406;
            if (v405 >= v676) {
              uint64_t v407 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v407 = 0;
            }
            v114 = &v405[v407];
            v56 += 4 * v407 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v114;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          --v397;
        }
        while (v397);
LABEL_779:
        v679 = v114;
        goto LABEL_923;
      case 4:
        int v102 = v694[0];
        unsigned int v59 = (char *)v683;
        uint64_t v103 = v679;
        do
        {
          int v104 = v12;
          do
          {
            float v105 = 1.0 - *(float *)v60;
            if (v105 <= 0.0)
            {
              *(_DWORD *)int v60 = 0;
              *float32x4_t v67 = 0.0;
            }
            else
            {
              if (v105 >= 1.0)
              {
                if (v43) {
                  float v107 = *(float *)v7;
                }
                else {
                  float v107 = 1.0;
                }
              }
              else
              {
                *float32x4_t v67 = v105 * *v40;
                if (v43) {
                  float v106 = *(float *)v7;
                }
                else {
                  float v106 = 1.0;
                }
                float v107 = v105 * v106;
              }
              *(float *)int v60 = v107;
            }
            uint64_t v108 = &v40[v655];
            if ((unint64_t)v108 >= v56) {
              uint64_t v109 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v109 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v109;
            uint64_t v40 = &v108[v109];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v104;
          }
          while (v104);
          if (v676)
          {
            uint64_t v110 = &v103[v677];
            if (v110 >= v676) {
              uint64_t v111 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v111 = 0;
            }
            v59 += 4 * v681 + 4 * v111;
            if (v110 >= v676) {
              uint64_t v112 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v112 = 0;
            }
            uint64_t v103 = &v110[v112];
            v56 += 4 * v112 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v103;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          --v102;
        }
        while (v102);
        goto LABEL_321;
      case 5:
        int v113 = v694[0];
        unsigned int v59 = (char *)v683;
        v114 = v679;
        do
        {
          int v115 = v12;
          do
          {
            float v116 = *(float *)v60;
            float v117 = *(float *)v7;
            float v118 = 1.0 - *(float *)v7;
            *float32x4_t v67 = (float)(v118 * *v67) + (float)(*v40 * *(float *)v60);
            *(float *)int v60 = (float)(v116 * v118) + (float)(v117 * v116);
            uint64_t v119 = &v40[v655];
            if ((unint64_t)v119 >= v56) {
              uint64_t v120 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v120 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v120;
            uint64_t v40 = &v119[v120];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v115;
          }
          while (v115);
          if (v676)
          {
            uint64_t v121 = &v114[v677];
            if (v121 >= v676) {
              uint64_t v122 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v122 = 0;
            }
            v59 += 4 * v681 + 4 * v122;
            if (v121 >= v676) {
              uint64_t v123 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v123 = 0;
            }
            v114 = &v121[v123];
            v56 += 4 * v123 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v114;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          --v113;
        }
        while (v113);
        goto LABEL_779;
      case 6:
        int v124 = v694[0];
        unsigned int v59 = (char *)v683;
        uint64_t v103 = v679;
        while (1)
        {
          int v125 = v12;
          do
          {
            float v126 = *(float *)v60;
            float v127 = 1.0 - *(float *)v60;
            if (v127 >= 1.0)
            {
              *float32x4_t v67 = *v40;
              if (v43) {
                float v129 = *(float *)v7;
              }
              else {
                float v129 = 1.0;
              }
            }
            else
            {
              if (v127 <= 0.0) {
                goto LABEL_182;
              }
              *float32x4_t v67 = *v67 + (float)(*v40 * v127);
              if (v43) {
                float v128 = *(float *)v7;
              }
              else {
                float v128 = 1.0;
              }
              float v129 = v126 + (float)(v128 * v127);
            }
            *(float *)int v60 = v129;
LABEL_182:
            v130 = &v40[v655];
            if ((unint64_t)v130 >= v56) {
              uint64_t v131 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v131 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v131;
            uint64_t v40 = &v130[v131];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v125;
          }
          while (v125);
          if (v676)
          {
            v132 = &v103[v677];
            if (v132 >= v676) {
              uint64_t v133 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v133 = 0;
            }
            v59 += 4 * v681 + 4 * v133;
            if (v132 >= v676) {
              uint64_t v134 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v134 = 0;
            }
            uint64_t v103 = &v132[v134];
            v56 += 4 * v134 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v103;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v124)
          {
LABEL_321:
            v679 = v103;
            goto LABEL_923;
          }
        }
      case 7:
        uint64_t v135 = (int)v43;
        if (v28)
        {
          int v136 = v694[0];
          unsigned int v59 = (char *)v683;
          uint64_t v82 = v679;
          do
          {
            int v137 = v12;
            do
            {
              float v138 = *(float *)v7;
              if (*(float *)v7 <= 0.0)
              {
                *(_DWORD *)int v60 = 0;
                *float32x4_t v67 = 0.0;
              }
              else if (v138 < 1.0)
              {
                *float32x4_t v67 = v138 * *v67;
                *(float *)int v60 = v138 * *(float *)v60;
              }
              v139 = &v40[v655];
              if ((unint64_t)v139 >= v56) {
                uint64_t v140 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v140 = 0;
              }
              v7 += 4 * v135 + 4 * v140;
              uint64_t v40 = &v139[v140];
              v60 += 4 * (int)v28;
              v67 += v655;
              --v137;
            }
            while (v137);
            if (v676)
            {
              v141 = &v82[v677];
              if (v141 >= v676) {
                uint64_t v142 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v142 = 0;
              }
              v59 += 4 * v681 + 4 * v142;
              if (v141 >= v676) {
                uint64_t v143 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v143 = 0;
              }
              uint64_t v82 = &v141[v143];
              v56 += 4 * v143 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v82;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            --v136;
          }
          while (v136);
          goto LABEL_882;
        }
        int v408 = v694[0];
        unsigned int v59 = (char *)v683;
        v388 = v679;
LABEL_781:
        int v409 = v12;
        while (1)
        {
          float v410 = *(float *)v7;
          float v411 = 0.0;
          if (*(float *)v7 <= 0.0) {
            goto LABEL_785;
          }
          if (v410 < 1.0) {
            break;
          }
LABEL_786:
          v412 = &v40[v655];
          if ((unint64_t)v412 >= v56) {
            uint64_t v413 = -(uint64_t)(int)v44;
          }
          else {
            uint64_t v413 = 0;
          }
          v7 += 4 * (int)v43 + 4 * v413;
          uint64_t v40 = &v412[v413];
          v67 += v655;
          if (!--v409)
          {
            if (v676)
            {
              v414 = &v388[v677];
              if (v414 >= v676) {
                uint64_t v415 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v415 = 0;
              }
              v59 += 4 * v681 + 4 * v415;
              if (v414 >= v676) {
                uint64_t v416 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v416 = 0;
              }
              v388 = &v414[v416];
              v56 += 4 * v416 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v388;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            if (!--v408) {
              goto LABEL_922;
            }
            goto LABEL_781;
          }
        }
        float v411 = v410 * *v67;
LABEL_785:
        *float32x4_t v67 = v411;
        goto LABEL_786;
      case 8:
        uint64_t v144 = (int)v43;
        if (v28)
        {
          int v145 = v694[0];
          unsigned int v59 = (char *)v683;
          uint64_t v82 = v679;
          do
          {
            int v146 = v12;
            do
            {
              float v147 = 1.0 - *(float *)v7;
              if (v147 <= 0.0)
              {
                *(_DWORD *)int v60 = 0;
                *float32x4_t v67 = 0.0;
              }
              else if (v147 < 1.0)
              {
                *float32x4_t v67 = v147 * *v67;
                *(float *)int v60 = v147 * *(float *)v60;
              }
              v148 = &v40[v655];
              if ((unint64_t)v148 >= v56) {
                uint64_t v149 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v149 = 0;
              }
              v7 += 4 * v144 + 4 * v149;
              uint64_t v40 = &v148[v149];
              v60 += 4 * (int)v28;
              v67 += v655;
              --v146;
            }
            while (v146);
            if (v676)
            {
              v150 = &v82[v677];
              if (v150 >= v676) {
                uint64_t v151 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v151 = 0;
              }
              v59 += 4 * v681 + 4 * v151;
              if (v150 >= v676) {
                uint64_t v152 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v152 = 0;
              }
              uint64_t v82 = &v150[v152];
              v56 += 4 * v152 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v82;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            --v145;
          }
          while (v145);
          goto LABEL_882;
        }
        int v417 = v694[0];
        unsigned int v59 = (char *)v683;
        v388 = v679;
LABEL_802:
        int v418 = v12;
        while (1)
        {
          float v419 = 1.0 - *(float *)v7;
          float v420 = 0.0;
          if (v419 <= 0.0) {
            goto LABEL_806;
          }
          if (v419 < 1.0) {
            break;
          }
LABEL_807:
          v421 = &v40[v655];
          if ((unint64_t)v421 >= v56) {
            uint64_t v422 = -(uint64_t)(int)v44;
          }
          else {
            uint64_t v422 = 0;
          }
          v7 += 4 * (int)v43 + 4 * v422;
          uint64_t v40 = &v421[v422];
          v67 += v655;
          if (!--v418)
          {
            if (v676)
            {
              v423 = &v388[v677];
              if (v423 >= v676) {
                uint64_t v424 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v424 = 0;
              }
              v59 += 4 * v681 + 4 * v424;
              if (v423 >= v676) {
                uint64_t v425 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v425 = 0;
              }
              v388 = &v423[v425];
              v56 += 4 * v425 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v388;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            if (!--v417) {
              goto LABEL_922;
            }
            goto LABEL_802;
          }
        }
        float v420 = v419 * *v67;
LABEL_806:
        *float32x4_t v67 = v420;
        goto LABEL_807;
      case 9:
        int v153 = v694[0];
        unsigned int v59 = (char *)v683;
        v114 = v679;
        do
        {
          int v154 = v12;
          do
          {
            float v155 = *(float *)v60;
            float v156 = *(float *)v7;
            float v157 = 1.0 - *(float *)v60;
            *float32x4_t v67 = (float)(*(float *)v7 * *v67) + (float)(*v40 * v157);
            *(float *)int v60 = (float)(v155 * v156) + (float)(v156 * v157);
            v158 = &v40[v655];
            if ((unint64_t)v158 >= v56) {
              uint64_t v159 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v159 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v159;
            uint64_t v40 = &v158[v159];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v154;
          }
          while (v154);
          if (v676)
          {
            v160 = &v114[v677];
            if (v160 >= v676) {
              uint64_t v161 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v161 = 0;
            }
            v59 += 4 * v681 + 4 * v161;
            if (v160 >= v676) {
              uint64_t v162 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v162 = 0;
            }
            v114 = &v160[v162];
            v56 += 4 * v162 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v114;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          --v153;
        }
        while (v153);
        goto LABEL_779;
      case 10:
        int v163 = v694[0];
        unsigned int v59 = (char *)v683;
        v114 = v679;
        do
        {
          int v164 = v12;
          do
          {
            float v165 = *(float *)v60;
            float v166 = *(float *)v7;
            float v167 = 1.0 - *(float *)v60;
            float v168 = 1.0 - *(float *)v7;
            *float32x4_t v67 = (float)(v168 * *v67) + (float)(*v40 * v167);
            *(float *)int v60 = (float)(v165 * v168) + (float)(v166 * v167);
            v169 = &v40[v655];
            if ((unint64_t)v169 >= v56) {
              uint64_t v170 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v170 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v170;
            uint64_t v40 = &v169[v170];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v164;
          }
          while (v164);
          if (v676)
          {
            v171 = &v114[v677];
            if (v171 >= v676) {
              uint64_t v172 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v172 = 0;
            }
            v59 += 4 * v681 + 4 * v172;
            if (v171 >= v676) {
              uint64_t v173 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v173 = 0;
            }
            v114 = &v171[v173];
            v56 += 4 * v173 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v114;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          --v163;
        }
        while (v163);
        goto LABEL_779;
      case 11:
        if (v28)
        {
          int v174 = v694[0];
          unsigned int v59 = (char *)v683;
          uint64_t v103 = v679;
          do
          {
            int v175 = v12;
            do
            {
              if (v43) {
                float v176 = *(float *)v7;
              }
              else {
                float v176 = 1.0;
              }
              float v177 = *(float *)v60 + v176;
              float v178 = (float)(*(float *)v60 - *v67) + (float)(v176 - *v40);
              if (v177 <= 1.0) {
                float v179 = v177;
              }
              else {
                float v179 = 1.0;
              }
              *(float *)int v60 = v179;
              *float32x4_t v67 = v179 - v178;
              v180 = &v40[v655];
              if ((unint64_t)v180 >= v56) {
                uint64_t v181 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v181 = 0;
              }
              v7 += 4 * (int)v43 + 4 * v181;
              uint64_t v40 = &v180[v181];
              v60 += 4 * (int)v28;
              v67 += v655;
              --v175;
            }
            while (v175);
            if (v676)
            {
              v182 = &v103[v677];
              if (v182 >= v676) {
                uint64_t v183 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v183 = 0;
              }
              v59 += 4 * v681 + 4 * v183;
              if (v182 >= v676) {
                uint64_t v184 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v184 = 0;
              }
              uint64_t v103 = &v182[v184];
              v56 += 4 * v184 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v103;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            --v174;
          }
          while (v174);
          goto LABEL_321;
        }
        int v426 = v694[0];
        unsigned int v59 = (char *)v683;
        v388 = v679;
        do
        {
          int v427 = v12;
          do
          {
            float v428 = 1.0;
            if (v43) {
              float v428 = *(float *)v7;
            }
            *float32x4_t v67 = 1.0 - (float)((float)(1.0 - *v67) + (float)(v428 - *v40));
            v429 = &v40[v655];
            if ((unint64_t)v429 >= v56) {
              uint64_t v430 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v430 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v430;
            uint64_t v40 = &v429[v430];
            v67 += v655;
            --v427;
          }
          while (v427);
          if (v676)
          {
            v431 = &v388[v677];
            if (v431 >= v676) {
              uint64_t v432 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v432 = 0;
            }
            v59 += 4 * v681 + 4 * v432;
            if (v431 >= v676) {
              uint64_t v433 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v433 = 0;
            }
            v388 = &v431[v433];
            v56 += 4 * v433 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v388;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          --v426;
        }
        while (v426);
        goto LABEL_922;
      case 12:
        if (!v28)
        {
          int v434 = v694[0];
          unsigned int v59 = (char *)v683;
          v388 = v679;
          do
          {
            int v435 = v12;
            do
            {
              *float32x4_t v67 = *v67 + *v40;
              v436 = &v40[v655];
              if ((unint64_t)v436 >= v56) {
                uint64_t v437 = -(uint64_t)(int)v44;
              }
              else {
                uint64_t v437 = 0;
              }
              v7 += 4 * (int)v43 + 4 * v437;
              uint64_t v40 = &v436[v437];
              v67 += v655;
              --v435;
            }
            while (v435);
            if (v676)
            {
              v438 = &v388[v677];
              if (v438 >= v676) {
                uint64_t v439 = -(uint64_t)(v681 * v656);
              }
              else {
                uint64_t v439 = 0;
              }
              v59 += 4 * v681 + 4 * v439;
              if (v438 >= v676) {
                uint64_t v440 = -(uint64_t)(v677 * v656);
              }
              else {
                uint64_t v440 = 0;
              }
              v388 = &v438[v440];
              v56 += 4 * v440 + 4 * v677;
              int v7 = v59;
              uint64_t v40 = v388;
            }
            else
            {
              v40 += v677;
              v7 += 4 * v681;
            }
            v67 += v685;
            v60 += 4 * v688;
            --v434;
          }
          while (v434);
          goto LABEL_922;
        }
        int v185 = v694[0];
        unsigned int v59 = (char *)v683;
        uint64_t v103 = v679;
        do
        {
          int v186 = v12;
          do
          {
            if (v43) {
              float v187 = *(float *)v7;
            }
            else {
              float v187 = 1.0;
            }
            float v188 = *(float *)v60 + v187;
            if (v188 > 1.0) {
              float v188 = 1.0;
            }
            *float32x4_t v67 = *v67 + *v40;
            *(float *)int v60 = v188;
            v189 = &v40[v655];
            if ((unint64_t)v189 >= v56) {
              uint64_t v190 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v190 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v190;
            uint64_t v40 = &v189[v190];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v186;
          }
          while (v186);
          if (v676)
          {
            v191 = &v103[v677];
            if (v191 >= v676) {
              uint64_t v192 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v192 = 0;
            }
            v59 += 4 * v681 + 4 * v192;
            if (v191 >= v676) {
              uint64_t v193 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v193 = 0;
            }
            uint64_t v103 = &v191[v193];
            v56 += 4 * v193 + 4 * v677;
            int v7 = v59;
            uint64_t v40 = v103;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          --v185;
        }
        while (v185);
        goto LABEL_321;
      case 13:
        int v194 = v694[0];
        while (1)
        {
          int v195 = v12;
          do
          {
            float v196 = 1.0;
            float v197 = 1.0;
            if (v43)
            {
              float v197 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_337;
              }
            }
            if (v28)
            {
              float v196 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_335;
              }
            }
            float v198 = (float)(*v67 * *v40) + (float)(*v67 * (float)(1.0 - v197));
            if (v197 == 1.0) {
              float v198 = *v67 * *v40;
            }
            if (v196 != 1.0) {
              float v198 = v198 + (float)(*v40 * (float)(1.0 - v196));
            }
            if (v28)
            {
              float v197 = (float)(v197 + v196) - (float)(v196 * v197);
              *float32x4_t v67 = v198;
LABEL_335:
              *(float *)int v60 = v197;
              goto LABEL_337;
            }
            *float32x4_t v67 = v198;
LABEL_337:
            v199 = &v40[v655];
            if ((unint64_t)v199 >= v56) {
              uint64_t v200 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v200 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v200;
            uint64_t v40 = &v199[v200];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v195;
          }
          while (v195);
          if (v676)
          {
            v201 = &v679[v677];
            if (v201 >= v676) {
              uint64_t v202 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v202 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v202);
            if (v201 >= v676) {
              uint64_t v203 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v203 = 0;
            }
            uint64_t v40 = &v201[v203];
            v56 += 4 * v203 + 4 * v677;
            v683 += 4 * v681 + 4 * v202;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v194)
          {
LABEL_732:
            v694[0] = 0;
LABEL_733:
            uint64_t v40 = (float *)v658;
            uint64_t v58 = v657;
LABEL_734:
            unsigned int v59 = (char *)v683;
            if (!v58) {
              return 1;
            }
LABEL_924:
            uint64_t v693 = 0;
LABEL_925:
            uint64_t v683 = (uint64_t)v59;
            if (!shape_enum_clip_next(v58, (int *)&v693 + 1, &v693, v704, v694))
            {
              float v68 = (void *)v58;
              goto LABEL_949;
            }
            uint64_t v657 = v58;
            uint64_t v658 = (uint64_t)v40;
            if (v676)
            {
              unint64_t v26 = v659;
              float32x4_t v67 = (float *)(v653 + 4 * v659 * (int)v693 + 4 * SHIDWORD(v693));
              int v468 = ((int)v693 + *(_DWORD *)(v11 + 60)) % v656;
              unint64_t v61 = v704[0];
              int v469 = (HIDWORD(v693) + *(_DWORD *)(v11 + 56)) % (int)v44;
              v470 = &v40[v677 * v468];
              uint64_t v40 = &v470[v469];
              unint64_t v56 = (unint64_t)&v470[(int)v44];
              uint64_t v28 = v692;
              if (v692) {
                int v60 = &v654[4 * v27 * (int)v693 + 4 * SHIDWORD(v693)];
              }
              unint64_t v471 = v688;
              if (v692) {
                unint64_t v471 = v27 - v704[0];
              }
              unint64_t v688 = v471;
              if (v690) {
                uint64_t v43 = v690;
              }
              else {
                uint64_t v43 = 0;
              }
              uint64_t v472 = v683;
              if (v690) {
                uint64_t v472 = v652 + 4 * v681 * v468 + 4 * v469;
              }
              uint64_t v683 = v472;
              if (v690) {
                int v7 = (char *)(v652 + 4 * v681 * v468 + 4 * v469);
              }
              LODWORD(v12) = v704[0];
              v679 = &v470[v469];
              int v650 = (HIDWORD(v693) + *(_DWORD *)(v11 + 56)) % (int)v44;
              int v651 = ((int)v693 + *(_DWORD *)(v11 + 60)) % v656;
            }
            else
            {
              int v473 = HIDWORD(v693) * v655;
              LODWORD(v12) = v704[0];
              int v474 = v704[0] * v655;
              unint64_t v26 = v659;
              float32x4_t v67 = (float *)(v653 + 4 * v659 * (int)v693 + 4 * HIDWORD(v693) * v655);
              unint64_t v61 = v704[0] * v655;
              v40 += (int)v693 * (int)v44 + HIDWORD(v693) * v655;
              v676 = 0;
              unint64_t v677 = (int)v44 - v704[0] * v655;
              uint64_t v28 = v692;
              if (v692) {
                int v60 = &v654[4 * v27 * (int)v693 + 4 * v473];
              }
              unint64_t v475 = v688;
              uint64_t v43 = v690;
              if (v692) {
                unint64_t v475 = v27 - v474;
              }
              unint64_t v688 = v475;
              uint64_t v476 = v652 + 4 * (int)v693 * v656 + 4 * v473;
              unint64_t v477 = v656 - v474;
              if (v690) {
                int v7 = (char *)v476;
              }
              unint64_t v478 = v681;
              if (v690) {
                unint64_t v478 = v477;
              }
              unint64_t v681 = v478;
            }
            goto LABEL_66;
          }
        }
      case 14:
        int v204 = v694[0];
        while (1)
        {
          int v205 = v12;
          do
          {
            if (v43)
            {
              float v206 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_363;
              }
              if (!v28)
              {
LABEL_360:
                *float32x4_t v67 = *v67 + (float)(*v40 * (float)(1.0 - *v67));
                goto LABEL_363;
              }
            }
            else
            {
              float v206 = 1.0;
              if (!v28) {
                goto LABEL_360;
              }
            }
            if (*(float *)v60 <= 0.0)
            {
              *float32x4_t v67 = *v40;
            }
            else
            {
              float v206 = (float)(v206 + *(float *)v60) - (float)(*(float *)v60 * v206);
              *float32x4_t v67 = *v67 + (float)(*v40 * (float)(1.0 - *v67));
            }
            *(float *)int v60 = v206;
LABEL_363:
            v207 = &v40[v655];
            if ((unint64_t)v207 >= v56) {
              uint64_t v208 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v208 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v208;
            uint64_t v40 = &v207[v208];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v205;
          }
          while (v205);
          if (v676)
          {
            v209 = &v679[v677];
            if (v209 >= v676) {
              uint64_t v210 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v210 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v210);
            if (v209 >= v676) {
              uint64_t v211 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v211 = 0;
            }
            uint64_t v40 = &v209[v211];
            v56 += 4 * v211 + 4 * v677;
            v683 += 4 * v681 + 4 * v210;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v204) {
            goto LABEL_732;
          }
        }
      case 15:
        unint64_t v646 = v44;
        unint64_t v648 = v27;
        int v666 = v12;
        uint64_t v212 = v655;
        uint64_t v213 = (int)v43;
        int v214 = v694[0];
        uint64_t v215 = 4 * (int)v28;
        uint64_t v216 = -(uint64_t)(int)v44;
        uint64_t v671 = v216;
        do
        {
          int v661 = v214;
          int v217 = v666;
          do
          {
            float v218 = 1.0;
            float v219 = 1.0;
            if (!v43 || (float v219 = *(float *)v7, *(float *)v7 > 0.0))
            {
              if (v28 && (float v218 = *(float *)v60, *(float *)v60 <= 0.0))
              {
                *float32x4_t v67 = *v40;
                *(float *)int v60 = v219;
              }
              else
              {
                uint64_t v220 = v212;
                LODWORD(v28) = v692;
                *float32x4_t v67 = PDAoverlayPDA(*v67, v218, *v40, v219);
                if (v692) {
                  *(_DWORD *)int v60 = v221;
                }
                LODWORD(v43) = v690;
                uint64_t v212 = v220;
                uint64_t v216 = v671;
              }
            }
            v222 = &v40[v212];
            if ((unint64_t)v222 >= v56) {
              uint64_t v223 = v216;
            }
            else {
              uint64_t v223 = 0;
            }
            v7 += 4 * v213 + 4 * v223;
            uint64_t v40 = &v222[v223];
            v60 += v215;
            v67 += v655;
            --v217;
          }
          while (v217);
          if (v676)
          {
            v224 = &v679[v677];
            uint64_t v225 = -(uint64_t)(v681 * v656);
            if (v224 < v676) {
              uint64_t v225 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v225);
            uint64_t v226 = -(uint64_t)(v677 * v656);
            if (v224 < v676) {
              uint64_t v226 = 0;
            }
            uint64_t v40 = &v224[v226];
            v56 += 4 * v226 + 4 * v677;
            v683 += 4 * v681 + 4 * v225;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          int v214 = v661 - 1;
        }
        while (v661 != 1);
        goto LABEL_556;
      case 16:
        int v227 = v694[0];
        while (1)
        {
          int v228 = v12;
          do
          {
            float v229 = 1.0;
            float v230 = 1.0;
            if (v43)
            {
              float v230 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_418;
              }
            }
            if (v28)
            {
              float v229 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_416;
              }
            }
            float v231 = v230 * *v67;
            if ((float)(v229 * *v40) < v231) {
              float v231 = v229 * *v40;
            }
            float v232 = v231 + (float)(*v67 * (float)(1.0 - v230));
            if (v230 == 1.0) {
              float v232 = v231;
            }
            if (v229 != 1.0) {
              float v232 = v232 + (float)(*v40 * (float)(1.0 - v229));
            }
            if (v28)
            {
              float v230 = (float)(v230 + v229) - (float)(v229 * v230);
              *float32x4_t v67 = v232;
LABEL_416:
              *(float *)int v60 = v230;
              goto LABEL_418;
            }
            *float32x4_t v67 = v232;
LABEL_418:
            v233 = &v40[v655];
            if ((unint64_t)v233 >= v56) {
              uint64_t v234 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v234 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v234;
            uint64_t v40 = &v233[v234];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v228;
          }
          while (v228);
          if (v676)
          {
            v235 = &v679[v677];
            if (v235 >= v676) {
              uint64_t v236 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v236 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v236);
            if (v235 >= v676) {
              uint64_t v237 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v237 = 0;
            }
            uint64_t v40 = &v235[v237];
            v56 += 4 * v237 + 4 * v677;
            v683 += 4 * v681 + 4 * v236;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v227) {
            goto LABEL_732;
          }
        }
      case 17:
        int v238 = v694[0];
        while (1)
        {
          int v239 = v12;
          do
          {
            float v240 = 1.0;
            float v241 = 1.0;
            if (v43)
            {
              float v241 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_450;
              }
            }
            if (v28)
            {
              float v240 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_448;
              }
            }
            float v242 = v241 * *v67;
            if ((float)(v240 * *v40) > v242) {
              float v242 = v240 * *v40;
            }
            float v243 = v242 + (float)(*v67 * (float)(1.0 - v241));
            if (v241 == 1.0) {
              float v243 = v242;
            }
            if (v240 != 1.0) {
              float v243 = v243 + (float)(*v40 * (float)(1.0 - v240));
            }
            if (v28)
            {
              float v241 = (float)(v241 + v240) - (float)(v240 * v241);
              *float32x4_t v67 = v243;
LABEL_448:
              *(float *)int v60 = v241;
              goto LABEL_450;
            }
            *float32x4_t v67 = v243;
LABEL_450:
            v244 = &v40[v655];
            if ((unint64_t)v244 >= v56) {
              uint64_t v245 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v245 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v245;
            uint64_t v40 = &v244[v245];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v239;
          }
          while (v239);
          if (v676)
          {
            v246 = &v679[v677];
            if (v246 >= v676) {
              uint64_t v247 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v247 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v247);
            if (v246 >= v676) {
              uint64_t v248 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v248 = 0;
            }
            uint64_t v40 = &v246[v248];
            v56 += 4 * v248 + 4 * v677;
            v683 += 4 * v681 + 4 * v247;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v238) {
            goto LABEL_732;
          }
        }
      case 18:
        unint64_t v646 = v44;
        unint64_t v648 = v27;
        int v667 = v12;
        uint64_t v249 = v655;
        uint64_t v250 = (int)v43;
        int v251 = v694[0];
        uint64_t v252 = 4 * (int)v28;
        uint64_t v253 = -(uint64_t)(int)v44;
        uint64_t v672 = v253;
        do
        {
          int v662 = v251;
          int v254 = v667;
          do
          {
            float v255 = 1.0;
            float v256 = 1.0;
            if (!v43 || (float v256 = *(float *)v7, *(float *)v7 > 0.0))
            {
              if (v28 && (float v255 = *(float *)v60, *(float *)v60 <= 0.0))
              {
                *float32x4_t v67 = *v40;
                *(float *)int v60 = v256;
              }
              else
              {
                uint64_t v257 = v249;
                LODWORD(v28) = v692;
                *float32x4_t v67 = PDAcolordodgePDA(*v67, v255, *v40, v256);
                if (v692) {
                  *(_DWORD *)int v60 = v258;
                }
                LODWORD(v43) = v690;
                uint64_t v249 = v257;
                uint64_t v253 = v672;
              }
            }
            v259 = &v40[v249];
            if ((unint64_t)v259 >= v56) {
              uint64_t v260 = v253;
            }
            else {
              uint64_t v260 = 0;
            }
            v7 += 4 * v250 + 4 * v260;
            uint64_t v40 = &v259[v260];
            v60 += v252;
            v67 += v655;
            --v254;
          }
          while (v254);
          if (v676)
          {
            v261 = &v679[v677];
            uint64_t v262 = -(uint64_t)(v681 * v656);
            if (v261 < v676) {
              uint64_t v262 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v262);
            uint64_t v263 = -(uint64_t)(v677 * v656);
            if (v261 < v676) {
              uint64_t v263 = 0;
            }
            uint64_t v40 = &v261[v263];
            v56 += 4 * v263 + 4 * v677;
            v683 += 4 * v681 + 4 * v262;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          int v251 = v662 - 1;
        }
        while (v662 != 1);
        goto LABEL_556;
      case 19:
        unint64_t v646 = v44;
        unint64_t v648 = v27;
        int v668 = v12;
        uint64_t v264 = v655;
        uint64_t v265 = (int)v43;
        int v266 = v694[0];
        uint64_t v267 = 4 * (int)v28;
        uint64_t v268 = -(uint64_t)(int)v44;
        uint64_t v673 = v268;
        do
        {
          int v663 = v266;
          int v269 = v668;
          do
          {
            float v270 = 1.0;
            float v271 = 1.0;
            if (!v43 || (float v271 = *(float *)v7, *(float *)v7 > 0.0))
            {
              if (v28 && (float v270 = *(float *)v60, *(float *)v60 <= 0.0))
              {
                *float32x4_t v67 = *v40;
                *(float *)int v60 = v271;
              }
              else
              {
                uint64_t v272 = v264;
                double v273 = PDAcolorburnPDA(*v67, v270, *v40, v271);
                LODWORD(v28) = v692;
                *float32x4_t v67 = *(float *)&v273;
                if (v692) {
                  *(_DWORD *)int v60 = v274;
                }
                LODWORD(v43) = v690;
                uint64_t v264 = v272;
                uint64_t v268 = v673;
              }
            }
            v275 = &v40[v264];
            if ((unint64_t)v275 >= v56) {
              uint64_t v276 = v268;
            }
            else {
              uint64_t v276 = 0;
            }
            v7 += 4 * v265 + 4 * v276;
            uint64_t v40 = &v275[v276];
            v60 += v267;
            v67 += v655;
            --v269;
          }
          while (v269);
          if (v676)
          {
            v277 = &v679[v677];
            uint64_t v278 = -(uint64_t)(v681 * v656);
            if (v277 < v676) {
              uint64_t v278 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v278);
            uint64_t v279 = -(uint64_t)(v677 * v656);
            if (v277 < v676) {
              uint64_t v279 = 0;
            }
            uint64_t v40 = &v277[v279];
            v56 += 4 * v279 + 4 * v677;
            v683 += 4 * v681 + 4 * v278;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          int v266 = v663 - 1;
        }
        while (v663 != 1);
        goto LABEL_556;
      case 20:
        unint64_t v646 = v44;
        unint64_t v648 = v27;
        int v669 = v12;
        uint64_t v280 = v655;
        uint64_t v281 = (int)v43;
        int v282 = v694[0];
        uint64_t v283 = 4 * (int)v28;
        uint64_t v284 = -(uint64_t)(int)v44;
        uint64_t v674 = v284;
        do
        {
          int v664 = v282;
          int v285 = v669;
          do
          {
            float v286 = 1.0;
            float v287 = 1.0;
            if (!v43 || (float v287 = *(float *)v7, *(float *)v7 > 0.0))
            {
              if (v28 && (float v286 = *(float *)v60, *(float *)v60 <= 0.0))
              {
                *float32x4_t v67 = *v40;
                *(float *)int v60 = v287;
              }
              else
              {
                uint64_t v288 = v280;
                LODWORD(v28) = v692;
                *float32x4_t v67 = PDAsoftlightPDA(*v67, v286, *v40, v287);
                if (v692) {
                  *(_DWORD *)int v60 = v289;
                }
                LODWORD(v43) = v690;
                uint64_t v280 = v288;
                uint64_t v284 = v674;
              }
            }
            v290 = &v40[v280];
            if ((unint64_t)v290 >= v56) {
              uint64_t v291 = v284;
            }
            else {
              uint64_t v291 = 0;
            }
            v7 += 4 * v281 + 4 * v291;
            uint64_t v40 = &v290[v291];
            v60 += v283;
            v67 += v655;
            --v285;
          }
          while (v285);
          if (v676)
          {
            v292 = &v679[v677];
            uint64_t v293 = -(uint64_t)(v681 * v656);
            if (v292 < v676) {
              uint64_t v293 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v293);
            uint64_t v294 = -(uint64_t)(v677 * v656);
            if (v292 < v676) {
              uint64_t v294 = 0;
            }
            uint64_t v40 = &v292[v294];
            v56 += 4 * v294 + 4 * v677;
            v683 += 4 * v681 + 4 * v293;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          int v282 = v664 - 1;
        }
        while (v664 != 1);
        goto LABEL_556;
      case 21:
        unint64_t v646 = v44;
        unint64_t v648 = v27;
        int v670 = v12;
        uint64_t v295 = v655;
        uint64_t v296 = (int)v43;
        int v297 = v694[0];
        uint64_t v298 = 4 * (int)v28;
        uint64_t v299 = -(uint64_t)(int)v44;
        uint64_t v675 = v299;
        do
        {
          int v665 = v297;
          int v300 = v670;
          do
          {
            float v301 = 1.0;
            float v302 = 1.0;
            if (!v43 || (float v302 = *(float *)v7, *(float *)v7 > 0.0))
            {
              if (v28 && (float v301 = *(float *)v60, *(float *)v60 <= 0.0))
              {
                *float32x4_t v67 = *v40;
                *(float *)int v60 = v302;
              }
              else
              {
                uint64_t v303 = v295;
                LODWORD(v28) = v692;
                *float32x4_t v67 = PDAhardlightPDA(*v67, v301, *v40, v302);
                if (v692) {
                  *(_DWORD *)int v60 = v304;
                }
                LODWORD(v43) = v690;
                uint64_t v295 = v303;
                uint64_t v299 = v675;
              }
            }
            v305 = &v40[v295];
            if ((unint64_t)v305 >= v56) {
              uint64_t v306 = v299;
            }
            else {
              uint64_t v306 = 0;
            }
            v7 += 4 * v296 + 4 * v306;
            uint64_t v40 = &v305[v306];
            v60 += v298;
            v67 += v655;
            --v300;
          }
          while (v300);
          if (v676)
          {
            v307 = &v679[v677];
            uint64_t v308 = -(uint64_t)(v681 * v656);
            if (v307 < v676) {
              uint64_t v308 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v308);
            uint64_t v309 = -(uint64_t)(v677 * v656);
            if (v307 < v676) {
              uint64_t v309 = 0;
            }
            uint64_t v40 = &v307[v309];
            v56 += 4 * v309 + 4 * v677;
            v683 += 4 * v681 + 4 * v308;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          int v297 = v665 - 1;
        }
        while (v665 != 1);
LABEL_556:
        v694[0] = 0;
        unint64_t v27 = v648;
        int v9 = v649;
        uint64_t v11 = v645;
        unint64_t v44 = v646;
        goto LABEL_733;
      case 22:
        int v310 = v694[0];
        while (1)
        {
          int v311 = v12;
          do
          {
            float v312 = 1.0;
            float v313 = 1.0;
            if (v43)
            {
              float v313 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_570;
              }
            }
            if (v28)
            {
              float v312 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_568;
              }
            }
            float v314 = v313 * *v67;
            float v315 = v312 * *v40;
            float v316 = (float)(*v67 + *v40) - v314;
            float v317 = v314 - v315;
            float v318 = v316 - v315;
            if (v317 < 0.0) {
              float v317 = -v317;
            }
            float v319 = v318 + v317;
            if (v28)
            {
              float v313 = (float)(v313 + v312) - (float)(v312 * v313);
              *float32x4_t v67 = v319;
LABEL_568:
              *(float *)int v60 = v313;
              goto LABEL_570;
            }
            *float32x4_t v67 = v319;
LABEL_570:
            v320 = &v40[v655];
            if ((unint64_t)v320 >= v56) {
              uint64_t v321 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v321 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v321;
            uint64_t v40 = &v320[v321];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v311;
          }
          while (v311);
          if (v676)
          {
            v322 = &v679[v677];
            if (v322 >= v676) {
              uint64_t v323 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v323 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v323);
            if (v322 >= v676) {
              uint64_t v324 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v324 = 0;
            }
            uint64_t v40 = &v322[v324];
            v56 += 4 * v324 + 4 * v677;
            v683 += 4 * v681 + 4 * v323;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v310) {
            goto LABEL_732;
          }
        }
      case 23:
        int v325 = v694[0];
        while (1)
        {
          int v326 = v12;
          do
          {
            float v327 = 1.0;
            float v328 = 1.0;
            if (v43)
            {
              float v328 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_596;
              }
            }
            if (v28)
            {
              float v327 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_594;
              }
            }
            float v329 = (float)(*v67 + *v40) + (float)((float)(*v40 * *v67) * -2.0);
            if (v28)
            {
              float v328 = (float)(v328 + v327) - (float)(v327 * v328);
              *float32x4_t v67 = v329;
LABEL_594:
              *(float *)int v60 = v328;
              goto LABEL_596;
            }
            *float32x4_t v67 = v329;
LABEL_596:
            v330 = &v40[v655];
            if ((unint64_t)v330 >= v56) {
              uint64_t v331 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v331 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v331;
            uint64_t v40 = &v330[v331];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v326;
          }
          while (v326);
          if (v676)
          {
            v332 = &v679[v677];
            if (v332 >= v676) {
              uint64_t v333 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v333 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v333);
            if (v332 >= v676) {
              uint64_t v334 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v334 = 0;
            }
            uint64_t v40 = &v332[v334];
            v56 += 4 * v334 + 4 * v677;
            v683 += 4 * v681 + 4 * v333;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v325) {
            goto LABEL_732;
          }
        }
      case 24:
        int v335 = v694[0];
        while (1)
        {
          int v336 = v12;
          do
          {
            float v337 = 1.0;
            float v338 = 1.0;
            if (v43)
            {
              float v338 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_627;
              }
            }
            if (v28)
            {
              float v337 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_625;
              }
            }
            float v339 = *v67;
            if (v338 == 1.0)
            {
              float v340 = 0.0;
            }
            else
            {
              float v339 = v338 * *v67;
              float v340 = *v67 - v339;
            }
            float v341 = (float)(*v40 + v340) - (float)(v337 * *v40);
            if (v337 == 1.0) {
              float v341 = v340;
            }
            float v342 = v339 + v341;
            if (v28)
            {
              float v338 = (float)(v338 + v337) - (float)(v338 * v337);
              *float32x4_t v67 = v342;
LABEL_625:
              *(float *)int v60 = v338;
              goto LABEL_627;
            }
            *float32x4_t v67 = v342;
LABEL_627:
            v343 = &v40[v655];
            if ((unint64_t)v343 >= v56) {
              uint64_t v344 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v344 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v344;
            uint64_t v40 = &v343[v344];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v336;
          }
          while (v336);
          if (v676)
          {
            v345 = &v679[v677];
            if (v345 >= v676) {
              uint64_t v346 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v346 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v346);
            if (v345 >= v676) {
              uint64_t v347 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v347 = 0;
            }
            uint64_t v40 = &v345[v347];
            v56 += 4 * v347 + 4 * v677;
            v683 += 4 * v681 + 4 * v346;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v335) {
            goto LABEL_732;
          }
        }
      case 25:
        int v348 = v694[0];
        while (1)
        {
          int v349 = v12;
          do
          {
            float v350 = 1.0;
            float v351 = 1.0;
            if (v43)
            {
              float v351 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_658;
              }
            }
            if (v28)
            {
              float v350 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_656;
              }
            }
            float v352 = *v67;
            if (v351 == 1.0)
            {
              float v353 = 0.0;
            }
            else
            {
              float v352 = v351 * *v67;
              float v353 = *v67 - v352;
            }
            float v354 = (float)(*v40 + v353) - (float)(v350 * *v40);
            if (v350 == 1.0) {
              float v354 = v353;
            }
            float v355 = v352 + v354;
            if (v28)
            {
              float v351 = (float)(v351 + v350) - (float)(v351 * v350);
              *float32x4_t v67 = v355;
LABEL_656:
              *(float *)int v60 = v351;
              goto LABEL_658;
            }
            *float32x4_t v67 = v355;
LABEL_658:
            v356 = &v40[v655];
            if ((unint64_t)v356 >= v56) {
              uint64_t v357 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v357 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v357;
            uint64_t v40 = &v356[v357];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v349;
          }
          while (v349);
          if (v676)
          {
            v358 = &v679[v677];
            if (v358 >= v676) {
              uint64_t v359 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v359 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v359);
            if (v358 >= v676) {
              uint64_t v360 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v360 = 0;
            }
            uint64_t v40 = &v358[v360];
            v56 += 4 * v360 + 4 * v677;
            v683 += 4 * v681 + 4 * v359;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v348) {
            goto LABEL_732;
          }
        }
      case 26:
        int v361 = v694[0];
        while (1)
        {
          int v362 = v12;
          do
          {
            float v363 = 1.0;
            float v364 = 1.0;
            if (v43)
            {
              float v364 = *(float *)v7;
              if (*(float *)v7 <= 0.0) {
                goto LABEL_688;
              }
            }
            if (v28)
            {
              float v363 = *(float *)v60;
              if (*(float *)v60 <= 0.0)
              {
                *float32x4_t v67 = *v40;
                goto LABEL_686;
              }
            }
            float v365 = *v67;
            float v366 = *v40 - (float)(v363 * *v40);
            if (v363 == 1.0) {
              float v366 = 0.0;
            }
            float v367 = (float)(v365 + v366) - (float)(v364 * v365);
            if (v364 != 1.0)
            {
              float v365 = v364 * v365;
              float v366 = v367;
            }
            float v368 = v365 + v366;
            if (v28)
            {
              float v364 = (float)(v364 + v363) - (float)(v364 * v363);
              *float32x4_t v67 = v368;
LABEL_686:
              *(float *)int v60 = v364;
              goto LABEL_688;
            }
            *float32x4_t v67 = v368;
LABEL_688:
            v369 = &v40[v655];
            if ((unint64_t)v369 >= v56) {
              uint64_t v370 = -(uint64_t)(int)v44;
            }
            else {
              uint64_t v370 = 0;
            }
            v7 += 4 * (int)v43 + 4 * v370;
            uint64_t v40 = &v369[v370];
            v60 += 4 * (int)v28;
            v67 += v655;
            --v362;
          }
          while (v362);
          if (v676)
          {
            v371 = &v679[v677];
            if (v371 >= v676) {
              uint64_t v372 = -(uint64_t)(v681 * v656);
            }
            else {
              uint64_t v372 = 0;
            }
            int v7 = (char *)(v683 + 4 * v681 + 4 * v372);
            if (v371 >= v676) {
              uint64_t v373 = -(uint64_t)(v677 * v656);
            }
            else {
              uint64_t v373 = 0;
            }
            uint64_t v40 = &v371[v373];
            v56 += 4 * v373 + 4 * v677;
            v683 += 4 * v681 + 4 * v372;
            v679 = v40;
          }
          else
          {
            v40 += v677;
            v7 += 4 * v681;
          }
          v67 += v685;
          v60 += 4 * v688;
          if (!--v361) {
            goto LABEL_732;
          }
        }
      case 27:
        int v374 = v694[0];
        break;
      default:
        goto LABEL_733;
    }
LABEL_704:
    int v375 = v12;
    while (1)
    {
      float v376 = 1.0;
      float v377 = 1.0;
      if (!v43 || (float v377 = *(float *)v7, *(float *)v7 > 0.0))
      {
        if (v28 && (float v376 = *(float *)v60, *(float *)v60 <= 0.0))
        {
          *float32x4_t v67 = *v40;
        }
        else
        {
          float v378 = *v40;
          float v379 = *v67 - (float)(v377 * *v67);
          if (v377 == 1.0) {
            float v379 = 0.0;
          }
          float v380 = (float)(v378 + v379) - (float)(v376 * v378);
          if (v376 != 1.0)
          {
            float v378 = v376 * v378;
            float v379 = v380;
          }
          float v381 = v378 + v379;
          if (!v28)
          {
            *float32x4_t v67 = v381;
            goto LABEL_718;
          }
          float v377 = (float)(v377 + v376) - (float)(v377 * v376);
          *float32x4_t v67 = v381;
        }
        *(float *)int v60 = v377;
      }
LABEL_718:
      v382 = &v40[v655];
      if ((unint64_t)v382 >= v56) {
        uint64_t v383 = -(uint64_t)(int)v44;
      }
      else {
        uint64_t v383 = 0;
      }
      v7 += 4 * (int)v43 + 4 * v383;
      uint64_t v40 = &v382[v383];
      v60 += 4 * (int)v28;
      v67 += v655;
      if (!--v375)
      {
        if (v676)
        {
          v384 = &v679[v677];
          if (v384 >= v676) {
            uint64_t v385 = -(uint64_t)(v681 * v656);
          }
          else {
            uint64_t v385 = 0;
          }
          int v7 = (char *)(v683 + 4 * v681 + 4 * v385);
          if (v384 >= v676) {
            uint64_t v386 = -(uint64_t)(v677 * v656);
          }
          else {
            uint64_t v386 = 0;
          }
          uint64_t v40 = &v384[v386];
          v56 += 4 * v386 + 4 * v677;
          v683 += 4 * v681 + 4 * v385;
          v679 = v40;
        }
        else
        {
          v40 += v677;
          v7 += 4 * v681;
        }
        v67 += v685;
        v60 += 4 * v688;
        if (!--v374) {
          goto LABEL_732;
        }
        goto LABEL_704;
      }
    }
  }
  int v17 = *(_DWORD *)(v3 + 128);
  if ((v17 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      Wf_mark_constmask(v3, v9, v4);
    }
    else {
      Wf_mark_pixelmask(v3, v9);
    }
    return 1;
  }
  int v29 = *(_DWORD *)(v3 + 112);
  int v30 = *(_DWORD *)(v3 + 116);
  uint64_t v31 = v3;
  unsigned int v32 = (v29 + 15) & 0xFFFFFFF0;
  size_t v33 = v32 * v30;
  if ((int)v33 <= 4096)
  {
    unint64_t v35 = v704;
  }
  else
  {
    uint64_t v34 = malloc_type_malloc(v33, 0x4E32AE95uLL);
    if (!v34) {
      return 1;
    }
    unint64_t v35 = v34;
    int v16 = *(uint16x4_t **)(v31 + 136);
    int v17 = *(_DWORD *)(v31 + 128);
  }
  CGSConvertBitsToMask(v16, *(_DWORD *)(v31 + 124), v35, v32, v29, v30, v17);
  long long v48 = *(_OWORD *)(v31 + 112);
  long long v700 = *(_OWORD *)(v31 + 96);
  long long v701 = v48;
  long long v49 = *(_OWORD *)(v31 + 144);
  long long v702 = *(_OWORD *)(v31 + 128);
  long long v703 = v49;
  long long v50 = *(_OWORD *)(v31 + 48);
  long long v696 = *(_OWORD *)(v31 + 32);
  long long v697 = v50;
  long long v51 = *(_OWORD *)(v31 + 80);
  long long v698 = *(_OWORD *)(v31 + 64);
  long long v699 = v51;
  long long v52 = *(_OWORD *)v31;
  long long v53 = *(_OWORD *)(v31 + 16);
  *(_OWORD *)v694 = *(_OWORD *)v31;
  long long v695 = v53;
  HIDWORD(v701) = (v29 + 15) & 0xFFFFFFF0;
  *((void *)&v702 + 1) = v35;
  if (BYTE1(v694[0]) << 8 == 1024) {
    Wf_mark_constmask((uint64_t)v694, v9, *(double *)&v52);
  }
  else {
    Wf_mark_pixelmask((uint64_t)v694, v9);
  }
  if (v35 != (unsigned char *)v704)
  {
LABEL_65:
    float v68 = v35;
LABEL_949:
    free(v68);
  }
  return 1;
}

float PDAoverlayPDA(float a1, float a2, float a3, float a4)
{
  float v4 = (float)(a1 * a3) + (float)(a1 * a3);
  BOOL v5 = a1 < (float)(a2 * 0.5);
  float v6 = (float)((float)((float)((float)(a2 + 1.0) * a3) + (float)(a1 * (float)(a4 + 1.0))) - v4) - (float)(a2 * a4);
  float result = (float)((float)((float)(1.0 - a2) * a3) + (float)(a1 * (float)(1.0 - a4))) + v4;
  if (!v5) {
    return v6;
  }
  return result;
}

float PDAcolordodgePDA(float a1, float a2, float a3, float a4)
{
  float v4 = 0.0;
  if (a1 != 0.0)
  {
    if (a3 == a4) {
      float v4 = 1.0;
    }
    else {
      float v4 = (float)(a1 * (float)(a4 * a4)) / (float)(a4 - a3);
    }
  }
  float result = v4 + (float)(a1 * (float)(1.0 - a4));
  if (a4 == 1.0) {
    float result = v4;
  }
  float v6 = result + (float)(a3 * (float)(1.0 - a2));
  if (a2 != 1.0) {
    float result = v6;
  }
  float v7 = (float)(a2 + a4) - (float)(a2 * a4);
  if (result > v7) {
    return v7;
  }
  return result;
}

double PDAcolorburnPDA(float a1, float a2, float a3, float a4)
{
  float v5 = (float)(a2 * a4) + (float)(a1 * (float)(1.0 - a4));
  if (a4 == 1.0) {
    float v5 = a2 * a4;
  }
  if (a2 == 1.0) {
    *(float *)&double result = v5;
  }
  else {
    *(float *)&double result = v5 + (float)(a3 * (float)(1.0 - a2));
  }
  float v7 = a2 - a1;
  if (v7 != 0.0)
  {
    if (a3 == 0.0) {
      return 0.0;
    }
    *(float *)&double result = *(float *)&result - (float)((float)(v7 * (float)(a4 * a4)) / a3);
    if (*(float *)&result < 0.0) {
      return 0.0;
    }
  }
  return result;
}

float PDAhardlightPDA(float a1, float a2, float a3, float a4)
{
  float v4 = (float)(a1 * a3) + (float)(a1 * a3);
  float v5 = (float)((float)((float)(1.0 - a2) * a3) + (float)(a1 * (float)(1.0 - a4))) + v4;
  float result = (float)((float)((float)((float)(a2 + 1.0) * a3) + (float)(a1 * (float)(a4 + 1.0))) - v4) - (float)(a2 * a4);
  if (a3 <= (float)(a4 * 0.5)) {
    return v5;
  }
  return result;
}

float PDAsoftlightPDA(float a1, float a2, float a3, float a4)
{
  float v4 = 0.0;
  if (a2 != 0.0)
  {
    float v4 = (float)((float)(a1 * a3) + (float)(a1 * a3))
       - (float)((float)((float)(a1 * a1) * (float)((float)(a3 + a3) - a4)) / a2);
    if (v4 < 0.0) {
      float v4 = 0.0;
    }
  }
  float result = v4 + (float)(a1 * (float)(1.0 - a4));
  if (a4 == 1.0) {
    float result = v4;
  }
  float v6 = result + (float)(a3 * (float)(1.0 - a2));
  if (a2 != 1.0) {
    return v6;
  }
  return result;
}

void Wf_mark_constmask(uint64_t a1, int a2, double a3)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 136);
  float v6 = *(float **)(a1 + 96);
  if (v6) {
    float v7 = *v6;
  }
  else {
    float v7 = 1.0;
  }
  uint64_t v9 = *(int *)(a1 + 12);
  uint64_t v8 = *(int *)(a1 + 16);
  if (v4)
  {
    unint64_t v10 = (unint64_t)*(int *)(a1 + 32) >> 2;
    uint64_t v11 = (float *)(v4 + 4 * (v9 + v10 * v8));
    uint64_t v12 = 1;
    if (!v5) {
      return;
    }
  }
  else
  {
    uint64_t v11 = 0;
    unint64_t v10 = 0;
    uint64_t v12 = 0;
    if (!v5) {
      return;
    }
  }
  int v13 = *(_DWORD *)(a1 + 4);
  unint64_t v14 = v10 - v13;
  if (v4) {
    unint64_t v15 = v10 - v13;
  }
  else {
    unint64_t v15 = v10;
  }
  int v16 = *(_DWORD *)(a1 + 8);
  unint64_t v17 = (unint64_t)*(int *)(a1 + 28) >> 2;
  v3.i32[0] = **(_DWORD **)(a1 + 88);
  int v18 = (float *)(*(void *)(a1 + 40) + 4 * (v9 + v17 * v8));
  uint64_t v19 = *(int *)(a1 + 124);
  unint64_t v20 = v5 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v19;
  uint64_t v21 = v19 - v13;
  unint64_t v22 = v17 - v13;
  __int32 v347 = v3.i32[0];
  unint64_t v346 = v22;
  uint64_t v23 = v21;
  int v24 = v13;
  unint64_t v25 = v15;
  switch(a2)
  {
    case 0:
      if (v4)
      {
        uint64_t v26 = 4 * v12;
        do
        {
          int v27 = v13;
          do
          {
            int v28 = *(unsigned __int8 *)v20;
            if (*(unsigned char *)v20)
            {
              if (v28 == 255)
              {
                *uint64_t v11 = 0.0;
                *int v18 = 0.0;
              }
              else
              {
                float v29 = (float)(v28 ^ 0xFFu) * 0.0039216;
                *int v18 = v29 * *v18;
                *uint64_t v11 = v29 * *v11;
              }
            }
            ++v20;
            ++v18;
            uint64_t v11 = (float *)((char *)v11 + v26);
            --v27;
          }
          while (v27);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v247 = v13;
          do
          {
            int v248 = *(unsigned __int8 *)v20;
            if (*(unsigned char *)v20)
            {
              float v249 = 0.0;
              if (v248 != 255) {
                float v249 = (float)((float)(v248 ^ 0xFFu) * 0.0039216) * *v18;
              }
              *int v18 = v249;
            }
            ++v20;
            ++v18;
            --v247;
          }
          while (v247);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 1:
      unsigned int v30 = v20 & 3;
      if (!v4)
      {
        int v250 = -1 << (8 * v30);
        if ((v20 & 3) != 0) {
          char v251 = v20 & 0xFC;
        }
        else {
          char v251 = v20;
        }
        if ((v20 & 3) != 0)
        {
          uint64_t v252 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v250 = -1;
          uint64_t v252 = (unsigned int *)v20;
        }
        if ((v20 & 3) != 0) {
          uint64_t v253 = &v18[-(v20 & 3)];
        }
        else {
          uint64_t v253 = v18;
        }
        if ((v20 & 3) != 0) {
          int v254 = v30 + v13;
        }
        else {
          int v254 = v13;
        }
        if ((((_BYTE)v254 + v251) & 3) != 0)
        {
          int v255 = 4 - (((_BYTE)v254 + v251) & 3);
          v30 += v255;
          unsigned int v256 = 0xFFFFFFFF >> (8 * v255);
          if (v254 >= 4) {
            unsigned int v257 = v256;
          }
          else {
            unsigned int v257 = 0;
          }
          if (v254 >= 4) {
            unsigned int v256 = -1;
          }
          v250 &= v256;
        }
        else
        {
          unsigned int v257 = 0;
        }
        uint64_t v324 = v21 - v30;
        int v325 = v254 >> 2;
        int32x4_t v326 = vdupq_lane_s32(v3, 0);
        unint64_t v327 = v22 - v30;
        while (1)
        {
          unsigned int v328 = *v252 & v250;
          int v329 = v325;
          unsigned int v330 = v257;
          if (!v328) {
            goto LABEL_554;
          }
LABEL_536:
          if (v328 == -1)
          {
            *(int32x4_t *)uint64_t v253 = v326;
            goto LABEL_554;
          }
          while (1)
          {
            if ((_BYTE)v328)
            {
              float v331 = *(float *)v3.i32;
              if (v328 != 255) {
                float v331 = (float)(*(float *)v3.i32 * (float)((float)v328 * 0.0039216))
              }
                     + (float)(*v253 * (float)(1.0 - (float)((float)v328 * 0.0039216)));
              *uint64_t v253 = v331;
            }
            if (BYTE1(v328))
            {
              float v332 = *(float *)v3.i32;
              if (BYTE1(v328) != 255) {
                float v332 = (float)(*(float *)v3.i32 * (float)((float)BYTE1(v328) * 0.0039216))
              }
                     + (float)(v253[1] * (float)(1.0 - (float)((float)BYTE1(v328) * 0.0039216)));
              v253[1] = v332;
            }
            if (BYTE2(v328))
            {
              float v333 = *(float *)v3.i32;
              if (BYTE2(v328) != 255) {
                float v333 = (float)(*(float *)v3.i32 * (float)((float)BYTE2(v328) * 0.0039216))
              }
                     + (float)(v253[2] * (float)(1.0 - (float)((float)BYTE2(v328) * 0.0039216)));
              v253[2] = v333;
            }
            unsigned int v334 = HIBYTE(v328);
            if (v334 == 255)
            {
              v253[3] = *(float *)v3.i32;
            }
            else if (v334)
            {
              v253[3] = (float)(*(float *)v3.i32 * (float)((float)v334 * 0.0039216))
                      + (float)(v253[3] * (float)(1.0 - (float)((float)v334 * 0.0039216)));
            }
LABEL_554:
            while (1)
            {
              int v335 = v329;
              v253 += 4;
              --v329;
              ++v252;
              if (v335 < 2) {
                break;
              }
              unsigned int v328 = *v252;
              if (*v252) {
                goto LABEL_536;
              }
            }
            if (!v330) {
              break;
            }
            unsigned int v330 = 0;
            unsigned int v328 = *v252 & v257;
          }
          uint64_t v252 = (unsigned int *)((char *)v252 + v324);
          v253 += v327;
          if (!--v16) {
            return;
          }
        }
      }
      int v31 = -1 << (8 * v30);
      unsigned int v32 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v33 = 4 * (v20 & 3);
      uint64_t v34 = &v18[v33 / 0xFFFFFFFFFFFFFFFCLL];
      unint64_t v35 = &v11[v33 / 0xFFFFFFFFFFFFFFFCLL];
      if ((v20 & 3) != 0) {
        char v36 = v20 & 0xFC;
      }
      else {
        char v36 = v20;
      }
      if ((v20 & 3) != 0)
      {
        int v37 = v30 + v13;
      }
      else
      {
        int v31 = -1;
        unsigned int v32 = (unsigned int *)v20;
        unint64_t v35 = v11;
        uint64_t v34 = v18;
        int v37 = v13;
      }
      if ((((_BYTE)v37 + v36) & 3) != 0)
      {
        int v38 = 4 - (((_BYTE)v37 + v36) & 3);
        v30 += v38;
        unsigned int v39 = 0xFFFFFFFF >> (8 * v38);
        if (v37 >= 4) {
          unsigned int v40 = v39;
        }
        else {
          unsigned int v40 = 0;
        }
        if (v37 >= 4) {
          unsigned int v39 = -1;
        }
        v31 &= v39;
      }
      else
      {
        unsigned int v40 = 0;
      }
      uint64_t v274 = v21 - v30;
      unint64_t v275 = v22 - v30;
      int v276 = v37 >> 2;
      unint64_t v277 = v14 - v30;
      do
      {
        unsigned int v278 = *v32 & v31;
        int v279 = v276;
        unsigned int v280 = v40;
        if (!v278) {
          goto LABEL_505;
        }
LABEL_484:
        if (v278 == -1)
        {
          *uint64_t v34 = *(float *)v3.i32;
          *unint64_t v35 = v7;
          v34[1] = *(float *)v3.i32;
          v35[1] = v7;
          v34[2] = *(float *)v3.i32;
          v35[2] = v7;
LABEL_502:
          v34[3] = *(float *)v3.i32;
          v35[3] = v7;
          goto LABEL_505;
        }
        while (1)
        {
          if ((_BYTE)v278)
          {
            if (v278 == 255)
            {
              *uint64_t v34 = *(float *)v3.i32;
              float v281 = v7;
            }
            else
            {
              float v282 = (float)v278 * 0.0039216;
              float v283 = *(float *)v3.i32 * v282;
              float v284 = v7 * v282;
              float v285 = 1.0 - v282;
              *uint64_t v34 = v283 + (float)(*v34 * v285);
              float v281 = v284 + (float)(*v35 * v285);
            }
            *unint64_t v35 = v281;
          }
          if (BYTE1(v278))
          {
            if (BYTE1(v278) == 255)
            {
              v34[1] = *(float *)v3.i32;
              float v286 = v7;
            }
            else
            {
              float v287 = (float)BYTE1(v278) * 0.0039216;
              float v288 = *(float *)v3.i32 * v287;
              float v289 = v7 * v287;
              float v290 = 1.0 - v287;
              v34[1] = v288 + (float)(v34[1] * v290);
              float v286 = v289 + (float)(v35[1] * v290);
            }
            v35[1] = v286;
          }
          if (BYTE2(v278))
          {
            if (BYTE2(v278) == 255)
            {
              v34[2] = *(float *)v3.i32;
              float v291 = v7;
            }
            else
            {
              float v292 = (float)BYTE2(v278) * 0.0039216;
              float v293 = *(float *)v3.i32 * v292;
              float v294 = v7 * v292;
              float v295 = 1.0 - v292;
              v34[2] = v293 + (float)(v34[2] * v295);
              float v291 = v294 + (float)(v35[2] * v295);
            }
            v35[2] = v291;
          }
          unsigned int v296 = HIBYTE(v278);
          if (v296 == 255) {
            goto LABEL_502;
          }
          if (v296)
          {
            float v297 = (float)v296 * 0.0039216;
            float v298 = *(float *)v3.i32 * v297;
            float v299 = v7 * v297;
            float v300 = 1.0 - v297;
            v34[3] = v298 + (float)(v34[3] * v300);
            v35[3] = v299 + (float)(v35[3] * v300);
          }
LABEL_505:
          while (1)
          {
            int v301 = v279;
            v34 += 4;
            v35 += 4;
            --v279;
            ++v32;
            if (v301 < 2) {
              break;
            }
            unsigned int v278 = *v32;
            if (*v32) {
              goto LABEL_484;
            }
          }
          if (!v280) {
            break;
          }
          unsigned int v280 = 0;
          unsigned int v278 = *v32 & v40;
        }
        unsigned int v32 = (unsigned int *)((char *)v32 + v274);
        v34 += v275;
        v35 += v277;
        --v16;
      }
      while (v16);
      return;
    case 2:
      *(float *)&a3 = 1.0 - v7;
      unsigned int v41 = v20 & 3;
      if (v4)
      {
        int v42 = -1 << (8 * v41);
        uint64_t v43 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
        uint64_t v44 = 4 * (v20 & 3);
        unint64_t v45 = &v18[v44 / 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v46 = &v11[v44 / 0xFFFFFFFFFFFFFFFCLL];
        if ((v20 & 3) != 0) {
          char v47 = v20 & 0xFC;
        }
        else {
          char v47 = v20;
        }
        if ((v20 & 3) != 0)
        {
          int v48 = v41 + v13;
        }
        else
        {
          int v42 = -1;
          uint64_t v43 = (unsigned int *)v20;
          uint64_t v46 = v11;
          unint64_t v45 = v18;
          int v48 = v13;
        }
        if ((((_BYTE)v48 + v47) & 3) != 0)
        {
          int v49 = 4 - (((_BYTE)v48 + v47) & 3);
          v41 += v49;
          unsigned int v50 = 0xFFFFFFFF >> (8 * v49);
          if (v48 >= 4) {
            unsigned int v51 = v50;
          }
          else {
            unsigned int v51 = 0;
          }
          if (v48 >= 4) {
            unsigned int v50 = -1;
          }
          v42 &= v50;
        }
        else
        {
          unsigned int v51 = 0;
        }
        uint64_t v302 = v21 - v41;
        unint64_t v303 = v22 - v41;
        int v304 = v48 >> 2;
        unint64_t v305 = v14 - v41;
        while (1)
        {
          unsigned int v306 = *v43 & v42;
          int v307 = v304;
          unsigned int v308 = v51;
          if (!v306) {
            goto LABEL_526;
          }
LABEL_515:
          if (v306 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v306)
            {
              float v310 = (float)v306 * 0.0039216;
              float v311 = *(float *)v3.i32 * v310;
              float v312 = v7 * v310;
              float *v45 = v311 + (float)(*v45 * (float)(1.0 - v312));
              float *v46 = v312 + (float)(*v46 * (float)(1.0 - v312));
            }
            if ((v306 & 0xFF00) != 0)
            {
              float v313 = (float)BYTE1(v306) * 0.0039216;
              float v314 = *(float *)v3.i32 * v313;
              float v315 = v7 * v313;
              v45[1] = v314 + (float)(v45[1] * (float)(1.0 - v315));
              v46[1] = v315 + (float)(v46[1] * (float)(1.0 - v315));
            }
            if ((v306 & 0xFF0000) != 0)
            {
              float v316 = (float)BYTE2(v306) * 0.0039216;
              float v317 = *(float *)v3.i32 * v316;
              float v318 = v7 * v316;
              v45[2] = v317 + (float)(v45[2] * (float)(1.0 - v318));
              v46[2] = v318 + (float)(v46[2] * (float)(1.0 - v318));
            }
            unsigned int v319 = HIBYTE(v306);
            if (v319)
            {
              float v320 = (float)v319 * 0.0039216;
              float v321 = *(float *)v3.i32 * v320;
              float v322 = v7 * v320;
              v45[3] = v321 + (float)(v45[3] * (float)(1.0 - v322));
              float v309 = v322 + (float)(v46[3] * (float)(1.0 - v322));
              goto LABEL_525;
            }
LABEL_526:
            while (1)
            {
              int v323 = v307;
              v45 += 4;
              v46 += 4;
              --v307;
              ++v43;
              if (v323 < 2) {
                break;
              }
              unsigned int v306 = *v43;
              if (*v43) {
                goto LABEL_515;
              }
            }
            if (!v308) {
              break;
            }
            unsigned int v308 = 0;
            unsigned int v306 = *v43 & v51;
          }
          uint64_t v43 = (unsigned int *)((char *)v43 + v302);
          v45 += v303;
          v46 += v305;
          if (!--v16) {
            return;
          }
        }
        float *v45 = *(float *)v3.i32 + (float)(*v45 * *(float *)&a3);
        float *v46 = v7 + (float)(*v46 * *(float *)&a3);
        v45[1] = *(float *)v3.i32 + (float)(v45[1] * *(float *)&a3);
        v46[1] = v7 + (float)(v46[1] * *(float *)&a3);
        v45[2] = *(float *)v3.i32 + (float)(v45[2] * *(float *)&a3);
        v46[2] = v7 + (float)(v46[2] * *(float *)&a3);
        v45[3] = *(float *)v3.i32 + (float)(v45[3] * *(float *)&a3);
        float v309 = v7 + (float)(v46[3] * *(float *)&a3);
LABEL_525:
        v46[3] = v309;
        goto LABEL_526;
      }
      int v258 = v41 + v13;
      int v259 = -1 << (8 * v41);
      if ((v20 & 3) != 0) {
        char v260 = v20 & 0xFC;
      }
      else {
        char v260 = v20;
      }
      if ((v20 & 3) != 0)
      {
        v261 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v259 = -1;
        v261 = (unsigned int *)v20;
      }
      if ((v20 & 3) != 0) {
        uint64_t v262 = (float32x4_t *)&v18[-(v20 & 3)];
      }
      else {
        uint64_t v262 = (float32x4_t *)v18;
      }
      if ((v20 & 3) == 0) {
        int v258 = v13;
      }
      if ((((_BYTE)v258 + v260) & 3) != 0)
      {
        int v263 = 4 - (((_BYTE)v258 + v260) & 3);
        v41 += v263;
        unsigned int v264 = 0xFFFFFFFF >> (8 * v263);
        if (v258 >= 4) {
          unsigned int v265 = v264;
        }
        else {
          unsigned int v265 = 0;
        }
        if (v258 >= 4) {
          unsigned int v264 = -1;
        }
        v259 &= v264;
      }
      else
      {
        unsigned int v265 = 0;
      }
      int v336 = v258 >> 2;
      uint64_t v337 = v21 - v41;
      float32x4_t v338 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0);
      float32x4_t v339 = (float32x4_t)vdupq_lane_s32(v3, 0);
      unint64_t v340 = v22 - v41;
      do
      {
        unsigned int v341 = *v261 & v259;
        int v342 = v336;
        unsigned int v343 = v265;
        if (!v341) {
          goto LABEL_574;
        }
LABEL_564:
        if (v341 == -1)
        {
          *uint64_t v262 = vmlaq_f32(v339, v338, *v262);
          goto LABEL_574;
        }
        while (1)
        {
          if ((_BYTE)v341) {
            v262->f32[0] = (float)(*(float *)v3.i32 * (float)((float)v341 * 0.0039216))
          }
                         + (float)(v262->f32[0]
                                 * (float)(1.0 - (float)(v7 * (float)((float)v341 * 0.0039216))));
          if ((v341 & 0xFF00) != 0) {
            v262->f32[1] = (float)(*(float *)v3.i32 * (float)((float)BYTE1(v341) * 0.0039216))
          }
                         + (float)(v262->f32[1] * (float)(1.0 - (float)(v7 * (float)((float)BYTE1(v341) * 0.0039216))));
          if ((v341 & 0xFF0000) != 0) {
            v262->f32[2] = (float)(*(float *)v3.i32 * (float)((float)BYTE2(v341) * 0.0039216))
          }
                         + (float)(v262->f32[2] * (float)(1.0 - (float)(v7 * (float)((float)BYTE2(v341) * 0.0039216))));
          unsigned int v344 = HIBYTE(v341);
          if (v344) {
            v262->f32[3] = (float)(*(float *)v3.i32 * (float)((float)v344 * 0.0039216))
          }
                         + (float)(v262->f32[3] * (float)(1.0 - (float)(v7 * (float)((float)v344 * 0.0039216))));
LABEL_574:
          while (1)
          {
            int v345 = v342;
            ++v262;
            --v342;
            ++v261;
            if (v345 < 2) {
              break;
            }
            unsigned int v341 = *v261;
            if (*v261) {
              goto LABEL_564;
            }
          }
          if (!v343) {
            break;
          }
          unsigned int v343 = 0;
          unsigned int v341 = *v261 & v265;
        }
        v261 = (unsigned int *)((char *)v261 + v337);
        uint64_t v262 = (float32x4_t *)((char *)v262 + 4 * v340);
        --v16;
      }
      while (v16);
      return;
    case 3:
      uint64_t v52 = 4 * v12;
      do
      {
        int v53 = v13;
        do
        {
          unsigned int v54 = *(unsigned __int8 *)v20;
          if (*(unsigned char *)v20)
          {
            if (v54 == 255)
            {
              float v55 = v7 * *v11;
              *int v18 = *(float *)v3.i32 * *v11;
            }
            else
            {
              float v56 = (float)v54 * 0.0039216;
              float v57 = *v11;
              float v58 = v56 * *v11;
              float v59 = 1.0 - v56;
              *int v18 = (float)(*(float *)v3.i32 * v58) + (float)(*v18 * v59);
              float v55 = (float)(v7 * v58) + (float)(v57 * v59);
            }
            *uint64_t v11 = v55;
          }
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v52);
          --v53;
        }
        while (v53);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 4:
      uint64_t v60 = 4 * v12;
      do
      {
        int v61 = v13;
        do
        {
          unsigned int v62 = *(unsigned __int8 *)v20;
          if (*(unsigned char *)v20)
          {
            if (v62 == 255)
            {
              float v63 = 1.0 - *v11;
              float v64 = *(float *)v3.i32 * v63;
              float v65 = v7 * v63;
              *int v18 = v64;
            }
            else
            {
              float v66 = (float)v62 * 0.0039216;
              float v67 = *v11;
              float v68 = v66 * (float)(1.0 - *v11);
              float v69 = 1.0 - v66;
              *int v18 = (float)(*(float *)v3.i32 * v68) + (float)(*v18 * v69);
              float v65 = (float)(v7 * v68) + (float)(v67 * v69);
            }
            *uint64_t v11 = v65;
          }
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v60);
          --v61;
        }
        while (v61);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 5:
      uint64_t v70 = 4 * v12;
      do
      {
        int v71 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v72 = *v11;
            float v73 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v74 = *(float *)v3.i32 * v73;
            float v75 = v7 * v73;
            *int v18 = (float)((float)(1.0 - v75) * *v18) + (float)(v74 * *v11);
            *uint64_t v11 = (float)((float)(1.0 - v75) * v72) + (float)(v75 * v72);
          }
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v70);
          --v71;
        }
        while (v71);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 6:
      uint64_t v76 = 4 * v12;
      while (1)
      {
        int v77 = v13;
        do
        {
          unsigned int v78 = *(unsigned __int8 *)v20;
          if (!*(unsigned char *)v20) {
            goto LABEL_85;
          }
          float v79 = *v11;
          float v80 = 1.0 - *v11;
          if (v80 >= 1.0)
          {
            float v83 = (float)v78 * 0.0039216;
            float v84 = *(float *)v3.i32 * v83;
            float v82 = v7 * v83;
            *int v18 = v84;
          }
          else
          {
            if (v80 <= 0.0) {
              goto LABEL_85;
            }
            float v81 = (float)v78 * 0.0039216;
            *int v18 = *v18 + (float)((float)(*(float *)v3.i32 * v81) * v80);
            float v82 = v79 + (float)((float)(v7 * v81) * v80);
          }
          *uint64_t v11 = v82;
LABEL_85:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v76);
          --v77;
        }
        while (v77);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 7:
      if (v4)
      {
        uint64_t v85 = 4 * v12;
        do
        {
          int v86 = v13;
          do
          {
            unsigned int v87 = *(unsigned __int8 *)v20;
            if (*(unsigned char *)v20)
            {
              if (v87 == 255)
              {
                float v88 = v7 * *v18;
                float v89 = v7;
              }
              else
              {
                float v89 = (float)(v7 * (float)((float)v87 * 0.0039216)) + (float)(1.0 - (float)((float)v87 * 0.0039216));
                float v88 = v89 * *v18;
              }
              *int v18 = v88;
              *uint64_t v11 = v89 * *v11;
            }
            ++v20;
            ++v18;
            uint64_t v11 = (float *)((char *)v11 + v85);
            --v86;
          }
          while (v86);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v266 = v13;
          do
          {
            unsigned int v267 = *(unsigned __int8 *)v20;
            if (*(unsigned char *)v20)
            {
              if (v267 == 255) {
                float v268 = v7 * *v18;
              }
              else {
                float v268 = (float)((float)(v7 * (float)((float)v267 * 0.0039216))
              }
                             + (float)(1.0 - (float)((float)v267 * 0.0039216)))
                     * *v18;
              *int v18 = v268;
            }
            ++v20;
            ++v18;
            --v266;
          }
          while (v266);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 8:
      float v90 = 1.0 - v7;
      if (v4)
      {
        uint64_t v91 = 4 * v12;
        do
        {
          int v92 = v13;
          do
          {
            unsigned int v93 = *(unsigned __int8 *)v20;
            if (*(unsigned char *)v20)
            {
              if (v93 == 255)
              {
                float v94 = v90 * *v18;
                float v95 = 1.0 - v7;
              }
              else
              {
                float v95 = (float)(v7 * (float)((float)v93 * -0.0039216)) + 1.0;
                float v94 = v95 * *v18;
              }
              *int v18 = v94;
              *uint64_t v11 = v95 * *v11;
            }
            ++v20;
            ++v18;
            uint64_t v11 = (float *)((char *)v11 + v91);
            --v92;
          }
          while (v92);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v269 = v13;
          do
          {
            unsigned int v270 = *(unsigned __int8 *)v20;
            if (*(unsigned char *)v20)
            {
              if (v270 == 255) {
                float v271 = v90 * *v18;
              }
              else {
                float v271 = (float)((float)(v7 * (float)((float)v270 * -0.0039216)) + 1.0) * *v18;
              }
              *int v18 = v271;
            }
            ++v20;
            ++v18;
            --v269;
          }
          while (v269);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 9:
      uint64_t v96 = 4 * v12;
      do
      {
        int v97 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v98 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v99 = *v11;
            float v100 = *(float *)v3.i32 * v98;
            float v101 = v7 * v98;
            float v102 = 1.0 - *v11;
            float v103 = (float)(1.0 - v98) + (float)(v7 * v98);
            *int v18 = (float)(v103 * *v18) + (float)(v100 * v102);
            *uint64_t v11 = (float)(v103 * v99) + (float)(v101 * v102);
          }
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v96);
          --v97;
        }
        while (v97);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 10:
      uint64_t v104 = 4 * v12;
      do
      {
        int v105 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v106 = *v11;
            float v107 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v108 = *(float *)v3.i32 * v107;
            float v109 = v7 * v107;
            float v110 = 1.0 - *v11;
            *int v18 = (float)((float)(1.0 - v109) * *v18) + (float)(v108 * v110);
            *uint64_t v11 = (float)((float)(1.0 - v109) * v106) + (float)(v109 * v110);
          }
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v104);
          --v105;
        }
        while (v105);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 11:
      if (v4)
      {
        uint64_t v111 = 4 * v12;
        do
        {
          int v112 = v13;
          do
          {
            if (*(unsigned char *)v20)
            {
              float v113 = (float)*(unsigned __int8 *)v20 * 0.0039216;
              float v114 = *(float *)v3.i32 * v113;
              float v115 = v7 * v113;
              float v116 = v115 + *v11;
              float v117 = (float)(v115 - v114) + (float)(*v11 - *v18);
              if (v116 <= 1.0) {
                float v118 = v116;
              }
              else {
                float v118 = 1.0;
              }
              *uint64_t v11 = v118;
              *int v18 = v118 - v117;
            }
            ++v20;
            ++v18;
            uint64_t v11 = (float *)((char *)v11 + v111);
            --v112;
          }
          while (v112);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v272 = v13;
          do
          {
            if (*(unsigned char *)v20) {
              *int v18 = 1.0
            }
                   - (float)((float)((float)(v7 * (float)((float)*(unsigned __int8 *)v20 * 0.0039216))
                                   - (float)(*(float *)v3.i32 * (float)((float)*(unsigned __int8 *)v20 * 0.0039216)))
                           + (float)(1.0 - *v18));
            ++v20;
            ++v18;
            --v272;
          }
          while (v272);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 12:
      if (v4)
      {
        uint64_t v119 = 4 * v12;
        do
        {
          int v120 = v13;
          do
          {
            if (*(unsigned char *)v20)
            {
              float v121 = (float)*(unsigned __int8 *)v20 * 0.0039216;
              float v122 = *(float *)v3.i32 * v121;
              float v123 = (float)(v7 * v121) + *v11;
              float v124 = v122 + *v18;
              if (v123 > 1.0) {
                float v123 = 1.0;
              }
              *int v18 = v124;
              *uint64_t v11 = v123;
            }
            ++v20;
            ++v18;
            uint64_t v11 = (float *)((char *)v11 + v119);
            --v120;
          }
          while (v120);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v273 = v13;
          do
          {
            if (*(unsigned char *)v20) {
              *int v18 = (float)(*(float *)v3.i32 * (float)((float)*(unsigned __int8 *)v20 * 0.0039216)) + *v18;
            }
            ++v20;
            ++v18;
            --v273;
          }
          while (v273);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 13:
      uint64_t v125 = 4 * v12;
      while (1)
      {
        int v126 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v127 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v128 = v7 * v127;
            if ((float)(v7 * v127) > 0.0)
            {
              float v129 = *(float *)v3.i32 * v127;
              if (v4)
              {
                float v130 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_159;
                }
              }
              else
              {
                float v130 = 1.0;
              }
              float v131 = (float)(v129 * *v18) + (float)(*v18 * (float)(1.0 - v128));
              if (v128 == 1.0) {
                float v131 = v129 * *v18;
              }
              float v129 = v131 + (float)(v129 * (float)(1.0 - v130));
              if (v130 == 1.0) {
                float v129 = v131;
              }
              if (v4)
              {
                float v128 = (float)(v128 + v130) - (float)(v130 * v128);
LABEL_159:
                *int v18 = v129;
                *uint64_t v11 = v128;
                goto LABEL_161;
              }
              *int v18 = v129;
            }
          }
LABEL_161:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v125);
          --v126;
        }
        while (v126);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 14:
      uint64_t v132 = 4 * v12;
      while (1)
      {
        int v133 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v134 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v135 = v7 * v134;
            if ((float)(v7 * v134) > 0.0)
            {
              float v136 = *(float *)v3.i32 * v134;
              if (v4)
              {
                float v137 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_174;
                }
              }
              else
              {
                float v137 = 1.0;
              }
              float v136 = *v18 + (float)(v136 * (float)(1.0 - *v18));
              if (v4)
              {
                float v135 = (float)(v135 + v137) - (float)(v137 * v135);
LABEL_174:
                *int v18 = v136;
                *uint64_t v11 = v135;
                goto LABEL_176;
              }
              *int v18 = v136;
            }
          }
LABEL_176:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v132);
          --v133;
        }
        while (v133);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 15:
      uint64_t v138 = 4 * v12;
      while (1)
      {
        int v139 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v140 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v141 = v7 * v140;
            if ((float)(v7 * v140) > 0.0)
            {
              float v142 = *(float *)v3.i32 * v140;
              if (v4)
              {
                float v143 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_189;
                }
              }
              else
              {
                float v143 = 1.0;
              }
              float v144 = PDAoverlayPDA(*v18, v143, v142, v141);
              float v142 = v144;
              if (v4)
              {
                float v141 = v145;
                v3.i32[0] = v347;
LABEL_189:
                *int v18 = v142;
                *uint64_t v11 = v141;
                goto LABEL_191;
              }
              *int v18 = v144;
              v3.i32[0] = v347;
            }
          }
LABEL_191:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v138);
          --v139;
        }
        while (v139);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        int v13 = v24;
        if (!v16) {
          return;
        }
      }
    case 16:
      uint64_t v146 = 4 * v12;
      while (1)
      {
        int v147 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v148 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v149 = v7 * v148;
            if ((float)(v7 * v148) > 0.0)
            {
              float v150 = *(float *)v3.i32 * v148;
              if (v4)
              {
                float v151 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_210;
                }
              }
              else
              {
                float v151 = 1.0;
              }
              float v152 = v149 * *v18;
              if ((float)(v150 * v151) < v152) {
                float v152 = v150 * v151;
              }
              float v153 = v152 + (float)(*v18 * (float)(1.0 - v149));
              if (v149 == 1.0) {
                float v153 = v152;
              }
              float v150 = v153 + (float)(v150 * (float)(1.0 - v151));
              if (v151 == 1.0) {
                float v150 = v153;
              }
              if (v4)
              {
                float v149 = (float)(v149 + v151) - (float)(v151 * v149);
LABEL_210:
                *int v18 = v150;
                *uint64_t v11 = v149;
                goto LABEL_212;
              }
              *int v18 = v150;
            }
          }
LABEL_212:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v146);
          --v147;
        }
        while (v147);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 17:
      uint64_t v154 = 4 * v12;
      while (1)
      {
        int v155 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v156 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v157 = v7 * v156;
            if ((float)(v7 * v156) > 0.0)
            {
              float v158 = *(float *)v3.i32 * v156;
              if (v4)
              {
                float v159 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_231;
                }
              }
              else
              {
                float v159 = 1.0;
              }
              float v160 = v157 * *v18;
              if ((float)(v158 * v159) > v160) {
                float v160 = v158 * v159;
              }
              float v161 = v160 + (float)(*v18 * (float)(1.0 - v157));
              if (v157 == 1.0) {
                float v161 = v160;
              }
              float v158 = v161 + (float)(v158 * (float)(1.0 - v159));
              if (v159 == 1.0) {
                float v158 = v161;
              }
              if (v4)
              {
                float v157 = (float)(v157 + v159) - (float)(v159 * v157);
LABEL_231:
                *int v18 = v158;
                *uint64_t v11 = v157;
                goto LABEL_233;
              }
              *int v18 = v158;
            }
          }
LABEL_233:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v154);
          --v155;
        }
        while (v155);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 18:
      uint64_t v162 = 4 * v12;
      while (1)
      {
        int v163 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v164 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v165 = v7 * v164;
            if ((float)(v7 * v164) > 0.0)
            {
              float v166 = *(float *)v3.i32 * v164;
              if (v4)
              {
                float v167 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_246;
                }
              }
              else
              {
                float v167 = 1.0;
              }
              float v168 = PDAcolordodgePDA(*v18, v167, v166, v165);
              float v166 = v168;
              if (v4)
              {
                float v165 = v169;
                v3.i32[0] = v347;
LABEL_246:
                *int v18 = v166;
                *uint64_t v11 = v165;
                goto LABEL_248;
              }
              *int v18 = v168;
              v3.i32[0] = v347;
            }
          }
LABEL_248:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v162);
          --v163;
        }
        while (v163);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        int v13 = v24;
        if (!v16) {
          return;
        }
      }
    case 19:
      uint64_t v170 = 4 * v12;
      while (1)
      {
        int v171 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v172 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v173 = v7 * v172;
            if ((float)(v7 * v172) > 0.0)
            {
              float v174 = *(float *)v3.i32 * v172;
              if (v4)
              {
                float v175 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_261;
                }
              }
              else
              {
                float v175 = 1.0;
              }
              double v176 = PDAcolorburnPDA(*v18, v175, v174, v173);
              float v174 = *(float *)&v176;
              if (v4)
              {
                float v173 = v177;
                v3.i32[0] = v347;
LABEL_261:
                *int v18 = v174;
                *uint64_t v11 = v173;
                goto LABEL_263;
              }
              *int v18 = *(float *)&v176;
              v3.i32[0] = v347;
            }
          }
LABEL_263:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v170);
          --v171;
        }
        while (v171);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        int v13 = v24;
        if (!v16) {
          return;
        }
      }
    case 20:
      uint64_t v178 = 4 * v12;
      while (1)
      {
        int v179 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v180 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v181 = v7 * v180;
            if ((float)(v7 * v180) > 0.0)
            {
              float v182 = *(float *)v3.i32 * v180;
              if (v4)
              {
                float v183 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_276;
                }
              }
              else
              {
                float v183 = 1.0;
              }
              float v184 = PDAsoftlightPDA(*v18, v183, v182, v181);
              float v182 = v184;
              if (v4)
              {
                float v181 = v185;
                v3.i32[0] = v347;
LABEL_276:
                *int v18 = v182;
                *uint64_t v11 = v181;
                goto LABEL_278;
              }
              *int v18 = v184;
              v3.i32[0] = v347;
            }
          }
LABEL_278:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v178);
          --v179;
        }
        while (v179);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        int v13 = v24;
        if (!v16) {
          return;
        }
      }
    case 21:
      uint64_t v186 = 4 * v12;
      while (1)
      {
        int v187 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v188 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v189 = v7 * v188;
            if ((float)(v7 * v188) > 0.0)
            {
              float v190 = *(float *)v3.i32 * v188;
              if (v4)
              {
                float v191 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_291;
                }
              }
              else
              {
                float v191 = 1.0;
              }
              float v192 = PDAhardlightPDA(*v18, v191, v190, v189);
              float v190 = v192;
              if (v4)
              {
                float v189 = v193;
                v3.i32[0] = v347;
LABEL_291:
                *int v18 = v190;
                *uint64_t v11 = v189;
                goto LABEL_293;
              }
              *int v18 = v192;
              v3.i32[0] = v347;
            }
          }
LABEL_293:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v186);
          --v187;
        }
        while (v187);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        int v13 = v24;
        if (!v16) {
          return;
        }
      }
    case 22:
      uint64_t v194 = 4 * v12;
      while (1)
      {
        int v195 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v196 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v197 = v7 * v196;
            if ((float)(v7 * v196) > 0.0)
            {
              float v198 = *(float *)v3.i32 * v196;
              if (v4)
              {
                float v199 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_308;
                }
              }
              else
              {
                float v199 = 1.0;
              }
              float v200 = v198 + *v18;
              float v201 = v197 * *v18;
              float v202 = v198 * v199;
              float v203 = v200 - v201;
              float v204 = v201 - v202;
              float v205 = v203 - v202;
              if (v204 < 0.0) {
                float v204 = -v204;
              }
              float v198 = v205 + v204;
              if (v4)
              {
                float v197 = (float)(v197 + v199) - (float)(v199 * v197);
LABEL_308:
                *int v18 = v198;
                *uint64_t v11 = v197;
                goto LABEL_310;
              }
              *int v18 = v198;
            }
          }
LABEL_310:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v194);
          --v195;
        }
        while (v195);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 23:
      uint64_t v206 = 4 * v12;
      while (1)
      {
        int v207 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v208 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v209 = v7 * v208;
            if ((float)(v7 * v208) > 0.0)
            {
              float v210 = *(float *)v3.i32 * v208;
              if (v4)
              {
                float v211 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_323;
                }
              }
              else
              {
                float v211 = 1.0;
              }
              float v210 = (float)(v210 + *v18) + (float)((float)(v210 * *v18) * -2.0);
              if (v4)
              {
                float v209 = (float)(v209 + v211) - (float)(v211 * v209);
LABEL_323:
                *int v18 = v210;
                *uint64_t v11 = v209;
                goto LABEL_325;
              }
              *int v18 = v210;
            }
          }
LABEL_325:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v206);
          --v207;
        }
        while (v207);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 24:
      uint64_t v212 = 4 * v12;
      while (1)
      {
        int v213 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v214 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v215 = v7 * v214;
            if ((float)(v7 * v214) > 0.0)
            {
              float v216 = *(float *)v3.i32 * v214;
              if (v4)
              {
                float v217 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_343;
                }
              }
              else
              {
                float v217 = 1.0;
              }
              float v218 = *v18;
              if (v215 == 1.0)
              {
                float v219 = 0.0;
              }
              else
              {
                float v218 = v215 * *v18;
                float v219 = *v18 - v218;
              }
              float v220 = (float)(v216 + v219) - (float)(v216 * v217);
              if (v217 == 1.0) {
                float v220 = v219;
              }
              float v216 = v218 + v220;
              if (v4)
              {
                float v215 = (float)(v215 + v217) - (float)(v215 * v217);
LABEL_343:
                *int v18 = v216;
                *uint64_t v11 = v215;
                goto LABEL_345;
              }
              *int v18 = v216;
            }
          }
LABEL_345:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v212);
          --v213;
        }
        while (v213);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 25:
      uint64_t v221 = 4 * v12;
      while (1)
      {
        int v222 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v223 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v224 = v7 * v223;
            if ((float)(v7 * v223) > 0.0)
            {
              float v225 = *(float *)v3.i32 * v223;
              if (v4)
              {
                float v226 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_363;
                }
              }
              else
              {
                float v226 = 1.0;
              }
              float v227 = *v18;
              if (v224 == 1.0)
              {
                float v228 = 0.0;
              }
              else
              {
                float v227 = v224 * *v18;
                float v228 = *v18 - v227;
              }
              float v229 = (float)(v225 + v228) - (float)(v225 * v226);
              if (v226 == 1.0) {
                float v229 = v228;
              }
              float v225 = v227 + v229;
              if (v4)
              {
                float v224 = (float)(v224 + v226) - (float)(v224 * v226);
LABEL_363:
                *int v18 = v225;
                *uint64_t v11 = v224;
                goto LABEL_365;
              }
              *int v18 = v225;
            }
          }
LABEL_365:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v221);
          --v222;
        }
        while (v222);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 26:
      uint64_t v230 = 4 * v12;
      while (1)
      {
        int v231 = v13;
        do
        {
          if (*(unsigned char *)v20)
          {
            float v232 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            float v233 = v7 * v232;
            if ((float)(v7 * v232) > 0.0)
            {
              float v234 = *(float *)v3.i32 * v232;
              if (v4)
              {
                float v235 = *v11;
                if (*v11 <= 0.0) {
                  goto LABEL_382;
                }
              }
              else
              {
                float v235 = 1.0;
              }
              float v236 = *v18;
              float v237 = v234 - (float)(v234 * v235);
              if (v235 == 1.0) {
                float v237 = 0.0;
              }
              float v238 = (float)(v236 + v237) - (float)(v233 * v236);
              if (v233 != 1.0)
              {
                float v236 = v233 * v236;
                float v237 = v238;
              }
              float v234 = v236 + v237;
              if (v4)
              {
                float v233 = (float)(v233 + v235) - (float)(v233 * v235);
LABEL_382:
                *int v18 = v234;
                *uint64_t v11 = v233;
                goto LABEL_384;
              }
              *int v18 = v234;
            }
          }
LABEL_384:
          ++v20;
          ++v18;
          uint64_t v11 = (float *)((char *)v11 + v230);
          --v231;
        }
        while (v231);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16) {
          return;
        }
      }
    case 27:
      uint64_t v239 = 4 * v12;
      break;
    default:
      return;
  }
  do
  {
    int v240 = v13;
    do
    {
      if (*(unsigned char *)v20)
      {
        float v241 = (float)*(unsigned __int8 *)v20 * 0.0039216;
        float v242 = v7 * v241;
        if ((float)(v7 * v241) > 0.0)
        {
          float v243 = *(float *)v3.i32 * v241;
          if (v4)
          {
            float v244 = *v11;
            if (*v11 <= 0.0) {
              goto LABEL_401;
            }
          }
          else
          {
            float v244 = 1.0;
          }
          float v245 = *v18 - (float)(v242 * *v18);
          if (v242 == 1.0) {
            float v245 = 0.0;
          }
          float v246 = (float)(v243 + v245) - (float)(v243 * v244);
          if (v244 != 1.0)
          {
            float v243 = v243 * v244;
            float v245 = v246;
          }
          float v243 = v243 + v245;
          if (v4)
          {
            float v242 = (float)(v242 + v244) - (float)(v242 * v244);
LABEL_401:
            *int v18 = v243;
            *uint64_t v11 = v242;
            goto LABEL_403;
          }
          *int v18 = v243;
        }
      }
LABEL_403:
      ++v20;
      ++v18;
      uint64_t v11 = (float *)((char *)v11 + v239);
      --v240;
    }
    while (v240);
    v20 += v21;
    v18 += v22;
    v11 += v15;
    --v16;
  }
  while (v16);
}

void Wf_mark_pixelmask(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v5 = *(int *)(a1 + 12);
  uint64_t v4 = *(int *)(a1 + 16);
  if (v2)
  {
    unint64_t v6 = (unint64_t)*(int *)(a1 + 32) >> 2;
    float v7 = (float *)(v2 + 4 * (v5 + v6 * v4));
    int v8 = -1;
    if (!v3) {
      return;
    }
  }
  else
  {
    float v7 = 0;
    unint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return;
    }
  }
  int v10 = *(_DWORD *)(a1 + 4);
  int v9 = *(_DWORD *)(a1 + 8);
  unint64_t v12 = *(void *)(a1 + 88);
  uint64_t v11 = *(void *)(a1 + 96);
  unint64_t v13 = (unint64_t)*(int *)(a1 + 28) >> 2;
  unint64_t v14 = (float *)(*(void *)(a1 + 40) + 4 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(a1 + 124);
  int v16 = (unsigned char *)(v3 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(a1 + 56);
  uint64_t v18 = *(int *)(a1 + 60);
  unint64_t v19 = *(int *)(a1 + 76);
  if ((*(_DWORD *)a1 & 0xFF00) == 0x100)
  {
    uint64_t v20 = v19 >> 2;
    if (v11)
    {
      unint64_t v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
      v11 += 4 * (v17 + v21 * v18);
      int v713 = -1;
    }
    else
    {
      unint64_t v21 = 0;
      int v713 = 0;
    }
    int v24 = (char *)(v12 + 4 * (v17 + v20 * v18));
    if (v20 == v13 && (char *)v14 - v24 >= 1)
    {
      if (v10 >= (uint64_t)((unint64_t)((char *)v14 - v24) >> 2))
      {
        v14 += v10 - 1;
        v24 += 4 * v10 - 4;
        v16 += v10 - 1;
        v7 += v8 & (v10 - 1);
        int v26 = -1;
        uint64_t v20 = (unint64_t)*(int *)(a1 + 28) >> 2;
        v11 += 4 * (v713 & (v10 - 1));
        goto LABEL_16;
      }
      uint64_t v25 = v9 - 1;
      if (v14 <= (float *)&v24[4 * v13 * v25 - 4 + 4 * v10])
      {
        v14 += v13 * v25;
        uint64_t v20 = -(uint64_t)v13;
        v16 += v15 * v25;
        uint64_t v15 = -v15;
        v7 += v6 * v25;
        unint64_t v6 = -(uint64_t)v6;
        v8 &= 1u;
        v11 += 4 * v21 * v25;
        unint64_t v21 = -(uint64_t)v21;
        v713 &= 1u;
        int v26 = 1;
        v24 += 4 * v13 * v25;
        unint64_t v13 = -(uint64_t)v13;
        goto LABEL_16;
      }
    }
    v8 &= 1u;
    v713 &= 1u;
    int v26 = 1;
LABEL_16:
    unint64_t v27 = 0;
    v712 = 0;
    unint64_t v12 = -1;
    int v23 = v21;
    int v22 = v20;
    goto LABEL_19;
  }
  int v22 = *(_DWORD *)(a1 + 64);
  int v23 = *(_DWORD *)(a1 + 68);
  uint64_t v20 = v19 >> 2;
  if (v11)
  {
    unint64_t v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
    int v713 = 1;
  }
  else
  {
    unint64_t v21 = 0;
    int v713 = 0;
  }
  unint64_t v27 = v12 + 4 * v20 * v23;
  v8 &= 1u;
  int v26 = 1;
  v712 = *(char **)(a1 + 88);
  int v24 = v712;
LABEL_19:
  int v714 = v8;
  int v28 = v26 * v10;
  if (v27)
  {
    uint64_t v29 = (int)v18 % v23;
    unsigned int v30 = &v24[4 * v20 * v29];
    uint64_t v31 = (int)v17 % v22;
    int v24 = &v30[4 * v31];
    unint64_t v12 = (unint64_t)&v30[4 * v22];
    if (v713) {
      v11 += 4 * v21 * v29 + 4 * v31;
    }
    v712 = &v30[4 * v31];
  }
  else
  {
    v20 -= v28;
    v21 -= v713 * v10;
  }
  uint64_t v32 = v15 - v28;
  unint64_t v33 = v13 - v28;
  unint64_t v711 = v6 - v714 * v10;
  uint64_t v688 = v20;
  int v689 = v10;
  unint64_t v686 = v33;
  uint64_t v687 = v32;
  unint64_t v690 = v27;
  switch(a2)
  {
    case 0:
      if (v714)
      {
        do
        {
          int v34 = v10;
          do
          {
            unsigned int v35 = *v16;
            if (*v16)
            {
              if (v35 == 255)
              {
                *float v7 = 0.0;
                *unint64_t v14 = 0.0;
              }
              else
              {
                float v36 = (float)((float)v35 * -0.0039216) + 1.0;
                *unint64_t v14 = v36 * *v14;
                *float v7 = v36 * *v7;
              }
            }
            v16 += v26;
            v7 += v714;
            v14 += v26;
            --v34;
          }
          while (v34);
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v578 = v10;
          do
          {
            unsigned int v579 = *v16;
            if (*v16)
            {
              float v580 = 0.0;
              if (v579 != 255) {
                float v580 = (float)((float)((float)v579 * -0.0039216) + 1.0) * *v14;
              }
              *unint64_t v14 = v580;
            }
            v16 += v26;
            v14 += v26;
            --v578;
          }
          while (v578);
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 1:
      if (v714)
      {
        uint64_t v37 = v26;
        if (v713)
        {
          uint64_t v38 = v23;
          uint64_t v39 = -(v20 * v23);
          uint64_t v40 = -(uint64_t)(v21 * v38);
          unsigned int v41 = (float *)v11;
          uint64_t v42 = -(uint64_t)v22;
          do
          {
            int v43 = v10;
            do
            {
              unsigned int v44 = *v16;
              if (*v16)
              {
                if (v44 == 255)
                {
                  *unint64_t v14 = *(float *)v24;
                  float v45 = *v41;
                }
                else
                {
                  float v46 = (float)v44 * 0.0039216;
                  *unint64_t v14 = (float)((float)(1.0 - v46) * *v14) + (float)(*(float *)v24 * v46);
                  float v45 = (float)((float)(1.0 - v46) * *v7) + (float)(*v41 * v46);
                }
                *float v7 = v45;
              }
              v16 += v37;
              char v47 = &v24[4 * v37];
              int v48 = &v41[v713];
              if ((unint64_t)v47 >= v12) {
                uint64_t v49 = v42;
              }
              else {
                uint64_t v49 = 0;
              }
              unsigned int v41 = &v48[v49];
              int v24 = &v47[4 * v49];
              v7 += v714;
              v14 += v37;
              --v43;
            }
            while (v43);
            if (v27)
            {
              unsigned int v50 = &v712[4 * v20];
              if ((unint64_t)v50 >= v27) {
                uint64_t v51 = v40;
              }
              else {
                uint64_t v51 = 0;
              }
              v11 += 4 * v21 + 4 * v51;
              if ((unint64_t)v50 >= v27) {
                uint64_t v52 = v39;
              }
              else {
                uint64_t v52 = 0;
              }
              int v24 = &v50[4 * v52];
              v12 += 4 * v52 + 4 * v20;
              unsigned int v41 = (float *)v11;
              v712 = v24;
            }
            else
            {
              v24 += 4 * v20;
              v41 += v21;
            }
            v16 += v32;
            v14 += v33;
            v7 += v711;
            --v9;
          }
          while (v9);
        }
        else
        {
          uint64_t v663 = -(uint64_t)v22;
          uint64_t v664 = -(v20 * v23);
          do
          {
            int v665 = v10;
            do
            {
              unsigned int v666 = *v16;
              if (*v16)
              {
                if (v666 == 255)
                {
                  *unint64_t v14 = *(float *)v24;
                  float v667 = 1.0;
                }
                else
                {
                  float v668 = (float)v666 * 0.0039216;
                  *unint64_t v14 = (float)((float)(1.0 - v668) * *v14) + (float)(*(float *)v24 * v668);
                  float v667 = v668 + (float)((float)(1.0 - v668) * *v7);
                }
                *float v7 = v667;
              }
              v16 += v37;
              int v669 = &v24[4 * v37];
              if ((unint64_t)v669 >= v12) {
                uint64_t v670 = v663;
              }
              else {
                uint64_t v670 = 0;
              }
              int v24 = &v669[4 * v670];
              v7 += v714;
              v14 += v37;
              --v665;
            }
            while (v665);
            v16 += v32;
            v14 += v33;
            uint64_t v671 = v712;
            v7 += v711;
            uint64_t v672 = &v712[4 * v20];
            if ((unint64_t)v672 >= v27) {
              uint64_t v673 = v664;
            }
            else {
              uint64_t v673 = 0;
            }
            uint64_t v674 = &v672[4 * v673];
            uint64_t v675 = v12 + 4 * v673 + 4 * v20;
            if (v27)
            {
              unint64_t v12 = v675;
              uint64_t v671 = v674;
            }
            v712 = v671;
            if (v27) {
              int v24 = v674;
            }
            else {
              v24 += 4 * v20;
            }
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        uint64_t v581 = v26;
        uint64_t v582 = -(uint64_t)v22;
        uint64_t v583 = -(v20 * v23);
        uint64_t v584 = 4 * v26;
        do
        {
          int v585 = v10;
          do
          {
            unsigned int v586 = *v16;
            if (*v16)
            {
              if (v586 == 255) {
                float v587 = *(float *)v24;
              }
              else {
                float v587 = (float)((float)(1.0 - (float)((float)v586 * 0.0039216)) * *v14)
              }
                     + (float)(*(float *)v24 * (float)((float)v586 * 0.0039216));
              *unint64_t v14 = v587;
            }
            v16 += v581;
            v588 = &v24[4 * v581];
            if ((unint64_t)v588 >= v12) {
              uint64_t v589 = v582;
            }
            else {
              uint64_t v589 = 0;
            }
            int v24 = &v588[4 * v589];
            unint64_t v14 = (float *)((char *)v14 + v584);
            --v585;
          }
          while (v585);
          v16 += v32;
          v14 += v33;
          int v590 = v712;
          double v591 = &v712[4 * v20];
          if ((unint64_t)v591 >= v27) {
            uint64_t v592 = v583;
          }
          else {
            uint64_t v592 = 0;
          }
          double v593 = &v591[4 * v592];
          uint64_t v594 = v12 + 4 * v592 + 4 * v20;
          if (v27)
          {
            unint64_t v12 = v594;
            int v590 = v593;
          }
          v712 = v590;
          if (v27) {
            int v24 = v593;
          }
          else {
            v24 += 4 * v20;
          }
          --v9;
        }
        while (v9);
      }
      return;
    case 2:
      uint64_t v53 = v26;
      if (v714)
      {
        uint64_t v54 = -(uint64_t)v22;
        uint64_t v55 = v23;
        uint64_t v56 = -(v20 * v23);
        uint64_t v57 = -(uint64_t)(v21 * v55);
        float v58 = (float *)v11;
        while (1)
        {
          int v59 = v10;
          do
          {
            unsigned int v60 = *v16;
            if (!*v16) {
              goto LABEL_73;
            }
            if (v60 == 255)
            {
              float v61 = *v58;
              if (*v58 >= 1.0)
              {
                *unint64_t v14 = *(float *)v24;
                goto LABEL_72;
              }
              if (v61 <= 0.0) {
                goto LABEL_73;
              }
              float v62 = *(float *)v24;
            }
            else
            {
              float v63 = (float)v60 * 0.0039216;
              float v61 = v63 * *v58;
              if (v61 <= 0.0) {
                goto LABEL_73;
              }
              float v62 = v63 * *(float *)v24;
            }
            *unint64_t v14 = v62 + (float)(*v14 * (float)(1.0 - v61));
            float v61 = v61 + (float)(*v7 * (float)(1.0 - v61));
LABEL_72:
            *float v7 = v61;
LABEL_73:
            v16 += v53;
            float v64 = &v24[4 * v53];
            float v65 = &v58[v713];
            if ((unint64_t)v64 >= v12) {
              uint64_t v66 = v54;
            }
            else {
              uint64_t v66 = 0;
            }
            float v58 = &v65[v66];
            int v24 = &v64[4 * v66];
            v7 += v714;
            v14 += v53;
            --v59;
          }
          while (v59);
          if (v27)
          {
            float v67 = &v712[4 * v20];
            if ((unint64_t)v67 >= v27) {
              uint64_t v68 = v57;
            }
            else {
              uint64_t v68 = 0;
            }
            v11 += 4 * v21 + 4 * v68;
            if ((unint64_t)v67 >= v27) {
              uint64_t v69 = v56;
            }
            else {
              uint64_t v69 = 0;
            }
            int v24 = &v67[4 * v69];
            v12 += 4 * v69 + 4 * v20;
            float v58 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v58 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          if (!--v9) {
            return;
          }
        }
      }
      uint64_t v595 = -(uint64_t)v22;
      uint64_t v596 = v23;
      uint64_t v597 = -(v20 * v23);
      uint64_t v598 = -(uint64_t)(v21 * v596);
      float v599 = (float *)v11;
LABEL_830:
      int v600 = v10;
      while (1)
      {
        unsigned int v601 = *v16;
        if (*v16)
        {
          if (v601 == 255)
          {
            float v602 = *v599;
            if (*v599 >= 1.0)
            {
              float v603 = *(float *)v24;
              goto LABEL_839;
            }
            if (v602 > 0.0)
            {
              float v603 = *(float *)v24 + (float)(*v14 * (float)(1.0 - v602));
LABEL_839:
              *unint64_t v14 = v603;
            }
          }
          else
          {
            float v604 = (float)v601 * 0.0039216;
            float v605 = v604 * *v599;
            if (v605 > 0.0)
            {
              float v603 = (float)(v604 * *(float *)v24) + (float)(*v14 * (float)(1.0 - v605));
              goto LABEL_839;
            }
          }
        }
        v16 += v53;
        float v606 = &v24[4 * v53];
        float v607 = &v599[v713];
        if ((unint64_t)v606 >= v12) {
          uint64_t v608 = v595;
        }
        else {
          uint64_t v608 = 0;
        }
        float v599 = &v607[v608];
        int v24 = &v606[4 * v608];
        v14 += v53;
        if (!--v600)
        {
          if (v27)
          {
            int v609 = &v712[4 * v20];
            if ((unint64_t)v609 >= v27) {
              uint64_t v610 = v598;
            }
            else {
              uint64_t v610 = 0;
            }
            v11 += 4 * v21 + 4 * v610;
            if ((unint64_t)v609 >= v27) {
              uint64_t v611 = v597;
            }
            else {
              uint64_t v611 = 0;
            }
            int v24 = &v609[4 * v611];
            v12 += 4 * v611 + 4 * v20;
            float v599 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v599 += v21;
          }
          v16 += v32;
          v14 += v33;
          if (!--v9) {
            return;
          }
          goto LABEL_830;
        }
      }
    case 3:
      uint64_t v70 = v26;
      uint64_t v71 = v23;
      uint64_t v72 = -(v20 * v23);
      uint64_t v73 = -(uint64_t)(v21 * v71);
      uint64_t v74 = 4 * v26;
      uint64_t v75 = -(uint64_t)v22;
      uint64_t v76 = (float *)v11;
      do
      {
        int v77 = v10;
        do
        {
          unsigned int v78 = *v16;
          if (*v16)
          {
            if (v78 == 255)
            {
              *unint64_t v14 = *(float *)v24 * *v7;
              if (v713) {
                float v79 = *v76;
              }
              else {
                float v79 = 1.0;
              }
              float v85 = v79 * *v7;
            }
            else
            {
              float v80 = (float)v78 * 0.0039216;
              float v81 = *v7;
              float v82 = v80 * *v7;
              float v83 = 1.0;
              float v84 = 1.0 - v80;
              *unint64_t v14 = (float)(v84 * *v14) + (float)(*(float *)v24 * v82);
              if (v713) {
                float v83 = *v76;
              }
              float v85 = (float)(v84 * v81) + (float)(v83 * v82);
            }
            *float v7 = v85;
          }
          v16 += v70;
          int v86 = &v24[4 * v70];
          unsigned int v87 = &v76[v713];
          if ((unint64_t)v86 >= v12) {
            uint64_t v88 = v75;
          }
          else {
            uint64_t v88 = 0;
          }
          uint64_t v76 = &v87[v88];
          int v24 = &v86[4 * v88];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v74);
          --v77;
        }
        while (v77);
        if (v27)
        {
          float v89 = &v712[4 * v20];
          if ((unint64_t)v89 >= v27) {
            uint64_t v90 = v73;
          }
          else {
            uint64_t v90 = 0;
          }
          v11 += 4 * v21 + 4 * v90;
          if ((unint64_t)v89 >= v27) {
            uint64_t v91 = v72;
          }
          else {
            uint64_t v91 = 0;
          }
          int v24 = &v89[4 * v91];
          v12 += 4 * v91 + 4 * v20;
          uint64_t v76 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v76 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 4:
      uint64_t v92 = v26;
      uint64_t v93 = v23;
      uint64_t v94 = -(v20 * v23);
      uint64_t v95 = -(uint64_t)(v21 * v93);
      uint64_t v96 = 4 * v26;
      uint64_t v97 = -(uint64_t)v22;
      float v98 = (float *)v11;
      do
      {
        int v99 = v10;
        do
        {
          unsigned int v100 = *v16;
          if (*v16)
          {
            if (v100 == 255)
            {
              float v101 = 1.0;
              *unint64_t v14 = *(float *)v24 * (float)(1.0 - *v7);
              if (v713) {
                float v101 = *v98;
              }
              float v102 = v101 * (float)(1.0 - *v7);
            }
            else
            {
              float v103 = (float)v100 * 0.0039216;
              float v104 = *v7;
              float v105 = 1.0;
              float v106 = v103 * (float)(1.0 - *v7);
              float v107 = 1.0 - v103;
              *unint64_t v14 = (float)(v107 * *v14) + (float)(*(float *)v24 * v106);
              if (v713) {
                float v105 = *v98;
              }
              float v102 = (float)(v107 * v104) + (float)(v105 * v106);
            }
            *float v7 = v102;
          }
          v16 += v92;
          float v108 = &v24[4 * v92];
          float v109 = &v98[v713];
          if ((unint64_t)v108 >= v12) {
            uint64_t v110 = v97;
          }
          else {
            uint64_t v110 = 0;
          }
          float v98 = &v109[v110];
          int v24 = &v108[4 * v110];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v96);
          --v99;
        }
        while (v99);
        if (v27)
        {
          uint64_t v111 = &v712[4 * v20];
          if ((unint64_t)v111 >= v27) {
            uint64_t v112 = v95;
          }
          else {
            uint64_t v112 = 0;
          }
          v11 += 4 * v21 + 4 * v112;
          if ((unint64_t)v111 >= v27) {
            uint64_t v113 = v94;
          }
          else {
            uint64_t v113 = 0;
          }
          int v24 = &v111[4 * v113];
          v12 += 4 * v113 + 4 * v20;
          float v98 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v98 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 5:
      uint64_t v114 = v26;
      uint64_t v115 = v23;
      uint64_t v116 = -(v20 * v23);
      uint64_t v117 = -(uint64_t)(v21 * v115);
      uint64_t v118 = 4 * v26;
      uint64_t v119 = -(uint64_t)v22;
      int v120 = (float *)v11;
      do
      {
        int v121 = v10;
        do
        {
          if (*v16)
          {
            float v122 = *v7;
            float v123 = (float)*v16 * 0.0039216;
            float v124 = v123 * *(float *)v24;
            float v125 = v123 * *v120;
            *unint64_t v14 = (float)(*v14 * (float)(1.0 - v125)) + (float)(v124 * *v7);
            *float v7 = (float)(v122 * (float)(1.0 - v125)) + (float)(v125 * v122);
          }
          v16 += v114;
          int v126 = &v24[4 * v114];
          float v127 = &v120[v713];
          if ((unint64_t)v126 >= v12) {
            uint64_t v128 = v119;
          }
          else {
            uint64_t v128 = 0;
          }
          int v120 = &v127[v128];
          int v24 = &v126[4 * v128];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v118);
          --v121;
        }
        while (v121);
        if (v27)
        {
          float v129 = &v712[4 * v20];
          if ((unint64_t)v129 >= v27) {
            uint64_t v130 = v117;
          }
          else {
            uint64_t v130 = 0;
          }
          v11 += 4 * v21 + 4 * v130;
          if ((unint64_t)v129 >= v27) {
            uint64_t v131 = v116;
          }
          else {
            uint64_t v131 = 0;
          }
          int v24 = &v129[4 * v131];
          v12 += 4 * v131 + 4 * v20;
          int v120 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v120 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 6:
      uint64_t v132 = v26;
      uint64_t v133 = v23;
      uint64_t v134 = -(v20 * v23);
      uint64_t v135 = -(uint64_t)(v21 * v133);
      uint64_t v136 = 4 * v26;
      uint64_t v137 = -(uint64_t)v22;
      uint64_t v138 = (float *)v11;
      while (1)
      {
        int v139 = v10;
        do
        {
          unsigned int v140 = *v16;
          if (!*v16) {
            goto LABEL_174;
          }
          float v141 = *v7;
          float v142 = 1.0 - *v7;
          if (v142 >= 1.0)
          {
            float v145 = (float)v140 * 0.0039216;
            *unint64_t v14 = v145 * *(float *)v24;
            if (v713) {
              float v146 = *v138;
            }
            else {
              float v146 = 1.0;
            }
            float v147 = v145 * v146;
          }
          else
          {
            if (v142 <= 0.0) {
              goto LABEL_174;
            }
            float v143 = (float)((float)v140 * 0.0039216) * v142;
            *unint64_t v14 = *v14 + (float)(*(float *)v24 * v143);
            if (v713) {
              float v144 = *v138;
            }
            else {
              float v144 = 1.0;
            }
            float v147 = v141 + (float)(v144 * v143);
          }
          *float v7 = v147;
LABEL_174:
          v16 += v132;
          float v148 = &v24[4 * v132];
          float v149 = &v138[v713];
          if ((unint64_t)v148 >= v12) {
            uint64_t v150 = v137;
          }
          else {
            uint64_t v150 = 0;
          }
          uint64_t v138 = &v149[v150];
          int v24 = &v148[4 * v150];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v136);
          --v139;
        }
        while (v139);
        if (v27)
        {
          float v151 = &v712[4 * v20];
          if ((unint64_t)v151 >= v27) {
            uint64_t v152 = v135;
          }
          else {
            uint64_t v152 = 0;
          }
          v11 += 4 * v21 + 4 * v152;
          if ((unint64_t)v151 >= v27) {
            uint64_t v153 = v134;
          }
          else {
            uint64_t v153 = 0;
          }
          int v24 = &v151[4 * v153];
          v12 += 4 * v153 + 4 * v20;
          uint64_t v138 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v138 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 7:
      uint64_t v154 = v26;
      if (v714)
      {
        uint64_t v155 = v23;
        uint64_t v156 = -(v20 * v23);
        uint64_t v157 = -(uint64_t)(v21 * v155);
        uint64_t v158 = -(uint64_t)v22;
        float v159 = (float *)v11;
        do
        {
          int v160 = v10;
          do
          {
            unsigned int v161 = *v16;
            if (*v16)
            {
              if (v161 == 255)
              {
                *unint64_t v14 = *v14 * *v159;
                float v162 = *v7 * *v159;
              }
              else
              {
                float v163 = (float)v161 * 0.0039216;
                float v164 = *v7;
                *unint64_t v14 = (float)((float)(1.0 - v163) * *v14) + (float)(*v14 * (float)(v163 * *v159));
                float v162 = (float)((float)(1.0 - v163) * v164) + (float)(v164 * (float)(v163 * *v159));
              }
              *float v7 = v162;
            }
            v16 += v154;
            float v165 = &v24[4 * v154];
            float v166 = &v159[v713];
            if ((unint64_t)v165 >= v12) {
              uint64_t v167 = v158;
            }
            else {
              uint64_t v167 = 0;
            }
            float v159 = &v166[v167];
            int v24 = &v165[4 * v167];
            v7 += v714;
            v14 += v154;
            --v160;
          }
          while (v160);
          if (v27)
          {
            float v168 = &v712[4 * v20];
            if ((unint64_t)v168 >= v27) {
              uint64_t v169 = v157;
            }
            else {
              uint64_t v169 = 0;
            }
            v11 += 4 * v21 + 4 * v169;
            if ((unint64_t)v168 >= v27) {
              uint64_t v170 = v156;
            }
            else {
              uint64_t v170 = 0;
            }
            int v24 = &v168[4 * v170];
            v12 += 4 * v170 + 4 * v20;
            float v159 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v159 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v612 = -(uint64_t)v22;
        uint64_t v613 = v23;
        uint64_t v614 = -(v20 * v23);
        uint64_t v615 = -(uint64_t)(v21 * v613);
        int v616 = (float *)v11;
        do
        {
          int v617 = v10;
          do
          {
            unsigned int v618 = *v16;
            if (*v16)
            {
              if (v618 == 255) {
                float v619 = *v14 * *v616;
              }
              else {
                float v619 = (float)((float)(1.0 - (float)((float)v618 * 0.0039216)) * *v14)
              }
                     + (float)(*v14 * (float)((float)((float)v618 * 0.0039216) * *v616));
              *unint64_t v14 = v619;
            }
            v16 += v154;
            float v620 = &v24[4 * v154];
            float v621 = &v616[v713];
            if ((unint64_t)v620 >= v12) {
              uint64_t v622 = v612;
            }
            else {
              uint64_t v622 = 0;
            }
            int v616 = &v621[v622];
            int v24 = &v620[4 * v622];
            v14 += v154;
            --v617;
          }
          while (v617);
          if (v27)
          {
            int v623 = &v712[4 * v20];
            if ((unint64_t)v623 >= v27) {
              uint64_t v624 = v615;
            }
            else {
              uint64_t v624 = 0;
            }
            v11 += 4 * v21 + 4 * v624;
            if ((unint64_t)v623 >= v27) {
              uint64_t v625 = v614;
            }
            else {
              uint64_t v625 = 0;
            }
            int v24 = &v623[4 * v625];
            v12 += 4 * v625 + 4 * v20;
            int v616 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v616 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 8:
      uint64_t v171 = v26;
      if (v714)
      {
        uint64_t v172 = -(uint64_t)v22;
        uint64_t v173 = v23;
        uint64_t v174 = -(v20 * v23);
        uint64_t v175 = -(uint64_t)(v21 * v173);
        double v176 = (float *)v11;
        do
        {
          int v177 = v10;
          do
          {
            unsigned int v178 = *v16;
            if (*v16)
            {
              if (v178 == 255)
              {
                *unint64_t v14 = *v14 * (float)(1.0 - *v176);
                float v179 = *v176;
              }
              else
              {
                float v180 = (float)v178 * 0.0039216;
                *unint64_t v14 = *v14 * (float)(1.0 - (float)(v180 * *v176));
                float v179 = v180 * *v176;
              }
              *float v7 = *v7 * (float)(1.0 - v179);
            }
            v16 += v171;
            float v181 = &v24[4 * v171];
            float v182 = &v176[v713];
            if ((unint64_t)v181 >= v12) {
              uint64_t v183 = v172;
            }
            else {
              uint64_t v183 = 0;
            }
            double v176 = &v182[v183];
            int v24 = &v181[4 * v183];
            v7 += v714;
            v14 += v171;
            --v177;
          }
          while (v177);
          if (v27)
          {
            float v184 = &v712[4 * v20];
            if ((unint64_t)v184 >= v27) {
              uint64_t v185 = v175;
            }
            else {
              uint64_t v185 = 0;
            }
            v11 += 4 * v21 + 4 * v185;
            if ((unint64_t)v184 >= v27) {
              uint64_t v186 = v174;
            }
            else {
              uint64_t v186 = 0;
            }
            int v24 = &v184[4 * v186];
            v12 += 4 * v186 + 4 * v20;
            double v176 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v176 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v626 = -(uint64_t)v22;
        uint64_t v627 = v23;
        uint64_t v628 = -(v20 * v23);
        uint64_t v629 = -(uint64_t)(v21 * v627);
        float v630 = (float *)v11;
        do
        {
          int v631 = v10;
          do
          {
            unsigned int v632 = *v16;
            if (*v16)
            {
              if (v632 == 255) {
                float v633 = *v630;
              }
              else {
                float v633 = (float)((float)v632 * 0.0039216) * *v630;
              }
              *unint64_t v14 = *v14 * (float)(1.0 - v633);
            }
            v16 += v171;
            int v634 = &v24[4 * v171];
            int v635 = &v630[v713];
            if ((unint64_t)v634 >= v12) {
              uint64_t v636 = v626;
            }
            else {
              uint64_t v636 = 0;
            }
            float v630 = &v635[v636];
            int v24 = &v634[4 * v636];
            v14 += v171;
            --v631;
          }
          while (v631);
          if (v27)
          {
            float v637 = &v712[4 * v20];
            if ((unint64_t)v637 >= v27) {
              uint64_t v638 = v629;
            }
            else {
              uint64_t v638 = 0;
            }
            v11 += 4 * v21 + 4 * v638;
            if ((unint64_t)v637 >= v27) {
              uint64_t v639 = v628;
            }
            else {
              uint64_t v639 = 0;
            }
            int v24 = &v637[4 * v639];
            v12 += 4 * v639 + 4 * v20;
            float v630 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v630 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 9:
      uint64_t v187 = v26;
      uint64_t v188 = v23;
      uint64_t v189 = -(v20 * v23);
      uint64_t v190 = -(uint64_t)(v21 * v188);
      uint64_t v191 = 4 * v26;
      uint64_t v192 = -(uint64_t)v22;
      float v193 = (float *)v11;
      do
      {
        int v194 = v10;
        do
        {
          if (*v16)
          {
            float v195 = *v7;
            float v196 = (float)*v16 * 0.0039216;
            float v197 = v196 * *(float *)v24;
            float v198 = v196 * *v193;
            float v199 = 1.0 - *v7;
            float v200 = (float)(1.0 - v196) + v198;
            *unint64_t v14 = (float)(*v14 * v200) + (float)(v197 * v199);
            *float v7 = (float)(v195 * v200) + (float)(v198 * v199);
          }
          v16 += v187;
          float v201 = &v24[4 * v187];
          float v202 = &v193[v713];
          if ((unint64_t)v201 >= v12) {
            uint64_t v203 = v192;
          }
          else {
            uint64_t v203 = 0;
          }
          float v193 = &v202[v203];
          int v24 = &v201[4 * v203];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v191);
          --v194;
        }
        while (v194);
        if (v27)
        {
          float v204 = &v712[4 * v20];
          if ((unint64_t)v204 >= v27) {
            uint64_t v205 = v190;
          }
          else {
            uint64_t v205 = 0;
          }
          v11 += 4 * v21 + 4 * v205;
          if ((unint64_t)v204 >= v27) {
            uint64_t v206 = v189;
          }
          else {
            uint64_t v206 = 0;
          }
          int v24 = &v204[4 * v206];
          v12 += 4 * v206 + 4 * v20;
          float v193 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v193 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 10:
      uint64_t v207 = v26;
      uint64_t v208 = v23;
      uint64_t v209 = -(v20 * v23);
      uint64_t v210 = -(uint64_t)(v21 * v208);
      uint64_t v211 = 4 * v26;
      uint64_t v212 = -(uint64_t)v22;
      int v213 = (float *)v11;
      do
      {
        int v214 = v10;
        do
        {
          if (*v16)
          {
            float v215 = *v7;
            float v216 = (float)*v16 * 0.0039216;
            float v217 = v216 * *(float *)v24;
            float v218 = v216 * *v213;
            float v219 = 1.0 - *v7;
            *unint64_t v14 = (float)(*v14 * (float)(1.0 - v218)) + (float)(v217 * v219);
            *float v7 = (float)(v215 * (float)(1.0 - v218)) + (float)(v218 * v219);
          }
          v16 += v207;
          float v220 = &v24[4 * v207];
          uint64_t v221 = &v213[v713];
          if ((unint64_t)v220 >= v12) {
            uint64_t v222 = v212;
          }
          else {
            uint64_t v222 = 0;
          }
          int v213 = &v221[v222];
          int v24 = &v220[4 * v222];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v211);
          --v214;
        }
        while (v214);
        if (v27)
        {
          float v223 = &v712[4 * v20];
          if ((unint64_t)v223 >= v27) {
            uint64_t v224 = v210;
          }
          else {
            uint64_t v224 = 0;
          }
          v11 += 4 * v21 + 4 * v224;
          if ((unint64_t)v223 >= v27) {
            uint64_t v225 = v209;
          }
          else {
            uint64_t v225 = 0;
          }
          int v24 = &v223[4 * v225];
          v12 += 4 * v225 + 4 * v20;
          int v213 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v213 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 11:
      uint64_t v226 = v26;
      if (v714)
      {
        uint64_t v227 = v23;
        uint64_t v228 = -(v20 * v23);
        uint64_t v229 = -(uint64_t)(v21 * v227);
        uint64_t v230 = -(uint64_t)v22;
        int v231 = (float *)v11;
        do
        {
          int v232 = v10;
          do
          {
            if (*v16)
            {
              if (v713) {
                float v233 = *v231;
              }
              else {
                float v233 = 1.0;
              }
              float v234 = (float)*v16 * 0.0039216;
              float v235 = v234 * v233;
              float v236 = *v7 + v235;
              float v237 = (float)(v235 - (float)(v234 * *(float *)v24)) + (float)(*v7 - *v14);
              if (v236 <= 1.0) {
                float v238 = v236;
              }
              else {
                float v238 = 1.0;
              }
              *float v7 = v238;
              *unint64_t v14 = v238 - v237;
            }
            v16 += v226;
            uint64_t v239 = &v24[4 * v226];
            int v240 = &v231[v713];
            if ((unint64_t)v239 >= v12) {
              uint64_t v241 = v230;
            }
            else {
              uint64_t v241 = 0;
            }
            int v231 = &v240[v241];
            int v24 = &v239[4 * v241];
            v7 += v714;
            v14 += v226;
            --v232;
          }
          while (v232);
          if (v27)
          {
            float v242 = &v712[4 * v20];
            if ((unint64_t)v242 >= v27) {
              uint64_t v243 = v229;
            }
            else {
              uint64_t v243 = 0;
            }
            v11 += 4 * v21 + 4 * v243;
            if ((unint64_t)v242 >= v27) {
              uint64_t v244 = v228;
            }
            else {
              uint64_t v244 = 0;
            }
            int v24 = &v242[4 * v244];
            v12 += 4 * v244 + 4 * v20;
            int v231 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v231 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v640 = -(uint64_t)v22;
        uint64_t v641 = v23;
        uint64_t v642 = -(v20 * v23);
        uint64_t v643 = -(uint64_t)(v21 * v641);
        unsigned int v644 = (float *)v11;
        do
        {
          int v645 = v10;
          do
          {
            if (*v16)
            {
              if (v713) {
                float v646 = *v644;
              }
              else {
                float v646 = 1.0;
              }
              *unint64_t v14 = 1.0
                   - (float)((float)(1.0 - *v14)
                           + (float)((float)((float)((float)*v16 * 0.0039216) * v646)
                                   - (float)((float)((float)*v16 * 0.0039216) * *(float *)v24)));
            }
            v16 += v226;
            unint64_t v647 = &v24[4 * v226];
            unint64_t v648 = &v644[v713];
            if ((unint64_t)v647 >= v12) {
              uint64_t v649 = v640;
            }
            else {
              uint64_t v649 = 0;
            }
            unsigned int v644 = &v648[v649];
            int v24 = &v647[4 * v649];
            v14 += v226;
            --v645;
          }
          while (v645);
          if (v27)
          {
            int v650 = &v712[4 * v20];
            if ((unint64_t)v650 >= v27) {
              uint64_t v651 = v643;
            }
            else {
              uint64_t v651 = 0;
            }
            v11 += 4 * v21 + 4 * v651;
            if ((unint64_t)v650 >= v27) {
              uint64_t v652 = v642;
            }
            else {
              uint64_t v652 = 0;
            }
            int v24 = &v650[4 * v652];
            v12 += 4 * v652 + 4 * v20;
            unsigned int v644 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v644 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 12:
      uint64_t v245 = v26;
      if (v714)
      {
        uint64_t v246 = v23;
        uint64_t v247 = -(v20 * v23);
        uint64_t v248 = -(uint64_t)(v21 * v246);
        uint64_t v249 = -(uint64_t)v22;
        int v250 = (float *)v11;
        do
        {
          int v251 = v10;
          do
          {
            if (*v16)
            {
              if (v713) {
                float v252 = *v250;
              }
              else {
                float v252 = 1.0;
              }
              float v253 = (float)*v16 * 0.0039216;
              float v254 = *v7 + (float)(v253 * v252);
              if (v254 > 1.0) {
                float v254 = 1.0;
              }
              *unint64_t v14 = (float)(v253 * *(float *)v24) + *v14;
              *float v7 = v254;
            }
            v16 += v245;
            int v255 = &v24[4 * v245];
            unsigned int v256 = &v250[v713];
            if ((unint64_t)v255 >= v12) {
              uint64_t v257 = v249;
            }
            else {
              uint64_t v257 = 0;
            }
            int v250 = &v256[v257];
            int v24 = &v255[4 * v257];
            v7 += v714;
            v14 += v245;
            --v251;
          }
          while (v251);
          if (v27)
          {
            int v258 = &v712[4 * v20];
            if ((unint64_t)v258 >= v27) {
              uint64_t v259 = v248;
            }
            else {
              uint64_t v259 = 0;
            }
            v11 += 4 * v21 + 4 * v259;
            if ((unint64_t)v258 >= v27) {
              uint64_t v260 = v247;
            }
            else {
              uint64_t v260 = 0;
            }
            int v24 = &v258[4 * v260];
            v12 += 4 * v260 + 4 * v20;
            int v250 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v250 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v653 = -(uint64_t)v22;
        uint64_t v654 = -(v20 * v23);
        do
        {
          int v655 = v10;
          do
          {
            if (*v16) {
              *unint64_t v14 = *v14 + (float)((float)((float)*v16 * 0.0039216) * *(float *)v24);
            }
            v16 += v245;
            int v656 = &v24[4 * v245];
            if ((unint64_t)v656 >= v12) {
              uint64_t v657 = v653;
            }
            else {
              uint64_t v657 = 0;
            }
            int v24 = &v656[4 * v657];
            v14 += v245;
            --v655;
          }
          while (v655);
          v16 += v32;
          v14 += v33;
          uint64_t v658 = v712;
          unint64_t v659 = &v712[4 * v20];
          if ((unint64_t)v659 >= v27) {
            uint64_t v660 = v654;
          }
          else {
            uint64_t v660 = 0;
          }
          int v661 = &v659[4 * v660];
          uint64_t v662 = v12 + 4 * v660 + 4 * v20;
          if (v27)
          {
            unint64_t v12 = v662;
            uint64_t v658 = v661;
          }
          v712 = v658;
          if (v27) {
            int v24 = v661;
          }
          else {
            v24 += 4 * v20;
          }
          --v9;
        }
        while (v9);
      }
      return;
    case 13:
      uint64_t v261 = v26;
      uint64_t v262 = v23;
      uint64_t v263 = -(v20 * v23);
      uint64_t v264 = -(uint64_t)(v21 * v262);
      uint64_t v265 = 4 * v26;
      uint64_t v266 = -(uint64_t)v22;
      unsigned int v267 = (float *)v11;
      while (1)
      {
        int v268 = v10;
        do
        {
          if (*v16)
          {
            float v269 = v713 ? *v267 : 1.0;
            float v270 = (float)*v16 * 0.0039216;
            float v271 = v270 * v269;
            if (v271 > 0.0)
            {
              float v272 = v270 * *(float *)v24;
              if (v714)
              {
                float v273 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_341;
                }
              }
              else
              {
                float v273 = 1.0;
              }
              float v274 = (float)(v272 * *v14) + (float)(*v14 * (float)(1.0 - v271));
              if (v271 == 1.0) {
                float v274 = v272 * *v14;
              }
              float v272 = v274 + (float)(v272 * (float)(1.0 - v273));
              if (v273 == 1.0) {
                float v272 = v274;
              }
              if (v714)
              {
                float v271 = (float)(v271 + v273) - (float)(v273 * v271);
LABEL_341:
                *unint64_t v14 = v272;
                *float v7 = v271;
                goto LABEL_343;
              }
              *unint64_t v14 = v272;
            }
          }
LABEL_343:
          v16 += v261;
          unint64_t v275 = &v24[4 * v261];
          int v276 = &v267[v713];
          if ((unint64_t)v275 >= v12) {
            uint64_t v277 = v266;
          }
          else {
            uint64_t v277 = 0;
          }
          unsigned int v267 = &v276[v277];
          int v24 = &v275[4 * v277];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v265);
          --v268;
        }
        while (v268);
        if (v27)
        {
          unsigned int v278 = &v712[4 * v20];
          if ((unint64_t)v278 >= v27) {
            uint64_t v279 = v264;
          }
          else {
            uint64_t v279 = 0;
          }
          v11 += 4 * v21 + 4 * v279;
          if ((unint64_t)v278 >= v27) {
            uint64_t v280 = v263;
          }
          else {
            uint64_t v280 = 0;
          }
          int v24 = &v278[4 * v280];
          v12 += 4 * v280 + 4 * v20;
          unsigned int v267 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v267 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 14:
      uint64_t v281 = v26;
      uint64_t v282 = v23;
      uint64_t v283 = -(v20 * v23);
      uint64_t v284 = -(uint64_t)(v21 * v282);
      uint64_t v285 = 4 * v26;
      uint64_t v286 = -(uint64_t)v22;
      float v287 = (float *)v11;
      while (1)
      {
        int v288 = v10;
        do
        {
          if (*v16)
          {
            float v289 = v713 ? *v287 : 1.0;
            float v290 = (float)*v16 * 0.0039216;
            float v291 = v290 * v289;
            if (v291 > 0.0)
            {
              float v292 = v290 * *(float *)v24;
              if (v714)
              {
                float v293 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_371;
                }
              }
              else
              {
                float v293 = 1.0;
              }
              float v292 = *v14 + (float)(v292 * (float)(1.0 - *v14));
              if (v714)
              {
                float v291 = (float)(v291 + v293) - (float)(v293 * v291);
LABEL_371:
                *unint64_t v14 = v292;
                *float v7 = v291;
                goto LABEL_373;
              }
              *unint64_t v14 = v292;
            }
          }
LABEL_373:
          v16 += v281;
          float v294 = &v24[4 * v281];
          float v295 = &v287[v713];
          if ((unint64_t)v294 >= v12) {
            uint64_t v296 = v286;
          }
          else {
            uint64_t v296 = 0;
          }
          float v287 = &v295[v296];
          int v24 = &v294[4 * v296];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v285);
          --v288;
        }
        while (v288);
        if (v27)
        {
          float v297 = &v712[4 * v20];
          if ((unint64_t)v297 >= v27) {
            uint64_t v298 = v284;
          }
          else {
            uint64_t v298 = 0;
          }
          v11 += 4 * v21 + 4 * v298;
          if ((unint64_t)v297 >= v27) {
            uint64_t v299 = v283;
          }
          else {
            uint64_t v299 = 0;
          }
          int v24 = &v297[4 * v299];
          v12 += 4 * v299 + 4 * v20;
          float v287 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v287 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 15:
      uint64_t v300 = v26;
      uint64_t v676 = -(uint64_t)(v21 * v23);
      uint64_t v681 = -(v20 * v23);
      uint64_t v301 = 4 * v26;
      uint64_t v302 = -(uint64_t)v22;
      unint64_t v303 = (float *)v11;
      uint64_t v691 = v302;
      uint64_t v696 = v26;
      while (1)
      {
        uint64_t v701 = v11;
        int v706 = v9;
        int v304 = v10;
        int v305 = v713;
        do
        {
          if (*v16)
          {
            float v306 = v305 ? *v303 : 1.0;
            float v307 = (float)*v16 * 0.0039216;
            float v308 = v307 * v306;
            if ((float)(v307 * v306) > 0.0)
            {
              float v309 = v307 * *(float *)v24;
              if (v714)
              {
                float v310 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_401;
                }
              }
              else
              {
                float v310 = 1.0;
              }
              float v311 = PDAoverlayPDA(*v14, v310, v309, v308);
              float v309 = v311;
              if (v714)
              {
                float v308 = v312;
                int v305 = v713;
                uint64_t v302 = v691;
                uint64_t v300 = v696;
LABEL_401:
                *unint64_t v14 = v309;
                *float v7 = v308;
                goto LABEL_403;
              }
              *unint64_t v14 = v311;
              int v305 = v713;
              uint64_t v302 = v691;
              uint64_t v300 = v696;
            }
          }
LABEL_403:
          v16 += v300;
          float v313 = &v24[4 * v300];
          if ((unint64_t)v313 >= v12) {
            uint64_t v314 = v302;
          }
          else {
            uint64_t v314 = 0;
          }
          v303 += v713 + v314;
          int v24 = &v313[4 * v314];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v301);
          --v304;
        }
        while (v304);
        if (v690)
        {
          int v10 = v689;
          float v315 = &v712[4 * v688];
          int v316 = v706;
          uint64_t v317 = v676;
          if ((unint64_t)v315 < v690) {
            uint64_t v317 = 0;
          }
          uint64_t v11 = v701 + 4 * v21 + 4 * v317;
          uint64_t v318 = v681;
          if ((unint64_t)v315 < v690) {
            uint64_t v318 = 0;
          }
          int v24 = &v315[4 * v318];
          v12 += 4 * v318 + 4 * v688;
          unint64_t v303 = (float *)(v701 + 4 * v21 + 4 * v317);
          v712 = v24;
          unint64_t v320 = v686;
          uint64_t v319 = v687;
        }
        else
        {
          int v10 = v689;
          v24 += 4 * v688;
          unint64_t v320 = v686;
          v303 += v21;
          uint64_t v11 = v701;
          int v316 = v706;
          uint64_t v319 = v687;
        }
        v16 += v319;
        v14 += v320;
        v7 += v711;
        int v9 = v316 - 1;
        if (!v9) {
          return;
        }
      }
    case 16:
      uint64_t v321 = v26;
      uint64_t v322 = v23;
      uint64_t v323 = -(v20 * v23);
      uint64_t v324 = -(uint64_t)(v21 * v322);
      uint64_t v325 = 4 * v26;
      uint64_t v326 = -(uint64_t)v22;
      unint64_t v327 = (float *)v11;
      while (1)
      {
        int v328 = v10;
        do
        {
          if (*v16)
          {
            float v329 = v713 ? *v327 : 1.0;
            float v330 = (float)*v16 * 0.0039216;
            float v331 = v330 * v329;
            if (v331 > 0.0)
            {
              float v332 = v330 * *(float *)v24;
              if (v714)
              {
                float v333 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_435;
                }
              }
              else
              {
                float v333 = 1.0;
              }
              float v334 = v331 * *v14;
              if ((float)(v332 * v333) < v334) {
                float v334 = v332 * v333;
              }
              float v335 = v334 + (float)(*v14 * (float)(1.0 - v331));
              if (v331 == 1.0) {
                float v335 = v334;
              }
              float v332 = v335 + (float)(v332 * (float)(1.0 - v333));
              if (v333 == 1.0) {
                float v332 = v335;
              }
              if (v714)
              {
                float v331 = (float)(v331 + v333) - (float)(v333 * v331);
LABEL_435:
                *unint64_t v14 = v332;
                *float v7 = v331;
                goto LABEL_437;
              }
              *unint64_t v14 = v332;
            }
          }
LABEL_437:
          v16 += v321;
          int v336 = &v24[4 * v321];
          uint64_t v337 = &v327[v713];
          if ((unint64_t)v336 >= v12) {
            uint64_t v338 = v326;
          }
          else {
            uint64_t v338 = 0;
          }
          unint64_t v327 = &v337[v338];
          int v24 = &v336[4 * v338];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v325);
          --v328;
        }
        while (v328);
        if (v27)
        {
          float32x4_t v339 = &v712[4 * v20];
          if ((unint64_t)v339 >= v27) {
            uint64_t v340 = v324;
          }
          else {
            uint64_t v340 = 0;
          }
          v11 += 4 * v21 + 4 * v340;
          if ((unint64_t)v339 >= v27) {
            uint64_t v341 = v323;
          }
          else {
            uint64_t v341 = 0;
          }
          int v24 = &v339[4 * v341];
          v12 += 4 * v341 + 4 * v20;
          unint64_t v327 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v327 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 17:
      uint64_t v342 = v26;
      uint64_t v343 = v23;
      uint64_t v344 = -(v20 * v23);
      uint64_t v345 = -(uint64_t)(v21 * v343);
      uint64_t v346 = 4 * v26;
      uint64_t v347 = -(uint64_t)v22;
      int v348 = (float *)v11;
      while (1)
      {
        int v349 = v10;
        do
        {
          if (*v16)
          {
            float v350 = v713 ? *v348 : 1.0;
            float v351 = (float)*v16 * 0.0039216;
            float v352 = v351 * v350;
            if (v352 > 0.0)
            {
              float v353 = v351 * *(float *)v24;
              if (v714)
              {
                float v354 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_471;
                }
              }
              else
              {
                float v354 = 1.0;
              }
              float v355 = v352 * *v14;
              if ((float)(v353 * v354) > v355) {
                float v355 = v353 * v354;
              }
              float v356 = v355 + (float)(*v14 * (float)(1.0 - v352));
              if (v352 == 1.0) {
                float v356 = v355;
              }
              float v353 = v356 + (float)(v353 * (float)(1.0 - v354));
              if (v354 == 1.0) {
                float v353 = v356;
              }
              if (v714)
              {
                float v352 = (float)(v352 + v354) - (float)(v354 * v352);
LABEL_471:
                *unint64_t v14 = v353;
                *float v7 = v352;
                goto LABEL_473;
              }
              *unint64_t v14 = v353;
            }
          }
LABEL_473:
          v16 += v342;
          uint64_t v357 = &v24[4 * v342];
          v358 = &v348[v713];
          if ((unint64_t)v357 >= v12) {
            uint64_t v359 = v347;
          }
          else {
            uint64_t v359 = 0;
          }
          int v348 = &v358[v359];
          int v24 = &v357[4 * v359];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v346);
          --v349;
        }
        while (v349);
        if (v27)
        {
          uint64_t v360 = &v712[4 * v20];
          if ((unint64_t)v360 >= v27) {
            uint64_t v361 = v345;
          }
          else {
            uint64_t v361 = 0;
          }
          v11 += 4 * v21 + 4 * v361;
          if ((unint64_t)v360 >= v27) {
            uint64_t v362 = v344;
          }
          else {
            uint64_t v362 = 0;
          }
          int v24 = &v360[4 * v362];
          v12 += 4 * v362 + 4 * v20;
          int v348 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v348 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 18:
      uint64_t v363 = v26;
      uint64_t v677 = -(uint64_t)(v21 * v23);
      uint64_t v682 = -(v20 * v23);
      uint64_t v364 = 4 * v26;
      uint64_t v365 = -(uint64_t)v22;
      float v366 = (float *)v11;
      uint64_t v692 = v365;
      uint64_t v697 = v26;
      while (1)
      {
        uint64_t v702 = v11;
        int v707 = v9;
        int v367 = v10;
        int v368 = v713;
        do
        {
          if (*v16)
          {
            float v369 = v368 ? *v366 : 1.0;
            float v370 = (float)*v16 * 0.0039216;
            float v371 = v370 * v369;
            if ((float)(v370 * v369) > 0.0)
            {
              float v372 = v370 * *(float *)v24;
              if (v714)
              {
                float v373 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_501;
                }
              }
              else
              {
                float v373 = 1.0;
              }
              float v374 = PDAcolordodgePDA(*v14, v373, v372, v371);
              float v372 = v374;
              if (v714)
              {
                float v371 = v375;
                int v368 = v713;
                uint64_t v365 = v692;
                uint64_t v363 = v697;
LABEL_501:
                *unint64_t v14 = v372;
                *float v7 = v371;
                goto LABEL_503;
              }
              *unint64_t v14 = v374;
              int v368 = v713;
              uint64_t v365 = v692;
              uint64_t v363 = v697;
            }
          }
LABEL_503:
          v16 += v363;
          float v376 = &v24[4 * v363];
          if ((unint64_t)v376 >= v12) {
            uint64_t v377 = v365;
          }
          else {
            uint64_t v377 = 0;
          }
          v366 += v713 + v377;
          int v24 = &v376[4 * v377];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v364);
          --v367;
        }
        while (v367);
        if (v690)
        {
          int v10 = v689;
          float v378 = &v712[4 * v688];
          int v379 = v707;
          uint64_t v380 = v677;
          if ((unint64_t)v378 < v690) {
            uint64_t v380 = 0;
          }
          uint64_t v11 = v702 + 4 * v21 + 4 * v380;
          uint64_t v381 = v682;
          if ((unint64_t)v378 < v690) {
            uint64_t v381 = 0;
          }
          int v24 = &v378[4 * v381];
          v12 += 4 * v381 + 4 * v688;
          float v366 = (float *)(v702 + 4 * v21 + 4 * v380);
          v712 = v24;
          unint64_t v383 = v686;
          uint64_t v382 = v687;
        }
        else
        {
          int v10 = v689;
          v24 += 4 * v688;
          unint64_t v383 = v686;
          v366 += v21;
          uint64_t v11 = v702;
          int v379 = v707;
          uint64_t v382 = v687;
        }
        v16 += v382;
        v14 += v383;
        v7 += v711;
        int v9 = v379 - 1;
        if (!v9) {
          return;
        }
      }
    case 19:
      uint64_t v384 = v26;
      uint64_t v678 = -(uint64_t)(v21 * v23);
      uint64_t v683 = -(v20 * v23);
      uint64_t v385 = 4 * v26;
      uint64_t v386 = -(uint64_t)v22;
      int v387 = (float *)v11;
      uint64_t v693 = v386;
      uint64_t v698 = v26;
      while (1)
      {
        uint64_t v703 = v11;
        int v708 = v9;
        int v388 = v10;
        int v389 = v713;
        do
        {
          if (*v16)
          {
            float v390 = v389 ? *v387 : 1.0;
            float v391 = (float)*v16 * 0.0039216;
            float v392 = v391 * v390;
            if ((float)(v391 * v390) > 0.0)
            {
              float v393 = v391 * *(float *)v24;
              if (v714)
              {
                float v394 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_529;
                }
              }
              else
              {
                float v394 = 1.0;
              }
              double v395 = PDAcolorburnPDA(*v14, v394, v393, v392);
              float v393 = *(float *)&v395;
              if (v714)
              {
                float v392 = v396;
                int v389 = v713;
                uint64_t v386 = v693;
                uint64_t v384 = v698;
LABEL_529:
                *unint64_t v14 = v393;
                *float v7 = v392;
                goto LABEL_531;
              }
              *unint64_t v14 = *(float *)&v395;
              int v389 = v713;
              uint64_t v386 = v693;
              uint64_t v384 = v698;
            }
          }
LABEL_531:
          v16 += v384;
          int v397 = &v24[4 * v384];
          if ((unint64_t)v397 >= v12) {
            uint64_t v398 = v386;
          }
          else {
            uint64_t v398 = 0;
          }
          v387 += v713 + v398;
          int v24 = &v397[4 * v398];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v385);
          --v388;
        }
        while (v388);
        if (v690)
        {
          int v10 = v689;
          float v399 = &v712[4 * v688];
          int v400 = v708;
          uint64_t v401 = v678;
          if ((unint64_t)v399 < v690) {
            uint64_t v401 = 0;
          }
          uint64_t v11 = v703 + 4 * v21 + 4 * v401;
          uint64_t v402 = v683;
          if ((unint64_t)v399 < v690) {
            uint64_t v402 = 0;
          }
          int v24 = &v399[4 * v402];
          v12 += 4 * v402 + 4 * v688;
          int v387 = (float *)(v703 + 4 * v21 + 4 * v401);
          v712 = v24;
          unint64_t v404 = v686;
          uint64_t v403 = v687;
        }
        else
        {
          int v10 = v689;
          v24 += 4 * v688;
          unint64_t v404 = v686;
          v387 += v21;
          uint64_t v11 = v703;
          int v400 = v708;
          uint64_t v403 = v687;
        }
        v16 += v403;
        v14 += v404;
        v7 += v711;
        int v9 = v400 - 1;
        if (!v9) {
          return;
        }
      }
    case 20:
      uint64_t v405 = v26;
      uint64_t v679 = -(uint64_t)(v21 * v23);
      uint64_t v684 = -(v20 * v23);
      uint64_t v406 = 4 * v26;
      uint64_t v407 = -(uint64_t)v22;
      int v408 = (float *)v11;
      uint64_t v694 = v407;
      uint64_t v699 = v26;
      while (1)
      {
        uint64_t v704 = v11;
        int v709 = v9;
        int v409 = v10;
        int v410 = v713;
        do
        {
          if (*v16)
          {
            float v411 = v410 ? *v408 : 1.0;
            float v412 = (float)*v16 * 0.0039216;
            float v413 = v412 * v411;
            if ((float)(v412 * v411) > 0.0)
            {
              float v414 = v412 * *(float *)v24;
              if (v714)
              {
                float v415 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_557;
                }
              }
              else
              {
                float v415 = 1.0;
              }
              float v416 = PDAsoftlightPDA(*v14, v415, v414, v413);
              float v414 = v416;
              if (v714)
              {
                float v413 = v417;
                int v410 = v713;
                uint64_t v407 = v694;
                uint64_t v405 = v699;
LABEL_557:
                *unint64_t v14 = v414;
                *float v7 = v413;
                goto LABEL_559;
              }
              *unint64_t v14 = v416;
              int v410 = v713;
              uint64_t v407 = v694;
              uint64_t v405 = v699;
            }
          }
LABEL_559:
          v16 += v405;
          int v418 = &v24[4 * v405];
          if ((unint64_t)v418 >= v12) {
            uint64_t v419 = v407;
          }
          else {
            uint64_t v419 = 0;
          }
          v408 += v713 + v419;
          int v24 = &v418[4 * v419];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v406);
          --v409;
        }
        while (v409);
        if (v690)
        {
          int v10 = v689;
          float v420 = &v712[4 * v688];
          int v421 = v709;
          uint64_t v422 = v679;
          if ((unint64_t)v420 < v690) {
            uint64_t v422 = 0;
          }
          uint64_t v11 = v704 + 4 * v21 + 4 * v422;
          uint64_t v423 = v684;
          if ((unint64_t)v420 < v690) {
            uint64_t v423 = 0;
          }
          int v24 = &v420[4 * v423];
          v12 += 4 * v423 + 4 * v688;
          int v408 = (float *)(v704 + 4 * v21 + 4 * v422);
          v712 = v24;
          unint64_t v425 = v686;
          uint64_t v424 = v687;
        }
        else
        {
          int v10 = v689;
          v24 += 4 * v688;
          unint64_t v425 = v686;
          v408 += v21;
          uint64_t v11 = v704;
          int v421 = v709;
          uint64_t v424 = v687;
        }
        v16 += v424;
        v14 += v425;
        v7 += v711;
        int v9 = v421 - 1;
        if (!v9) {
          return;
        }
      }
    case 21:
      uint64_t v426 = v26;
      uint64_t v680 = -(uint64_t)(v21 * v23);
      uint64_t v685 = -(v20 * v23);
      uint64_t v427 = 4 * v26;
      uint64_t v428 = -(uint64_t)v22;
      v429 = (float *)v11;
      uint64_t v695 = v428;
      uint64_t v700 = v26;
      do
      {
        uint64_t v705 = v11;
        int v710 = v9;
        int v430 = v10;
        int v431 = v713;
        do
        {
          if (*v16)
          {
            float v432 = v431 ? *v429 : 1.0;
            float v433 = (float)*v16 * 0.0039216;
            float v434 = v433 * v432;
            if ((float)(v433 * v432) > 0.0)
            {
              float v435 = v433 * *(float *)v24;
              if (v714)
              {
                float v436 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_585;
                }
              }
              else
              {
                float v436 = 1.0;
              }
              float v437 = PDAhardlightPDA(*v14, v436, v435, v434);
              float v435 = v437;
              if (v714)
              {
                float v434 = v438;
                int v431 = v713;
                uint64_t v428 = v695;
                uint64_t v426 = v700;
LABEL_585:
                *unint64_t v14 = v435;
                *float v7 = v434;
                goto LABEL_587;
              }
              *unint64_t v14 = v437;
              int v431 = v713;
              uint64_t v428 = v695;
              uint64_t v426 = v700;
            }
          }
LABEL_587:
          v16 += v426;
          uint64_t v439 = &v24[4 * v426];
          if ((unint64_t)v439 >= v12) {
            uint64_t v440 = v428;
          }
          else {
            uint64_t v440 = 0;
          }
          v429 += v713 + v440;
          int v24 = &v439[4 * v440];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v427);
          --v430;
        }
        while (v430);
        if (v690)
        {
          int v10 = v689;
          uint8x8_t v441 = &v712[4 * v688];
          int v442 = v710;
          uint64_t v443 = v680;
          if ((unint64_t)v441 < v690) {
            uint64_t v443 = 0;
          }
          uint64_t v11 = v705 + 4 * v21 + 4 * v443;
          uint64_t v444 = v685;
          if ((unint64_t)v441 < v690) {
            uint64_t v444 = 0;
          }
          int v24 = &v441[4 * v444];
          v12 += 4 * v444 + 4 * v688;
          v429 = (float *)(v705 + 4 * v21 + 4 * v443);
          v712 = v24;
          unint64_t v446 = v686;
          uint64_t v445 = v687;
        }
        else
        {
          int v10 = v689;
          v24 += 4 * v688;
          unint64_t v446 = v686;
          v429 += v21;
          uint64_t v11 = v705;
          int v442 = v710;
          uint64_t v445 = v687;
        }
        v16 += v445;
        v14 += v446;
        v7 += v711;
        int v9 = v442 - 1;
      }
      while (v9);
      return;
    case 22:
      uint64_t v447 = v26;
      uint64_t v448 = v23;
      uint64_t v449 = -(v20 * v23);
      uint64_t v450 = -(uint64_t)(v21 * v448);
      uint64_t v451 = 4 * v26;
      uint64_t v452 = -(uint64_t)v22;
      uint64_t v453 = (float *)v11;
      while (1)
      {
        int v454 = v10;
        do
        {
          if (*v16)
          {
            float v455 = v713 ? *v453 : 1.0;
            float v456 = (float)*v16 * 0.0039216;
            float v457 = v456 * v455;
            if (v457 > 0.0)
            {
              float v458 = v456 * *(float *)v24;
              if (v714)
              {
                float v459 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_615;
                }
              }
              else
              {
                float v459 = 1.0;
              }
              float v460 = v458 + *v14;
              float v461 = v457 * *v14;
              float v462 = v458 * v459;
              float v463 = v460 - v461;
              float v464 = v461 - v462;
              float v465 = v463 - v462;
              if (v464 < 0.0) {
                float v464 = -v464;
              }
              float v458 = v465 + v464;
              if (v714)
              {
                float v457 = (float)(v457 + v459) - (float)(v459 * v457);
LABEL_615:
                *unint64_t v14 = v458;
                *float v7 = v457;
                goto LABEL_617;
              }
              *unint64_t v14 = v458;
            }
          }
LABEL_617:
          v16 += v447;
          uint64_t v466 = &v24[4 * v447];
          uint64_t v467 = &v453[v713];
          if ((unint64_t)v466 >= v12) {
            uint64_t v468 = v452;
          }
          else {
            uint64_t v468 = 0;
          }
          uint64_t v453 = &v467[v468];
          int v24 = &v466[4 * v468];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v451);
          --v454;
        }
        while (v454);
        if (v27)
        {
          int v469 = &v712[4 * v20];
          if ((unint64_t)v469 >= v27) {
            uint64_t v470 = v450;
          }
          else {
            uint64_t v470 = 0;
          }
          v11 += 4 * v21 + 4 * v470;
          if ((unint64_t)v469 >= v27) {
            uint64_t v471 = v449;
          }
          else {
            uint64_t v471 = 0;
          }
          int v24 = &v469[4 * v471];
          v12 += 4 * v471 + 4 * v20;
          uint64_t v453 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v453 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 23:
      uint64_t v472 = v26;
      uint64_t v473 = v23;
      uint64_t v474 = -(v20 * v23);
      uint64_t v475 = -(uint64_t)(v21 * v473);
      uint64_t v476 = 4 * v26;
      uint64_t v477 = -(uint64_t)v22;
      unint64_t v478 = (float *)v11;
      while (1)
      {
        int v479 = v10;
        do
        {
          if (*v16)
          {
            float v480 = v713 ? *v478 : 1.0;
            float v481 = (float)*v16 * 0.0039216;
            float v482 = v481 * v480;
            if (v482 > 0.0)
            {
              float v483 = v481 * *(float *)v24;
              if (v714)
              {
                float v484 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_645;
                }
              }
              else
              {
                float v484 = 1.0;
              }
              float v483 = (float)(v483 + *v14) + (float)((float)(v483 * *v14) * -2.0);
              if (v714)
              {
                float v482 = (float)(v482 + v484) - (float)(v484 * v482);
LABEL_645:
                *unint64_t v14 = v483;
                *float v7 = v482;
                goto LABEL_647;
              }
              *unint64_t v14 = v483;
            }
          }
LABEL_647:
          v16 += v472;
          int v485 = &v24[4 * v472];
          int v486 = &v478[v713];
          if ((unint64_t)v485 >= v12) {
            uint64_t v487 = v477;
          }
          else {
            uint64_t v487 = 0;
          }
          unint64_t v478 = &v486[v487];
          int v24 = &v485[4 * v487];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v476);
          --v479;
        }
        while (v479);
        if (v27)
        {
          v488 = &v712[4 * v20];
          if ((unint64_t)v488 >= v27) {
            uint64_t v489 = v475;
          }
          else {
            uint64_t v489 = 0;
          }
          v11 += 4 * v21 + 4 * v489;
          if ((unint64_t)v488 >= v27) {
            uint64_t v490 = v474;
          }
          else {
            uint64_t v490 = 0;
          }
          int v24 = &v488[4 * v490];
          v12 += 4 * v490 + 4 * v20;
          unint64_t v478 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v478 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 24:
      uint64_t v491 = v26;
      uint64_t v492 = v23;
      uint64_t v493 = -(v20 * v23);
      uint64_t v494 = -(uint64_t)(v21 * v492);
      uint64_t v495 = 4 * v26;
      uint64_t v496 = -(uint64_t)v22;
      unint64_t v497 = (float *)v11;
      while (1)
      {
        int v498 = v10;
        do
        {
          if (*v16)
          {
            float v499 = v713 ? *v497 : 1.0;
            float v500 = (float)*v16 * 0.0039216;
            float v501 = v500 * v499;
            if (v501 > 0.0)
            {
              float v502 = v500 * *(float *)v24;
              if (v714)
              {
                float v503 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_680;
                }
              }
              else
              {
                float v503 = 1.0;
              }
              float v504 = *v14;
              if (v501 == 1.0)
              {
                float v505 = 0.0;
              }
              else
              {
                float v504 = v501 * *v14;
                float v505 = *v14 - v504;
              }
              float v506 = (float)(v502 + v505) - (float)(v502 * v503);
              if (v503 == 1.0) {
                float v506 = v505;
              }
              float v502 = v504 + v506;
              if (v714)
              {
                float v501 = (float)(v501 + v503) - (float)(v501 * v503);
LABEL_680:
                *unint64_t v14 = v502;
                *float v7 = v501;
                goto LABEL_682;
              }
              *unint64_t v14 = v502;
            }
          }
LABEL_682:
          v16 += v491;
          signed int v507 = &v24[4 * v491];
          v508 = &v497[v713];
          if ((unint64_t)v507 >= v12) {
            uint64_t v509 = v496;
          }
          else {
            uint64_t v509 = 0;
          }
          unint64_t v497 = &v508[v509];
          int v24 = &v507[4 * v509];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v495);
          --v498;
        }
        while (v498);
        if (v27)
        {
          unsigned int v510 = &v712[4 * v20];
          if ((unint64_t)v510 >= v27) {
            uint64_t v511 = v494;
          }
          else {
            uint64_t v511 = 0;
          }
          v11 += 4 * v21 + 4 * v511;
          if ((unint64_t)v510 >= v27) {
            uint64_t v512 = v493;
          }
          else {
            uint64_t v512 = 0;
          }
          int v24 = &v510[4 * v512];
          v12 += 4 * v512 + 4 * v20;
          unint64_t v497 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v497 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 25:
      uint64_t v513 = v26;
      uint64_t v514 = v23;
      uint64_t v515 = -(v20 * v23);
      uint64_t v516 = -(uint64_t)(v21 * v514);
      uint64_t v517 = 4 * v26;
      uint64_t v518 = -(uint64_t)v22;
      int v519 = (float *)v11;
      while (1)
      {
        int v520 = v10;
        do
        {
          if (*v16)
          {
            float v521 = v713 ? *v519 : 1.0;
            float v522 = (float)*v16 * 0.0039216;
            float v523 = v522 * v521;
            if (v523 > 0.0)
            {
              float v524 = v522 * *(float *)v24;
              if (v714)
              {
                float v525 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_715;
                }
              }
              else
              {
                float v525 = 1.0;
              }
              float v526 = *v14;
              if (v523 == 1.0)
              {
                float v527 = 0.0;
              }
              else
              {
                float v526 = v523 * *v14;
                float v527 = *v14 - v526;
              }
              float v528 = (float)(v524 + v527) - (float)(v524 * v525);
              if (v525 == 1.0) {
                float v528 = v527;
              }
              float v524 = v526 + v528;
              if (v714)
              {
                float v523 = (float)(v523 + v525) - (float)(v523 * v525);
LABEL_715:
                *unint64_t v14 = v524;
                *float v7 = v523;
                goto LABEL_717;
              }
              *unint64_t v14 = v524;
            }
          }
LABEL_717:
          v16 += v513;
          float v529 = &v24[4 * v513];
          int v530 = &v519[v713];
          if ((unint64_t)v529 >= v12) {
            uint64_t v531 = v518;
          }
          else {
            uint64_t v531 = 0;
          }
          int v519 = &v530[v531];
          int v24 = &v529[4 * v531];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v517);
          --v520;
        }
        while (v520);
        if (v27)
        {
          int v532 = &v712[4 * v20];
          if ((unint64_t)v532 >= v27) {
            uint64_t v533 = v516;
          }
          else {
            uint64_t v533 = 0;
          }
          v11 += 4 * v21 + 4 * v533;
          if ((unint64_t)v532 >= v27) {
            uint64_t v534 = v515;
          }
          else {
            uint64_t v534 = 0;
          }
          int v24 = &v532[4 * v534];
          v12 += 4 * v534 + 4 * v20;
          int v519 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v519 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 26:
      uint64_t v535 = v26;
      uint64_t v536 = v23;
      uint64_t v537 = -(v20 * v23);
      uint64_t v538 = -(uint64_t)(v21 * v536);
      uint64_t v539 = 4 * v26;
      uint64_t v540 = -(uint64_t)v22;
      float v541 = (float *)v11;
      while (1)
      {
        int v542 = v10;
        do
        {
          if (*v16)
          {
            float v543 = v713 ? *v541 : 1.0;
            float v544 = (float)*v16 * 0.0039216;
            float v545 = v544 * v543;
            if (v545 > 0.0)
            {
              float v546 = v544 * *(float *)v24;
              if (v714)
              {
                float v547 = *v7;
                if (*v7 <= 0.0) {
                  goto LABEL_749;
                }
              }
              else
              {
                float v547 = 1.0;
              }
              float v548 = *v14;
              float v549 = v546 - (float)(v546 * v547);
              if (v547 == 1.0) {
                float v549 = 0.0;
              }
              float v550 = (float)(v548 + v549) - (float)(v545 * v548);
              if (v545 != 1.0)
              {
                float v548 = v545 * v548;
                float v549 = v550;
              }
              float v546 = v548 + v549;
              if (v714)
              {
                float v545 = (float)(v545 + v547) - (float)(v545 * v547);
LABEL_749:
                *unint64_t v14 = v546;
                *float v7 = v545;
                goto LABEL_751;
              }
              *unint64_t v14 = v546;
            }
          }
LABEL_751:
          v16 += v535;
          float v551 = &v24[4 * v535];
          int v552 = &v541[v713];
          if ((unint64_t)v551 >= v12) {
            uint64_t v553 = v540;
          }
          else {
            uint64_t v553 = 0;
          }
          float v541 = &v552[v553];
          int v24 = &v551[4 * v553];
          v7 += v714;
          unint64_t v14 = (float *)((char *)v14 + v539);
          --v542;
        }
        while (v542);
        if (v27)
        {
          uint64_t v554 = &v712[4 * v20];
          if ((unint64_t)v554 >= v27) {
            uint64_t v555 = v538;
          }
          else {
            uint64_t v555 = 0;
          }
          v11 += 4 * v21 + 4 * v555;
          if ((unint64_t)v554 >= v27) {
            uint64_t v556 = v537;
          }
          else {
            uint64_t v556 = 0;
          }
          int v24 = &v554[4 * v556];
          v12 += 4 * v556 + 4 * v20;
          float v541 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v541 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9) {
          return;
        }
      }
    case 27:
      uint64_t v557 = v26;
      uint64_t v558 = v23;
      uint64_t v559 = -(v20 * v23);
      uint64_t v560 = -(uint64_t)(v21 * v558);
      uint64_t v561 = 4 * v26;
      uint64_t v562 = -(uint64_t)v22;
      int v563 = (float *)v11;
      break;
    default:
      return;
  }
LABEL_767:
  int v564 = v10;
  while (1)
  {
    if (!*v16) {
      goto LABEL_785;
    }
    float v565 = v713 ? *v563 : 1.0;
    float v566 = (float)*v16 * 0.0039216;
    float v567 = v566 * v565;
    if (v567 <= 0.0) {
      goto LABEL_785;
    }
    float v568 = v566 * *(float *)v24;
    if (v714)
    {
      float v569 = *v7;
      if (*v7 <= 0.0) {
        goto LABEL_783;
      }
    }
    else
    {
      float v569 = 1.0;
    }
    float v570 = *v14 - (float)(v567 * *v14);
    if (v567 == 1.0) {
      float v570 = 0.0;
    }
    float v571 = (float)(v568 + v570) - (float)(v568 * v569);
    if (v569 != 1.0)
    {
      float v568 = v568 * v569;
      float v570 = v571;
    }
    float v568 = v568 + v570;
    if (!v714)
    {
      *unint64_t v14 = v568;
      goto LABEL_785;
    }
    float v567 = (float)(v567 + v569) - (float)(v567 * v569);
LABEL_783:
    *unint64_t v14 = v568;
    *float v7 = v567;
LABEL_785:
    v16 += v557;
    int v572 = &v24[4 * v557];
    int v573 = &v563[v713];
    if ((unint64_t)v572 >= v12) {
      uint64_t v574 = v562;
    }
    else {
      uint64_t v574 = 0;
    }
    int v563 = &v573[v574];
    int v24 = &v572[4 * v574];
    v7 += v714;
    unint64_t v14 = (float *)((char *)v14 + v561);
    if (!--v564)
    {
      if (v27)
      {
        float v575 = &v712[4 * v20];
        if ((unint64_t)v575 >= v27) {
          uint64_t v576 = v560;
        }
        else {
          uint64_t v576 = 0;
        }
        v11 += 4 * v21 + 4 * v576;
        if ((unint64_t)v575 >= v27) {
          uint64_t v577 = v559;
        }
        else {
          uint64_t v577 = 0;
        }
        int v24 = &v575[4 * v577];
        v12 += 4 * v577 + 4 * v20;
        int v563 = (float *)v11;
        v712 = v24;
      }
      else
      {
        v24 += 4 * v20;
        v563 += v21;
      }
      v16 += v32;
      v14 += v33;
      v7 += v711;
      if (!--v9) {
        return;
      }
      goto LABEL_767;
    }
  }
}

uint64_t Wf_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (int *)*a1;
  memset(v37, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v31, (uint64_t)v37) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  unsigned int v19 = *(_DWORD *)a3;
  unsigned int v32 = v19;
  int v33 = v18;
  if (v19 != 136319269)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        int v22 = 255;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
        int v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v21 = 0;
            int v22 = 16;
            break;
          case 5u:
            char v21 = 0;
            int v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v21 = 0;
            int v22 = 32;
            break;
          case 8u:
            char v21 = 0;
            int v22 = 8;
            break;
          case 9u:
            char v21 = 0;
            int v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      int v23 = WF_image_sample;
      uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&WF_image_sample[2 * v20 + 2];
      if (v31)
      {
LABEL_28:
        unsigned int v32 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v35 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = Wf_image_mark_RGB32;
              goto LABEL_50;
            case 1u:
              unsigned int v32 = *(_DWORD *)a3;
              int v26 = Wf_image_mark_RGB32;
              goto LABEL_52;
            case 2u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = Wf_image_mark_W8;
              goto LABEL_50;
            case 3u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = Wf_image_mark_RGB24;
              goto LABEL_50;
            case 4u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = Wf_image_mark_rgb32;
LABEL_50:
              unint64_t v27 = v25;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 0;
              break;
            case 5u:
              unsigned int v32 = *(_DWORD *)a3;
              int v26 = Wf_image_mark_rgb32;
LABEL_52:
              unint64_t v27 = v26;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 8;
              break;
            default:
              goto LABEL_36;
          }
          Wf_image_mark_image(v28, (uint64_t)&v31, v29, v30, (void (*)(uint64_t, _DWORD *))v27);
          return 1;
        }
        goto LABEL_36;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        int v23 = W8_image_sample;
        uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W8_image_sample[2 * v20 + 2];
        if (v31)
        {
LABEL_27:
          int v34 = 4;
          goto LABEL_28;
        }
      }
      int v23 = W16_image_sample;
      uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W16_image_sample[2 * v20 + 2];
      if (v31) {
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v36 && (~v35 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v35 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      Wf_mark_inner(*(void *)(*a1 + 56), v17);
      return 1;
    }
  }
  uint64_t v31 = Wf_sample_Wf_inner;
LABEL_36:
  Wf_image_mark((uint64_t)a2, (uint64_t)&v31, v8, v17);
  return 1;
}

void Wf_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  v56[0] = a3;
  v56[1] = a4;
  v56[2] = *(_DWORD *)(a2 + 184);
  unint64_t v8 = (unint64_t)*(int *)(a1 + 28) >> 2;
  unint64_t v58 = v8;
  if (*(void *)(a1 + 48)) {
    unint64_t v9 = (unint64_t)*(int *)(a1 + 32) >> 2;
  }
  else {
    unint64_t v9 = 0;
  }
  unint64_t v60 = v9;
  uint64_t v10 = *(void *)(a2 + 120);
  unsigned int v11 = *(_DWORD *)(a2 + 20);
  if (v10)
  {
    unsigned int v12 = HIBYTE(v11);
    unint64_t v13 = *(int *)(a2 + 24);
    uint64_t v14 = (uint64_t *)(a2 + 104);
    uint64_t v15 = (uint64_t *)(a2 + 72);
    uint64_t v16 = (uint64_t *)(a2 + 88);
  }
  else
  {
    unsigned int v12 = BYTE2(v11);
    unint64_t v13 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    uint64_t v14 = (uint64_t *)(a2 + 96);
    uint64_t v15 = (uint64_t *)(a2 + 64);
    uint64_t v16 = (uint64_t *)(a2 + 80);
    uint64_t v10 = *(void *)(a2 + 112);
  }
  uint64_t v17 = *v16;
  uint64_t v18 = *v15;
  uint64_t v19 = *v14;
  char v20 = v12;
  uint64_t v63 = v12;
  uint64_t v61 = v19;
  unint64_t v71 = v13;
  uint64_t v69 = v17;
  uint64_t v67 = v18;
  uint64_t v65 = v10;
  uint64_t v21 = *(void *)(a2 + 128);
  uint64_t v54 = v18;
  uint64_t v55 = v17;
  if (v21)
  {
    unsigned int v22 = BYTE2(v11);
    unint64_t v23 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    unint64_t v24 = (uint64_t *)(a2 + 96);
    uint64_t v25 = (uint64_t *)(a2 + 64);
    int v26 = (uint64_t *)(a2 + 80);
  }
  else
  {
    unsigned int v22 = HIBYTE(v11);
    unint64_t v23 = *(int *)(a2 + 24);
    unint64_t v24 = (uint64_t *)(a2 + 104);
    uint64_t v25 = (uint64_t *)(a2 + 72);
    int v26 = (uint64_t *)(a2 + 88);
    uint64_t v21 = *(void *)(a2 + 136);
  }
  uint64_t v27 = *v26;
  uint64_t v28 = *v25;
  uint64_t v29 = *v24;
  uint64_t v64 = v22;
  uint64_t v62 = v29;
  unint64_t v72 = v23;
  uint64_t v70 = v27;
  uint64_t v68 = v28;
  uint64_t v66 = v21;
  uint64_t v30 = *(unsigned int *)(a1 + 4);
  if ((v30 & 0x80000000) == 0)
  {
    uint64_t v31 = malloc_type_malloc(16 * v30, 0xABB5E7F1uLL);
    uint64_t v73 = v31;
    if (v31)
    {
      if (*(void *)(a2 + 176))
      {
        if (v30)
        {
          int v33 = v31 + 1;
          uint64_t v34 = v55 - v19;
          do
          {
            if (((v19 - v54) | v34) < 0)
            {
              unint64_t v37 = 0;
              uint64_t v38 = 0;
            }
            else
            {
              unint64_t v35 = ((v19 & (unint64_t)~(-1 << v20)) >> (v20 - 4)) & 0xF;
              char v36 = weights_21383[v35];
              if (v35 - 7 >= 9) {
                unint64_t v37 = -(uint64_t)v13;
              }
              else {
                unint64_t v37 = v13;
              }
              uint64_t v38 = v36 & 0xF;
            }
            *(v33 - 1) = v13 * (v19 >> v20);
            *int v33 = v38 | (16 * v37);
            v33 += 2;
            v19 += v10;
            v34 -= v10;
            --v30;
          }
          while (v30);
        }
      }
      else if (v30)
      {
        uint64_t v39 = v31 + 1;
        do
        {
          *(v39 - 1) = v13 * (v19 >> v20);
          *uint64_t v39 = 0;
          v39 += 2;
          v19 += v10;
          --v30;
        }
        while (v30);
      }
      uint64_t v40 = v31;
      int v41 = *(_DWORD *)(a1 + 4);
      int v42 = *(_DWORD *)(a1 + 8);
      int v74 = v42;
      int v75 = v41;
      int v43 = *(int **)(a1 + 136);
      if (v43)
      {
        int v44 = *(_DWORD *)(a1 + 104);
        v76[0] = *(_DWORD *)(a1 + 108);
        v76[1] = v44;
        shape_enum_clip_alloc((uint64_t)v31, v32, v43, 1, 1, 1, v44, v76[0], v41, v42);
        float v46 = v45;
        if (v45) {
          goto LABEL_32;
        }
      }
      int v47 = 0;
      int v48 = 0;
      float v46 = 0;
      *(void *)uint64_t v76 = 0;
      while (1)
      {
        uint64_t v49 = *(int *)(a1 + 16) + (uint64_t)v48;
        uint64_t v50 = *(void *)(a1 + 48);
        int v51 = v47 + *(_DWORD *)(a1 + 12);
        uint64_t v52 = *(void *)(a1 + 40) + 4 * v8 * v49 + 4 * v51;
        uint64_t v53 = v50 + 4 * v9 * v49 + 4 * v51;
        if (!v50) {
          uint64_t v53 = 0;
        }
        uint64_t v57 = v52;
        uint64_t v59 = v53;
        a5(a2, v56);
        if (!v46) {
          break;
        }
LABEL_32:
        if (!shape_enum_clip_next((uint64_t)v46, &v76[1], v76, &v75, &v74))
        {
          free(v46);
          break;
        }
        int v48 = v76[0];
        int v47 = v76[1];
        unint64_t v8 = v58;
        unint64_t v9 = v60;
      }
      free(v40);
    }
  }
}

void Wf_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v399 = a3;
  uint64_t v411 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  uint64_t v397 = (int)v4;
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  unint64_t v7 = *(int *)(a1 + 28);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  __n128 v405 = a4;
  int v410 = *(int **)(a1 + 136);
  uint64_t v10 = *(void *)(a2 + 104);
  uint64_t v400 = *(void *)(a2 + 96);
  uint64_t v401 = v10;
  uint64_t v12 = *(int *)(a1 + 12);
  uint64_t v11 = *(int *)(a1 + 16);
  int v408 = *(_DWORD *)(a1 + 8);
  uint64_t v398 = (void *)a2;
  uint64_t v13 = *(int *)(a2 + 16);
  uint64_t v14 = (v13 + 10) * v5;
  if (v14 > 65439)
  {
    uint64_t v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x114F985BuLL);
    uint64_t v16 = v17;
    uint64_t v19 = v17;
    char v20 = v398;
    if (!v17) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    uint64_t v16 = (char *)&v393 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    uint64_t v19 = 0;
    char v20 = v398;
  }
  float v394 = v19;
  unint64_t v21 = v7 >> 2;
  unint64_t v22 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v23 = v22 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v13) {
    uint64_t v24 = 8 * v5;
  }
  else {
    uint64_t v24 = 0;
  }
  unint64_t v25 = v23 + v24;
  v20[18] = v22;
  v20[19] = v23 + v24;
  v20[20] = v23;
  if (v9)
  {
    unint64_t v26 = (unint64_t)*(int *)(a1 + 32) >> 2;
    uint64_t v27 = (float *)(v9 + 4 * (v12 + v26 * v11));
    uint64_t v28 = v397;
    uint64_t v406 = v26 - v397;
    uint64_t v29 = 1;
  }
  else
  {
    uint64_t v27 = 0;
    uint64_t v406 = 0;
    uint64_t v29 = 0;
    uint64_t v28 = v397;
  }
  uint64_t v30 = v400;
  uint64_t v31 = v410;
  uint64_t v32 = (float *)(v8 + 4 * (v12 + v21 * v11));
  uint64_t v404 = v21 - v28;
  uint64_t v33 = *(int *)(a1 + 104);
  int v34 = *(_DWORD *)(a1 + 108);
  int v35 = *(unsigned __int8 *)(a1 + 2);
  if (v35 == 6 || v35 == 1)
  {
    int v36 = v399;
    unint64_t v37 = v398;
    uint64_t v38 = v401;
    if (!v410) {
      goto LABEL_598;
    }
    unint64_t v393 = v21;
    uint64_t v39 = 0;
    LODWORD(v410) = 0;
    uint64_t v40 = *(int *)(a1 + 124);
    int v41 = (unsigned __int8 *)v31 + v33 + (int)v40 * (uint64_t)v34;
    uint64_t v28 = v397;
    uint64_t v403 = v40 - v397;
LABEL_21:
    int v42 = v408;
    goto LABEL_22;
  }
  unint64_t v393 = v21;
  if (!v410)
  {
    uint64_t v403 = 0;
    uint64_t v39 = 0;
    int v41 = 0;
    LODWORD(v410) = 0;
    int v36 = v399;
    unint64_t v37 = v398;
    uint64_t v38 = v401;
    goto LABEL_21;
  }
  uint64_t v407 = v29;
  int v42 = v408;
  shape_enum_clip_alloc((uint64_t)v17, v18, v410, 1, 1, 1, v33, v34, v4, v408);
  if (!v43) {
    goto LABEL_598;
  }
  int v409 = v43;
  int v44 = 0;
  uint64_t v45 = (int)((v13 * v5 + 15) & 0xFFFFFFF0);
  if (!v13) {
    uint64_t v45 = 8 * v5;
  }
  uint64_t v46 = v397;
  unint64_t v37 = v398;
  uint64_t v403 = -v397;
  int v41 = (unsigned __int8 *)(v25 + v45 + 16);
  int v36 = v399;
LABEL_586:
  uint64_t v388 = v406 + v46;
  while (1)
  {
    LODWORD(v410) = v44;
    while (1)
    {
      int v389 = *((_DWORD *)v41 - 4);
      int v390 = v389 - v44;
      if (v389 > v44) {
        break;
      }
      uint64_t v39 = v409;
      if (v44 < *((_DWORD *)v41 - 3) + v389)
      {
        uint64_t v28 = v397;
        uint64_t v38 = v401;
        uint64_t v29 = v407;
LABEL_22:
        uint64_t v395 = -v28;
        uint64_t v396 = (v4 - 1) + 1;
        uint64_t v47 = 4 * v29;
        int v48 = v39;
        uint64_t v402 = v4;
        uint64_t v407 = v29;
        while (2)
        {
          int v408 = v42;
          int v409 = v48;
          ((void (*)(void *, uint64_t, uint64_t, uint64_t))*v37)(v37, v30, v38, v4);
          uint64_t v49 = (float32x2_t *)v37[20];
          uint64_t v50 = (unsigned __int8 *)v37[18];
          unsigned int v51 = *((_DWORD *)v37 + 2);
          if (v51 == *((_DWORD *)v37 + 3))
          {
            float v52 = v405.n128_f32[0];
            if (v405.n128_f32[0] >= 1.0)
            {
              int v55 = v407;
            }
            else
            {
              int v53 = v4;
              uint64_t v54 = (unsigned char *)v37[18];
              int v55 = v407;
              do
              {
                if (*v54) {
                  *uint64_t v49 = vmul_n_f32(*v49, v52);
                }
                ++v54;
                ++v49;
                --v53;
              }
              while (v53);
              v49 += v395;
              v50 += v396 + v395;
            }
          }
          else
          {
            uint64_t v56 = v37[19];
            int v57 = HIWORD(v51) & 0x3F;
            float v58 = v405.n128_f32[0];
            if (v57 == 16)
            {
              int v55 = v407;
              uint64_t v61 = 0;
              uint64_t v62 = (float *)v49 + 1;
              if (v405.n128_f32[0] >= 1.0)
              {
                do
                {
                  if (v50[v61])
                  {
                    unint64_t v64 = *(unsigned int *)(v56 + 4 * v61);
                    *(v62 - 1) = *(float *)&_blt_float[v64 + 256]
                               + *(float *)&_blt_float[BYTE1(v64) + 512];
                    float *v62 = *(float *)&_blt_float[BYTE2(v64) + 256]
                         + *(float *)((char *)&_blt_float[512] + ((v64 >> 22) & 0x3FC));
                  }
                  ++v61;
                  v62 += 2;
                }
                while (v4 != v61);
              }
              else
              {
                do
                {
                  if (v50[v61])
                  {
                    unint64_t v63 = *(unsigned int *)(v56 + 4 * v61);
                    *(v62 - 1) = v58
                               * (float)(*(float *)&_blt_float[v63 + 256]
                                       + *(float *)&_blt_float[BYTE1(v63) + 512]);
                    float *v62 = v58
                         * (float)(*(float *)&_blt_float[BYTE2(v63) + 256]
                                 + *(float *)((char *)&_blt_float[512] + ((v63 >> 22) & 0x3FC)));
                  }
                  ++v61;
                  v62 += 2;
                }
                while (v4 != v61);
              }
            }
            else
            {
              BOOL v59 = v57 == 32;
              int v55 = v407;
              uint64_t v60 = 0;
              if (v59)
              {
                if (v405.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v50[v60]) {
                      v49[v60] = *(float32x2_t *)(v56 + 8 * v60);
                    }
                    ++v60;
                  }
                  while (v4 != v60);
                }
                else
                {
                  do
                  {
                    if (v50[v60]) {
                      v49[v60] = vmul_n_f32(*(float32x2_t *)(v56 + 8 * v60), v58);
                    }
                    ++v60;
                  }
                  while (v4 != v60);
                }
              }
              else
              {
                uint64_t v65 = (float *)v49 + 1;
                if (v405.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v50[v60])
                    {
                      unint64_t v67 = *(unsigned int *)(v56 + 4 * v60);
                      *(v65 - 1) = *(float *)&_blt_float[*(_DWORD *)(v56 + 4 * v60)];
                      *uint64_t v65 = *(float *)((char *)_blt_float + ((v67 >> 22) & 0x3FC));
                    }
                    ++v60;
                    v65 += 2;
                  }
                  while (v4 != v60);
                }
                else
                {
                  do
                  {
                    if (v50[v60])
                    {
                      unint64_t v66 = *(unsigned int *)(v56 + 4 * v60);
                      *(v65 - 1) = v58 * *(float *)&_blt_float[*(_DWORD *)(v56 + 4 * v60)];
                      *uint64_t v65 = v58 * *(float *)((char *)_blt_float + ((v66 >> 22) & 0x3FC));
                    }
                    ++v60;
                    v65 += 2;
                  }
                  while (v4 != v60);
                }
              }
            }
          }
          uint64_t v68 = &xmmword_1850CE000;
          switch(v36)
          {
            case 0:
              uint64_t v69 = v41 != 0;
              int v70 = v4;
              unint64_t v71 = v41;
              if (v55)
              {
                do
                {
                  unsigned int v72 = *v50;
                  if (*v50)
                  {
                    if (v41) {
                      unsigned int v72 = (*v71 * v72 + ((*v71 * v72) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v72)
                    {
                      if (v72 == 255)
                      {
                        *uint64_t v27 = 0.0;
                        *uint64_t v32 = 0.0;
                      }
                      else
                      {
                        float v73 = (float)((float)v72 * -0.0039216) + 1.0;
                        *uint64_t v32 = v73 * *v32;
                        *uint64_t v27 = v73 * *v27;
                      }
                    }
                  }
                  ++v50;
                  v71 += v69;
                  ++v32;
                  ++v27;
                  --v70;
                }
                while (v70);
              }
              else
              {
                do
                {
                  unsigned int v74 = *v50;
                  if (*v50)
                  {
                    if (v41) {
                      unsigned int v74 = (*v71 * v74 + ((*v71 * v74) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v74)
                    {
                      float v75 = 0.0;
                      if (v74 != 255) {
                        float v75 = (float)((float)((float)v74 * -0.0039216) + 1.0) * *v32;
                      }
                      *uint64_t v32 = v75;
                    }
                  }
                  ++v50;
                  v71 += v69;
                  ++v32;
                  --v70;
                }
                while (v70);
              }
              goto LABEL_500;
            case 1:
              unsigned __int8 v76 = *v50;
              if (v55)
              {
                int v77 = v32 - 1;
                unsigned int v78 = (float *)v49 + 1;
                float v79 = v50 + 1;
                float v80 = v27 - 1;
                int v81 = v4;
                if (v41)
                {
                  int v82 = v408;
                  do
                  {
                    if (v76)
                    {
                      unsigned int v83 = ((unsigned __int16)(*v41 * v76 + ((*v41 * v76) >> 8) + 1) >> 8);
                      if (v83)
                      {
                        if (v83 == 255)
                        {
                          v77[1] = *(v78 - 1);
                          float v84 = *v78;
                        }
                        else
                        {
                          float v85 = (float)v83 * 0.0039216;
                          v77[1] = (float)((float)(1.0 - v85) * v77[1]) + (float)(*(v78 - 1) * v85);
                          float v84 = (float)((float)(1.0 - v85) * v80[1]) + (float)(*v78 * v85);
                        }
                        v80[1] = v84;
                      }
                    }
                    unsigned __int8 v86 = *v79++;
                    unsigned __int8 v76 = v86;
                    ++v41;
                    ++v77;
                    v78 += 2;
                    ++v80;
                    --v81;
                  }
                  while (v81);
                  v41 += v403;
                }
                else
                {
                  int v82 = v408;
                  do
                  {
                    if (v76)
                    {
                      if (v76 == 255)
                      {
                        v77[1] = *(v78 - 1);
                        float v373 = *v78;
                      }
                      else
                      {
                        float v374 = (float)v76 * 0.0039216;
                        v77[1] = (float)((float)(1.0 - v374) * v77[1]) + (float)(*(v78 - 1) * v374);
                        float v373 = (float)((float)(1.0 - v374) * v80[1]) + (float)(*v78 * v374);
                      }
                      v80[1] = v373;
                    }
                    unsigned __int8 v375 = *v79++;
                    unsigned __int8 v76 = v375;
                    ++v77;
                    v78 += 2;
                    ++v80;
                    --v81;
                  }
                  while (v81);
                  int v41 = 0;
                }
                uint64_t v32 = &v77[v404 + 1];
                uint64_t v27 = &v80[v406 + 1];
                goto LABEL_503;
              }
              float v354 = v50 + 1;
              float v355 = v32 - 1;
              int v356 = v4;
              if (v41)
              {
                int v82 = v408;
                do
                {
                  if (v76)
                  {
                    unsigned int v357 = ((unsigned __int16)(*v41 * v76 + ((*v41 * v76) >> 8) + 1) >> 8);
                    if (v357)
                    {
                      if (v357 == 255) {
                        float v358 = v49->f32[0];
                      }
                      else {
                        float v358 = (float)((float)(1.0 - (float)((float)v357 * 0.0039216)) * v355[1])
                      }
                             + (float)(v49->f32[0] * (float)((float)v357 * 0.0039216));
                      v355[1] = v358;
                    }
                  }
                  unsigned __int8 v359 = *v354++;
                  unsigned __int8 v76 = v359;
                  ++v49;
                  ++v41;
                  ++v355;
                  --v356;
                }
                while (v356);
                v41 += v403;
              }
              else
              {
                int v82 = v408;
                do
                {
                  if (v76)
                  {
                    if (v76 == 255) {
                      float v380 = v49->f32[0];
                    }
                    else {
                      float v380 = (float)((float)(1.0 - (float)((float)v76 * 0.0039216)) * v355[1])
                    }
                           + (float)(v49->f32[0] * (float)((float)v76 * 0.0039216));
                    v355[1] = v380;
                  }
                  unsigned __int8 v381 = *v354++;
                  unsigned __int8 v76 = v381;
                  ++v49;
                  ++v355;
                  --v356;
                }
                while (v356);
                int v41 = 0;
              }
              uint64_t v382 = &v355[v404];
              goto LABEL_585;
            case 2:
              unsigned __int8 v87 = *v50;
              if (v55)
              {
                uint64_t v88 = v32 - 1;
                float v89 = v50 + 1;
                uint64_t v90 = v27 - 1;
                int v91 = v4;
                if (v41)
                {
                  int v82 = v408;
                  while (1)
                  {
                    if (!v87) {
                      goto LABEL_105;
                    }
                    unsigned int v92 = ((unsigned __int16)(*v41 * v87 + ((*v41 * v87) >> 8) + 1) >> 8);
                    if (!v92) {
                      goto LABEL_105;
                    }
                    if (v92 == 255)
                    {
                      float v93 = v49->f32[1];
                      if (v93 >= 1.0)
                      {
                        v88[1] = v49->f32[0];
                        goto LABEL_104;
                      }
                      if (v93 > 0.0)
                      {
                        float v94 = v49->f32[0];
                        goto LABEL_102;
                      }
                    }
                    else
                    {
                      float v95 = (float)v92 * 0.0039216;
                      float v93 = v95 * v49->f32[1];
                      if (v93 > 0.0)
                      {
                        float v94 = v95 * v49->f32[0];
LABEL_102:
                        v88[1] = v94 + (float)(v88[1] * (float)(1.0 - v93));
                        float v93 = v93 + (float)(v90[1] * (float)(1.0 - v93));
LABEL_104:
                        v90[1] = v93;
                      }
                    }
LABEL_105:
                    unsigned __int8 v96 = *v89++;
                    unsigned __int8 v87 = v96;
                    ++v49;
                    ++v41;
                    ++v88;
                    ++v90;
                    if (!--v91)
                    {
                      v41 += v403;
LABEL_561:
                      uint64_t v32 = &v88[v404 + 1];
                      uint64_t v27 = &v90[v406 + 1];
                      goto LABEL_503;
                    }
                  }
                }
                int v82 = v408;
                while (1)
                {
                  if (v87)
                  {
                    if (v87 == 255)
                    {
                      float v376 = v49->f32[1];
                      if (v376 >= 1.0)
                      {
                        v88[1] = v49->f32[0];
                        goto LABEL_558;
                      }
                      if (v376 > 0.0)
                      {
                        float v377 = v49->f32[0];
                        goto LABEL_556;
                      }
                    }
                    else
                    {
                      float v378 = (float)v87 * 0.0039216;
                      float v376 = v378 * v49->f32[1];
                      if (v376 > 0.0)
                      {
                        float v377 = v378 * v49->f32[0];
LABEL_556:
                        v88[1] = v377 + (float)(v88[1] * (float)(1.0 - v376));
                        float v376 = v376 + (float)(v90[1] * (float)(1.0 - v376));
LABEL_558:
                        v90[1] = v376;
                      }
                    }
                  }
                  unsigned __int8 v379 = *v89++;
                  unsigned __int8 v87 = v379;
                  ++v49;
                  ++v88;
                  ++v90;
                  if (!--v91)
                  {
                    int v41 = 0;
                    goto LABEL_561;
                  }
                }
              }
              uint64_t v360 = v50 + 1;
              uint64_t v361 = v32 - 1;
              int v362 = v4;
              if (!v41)
              {
                int v82 = v408;
                while (1)
                {
                  if (v87)
                  {
                    if (v87 == 255)
                    {
                      float v383 = v49->f32[1];
                      if (v383 >= 1.0)
                      {
                        float v386 = v49->f32[0];
                        goto LABEL_581;
                      }
                      if (v383 > 0.0)
                      {
                        float v384 = v49->f32[0];
                        goto LABEL_579;
                      }
                    }
                    else
                    {
                      float v385 = (float)v87 * 0.0039216;
                      float v383 = v385 * v49->f32[1];
                      if (v383 > 0.0)
                      {
                        float v384 = v385 * v49->f32[0];
LABEL_579:
                        float v386 = v384 + (float)(v361[1] * (float)(1.0 - v383));
LABEL_581:
                        v361[1] = v386;
                      }
                    }
                  }
                  unsigned __int8 v387 = *v360++;
                  unsigned __int8 v87 = v387;
                  ++v49;
                  ++v361;
                  if (!--v362)
                  {
                    int v41 = 0;
                    goto LABEL_584;
                  }
                }
              }
              int v82 = v408;
              do
              {
                if (v87)
                {
                  unsigned int v363 = ((unsigned __int16)(*v41 * v87 + ((*v41 * v87) >> 8) + 1) >> 8);
                  if (v363)
                  {
                    if (v363 == 255)
                    {
                      float v364 = v49->f32[1];
                      if (v364 >= 1.0)
                      {
                        float v367 = v49->f32[0];
                        goto LABEL_528;
                      }
                      if (v364 <= 0.0) {
                        goto LABEL_529;
                      }
                      float v365 = v49->f32[0];
                    }
                    else
                    {
                      float v366 = (float)v363 * 0.0039216;
                      float v364 = v366 * v49->f32[1];
                      if (v364 <= 0.0) {
                        goto LABEL_529;
                      }
                      float v365 = v366 * v49->f32[0];
                    }
                    float v367 = v365 + (float)(v361[1] * (float)(1.0 - v364));
LABEL_528:
                    v361[1] = v367;
                  }
                }
LABEL_529:
                unsigned __int8 v368 = *v360++;
                unsigned __int8 v87 = v368;
                ++v49;
                ++v41;
                ++v361;
                --v362;
              }
              while (v362);
              v41 += v403;
LABEL_584:
              uint64_t v382 = &v361[v404];
LABEL_585:
              uint64_t v32 = v382 + 1;
              v27 += v406;
LABEL_503:
              int v42 = v82 - 1;
              if (!v42) {
                goto LABEL_596;
              }
              int v48 = 0;
              LODWORD(v410) = v410 + 1;
              v30 += v37[16];
              v38 += v37[17];
              if (v409)
              {
                uint64_t v401 = v38;
                uint64_t v46 = v397;
                int v44 = (int)v410;
                goto LABEL_586;
              }
              continue;
            case 3:
              uint64_t v97 = (float *)v49 + 1;
              int v98 = v4;
              unint64_t v71 = v41;
              do
              {
                unsigned int v99 = *v50;
                if (*v50)
                {
                  if (v41) {
                    unsigned int v99 = (*v71 * v99 + ((*v71 * v99) >> 8) + 1) >> 8;
                  }
                  if ((_BYTE)v99)
                  {
                    if (v99 == 255)
                    {
                      *uint64_t v32 = *(v97 - 1) * *v27;
                      float v100 = *v97 * *v27;
                    }
                    else
                    {
                      float v101 = (float)v99 * 0.0039216;
                      float v102 = *v27;
                      float v103 = v101 * *v27;
                      float v104 = 1.0 - v101;
                      *uint64_t v32 = (float)(v104 * *v32) + (float)(*(v97 - 1) * v103);
                      float v100 = (float)(v104 * v102) + (float)(*v97 * v103);
                    }
                    *uint64_t v27 = v100;
                  }
                }
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v97 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                --v98;
              }
              while (v98);
              goto LABEL_500;
            case 4:
              float v105 = (float *)v49 + 1;
              int v106 = v4;
              unint64_t v71 = v41;
              do
              {
                unsigned int v107 = *v50;
                if (*v50)
                {
                  if (v41) {
                    unsigned int v107 = (*v71 * v107 + ((*v71 * v107) >> 8) + 1) >> 8;
                  }
                  if ((_BYTE)v107)
                  {
                    if (v107 == 255)
                    {
                      *uint64_t v32 = *(v105 - 1) * (float)(1.0 - *v27);
                      float v108 = *v105 * (float)(1.0 - *v27);
                    }
                    else
                    {
                      float v109 = (float)v107 * 0.0039216;
                      float v110 = *v27;
                      float v111 = v109 * (float)(1.0 - *v27);
                      float v112 = 1.0 - v109;
                      *uint64_t v32 = (float)(v112 * *v32) + (float)(*(v105 - 1) * v111);
                      float v108 = (float)(v112 * v110) + (float)(*v105 * v111);
                    }
                    *uint64_t v27 = v108;
                  }
                }
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v105 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                --v106;
              }
              while (v106);
              goto LABEL_500;
            case 5:
              uint64_t v113 = (float *)v49 + 1;
              int v114 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v115 = *v50;
                if (*v50)
                {
                  if (!v41) {
                    goto LABEL_134;
                  }
                  unsigned int v116 = *v71 * v115 + ((*v71 * v115) >> 8) + 1;
                  if (BYTE1(v116)) {
                    break;
                  }
                }
LABEL_135:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v113 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v114) {
                  goto LABEL_500;
                }
              }
              unsigned int v115 = v116 >> 8;
LABEL_134:
              float v117 = *v27;
              float v118 = (float)v115 * 0.0039216;
              float v119 = *(v113 - 1) * v118;
              float v120 = v118 * *v113;
              *uint64_t v32 = (float)(*v32 * (float)(1.0 - v120)) + (float)(v119 * *v27);
              *uint64_t v27 = (float)(v117 * (float)(1.0 - v120)) + (float)(v120 * v117);
              goto LABEL_135;
            case 6:
              int v121 = (float *)v49 + 1;
              int v122 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v123 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v124 = *v71 * v123 + ((*v71 * v123) >> 8) + 1;
                    if (!BYTE1(v124)) {
                      goto LABEL_147;
                    }
                    unsigned int v123 = v124 >> 8;
                  }
                  float v125 = *v27;
                  float v126 = 1.0 - *v27;
                  if (v126 >= 1.0)
                  {
                    float v129 = (float)v123 * 0.0039216;
                    *uint64_t v32 = v129 * *(v121 - 1);
                    float v128 = v129 * *v121;
                    goto LABEL_146;
                  }
                  if (v126 > 0.0)
                  {
                    float v127 = v126 * (float)((float)v123 * 0.0039216);
                    *uint64_t v32 = *v32 + (float)(*(v121 - 1) * v127);
                    float v128 = v125 + (float)(*v121 * v127);
LABEL_146:
                    *uint64_t v27 = v128;
                  }
                }
LABEL_147:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v121 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v122) {
                  goto LABEL_500;
                }
              }
            case 7:
              uint64_t v130 = v41 != 0;
              uint64_t v131 = (float *)v49 + 1;
              int v132 = v4;
              unint64_t v71 = v41;
              if (v55)
              {
                do
                {
                  unsigned int v133 = *v50;
                  if (*v50)
                  {
                    if (v41) {
                      unsigned int v133 = (*v71 * v133 + ((*v71 * v133) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v133)
                    {
                      if (v133 == 255)
                      {
                        float v134 = *v131;
                        *uint64_t v32 = *v32 * *v131;
                        float v135 = v134 * *v27;
                      }
                      else
                      {
                        float v136 = (float)v133 * 0.0039216;
                        float v137 = *v27;
                        float v138 = v136 * *v131;
                        float v139 = 1.0 - v136;
                        *uint64_t v32 = (float)(v139 * *v32) + (float)(*v32 * v138);
                        float v135 = (float)(v139 * v137) + (float)(v137 * v138);
                      }
                      *uint64_t v27 = v135;
                    }
                  }
                  ++v50;
                  v71 += v130;
                  ++v32;
                  ++v27;
                  v131 += 2;
                  --v132;
                }
                while (v132);
              }
              else
              {
                do
                {
                  unsigned int v140 = *v50;
                  if (*v50)
                  {
                    if (v41) {
                      unsigned int v140 = (*v71 * v140 + ((*v71 * v140) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v140)
                    {
                      if (v140 == 255) {
                        float v141 = *v32 * *v131;
                      }
                      else {
                        float v141 = (float)((float)(1.0 - (float)((float)v140 * 0.0039216)) * *v32)
                      }
                             + (float)(*v32 * (float)((float)((float)v140 * 0.0039216) * *v131));
                      *uint64_t v32 = v141;
                    }
                  }
                  ++v50;
                  v71 += v130;
                  ++v32;
                  v131 += 2;
                  --v132;
                }
                while (v132);
              }
              goto LABEL_500;
            case 8:
              uint64_t v142 = v41 != 0;
              float v143 = (float *)v49 + 1;
              int v144 = v4;
              unint64_t v71 = v41;
              if (v55)
              {
                do
                {
                  unsigned int v145 = *v50;
                  if (*v50)
                  {
                    if (v41) {
                      unsigned int v145 = (*v71 * v145 + ((*v71 * v145) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v145)
                    {
                      if (v145 == 255)
                      {
                        float v146 = 1.0 - *v143;
                        *uint64_t v32 = *v32 * v146;
                        float v147 = v146 * *v27;
                      }
                      else
                      {
                        float v148 = (float)v145 * 0.0039216;
                        float v149 = *v27;
                        float v150 = v148 * (float)(1.0 - *v143);
                        float v151 = 1.0 - v148;
                        *uint64_t v32 = (float)(v151 * *v32) + (float)(*v32 * v150);
                        float v147 = (float)(v151 * v149) + (float)(v149 * v150);
                      }
                      *uint64_t v27 = v147;
                    }
                  }
                  ++v50;
                  v71 += v142;
                  ++v32;
                  ++v27;
                  v143 += 2;
                  --v144;
                }
                while (v144);
              }
              else
              {
                do
                {
                  unsigned int v152 = *v50;
                  if (*v50)
                  {
                    if (v41) {
                      unsigned int v152 = (*v71 * v152 + ((*v71 * v152) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v152)
                    {
                      if (v152 == 255) {
                        float v153 = *v32 * (float)(1.0 - *v143);
                      }
                      else {
                        float v153 = (float)((float)(1.0 - (float)((float)v152 * 0.0039216)) * *v32)
                      }
                             + (float)(*v32
                                     * (float)((float)((float)v152 * 0.0039216) * (float)(1.0 - *v143)));
                      *uint64_t v32 = v153;
                    }
                  }
                  ++v50;
                  v71 += v142;
                  ++v32;
                  v143 += 2;
                  --v144;
                }
                while (v144);
              }
              goto LABEL_500;
            case 9:
              uint64_t v154 = (float *)v49 + 1;
              int v155 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v156 = *v50;
                if (*v50)
                {
                  if (!v41) {
                    goto LABEL_196;
                  }
                  unsigned int v157 = *v71 * v156 + ((*v71 * v156) >> 8) + 1;
                  if (BYTE1(v157)) {
                    break;
                  }
                }
LABEL_197:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v154 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v155) {
                  goto LABEL_500;
                }
              }
              unsigned int v156 = v157 >> 8;
LABEL_196:
              float v158 = *v27;
              float v159 = (float)v156 * 0.0039216;
              float v160 = *(v154 - 1) * v159;
              float v161 = v159 * *v154;
              float v162 = 1.0 - *v27;
              float v163 = (float)(1.0 - v159) + v161;
              *uint64_t v32 = (float)(*v32 * v163) + (float)(v160 * v162);
              *uint64_t v27 = (float)(v158 * v163) + (float)(v161 * v162);
              goto LABEL_197;
            case 10:
              float v164 = (float *)v49 + 1;
              int v165 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v166 = *v50;
                if (*v50)
                {
                  if (!v41) {
                    goto LABEL_204;
                  }
                  unsigned int v167 = *v71 * v166 + ((*v71 * v166) >> 8) + 1;
                  if (BYTE1(v167)) {
                    break;
                  }
                }
LABEL_205:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v164 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v165) {
                  goto LABEL_500;
                }
              }
              unsigned int v166 = v167 >> 8;
LABEL_204:
              float v168 = *v27;
              float v169 = (float)v166 * 0.0039216;
              float v170 = *(v164 - 1) * v169;
              float v171 = v169 * *v164;
              float v172 = 1.0 - *v27;
              *uint64_t v32 = (float)(*v32 * (float)(1.0 - v171)) + (float)(v170 * v172);
              *uint64_t v27 = (float)(v168 * (float)(1.0 - v171)) + (float)(v171 * v172);
              goto LABEL_205;
            case 11:
              uint64_t v173 = v41 != 0;
              uint64_t v174 = (float *)v49 + 1;
              int v175 = v4;
              unint64_t v71 = v41;
              if (v55)
              {
                while (1)
                {
                  unsigned int v176 = *v50;
                  if (*v50)
                  {
                    if (!v41) {
                      goto LABEL_212;
                    }
                    unsigned int v177 = *v71 * v176 + ((*v71 * v176) >> 8) + 1;
                    if (BYTE1(v177)) {
                      break;
                    }
                  }
LABEL_215:
                  ++v50;
                  v71 += v173;
                  ++v32;
                  ++v27;
                  v174 += 2;
                  if (!--v175) {
                    goto LABEL_500;
                  }
                }
                unsigned int v176 = v177 >> 8;
LABEL_212:
                float v178 = (float)v176 * 0.0039216;
                float v179 = *(v174 - 1) * v178;
                float v180 = *v174 * v178;
                float v181 = *v27 + v180;
                float v182 = (float)(v180 - v179) + (float)(*v27 - *v32);
                float v183 = 1.0;
                if (v181 <= 1.0) {
                  float v183 = v181;
                }
                *uint64_t v27 = v183;
                *uint64_t v32 = v183 - v182;
                goto LABEL_215;
              }
              while (1)
              {
                unsigned int v184 = *v50;
                if (*v50)
                {
                  if (!v41) {
                    goto LABEL_221;
                  }
                  unsigned int v185 = *v71 * v184 + ((*v71 * v184) >> 8) + 1;
                  if (BYTE1(v185)) {
                    break;
                  }
                }
LABEL_222:
                ++v50;
                v71 += v173;
                ++v32;
                v174 += 2;
                if (!--v175) {
                  goto LABEL_500;
                }
              }
              unsigned int v184 = v185 >> 8;
LABEL_221:
              *uint64_t v32 = 1.0
                   - (float)((float)(1.0 - *v32)
                           + (float)((float)(*v174 * (float)((float)v184 * 0.0039216))
                                   - (float)(*(v174 - 1) * (float)((float)v184 * 0.0039216))));
              goto LABEL_222;
            case 12:
              uint64_t v186 = v41 != 0;
              if (v55)
              {
                uint64_t v187 = (float *)v49 + 1;
                int v188 = v4;
                unint64_t v71 = v41;
                while (1)
                {
                  unsigned int v189 = *v50;
                  if (*v50)
                  {
                    if (!v41) {
                      goto LABEL_230;
                    }
                    unsigned int v190 = *v71 * v189 + ((*v71 * v189) >> 8) + 1;
                    if (BYTE1(v190)) {
                      break;
                    }
                  }
LABEL_233:
                  ++v50;
                  v71 += v186;
                  ++v32;
                  ++v27;
                  v187 += 2;
                  if (!--v188) {
                    goto LABEL_500;
                  }
                }
                unsigned int v189 = v190 >> 8;
LABEL_230:
                float v191 = (float)v189 * 0.0039216;
                float v192 = *(v187 - 1) * v191;
                float v193 = *v27 + (float)(*v187 * v191);
                float v194 = v192 + *v32;
                if (v193 > 1.0) {
                  float v193 = 1.0;
                }
                *uint64_t v32 = v194;
                *uint64_t v27 = v193;
                goto LABEL_233;
              }
              int v369 = v4;
              float v370 = v41;
              while (1)
              {
                unsigned int v371 = *v50;
                if (*v50)
                {
                  if (!v41) {
                    goto LABEL_536;
                  }
                  unsigned int v372 = *v370 * v371 + ((*v370 * v371) >> 8) + 1;
                  if (BYTE1(v372)) {
                    break;
                  }
                }
LABEL_537:
                ++v50;
                ++v49;
                v370 += v186;
                ++v32;
                if (!--v369)
                {
                  int v41 = &v370[v403];
LABEL_501:
                  v32 += v404;
                  v27 += v406;
LABEL_502:
                  int v82 = v408;
                  goto LABEL_503;
                }
              }
              unsigned int v371 = v372 >> 8;
LABEL_536:
              *uint64_t v32 = *v32 + (float)(v49->f32[0] * (float)((float)v371 * 0.0039216));
              goto LABEL_537;
            case 13:
              float v195 = (float *)v49 + 1;
              int v196 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v197 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v198 = *v71 * v197 + ((*v71 * v197) >> 8) + 1;
                    if (!BYTE1(v198)) {
                      goto LABEL_251;
                    }
                    unsigned int v197 = v198 >> 8;
                  }
                  float v199 = (float)v197 * 0.0039216;
                  float v200 = *v195 * v199;
                  if (v200 > 0.0)
                  {
                    float v201 = *(v195 - 1) * v199;
                    float v202 = 1.0;
                    if (!v55 || (float v202 = *v27, *v27 > 0.0))
                    {
                      float v203 = (float)(v201 * *v32) + (float)(*v32 * (float)(1.0 - v200));
                      if (v200 == 1.0) {
                        float v203 = v201 * *v32;
                      }
                      float v201 = v203 + (float)(v201 * (float)(1.0 - v202));
                      if (v202 == 1.0) {
                        float v201 = v203;
                      }
                      if (!v55)
                      {
                        *uint64_t v32 = v201;
                        goto LABEL_251;
                      }
                      float v200 = (float)(v200 + v202) - (float)(v202 * v200);
                    }
                    *uint64_t v32 = v201;
                    *uint64_t v27 = v200;
                  }
                }
LABEL_251:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v195 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v196) {
                  goto LABEL_500;
                }
              }
            case 14:
              float v204 = (float *)v49 + 1;
              int v205 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v206 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v207 = *v71 * v206 + ((*v71 * v206) >> 8) + 1;
                    if (!BYTE1(v207)) {
                      goto LABEL_265;
                    }
                    unsigned int v206 = v207 >> 8;
                  }
                  float v208 = (float)v206 * 0.0039216;
                  float v209 = *v204 * v208;
                  if (v209 > 0.0)
                  {
                    float v210 = *(v204 - 1) * v208;
                    float v211 = 1.0;
                    if (!v55 || (float v211 = *v27, *v27 > 0.0))
                    {
                      float v210 = *v32 + (float)(v210 * (float)(1.0 - *v32));
                      if (!v55)
                      {
                        *uint64_t v32 = v210;
                        goto LABEL_265;
                      }
                      float v209 = (float)(v209 + v211) - (float)(v211 * v209);
                    }
                    *uint64_t v32 = v210;
                    *uint64_t v27 = v209;
                  }
                }
LABEL_265:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v204 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v205) {
                  goto LABEL_500;
                }
              }
            case 15:
              uint64_t v400 = v30;
              uint64_t v401 = v38;
              uint64_t v212 = (float *)v49 + 1;
              int v213 = v4;
              int v214 = v41;
              while (1)
              {
                unsigned int v215 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v216 = *v214 * v215 + ((*v214 * v215) >> 8) + 1;
                    if (!BYTE1(v216)) {
                      goto LABEL_281;
                    }
                    unsigned int v215 = v216 >> 8;
                  }
                  float v217 = (float)v215 * *((float *)v68 + 677);
                  float v218 = *v212 * v217;
                  if (v218 > 0.0)
                  {
                    float v219 = *(v212 - 1) * v217;
                    if (v55)
                    {
                      float v220 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_279:
                        *uint64_t v32 = v219;
                        *uint64_t v27 = v218;
                        goto LABEL_281;
                      }
                    }
                    else
                    {
                      float v220 = 1.0;
                    }
                    uint64_t v221 = v68;
                    float v222 = PDAoverlayPDA(*v32, v220, v219, v218);
                    int v55 = v407;
                    float v219 = v222;
                    if (!v407)
                    {
                      *uint64_t v32 = v222;
                      uint64_t v68 = v221;
                      uint64_t v4 = v402;
                      goto LABEL_281;
                    }
                    float v218 = v223;
                    uint64_t v68 = v221;
                    uint64_t v4 = v402;
                    goto LABEL_279;
                  }
                }
LABEL_281:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v212 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v213) {
                  goto LABEL_386;
                }
              }
            case 16:
              uint64_t v224 = (float *)v49 + 1;
              int v225 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v226 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v227 = *v71 * v226 + ((*v71 * v226) >> 8) + 1;
                    if (!BYTE1(v227)) {
                      goto LABEL_301;
                    }
                    unsigned int v226 = v227 >> 8;
                  }
                  float v228 = (float)v226 * 0.0039216;
                  float v229 = *v224 * v228;
                  if (v229 > 0.0)
                  {
                    float v230 = *(v224 - 1) * v228;
                    float v231 = 1.0;
                    if (!v55 || (float v231 = *v27, *v27 > 0.0))
                    {
                      float v232 = v229 * *v32;
                      if ((float)(v230 * v231) < v232) {
                        float v232 = v230 * v231;
                      }
                      float v233 = v232 + (float)(*v32 * (float)(1.0 - v229));
                      if (v229 == 1.0) {
                        float v233 = v232;
                      }
                      float v230 = v233 + (float)(v230 * (float)(1.0 - v231));
                      if (v231 == 1.0) {
                        float v230 = v233;
                      }
                      if (!v55)
                      {
                        *uint64_t v32 = v230;
                        goto LABEL_301;
                      }
                      float v229 = (float)(v229 + v231) - (float)(v231 * v229);
                    }
                    *uint64_t v32 = v230;
                    *uint64_t v27 = v229;
                  }
                }
LABEL_301:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v224 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v225) {
                  goto LABEL_500;
                }
              }
            case 17:
              float v234 = (float *)v49 + 1;
              int v235 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v236 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v237 = *v71 * v236 + ((*v71 * v236) >> 8) + 1;
                    if (!BYTE1(v237)) {
                      goto LABEL_321;
                    }
                    unsigned int v236 = v237 >> 8;
                  }
                  float v238 = (float)v236 * 0.0039216;
                  float v239 = *v234 * v238;
                  if (v239 > 0.0)
                  {
                    float v240 = *(v234 - 1) * v238;
                    float v241 = 1.0;
                    if (!v55 || (float v241 = *v27, *v27 > 0.0))
                    {
                      float v242 = v239 * *v32;
                      if ((float)(v240 * v241) > v242) {
                        float v242 = v240 * v241;
                      }
                      float v243 = v242 + (float)(*v32 * (float)(1.0 - v239));
                      if (v239 == 1.0) {
                        float v243 = v242;
                      }
                      float v240 = v243 + (float)(v240 * (float)(1.0 - v241));
                      if (v241 == 1.0) {
                        float v240 = v243;
                      }
                      if (!v55)
                      {
                        *uint64_t v32 = v240;
                        goto LABEL_321;
                      }
                      float v239 = (float)(v239 + v241) - (float)(v241 * v239);
                    }
                    *uint64_t v32 = v240;
                    *uint64_t v27 = v239;
                  }
                }
LABEL_321:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v234 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v235) {
                  goto LABEL_500;
                }
              }
            case 18:
              uint64_t v400 = v30;
              uint64_t v401 = v38;
              uint64_t v244 = (float *)v49 + 1;
              int v245 = v4;
              int v214 = v41;
              while (1)
              {
                unsigned int v246 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v247 = *v214 * v246 + ((*v214 * v246) >> 8) + 1;
                    if (!BYTE1(v247)) {
                      goto LABEL_337;
                    }
                    unsigned int v246 = v247 >> 8;
                  }
                  float v248 = (float)v246 * *((float *)v68 + 677);
                  float v249 = *v244 * v248;
                  if (v249 > 0.0)
                  {
                    float v250 = *(v244 - 1) * v248;
                    if (v55)
                    {
                      float v251 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_335:
                        *uint64_t v32 = v250;
                        *uint64_t v27 = v249;
                        goto LABEL_337;
                      }
                    }
                    else
                    {
                      float v251 = 1.0;
                    }
                    float v252 = v68;
                    float v253 = PDAcolordodgePDA(*v32, v251, v250, v249);
                    int v55 = v407;
                    float v250 = v253;
                    if (!v407)
                    {
                      *uint64_t v32 = v253;
                      uint64_t v68 = v252;
                      uint64_t v4 = v402;
                      goto LABEL_337;
                    }
                    float v249 = v254;
                    uint64_t v68 = v252;
                    uint64_t v4 = v402;
                    goto LABEL_335;
                  }
                }
LABEL_337:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v244 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v245) {
                  goto LABEL_386;
                }
              }
            case 19:
              uint64_t v400 = v30;
              uint64_t v401 = v38;
              int v255 = (float *)v49 + 1;
              int v256 = v4;
              int v214 = v41;
              while (1)
              {
                unsigned int v257 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v258 = *v214 * v257 + ((*v214 * v257) >> 8) + 1;
                    if (!BYTE1(v258)) {
                      goto LABEL_353;
                    }
                    unsigned int v257 = v258 >> 8;
                  }
                  float v259 = (float)v257 * *((float *)v68 + 677);
                  float v260 = *v255 * v259;
                  if (v260 > 0.0)
                  {
                    float v261 = *(v255 - 1) * v259;
                    if (v55)
                    {
                      float v262 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_351:
                        *uint64_t v32 = v261;
                        *uint64_t v27 = v260;
                        goto LABEL_353;
                      }
                    }
                    else
                    {
                      float v262 = 1.0;
                    }
                    uint64_t v263 = v68;
                    double v264 = PDAcolorburnPDA(*v32, v262, v261, v260);
                    int v55 = v407;
                    float v261 = *(float *)&v264;
                    if (!v407)
                    {
                      *uint64_t v32 = *(float *)&v264;
                      uint64_t v68 = v263;
                      uint64_t v4 = v402;
                      goto LABEL_353;
                    }
                    float v260 = v265;
                    uint64_t v68 = v263;
                    uint64_t v4 = v402;
                    goto LABEL_351;
                  }
                }
LABEL_353:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v255 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v256) {
                  goto LABEL_386;
                }
              }
            case 20:
              uint64_t v400 = v30;
              uint64_t v401 = v38;
              uint64_t v266 = (float *)v49 + 1;
              int v267 = v4;
              int v214 = v41;
              while (1)
              {
                unsigned int v268 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v269 = *v214 * v268 + ((*v214 * v268) >> 8) + 1;
                    if (!BYTE1(v269)) {
                      goto LABEL_369;
                    }
                    unsigned int v268 = v269 >> 8;
                  }
                  float v270 = (float)v268 * *((float *)v68 + 677);
                  float v271 = *v266 * v270;
                  if (v271 > 0.0)
                  {
                    float v272 = *(v266 - 1) * v270;
                    if (v55)
                    {
                      float v273 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_367:
                        *uint64_t v32 = v272;
                        *uint64_t v27 = v271;
                        goto LABEL_369;
                      }
                    }
                    else
                    {
                      float v273 = 1.0;
                    }
                    float v274 = v68;
                    float v275 = PDAsoftlightPDA(*v32, v273, v272, v271);
                    int v55 = v407;
                    float v272 = v275;
                    if (!v407)
                    {
                      *uint64_t v32 = v275;
                      uint64_t v68 = v274;
                      uint64_t v4 = v402;
                      goto LABEL_369;
                    }
                    float v271 = v276;
                    uint64_t v68 = v274;
                    uint64_t v4 = v402;
                    goto LABEL_367;
                  }
                }
LABEL_369:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v266 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v267) {
                  goto LABEL_386;
                }
              }
            case 21:
              uint64_t v400 = v30;
              uint64_t v401 = v38;
              uint64_t v277 = (float *)v49 + 1;
              int v278 = v4;
              int v214 = v41;
              while (1)
              {
                unsigned int v279 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v280 = *v214 * v279 + ((*v214 * v279) >> 8) + 1;
                    if (!BYTE1(v280)) {
                      goto LABEL_385;
                    }
                    unsigned int v279 = v280 >> 8;
                  }
                  float v281 = (float)v279 * *((float *)v68 + 677);
                  float v282 = *v277 * v281;
                  if (v282 > 0.0)
                  {
                    float v283 = *(v277 - 1) * v281;
                    if (v55)
                    {
                      float v284 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_383:
                        *uint64_t v32 = v283;
                        *uint64_t v27 = v282;
                        goto LABEL_385;
                      }
                    }
                    else
                    {
                      float v284 = 1.0;
                    }
                    uint64_t v285 = v68;
                    float v286 = PDAhardlightPDA(*v32, v284, v283, v282);
                    int v55 = v407;
                    float v283 = v286;
                    if (!v407)
                    {
                      *uint64_t v32 = v286;
                      uint64_t v68 = v285;
                      uint64_t v4 = v402;
                      goto LABEL_385;
                    }
                    float v282 = v287;
                    uint64_t v68 = v285;
                    uint64_t v4 = v402;
                    goto LABEL_383;
                  }
                }
LABEL_385:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v277 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v278)
                {
LABEL_386:
                  int v41 = &v214[v403];
                  v32 += v404;
                  v27 += v406;
                  int v36 = v399;
                  unint64_t v37 = v398;
                  uint64_t v30 = v400;
                  uint64_t v38 = v401;
                  goto LABEL_502;
                }
              }
            case 22:
              int v288 = (float *)v49 + 1;
              int v289 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v290 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v291 = *v71 * v290 + ((*v71 * v290) >> 8) + 1;
                    if (!BYTE1(v291)) {
                      goto LABEL_403;
                    }
                    unsigned int v290 = v291 >> 8;
                  }
                  float v292 = (float)v290 * 0.0039216;
                  float v293 = *v288 * v292;
                  if (v293 > 0.0)
                  {
                    float v294 = *(v288 - 1) * v292;
                    if (v55)
                    {
                      float v295 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_401:
                        *uint64_t v32 = v294;
                        *uint64_t v27 = v293;
                        goto LABEL_403;
                      }
                    }
                    else
                    {
                      float v295 = 1.0;
                    }
                    float v296 = v294 + *v32;
                    float v297 = v293 * *v32;
                    float v298 = v294 * v295;
                    float v299 = v296 - v297;
                    float v300 = v297 - v298;
                    float v301 = v299 - v298;
                    if (v300 < 0.0) {
                      float v300 = -v300;
                    }
                    float v294 = v301 + v300;
                    if (!v55)
                    {
                      *uint64_t v32 = v294;
                      goto LABEL_403;
                    }
                    float v293 = (float)(v293 + v295) - (float)(v295 * v293);
                    goto LABEL_401;
                  }
                }
LABEL_403:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v288 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v289) {
                  goto LABEL_500;
                }
              }
            case 23:
              uint64_t v302 = (float *)v49 + 1;
              int v303 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v304 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v305 = *v71 * v304 + ((*v71 * v304) >> 8) + 1;
                    if (!BYTE1(v305)) {
                      goto LABEL_419;
                    }
                    unsigned int v304 = v305 >> 8;
                  }
                  float v306 = (float)v304 * 0.0039216;
                  float v307 = *v302 * v306;
                  if (v307 > 0.0)
                  {
                    float v308 = *(v302 - 1) * v306;
                    if (v55)
                    {
                      float v309 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_417:
                        *uint64_t v32 = v308;
                        *uint64_t v27 = v307;
                        goto LABEL_419;
                      }
                    }
                    else
                    {
                      float v309 = 1.0;
                    }
                    float v308 = (float)(v308 + *v32) + (float)((float)(v308 * *v32) * -2.0);
                    if (!v55)
                    {
                      *uint64_t v32 = v308;
                      goto LABEL_419;
                    }
                    float v307 = (float)(v307 + v309) - (float)(v309 * v307);
                    goto LABEL_417;
                  }
                }
LABEL_419:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v302 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v303) {
                  goto LABEL_500;
                }
              }
            case 24:
              float v310 = (float *)v49 + 1;
              int v311 = v4;
              unint64_t v71 = v41;
              while (1)
              {
                unsigned int v312 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v313 = *v71 * v312 + ((*v71 * v312) >> 8) + 1;
                    if (!BYTE1(v313)) {
                      goto LABEL_439;
                    }
                    unsigned int v312 = v313 >> 8;
                  }
                  float v314 = (float)v312 * 0.0039216;
                  float v315 = *v310 * v314;
                  if (v315 > 0.0)
                  {
                    float v316 = *(v310 - 1) * v314;
                    float v317 = 1.0;
                    if (!v55 || (float v317 = *v27, *v27 > 0.0))
                    {
                      float v318 = *v32;
                      if (v315 != 1.0) {
                        float v318 = v315 * *v32;
                      }
                      float v319 = 0.0;
                      if (v315 != 1.0) {
                        float v319 = *v32 - (float)(v315 * *v32);
                      }
                      float v320 = (float)(v316 + v319) - (float)(v316 * v317);
                      if (v317 == 1.0) {
                        float v320 = v319;
                      }
                      float v316 = v318 + v320;
                      if (!v55)
                      {
                        *uint64_t v32 = v316;
                        goto LABEL_439;
                      }
                      float v315 = (float)(v315 + v317) - (float)(v315 * v317);
                    }
                    *uint64_t v32 = v316;
                    *uint64_t v27 = v315;
                  }
                }
LABEL_439:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v310 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v311) {
                  goto LABEL_500;
                }
              }
            case 25:
              uint64_t v321 = (float *)v49 + 1;
              unint64_t v71 = v41;
              int v322 = v4;
              while (1)
              {
                unsigned int v323 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v324 = *v71 * v323 + ((*v71 * v323) >> 8) + 1;
                    if (!BYTE1(v324)) {
                      goto LABEL_459;
                    }
                    unsigned int v323 = v324 >> 8;
                  }
                  float v325 = (float)v323 * 0.0039216;
                  float v326 = *v321 * v325;
                  if (v326 > 0.0)
                  {
                    float v327 = *(v321 - 1) * v325;
                    float v328 = 1.0;
                    if (!v55 || (float v328 = *v27, *v27 > 0.0))
                    {
                      float v329 = *v32;
                      if (v326 != 1.0) {
                        float v329 = v326 * *v32;
                      }
                      float v330 = 0.0;
                      if (v326 != 1.0) {
                        float v330 = *v32 - (float)(v326 * *v32);
                      }
                      float v331 = (float)(v327 + v330) - (float)(v327 * v328);
                      if (v328 == 1.0) {
                        float v331 = v330;
                      }
                      float v327 = v329 + v331;
                      if (!v55)
                      {
                        *uint64_t v32 = v327;
                        goto LABEL_459;
                      }
                      float v326 = (float)(v326 + v328) - (float)(v326 * v328);
                    }
                    *uint64_t v32 = v327;
                    *uint64_t v27 = v326;
                  }
                }
LABEL_459:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v321 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v322) {
                  goto LABEL_500;
                }
              }
            case 26:
              float v332 = (float *)v49 + 1;
              unint64_t v71 = v41;
              int v333 = v4;
              while (1)
              {
                unsigned int v334 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    unsigned int v335 = *v71 * v334 + ((*v71 * v334) >> 8) + 1;
                    if (!BYTE1(v335)) {
                      goto LABEL_480;
                    }
                    unsigned int v334 = v335 >> 8;
                  }
                  float v336 = (float)v334 * 0.0039216;
                  float v337 = *v332 * v336;
                  if (v337 > 0.0)
                  {
                    float v338 = *(v332 - 1) * v336;
                    float v339 = 1.0;
                    if (!v55 || (float v339 = *v27, *v27 > 0.0))
                    {
                      float v340 = *v32;
                      float v341 = v338 - (float)(v338 * v339);
                      if (v339 == 1.0) {
                        float v341 = 0.0;
                      }
                      if (v337 == 1.0) {
                        float v342 = *v32;
                      }
                      else {
                        float v342 = v337 * v340;
                      }
                      if (v337 != 1.0) {
                        float v341 = (float)(v340 + v341) - (float)(v337 * v340);
                      }
                      float v338 = v342 + v341;
                      if (!v55)
                      {
                        *uint64_t v32 = v338;
                        goto LABEL_480;
                      }
                      float v337 = (float)(v337 + v339) - (float)(v337 * v339);
                    }
                    *uint64_t v32 = v338;
                    *uint64_t v27 = v337;
                  }
                }
LABEL_480:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v332 += 2;
                uint64_t v27 = (float *)((char *)v27 + v47);
                if (!--v333) {
                  goto LABEL_500;
                }
              }
            case 27:
              uint64_t v343 = (float *)v49 + 1;
              unint64_t v71 = v41;
              int v344 = v4;
              break;
            default:
              goto LABEL_502;
          }
          break;
        }
        while (2)
        {
          unsigned int v345 = *v50;
          if (*v50)
          {
            if (!v41) {
              goto LABEL_487;
            }
            unsigned int v346 = *v71 * v345 + ((*v71 * v345) >> 8) + 1;
            if (BYTE1(v346))
            {
              unsigned int v345 = v346 >> 8;
LABEL_487:
              float v347 = (float)v345 * 0.0039216;
              float v348 = *v343 * v347;
              if (v348 > 0.0)
              {
                float v349 = *(v343 - 1) * v347;
                float v350 = 1.0;
                if (v55 && (float v350 = *v27, *v27 <= 0.0))
                {
LABEL_497:
                  *uint64_t v32 = v349;
                  *uint64_t v27 = v348;
                }
                else
                {
                  float v351 = *v32 - (float)(v348 * *v32);
                  if (v348 == 1.0) {
                    float v351 = 0.0;
                  }
                  float v352 = (float)(v349 + v351) - (float)(v349 * v350);
                  if (v350 == 1.0)
                  {
                    float v353 = v351;
                  }
                  else
                  {
                    float v349 = v349 * v350;
                    float v353 = v352;
                  }
                  float v349 = v349 + v353;
                  if (v55)
                  {
                    float v348 = (float)(v348 + v350) - (float)(v348 * v350);
                    goto LABEL_497;
                  }
                  *uint64_t v32 = v349;
                }
              }
            }
          }
          ++v50;
          v71 += v41 != 0;
          ++v32;
          v343 += 2;
          uint64_t v27 = (float *)((char *)v27 + v47);
          if (!--v344)
          {
LABEL_500:
            int v41 = &v71[v403];
            goto LABEL_501;
          }
          continue;
        }
      }
      int v391 = shape_enum_clip_scan((uint64_t)v409, (_DWORD *)v41 - 4);
      int v44 = (int)v410;
      if (!v391) {
        goto LABEL_596;
      }
    }
    v42 -= v390;
    if (v42 < 1) {
      break;
    }
    v30 += v37[16] * v390;
    v401 += v37[17] * v390;
    v32 += v393 * v390;
    uint64_t v392 = v388 * v390;
    if (!v407) {
      uint64_t v392 = 0;
    }
    v27 += v392;
    int v44 = v389;
  }
LABEL_596:
  if (v409) {
    free(v409);
  }
LABEL_598:
  if (v394) {
    free(v394);
  }
}

uint64_t Wf_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  unint64_t v7 = (float *)*((void *)a2 + 2);
  uint64_t v8 = (float *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v119 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v119 = 0;
  }
  float v9 = *((float *)a2 + 2);
  int v10 = a2[1];
  int v118 = *a2;
  uint64_t v117 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v116 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v116 * a4;
  size_t v15 = *(unsigned int **)(a1 + 32);
  uint64_t v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 4 * (v8 != 0);
  if (v17)
  {
    uint64_t v115 = *((void *)a2 + 13);
    uint64_t v114 = *((void *)a2 + 15);
    char v19 = 32 - v10;
    float v20 = v9 * 0.3;
    float v21 = v9 * 0.59;
    float v22 = v9 * 0.11;
    uint64_t v113 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v114 - v14) | (v14 - v115)) < 0)
      {
        int v25 = 0;
        uint64_t v24 = 0;
      }
      else
      {
        unint64_t v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        uint64_t v24 = v23 - 7 >= 9 ? -v12 : v12;
        int v25 = weights_21383[v23] & 0xF;
      }
      unint64_t v26 = (char *)v15 + (v14 >> v13) * v12;
      if (v118 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v27 = (uint64_t *)v113;
        uint64_t v28 = a5;
        while (1)
        {
          uint64_t v29 = *(v27 - 1);
          uint64_t v30 = *v27;
          uint64_t v31 = &v26[v29];
          if (v16 >= (unsigned int *)&v26[v29]) {
            uint64_t v32 = (unsigned int *)&v26[v29];
          }
          else {
            uint64_t v32 = v16;
          }
          if (v15 > v32) {
            uint64_t v32 = v15;
          }
          unsigned int v33 = *v32;
          char v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0) {
            break;
          }
          if (v25)
          {
            uint64_t v45 = (unsigned int *)&v31[v24];
            if (v16 < (unsigned int *)&v31[v24]) {
              uint64_t v45 = v16;
            }
            if (v15 > v45) {
              uint64_t v45 = v15;
            }
            unsigned int v46 = BLEND8_21385[v25];
            unsigned int v43 = v33 - ((v46 & v33) >> v25);
            unsigned int v44 = (v46 & *v45) >> v25;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v47 = __ROL4__(v33, v10);
          float v48 = *(float *)&_blt_float[HIBYTE(v47)];
          float v49 = *(float *)&_blt_float[BYTE2(v47)];
          float v50 = *(float *)&_blt_float[BYTE1(v47)];
          float v51 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
          if (v9 >= 1.0)
          {
            float v52 = v48 * 0.3;
            float v53 = v49 * 0.59;
            float v54 = v50 * 0.11;
          }
          else
          {
            float v52 = v20 * v48;
            float v53 = v21 * v49;
            float v54 = v22 * v50;
            float v51 = v9 * v51;
          }
          *unint64_t v7 = (float)(v52 + v53) + v54;
          if (v8) {
            *uint64_t v8 = v51;
          }
          v27 += 2;
          ++v7;
          uint64_t v8 = (float *)((char *)v8 + result);
          if (!--v28) {
            goto LABEL_99;
          }
        }
        int v35 = (unsigned int *)&v31[v30 >> 4];
        if (v16 < v35) {
          int v35 = v16;
        }
        if (v15 > v35) {
          int v35 = v15;
        }
        unsigned int v36 = *v35;
        if (v25)
        {
          unint64_t v37 = (unsigned int *)&v31[v24];
          if (v16 >= v37) {
            uint64_t v38 = v37;
          }
          else {
            uint64_t v38 = v16;
          }
          if (v15 > v38) {
            uint64_t v38 = v15;
          }
          unsigned int v39 = *v38;
          uint64_t v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v16 < v40) {
            uint64_t v40 = v16;
          }
          if (v15 > v40) {
            uint64_t v40 = v15;
          }
          unsigned int v41 = BLEND8_21385[v25];
          unsigned int v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          unsigned int v36 = v36 - ((v41 & v36) >> v25) + ((v41 & *v40) >> v25);
        }
        int v42 = BLEND8_21385[*v27 & 0xF];
        unsigned int v43 = v33 - ((v42 & v33) >> v34);
        unsigned int v44 = (v42 & v36) >> v34;
LABEL_46:
        unsigned int v33 = v43 + v44;
        goto LABEL_47;
      }
LABEL_99:
      v7 += v117;
      v14 += v116;
      v8 += v119;
      if (!--a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_99;
    }
    uint64_t v56 = (uint64_t *)v113;
    uint64_t v55 = a5;
    while (1)
    {
      uint64_t v57 = *(v56 - 1);
      uint64_t v58 = *v56;
      BOOL v59 = &v26[v57];
      if (v16 >= (unsigned int *)&v26[v57]) {
        uint64_t v60 = (unsigned int *)&v26[v57];
      }
      else {
        uint64_t v60 = v16;
      }
      if (v15 > v60) {
        uint64_t v60 = v15;
      }
      unsigned int v61 = *v60;
      char v62 = v58 & 0xF;
      if ((v58 & 0xF) != 0)
      {
        unint64_t v63 = (unsigned int *)&v59[v58 >> 4];
        if (v16 < v63) {
          unint64_t v63 = v16;
        }
        if (v15 > v63) {
          unint64_t v63 = v15;
        }
        unsigned int v64 = *v63;
        if (v25)
        {
          if (v16 >= (unsigned int *)&v59[v24]) {
            uint64_t v65 = (unsigned int *)&v59[v24];
          }
          else {
            uint64_t v65 = v16;
          }
          if (v15 > v65) {
            uint64_t v65 = v15;
          }
          unsigned int v66 = *v65;
          unint64_t v67 = (unsigned int *)&v59[v24 + (v58 >> 4)];
          if (v16 < v67) {
            unint64_t v67 = v16;
          }
          if (v15 > v67) {
            unint64_t v67 = v15;
          }
          unsigned int v68 = BLEND8_21385[v25];
          unsigned int v61 = v61 - ((v68 & v61) >> v25) + ((v68 & v66) >> v25);
          unsigned int v64 = v64 - ((v68 & v64) >> v25) + ((v68 & *v67) >> v25);
        }
        int v69 = BLEND8_21385[*v56 & 0xF];
        unsigned int v70 = v61 - ((v69 & v61) >> v62);
        unsigned int v71 = (v69 & v64) >> v62;
      }
      else
      {
        if (!v25) {
          goto LABEL_85;
        }
        unsigned int v72 = (unsigned int *)&v59[v24];
        if (v16 < (unsigned int *)&v59[v24]) {
          unsigned int v72 = v16;
        }
        if (v15 > v72) {
          unsigned int v72 = v15;
        }
        unsigned int v73 = BLEND8_21385[v25];
        unsigned int v70 = v61 - ((v73 & v61) >> v25);
        unsigned int v71 = (v73 & *v72) >> v25;
      }
      unsigned int v61 = v70 + v71;
LABEL_85:
      unsigned int v74 = __ROL4__(v61, v10);
      float v75 = *(float *)&_blt_float[HIBYTE(v74)];
      float v76 = *(float *)&_blt_float[BYTE2(v74)];
      float v77 = *(float *)&_blt_float[BYTE1(v74)];
      float v78 = *(float *)&_blt_float[(((_BYTE)v61 << v10) | (v61 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        float v79 = v75 * 0.3;
        float v80 = v76 * 0.59;
        float v81 = v77 * 0.11;
      }
      else
      {
        float v79 = v20 * v75;
        float v80 = v21 * v76;
        float v81 = v22 * v77;
        float v78 = v9 * v78;
      }
      float v82 = (float)(v79 + v80) + v81;
      if (!v8)
      {
        if (v78 < 1.0)
        {
          if (v78 > 0.0) {
            *unint64_t v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
          }
        }
        else
        {
          *unint64_t v7 = v82;
        }
        goto LABEL_98;
      }
      if (v78 >= 1.0)
      {
        *unint64_t v7 = v82;
LABEL_97:
        *uint64_t v8 = v78;
        goto LABEL_98;
      }
      if (v78 > 0.0)
      {
        *unint64_t v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
        float v78 = v78 + (float)(*v8 * (float)(1.0 - v78));
        goto LABEL_97;
      }
LABEL_98:
      v56 += 2;
      ++v7;
      uint64_t v8 = (float *)((char *)v8 + result);
      if (!--v55) {
        goto LABEL_99;
      }
    }
  }
  unsigned int v83 = (uint64_t *)(v11 + 16 * a3);
  float v84 = v9 * 0.3;
  float v85 = v9 * 0.59;
  float v86 = v9 * 0.11;
  do
  {
    unsigned __int8 v87 = (char *)v15 + (v14 >> v13) * v12;
    if (v118 != 1)
    {
      float v100 = v83;
      uint64_t v101 = a5;
      if (a5 < 1) {
        goto LABEL_135;
      }
      while (1)
      {
        uint64_t v102 = *v100;
        v100 += 2;
        float v103 = (unsigned int *)&v87[v102];
        if (v16 < (unsigned int *)&v87[v102]) {
          float v103 = v16;
        }
        if (v15 > v103) {
          float v103 = v15;
        }
        unsigned int v104 = __ROL4__(*v103, v10);
        float v105 = *(float *)&_blt_float[HIBYTE(v104)];
        float v106 = *(float *)&_blt_float[BYTE2(v104)];
        float v107 = *(float *)&_blt_float[BYTE1(v104)];
        float v108 = *(float *)&_blt_float[v104 | v6];
        if (v9 >= 1.0)
        {
          float v109 = v105 * 0.3;
          float v110 = v106 * 0.59;
          float v111 = v107 * 0.11;
        }
        else
        {
          float v109 = v84 * v105;
          float v110 = v85 * v106;
          float v111 = v86 * v107;
          float v108 = v9 * v108;
        }
        float v112 = (float)(v109 + v110) + v111;
        if (!v8)
        {
          if (v108 < 1.0)
          {
            if (v108 > 0.0) {
              *unint64_t v7 = v112 + (float)(*v7 * (float)(1.0 - v108));
            }
          }
          else
          {
            *unint64_t v7 = v112;
          }
          goto LABEL_134;
        }
        if (v108 >= 1.0) {
          break;
        }
        if (v108 > 0.0)
        {
          *unint64_t v7 = v112 + (float)(*v7 * (float)(1.0 - v108));
          float v108 = v108 + (float)(*v8 * (float)(1.0 - v108));
          goto LABEL_133;
        }
LABEL_134:
        ++v7;
        uint64_t v8 = (float *)((char *)v8 + result);
        if (!--v101) {
          goto LABEL_135;
        }
      }
      *unint64_t v7 = v112;
LABEL_133:
      *uint64_t v8 = v108;
      goto LABEL_134;
    }
    if (a5 >= 1)
    {
      uint64_t v88 = v83;
      uint64_t v89 = a5;
      do
      {
        uint64_t v90 = *v88;
        v88 += 2;
        int v91 = (unsigned int *)&v87[v90];
        if (v16 < (unsigned int *)&v87[v90]) {
          int v91 = v16;
        }
        if (v15 > v91) {
          int v91 = v15;
        }
        unsigned int v92 = __ROL4__(*v91, v10);
        float v93 = *(float *)&_blt_float[HIBYTE(v92)];
        float v94 = *(float *)&_blt_float[BYTE2(v92)];
        float v95 = *(float *)&_blt_float[BYTE1(v92)];
        float v96 = *(float *)&_blt_float[v92 | v6];
        if (v9 >= 1.0)
        {
          float v97 = v93 * 0.3;
          float v98 = v94 * 0.59;
          float v99 = v95 * 0.11;
        }
        else
        {
          float v97 = v84 * v93;
          float v98 = v85 * v94;
          float v99 = v86 * v95;
          float v96 = v9 * v96;
        }
        *unint64_t v7 = (float)(v97 + v98) + v99;
        if (v8) {
          *uint64_t v8 = v96;
        }
        ++v7;
        uint64_t v8 = (float *)((char *)v8 + result);
        --v89;
      }
      while (v89);
    }
LABEL_135:
    v7 += v117;
    v14 += v116;
    v8 += v119;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t Wf_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  unint64_t v7 = (float *)*((void *)a2 + 2);
  uint64_t v8 = (float *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v118 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v118 = 0;
  }
  float v9 = *((float *)a2 + 2);
  int v10 = a2[1];
  int v117 = *a2;
  uint64_t v116 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 17);
  uint64_t v12 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v115 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v115 * a4;
  size_t v15 = *(unsigned int **)(a1 + 32);
  uint64_t v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 4 * (v8 != 0);
  if (v17)
  {
    uint64_t v114 = *((void *)a2 + 13);
    uint64_t v113 = *((void *)a2 + 15);
    char v19 = 32 - v10;
    float v20 = v9 * 0.3;
    float v21 = v9 * 0.59;
    float v22 = v9 * 0.11;
    uint64_t v112 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v113 - v14) | (v14 - v114)) < 0)
      {
        int v25 = 0;
        uint64_t v24 = 0;
      }
      else
      {
        unint64_t v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        uint64_t v24 = v23 - 7 >= 9 ? -v11 : v11;
        int v25 = weights_21383[v23] & 0xF;
      }
      unint64_t v26 = (char *)v15 + (v14 >> v13) * v11;
      if (v117 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v27 = (uint64_t *)v112;
        uint64_t v28 = a5;
        while (1)
        {
          uint64_t v29 = *(v27 - 1);
          uint64_t v30 = *v27;
          uint64_t v31 = &v26[v29];
          if (v16 >= (unsigned int *)&v26[v29]) {
            uint64_t v32 = (unsigned int *)&v26[v29];
          }
          else {
            uint64_t v32 = v16;
          }
          if (v15 > v32) {
            uint64_t v32 = v15;
          }
          unsigned int v33 = bswap32(*v32);
          char v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0) {
            break;
          }
          if (v25)
          {
            uint64_t v45 = (unsigned int *)&v31[v24];
            if (v16 < (unsigned int *)&v31[v24]) {
              uint64_t v45 = v16;
            }
            if (v15 > v45) {
              uint64_t v45 = v15;
            }
            int v46 = BLEND8_21385[v25];
            unsigned int v43 = v33 - ((v46 & v33) >> v25);
            unsigned int v44 = (bswap32(*v45) & v46) >> v25;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v47 = __ROL4__(v33, v10);
          float v48 = *(float *)&_blt_float[HIBYTE(v47)];
          float v49 = *(float *)&_blt_float[BYTE2(v47)];
          float v50 = *(float *)&_blt_float[BYTE1(v47)];
          float v51 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
          if (v9 >= 1.0)
          {
            float v52 = v48 * 0.3;
            float v53 = v49 * 0.59;
            float v54 = v50 * 0.11;
          }
          else
          {
            float v52 = v20 * v48;
            float v53 = v21 * v49;
            float v54 = v22 * v50;
            float v51 = v9 * v51;
          }
          *unint64_t v7 = (float)(v52 + v53) + v54;
          if (v8) {
            *uint64_t v8 = v51;
          }
          v27 += 2;
          ++v7;
          uint64_t v8 = (float *)((char *)v8 + result);
          if (!--v28) {
            goto LABEL_99;
          }
        }
        int v35 = (unsigned int *)&v31[v30 >> 4];
        if (v16 < v35) {
          int v35 = v16;
        }
        if (v15 > v35) {
          int v35 = v15;
        }
        unsigned int v36 = bswap32(*v35);
        if (v25)
        {
          unint64_t v37 = (unsigned int *)&v31[v24];
          if (v16 >= v37) {
            uint64_t v38 = v37;
          }
          else {
            uint64_t v38 = v16;
          }
          if (v15 > v38) {
            uint64_t v38 = v15;
          }
          unsigned int v39 = bswap32(*v38);
          uint64_t v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v16 < v40) {
            uint64_t v40 = v16;
          }
          if (v15 > v40) {
            uint64_t v40 = v15;
          }
          int v41 = BLEND8_21385[v25];
          unsigned int v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          unsigned int v36 = v36 - ((v41 & v36) >> v25) + ((bswap32(*v40) & v41) >> v25);
        }
        int v42 = BLEND8_21385[*v27 & 0xF];
        unsigned int v43 = v33 - ((v42 & v33) >> v34);
        unsigned int v44 = (v42 & v36) >> v34;
LABEL_46:
        unsigned int v33 = v43 + v44;
        goto LABEL_47;
      }
LABEL_99:
      v7 += v116;
      v14 += v115;
      v8 += v118;
      if (!--a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_99;
    }
    uint64_t v56 = (uint64_t *)v112;
    uint64_t v55 = a5;
    while (1)
    {
      uint64_t v57 = *(v56 - 1);
      uint64_t v58 = *v56;
      BOOL v59 = &v26[v57];
      if (v16 >= (unsigned int *)&v26[v57]) {
        uint64_t v60 = (unsigned int *)&v26[v57];
      }
      else {
        uint64_t v60 = v16;
      }
      if (v15 > v60) {
        uint64_t v60 = v15;
      }
      unsigned int v61 = bswap32(*v60);
      char v62 = v58 & 0xF;
      if ((v58 & 0xF) != 0)
      {
        unint64_t v63 = (unsigned int *)&v59[v58 >> 4];
        if (v16 < v63) {
          unint64_t v63 = v16;
        }
        if (v15 > v63) {
          unint64_t v63 = v15;
        }
        unsigned int v64 = bswap32(*v63);
        if (v25)
        {
          if (v16 >= (unsigned int *)&v59[v24]) {
            uint64_t v65 = (unsigned int *)&v59[v24];
          }
          else {
            uint64_t v65 = v16;
          }
          if (v15 > v65) {
            uint64_t v65 = v15;
          }
          unsigned int v66 = bswap32(*v65);
          unint64_t v67 = (unsigned int *)&v59[v24 + (v58 >> 4)];
          if (v16 < v67) {
            unint64_t v67 = v16;
          }
          if (v15 > v67) {
            unint64_t v67 = v15;
          }
          int v68 = BLEND8_21385[v25];
          unsigned int v61 = v61 - ((v68 & v61) >> v25) + ((v68 & v66) >> v25);
          unsigned int v64 = v64 - ((v68 & v64) >> v25) + ((bswap32(*v67) & v68) >> v25);
        }
        int v69 = BLEND8_21385[*v56 & 0xF];
        unsigned int v70 = v61 - ((v69 & v61) >> v62);
        unsigned int v71 = (v69 & v64) >> v62;
      }
      else
      {
        if (!v25) {
          goto LABEL_85;
        }
        unsigned int v72 = (unsigned int *)&v59[v24];
        if (v16 < (unsigned int *)&v59[v24]) {
          unsigned int v72 = v16;
        }
        if (v15 > v72) {
          unsigned int v72 = v15;
        }
        int v73 = BLEND8_21385[v25];
        unsigned int v70 = v61 - ((v73 & v61) >> v25);
        unsigned int v71 = (bswap32(*v72) & v73) >> v25;
      }
      unsigned int v61 = v70 + v71;
LABEL_85:
      unsigned int v74 = __ROL4__(v61, v10);
      float v75 = *(float *)&_blt_float[HIBYTE(v74)];
      float v76 = *(float *)&_blt_float[BYTE2(v74)];
      float v77 = *(float *)&_blt_float[BYTE1(v74)];
      float v78 = *(float *)&_blt_float[(((_BYTE)v61 << v10) | (v61 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        float v79 = v75 * 0.3;
        float v80 = v76 * 0.59;
        float v81 = v77 * 0.11;
      }
      else
      {
        float v79 = v20 * v75;
        float v80 = v21 * v76;
        float v81 = v22 * v77;
        float v78 = v9 * v78;
      }
      float v82 = (float)(v79 + v80) + v81;
      if (!v8)
      {
        if (v78 < 1.0)
        {
          if (v78 > 0.0) {
            *unint64_t v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
          }
        }
        else
        {
          *unint64_t v7 = v82;
        }
        goto LABEL_98;
      }
      if (v78 >= 1.0)
      {
        *unint64_t v7 = v82;
LABEL_97:
        *uint64_t v8 = v78;
        goto LABEL_98;
      }
      if (v78 > 0.0)
      {
        *unint64_t v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
        float v78 = v78 + (float)(*v8 * (float)(1.0 - v78));
        goto LABEL_97;
      }
LABEL_98:
      v56 += 2;
      ++v7;
      uint64_t v8 = (float *)((char *)v8 + result);
      if (!--v55) {
        goto LABEL_99;
      }
    }
  }
  float v83 = v9 * 0.3;
  float v84 = v9 * 0.59;
  float v85 = v9 * 0.11;
  do
  {
    float v86 = (char *)v15 + (v14 >> v13) * v11;
    if (v117 != 1)
    {
      float v99 = (uint64_t *)(v12 + 16 * a3);
      uint64_t v100 = a5;
      if (a5 < 1) {
        goto LABEL_135;
      }
      while (1)
      {
        uint64_t v101 = *v99;
        v99 += 2;
        uint64_t v102 = (unsigned int *)&v86[v101];
        if (v16 < (unsigned int *)&v86[v101]) {
          uint64_t v102 = v16;
        }
        if (v15 > v102) {
          uint64_t v102 = v15;
        }
        unsigned int v103 = __ROL4__(bswap32(*v102), v10);
        float v104 = *(float *)&_blt_float[HIBYTE(v103)];
        float v105 = *(float *)&_blt_float[BYTE2(v103)];
        float v106 = *(float *)&_blt_float[BYTE1(v103)];
        float v107 = *(float *)&_blt_float[v103 | v6];
        if (v9 >= 1.0)
        {
          float v108 = v104 * 0.3;
          float v109 = v105 * 0.59;
          float v110 = v106 * 0.11;
        }
        else
        {
          float v108 = v83 * v104;
          float v109 = v84 * v105;
          float v110 = v85 * v106;
          float v107 = v9 * v107;
        }
        float v111 = (float)(v108 + v109) + v110;
        if (!v8)
        {
          if (v107 < 1.0)
          {
            if (v107 > 0.0) {
              *unint64_t v7 = v111 + (float)(*v7 * (float)(1.0 - v107));
            }
          }
          else
          {
            *unint64_t v7 = v111;
          }
          goto LABEL_134;
        }
        if (v107 >= 1.0) {
          break;
        }
        if (v107 > 0.0)
        {
          *unint64_t v7 = v111 + (float)(*v7 * (float)(1.0 - v107));
          float v107 = v107 + (float)(*v8 * (float)(1.0 - v107));
          goto LABEL_133;
        }
LABEL_134:
        ++v7;
        uint64_t v8 = (float *)((char *)v8 + result);
        if (!--v100) {
          goto LABEL_135;
        }
      }
      *unint64_t v7 = v111;
LABEL_133:
      *uint64_t v8 = v107;
      goto LABEL_134;
    }
    if (a5 >= 1)
    {
      unsigned __int8 v87 = (uint64_t *)(v12 + 16 * a3);
      uint64_t v88 = a5;
      do
      {
        uint64_t v89 = *v87;
        v87 += 2;
        uint64_t v90 = (unsigned int *)&v86[v89];
        if (v16 < (unsigned int *)&v86[v89]) {
          uint64_t v90 = v16;
        }
        if (v15 > v90) {
          uint64_t v90 = v15;
        }
        unsigned int v91 = __ROL4__(bswap32(*v90), v10);
        float v92 = *(float *)&_blt_float[HIBYTE(v91)];
        float v93 = *(float *)&_blt_float[BYTE2(v91)];
        float v94 = *(float *)&_blt_float[BYTE1(v91)];
        float v95 = *(float *)&_blt_float[v91 | v6];
        if (v9 >= 1.0)
        {
          float v96 = v92 * 0.3;
          float v97 = v93 * 0.59;
          float v98 = v94 * 0.11;
        }
        else
        {
          float v96 = v83 * v92;
          float v97 = v84 * v93;
          float v98 = v85 * v94;
          float v95 = v9 * v95;
        }
        *unint64_t v7 = (float)(v96 + v97) + v98;
        if (v8) {
          *uint64_t v8 = v95;
        }
        ++v7;
        uint64_t v8 = (float *)((char *)v8 + result);
        --v88;
      }
      while (v88);
    }
LABEL_135:
    v7 += v116;
    v14 += v115;
    v8 += v118;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t Wf_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (float *)*((void *)a2 + 2);
  unint64_t v7 = (float *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v91 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v91 = 0;
  }
  float v8 = *((float *)a2 + 2);
  int v90 = *a2;
  uint64_t v9 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 17);
  uint64_t v10 = *((void *)a2 + 18);
  uint64_t v12 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v13 * a4;
  size_t v15 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 4 * (v7 != 0);
  if (v17)
  {
    uint64_t v88 = *((void *)a2 + 15);
    uint64_t v89 = *((void *)a2 + 13);
    float v19 = v8 * 0.3;
    float v20 = v8 * 0.59;
    float v21 = v8 * 0.11;
    uint64_t v87 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v88 - v14) | (v14 - v89)) < 0)
      {
        int v24 = 0;
        uint64_t v23 = 0;
      }
      else
      {
        unint64_t v22 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v22 - 7 >= 9) {
          uint64_t v23 = -v11;
        }
        else {
          uint64_t v23 = v11;
        }
        int v24 = weights_21383[v22] & 0xF;
      }
      int v25 = &v15[(v14 >> v12) * v11];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          unint64_t v26 = (uint64_t *)v87;
          uint64_t v27 = a5;
          do
          {
            uint64_t v28 = *(v26 - 1);
            uint64_t v29 = *v26;
            uint64_t v30 = &v25[v28];
            if (v16 >= &v25[v28]) {
              uint64_t v31 = &v25[v28];
            }
            else {
              uint64_t v31 = v16;
            }
            if (v15 > v31) {
              uint64_t v31 = v15;
            }
            unsigned int v32 = (*v31 << 24) | (v31[1] << 16) | (v31[2] << 8);
            if ((v29 & 0xF) != 0)
            {
              unsigned int v33 = &v30[v29 >> 4];
              if (v16 < v33) {
                unsigned int v33 = v16;
              }
              if (v15 > v33) {
                unsigned int v33 = v15;
              }
              int v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
              if (v24)
              {
                if (v16 >= &v30[v23]) {
                  int v35 = &v30[v23];
                }
                else {
                  int v35 = v16;
                }
                if (v15 > v35) {
                  int v35 = v15;
                }
                int v36 = (*v35 << 24) | (v35[1] << 16) | (v35[2] << 8);
                unint64_t v37 = &v30[v23 + (v29 >> 4)];
                if (v16 < v37) {
                  unint64_t v37 = v16;
                }
                if (v15 > v37) {
                  unint64_t v37 = v15;
                }
                unsigned int v38 = BLEND8_21385[v24];
                unsigned int v32 = v32 - ((v38 & v32) >> v24) + ((v38 & v36) >> v24);
                int v34 = v34 - ((v38 & v34) >> v24) + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v24);
              }
              unsigned int v32 = v32
                  - ((BLEND8_21385[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_21385[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v24)
            {
              unsigned int v39 = &v30[v23];
              if (v16 < &v30[v23]) {
                unsigned int v39 = v16;
              }
              if (v15 > v39) {
                unsigned int v39 = v15;
              }
              unsigned int v32 = v32
                  - ((BLEND8_21385[v24] & v32) >> v24)
                  + ((((*v39 << 24) | (v39[1] << 16) | (v39[2] << 8)) & BLEND8_21385[v24]) >> v24);
            }
            float v40 = *(float *)&_blt_float[HIBYTE(v32)];
            float v41 = *(float *)&_blt_float[BYTE2(v32)];
            float v42 = *(float *)&_blt_float[BYTE1(v32)];
            if (v8 >= 1.0)
            {
              float v43 = (float)((float)(v40 * 0.3) + (float)(v41 * 0.59)) + (float)(v42 * 0.11);
              float v44 = 1.0;
            }
            else
            {
              float v43 = (float)((float)(v19 * v40) + (float)(v20 * v41)) + (float)(v21 * v42);
              float v44 = v8;
            }
            *int v6 = v43;
            if (v7) {
              *unint64_t v7 = v44;
            }
            v26 += 2;
            ++v6;
            unint64_t v7 = (float *)((char *)v7 + result);
            --v27;
          }
          while (v27);
        }
        goto LABEL_93;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_93:
      v6 += v9;
      v14 += v13;
      v7 += v91;
      if (!--a6) {
        return result;
      }
    }
    int v46 = (uint64_t *)v87;
    uint64_t v45 = a5;
    while (1)
    {
      uint64_t v47 = *(v46 - 1);
      uint64_t v48 = *v46;
      float v49 = &v25[v47];
      if (v16 >= &v25[v47]) {
        float v50 = &v25[v47];
      }
      else {
        float v50 = v16;
      }
      if (v15 > v50) {
        float v50 = v15;
      }
      unsigned int v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      if ((v48 & 0xF) != 0)
      {
        float v52 = &v49[v48 >> 4];
        if (v16 < v52) {
          float v52 = v16;
        }
        if (v15 > v52) {
          float v52 = v15;
        }
        int v53 = (*v52 << 24) | (v52[1] << 16) | (v52[2] << 8);
        if (v24)
        {
          if (v16 >= &v49[v23]) {
            float v54 = &v49[v23];
          }
          else {
            float v54 = v16;
          }
          if (v15 > v54) {
            float v54 = v15;
          }
          int v55 = (*v54 << 24) | (v54[1] << 16) | (v54[2] << 8);
          uint64_t v56 = &v49[v23 + (v48 >> 4)];
          if (v16 < v56) {
            uint64_t v56 = v16;
          }
          if (v15 > v56) {
            uint64_t v56 = v15;
          }
          unsigned int v57 = BLEND8_21385[v24];
          unsigned int v51 = v51 - ((v57 & v51) >> v24) + ((v57 & v55) >> v24);
          int v53 = v53 - ((v57 & v53) >> v24) + ((((*v56 << 24) | (v56[1] << 16) | (v56[2] << 8)) & v57) >> v24);
        }
        unsigned int v51 = v51
            - ((BLEND8_21385[*v46 & 0xF] & v51) >> (*v46 & 0xF))
            + ((BLEND8_21385[*v46 & 0xF] & v53) >> (*v46 & 0xF));
      }
      else if (v24)
      {
        uint64_t v58 = &v49[v23];
        if (v16 < &v49[v23]) {
          uint64_t v58 = v16;
        }
        if (v15 > v58) {
          uint64_t v58 = v15;
        }
        unsigned int v51 = v51
            - ((BLEND8_21385[v24] & v51) >> v24)
            + ((((*v58 << 24) | (v58[1] << 16) | (v58[2] << 8)) & BLEND8_21385[v24]) >> v24);
      }
      float v59 = *(float *)&_blt_float[HIBYTE(v51)];
      float v60 = *(float *)&_blt_float[BYTE2(v51)];
      float v61 = *(float *)&_blt_float[BYTE1(v51)];
      if (v8 >= 1.0)
      {
        float v62 = (float)((float)(v59 * 0.3) + (float)(v60 * 0.59)) + (float)(v61 * 0.11);
        float v63 = 1.0;
      }
      else
      {
        float v62 = (float)((float)(v19 * v59) + (float)(v20 * v60)) + (float)(v21 * v61);
        float v63 = v8;
      }
      if (v7)
      {
        if (v63 < 1.0)
        {
          if (v63 > 0.0)
          {
            *int v6 = v62 + (float)(*v6 * (float)(1.0 - v63));
            *unint64_t v7 = v63 + (float)(*v7 * (float)(1.0 - v63));
          }
        }
        else
        {
          *int v6 = v62;
          *unint64_t v7 = v63;
        }
        goto LABEL_92;
      }
      if (v63 >= 1.0) {
        goto LABEL_91;
      }
      if (v63 > 0.0) {
        break;
      }
LABEL_92:
      v46 += 2;
      ++v6;
      unint64_t v7 = (float *)((char *)v7 + result);
      if (!--v45) {
        goto LABEL_93;
      }
    }
    float v62 = v62 + (float)(*v6 * (float)(1.0 - v63));
LABEL_91:
    *int v6 = v62;
    goto LABEL_92;
  }
  unsigned int v64 = (uint64_t *)(v10 + 16 * a3);
  float v65 = v8 * 0.3;
  float v66 = v8 * 0.59;
  float v67 = v8 * 0.11;
  do
  {
    int v68 = &v15[(v14 >> v12) * v11];
    if (v90 != 1)
    {
      float v78 = v64;
      uint64_t v79 = a5;
      if (a5 < 1) {
        goto LABEL_128;
      }
      while (1)
      {
        uint64_t v80 = *v78;
        v78 += 2;
        float v81 = &v68[v80];
        if (v16 < &v68[v80]) {
          float v81 = v16;
        }
        if (v15 > v81) {
          float v81 = v15;
        }
        float v82 = *(float *)&_blt_float[*v81];
        float v83 = *(float *)&_blt_float[v81[1]];
        float v84 = *(float *)&_blt_float[v81[2]];
        if (v8 >= 1.0)
        {
          float v85 = (float)((float)(v82 * 0.3) + (float)(v83 * 0.59)) + (float)(v84 * 0.11);
          float v86 = 1.0;
        }
        else
        {
          float v85 = (float)((float)(v65 * v82) + (float)(v66 * v83)) + (float)(v67 * v84);
          float v86 = v8;
        }
        if (v7)
        {
          if (v86 < 1.0)
          {
            if (v86 > 0.0)
            {
              *int v6 = v85 + (float)(*v6 * (float)(1.0 - v86));
              *unint64_t v7 = v86 + (float)(*v7 * (float)(1.0 - v86));
            }
          }
          else
          {
            *int v6 = v85;
            *unint64_t v7 = v86;
          }
          goto LABEL_127;
        }
        if (v86 >= 1.0) {
          goto LABEL_126;
        }
        if (v86 > 0.0) {
          break;
        }
LABEL_127:
        ++v6;
        unint64_t v7 = (float *)((char *)v7 + result);
        if (!--v79) {
          goto LABEL_128;
        }
      }
      float v85 = v85 + (float)(*v6 * (float)(1.0 - v86));
LABEL_126:
      *int v6 = v85;
      goto LABEL_127;
    }
    if (a5 >= 1)
    {
      int v69 = v64;
      uint64_t v70 = a5;
      do
      {
        uint64_t v71 = *v69;
        v69 += 2;
        unsigned int v72 = &v68[v71];
        if (v16 < &v68[v71]) {
          unsigned int v72 = v16;
        }
        if (v15 > v72) {
          unsigned int v72 = v15;
        }
        float v73 = *(float *)&_blt_float[*v72];
        float v74 = *(float *)&_blt_float[v72[1]];
        float v75 = *(float *)&_blt_float[v72[2]];
        if (v8 >= 1.0)
        {
          float v76 = (float)((float)(v73 * 0.3) + (float)(v74 * 0.59)) + (float)(v75 * 0.11);
          float v77 = 1.0;
        }
        else
        {
          float v76 = (float)((float)(v65 * v73) + (float)(v66 * v74)) + (float)(v67 * v75);
          float v77 = v8;
        }
        *int v6 = v76;
        if (v7) {
          *unint64_t v7 = v77;
        }
        ++v6;
        unint64_t v7 = (float *)((char *)v7 + result);
        --v70;
      }
      while (v70);
    }
LABEL_128:
    v6 += v9;
    v14 += v13;
    v7 += v91;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t Wf_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (float *)*((void *)a2 + 2);
  unint64_t v7 = (float *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v70 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v70 = 0;
  }
  float v8 = *((float *)a2 + 2);
  int v9 = *a2;
  uint64_t v10 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 17);
  uint64_t v12 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v14 = *((void *)a2 + 11);
  uint64_t v15 = *((void *)a2 + 7) + v14 * a4;
  uint64_t v16 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v17 = &v16[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v18 = 4 * (v7 != 0);
  if (*(void *)(a1 + 176))
  {
    uint64_t v69 = *((void *)a2 + 13);
    uint64_t v68 = *((void *)a2 + 15);
    float v19 = fminf(v8, 1.0);
    float v20 = 1.0 - v19;
    uint64_t v67 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v68 - v15) | (v15 - v69)) < 0)
      {
        uint64_t v22 = 0;
        unsigned int v23 = 0;
      }
      else
      {
        unint64_t v21 = ((v15 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        if (v21 - 7 >= 9) {
          uint64_t v22 = -v11;
        }
        else {
          uint64_t v22 = v11;
        }
        unsigned int v23 = weights_21383[v21] & 0xF;
      }
      uint64_t result = v15 >> v13;
      int v25 = &v16[(v15 >> v13) * v11];
      if (v9 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t result = v23;
          unint64_t v26 = (uint64_t *)v67;
          uint64_t v27 = a5;
          do
          {
            uint64_t v28 = *(v26 - 1);
            uint64_t v29 = *v26;
            uint64_t v30 = &v25[v28];
            if (v17 >= &v25[v28]) {
              uint64_t v31 = &v25[v28];
            }
            else {
              uint64_t v31 = v17;
            }
            if (v16 > v31) {
              uint64_t v31 = v16;
            }
            unsigned int v32 = *v31;
            if ((v29 & 0xF) != 0)
            {
              unsigned int v33 = &v30[v29 >> 4];
              if (v17 < v33) {
                unsigned int v33 = v17;
              }
              if (v16 > v33) {
                unsigned int v33 = v16;
              }
              unsigned int v34 = *v33;
              if (v23)
              {
                int v35 = &v30[v22];
                if (v17 >= v35) {
                  int v36 = v35;
                }
                else {
                  int v36 = v17;
                }
                if (v16 > v36) {
                  int v36 = v16;
                }
                unsigned int v37 = *v36;
                unsigned int v38 = &v35[v29 >> 4];
                if (v17 < v38) {
                  unsigned int v38 = v17;
                }
                if (v16 > v38) {
                  unsigned int v38 = v16;
                }
                int v39 = BLEND8_21385[v23];
                unsigned int v32 = v32 - ((v39 & v32) >> v23) + ((v39 & v37) >> v23);
                unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
              }
              unsigned int v32 = v32
                  - ((BLEND8_21385[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_21385[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v23)
            {
              float v40 = &v30[v22];
              if (v17 < &v30[v22]) {
                float v40 = v17;
              }
              if (v16 > v40) {
                float v40 = v16;
              }
              unsigned int v32 = v32 - ((BLEND8_21385[v23] & v32) >> v23) + ((BLEND8_21385[v23] & *v40) >> v23);
            }
            *int v6 = *(float *)&_blt_float[v32] * v19;
            if (v7) {
              *unint64_t v7 = v19;
            }
            v26 += 2;
            ++v6;
            unint64_t v7 = (float *)((char *)v7 + v18);
            --v27;
          }
          while (v27);
        }
        goto LABEL_87;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_87:
      v6 += v10;
      v15 += v14;
      v7 += v70;
      if (!--a6) {
        return result;
      }
    }
    float v41 = (uint64_t *)v67;
    uint64_t result = a5;
    while (1)
    {
      uint64_t v42 = *(v41 - 1);
      uint64_t v43 = *v41;
      float v44 = &v25[v42];
      if (v17 >= &v25[v42]) {
        uint64_t v45 = &v25[v42];
      }
      else {
        uint64_t v45 = v17;
      }
      if (v16 > v45) {
        uint64_t v45 = v16;
      }
      unsigned int v46 = *v45;
      if ((v43 & 0xF) != 0)
      {
        uint64_t v47 = &v44[v43 >> 4];
        if (v17 < v47) {
          uint64_t v47 = v17;
        }
        if (v16 > v47) {
          uint64_t v47 = v16;
        }
        unsigned int v48 = *v47;
        if (v23)
        {
          if (v17 >= &v44[v22]) {
            float v49 = &v44[v22];
          }
          else {
            float v49 = v17;
          }
          if (v16 > v49) {
            float v49 = v16;
          }
          unsigned int v50 = *v49;
          unsigned int v51 = &v44[v22 + (v43 >> 4)];
          if (v17 < v51) {
            unsigned int v51 = v17;
          }
          if (v16 > v51) {
            unsigned int v51 = v16;
          }
          int v52 = BLEND8_21385[v23];
          unsigned int v46 = v46 - ((v52 & v46) >> v23) + ((v52 & v50) >> v23);
          unsigned int v48 = v48 - ((v52 & v48) >> v23) + ((v52 & *v51) >> v23);
        }
        unsigned int v46 = v46
            - ((BLEND8_21385[*v41 & 0xF] & v46) >> (*v41 & 0xF))
            + ((BLEND8_21385[*v41 & 0xF] & v48) >> (*v41 & 0xF));
      }
      else if (v23)
      {
        int v53 = &v44[v22];
        if (v17 < &v44[v22]) {
          int v53 = v17;
        }
        if (v16 > v53) {
          int v53 = v16;
        }
        unsigned int v46 = v46 - ((BLEND8_21385[v23] & v46) >> v23) + ((BLEND8_21385[v23] & *v53) >> v23);
      }
      float v54 = *(float *)&_blt_float[v46] * v19;
      if (v7)
      {
        if (v19 < 1.0)
        {
          if (v19 > 0.0)
          {
            *int v6 = v54 + (float)(*v6 * v20);
            *unint64_t v7 = v19 + (float)(*v7 * v20);
          }
        }
        else
        {
          *int v6 = v54;
          *unint64_t v7 = v19;
        }
        goto LABEL_86;
      }
      if (v19 >= 1.0) {
        goto LABEL_85;
      }
      if (v19 > 0.0) {
        break;
      }
LABEL_86:
      v41 += 2;
      ++v6;
      unint64_t v7 = (float *)((char *)v7 + v18);
      if (!--result) {
        goto LABEL_87;
      }
    }
    float v54 = v54 + (float)(*v6 * v20);
LABEL_85:
    *int v6 = v54;
    goto LABEL_86;
  }
  int v55 = (uint64_t *)(v12 + 16 * a3);
  float v56 = fminf(v8, 1.0);
  float v57 = 1.0 - v56;
  do
  {
    uint64_t result = (uint64_t)&v16[(v15 >> v13) * v11];
    if (v9 != 1)
    {
      float v62 = v55;
      uint64_t v63 = a5;
      if (a5 < 1) {
        goto LABEL_116;
      }
      while (1)
      {
        uint64_t v64 = *v62;
        v62 += 2;
        float v65 = (unsigned __int8 *)(result + v64);
        if ((unint64_t)v17 < result + v64) {
          float v65 = v17;
        }
        if (v16 > v65) {
          float v65 = v16;
        }
        float v66 = *(float *)&_blt_float[*v65] * v56;
        if (v7)
        {
          if (v56 < 1.0)
          {
            if (v56 > 0.0)
            {
              *int v6 = v66 + (float)(*v6 * v57);
              *unint64_t v7 = v56 + (float)(*v7 * v57);
            }
          }
          else
          {
            *int v6 = v66;
            *unint64_t v7 = v56;
          }
          goto LABEL_115;
        }
        if (v56 >= 1.0) {
          goto LABEL_114;
        }
        if (v56 > 0.0) {
          break;
        }
LABEL_115:
        ++v6;
        unint64_t v7 = (float *)((char *)v7 + v18);
        if (!--v63) {
          goto LABEL_116;
        }
      }
      float v66 = v66 + (float)(*v6 * v57);
LABEL_114:
      *int v6 = v66;
      goto LABEL_115;
    }
    if (a5 >= 1)
    {
      uint64_t v58 = v55;
      uint64_t v59 = a5;
      do
      {
        uint64_t v60 = *v58;
        v58 += 2;
        float v61 = (unsigned __int8 *)(result + v60);
        if ((unint64_t)v17 < result + v60) {
          float v61 = v17;
        }
        if (v16 > v61) {
          float v61 = v16;
        }
        *int v6 = *(float *)&_blt_float[*v61] * v56;
        if (v7) {
          *unint64_t v7 = v56;
        }
        ++v6;
        unint64_t v7 = (float *)((char *)v7 + v18);
        --v59;
      }
      while (v59);
    }
LABEL_116:
    v6 += v10;
    v15 += v14;
    v7 += v70;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t Wf_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x1000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    uint64_t v12 = Wf_shade_radial_W;
  }
  else if (*(void *)(v5 + 24))
  {
    uint64_t v12 = Wf_shade_conic_W;
  }
  else if (v16 < 2)
  {
    uint64_t v12 = Wf_shade_axial_W;
  }
  else
  {
    uint64_t v12 = Wf_shade_custom_W;
  }
  uint64_t v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  Wf_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

void Wf_shade_axial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  uint64_t v6 = *(float **)(a1 + 272);
  float v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  float v8 = *(float *)(a1 + 336);
  float v9 = *(float *)(a1 + 344);
  float v10 = *(float *)(a1 + 304);
  float v11 = *(float *)(a1 + 308);
  unsigned int v12 = *(_DWORD *)(a1 + 320);
  unsigned int v13 = *(_DWORD *)(a1 + 324);
  uint64_t v16 = a1 + 144;
  int v14 = *(_DWORD **)(a1 + 144);
  int v15 = *(float **)(v16 + 8);
  uint64_t v17 = *(float **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v18 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v18 = v6;
  }
  uint64_t v19 = *(void *)(a1 + 32);
  uint64_t v20 = *(void *)(a1 + 40);
  if (v20) {
    unint64_t v21 = *(float **)(a1 + 40);
  }
  else {
    unint64_t v21 = v6;
  }
  if (v5 != 0.0)
  {
    for (i = v15 + 1; ; i += 2)
    {
      unsigned int v24 = v12;
      if (v7 >= v10)
      {
        unsigned int v24 = v13;
        if (v7 <= v11) {
          unsigned int v24 = (int)(float)(v9 * (float)(v7 - v8));
        }
      }
      if ((v24 & 0x80000000) != 0)
      {
        if (!v17)
        {
          char v29 = 0;
          goto LABEL_31;
        }
        float v26 = *v18;
        float v28 = *v18 * *v17;
      }
      else
      {
        uint64_t v25 = v24;
        if (!v20) {
          uint64_t v25 = 0;
        }
        float v26 = v21[v25];
        if (v20) {
          float v27 = v21[v25];
        }
        else {
          float v27 = 1.0;
        }
        float v28 = *(float *)(v19 + 4 * v24) * v27;
      }
      *(i - 1) = v28;
      float *i = v26;
      char v29 = -1;
LABEL_31:
      float v7 = v5 + v7;
      *(unsigned char *)int v14 = v29;
      int v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v7 >= v10)
  {
    unsigned int v12 = v13;
    if (v7 <= v11) {
      unsigned int v12 = (int)(float)(v9 * (float)(v7 - v8));
    }
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      float v31 = *v18;
      float v33 = *v18 * *v17;
    }
    else
    {
      uint64_t v30 = v12;
      if (!v20) {
        uint64_t v30 = 0;
      }
      float v31 = v21[v30];
      float v32 = 1.0;
      if (v20) {
        float v32 = v21[v30];
      }
      float v33 = *(float *)(v19 + 4 * v12) * v32;
    }
    int v34 = a4 + 4;
    do
    {
      *int v15 = v33;
      v15[1] = v31;
      v15[2] = v33;
      v15[3] = v31;
      v15[4] = v33;
      v15[5] = v31;
      v34 -= 4;
      v15[6] = v33;
      v15[7] = v31;
      v15 += 8;
      *v14++ = -1;
    }
    while (v34 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v22 = 4;
    }
    else {
      int v22 = a4;
    }
    bzero(v14, ((a4 - v22 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t Wf_shade_custom_W(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  uint64_t v6 = *(void *)(result + 272);
  float32x2_t v7 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), *(float *)(v6 + 4) * (float)a3), v7, *(float *)(v6 + 4) * (float)a2));
  float32x4_t v8 = *(float32x4_t *)(result + 304);
  float v9 = *(float *)(result + 336);
  float v10 = *(float *)(result + 348);
  float v11 = *(float *)(result + 344);
  float v12 = *(float *)(result + 356);
  unsigned int v13 = *(char **)(result + 144);
  int v14 = *(float **)(result + 384);
  int v15 = *(float **)(result + 392);
  if (!v15) {
    int v15 = *(float **)(result + 272);
  }
  uint64_t v16 = *(void *)(result + 32);
  uint64_t v17 = *(void *)(result + 40);
  int v18 = *(_DWORD *)(result + 48);
  if (v17) {
    int v19 = *(_DWORD *)(result + 48);
  }
  else {
    int v19 = 0;
  }
  if (v17) {
    uint64_t v6 = *(void *)(result + 40);
  }
  uint64_t v20 = (float *)(*(void *)(result + 152) + 4);
  do
  {
    float32x4_t v21 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v8, v21))), vmovn_s32(vcgtq_f32(v21, v8))), 0xFuLL))) & 1) == 0)
    {
      int v24 = (int)(float)(v12 * (float)(*(float *)&a6.i32[1] - v10));
      uint64_t result = (int)(float)(v11 * (float)(*(float *)a6.i32 - v9));
      uint64_t v25 = v16 + 4 * v18 * v24;
      uint64_t v26 = (int)result;
      uint64_t v27 = v6 + 4 * v19 * v24;
      if (!v17) {
        uint64_t v26 = 0;
      }
      float v22 = *(float *)(v27 + 4 * v26);
      if (v17) {
        float v28 = *(float *)(v27 + 4 * v26);
      }
      else {
        float v28 = 1.0;
      }
      float v23 = *(float *)(v25 + 4 * (int)result) * v28;
      goto LABEL_18;
    }
    if (v14)
    {
      float v22 = *v15;
      float v23 = *v15 * *v14;
LABEL_18:
      *(v20 - 1) = v23;
      *uint64_t v20 = v22;
      char v29 = -1;
      goto LABEL_20;
    }
    char v29 = 0;
LABEL_20:
    *(float32x2_t *)a6.i8 = vadd_f32(v7, *(float32x2_t *)a6.i8);
    *v13++ = v29;
    v20 += 2;
    --a4;
  }
  while (a4);
  return result;
}

void Wf_shade_conic_W(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(void *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(void *)&a1[34] + 4) * (float)a2));
  float v8 = a1[42].f32[0];
  float v9 = a1[43].f32[0];
  float v10 = a1[38].f32[0];
  float v12 = (unsigned char *)a1[18];
  float v11 = (float *)a1[19];
  float32x2_t v13 = a1[4];
  float32x2_t v14 = a1[5];
  if (v14) {
    float32x2_t v15 = a1[5];
  }
  else {
    float32x2_t v15 = a1[34];
  }
  float v16 = a1[38].f32[1] - v10;
  do
  {
    __n128 v33 = a6;
    float v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    float v18 = floorf(v17);
    signed int v19 = vcvtms_s32_f32(v17);
    float v20 = ceilf(v17);
    unsigned int v21 = vcvtms_s32_f32(v9 + v17);
    if (v17 < 0.0) {
      signed int v19 = v21;
    }
    float v22 = ceilf(v17 - v9);
    if (v17 > v9) {
      float v20 = v22;
    }
    int v23 = (int)v20;
    float v24 = (float)(int)v18;
    uint64_t v25 = v19;
    if (!*(void *)&v14) {
      uint64_t v25 = 0;
    }
    float v26 = *(float *)(*(void *)&v15 + 4 * v25);
    uint64_t v27 = v23;
    if (!*(void *)&v14) {
      uint64_t v27 = 0;
    }
    float v28 = v17 - v24;
    if (v14) {
      float v29 = v26;
    }
    else {
      float v29 = 1.0;
    }
    if (v14) {
      float v30 = *(float *)(*(void *)&v15 + 4 * v27);
    }
    else {
      float v30 = 1.0;
    }
    float v31 = *(float *)(*(void *)&v13 + 4 * v19) * v29;
    float v32 = v26 + (float)(v28 * (float)(*(float *)(*(void *)&v15 + 4 * v27) - v26));
    a6.n128_u64[1] = v33.n128_u64[1];
    *float v11 = v31 + (float)(v28 * (float)((float)(*(float *)(*(void *)&v13 + 4 * v23) * v30) - v31));
    v11[1] = v32;
    v11 += 2;
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v33.n128_u64[0]);
    *v12++ = -1;
    --a4;
  }
  while (a4);
}

void Wf_shade_radial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float **)(a1 + 400);
  float v6 = *(float *)(a1 + 280);
  float v7 = *(float *)(a1 + 284);
  float v8 = *(float **)(a1 + 272);
  float v9 = v8[1];
  float v10 = v9 * (float)a2;
  float v11 = v9 * (float)a3;
  float v12 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v11) + (float)(v6 * v10));
  float v13 = *(float *)(a1 + 300) + (float)((float)(v11 * *(float *)(a1 + 292)) + (float)(v7 * v10));
  float v14 = *(float *)(a1 + 336);
  float v15 = *(float *)(a1 + 344);
  float v16 = *(float *)(a1 + 304);
  float v17 = *(float *)(a1 + 308);
  uint64_t v18 = *(unsigned int *)(a1 + 324);
  float v19 = v5[2];
  float v20 = v5[4];
  float v21 = v5[5];
  float v22 = v5[7];
  uint64_t v25 = a1 + 144;
  int v23 = *(char **)(a1 + 144);
  float v24 = *(float **)(v25 + 8);
  float v26 = *(float **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v27 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v27 = v8;
  }
  uint64_t v28 = *(void *)(a1 + 32);
  uint64_t v29 = *(void *)(a1 + 40);
  if (v29) {
    float v8 = *(float **)(a1 + 40);
  }
  if (v19 != 0.0 || v22 != 0.0 || v7 != 0.0)
  {
    unsigned int v33 = *(_DWORD *)(a1 + 320);
    float v34 = v5[3];
    float v35 = v5[8];
    float v36 = -v5[6];
    float v37 = v17 - v16;
    for (i = v24 + 1; ; i += 2)
    {
      float v39 = v36 + (float)((float)(v12 + v12) * v19);
      float v40 = (float)((float)(v13 * v13) + (float)(v12 * v12)) - v22;
      if (v21 == 0.0)
      {
        float v47 = v40 / v39;
      }
      else
      {
        float v41 = (float)((float)(v21 * -4.0) * v40) + (float)(v39 * v39);
        if (v41 < 0.0) {
          goto LABEL_49;
        }
        float v42 = sqrtf(v41);
        float v43 = v35 * (float)(v39 - v42);
        float v44 = v39 + v42;
        float v45 = v35 * v44;
        BOOL v46 = (float)(v35 * v44) <= v43;
        if ((float)(v35 * v44) <= v43) {
          float v47 = v35 * v44;
        }
        else {
          float v47 = v43;
        }
        if (v46) {
          float v45 = v43;
        }
        if (v45 < 0.0)
        {
          BOOL v48 = v45 < v34;
LABEL_30:
          unsigned int v49 = v33;
          if (v48) {
            goto LABEL_49;
          }
LABEL_31:
          if ((v49 & 0x80000000) == 0) {
            goto LABEL_43;
          }
          goto LABEL_49;
        }
        if (v45 <= 1.0)
        {
          float v50 = v16 + (float)(v45 * v37);
          goto LABEL_42;
        }
        if ((v18 & 0x80000000) == 0)
        {
          unsigned int v49 = v18;
          if (v45 <= v20)
          {
LABEL_43:
            uint64_t v51 = v49;
            if (!v29) {
              uint64_t v51 = 0;
            }
            float v52 = v8[v51];
            if (v29) {
              float v53 = v8[v51];
            }
            else {
              float v53 = 1.0;
            }
            float v54 = *(float *)(v28 + 4 * v49) * v53;
            goto LABEL_51;
          }
        }
      }
      if (v47 < 0.0)
      {
        BOOL v48 = v47 < v34;
        goto LABEL_30;
      }
      if (v47 > 1.0)
      {
        unsigned int v49 = v18;
        if (v47 > v20) {
          goto LABEL_49;
        }
        goto LABEL_31;
      }
      float v50 = v16 + (float)(v47 * v37);
LABEL_42:
      unsigned int v49 = (int)(float)(v15 * (float)(v50 - v14));
      if ((v49 & 0x80000000) == 0) {
        goto LABEL_43;
      }
LABEL_49:
      if (!v26)
      {
        char v55 = 0;
        goto LABEL_53;
      }
      float v52 = *v27;
      float v54 = *v27 * *v26;
LABEL_51:
      *(i - 1) = v54;
      float *i = v52;
      char v55 = -1;
LABEL_53:
      float v12 = v6 + v12;
      float v13 = v7 + v13;
      *v23++ = v55;
      if (!--a4) {
        return;
      }
    }
  }
  float v30 = v13 * v13;
  float v31 = -v21;
  if (v30 <= (float)-v21)
  {
    float v56 = fabsf(v5[8]);
    float v57 = v21 * -4.0;
    float v58 = v17 - v16;
    if (v29) {
      uint64_t v59 = v18;
    }
    else {
      uint64_t v59 = 0;
    }
    int v60 = a4 + 2;
    while (1)
    {
      float v61 = v30 + (float)(v12 * v12);
      float v62 = v6 + v12;
      float v63 = v30 + (float)(v62 * v62);
      if (v61 > v31 && v63 > v31)
      {
        if ((v18 & 0x80000000) != 0)
        {
          if (!v26)
          {
            char v82 = 0;
LABEL_121:
            char v83 = 0;
            goto LABEL_93;
          }
          float v72 = *v27;
          float v74 = *v27 * *v26;
        }
        else
        {
          float v72 = v8[v59];
          if (v29) {
            float v73 = v8[v59];
          }
          else {
            float v73 = 1.0;
          }
          float v74 = *(float *)(v28 + 4 * v18) * v73;
        }
        *float v24 = v74;
        v24[1] = v72;
        goto LABEL_91;
      }
      float v65 = sqrtf(v57 * v63);
      float v66 = v56 * sqrtf(v57 * v61);
      float v67 = v56 * v65;
      uint64_t v68 = (int)(float)(v15 * (float)((float)(v16 + (float)(v66 * v58)) - v14));
      uint64_t v69 = (int)(float)(v15 * (float)((float)(v16 + (float)((float)(v56 * v65) * v58)) - v14));
      if (v66 <= 1.0 && v67 <= 1.0)
      {
        uint64_t v75 = (int)v68;
        if (!v29) {
          uint64_t v75 = 0;
        }
        float v76 = v8[v75];
        float v77 = *(float *)(v28 + 4 * (int)v68);
        uint64_t v78 = (int)v69;
        if (v29) {
          float v79 = v8[v75];
        }
        else {
          float v79 = 1.0;
        }
        if (!v29) {
          uint64_t v78 = 0;
        }
        float v72 = v8[v78];
        float v80 = v77 * v79;
        if (v29) {
          float v81 = v8[v78];
        }
        else {
          float v81 = 1.0;
        }
        float v74 = *(float *)(v28 + 4 * (int)v69) * v81;
        *float v24 = v80;
        v24[1] = v76;
LABEL_91:
        char v82 = -1;
        goto LABEL_92;
      }
      if (v66 <= 1.0)
      {
        if ((v68 & 0x80000000) == 0)
        {
          if (v29) {
            uint64_t v71 = (int)(float)(v15 * (float)((float)(v16 + (float)(v66 * v58)) - v14));
          }
          else {
            uint64_t v71 = 0;
          }
LABEL_99:
          float v84 = v8[v71];
          if (v29) {
            float v85 = v8[v71];
          }
          else {
            float v85 = 1.0;
          }
          float v86 = *(float *)(v28 + 4 * v68) * v85;
          goto LABEL_105;
        }
      }
      else if (v66 <= v20)
      {
        uint64_t v71 = v59;
        uint64_t v68 = v18;
        if ((v18 & 0x80000000) == 0) {
          goto LABEL_99;
        }
      }
      if (!v26)
      {
        char v82 = 0;
        goto LABEL_106;
      }
      float v84 = *v27;
      float v86 = *v27 * *v26;
LABEL_105:
      *float v24 = v86;
      v24[1] = v84;
      char v82 = -1;
LABEL_106:
      if (v67 <= 1.0)
      {
        if ((v69 & 0x80000000) == 0)
        {
          if (v29) {
            uint64_t v87 = v69;
          }
          else {
            uint64_t v87 = 0;
          }
LABEL_114:
          float v72 = v8[v87];
          if (v29) {
            float v88 = v8[v87];
          }
          else {
            float v88 = 1.0;
          }
          float v74 = *(float *)(v28 + 4 * v69) * v88;
          goto LABEL_92;
        }
      }
      else if (v67 <= v20)
      {
        uint64_t v87 = v59;
        uint64_t v69 = v18;
        if ((v18 & 0x80000000) == 0) {
          goto LABEL_114;
        }
      }
      if (!v26) {
        goto LABEL_121;
      }
      float v72 = *v27;
      float v74 = *v27 * *v26;
LABEL_92:
      v24[2] = v74;
      v24[3] = v72;
      char v83 = -1;
LABEL_93:
      float v12 = v6 + v62;
      v24 += 4;
      *int v23 = v82;
      v23[1] = v83;
      v23 += 2;
      v60 -= 2;
      if (v60 <= 2) {
        return;
      }
    }
  }
  if (v26 || (v18 & 0x80000000) == 0)
  {
    if ((v18 & 0x80000000) != 0)
    {
      float v90 = *v27;
      float v92 = *v27 * *v26;
    }
    else
    {
      if (v29) {
        uint64_t v89 = v18;
      }
      else {
        uint64_t v89 = 0;
      }
      float v90 = v8[v89];
      float v91 = 1.0;
      if (v29) {
        float v91 = v8[v89];
      }
      float v92 = *(float *)(v28 + 4 * v18) * v91;
    }
    int v93 = a4 + 4;
    do
    {
      *float v24 = v92;
      v24[1] = v90;
      v24[2] = v92;
      v24[3] = v90;
      v24[4] = v92;
      v24[5] = v90;
      v93 -= 4;
      v24[6] = v92;
      v24[7] = v90;
      v24 += 8;
      *(_DWORD *)int v23 = -1;
      v23 += 4;
    }
    while (v93 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v32 = 4;
    }
    else {
      int v32 = a4;
    }
    bzero(v23, ((a4 - v32 + 3) & 0xFFFFFFFC) + 4);
  }
}

int8x8_t *WF_pattern(uint64_t a1, int8x8_t *a2, unsigned int a3, int a4, float *a5, float a6)
{
  uint64_t v9 = *(void *)(*(void *)a1 + 64);
  v10.i32[0] = *(_DWORD *)v9;
  float v11 = *(float *)(v9 + 4);
  if (!a2 || a3 <= 7)
  {
    __int32 v18 = *(_DWORD *)v9;
    float v12 = (int8x8_t *)malloc_type_malloc(0x38uLL, 0x705560E0uLL);
    v10.i32[0] = v18;
    a2 = v12;
    if (!v12) {
      return a2;
    }
  }
  if (*(float *)v10.i32 <= a6) {
    float v13 = a6;
  }
  else {
    float v13 = *(float *)v10.i32;
  }
  if (v11 < a6) {
    float v13 = v11;
  }
  if (a5) {
    int v14 = a4;
  }
  else {
    int v14 = 0;
  }
  switch(v14)
  {
    case 1:
      float v15 = *a5;
      goto LABEL_18;
    case 4:
      float v15 = (float)(v11
                  - (float)((float)((float)(*a5 * *(float *)(v9 + 8)) + (float)(a5[1] * *(float *)(v9 + 12)))
                          + (float)(a5[2] * *(float *)(v9 + 16))))
          - a5[3];
      goto LABEL_18;
    case 3:
      float v15 = (float)((float)(*a5 * *(float *)(v9 + 8)) + (float)(a5[1] * *(float *)(v9 + 12)))
          + (float)(a5[2] * *(float *)(v9 + 16));
LABEL_18:
      *(float *)v10.i32 = v13 * v15;
      break;
  }
  *(_OWORD *)a2->i8 = xmmword_1850CDB00;
  a2[3].i32[0] = 0;
  *(float *)&v10.i32[1] = v13;
  a2[6] = vrev32_s8(v10);
  a2[2] = (int8x8_t)1;
  float v16 = (char *)&a2[6] + 4;
  if (v13 >= v11) {
    float v16 = 0;
  }
  a2[4] = (int8x8_t)&a2[6];
  a2[5] = (int8x8_t)v16;
  return a2;
}

uint64_t WF_mark(uint64_t a1, __n128 a2)
{
  return WF_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

uint64_t WF_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v685 = *MEMORY[0x1E4F143B8];
  float v7 = *(unsigned int **)(v3 + 96);
  uint64_t v8 = *(void *)(v3 + 48);
  uint64_t v9 = *(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
  if ((int)v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v3;
  unint64_t v12 = *(unsigned int *)(v3 + 4);
  unsigned int v13 = v12 - 1;
  if ((int)v12 < 1) {
    return 0;
  }
  int v14 = *(_DWORD *)(v3 + 8);
  uint64_t v15 = (v14 - 1);
  if (v14 < 1) {
    return 0;
  }
  float v16 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v16)
  {
    int v18 = *(_DWORD *)v3 & 0xFF00;
    uint64_t v634 = v9;
    uint64_t v638 = v3;
    if (v18 == 1024)
    {
      v684[0] = *(_DWORD *)(v3 + 4);
      v674[0] = v14;
      unsigned int v19 = **(_DWORD **)(v3 + 88);
      unsigned int v20 = bswap32(v19);
      float v21 = 1.0;
      if (v7) {
        float v21 = COERCE_FLOAT(bswap32(*v7));
      }
      v6.i32[0] = v20;
      uint64_t v22 = *(void *)(v3 + 40);
      unint64_t v23 = (unint64_t)*(int *)(v3 + 28) >> 2;
      uint64_t v25 = *(int *)(v3 + 12);
      uint64_t v24 = *(int *)(v3 + 16);
      if (v8)
      {
        unint64_t v669 = (unint64_t)*(int *)(v3 + 32) >> 2;
        uint64_t v667 = v8 + 4 * (v25 + v669 * v24);
        unsigned int v661 = 1;
      }
      else
      {
        uint64_t v667 = 0;
        unint64_t v669 = 0;
        unsigned int v661 = 0;
      }
      *(float *)v5.i32 = 1.0 - v21;
      unint64_t v37 = v22 + 4 * (v25 + v24 * v23);
      int32x2_t v671 = v6;
      int32x2_t v665 = v5;
      unint64_t v652 = (unint64_t)*(int *)(v3 + 28) >> 2;
      unint64_t v663 = v37;
      if (v16)
      {
        shape_enum_clip_alloc(v12, v3, (int *)v16, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
        float v36 = v38;
        uint64_t v39 = v667;
        unint64_t v40 = v669;
        if (v38) {
          goto LABEL_308;
        }
        return 1;
      }
      float v36 = 0;
      if (v8) {
        unint64_t v46 = v12;
      }
      else {
        unint64_t v46 = 0;
      }
      uint64_t v39 = v667;
      unint64_t v40 = v669 - v46;
      float v47 = (int8x16_t *)(v22 + 4 * (v25 + v24 * v23));
      unint64_t v48 = v12;
LABEL_65:
      unint64_t v37 = v23 - v48;
      switch((int)v9)
      {
        case 0:
          uint64_t v74 = v9;
          uint64_t v75 = v36;
          uint64_t v76 = v37 + (int)v12;
          unsigned int v77 = v674[0];
          uint64_t v78 = v674[0] - 1;
          float v79 = &v47->i8[4 * ((v76 * v78) & (v76 >> 63))];
          if (v76 < 0) {
            uint64_t v76 = -v76;
          }
          int v80 = 4 * v12;
          int v81 = v12;
          CGBlt_fillBytes(4 * v12, v674[0], 0, v79, 4 * v76);
          if (v8)
          {
            uint64_t v82 = v40 + v81;
            v39 += 4 * ((v82 * v78) & (v82 >> 63));
            if (v82 >= 0) {
              v40 += v81;
            }
            else {
              unint64_t v40 = -v82;
            }
            CGBlt_fillBytes(v80, v77, 0, (char *)v39, 4 * v40);
          }
          uint64_t v11 = v638;
          unint64_t v37 = v663;
          float v36 = v75;
          uint64_t v9 = v74;
          unint64_t v23 = v652;
          goto LABEL_306;
        case 1:
          uint64_t v83 = (int)v12;
          uint64_t v84 = v37 + (int)v12;
          if (v84 < 0)
          {
            float v47 = (int8x16_t *)((char *)v47 + 4 * v84 * (v674[0] - 1));
            uint64_t v84 = -v84;
          }
          int v85 = 0;
          float v86 = *(int **)(v11 + 88);
          if (v86) {
            int v85 = *v86;
          }
          int v87 = 4 * v12;
          int v88 = v674[0];
          CGBlt_fillBytes(4 * v12, v674[0], v85, v47->i8, 4 * v84);
          if (v8)
          {
            uint64_t v89 = v88;
            uint64_t v11 = v638;
            float v90 = *(int **)(v638 + 96);
            if (!v90) {
              float v90 = (int *)&unk_18529410C;
            }
            v39 += 4 * (((v40 + v83) * (v89 - 1)) & ((uint64_t)(v40 + v83) >> 63));
            if ((uint64_t)(v40 + v83) >= 0) {
              v40 += v83;
            }
            else {
              unint64_t v40 = -(uint64_t)(v40 + v83);
            }
            CGBlt_fillBytes(v87, v89, *v90, (char *)v39, 4 * v40);
            uint64_t v9 = v634;
          }
          else
          {
            uint64_t v9 = v634;
            uint64_t v11 = v638;
          }
          goto LABEL_305;
        case 2:
          uint64_t v91 = 4 * v661;
          if (v8)
          {
            do
            {
              int v92 = v684[0];
              if (v684[0] >= 4)
              {
                unsigned int v93 = (v684[0] >> 2) + 1;
                do
                {
                  unsigned int v94 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)v39))
                                                                * *(float *)v5.i32)));
                  v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->i32[0]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)uint64_t v39 = v94;
                  unsigned int v95 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v39 + 4)))
                                                                * *(float *)v5.i32)));
                  v47->i32[1] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->u32[1]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)(v39 + 4) = v95;
                  unsigned int v96 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v39 + 8)))
                                                                * *(float *)v5.i32)));
                  v47->i32[2] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->u32[2]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)(v39 + 8) = v96;
                  unsigned int v97 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v39 + 12)))
                                                                * *(float *)v5.i32)));
                  v47->i32[3] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->u32[3]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)(v39 + 12) = v97;
                  ++v47;
                  --v93;
                  v39 += 16 * v661;
                }
                while (v93 > 1);
                int v92 = v684[0] & 3;
              }
              if (v92 >= 1)
              {
                unsigned int v98 = v92 + 1;
                do
                {
                  unsigned int v99 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)v39))
                                                                * *(float *)v5.i32)));
                  v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->i32[0]))
                                                                                     * *(float *)v5.i32)));
                  float v47 = (int8x16_t *)((char *)v47 + 4);
                  *(_DWORD *)uint64_t v39 = v99;
                  v39 += v91;
                  --v98;
                }
                while (v98 > 1);
              }
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            float32x4_t v213 = (float32x4_t)vdupq_lane_s32(v5, 0);
            float32x4_t v214 = (float32x4_t)vdupq_lane_s32(v6, 0);
            do
            {
              int v215 = v684[0];
              if (v684[0] >= 4)
              {
                unsigned int v216 = (v684[0] >> 2) + 1;
                do
                {
                  *float v47 = vrev32q_s8((int8x16_t)vmlaq_f32(v214, v213, (float32x4_t)vrev32q_s8(*v47)));
                  ++v47;
                  --v216;
                  v39 += 16 * v661;
                }
                while (v216 > 1);
                v215 &= 3u;
              }
              if (v215 >= 1)
              {
                unsigned int v217 = v215 + 1;
                do
                {
                  v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->i32[0]))
                                                                                     * *(float *)v5.i32)));
                  float v47 = (int8x16_t *)((char *)v47 + 4);
                  v39 += v91;
                  --v217;
                }
                while (v217 > 1);
              }
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 3:
          unsigned int v100 = bswap32(LODWORD(v21));
          do
          {
            int v101 = v684[0];
            do
            {
              float v102 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              if (v102 <= 0.0)
              {
                *(_DWORD *)uint64_t v39 = 0;
                v47->i32[0] = 0;
              }
              else if (v102 >= 1.0)
              {
                v47->i32[0] = v19;
                *(_DWORD *)uint64_t v39 = v100;
              }
              else
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 * v102));
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT(v21 * v102));
              }
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v101;
            }
            while (v101);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 4:
          unsigned int v103 = bswap32(LODWORD(v21));
          do
          {
            int v104 = v684[0];
            do
            {
              float v105 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              if (v105 <= 0.0)
              {
                *(_DWORD *)uint64_t v39 = 0;
                v47->i32[0] = 0;
              }
              else if (v105 >= 1.0)
              {
                v47->i32[0] = v19;
                *(_DWORD *)uint64_t v39 = v103;
              }
              else
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v105 * *(float *)v6.i32));
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT(v21 * v105));
              }
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v104;
            }
            while (v104);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 5:
          do
          {
            int v106 = v684[0];
            do
            {
              float v107 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0])))+ (float)(*(float *)v6.i32 * v107)));
              float v47 = (int8x16_t *)((char *)v47 + 4);
              *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * v107) + (float)(v21 * v107)));
              v39 += 4 * v661;
              --v106;
            }
            while (v106);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 6:
          unsigned int v108 = bswap32(LODWORD(v21));
          while (1)
          {
            int v109 = v684[0];
            do
            {
              float v110 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              float v111 = 1.0 - v110;
              unsigned int v112 = v19;
              unsigned int v113 = v108;
              if ((float)(1.0 - v110) < 1.0)
              {
                if (v111 <= 0.0) {
                  goto LABEL_125;
                }
                unsigned int v112 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v47->i32[0])) + (float)(*(float *)v6.i32 * v111)));
                unsigned int v113 = bswap32(COERCE_UNSIGNED_INT(v110 + (float)(v21 * v111)));
              }
              v47->i32[0] = v112;
              *(_DWORD *)uint64_t v39 = v113;
LABEL_125:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v109;
            }
            while (v109);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 7:
          uint64_t v114 = 4 * v661;
          if (v8)
          {
            do
            {
              int v115 = v684[0];
              do
              {
                unsigned int v116 = bswap32(COERCE_UNSIGNED_INT(v21 * COERCE_FLOAT(bswap32(*(_DWORD *)v39))));
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v21 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)uint64_t v39 = v116;
                v39 += v114;
                --v115;
              }
              while (v115);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              int v117 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v21 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v114;
                --v117;
              }
              while (v117);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 8:
          uint64_t v118 = 4 * v661;
          if (v8)
          {
            do
            {
              int v119 = v684[0];
              do
              {
                unsigned int v120 = bswap32(COERCE_UNSIGNED_INT(*(float *)v5.i32 * COERCE_FLOAT(bswap32(*(_DWORD *)v39))));
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)uint64_t v39 = v120;
                v39 += v118;
                --v119;
              }
              while (v119);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              int v121 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v118;
                --v121;
              }
              while (v121);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 9:
          do
          {
            int v122 = v684[0];
            do
            {
              float v123 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(v21 * COERCE_FLOAT(bswap32(v47->i32[0])))+ (float)(*(float *)v6.i32 * (float)(1.0 - v123))));
              float v47 = (int8x16_t *)((char *)v47 + 4);
              *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 * v123) + (float)(v21 * (float)(1.0 - v123))));
              v39 += 4 * v661;
              --v122;
            }
            while (v122);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 10:
          do
          {
            int v124 = v684[0];
            do
            {
              float v125 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0])))+ (float)(*(float *)v6.i32 * (float)(1.0 - v125))));
              float v47 = (int8x16_t *)((char *)v47 + 4);
              *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * v125) + (float)(v21 * (float)(1.0 - v125))));
              v39 += 4 * v661;
              --v124;
            }
            while (v124);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 11:
          float v126 = v21 - *(float *)v6.i32;
          uint64_t v127 = 4 * v661;
          if (v8)
          {
            do
            {
              int v128 = v684[0];
              do
              {
                float v129 = COERCE_FLOAT(bswap32(v47->i32[0]));
                float v130 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                float v131 = v21 + v130;
                if ((float)(v21 + v130) > 1.0) {
                  float v131 = 1.0;
                }
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v126 + (float)(v131 - (float)(v130 - v129))));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)uint64_t v39 = bswap32(LODWORD(v131));
                v39 += v127;
                --v128;
              }
              while (v128);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              int v132 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v126 + COERCE_FLOAT(bswap32(v47->i32[0]))));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v127;
                --v132;
              }
              while (v132);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 12:
          uint64_t v133 = 4 * v661;
          if (v8)
          {
            do
            {
              int v134 = v684[0];
              do
              {
                float v135 = v21 + COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                float v136 = *(float *)v6.i32 + COERCE_FLOAT(bswap32(v47->i32[0]));
                if (v135 > 1.0) {
                  float v135 = 1.0;
                }
                v47->i32[0] = bswap32(LODWORD(v136));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)uint64_t v39 = bswap32(LODWORD(v135));
                v39 += v133;
                --v134;
              }
              while (v134);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              int v137 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + COERCE_FLOAT(bswap32(v47->i32[0]))));
                float v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v133;
                --v137;
              }
              while (v137);
              float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 13:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v138 = bswap32(LODWORD(v21));
          while (1)
          {
            int v139 = v684[0];
            do
            {
              if (v8)
              {
                float v140 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v140 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v138;
                  goto LABEL_189;
                }
              }
              else
              {
                float v140 = 1.0;
              }
              float v141 = COERCE_FLOAT(bswap32(v47->i32[0]));
              float v142 = (float)(*(float *)v6.i32 * v141) + (float)(v141 * *(float *)v5.i32);
              if (v21 == 1.0) {
                float v142 = *(float *)v6.i32 * v141;
              }
              if (v140 != 1.0) {
                float v142 = v142 + (float)(*(float *)v6.i32 * (float)(1.0 - v140));
              }
              v47->i32[0] = bswap32(LODWORD(v142));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v140) - (float)(v140 * v21)));
              }
LABEL_189:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v139;
            }
            while (v139);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 14:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v143 = bswap32(LODWORD(v21));
          while (1)
          {
            int v144 = v684[0];
            do
            {
              if (v8)
              {
                float v145 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v145 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v143;
                  goto LABEL_201;
                }
              }
              else
              {
                float v145 = 1.0;
              }
              float v146 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v146 + (float)(*(float *)v6.i32 * (float)(1.0 - v146))));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v145) - (float)(v145 * v21)));
              }
LABEL_201:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v144;
            }
            while (v144);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 15:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v147 = bswap32(LODWORD(v21));
          while (1)
          {
            int v148 = v684[0];
            do
            {
              if (v8)
              {
                float v149 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v149 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v147;
                  goto LABEL_214;
                }
              }
              else
              {
                float v149 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAoverlayPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v149, *(float *)v6.i32, v21)));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(v150);
              }
              v6.i32[0] = v671.i32[0];
LABEL_214:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v148;
            }
            while (v148);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_304;
            }
          }
        case 16:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v151 = bswap32(LODWORD(v21));
          while (1)
          {
            int v152 = v684[0];
            do
            {
              if (v8)
              {
                float v153 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v153 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v151;
                  goto LABEL_232;
                }
              }
              else
              {
                float v153 = 1.0;
              }
              float v154 = COERCE_FLOAT(bswap32(v47->i32[0]));
              float v155 = v21 * v154;
              if ((float)(v153 * *(float *)v6.i32) < (float)(v21 * v154)) {
                float v155 = v153 * *(float *)v6.i32;
              }
              float v156 = v155 + (float)(v154 * *(float *)v5.i32);
              if (v21 == 1.0) {
                float v156 = v155;
              }
              if (v153 != 1.0) {
                float v156 = v156 + (float)(*(float *)v6.i32 * (float)(1.0 - v153));
              }
              v47->i32[0] = bswap32(LODWORD(v156));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v153) - (float)(v153 * v21)));
              }
LABEL_232:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v152;
            }
            while (v152);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 17:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v157 = bswap32(LODWORD(v21));
          while (1)
          {
            int v158 = v684[0];
            do
            {
              if (v8)
              {
                float v159 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v159 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v157;
                  goto LABEL_250;
                }
              }
              else
              {
                float v159 = 1.0;
              }
              float v160 = COERCE_FLOAT(bswap32(v47->i32[0]));
              float v161 = v21 * v160;
              if ((float)(v159 * *(float *)v6.i32) > (float)(v21 * v160)) {
                float v161 = v159 * *(float *)v6.i32;
              }
              float v162 = v161 + (float)(v160 * *(float *)v5.i32);
              if (v21 == 1.0) {
                float v162 = v161;
              }
              if (v159 != 1.0) {
                float v162 = v162 + (float)(*(float *)v6.i32 * (float)(1.0 - v159));
              }
              v47->i32[0] = bswap32(LODWORD(v162));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v159) - (float)(v159 * v21)));
              }
LABEL_250:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v158;
            }
            while (v158);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 18:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v163 = bswap32(LODWORD(v21));
          while (1)
          {
            int v164 = v684[0];
            do
            {
              if (v8)
              {
                float v165 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v165 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v163;
                  goto LABEL_263;
                }
              }
              else
              {
                float v165 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAcolordodgePDA(COERCE_FLOAT(bswap32(v47->i32[0])), v165, *(float *)v6.i32, v21)));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(v166);
              }
              v6.i32[0] = v671.i32[0];
LABEL_263:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v164;
            }
            while (v164);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_304;
            }
          }
        case 19:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v167 = bswap32(LODWORD(v21));
          while (1)
          {
            int v168 = v684[0];
            do
            {
              if (v8)
              {
                float v169 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v169 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v167;
                  goto LABEL_276;
                }
              }
              else
              {
                float v169 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT64(PDAcolorburnPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v169, *(float *)v6.i32, v21)));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(v170);
              }
              v6.i32[0] = v671.i32[0];
LABEL_276:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v168;
            }
            while (v168);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_304;
            }
          }
        case 20:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v171 = bswap32(LODWORD(v21));
          while (1)
          {
            int v172 = v684[0];
            do
            {
              if (v8)
              {
                float v173 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v173 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v171;
                  goto LABEL_289;
                }
              }
              else
              {
                float v173 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAsoftlightPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v173, *(float *)v6.i32, v21)));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(v174);
              }
              v6.i32[0] = v671.i32[0];
LABEL_289:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v172;
            }
            while (v172);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_304;
            }
          }
        case 21:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v175 = bswap32(LODWORD(v21));
          while (1)
          {
            int v176 = v684[0];
            do
            {
              if (v8)
              {
                float v177 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v177 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v175;
                  goto LABEL_302;
                }
              }
              else
              {
                float v177 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAhardlightPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v177, *(float *)v6.i32, v21)));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(v178);
              }
              v6.i32[0] = v671.i32[0];
LABEL_302:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v176;
            }
            while (v176);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
            {
LABEL_304:
              uint64_t v9 = v634;
              uint64_t v11 = v638;
              unint64_t v23 = v652;
LABEL_305:
              unint64_t v37 = v663;
LABEL_306:
              if (!v36) {
                return 1;
              }
              uint64_t v673 = 0;
LABEL_308:
              if (!shape_enum_clip_next((uint64_t)v36, (int *)&v673 + 1, &v673, v684, v674)) {
                goto LABEL_312;
              }
              float v47 = (int8x16_t *)(v37 + 4 * v23 * (int)v673 + 4 * SHIDWORD(v673));
              unint64_t v48 = v684[0];
              if (v8)
              {
                uint64_t v39 = v667 + 4 * v669 * (int)v673 + 4 * SHIDWORD(v673);
                unint64_t v40 = v669 - v684[0];
              }
              LODWORD(v12) = v684[0];
              int32x2_t v6 = v671;
              int32x2_t v5 = v665;
              goto LABEL_65;
            }
          }
        case 22:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v180 = bswap32(LODWORD(v21));
          while (1)
          {
            int v181 = v684[0];
            do
            {
              if (v8)
              {
                float v182 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v182 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v180;
                  goto LABEL_324;
                }
              }
              else
              {
                float v182 = 1.0;
              }
              float v183 = COERCE_FLOAT(bswap32(v47->i32[0]));
              float v184 = (float)(v21 * v183) - (float)(v182 * *(float *)v6.i32);
              if (v184 < 0.0) {
                float v184 = -v184;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)(*(float *)v6.i32 + v183) - (float)(v21 * v183))- (float)(v182 * *(float *)v6.i32))+ v184));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v182) - (float)(v182 * v21)));
              }
LABEL_324:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v181;
            }
            while (v181);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 23:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v185 = bswap32(LODWORD(v21));
          while (1)
          {
            int v186 = v684[0];
            do
            {
              if (v8)
              {
                float v187 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v187 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v185;
                  goto LABEL_336;
                }
              }
              else
              {
                float v187 = 1.0;
              }
              float v188 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v6.i32 + v188) + (float)((float)(*(float *)v6.i32 * v188)
                                                                                                 * -2.0)));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v187) - (float)(v187 * v21)));
              }
LABEL_336:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v186;
            }
            while (v186);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 24:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v189 = bswap32(LODWORD(v21));
          while (1)
          {
            int v190 = v684[0];
            do
            {
              if (v8)
              {
                float v191 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v191 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v189;
                  goto LABEL_353;
                }
              }
              else
              {
                float v191 = 1.0;
              }
              float v192 = COERCE_FLOAT(bswap32(v47->i32[0]));
              float v193 = v192;
              if (v21 == 1.0)
              {
                float v194 = 0.0;
              }
              else
              {
                float v193 = v21 * v192;
                float v194 = v192 - (float)(v21 * v192);
              }
              if (v191 != 1.0) {
                float v194 = (float)(v194 + *(float *)v6.i32) - (float)(v191 * *(float *)v6.i32);
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v193 + v194));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v191) - (float)(v21 * v191)));
              }
LABEL_353:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v190;
            }
            while (v190);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 25:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v195 = bswap32(LODWORD(v21));
          while (1)
          {
            int v196 = v684[0];
            do
            {
              if (v8)
              {
                float v197 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v197 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v195;
                  goto LABEL_370;
                }
              }
              else
              {
                float v197 = 1.0;
              }
              float v198 = COERCE_FLOAT(bswap32(v47->i32[0]));
              float v199 = v198;
              if (v21 == 1.0)
              {
                float v200 = 0.0;
              }
              else
              {
                float v199 = v21 * v198;
                float v200 = v198 - (float)(v21 * v198);
              }
              if (v197 != 1.0) {
                float v200 = (float)(v200 + *(float *)v6.i32) - (float)(v197 * *(float *)v6.i32);
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v199 + v200));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v197) - (float)(v21 * v197)));
              }
LABEL_370:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v196;
            }
            while (v196);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 26:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v201 = bswap32(LODWORD(v21));
          while (1)
          {
            int v202 = v684[0];
            do
            {
              if (v8)
              {
                float v203 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v203 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)uint64_t v39 = v201;
                  goto LABEL_386;
                }
              }
              else
              {
                float v203 = 1.0;
              }
              float v204 = COERCE_FLOAT(bswap32(v47->i32[0]));
              float v205 = v204;
              float v206 = *(float *)v6.i32 - (float)(v203 * *(float *)v6.i32);
              if (v203 == 1.0) {
                float v206 = 0.0;
              }
              if (v21 != 1.0)
              {
                float v205 = v21 * v204;
                float v206 = (float)(v206 + v204) - (float)(v21 * v204);
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v205 + v206));
              if (v8) {
                *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v203) - (float)(v21 * v203)));
              }
LABEL_386:
              float v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v202;
            }
            while (v202);
            float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0]) {
              goto LABEL_305;
            }
          }
        case 27:
          if (v21 <= 0.0) {
            goto LABEL_305;
          }
          unsigned int v207 = bswap32(LODWORD(v21));
          break;
        default:
          goto LABEL_306;
      }
LABEL_391:
      int v208 = v684[0];
      while (v8)
      {
        float v209 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
        if (v209 > 0.0) {
          goto LABEL_396;
        }
        v47->i32[0] = v19;
        *(_DWORD *)uint64_t v39 = v207;
LABEL_403:
        float v47 = (int8x16_t *)((char *)v47 + 4);
        v39 += 4 * v661;
        if (!--v208)
        {
          float v47 = (int8x16_t *)((char *)v47 + 4 * v37);
          v39 += 4 * v40;
          if (!--v674[0]) {
            goto LABEL_305;
          }
          goto LABEL_391;
        }
      }
      float v209 = 1.0;
LABEL_396:
      float v210 = COERCE_FLOAT(bswap32(v47->i32[0]));
      float v211 = v210 - (float)(v21 * v210);
      if (v21 == 1.0) {
        float v211 = 0.0;
      }
      float v212 = v209 * *(float *)v6.i32;
      if (v209 == 1.0) {
        float v212 = *(float *)v6.i32;
      }
      else {
        float v211 = (float)(v211 + *(float *)v6.i32) - (float)(v209 * *(float *)v6.i32);
      }
      v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v212 + v211));
      if (v8) {
        *(_DWORD *)uint64_t v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v209) - (float)(v21 * v209)));
      }
      goto LABEL_403;
    }
    v684[0] = *(_DWORD *)(v3 + 4);
    v674[0] = v14;
    uint64_t v26 = *(void *)(v3 + 40);
    uint64_t v28 = *(int *)(v3 + 12);
    uint64_t v27 = *(int *)(v3 + 16);
    unint64_t v29 = (unint64_t)*(int *)(v3 + 28) >> 2;
    if (v8)
    {
      unint64_t v642 = (unint64_t)*(int *)(v3 + 32) >> 2;
      uint64_t v643 = (char *)(v8 + 4 * (v28 + v642 * v27));
      uint64_t v30 = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v642 = 0;
      uint64_t v643 = 0;
      uint64_t v30 = 0;
    }
    float v41 = *(unsigned int **)(v11 + 88);
    uint64_t v641 = (unsigned int *)(v26 + 4 * (v28 + v27 * v29));
    int v42 = *(_DWORD *)(v11 + 56);
    int v43 = *(_DWORD *)(v11 + 60);
    unint64_t v666 = (unint64_t)*(int *)(v11 + 76) >> 2;
    if (v18 == 256)
    {
      if (v7)
      {
        unint64_t v664 = (unint64_t)*(int *)(v11 + 80) >> 2;
        v7 += v42 + v664 * v43;
        uint64_t v44 = 0xFFFFFFFFLL;
      }
      else
      {
        unint64_t v664 = 0;
        uint64_t v44 = 0;
      }
      v41 += v42 + v43 * v666;
      if (v666 == v29 && (char *)v641 - (char *)v41 >= 1)
      {
        if (v12 >= (unint64_t)((char *)v641 - (char *)v41) >> 2)
        {
          v641 += v13;
          v41 += v13;
          v643 += 4 * (v30 & v13);
          int v56 = -1;
          unint64_t v666 = v29;
          v7 += v44 & v13;
          goto LABEL_48;
        }
        char v55 = &v41[v29 * v15];
        if (v641 <= &v55[v13])
        {
          v641 += v29 * v15;
          unint64_t v29 = -(uint64_t)v29;
          float v73 = &v643[4 * v642 * v15];
          unint64_t v642 = -(uint64_t)v642;
          uint64_t v643 = v73;
          v7 += v664 * v15;
          v30 &= 1u;
          unint64_t v664 = -(uint64_t)v664;
          unint64_t v666 = v29;
          v44 &= 1u;
          int v56 = 1;
          float v41 = v55;
          goto LABEL_48;
        }
      }
      v30 &= 1u;
      v44 &= 1u;
      int v56 = 1;
LABEL_48:
      int v639 = *(_DWORD *)(v11 + 56);
      int v640 = *(_DWORD *)(v11 + 60);
      if (v16)
      {
        float v57 = v7;
        uint64_t v670 = v44;
        uint64_t v672 = v30;
        int v650 = 0;
        uint64_t v662 = 0;
        uint64_t v58 = -1;
        unint64_t v45 = v666;
        int v645 = v664;
        goto LABEL_53;
      }
      unint64_t v63 = v56 * (int)v12;
      unint64_t v668 = v642 - (int)v30 * (int)v12;
      unint64_t v64 = -1;
      unint64_t v65 = v664;
      int v644 = v56;
      int v645 = v664;
      unint64_t v66 = v666;
      unint64_t v45 = v666;
LABEL_61:
      uint64_t v646 = 0;
      uint64_t v647 = (uint64_t)v41;
      uint64_t v70 = 0;
      unint64_t v666 = v66 - v63;
      uint64_t v662 = 0;
      unint64_t v664 = v65 - (int)v44 * (int)v12;
      uint64_t v71 = (uint64_t)v7;
      float v61 = (char *)v7;
      float v62 = v643;
      float v72 = v641;
      goto LABEL_438;
    }
    unint64_t v45 = *(unsigned int *)(v11 + 64);
    int v645 = *(_DWORD *)(v11 + 68);
    if (v7)
    {
      unint64_t v664 = (unint64_t)*(int *)(v11 + 80) >> 2;
      uint64_t v44 = 1;
    }
    else
    {
      unint64_t v664 = 0;
      uint64_t v44 = 0;
    }
    uint64_t v662 = &v41[v666 * v645];
    v30 &= 1u;
    if (v16)
    {
      float v57 = v7;
      int v639 = *(_DWORD *)(v11 + 56);
      int v640 = *(_DWORD *)(v11 + 60);
      uint64_t v670 = v44;
      uint64_t v672 = v30;
      int v56 = 1;
      int v650 = *(unsigned int **)(v11 + 88);
      uint64_t v58 = (uint64_t)v650;
LABEL_53:
      int v644 = v56;
      shape_enum_clip_alloc(v12, v30, (int *)v16, v56, v29, 1, *(_DWORD *)(v11 + 104), *(_DWORD *)(v11 + 108), v12, v14);
      uint64_t v60 = v59;
      float v7 = v57;
      uint64_t v651 = (uint64_t)v57;
      float v61 = (char *)v57;
      float v62 = v643;
      unint64_t v668 = v642;
      if (v59) {
        goto LABEL_417;
      }
      return 1;
    }
    unint64_t v668 = v642 - (v30 * v12);
    if (!v41)
    {
      int v639 = *(_DWORD *)(v11 + 56);
      int v640 = *(_DWORD *)(v11 + 60);
      unint64_t v64 = 0;
      int v644 = 1;
      unint64_t v63 = v12;
      unint64_t v65 = v664;
      unint64_t v66 = (unint64_t)*(int *)(v11 + 76) >> 2;
      goto LABEL_61;
    }
    uint64_t v67 = v43 % v645;
    int v640 = v43 % v645;
    uint64_t v647 = *(void *)(v11 + 88);
    uint64_t v68 = &v41[v666 * v67];
    int v69 = v42 % (int)v45;
    uint64_t v70 = &v68[v69];
    unint64_t v64 = (unint64_t)&v68[(int)v45];
    int v639 = v69;
    uint64_t v646 = 0;
    if (v7)
    {
      uint64_t v71 = (uint64_t)&v7[v664 * v67 + v69];
      int v644 = 1;
      uint64_t v44 = 1;
      float v61 = (char *)v71;
    }
    else
    {
      uint64_t v71 = 0;
      float v61 = 0;
      int v644 = 1;
    }
    float v41 = &v68[v69];
    float v62 = v643;
    float v72 = v641;
    unint64_t v63 = v12;
LABEL_438:
    uint64_t v670 = v44;
    uint64_t v672 = v30;
    unint64_t v228 = v29 - v63;
    unint64_t v648 = v29 - v63;
    switch((int)v9)
    {
      case 0:
        unsigned int v632 = v7;
        int v650 = v70;
        uint64_t v651 = v71;
        uint64_t v58 = v64;
        unint64_t v635 = v29;
        uint64_t v229 = (int)v12;
        uint64_t v230 = v228 - (int)v12;
        int v231 = v12 - 1;
        float v232 = &v72[-(int)v12 + 1];
        if (v644 >= 0)
        {
          float v232 = v72;
          uint64_t v230 = v228 + (int)v12;
        }
        unsigned int v233 = v674[0];
        uint64_t v234 = v674[0] - 1;
        int v235 = (char *)&v232[(v230 * v234) & (v230 >> 63)];
        if (v230 < 0) {
          uint64_t v230 = -v230;
        }
        int v653 = 4 * v12;
        CGBlt_fillBytes(4 * v12, v674[0], 0, v235, 4 * v230);
        if (v672)
        {
          if (v644 < 0)
          {
            uint64_t v236 = v668 - v229;
            v62 -= 4 * v231;
          }
          else
          {
            uint64_t v236 = v668 + v229;
          }
          v62 += 4 * ((v236 * v234) & (v236 >> 63));
          if (v236 < 0) {
            uint64_t v236 = -v236;
          }
          unint64_t v668 = v236;
          CGBlt_fillBytes(v653, v233, 0, v62, 4 * v236);
        }
        unint64_t v29 = v635;
        float v41 = (unsigned int *)v647;
        goto LABEL_1229;
      case 1:
        unint64_t v636 = v29;
        int v237 = *(unsigned __int8 *)(v11 + 1);
        int v238 = v12;
        if (v237 == 2)
        {
          if ((int)v12 >= 8 && (4 * v45) <= 0x40)
          {
            LODWORD(v4) = 4 * v45;
            uint8x8_t v590 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v4);
            v590.i16[0] = vaddlv_u8(v590);
            if (v590.i32[0] <= 1u)
            {
              int v650 = v70;
              uint64_t v651 = v71;
              uint64_t v58 = v64;
              unsigned int v591 = 4 * v12;
              int v592 = v12;
              int v659 = v674[0];
              CGSFillDRAM64((unint64_t)v72, 4 * (v12 + v228), 4 * v12, v674[0], v647, 4 * v666, 4 * v45, v645, 4 * v639, v640);
              if (v672)
              {
                unsigned int v593 = v591;
                uint64_t v60 = v646;
                unint64_t v29 = v636;
                if (v670) {
                  CGSFillDRAM64((unint64_t)v62, 4 * (v592 + v668), v593, v659, (uint64_t)v7, 4 * v664, 4 * v45, v645, 4 * v639, v640);
                }
                else {
                  CGBlt_fillBytes(v593, v659, 32831, v62, 4 * (v592 + v668));
                }
                float v41 = (unsigned int *)v647;
                if (v646) {
                  goto LABEL_1268;
                }
                return 1;
              }
              uint64_t v60 = v646;
              float v41 = (unsigned int *)v647;
LABEL_1248:
              unint64_t v29 = v636;
              if (v60) {
                goto LABEL_1268;
              }
              return 1;
            }
          }
        }
        else if (v237 == 1)
        {
          int v650 = v70;
          uint64_t v651 = v71;
          uint64_t v239 = (int)v12;
          unsigned int v632 = v7;
          uint64_t v58 = v64;
          if (v644 < 0)
          {
            uint64_t v240 = v666 - (int)v12;
            v41 += -(int)v12 + 1;
            uint64_t v241 = v648 - (int)v12;
            v72 += -(int)v12 + 1;
          }
          else
          {
            uint64_t v240 = v666 + (int)v12;
            uint64_t v241 = v648 + (int)v12;
          }
          uint64_t v616 = v674[0] - 1;
          int v617 = (char *)&v41[(v240 * v616) & (v240 >> 63)];
          if (v240 >= 0) {
            unint64_t v618 = v240;
          }
          else {
            unint64_t v618 = -v240;
          }
          uint64_t v649 = v674[0] - 1;
          float v619 = (char *)&v72[(v241 * v616) & (v241 >> 63)];
          if (v241 >= 0) {
            LODWORD(v620) = v241;
          }
          else {
            uint64_t v620 = -v241;
          }
          int v621 = 4 * v12;
          unint64_t v666 = v618;
          int v660 = v674[0];
          CGBlt_copyBytes(4 * v12, v674[0], v617, v619, 4 * v618, 4 * v620);
          if (v672)
          {
            float v41 = (unsigned int *)v647;
            if (v670)
            {
              uint64_t v622 = v664 - v239;
              int v623 = &v61[-4 * v238 + 4];
              uint64_t v624 = v668 - v239;
              uint64_t v625 = &v62[-4 * v238 + 4];
              if (v644 >= 0)
              {
                int v623 = v61;
                uint64_t v625 = v62;
                uint64_t v622 = v664 + v239;
                uint64_t v624 = v668 + v239;
              }
              float v61 = &v623[4 * ((v622 * v649) & (v622 >> 63))];
              if (v622 >= 0) {
                unint64_t v626 = v622;
              }
              else {
                unint64_t v626 = -v622;
              }
              float v62 = &v625[4 * ((v624 * v649) & (v624 >> 63))];
              if (v624 >= 0) {
                uint64_t v627 = v624;
              }
              else {
                uint64_t v627 = -v624;
              }
              unint64_t v664 = v626;
              unint64_t v668 = v627;
              CGBlt_copyBytes(v621, v660, v61, &v625[4 * ((v624 * v649) & (v624 >> 63))], 4 * v626, 4 * v627);
            }
            else
            {
              uint64_t v628 = v668 - v239;
              uint64_t v629 = &v62[-4 * v238 + 4];
              if (v644 >= 0)
              {
                uint64_t v629 = v62;
                uint64_t v628 = v668 + v239;
              }
              uint64_t v630 = (v628 * v649) & (v628 >> 63);
              float v62 = &v629[4 * v630];
              if (v628 < 0) {
                uint64_t v628 = -v628;
              }
              unint64_t v668 = v628;
              CGBlt_fillBytes(v621, v660, 32831, &v629[4 * v630], 4 * v628);
            }
            unint64_t v29 = v636;
          }
          else
          {
            unint64_t v29 = v636;
            float v41 = (unsigned int *)v647;
          }
LABEL_1229:
          uint64_t v60 = v646;
          float v7 = v632;
          if (v646) {
            goto LABEL_1268;
          }
          return 1;
        }
        if (v30)
        {
          uint64_t v594 = 4 * (int)v30;
          uint64_t v595 = 4 * v644;
          if (!v44)
          {
            unint64_t v29 = v636;
            do
            {
              int v610 = v684[0];
              do
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = 32831;
                uint64_t v611 = &v41[v644];
                if ((unint64_t)v611 >= v64) {
                  uint64_t v612 = -(uint64_t)(int)v45;
                }
                else {
                  uint64_t v612 = 0;
                }
                v61 += 4 * v612;
                float v41 = &v611[v612];
                v62 += v594;
                float v72 = (unsigned int *)((char *)v72 + v595);
                --v610;
              }
              while (v610);
              if (v662)
              {
                uint64_t v613 = &v70[v666];
                if (v613 >= v662) {
                  uint64_t v614 = -(uint64_t)(v664 * v645);
                }
                else {
                  uint64_t v614 = 0;
                }
                v71 += 4 * v664 + 4 * v614;
                if (v613 >= v662) {
                  uint64_t v615 = -(uint64_t)(v666 * v645);
                }
                else {
                  uint64_t v615 = 0;
                }
                uint64_t v70 = &v613[v615];
                v64 += 4 * v615 + 4 * v666;
                float v61 = (char *)v71;
                float v41 = v70;
              }
              else
              {
                v41 += v666;
                v61 += 4 * v664;
              }
              v72 += v228;
              v62 += 4 * v668;
              --v674[0];
            }
            while (v674[0]);
            goto LABEL_1266;
          }
          int v596 = v674[0];
          do
          {
            int v597 = v12;
            do
            {
              *float v72 = *v41;
              *(_DWORD *)float v62 = *(_DWORD *)v61;
              uint64_t v598 = &v41[v644];
              if ((unint64_t)v598 >= v64) {
                uint64_t v599 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v599 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v599;
              float v41 = &v598[v599];
              v62 += v594;
              float v72 = (unsigned int *)((char *)v72 + v595);
              --v597;
            }
            while (v597);
            if (v662)
            {
              int v600 = &v70[v666];
              if (v600 >= v662) {
                uint64_t v601 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v601 = 0;
              }
              v71 += 4 * v664 + 4 * v601;
              if (v600 >= v662) {
                uint64_t v602 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v602 = 0;
              }
              uint64_t v70 = &v600[v602];
              v64 += 4 * v602 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v596;
            LODWORD(v12) = v238;
          }
          while (v596);
        }
        else
        {
          int v603 = v674[0];
          do
          {
            int v604 = v12;
            do
            {
              *float v72 = *v41;
              float v605 = &v41[v644];
              if ((unint64_t)v605 >= v64) {
                uint64_t v606 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v606 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v606;
              float v41 = &v605[v606];
              v72 += v644;
              --v604;
            }
            while (v604);
            if (v662)
            {
              float v607 = &v70[v666];
              if (v607 >= v662) {
                uint64_t v608 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v608 = 0;
              }
              v71 += 4 * v664 + 4 * v608;
              if (v607 >= v662) {
                uint64_t v609 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v609 = 0;
              }
              uint64_t v70 = &v607[v609];
              v64 += 4 * v609 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v603;
            LODWORD(v12) = v238;
          }
          while (v603);
        }
        int v650 = v70;
        uint64_t v651 = v71;
        uint64_t v58 = v64;
        v674[0] = 0;
        uint64_t v60 = v646;
        float v41 = (unsigned int *)v647;
        goto LABEL_1248;
      case 2:
        if (v30)
        {
          do
          {
            int v242 = v684[0];
            do
            {
              float v243 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v243 >= 1.0)
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = *(_DWORD *)v61;
              }
              else if (v243 > 0.0)
              {
                unsigned int v244 = bswap32(COERCE_UNSIGNED_INT(v243 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)v62))
                                                                * (float)(1.0 - v243))));
                *float v72 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v41)) + (float)(COERCE_FLOAT(bswap32(*v72))
                                                                                       * (float)(1.0 - v243))));
                *(_DWORD *)float v62 = v244;
              }
              int v245 = &v41[v644];
              if ((unint64_t)v245 >= v64) {
                uint64_t v246 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v246 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v246;
              float v41 = &v245[v246];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v242;
            }
            while (v242);
            if (v662)
            {
              unsigned int v247 = &v70[v666];
              if (v247 >= v662) {
                uint64_t v248 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v248 = 0;
              }
              v71 += 4 * v664 + 4 * v248;
              if (v247 >= v662) {
                uint64_t v249 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v249 = 0;
              }
              uint64_t v70 = &v247[v249];
              v64 += 4 * v249 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            int v549 = v684[0];
            do
            {
              float v550 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v550 >= 1.0)
              {
                *float v72 = *v41;
              }
              else if (v550 > 0.0)
              {
                *float v72 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v41)) + (float)(COERCE_FLOAT(bswap32(*v72))
                                                                                       * (float)(1.0 - v550))));
              }
              float v551 = &v41[v644];
              if ((unint64_t)v551 >= v64) {
                uint64_t v552 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v552 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v552;
              float v41 = &v551[v552];
              v72 += v644;
              --v549;
            }
            while (v549);
            if (v662)
            {
              uint64_t v553 = &v70[v666];
              if (v553 >= v662) {
                uint64_t v554 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v554 = 0;
              }
              v71 += 4 * v664 + 4 * v554;
              if (v553 >= v662) {
                uint64_t v555 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v555 = 0;
              }
              uint64_t v70 = &v553[v555];
              v64 += 4 * v555 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 3:
        if (v44)
        {
          do
          {
            int v250 = v684[0];
            do
            {
              float v251 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v251 <= 0.0)
              {
                *(_DWORD *)float v62 = 0;
                *float v72 = 0;
              }
              else if (v251 >= 1.0)
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = *(_DWORD *)v61;
              }
              else
              {
                unsigned int v252 = bswap32(COERCE_UNSIGNED_INT(v251 * COERCE_FLOAT(bswap32(*(_DWORD *)v61))));
                *float v72 = bswap32(COERCE_UNSIGNED_INT(v251 * COERCE_FLOAT(bswap32(*v41))));
                *(_DWORD *)float v62 = v252;
              }
              float v253 = &v41[v644];
              if ((unint64_t)v253 >= v64) {
                uint64_t v254 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v254 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v254;
              float v41 = &v253[v254];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v250;
            }
            while (v250);
            if (v662)
            {
              int v255 = &v70[v666];
              if (v255 >= v662) {
                uint64_t v256 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v256 = 0;
              }
              v71 += 4 * v664 + 4 * v256;
              if (v255 >= v662) {
                uint64_t v257 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v257 = 0;
              }
              uint64_t v70 = &v255[v257];
              v64 += 4 * v257 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            int v556 = v684[0];
            do
            {
              float v557 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v557 <= 0.0)
              {
                *float v72 = 0;
              }
              else if (v557 >= 1.0)
              {
                *float v72 = *v41;
              }
              else
              {
                *float v72 = bswap32(COERCE_UNSIGNED_INT(v557 * COERCE_FLOAT(bswap32(*v41))));
              }
              uint64_t v558 = &v41[v644];
              if ((unint64_t)v558 >= v64) {
                uint64_t v559 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v559 = 0;
              }
              v61 += 4 * v559;
              float v41 = &v558[v559];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v556;
            }
            while (v556);
            if (v662)
            {
              uint64_t v560 = &v70[v666];
              if (v560 >= v662) {
                uint64_t v561 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v561 = 0;
              }
              v71 += 4 * v664 + 4 * v561;
              if (v560 >= v662) {
                uint64_t v562 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v562 = 0;
              }
              uint64_t v70 = &v560[v562];
              v64 += 4 * v562 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 4:
        do
        {
          int v258 = v684[0];
          do
          {
            float v259 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            if (v259 <= 0.0)
            {
              *(_DWORD *)float v62 = 0;
              *float v72 = 0;
            }
            else if (v259 >= 1.0)
            {
              if (v44) {
                unsigned int v261 = bswap32(*(_DWORD *)v61);
              }
              else {
                unsigned int v261 = 1065353216;
              }
              *(_DWORD *)float v62 = bswap32(v261);
            }
            else
            {
              if (v44) {
                float v260 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              }
              else {
                float v260 = 1.0;
              }
              *float v72 = bswap32(COERCE_UNSIGNED_INT(v259 * COERCE_FLOAT(bswap32(*v41))));
              *(_DWORD *)float v62 = bswap32(COERCE_UNSIGNED_INT(v259 * v260));
            }
            float v262 = &v41[v644];
            if ((unint64_t)v262 >= v64) {
              uint64_t v263 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v263 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v263;
            float v41 = &v262[v263];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v258;
          }
          while (v258);
          if (v662)
          {
            double v264 = &v70[v666];
            if (v264 >= v662) {
              uint64_t v265 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v265 = 0;
            }
            v71 += 4 * v664 + 4 * v265;
            if (v264 >= v662) {
              uint64_t v266 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v266 = 0;
            }
            uint64_t v70 = &v264[v266];
            v64 += 4 * v266 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 5:
        do
        {
          int v267 = v684[0];
          do
          {
            float v268 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            float v269 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
            *float v72 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v269) * COERCE_FLOAT(bswap32(*v72)))+ (float)(COERCE_FLOAT(bswap32(*v41)) * v268)));
            *(_DWORD *)float v62 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v269) * v268) + (float)(v269 * v268)));
            float v270 = &v41[v644];
            if ((unint64_t)v270 >= v64) {
              uint64_t v271 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v271 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v271;
            float v41 = &v270[v271];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v267;
          }
          while (v267);
          if (v662)
          {
            float v272 = &v70[v666];
            if (v272 >= v662) {
              uint64_t v273 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v273 = 0;
            }
            v71 += 4 * v664 + 4 * v273;
            if (v272 >= v662) {
              uint64_t v274 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v274 = 0;
            }
            uint64_t v70 = &v272[v274];
            v64 += 4 * v274 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 6:
        while (1)
        {
          int v275 = v684[0];
          do
          {
            float v276 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            float v277 = 1.0 - v276;
            if ((float)(1.0 - v276) >= 1.0)
            {
              unsigned int v279 = *v41;
              if (v44) {
                float v280 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              }
              else {
                float v280 = 1.0;
              }
            }
            else
            {
              if (v277 <= 0.0) {
                goto LABEL_547;
              }
              if (v44) {
                float v278 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              }
              else {
                float v278 = 1.0;
              }
              unsigned int v279 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v72)) + (float)(COERCE_FLOAT(bswap32(*v41)) * v277)));
              float v280 = v276 + (float)(v278 * v277);
            }
            *float v72 = v279;
            *(_DWORD *)float v62 = bswap32(LODWORD(v280));
LABEL_547:
            float v281 = &v41[v644];
            if ((unint64_t)v281 >= v64) {
              uint64_t v282 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v282 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v282;
            float v41 = &v281[v282];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v275;
          }
          while (v275);
          if (v662)
          {
            float v283 = &v70[v666];
            if (v283 >= v662) {
              uint64_t v284 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v284 = 0;
            }
            v71 += 4 * v664 + 4 * v284;
            if (v283 >= v662) {
              uint64_t v285 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v285 = 0;
            }
            uint64_t v70 = &v283[v285];
            v64 += 4 * v285 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
          {
LABEL_1266:
            int v650 = v70;
            uint64_t v651 = v71;
            uint64_t v58 = v64;
            float v41 = (unsigned int *)v647;
LABEL_1267:
            uint64_t v60 = v646;
            if (!v646) {
              return 1;
            }
LABEL_1268:
            uint64_t v673 = 0;
LABEL_417:
            if (!shape_enum_clip_next(v60, (int *)&v673 + 1, &v673, v684, v674))
            {
              float v179 = (void *)v60;
LABEL_1082:
              free(v179);
              return 1;
            }
            uint64_t v646 = v60;
            uint64_t v647 = (uint64_t)v41;
            if (v662)
            {
              float v72 = &v641[v29 * (int)v673 + SHIDWORD(v673)];
              int v218 = ((int)v673 + *(_DWORD *)(v11 + 60)) % v645;
              unint64_t v63 = v684[0];
              int v219 = (HIDWORD(v673) + *(_DWORD *)(v11 + 56)) % (int)v45;
              float v220 = &v41[v666 * v218];
              uint64_t v70 = &v220[v219];
              unint64_t v64 = (unint64_t)&v220[(int)v45];
              uint64_t v30 = v672;
              if (v672) {
                float v62 = &v643[4 * v642 * (int)v673 + 4 * SHIDWORD(v673)];
              }
              unint64_t v221 = v668;
              if (v672) {
                unint64_t v221 = v642 - v684[0];
              }
              unint64_t v668 = v221;
              if (v670) {
                uint64_t v44 = v670;
              }
              else {
                uint64_t v44 = 0;
              }
              uint64_t v71 = v651;
              if (v670)
              {
                uint64_t v71 = (uint64_t)&v7[v664 * v218 + v219];
                float v61 = (char *)v71;
              }
              LODWORD(v12) = v684[0];
              float v41 = &v220[v219];
              int v639 = (HIDWORD(v673) + *(_DWORD *)(v11 + 56)) % (int)v45;
              int v640 = ((int)v673 + *(_DWORD *)(v11 + 60)) % v645;
            }
            else
            {
              uint64_t v662 = 0;
              int v222 = HIDWORD(v673) * v644;
              LODWORD(v12) = v684[0];
              int v223 = v684[0] * v644;
              float v72 = &v641[v29 * (int)v673 + HIDWORD(v673) * v644];
              unint64_t v63 = v684[0] * v644;
              v41 += (int)v673 * (int)v45 + HIDWORD(v673) * v644;
              unint64_t v666 = (int)v45 - v684[0] * v644;
              uint64_t v44 = v670;
              uint64_t v30 = v672;
              if (v672) {
                float v62 = &v643[4 * v642 * (int)v673 + 4 * v222];
              }
              unint64_t v224 = v668;
              if (v672) {
                unint64_t v224 = v642 - v223;
              }
              unint64_t v668 = v224;
              uint64_t v225 = (uint64_t)&v7[(int)v673 * v645 + v222];
              unint64_t v226 = v645 - v223;
              if (v670) {
                float v61 = (char *)v225;
              }
              unint64_t v227 = v664;
              if (v670) {
                unint64_t v227 = v226;
              }
              unint64_t v664 = v227;
              unint64_t v64 = v58;
              uint64_t v70 = v650;
              uint64_t v71 = v651;
            }
            goto LABEL_438;
          }
        }
      case 7:
        if (v30)
        {
          do
          {
            int v286 = v684[0];
            do
            {
              float v287 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v287 <= 0.0)
              {
                *(_DWORD *)float v62 = 0;
                *float v72 = 0;
              }
              else if (v287 < 1.0)
              {
                unsigned int v288 = bswap32(COERCE_UNSIGNED_INT(v287 * COERCE_FLOAT(bswap32(*(_DWORD *)v62))));
                *float v72 = bswap32(COERCE_UNSIGNED_INT(v287 * COERCE_FLOAT(bswap32(*v72))));
                *(_DWORD *)float v62 = v288;
              }
              int v289 = &v41[v644];
              if ((unint64_t)v289 >= v64) {
                uint64_t v290 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v290 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v290;
              float v41 = &v289[v290];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v286;
            }
            while (v286);
            if (v662)
            {
              unsigned int v291 = &v70[v666];
              if (v291 >= v662) {
                uint64_t v292 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v292 = 0;
              }
              v71 += 4 * v664 + 4 * v292;
              if (v291 >= v662) {
                uint64_t v293 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v293 = 0;
              }
              uint64_t v70 = &v291[v293];
              v64 += 4 * v293 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            int v563 = v684[0];
            do
            {
              float v564 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v564 <= 0.0)
              {
                *float v72 = 0;
              }
              else if (v564 < 1.0)
              {
                *float v72 = bswap32(COERCE_UNSIGNED_INT(v564 * COERCE_FLOAT(bswap32(*v72))));
              }
              float v565 = &v41[v644];
              if ((unint64_t)v565 >= v64) {
                uint64_t v566 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v566 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v566;
              float v41 = &v565[v566];
              v72 += v644;
              --v563;
            }
            while (v563);
            if (v662)
            {
              float v567 = &v70[v666];
              if (v567 >= v662) {
                uint64_t v568 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v568 = 0;
              }
              v71 += 4 * v664 + 4 * v568;
              if (v567 >= v662) {
                uint64_t v569 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v569 = 0;
              }
              uint64_t v70 = &v567[v569];
              v64 += 4 * v569 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 8:
        if (v30)
        {
          do
          {
            int v294 = v684[0];
            do
            {
              float v295 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v295 <= 0.0)
              {
                *(_DWORD *)float v62 = 0;
                *float v72 = 0;
              }
              else if (v295 < 1.0)
              {
                unsigned int v296 = bswap32(COERCE_UNSIGNED_INT(v295 * COERCE_FLOAT(bswap32(*(_DWORD *)v62))));
                *float v72 = bswap32(COERCE_UNSIGNED_INT(v295 * COERCE_FLOAT(bswap32(*v72))));
                *(_DWORD *)float v62 = v296;
              }
              float v297 = &v41[v644];
              if ((unint64_t)v297 >= v64) {
                uint64_t v298 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v298 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v298;
              float v41 = &v297[v298];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v294;
            }
            while (v294);
            if (v662)
            {
              float v299 = &v70[v666];
              if (v299 >= v662) {
                uint64_t v300 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v300 = 0;
              }
              v71 += 4 * v664 + 4 * v300;
              if (v299 >= v662) {
                uint64_t v301 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v301 = 0;
              }
              uint64_t v70 = &v299[v301];
              v64 += 4 * v301 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            int v570 = v684[0];
            do
            {
              float v571 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v571 <= 0.0)
              {
                *float v72 = 0;
              }
              else if (v571 < 1.0)
              {
                *float v72 = bswap32(COERCE_UNSIGNED_INT(v571 * COERCE_FLOAT(bswap32(*v72))));
              }
              int v572 = &v41[v644];
              if ((unint64_t)v572 >= v64) {
                uint64_t v573 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v573 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v573;
              float v41 = &v572[v573];
              v72 += v644;
              --v570;
            }
            while (v570);
            if (v662)
            {
              uint64_t v574 = &v70[v666];
              if (v574 >= v662) {
                uint64_t v575 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v575 = 0;
              }
              v71 += 4 * v664 + 4 * v575;
              if (v574 >= v662) {
                uint64_t v576 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v576 = 0;
              }
              uint64_t v70 = &v574[v576];
              v64 += 4 * v576 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 9:
        do
        {
          int v302 = v684[0];
          do
          {
            float v303 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            float v304 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
            *float v72 = bswap32(COERCE_UNSIGNED_INT((float)(v304 * COERCE_FLOAT(bswap32(*v72)))+ (float)(COERCE_FLOAT(bswap32(*v41)) * (float)(1.0 - v303))));
            *(_DWORD *)float v62 = bswap32(COERCE_UNSIGNED_INT((float)(v303 * v304) + (float)(v304 * (float)(1.0 - v303))));
            unsigned int v305 = &v41[v644];
            if ((unint64_t)v305 >= v64) {
              uint64_t v306 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v306 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v306;
            float v41 = &v305[v306];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v302;
          }
          while (v302);
          if (v662)
          {
            float v307 = &v70[v666];
            if (v307 >= v662) {
              uint64_t v308 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v308 = 0;
            }
            v71 += 4 * v664 + 4 * v308;
            if (v307 >= v662) {
              uint64_t v309 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v309 = 0;
            }
            uint64_t v70 = &v307[v309];
            v64 += 4 * v309 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 10:
        do
        {
          int v310 = v684[0];
          do
          {
            float v311 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            float v312 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
            *float v72 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v312) * COERCE_FLOAT(bswap32(*v72)))+ (float)(COERCE_FLOAT(bswap32(*v41)) * (float)(1.0 - v311))));
            *(_DWORD *)float v62 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v312) * v311) + (float)(v312 * (float)(1.0 - v311))));
            unsigned int v313 = &v41[v644];
            if ((unint64_t)v313 >= v64) {
              uint64_t v314 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v314 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v314;
            float v41 = &v313[v314];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v310;
          }
          while (v310);
          if (v662)
          {
            float v315 = &v70[v666];
            if (v315 >= v662) {
              uint64_t v316 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v316 = 0;
            }
            v71 += 4 * v664 + 4 * v316;
            if (v315 >= v662) {
              uint64_t v317 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v317 = 0;
            }
            uint64_t v70 = &v315[v317];
            v64 += 4 * v317 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 11:
        if (v30)
        {
          do
          {
            int v318 = v684[0];
            do
            {
              if (v44) {
                float v319 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              }
              else {
                float v319 = 1.0;
              }
              float v320 = COERCE_FLOAT(bswap32(*v72));
              float v321 = COERCE_FLOAT(bswap32(*v41));
              float v322 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              float v323 = v319 + v322;
              if ((float)(v319 + v322) > 1.0) {
                float v323 = 1.0;
              }
              *float v72 = bswap32(COERCE_UNSIGNED_INT((float)(v319 - v321) + (float)(v323 - (float)(v322 - v320))));
              *(_DWORD *)float v62 = bswap32(LODWORD(v323));
              unsigned int v324 = &v41[v644];
              if ((unint64_t)v324 >= v64) {
                uint64_t v325 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v325 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v325;
              float v41 = &v324[v325];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v318;
            }
            while (v318);
            if (v662)
            {
              float v326 = &v70[v666];
              if (v326 >= v662) {
                uint64_t v327 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v327 = 0;
              }
              v71 += 4 * v664 + 4 * v327;
              if (v326 >= v662) {
                uint64_t v328 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v328 = 0;
              }
              uint64_t v70 = &v326[v328];
              v64 += 4 * v328 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            int v577 = v684[0];
            do
            {
              if (v44) {
                float v578 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              }
              else {
                float v578 = 1.0;
              }
              *float v72 = bswap32(COERCE_UNSIGNED_INT((float)(v578 - COERCE_FLOAT(bswap32(*v41))) + COERCE_FLOAT(bswap32(*v72))));
              unsigned int v579 = &v41[v644];
              if ((unint64_t)v579 >= v64) {
                uint64_t v580 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v580 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v580;
              float v41 = &v579[v580];
              v72 += v644;
              --v577;
            }
            while (v577);
            if (v662)
            {
              uint64_t v581 = &v70[v666];
              if (v581 >= v662) {
                uint64_t v582 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v582 = 0;
              }
              v71 += 4 * v664 + 4 * v582;
              if (v581 >= v662) {
                uint64_t v583 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v583 = 0;
              }
              uint64_t v70 = &v581[v583];
              v64 += 4 * v583 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 12:
        if (v30)
        {
          do
          {
            int v329 = v684[0];
            do
            {
              if (v44) {
                float v330 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              }
              else {
                float v330 = 1.0;
              }
              float v331 = v330 + COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              float v332 = COERCE_FLOAT(bswap32(*v72)) + COERCE_FLOAT(bswap32(*v41));
              if (v331 > 1.0) {
                float v331 = 1.0;
              }
              *float v72 = bswap32(LODWORD(v332));
              *(_DWORD *)float v62 = bswap32(LODWORD(v331));
              int v333 = &v41[v644];
              if ((unint64_t)v333 >= v64) {
                uint64_t v334 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v334 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v334;
              float v41 = &v333[v334];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v329;
            }
            while (v329);
            if (v662)
            {
              unsigned int v335 = &v70[v666];
              if (v335 >= v662) {
                uint64_t v336 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v336 = 0;
              }
              v71 += 4 * v664 + 4 * v336;
              if (v335 >= v662) {
                uint64_t v337 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v337 = 0;
              }
              uint64_t v70 = &v335[v337];
              v64 += 4 * v337 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            int v584 = v684[0];
            do
            {
              *float v72 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v72)) + COERCE_FLOAT(bswap32(*v41))));
              int v585 = &v41[v644];
              if ((unint64_t)v585 >= v64) {
                uint64_t v586 = -(uint64_t)(int)v45;
              }
              else {
                uint64_t v586 = 0;
              }
              v61 += 4 * (int)v44 + 4 * v586;
              float v41 = &v585[v586];
              v72 += v644;
              --v584;
            }
            while (v584);
            if (v662)
            {
              float v587 = &v70[v666];
              if (v587 >= v662) {
                uint64_t v588 = -(uint64_t)(v664 * v645);
              }
              else {
                uint64_t v588 = 0;
              }
              v71 += 4 * v664 + 4 * v588;
              if (v587 >= v662) {
                uint64_t v589 = -(uint64_t)(v666 * v645);
              }
              else {
                uint64_t v589 = 0;
              }
              uint64_t v70 = &v587[v589];
              v64 += 4 * v589 + 4 * v666;
              float v61 = (char *)v71;
              float v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 13:
        while (1)
        {
          int v338 = v684[0];
          do
          {
            float v339 = 1.0;
            float v340 = 1.0;
            if (v44)
            {
              float v340 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v340 <= 0.0) {
                goto LABEL_694;
              }
            }
            if (v30)
            {
              float v339 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v339 <= 0.0)
              {
                unsigned int v345 = *v41;
                goto LABEL_692;
              }
            }
            float v341 = COERCE_FLOAT(bswap32(*v72));
            float v342 = COERCE_FLOAT(bswap32(*v41));
            float v343 = v341 * v342;
            float v344 = (float)(v341 * v342) + (float)(v341 * (float)(1.0 - v340));
            if (v340 == 1.0) {
              float v344 = v343;
            }
            if (v339 != 1.0) {
              float v344 = v344 + (float)(v342 * (float)(1.0 - v339));
            }
            if (v30)
            {
              float v340 = (float)(v340 + v339) - (float)(v339 * v340);
              unsigned int v345 = bswap32(LODWORD(v344));
LABEL_692:
              *float v72 = v345;
              *(_DWORD *)float v62 = bswap32(LODWORD(v340));
              goto LABEL_694;
            }
            *float v72 = bswap32(LODWORD(v344));
LABEL_694:
            unsigned int v346 = &v41[v644];
            if ((unint64_t)v346 >= v64) {
              uint64_t v347 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v347 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v347;
            float v41 = &v346[v347];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v338;
          }
          while (v338);
          if (v662)
          {
            float v348 = &v70[v666];
            if (v348 >= v662) {
              uint64_t v349 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v349 = 0;
            }
            v71 += 4 * v664 + 4 * v349;
            if (v348 >= v662) {
              uint64_t v350 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v350 = 0;
            }
            uint64_t v70 = &v348[v350];
            v64 += 4 * v350 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 14:
        while (1)
        {
          int v351 = v684[0];
          do
          {
            float v352 = 1.0;
            float v353 = 1.0;
            if (v44)
            {
              float v353 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v353 <= 0.0) {
                goto LABEL_719;
              }
            }
            if (v30)
            {
              float v352 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v352 <= 0.0)
              {
                unsigned int v356 = *v41;
                goto LABEL_717;
              }
            }
            float v354 = COERCE_FLOAT(bswap32(*v72));
            float v355 = v354 + (float)(COERCE_FLOAT(bswap32(*v41)) * (float)(1.0 - v354));
            if (v30)
            {
              float v353 = (float)(v353 + v352) - (float)(v352 * v353);
              unsigned int v356 = bswap32(LODWORD(v355));
LABEL_717:
              *float v72 = v356;
              *(_DWORD *)float v62 = bswap32(LODWORD(v353));
              goto LABEL_719;
            }
            *float v72 = bswap32(LODWORD(v355));
LABEL_719:
            unsigned int v357 = &v41[v644];
            if ((unint64_t)v357 >= v64) {
              uint64_t v358 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v358 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v358;
            float v41 = &v357[v358];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v351;
          }
          while (v351);
          if (v662)
          {
            unsigned __int8 v359 = &v70[v666];
            if (v359 >= v662) {
              uint64_t v360 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v360 = 0;
            }
            v71 += 4 * v664 + 4 * v360;
            if (v359 >= v662) {
              uint64_t v361 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v361 = 0;
            }
            uint64_t v70 = &v359[v361];
            v64 += 4 * v361 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 15:
        int v650 = v70;
        uint64_t v651 = v71;
        unint64_t v637 = v29;
        unint64_t v631 = v45;
        float v633 = v7;
        uint64_t v362 = (int)v44;
        uint64_t v363 = 4 * (int)v30;
        uint64_t v364 = -(uint64_t)(int)v45;
        *(void *)uint64_t v654 = v364;
        do
        {
          int v365 = v684[0];
          do
          {
            float v366 = 1.0;
            float v367 = 1.0;
            if (!v44 || (float v367 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v367 > 0.0))
            {
              if (v30 && (float v366 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v366 <= 0.0))
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = bswap32(LODWORD(v367));
              }
              else
              {
                uint64_t v368 = v363;
                unint64_t v369 = v64;
                float v370 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v72)), v366, COERCE_FLOAT(bswap32(*v41)), v367);
                LODWORD(v30) = v672;
                *float v72 = bswap32(LODWORD(v370));
                if (v672) {
                  *(_DWORD *)float v62 = bswap32(v371);
                }
                LODWORD(v44) = v670;
                unint64_t v64 = v369;
                uint64_t v363 = v368;
                uint64_t v364 = *(void *)v654;
              }
            }
            unsigned int v372 = &v41[v644];
            if ((unint64_t)v372 >= v64) {
              uint64_t v373 = v364;
            }
            else {
              uint64_t v373 = 0;
            }
            v61 += 4 * v362 + 4 * v373;
            float v41 = &v372[v373];
            v62 += v363;
            v72 += v644;
            --v365;
          }
          while (v365);
          if (v662)
          {
            float v374 = &v650[v666];
            uint64_t v375 = -(uint64_t)(v664 * v645);
            if (v374 < v662) {
              uint64_t v375 = 0;
            }
            float v61 = (char *)(v651 + 4 * v664 + 4 * v375);
            uint64_t v376 = -(uint64_t)(v666 * v645);
            if (v374 < v662) {
              uint64_t v376 = 0;
            }
            float v41 = &v374[v376];
            v64 += 4 * v376 + 4 * v666;
            int v650 = v41;
            v651 += 4 * v664 + 4 * v375;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 16:
        while (1)
        {
          int v377 = v684[0];
          do
          {
            float v378 = 1.0;
            float v379 = 1.0;
            if (v44)
            {
              float v379 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v379 <= 0.0) {
                goto LABEL_773;
              }
            }
            if (v30)
            {
              float v378 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v378 <= 0.0)
              {
                unsigned int v384 = *v41;
                goto LABEL_771;
              }
            }
            float v380 = COERCE_FLOAT(bswap32(*v72));
            float v381 = COERCE_FLOAT(bswap32(*v41));
            float v382 = v379 * v380;
            if ((float)(v378 * v381) < (float)(v379 * v380)) {
              float v382 = v378 * v381;
            }
            float v383 = v382 + (float)(v380 * (float)(1.0 - v379));
            if (v379 == 1.0) {
              float v383 = v382;
            }
            if (v378 != 1.0) {
              float v383 = v383 + (float)(v381 * (float)(1.0 - v378));
            }
            if (v30)
            {
              float v379 = (float)(v379 + v378) - (float)(v378 * v379);
              unsigned int v384 = bswap32(LODWORD(v383));
LABEL_771:
              *float v72 = v384;
              *(_DWORD *)float v62 = bswap32(LODWORD(v379));
              goto LABEL_773;
            }
            *float v72 = bswap32(LODWORD(v383));
LABEL_773:
            float v385 = &v41[v644];
            if ((unint64_t)v385 >= v64) {
              uint64_t v386 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v386 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v386;
            float v41 = &v385[v386];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v377;
          }
          while (v377);
          if (v662)
          {
            unsigned __int8 v387 = &v70[v666];
            if (v387 >= v662) {
              uint64_t v388 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v388 = 0;
            }
            v71 += 4 * v664 + 4 * v388;
            if (v387 >= v662) {
              uint64_t v389 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v389 = 0;
            }
            uint64_t v70 = &v387[v389];
            v64 += 4 * v389 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 17:
        while (1)
        {
          int v390 = v684[0];
          do
          {
            float v391 = 1.0;
            float v392 = 1.0;
            if (v44)
            {
              float v392 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v392 <= 0.0) {
                goto LABEL_804;
              }
            }
            if (v30)
            {
              float v391 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v391 <= 0.0)
              {
                unsigned int v397 = *v41;
                goto LABEL_802;
              }
            }
            float v393 = COERCE_FLOAT(bswap32(*v72));
            float v394 = COERCE_FLOAT(bswap32(*v41));
            float v395 = v392 * v393;
            if ((float)(v391 * v394) > (float)(v392 * v393)) {
              float v395 = v391 * v394;
            }
            float v396 = v395 + (float)(v393 * (float)(1.0 - v392));
            if (v392 == 1.0) {
              float v396 = v395;
            }
            if (v391 != 1.0) {
              float v396 = v396 + (float)(v394 * (float)(1.0 - v391));
            }
            if (v30)
            {
              float v392 = (float)(v392 + v391) - (float)(v391 * v392);
              unsigned int v397 = bswap32(LODWORD(v396));
LABEL_802:
              *float v72 = v397;
              *(_DWORD *)float v62 = bswap32(LODWORD(v392));
              goto LABEL_804;
            }
            *float v72 = bswap32(LODWORD(v396));
LABEL_804:
            uint64_t v398 = &v41[v644];
            if ((unint64_t)v398 >= v64) {
              uint64_t v399 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v399 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v399;
            float v41 = &v398[v399];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v390;
          }
          while (v390);
          if (v662)
          {
            uint64_t v400 = &v70[v666];
            if (v400 >= v662) {
              uint64_t v401 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v401 = 0;
            }
            v71 += 4 * v664 + 4 * v401;
            if (v400 >= v662) {
              uint64_t v402 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v402 = 0;
            }
            uint64_t v70 = &v400[v402];
            v64 += 4 * v402 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 18:
        int v650 = v70;
        uint64_t v651 = v71;
        unint64_t v637 = v29;
        unint64_t v631 = v45;
        float v633 = v7;
        uint64_t v403 = (int)v44;
        uint64_t v404 = 4 * (int)v30;
        uint64_t v405 = -(uint64_t)(int)v45;
        *(void *)int v655 = v405;
        do
        {
          int v406 = v684[0];
          do
          {
            float v407 = 1.0;
            float v408 = 1.0;
            if (!v44 || (float v408 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v408 > 0.0))
            {
              if (v30 && (float v407 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v407 <= 0.0))
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = bswap32(LODWORD(v408));
              }
              else
              {
                uint64_t v409 = v404;
                unint64_t v410 = v64;
                float v411 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v72)), v407, COERCE_FLOAT(bswap32(*v41)), v408);
                LODWORD(v30) = v672;
                *float v72 = bswap32(LODWORD(v411));
                if (v672) {
                  *(_DWORD *)float v62 = bswap32(v412);
                }
                LODWORD(v44) = v670;
                unint64_t v64 = v410;
                uint64_t v404 = v409;
                uint64_t v405 = *(void *)v655;
              }
            }
            float v413 = &v41[v644];
            if ((unint64_t)v413 >= v64) {
              uint64_t v414 = v405;
            }
            else {
              uint64_t v414 = 0;
            }
            v61 += 4 * v403 + 4 * v414;
            float v41 = &v413[v414];
            v62 += v404;
            v72 += v644;
            --v406;
          }
          while (v406);
          if (v662)
          {
            float v415 = &v650[v666];
            uint64_t v416 = -(uint64_t)(v664 * v645);
            if (v415 < v662) {
              uint64_t v416 = 0;
            }
            float v61 = (char *)(v651 + 4 * v664 + 4 * v416);
            uint64_t v417 = -(uint64_t)(v666 * v645);
            if (v415 < v662) {
              uint64_t v417 = 0;
            }
            float v41 = &v415[v417];
            v64 += 4 * v417 + 4 * v666;
            int v650 = v41;
            v651 += 4 * v664 + 4 * v416;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 19:
        int v650 = v70;
        uint64_t v651 = v71;
        unint64_t v637 = v29;
        unint64_t v631 = v45;
        float v633 = v7;
        uint64_t v418 = (int)v44;
        uint64_t v419 = 4 * (int)v30;
        uint64_t v420 = -(uint64_t)(int)v45;
        *(void *)int v656 = v420;
        do
        {
          int v421 = v684[0];
          do
          {
            float v422 = 1.0;
            float v423 = 1.0;
            if (!v44 || (float v423 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v423 > 0.0))
            {
              if (v30 && (float v422 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v422 <= 0.0))
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = bswap32(LODWORD(v423));
              }
              else
              {
                uint64_t v424 = v419;
                unint64_t v425 = v64;
                double v426 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v72)), v422, COERCE_FLOAT(bswap32(*v41)), v423);
                LODWORD(v30) = v672;
                *float v72 = bswap32(LODWORD(v426));
                if (v672) {
                  *(_DWORD *)float v62 = bswap32(v427);
                }
                LODWORD(v44) = v670;
                unint64_t v64 = v425;
                uint64_t v419 = v424;
                uint64_t v420 = *(void *)v656;
              }
            }
            uint64_t v428 = &v41[v644];
            if ((unint64_t)v428 >= v64) {
              uint64_t v429 = v420;
            }
            else {
              uint64_t v429 = 0;
            }
            v61 += 4 * v418 + 4 * v429;
            float v41 = &v428[v429];
            v62 += v419;
            v72 += v644;
            --v421;
          }
          while (v421);
          if (v662)
          {
            int v430 = &v650[v666];
            uint64_t v431 = -(uint64_t)(v664 * v645);
            if (v430 < v662) {
              uint64_t v431 = 0;
            }
            float v61 = (char *)(v651 + 4 * v664 + 4 * v431);
            uint64_t v432 = -(uint64_t)(v666 * v645);
            if (v430 < v662) {
              uint64_t v432 = 0;
            }
            float v41 = &v430[v432];
            v64 += 4 * v432 + 4 * v666;
            int v650 = v41;
            v651 += 4 * v664 + 4 * v431;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 20:
        int v650 = v70;
        uint64_t v651 = v71;
        unint64_t v637 = v29;
        unint64_t v631 = v45;
        float v633 = v7;
        uint64_t v433 = (int)v44;
        uint64_t v434 = 4 * (int)v30;
        uint64_t v435 = -(uint64_t)(int)v45;
        *(void *)uint64_t v657 = v435;
        do
        {
          int v436 = v684[0];
          do
          {
            float v437 = 1.0;
            float v438 = 1.0;
            if (!v44 || (float v438 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v438 > 0.0))
            {
              if (v30 && (float v437 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v437 <= 0.0))
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = bswap32(LODWORD(v438));
              }
              else
              {
                uint64_t v439 = v434;
                unint64_t v440 = v64;
                float v441 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v72)), v437, COERCE_FLOAT(bswap32(*v41)), v438);
                LODWORD(v30) = v672;
                *float v72 = bswap32(LODWORD(v441));
                if (v672) {
                  *(_DWORD *)float v62 = bswap32(v442);
                }
                LODWORD(v44) = v670;
                unint64_t v64 = v440;
                uint64_t v434 = v439;
                uint64_t v435 = *(void *)v657;
              }
            }
            uint64_t v443 = &v41[v644];
            if ((unint64_t)v443 >= v64) {
              uint64_t v444 = v435;
            }
            else {
              uint64_t v444 = 0;
            }
            v61 += 4 * v433 + 4 * v444;
            float v41 = &v443[v444];
            v62 += v434;
            v72 += v644;
            --v436;
          }
          while (v436);
          if (v662)
          {
            uint64_t v445 = &v650[v666];
            uint64_t v446 = -(uint64_t)(v664 * v645);
            if (v445 < v662) {
              uint64_t v446 = 0;
            }
            float v61 = (char *)(v651 + 4 * v664 + 4 * v446);
            uint64_t v447 = -(uint64_t)(v666 * v645);
            if (v445 < v662) {
              uint64_t v447 = 0;
            }
            float v41 = &v445[v447];
            v64 += 4 * v447 + 4 * v666;
            int v650 = v41;
            v651 += 4 * v664 + 4 * v446;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 21:
        int v650 = v70;
        uint64_t v651 = v71;
        unint64_t v637 = v29;
        unint64_t v631 = v45;
        float v633 = v7;
        uint64_t v448 = (int)v44;
        uint64_t v449 = 4 * (int)v30;
        uint64_t v450 = -(uint64_t)(int)v45;
        *(void *)uint64_t v658 = v450;
        do
        {
          int v451 = v684[0];
          do
          {
            float v452 = 1.0;
            float v453 = 1.0;
            if (!v44 || (float v453 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v453 > 0.0))
            {
              if (v30 && (float v452 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v452 <= 0.0))
              {
                *float v72 = *v41;
                *(_DWORD *)float v62 = bswap32(LODWORD(v453));
              }
              else
              {
                uint64_t v454 = v449;
                unint64_t v455 = v64;
                float v456 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v72)), v452, COERCE_FLOAT(bswap32(*v41)), v453);
                LODWORD(v30) = v672;
                *float v72 = bswap32(LODWORD(v456));
                if (v672) {
                  *(_DWORD *)float v62 = bswap32(v457);
                }
                LODWORD(v44) = v670;
                unint64_t v64 = v455;
                uint64_t v449 = v454;
                uint64_t v450 = *(void *)v658;
              }
            }
            float v458 = &v41[v644];
            if ((unint64_t)v458 >= v64) {
              uint64_t v459 = v450;
            }
            else {
              uint64_t v459 = 0;
            }
            v61 += 4 * v448 + 4 * v459;
            float v41 = &v458[v459];
            v62 += v449;
            v72 += v644;
            --v451;
          }
          while (v451);
          if (v662)
          {
            float v460 = &v650[v666];
            uint64_t v461 = -(uint64_t)(v664 * v645);
            if (v460 < v662) {
              uint64_t v461 = 0;
            }
            float v61 = (char *)(v651 + 4 * v664 + 4 * v461);
            uint64_t v462 = -(uint64_t)(v666 * v645);
            if (v460 < v662) {
              uint64_t v462 = 0;
            }
            float v41 = &v460[v462];
            v64 += 4 * v462 + 4 * v666;
            int v650 = v41;
            v651 += 4 * v664 + 4 * v461;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
LABEL_910:
        uint64_t v58 = v64;
        float v7 = v633;
        LODWORD(v9) = v634;
        unint64_t v29 = v637;
        uint64_t v11 = v638;
        float v41 = (unsigned int *)v647;
        unint64_t v45 = v631;
        goto LABEL_1267;
      case 22:
        while (1)
        {
          int v463 = v684[0];
          do
          {
            float v464 = 1.0;
            float v465 = 1.0;
            if (v44)
            {
              float v465 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v465 <= 0.0) {
                goto LABEL_923;
              }
            }
            if (v30)
            {
              float v464 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v464 <= 0.0)
              {
                unsigned int v473 = *v41;
                goto LABEL_921;
              }
            }
            float v466 = COERCE_FLOAT(bswap32(*v72));
            float v467 = COERCE_FLOAT(bswap32(*v41));
            float v468 = v466 + v467;
            float v469 = v465 * v466;
            float v470 = v468 - v469;
            float v471 = v469 - (float)(v464 * v467);
            if (v471 < 0.0) {
              float v471 = -v471;
            }
            float v472 = (float)(v470 - (float)(v464 * v467)) + v471;
            if (v30)
            {
              float v465 = (float)(v465 + v464) - (float)(v464 * v465);
              unsigned int v473 = bswap32(LODWORD(v472));
LABEL_921:
              *float v72 = v473;
              *(_DWORD *)float v62 = bswap32(LODWORD(v465));
              goto LABEL_923;
            }
            *float v72 = bswap32(LODWORD(v472));
LABEL_923:
            uint64_t v474 = &v41[v644];
            if ((unint64_t)v474 >= v64) {
              uint64_t v475 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v475 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v475;
            float v41 = &v474[v475];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v463;
          }
          while (v463);
          if (v662)
          {
            uint64_t v476 = &v70[v666];
            if (v476 >= v662) {
              uint64_t v477 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v477 = 0;
            }
            v71 += 4 * v664 + 4 * v477;
            if (v476 >= v662) {
              uint64_t v478 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v478 = 0;
            }
            uint64_t v70 = &v476[v478];
            v64 += 4 * v478 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 23:
        while (1)
        {
          int v479 = v684[0];
          do
          {
            float v480 = 1.0;
            float v481 = 1.0;
            if (v44)
            {
              float v481 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v481 <= 0.0) {
                goto LABEL_948;
              }
            }
            if (v30)
            {
              float v480 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v480 <= 0.0)
              {
                unsigned int v485 = *v41;
                goto LABEL_946;
              }
            }
            float v482 = COERCE_FLOAT(bswap32(*v72));
            float v483 = COERCE_FLOAT(bswap32(*v41));
            float v484 = (float)(v482 + v483) + (float)((float)(v482 * v483) * -2.0);
            if (v30)
            {
              float v481 = (float)(v481 + v480) - (float)(v480 * v481);
              unsigned int v485 = bswap32(LODWORD(v484));
LABEL_946:
              *float v72 = v485;
              *(_DWORD *)float v62 = bswap32(LODWORD(v481));
              goto LABEL_948;
            }
            *float v72 = bswap32(LODWORD(v484));
LABEL_948:
            int v486 = &v41[v644];
            if ((unint64_t)v486 >= v64) {
              uint64_t v487 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v487 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v487;
            float v41 = &v486[v487];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v479;
          }
          while (v479);
          if (v662)
          {
            v488 = &v70[v666];
            if (v488 >= v662) {
              uint64_t v489 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v489 = 0;
            }
            v71 += 4 * v664 + 4 * v489;
            if (v488 >= v662) {
              uint64_t v490 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v490 = 0;
            }
            uint64_t v70 = &v488[v490];
            v64 += 4 * v490 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 24:
        while (1)
        {
          int v491 = v684[0];
          do
          {
            float v492 = 1.0;
            float v493 = 1.0;
            if (v44)
            {
              float v493 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v493 <= 0.0) {
                goto LABEL_978;
              }
            }
            if (v30)
            {
              float v492 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v492 <= 0.0)
              {
                unsigned int v500 = *v41;
                goto LABEL_976;
              }
            }
            float v494 = COERCE_FLOAT(bswap32(*v72));
            float v495 = COERCE_FLOAT(bswap32(*v41));
            float v496 = v494 - (float)(v493 * v494);
            if (v493 == 1.0)
            {
              float v497 = 0.0;
            }
            else
            {
              float v494 = v493 * v494;
              float v497 = v496;
            }
            float v498 = (float)(v497 + v495) - (float)(v492 * v495);
            if (v492 == 1.0) {
              float v498 = v497;
            }
            float v499 = v494 + v498;
            if (v30)
            {
              float v493 = (float)(v493 + v492) - (float)(v493 * v492);
              unsigned int v500 = bswap32(LODWORD(v499));
LABEL_976:
              *float v72 = v500;
              *(_DWORD *)float v62 = bswap32(LODWORD(v493));
              goto LABEL_978;
            }
            *float v72 = bswap32(LODWORD(v499));
LABEL_978:
            float v501 = &v41[v644];
            if ((unint64_t)v501 >= v64) {
              uint64_t v502 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v502 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v502;
            float v41 = &v501[v502];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v491;
          }
          while (v491);
          if (v662)
          {
            float v503 = &v70[v666];
            if (v503 >= v662) {
              uint64_t v504 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v504 = 0;
            }
            v71 += 4 * v664 + 4 * v504;
            if (v503 >= v662) {
              uint64_t v505 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v505 = 0;
            }
            uint64_t v70 = &v503[v505];
            v64 += 4 * v505 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 25:
        while (1)
        {
          int v506 = v684[0];
          do
          {
            float v507 = 1.0;
            float v508 = 1.0;
            if (v44)
            {
              float v508 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v508 <= 0.0) {
                goto LABEL_1008;
              }
            }
            if (v30)
            {
              float v507 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v507 <= 0.0)
              {
                unsigned int v515 = *v41;
                goto LABEL_1006;
              }
            }
            float v509 = COERCE_FLOAT(bswap32(*v72));
            float v510 = COERCE_FLOAT(bswap32(*v41));
            float v511 = v509 - (float)(v508 * v509);
            if (v508 == 1.0)
            {
              float v512 = 0.0;
            }
            else
            {
              float v509 = v508 * v509;
              float v512 = v511;
            }
            float v513 = (float)(v512 + v510) - (float)(v507 * v510);
            if (v507 == 1.0) {
              float v513 = v512;
            }
            float v514 = v509 + v513;
            if (v30)
            {
              float v508 = (float)(v508 + v507) - (float)(v508 * v507);
              unsigned int v515 = bswap32(LODWORD(v514));
LABEL_1006:
              *float v72 = v515;
              *(_DWORD *)float v62 = bswap32(LODWORD(v508));
              goto LABEL_1008;
            }
            *float v72 = bswap32(LODWORD(v514));
LABEL_1008:
            uint64_t v516 = &v41[v644];
            if ((unint64_t)v516 >= v64) {
              uint64_t v517 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v517 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v517;
            float v41 = &v516[v517];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v506;
          }
          while (v506);
          if (v662)
          {
            uint64_t v518 = &v70[v666];
            if (v518 >= v662) {
              uint64_t v519 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v519 = 0;
            }
            v71 += 4 * v664 + 4 * v519;
            if (v518 >= v662) {
              uint64_t v520 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v520 = 0;
            }
            uint64_t v70 = &v518[v520];
            v64 += 4 * v520 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 26:
        while (1)
        {
          int v521 = v684[0];
          do
          {
            float v522 = 1.0;
            float v523 = 1.0;
            if (v44)
            {
              float v523 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v523 <= 0.0) {
                goto LABEL_1037;
              }
            }
            if (v30)
            {
              float v522 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v522 <= 0.0)
              {
                unsigned int v529 = *v41;
                goto LABEL_1035;
              }
            }
            float v524 = COERCE_FLOAT(bswap32(*v41));
            float v525 = COERCE_FLOAT(bswap32(*v72));
            float v526 = v525;
            float v527 = v524 - (float)(v522 * v524);
            if (v522 == 1.0) {
              float v527 = 0.0;
            }
            if (v523 != 1.0)
            {
              float v526 = v523 * v525;
              float v527 = (float)(v527 + v525) - (float)(v523 * v525);
            }
            float v528 = v526 + v527;
            if (v30)
            {
              float v523 = (float)(v523 + v522) - (float)(v523 * v522);
              unsigned int v529 = bswap32(LODWORD(v528));
LABEL_1035:
              *float v72 = v529;
              *(_DWORD *)float v62 = bswap32(LODWORD(v523));
              goto LABEL_1037;
            }
            *float v72 = bswap32(LODWORD(v528));
LABEL_1037:
            int v530 = &v41[v644];
            if ((unint64_t)v530 >= v64) {
              uint64_t v531 = -(uint64_t)(int)v45;
            }
            else {
              uint64_t v531 = 0;
            }
            v61 += 4 * (int)v44 + 4 * v531;
            float v41 = &v530[v531];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v521;
          }
          while (v521);
          if (v662)
          {
            int v532 = &v70[v666];
            if (v532 >= v662) {
              uint64_t v533 = -(uint64_t)(v664 * v645);
            }
            else {
              uint64_t v533 = 0;
            }
            v71 += 4 * v664 + 4 * v533;
            if (v532 >= v662) {
              uint64_t v534 = -(uint64_t)(v666 * v645);
            }
            else {
              uint64_t v534 = 0;
            }
            uint64_t v70 = &v532[v534];
            v64 += 4 * v534 + 4 * v666;
            float v61 = (char *)v71;
            float v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0]) {
            goto LABEL_1266;
          }
        }
      case 27:
        break;
      default:
        goto LABEL_1266;
    }
LABEL_1052:
    int v535 = v684[0];
    while (1)
    {
      float v536 = 1.0;
      float v537 = 1.0;
      if (!v44 || (float v537 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v537 > 0.0))
      {
        if (v30 && (float v536 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v536 <= 0.0))
        {
          unsigned int v543 = *v41;
        }
        else
        {
          float v538 = COERCE_FLOAT(bswap32(*v72));
          float v539 = COERCE_FLOAT(bswap32(*v41));
          float v540 = v539;
          float v541 = v538 - (float)(v537 * v538);
          if (v537 == 1.0) {
            float v541 = 0.0;
          }
          if (v536 != 1.0)
          {
            float v540 = v536 * v539;
            float v541 = (float)(v541 + v539) - (float)(v536 * v539);
          }
          float v542 = v540 + v541;
          if (!v30)
          {
            *float v72 = bswap32(LODWORD(v542));
            goto LABEL_1066;
          }
          float v537 = (float)(v537 + v536) - (float)(v537 * v536);
          unsigned int v543 = bswap32(LODWORD(v542));
        }
        *float v72 = v543;
        *(_DWORD *)float v62 = bswap32(LODWORD(v537));
      }
LABEL_1066:
      float v544 = &v41[v644];
      if ((unint64_t)v544 >= v64) {
        uint64_t v545 = -(uint64_t)(int)v45;
      }
      else {
        uint64_t v545 = 0;
      }
      v61 += 4 * (int)v44 + 4 * v545;
      float v41 = &v544[v545];
      v62 += 4 * (int)v30;
      v72 += v644;
      if (!--v535)
      {
        if (v662)
        {
          float v546 = &v70[v666];
          if (v546 >= v662) {
            uint64_t v547 = -(uint64_t)(v664 * v645);
          }
          else {
            uint64_t v547 = 0;
          }
          v71 += 4 * v664 + 4 * v547;
          if (v546 >= v662) {
            uint64_t v548 = -(uint64_t)(v666 * v645);
          }
          else {
            uint64_t v548 = 0;
          }
          uint64_t v70 = &v546[v548];
          v64 += 4 * v548 + 4 * v666;
          float v61 = (char *)v71;
          float v41 = v70;
        }
        else
        {
          v41 += v666;
          v61 += 4 * v664;
        }
        v72 += v228;
        v62 += 4 * v668;
        if (!--v674[0]) {
          goto LABEL_1266;
        }
        goto LABEL_1052;
      }
    }
  }
  int v17 = *(_DWORD *)(v3 + 128);
  if ((v17 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      WF_mark_constmask(v3, v9, v4);
    }
    else {
      WF_mark_pixelmask(v3, v9);
    }
  }
  else
  {
    int v31 = *(_DWORD *)(v3 + 112);
    int v32 = *(_DWORD *)(v3 + 116);
    unsigned int v33 = (v31 + 15) & 0xFFFFFFF0;
    size_t v34 = v33 * v32;
    if ((int)v34 <= 4096)
    {
      float v36 = v684;
    }
    else
    {
      float v35 = malloc_type_malloc(v34, 0xB98CD2D6uLL);
      if (!v35) {
        return 1;
      }
      float v36 = v35;
      float v16 = *(uint16x4_t **)(v11 + 136);
      int v17 = *(_DWORD *)(v11 + 128);
    }
    CGSConvertBitsToMask(v16, *(_DWORD *)(v11 + 124), v36, v33, v31, v32, v17);
    long long v49 = *(_OWORD *)(v11 + 112);
    long long v680 = *(_OWORD *)(v11 + 96);
    long long v681 = v49;
    long long v50 = *(_OWORD *)(v11 + 144);
    long long v682 = *(_OWORD *)(v11 + 128);
    long long v683 = v50;
    long long v51 = *(_OWORD *)(v11 + 48);
    long long v676 = *(_OWORD *)(v11 + 32);
    long long v677 = v51;
    long long v52 = *(_OWORD *)(v11 + 80);
    long long v678 = *(_OWORD *)(v11 + 64);
    long long v679 = v52;
    long long v53 = *(_OWORD *)v11;
    long long v54 = *(_OWORD *)(v11 + 16);
    *(_OWORD *)uint64_t v674 = *(_OWORD *)v11;
    long long v675 = v54;
    HIDWORD(v681) = (v31 + 15) & 0xFFFFFFF0;
    *((void *)&v682 + 1) = v36;
    if (BYTE1(v674[0]) << 8 == 1024) {
      WF_mark_constmask((uint64_t)v674, v9, *(double *)&v53);
    }
    else {
      WF_mark_pixelmask((uint64_t)v674, v9);
    }
    if (v36 != (unsigned char *)v684)
    {
LABEL_312:
      float v179 = v36;
      goto LABEL_1082;
    }
  }
  return 1;
}

void WF_mark_constmask(uint64_t a1, int a2, double a3)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 136);
  int32x2_t v6 = *(unsigned int **)(a1 + 96);
  if (v6) {
    float v7 = COERCE_FLOAT(bswap32(*v6));
  }
  else {
    float v7 = 1.0;
  }
  unsigned int v8 = **(_DWORD **)(a1 + 88);
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  uint64_t v12 = *(int *)(a1 + 12);
  uint64_t v11 = *(int *)(a1 + 16);
  if (v4)
  {
    unint64_t v13 = (unint64_t)*(int *)(a1 + 32) >> 2;
    int v14 = (unsigned int *)(v4 + 4 * (v12 + v13 * v11));
    uint64_t v15 = 1;
    if (!v5) {
      return;
    }
  }
  else
  {
    int v14 = 0;
    unint64_t v13 = 0;
    uint64_t v15 = 0;
    if (!v5) {
      return;
    }
  }
  unint64_t v16 = v13 - v9;
  if (v4) {
    unint64_t v17 = v13 - v9;
  }
  else {
    unint64_t v17 = v13;
  }
  float v18 = COERCE_FLOAT(bswap32(v8));
  unint64_t v19 = (unint64_t)*(int *)(a1 + 28) >> 2;
  *(float *)v3.i32 = v18;
  unsigned int v20 = (unsigned int *)(*(void *)(a1 + 40) + 4 * (v12 + v19 * v11));
  uint64_t v21 = *(int *)(a1 + 124);
  unint64_t v22 = v5 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v21;
  uint64_t v23 = v21 - v9;
  unint64_t v24 = v19 - v9;
  float v372 = v18;
  unint64_t v371 = v24;
  uint64_t v25 = v23;
  int v26 = *(_DWORD *)(a1 + 4);
  unint64_t v27 = v17;
  switch(a2)
  {
    case 0:
      if (v4)
      {
        uint64_t v28 = 4 * v15;
        do
        {
          int v29 = v9;
          do
          {
            int v30 = *(unsigned __int8 *)v22;
            if (*(unsigned char *)v22)
            {
              if (v30 == 255)
              {
                *int v14 = 0;
                *unsigned int v20 = 0;
              }
              else
              {
                float v31 = (float)(v30 ^ 0xFFu) * 0.0039216;
                unsigned int v32 = bswap32(COERCE_UNSIGNED_INT(v31 * COERCE_FLOAT(bswap32(*v14))));
                *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT(v31 * COERCE_FLOAT(bswap32(*v20))));
                *int v14 = v32;
              }
            }
            ++v22;
            ++v20;
            int v14 = (unsigned int *)((char *)v14 + v28);
            --v29;
          }
          while (v29);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v260 = v9;
          do
          {
            int v261 = *(unsigned __int8 *)v22;
            if (*(unsigned char *)v22)
            {
              if (v261 == 255) {
                *unsigned int v20 = 0;
              }
              else {
                *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(v261 ^ 0xFFu) * 0.0039216) * COERCE_FLOAT(bswap32(*v20))));
              }
            }
            ++v22;
            ++v20;
            --v260;
          }
          while (v260);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 1:
      unsigned int v33 = v22 & 3;
      if (!v4)
      {
        int v262 = -1 << (8 * v33);
        if ((v22 & 3) != 0) {
          char v263 = v22 & 0xFC;
        }
        else {
          char v263 = v22;
        }
        if ((v22 & 3) != 0)
        {
          double v264 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v262 = -1;
          double v264 = (unsigned int *)v22;
        }
        if ((v22 & 3) != 0) {
          uint64_t v265 = &v20[-(v22 & 3)];
        }
        else {
          uint64_t v265 = v20;
        }
        if ((v22 & 3) != 0) {
          int v266 = v33 + v9;
        }
        else {
          int v266 = v9;
        }
        if ((((_BYTE)v266 + v263) & 3) != 0)
        {
          int v267 = 4 - (((_BYTE)v266 + v263) & 3);
          v33 += v267;
          unsigned int v268 = 0xFFFFFFFF >> (8 * v267);
          if (v266 >= 4) {
            unsigned int v269 = v268;
          }
          else {
            unsigned int v269 = 0;
          }
          if (v266 >= 4) {
            unsigned int v268 = -1;
          }
          v262 &= v268;
        }
        else
        {
          unsigned int v269 = 0;
        }
        uint64_t v347 = v23 - v33;
        int v348 = v266 >> 2;
        int32x4_t v349 = vdupq_n_s32(v8);
        unint64_t v350 = v24 - v33;
        while (1)
        {
          unsigned int v351 = *v264 & v262;
          int v352 = v348;
          unsigned int v353 = v269;
          if (!v351) {
            goto LABEL_550;
          }
LABEL_532:
          if (v351 == -1)
          {
            *(int32x4_t *)uint64_t v265 = v349;
            goto LABEL_550;
          }
          while (1)
          {
            if ((_BYTE)v351)
            {
              unsigned int v354 = v8;
              if (v351 != 255) {
                unsigned int v354 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v351 * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(*v265))* (float)(1.0 - (float)((float)v351 * 0.0039216)))));
              }
              *uint64_t v265 = v354;
            }
            if (BYTE1(v351))
            {
              unsigned int v355 = v8;
              if (BYTE1(v351) != 255) {
                unsigned int v355 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE1(v351) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v265[1]))* (float)(1.0 - (float)((float)BYTE1(v351) * 0.0039216)))));
              }
              v265[1] = v355;
            }
            if (BYTE2(v351))
            {
              unsigned int v356 = v8;
              if (BYTE2(v351) != 255) {
                unsigned int v356 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE2(v351) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v265[2]))* (float)(1.0 - (float)((float)BYTE2(v351) * 0.0039216)))));
              }
              v265[2] = v356;
            }
            unsigned int v357 = HIBYTE(v351);
            if (v357 == 255)
            {
              v265[3] = v8;
            }
            else if (v357)
            {
              v265[3] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v357 * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v265[3])) * (float)(1.0 - (float)((float)v357 * 0.0039216)))));
            }
LABEL_550:
            while (1)
            {
              int v358 = v352;
              v265 += 4;
              --v352;
              ++v264;
              if (v358 < 2) {
                break;
              }
              unsigned int v351 = *v264;
              if (*v264) {
                goto LABEL_532;
              }
            }
            if (!v353) {
              break;
            }
            unsigned int v353 = 0;
            unsigned int v351 = *v264 & v269;
          }
          double v264 = (unsigned int *)((char *)v264 + v347);
          v265 += v350;
          if (!--v10) {
            return;
          }
        }
      }
      int v34 = -1 << (8 * v33);
      float v35 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v36 = 4 * (v22 & 3);
      unint64_t v37 = &v20[v36 / 0xFFFFFFFFFFFFFFFCLL];
      unsigned int v38 = &v14[v36 / 0xFFFFFFFFFFFFFFFCLL];
      if ((v22 & 3) != 0) {
        char v39 = v22 & 0xFC;
      }
      else {
        char v39 = v22;
      }
      if ((v22 & 3) != 0)
      {
        int v40 = v33 + v9;
      }
      else
      {
        int v34 = -1;
        float v35 = (unsigned int *)v22;
        unsigned int v38 = v14;
        unint64_t v37 = v20;
        int v40 = v9;
      }
      if ((((_BYTE)v40 + v39) & 3) != 0)
      {
        int v41 = 4 - (((_BYTE)v40 + v39) & 3);
        v33 += v41;
        unsigned int v42 = 0xFFFFFFFF >> (8 * v41);
        if (v40 >= 4) {
          unsigned int v43 = v42;
        }
        else {
          unsigned int v43 = 0;
        }
        if (v40 >= 4) {
          unsigned int v42 = -1;
        }
        v34 &= v42;
      }
      else
      {
        unsigned int v43 = 0;
      }
      uint64_t v286 = v23 - v33;
      int v287 = v40 >> 2;
      unint64_t v288 = v24 - v33;
      unsigned int v289 = bswap32(LODWORD(v7));
      unint64_t v290 = v16 - v33;
      do
      {
        unsigned int v291 = *v35 & v34;
        int v292 = v287;
        unsigned int v293 = v43;
        if (!v291) {
          goto LABEL_501;
        }
LABEL_483:
        if (v291 == -1)
        {
          *unint64_t v37 = v8;
          *unsigned int v38 = v289;
          v37[1] = v8;
          v38[1] = v289;
          v37[2] = v8;
          v38[2] = v289;
LABEL_498:
          v37[3] = v8;
          v38[3] = v289;
          goto LABEL_501;
        }
        while (1)
        {
          if ((_BYTE)v291)
          {
            unsigned int v294 = v8;
            unsigned int v295 = v289;
            if (v291 != 255)
            {
              float v296 = (float)v291 * 0.0039216;
              float v297 = v296 * *(float *)v3.i32;
              float v298 = v7 * v296;
              float v299 = 1.0 - v296;
              unsigned int v294 = bswap32(COERCE_UNSIGNED_INT(v297 + (float)(COERCE_FLOAT(bswap32(*v37)) * v299)));
              unsigned int v295 = bswap32(COERCE_UNSIGNED_INT(v298 + (float)(COERCE_FLOAT(bswap32(*v38)) * v299)));
            }
            *unint64_t v37 = v294;
            *unsigned int v38 = v295;
          }
          if (BYTE1(v291))
          {
            unsigned int v300 = v8;
            unsigned int v301 = v289;
            if (BYTE1(v291) != 255)
            {
              float v302 = (float)BYTE1(v291) * 0.0039216;
              float v303 = v302 * *(float *)v3.i32;
              float v304 = v7 * v302;
              float v305 = 1.0 - v302;
              unsigned int v300 = bswap32(COERCE_UNSIGNED_INT(v303 + (float)(COERCE_FLOAT(bswap32(v37[1])) * v305)));
              unsigned int v301 = bswap32(COERCE_UNSIGNED_INT(v304 + (float)(COERCE_FLOAT(bswap32(v38[1])) * v305)));
            }
            v37[1] = v300;
            v38[1] = v301;
          }
          if (BYTE2(v291))
          {
            unsigned int v306 = v8;
            unsigned int v307 = v289;
            if (BYTE2(v291) != 255)
            {
              float v308 = (float)BYTE2(v291) * 0.0039216;
              float v309 = v308 * *(float *)v3.i32;
              float v310 = v7 * v308;
              float v311 = 1.0 - v308;
              unsigned int v306 = bswap32(COERCE_UNSIGNED_INT(v309 + (float)(COERCE_FLOAT(bswap32(v37[2])) * v311)));
              unsigned int v307 = bswap32(COERCE_UNSIGNED_INT(v310 + (float)(COERCE_FLOAT(bswap32(v38[2])) * v311)));
            }
            v37[2] = v306;
            v38[2] = v307;
          }
          unsigned int v312 = HIBYTE(v291);
          if (v312 == 255) {
            goto LABEL_498;
          }
          if (v312)
          {
            float v313 = (float)v312 * 0.0039216;
            float v314 = v313 * *(float *)v3.i32;
            float v315 = v7 * v313;
            float v316 = 1.0 - v313;
            unsigned int v317 = bswap32(COERCE_UNSIGNED_INT(v315 + (float)(COERCE_FLOAT(bswap32(v38[3])) * v316)));
            v37[3] = bswap32(COERCE_UNSIGNED_INT(v314 + (float)(COERCE_FLOAT(bswap32(v37[3])) * v316)));
            v38[3] = v317;
          }
LABEL_501:
          while (1)
          {
            int v318 = v292;
            v37 += 4;
            v38 += 4;
            --v292;
            ++v35;
            if (v318 < 2) {
              break;
            }
            unsigned int v291 = *v35;
            if (*v35) {
              goto LABEL_483;
            }
          }
          if (!v293) {
            break;
          }
          unsigned int v293 = 0;
          unsigned int v291 = *v35 & v43;
        }
        float v35 = (unsigned int *)((char *)v35 + v286);
        v37 += v288;
        v38 += v290;
        --v10;
      }
      while (v10);
      return;
    case 2:
      *(float *)&a3 = 1.0 - v7;
      unsigned int v44 = v22 & 3;
      if (v4)
      {
        int v45 = -1 << (8 * v44);
        unint64_t v46 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        uint64_t v47 = 4 * (v22 & 3);
        unint64_t v48 = &v20[v47 / 0xFFFFFFFFFFFFFFFCLL];
        long long v49 = &v14[v47 / 0xFFFFFFFFFFFFFFFCLL];
        if ((v22 & 3) != 0) {
          char v50 = v22 & 0xFC;
        }
        else {
          char v50 = v22;
        }
        if ((v22 & 3) != 0)
        {
          int v51 = v44 + v9;
        }
        else
        {
          int v45 = -1;
          unint64_t v46 = (unsigned int *)v22;
          long long v49 = v14;
          unint64_t v48 = v20;
          int v51 = *(_DWORD *)(a1 + 4);
        }
        if ((((_BYTE)v51 + v50) & 3) != 0)
        {
          int v52 = 4 - (((_BYTE)v51 + v50) & 3);
          v44 += v52;
          unsigned int v53 = 0xFFFFFFFF >> (8 * v52);
          if (v51 >= 4) {
            unsigned int v54 = v53;
          }
          else {
            unsigned int v54 = 0;
          }
          if (v51 >= 4) {
            unsigned int v53 = -1;
          }
          v45 &= v53;
        }
        else
        {
          unsigned int v54 = 0;
        }
        uint64_t v319 = v23 - v44;
        unint64_t v320 = v24 - v44;
        int v321 = v51 >> 2;
        unint64_t v322 = v16 - v44;
        while (1)
        {
          unsigned int v323 = *v46 & v45;
          int v324 = v321;
          unsigned int v325 = v54;
          if (!v323) {
            goto LABEL_522;
          }
LABEL_511:
          if (v323 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v323)
            {
              float v331 = (float)v323 * 0.0039216;
              float v332 = v331 * *(float *)v3.i32;
              float v333 = v7 * v331;
              unsigned int v334 = bswap32(COERCE_UNSIGNED_INT(v333 + (float)(COERCE_FLOAT(bswap32(*v49)) * (float)(1.0 - v333))));
              *unint64_t v48 = bswap32(COERCE_UNSIGNED_INT(v332 + (float)(COERCE_FLOAT(bswap32(*v48)) * (float)(1.0 - v333))));
              *long long v49 = v334;
            }
            if ((v323 & 0xFF00) != 0)
            {
              float v335 = (float)BYTE1(v323) * 0.0039216;
              float v336 = v335 * *(float *)v3.i32;
              float v337 = v7 * v335;
              unsigned int v338 = bswap32(COERCE_UNSIGNED_INT(v337 + (float)(COERCE_FLOAT(bswap32(v49[1])) * (float)(1.0 - v337))));
              v48[1] = bswap32(COERCE_UNSIGNED_INT(v336 + (float)(COERCE_FLOAT(bswap32(v48[1])) * (float)(1.0 - v337))));
              v49[1] = v338;
            }
            if ((v323 & 0xFF0000) != 0)
            {
              float v339 = (float)BYTE2(v323) * 0.0039216;
              float v340 = v339 * *(float *)v3.i32;
              float v341 = v7 * v339;
              unsigned int v342 = bswap32(COERCE_UNSIGNED_INT(v341 + (float)(COERCE_FLOAT(bswap32(v49[2])) * (float)(1.0 - v341))));
              v48[2] = bswap32(COERCE_UNSIGNED_INT(v340 + (float)(COERCE_FLOAT(bswap32(v48[2])) * (float)(1.0 - v341))));
              v49[2] = v342;
            }
            unsigned int v343 = HIBYTE(v323);
            if (v343)
            {
              float v344 = (float)v343 * 0.0039216;
              float v345 = v7 * v344;
              float v329 = (float)(v344 * *(float *)v3.i32)
                   + (float)(COERCE_FLOAT(bswap32(v48[3])) * (float)(1.0 - (float)(v7 * v344)));
              float v330 = v345 + (float)(COERCE_FLOAT(bswap32(v49[3])) * (float)(1.0 - v345));
              goto LABEL_521;
            }
LABEL_522:
            while (1)
            {
              int v346 = v324;
              v48 += 4;
              v49 += 4;
              --v324;
              ++v46;
              if (v346 < 2) {
                break;
              }
              unsigned int v323 = *v46;
              if (*v46) {
                goto LABEL_511;
              }
            }
            if (!v325) {
              break;
            }
            unsigned int v325 = 0;
            unsigned int v323 = *v46 & v54;
          }
          unint64_t v46 = (unsigned int *)((char *)v46 + v319);
          v48 += v320;
          v49 += v322;
          if (!--v10) {
            return;
          }
        }
        unsigned int v326 = bswap32(COERCE_UNSIGNED_INT(v7 + (float)(COERCE_FLOAT(bswap32(*v49)) * *(float *)&a3)));
        *unint64_t v48 = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(*v48)) * *(float *)&a3)));
        *long long v49 = v326;
        unsigned int v327 = bswap32(COERCE_UNSIGNED_INT(v7 + (float)(COERCE_FLOAT(bswap32(v49[1])) * *(float *)&a3)));
        v48[1] = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v48[1])) * *(float *)&a3)));
        v49[1] = v327;
        unsigned int v328 = bswap32(COERCE_UNSIGNED_INT(v7 + (float)(COERCE_FLOAT(bswap32(v49[2])) * *(float *)&a3)));
        v48[2] = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v48[2])) * *(float *)&a3)));
        v49[2] = v328;
        float v329 = *(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v48[3])) * *(float *)&a3);
        float v330 = v7 + (float)(COERCE_FLOAT(bswap32(v49[3])) * *(float *)&a3);
LABEL_521:
        v48[3] = bswap32(LODWORD(v329));
        v49[3] = bswap32(LODWORD(v330));
        goto LABEL_522;
      }
      int v270 = v44 + v9;
      int v271 = -1 << (8 * v44);
      if ((v22 & 3) != 0) {
        char v272 = v22 & 0xFC;
      }
      else {
        char v272 = v5 + *(_DWORD *)(a1 + 104) + *(_DWORD *)(a1 + 108) * v21;
      }
      if ((v22 & 3) != 0)
      {
        uint64_t v273 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v271 = -1;
        uint64_t v273 = (unsigned int *)(v5 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v21);
      }
      if ((v22 & 3) != 0) {
        uint64_t v274 = (int8x8_t *)&v20[-(v22 & 3)];
      }
      else {
        uint64_t v274 = (int8x8_t *)v20;
      }
      if ((v22 & 3) == 0) {
        int v270 = *(_DWORD *)(a1 + 4);
      }
      if ((((_BYTE)v270 + v272) & 3) != 0)
      {
        int v275 = 4 - (((_BYTE)v270 + v272) & 3);
        v44 += v275;
        unsigned int v276 = 0xFFFFFFFF >> (8 * v275);
        if (v270 >= 4) {
          unsigned int v277 = v276;
        }
        else {
          unsigned int v277 = 0;
        }
        if (v270 >= 4) {
          unsigned int v276 = -1;
        }
        v271 &= v276;
      }
      else
      {
        unsigned int v277 = 0;
      }
      int v359 = v270 >> 2;
      uint64_t v360 = v23 - v44;
      float32x2_t v361 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
      float32x2_t v362 = (float32x2_t)vdup_lane_s32(v3, 0);
      unint64_t v363 = v24 - v44;
      while (1)
      {
        unsigned int v364 = *v273 & v271;
        int v365 = v359;
        unsigned int v366 = v277;
        if (!v364) {
          goto LABEL_571;
        }
LABEL_560:
        if (v364 == -1) {
          break;
        }
        while (1)
        {
          if ((_BYTE)v364) {
            v274->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v364 * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v274->i32[0]))* (float)(1.0 - (float)(v7 * (float)((float)v364 * 0.0039216))))));
          }
          if ((v364 & 0xFF00) != 0) {
            v274->i32[1] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE1(v364) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v274->u32[1]))* (float)(1.0 - (float)(v7 * (float)((float)BYTE1(v364) * 0.0039216))))));
          }
          if ((v364 & 0xFF0000) != 0) {
            v274[1].i32[0] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE2(v364) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v274[1].u32[0]))* (float)(1.0 - (float)(v7 * (float)((float)BYTE2(v364) * 0.0039216))))));
          }
          unsigned int v369 = HIBYTE(v364);
          if (v369)
          {
            float v368 = (float)((float)((float)v369 * 0.0039216) * *(float *)v3.i32)
                 + (float)(COERCE_FLOAT(bswap32(v274[1].u32[1]))
                         * (float)(1.0 - (float)(v7 * (float)((float)v369 * 0.0039216))));
            goto LABEL_570;
          }
LABEL_571:
          while (1)
          {
            int v370 = v365;
            v274 += 2;
            --v365;
            ++v273;
            if (v370 < 2) {
              break;
            }
            unsigned int v364 = *v273;
            if (*v273) {
              goto LABEL_560;
            }
          }
          if (!v366) {
            break;
          }
          unsigned int v366 = 0;
          unsigned int v364 = *v273 & v277;
        }
        uint64_t v273 = (unsigned int *)((char *)v273 + v360);
        uint64_t v274 = (int8x8_t *)((char *)v274 + 4 * v363);
        if (!--v10) {
          return;
        }
      }
      unsigned int v367 = v274[1].u32[1];
      v274[1].i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v274[1].u32[0]))
                                                                            * *(float *)&a3)));
      *uint64_t v274 = vrev32_s8((int8x8_t)vmla_f32(v362, v361, (float32x2_t)vrev32_s8(*v274)));
      float v368 = *(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v367)) * *(float *)&a3);
LABEL_570:
      v274[1].i32[1] = bswap32(LODWORD(v368));
      goto LABEL_571;
    case 3:
      uint64_t v55 = 4 * v15;
      do
      {
        int v56 = v9;
        do
        {
          unsigned int v57 = *(unsigned __int8 *)v22;
          if (*(unsigned char *)v22)
          {
            if (v57 == 255)
            {
              float v58 = COERCE_FLOAT(bswap32(*v14));
              float v59 = v18 * v58;
              float v60 = v7 * v58;
            }
            else
            {
              float v61 = (float)v57 * 0.0039216;
              float v62 = COERCE_FLOAT(bswap32(*v14));
              float v63 = v7 * (float)(v61 * v62);
              float v64 = 1.0 - v61;
              float v59 = (float)((float)(v61 * v62) * v18) + (float)(COERCE_FLOAT(bswap32(*v20)) * (float)(1.0 - v61));
              float v60 = v63 + (float)(v62 * v64);
            }
            *unsigned int v20 = bswap32(LODWORD(v59));
            *int v14 = bswap32(LODWORD(v60));
          }
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v55);
          --v56;
        }
        while (v56);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 4:
      uint64_t v65 = 4 * v15;
      do
      {
        int v66 = v9;
        do
        {
          unsigned int v67 = *(unsigned __int8 *)v22;
          if (*(unsigned char *)v22)
          {
            if (v67 == 255)
            {
              float v68 = COERCE_FLOAT(bswap32(*v14));
              float v69 = (float)(1.0 - v68) * v18;
              float v70 = v7 * (float)(1.0 - v68);
            }
            else
            {
              float v71 = (float)v67 * 0.0039216;
              float v72 = COERCE_FLOAT(bswap32(*v14));
              float v73 = v71 * (float)(1.0 - v72);
              float v74 = 1.0 - v71;
              float v69 = (float)(v73 * v18) + (float)(COERCE_FLOAT(bswap32(*v20)) * (float)(1.0 - v71));
              float v70 = (float)(v7 * v73) + (float)(v72 * v74);
            }
            *unsigned int v20 = bswap32(LODWORD(v69));
            *int v14 = bswap32(LODWORD(v70));
          }
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v65);
          --v66;
        }
        while (v66);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 5:
      uint64_t v75 = 4 * v15;
      do
      {
        int v76 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v77 = COERCE_FLOAT(bswap32(*v14));
            float v78 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v79 = v78 * v18;
            float v80 = v7 * v78;
            *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v80) * COERCE_FLOAT(bswap32(*v20))) + (float)(v79 * v77)));
            *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v80) * v77) + (float)(v80 * v77)));
          }
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v75);
          --v76;
        }
        while (v76);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 6:
      uint64_t v81 = 4 * v15;
      while (1)
      {
        int v82 = v9;
        do
        {
          unsigned int v83 = *(unsigned __int8 *)v22;
          if (!*(unsigned char *)v22) {
            goto LABEL_85;
          }
          float v84 = COERCE_FLOAT(bswap32(*v14));
          float v85 = 1.0 - v84;
          if ((float)(1.0 - v84) >= 1.0)
          {
            float v90 = (float)v83 * 0.0039216;
            float v88 = v90 * v18;
            float v89 = v7 * v90;
          }
          else
          {
            if (v85 <= 0.0) {
              goto LABEL_85;
            }
            float v86 = (float)v83 * 0.0039216;
            float v87 = v7 * v86;
            float v88 = COERCE_FLOAT(bswap32(*v20)) + (float)((float)(v86 * v18) * v85);
            float v89 = v84 + (float)(v87 * v85);
          }
          *unsigned int v20 = bswap32(LODWORD(v88));
          *int v14 = bswap32(LODWORD(v89));
LABEL_85:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v81);
          --v82;
        }
        while (v82);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 7:
      if (v4)
      {
        uint64_t v91 = 4 * v15;
        do
        {
          int v92 = v9;
          do
          {
            unsigned int v93 = *(unsigned __int8 *)v22;
            if (*(unsigned char *)v22)
            {
              if (v93 == 255)
              {
                float v94 = v7 * COERCE_FLOAT(bswap32(*v20));
                float v95 = v7 * COERCE_FLOAT(bswap32(*v14));
              }
              else
              {
                float v96 = (float)(v7 * (float)((float)v93 * 0.0039216)) + (float)(1.0 - (float)((float)v93 * 0.0039216));
                float v94 = v96 * COERCE_FLOAT(bswap32(*v20));
                float v95 = v96 * COERCE_FLOAT(bswap32(*v14));
              }
              *unsigned int v20 = bswap32(LODWORD(v94));
              *int v14 = bswap32(LODWORD(v95));
            }
            ++v22;
            ++v20;
            int v14 = (unsigned int *)((char *)v14 + v91);
            --v92;
          }
          while (v92);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v278 = v9;
          do
          {
            unsigned int v279 = *(unsigned __int8 *)v22;
            if (*(unsigned char *)v22)
            {
              if (v279 == 255) {
                float v280 = v7 * COERCE_FLOAT(bswap32(*v20));
              }
              else {
                float v280 = (float)((float)(v7 * (float)((float)v279 * 0.0039216))
              }
                             + (float)(1.0 - (float)((float)v279 * 0.0039216)))
                     * COERCE_FLOAT(bswap32(*v20));
              *unsigned int v20 = bswap32(LODWORD(v280));
            }
            ++v22;
            ++v20;
            --v278;
          }
          while (v278);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 8:
      float v97 = 1.0 - v7;
      if (v4)
      {
        uint64_t v98 = 4 * v15;
        do
        {
          int v99 = v9;
          do
          {
            unsigned int v100 = *(unsigned __int8 *)v22;
            if (*(unsigned char *)v22)
            {
              if (v100 == 255)
              {
                float v101 = v97 * COERCE_FLOAT(bswap32(*v20));
                float v102 = v97 * COERCE_FLOAT(bswap32(*v14));
              }
              else
              {
                float v103 = (float)(v7 * (float)((float)v100 * -0.0039216)) + 1.0;
                float v101 = v103 * COERCE_FLOAT(bswap32(*v20));
                float v102 = v103 * COERCE_FLOAT(bswap32(*v14));
              }
              *unsigned int v20 = bswap32(LODWORD(v101));
              *int v14 = bswap32(LODWORD(v102));
            }
            ++v22;
            ++v20;
            int v14 = (unsigned int *)((char *)v14 + v98);
            --v99;
          }
          while (v99);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v281 = v9;
          do
          {
            unsigned int v282 = *(unsigned __int8 *)v22;
            if (*(unsigned char *)v22)
            {
              if (v282 == 255) {
                float v283 = v97 * COERCE_FLOAT(bswap32(*v20));
              }
              else {
                float v283 = (float)((float)(v7 * (float)((float)v282 * -0.0039216)) + 1.0) * COERCE_FLOAT(bswap32(*v20));
              }
              *unsigned int v20 = bswap32(LODWORD(v283));
            }
            ++v22;
            ++v20;
            --v281;
          }
          while (v281);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 9:
      uint64_t v104 = 4 * v15;
      do
      {
        int v105 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v106 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v107 = COERCE_FLOAT(bswap32(*v14));
            float v108 = v106 * v18;
            float v109 = v7 * v106;
            float v110 = (float)(1.0 - v106) + (float)(v7 * v106);
            *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT((float)(v110 * COERCE_FLOAT(bswap32(*v20))) + (float)(v108 * (float)(1.0 - v107))));
            *int v14 = bswap32(COERCE_UNSIGNED_INT((float)(v110 * v107) + (float)(v109 * (float)(1.0 - v107))));
          }
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v104);
          --v105;
        }
        while (v105);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 10:
      uint64_t v111 = 4 * v15;
      do
      {
        int v112 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v113 = COERCE_FLOAT(bswap32(*v14));
            float v114 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v115 = v114 * v18;
            float v116 = v7 * v114;
            *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v116) * COERCE_FLOAT(bswap32(*v20))) + (float)(v115 * (float)(1.0 - v113))));
            *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v116) * v113) + (float)(v116 * (float)(1.0 - v113))));
          }
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v111);
          --v112;
        }
        while (v112);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 11:
      if (v4)
      {
        uint64_t v117 = 4 * v15;
        do
        {
          int v118 = v9;
          do
          {
            if (*(unsigned char *)v22)
            {
              float v119 = (float)*(unsigned __int8 *)v22 * 0.0039216;
              float v120 = v119 * v18;
              float v121 = v7 * v119;
              float v122 = COERCE_FLOAT(bswap32(*v20));
              float v123 = COERCE_FLOAT(bswap32(*v14));
              float v124 = v121 + v123;
              if ((float)(v121 + v123) > 1.0) {
                float v124 = 1.0;
              }
              *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT((float)(v121 - v120) + (float)(v124 - (float)(v123 - v122))));
              *int v14 = bswap32(LODWORD(v124));
            }
            ++v22;
            ++v20;
            int v14 = (unsigned int *)((char *)v14 + v117);
            --v118;
          }
          while (v118);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v284 = v9;
          do
          {
            if (*(unsigned char *)v22) {
              *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(v7 * (float)((float)*(unsigned __int8 *)v22 * 0.0039216))- (float)((float)((float)*(unsigned __int8 *)v22 * 0.0039216) * v18))+ COERCE_FLOAT(bswap32(*v20))));
            }
            ++v22;
            ++v20;
            --v284;
          }
          while (v284);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 12:
      if (v4)
      {
        uint64_t v125 = 4 * v15;
        do
        {
          int v126 = v9;
          do
          {
            if (*(unsigned char *)v22)
            {
              float v127 = (float)*(unsigned __int8 *)v22 * 0.0039216;
              float v128 = v127 * v18;
              float v129 = (float)(v7 * v127) + COERCE_FLOAT(bswap32(*v14));
              float v130 = v128 + COERCE_FLOAT(bswap32(*v20));
              if (v129 > 1.0) {
                float v129 = 1.0;
              }
              *unsigned int v20 = bswap32(LODWORD(v130));
              *int v14 = bswap32(LODWORD(v129));
            }
            ++v22;
            ++v20;
            int v14 = (unsigned int *)((char *)v14 + v125);
            --v126;
          }
          while (v126);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v285 = v9;
          do
          {
            if (*(unsigned char *)v22) {
              *unsigned int v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)*(unsigned __int8 *)v22 * 0.0039216) * v18)+ COERCE_FLOAT(bswap32(*v20))));
            }
            ++v22;
            ++v20;
            --v285;
          }
          while (v285);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 13:
      uint64_t v131 = 4 * v15;
      while (1)
      {
        int v132 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v133 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v134 = v7 * v133;
            if ((float)(v7 * v133) > 0.0)
            {
              float v135 = v133 * v18;
              if (v4)
              {
                float v136 = COERCE_FLOAT(bswap32(*v14));
                if (v136 <= 0.0) {
                  goto LABEL_158;
                }
              }
              else
              {
                float v136 = 1.0;
              }
              float v137 = COERCE_FLOAT(bswap32(*v20));
              float v138 = (float)(v135 * v137) + (float)(v137 * (float)(1.0 - v134));
              if (v134 == 1.0) {
                float v138 = v135 * v137;
              }
              float v135 = v138 + (float)(v135 * (float)(1.0 - v136));
              if (v136 == 1.0) {
                float v135 = v138;
              }
              if (v4)
              {
                float v134 = (float)(v134 + v136) - (float)(v136 * v134);
LABEL_158:
                *unsigned int v20 = bswap32(LODWORD(v135));
                *int v14 = bswap32(LODWORD(v134));
                goto LABEL_160;
              }
              *unsigned int v20 = bswap32(LODWORD(v135));
            }
          }
LABEL_160:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v131);
          --v132;
        }
        while (v132);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 14:
      uint64_t v139 = 4 * v15;
      while (1)
      {
        int v140 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v141 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v142 = v7 * v141;
            if ((float)(v7 * v141) > 0.0)
            {
              float v143 = v141 * v18;
              if (v4)
              {
                float v144 = COERCE_FLOAT(bswap32(*v14));
                if (v144 <= 0.0) {
                  goto LABEL_173;
                }
              }
              else
              {
                float v144 = 1.0;
              }
              float v145 = COERCE_FLOAT(bswap32(*v20));
              float v143 = v145 + (float)(v143 * (float)(1.0 - v145));
              if (v4)
              {
                float v142 = (float)(v142 + v144) - (float)(v144 * v142);
LABEL_173:
                *unsigned int v20 = bswap32(LODWORD(v143));
                *int v14 = bswap32(LODWORD(v142));
                goto LABEL_175;
              }
              *unsigned int v20 = bswap32(LODWORD(v143));
            }
          }
LABEL_175:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v139);
          --v140;
        }
        while (v140);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 15:
      uint64_t v146 = 4 * v15;
      while (1)
      {
        int v147 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v148 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v149 = v7 * v148;
            if ((float)(v7 * v148) > 0.0)
            {
              float v150 = v148 * *(float *)v3.i32;
              if (v4)
              {
                float v151 = COERCE_FLOAT(bswap32(*v14));
                if (v151 <= 0.0) {
                  goto LABEL_188;
                }
              }
              else
              {
                float v151 = 1.0;
              }
              float v152 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v20)), v151, v150, v149);
              float v150 = v152;
              if (v4)
              {
                float v149 = v153;
                *(float *)v3.i32 = v372;
LABEL_188:
                *unsigned int v20 = bswap32(LODWORD(v150));
                *int v14 = bswap32(LODWORD(v149));
                goto LABEL_190;
              }
              *unsigned int v20 = bswap32(LODWORD(v152));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_190:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v146);
          --v147;
        }
        while (v147);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        int v9 = v26;
        if (!v10) {
          return;
        }
      }
    case 16:
      uint64_t v154 = 4 * v15;
      while (1)
      {
        int v155 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v156 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v157 = v7 * v156;
            if ((float)(v7 * v156) > 0.0)
            {
              float v158 = v156 * v18;
              if (v4)
              {
                float v159 = COERCE_FLOAT(bswap32(*v14));
                if (v159 <= 0.0) {
                  goto LABEL_209;
                }
              }
              else
              {
                float v159 = 1.0;
              }
              float v160 = COERCE_FLOAT(bswap32(*v20));
              float v161 = v157 * v160;
              if ((float)(v158 * v159) < (float)(v157 * v160)) {
                float v161 = v158 * v159;
              }
              float v162 = v161 + (float)(v160 * (float)(1.0 - v157));
              if (v157 == 1.0) {
                float v162 = v161;
              }
              float v158 = v162 + (float)(v158 * (float)(1.0 - v159));
              if (v159 == 1.0) {
                float v158 = v162;
              }
              if (v4)
              {
                float v157 = (float)(v157 + v159) - (float)(v159 * v157);
LABEL_209:
                *unsigned int v20 = bswap32(LODWORD(v158));
                *int v14 = bswap32(LODWORD(v157));
                goto LABEL_211;
              }
              *unsigned int v20 = bswap32(LODWORD(v158));
            }
          }
LABEL_211:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v154);
          --v155;
        }
        while (v155);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 17:
      uint64_t v163 = 4 * v15;
      while (1)
      {
        int v164 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v165 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v166 = v7 * v165;
            if ((float)(v7 * v165) > 0.0)
            {
              float v167 = v165 * v18;
              if (v4)
              {
                float v168 = COERCE_FLOAT(bswap32(*v14));
                if (v168 <= 0.0) {
                  goto LABEL_230;
                }
              }
              else
              {
                float v168 = 1.0;
              }
              float v169 = COERCE_FLOAT(bswap32(*v20));
              float v170 = v166 * v169;
              if ((float)(v167 * v168) > (float)(v166 * v169)) {
                float v170 = v167 * v168;
              }
              float v171 = v170 + (float)(v169 * (float)(1.0 - v166));
              if (v166 == 1.0) {
                float v171 = v170;
              }
              float v167 = v171 + (float)(v167 * (float)(1.0 - v168));
              if (v168 == 1.0) {
                float v167 = v171;
              }
              if (v4)
              {
                float v166 = (float)(v166 + v168) - (float)(v168 * v166);
LABEL_230:
                *unsigned int v20 = bswap32(LODWORD(v167));
                *int v14 = bswap32(LODWORD(v166));
                goto LABEL_232;
              }
              *unsigned int v20 = bswap32(LODWORD(v167));
            }
          }
LABEL_232:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v163);
          --v164;
        }
        while (v164);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 18:
      uint64_t v172 = 4 * v15;
      while (1)
      {
        int v173 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v174 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v175 = v7 * v174;
            if ((float)(v7 * v174) > 0.0)
            {
              float v176 = v174 * *(float *)v3.i32;
              if (v4)
              {
                float v177 = COERCE_FLOAT(bswap32(*v14));
                if (v177 <= 0.0) {
                  goto LABEL_245;
                }
              }
              else
              {
                float v177 = 1.0;
              }
              float v178 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v20)), v177, v176, v175);
              float v176 = v178;
              if (v4)
              {
                float v175 = v179;
                *(float *)v3.i32 = v372;
LABEL_245:
                *unsigned int v20 = bswap32(LODWORD(v176));
                *int v14 = bswap32(LODWORD(v175));
                goto LABEL_247;
              }
              *unsigned int v20 = bswap32(LODWORD(v178));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_247:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v172);
          --v173;
        }
        while (v173);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        int v9 = v26;
        if (!v10) {
          return;
        }
      }
    case 19:
      uint64_t v180 = 4 * v15;
      while (1)
      {
        int v181 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v182 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v183 = v7 * v182;
            if ((float)(v7 * v182) > 0.0)
            {
              float v184 = v182 * *(float *)v3.i32;
              if (v4)
              {
                float v185 = COERCE_FLOAT(bswap32(*v14));
                if (v185 <= 0.0) {
                  goto LABEL_260;
                }
              }
              else
              {
                float v185 = 1.0;
              }
              double v186 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v20)), v185, v184, v183);
              float v184 = *(float *)&v186;
              if (v4)
              {
                float v183 = v187;
                *(float *)v3.i32 = v372;
LABEL_260:
                *unsigned int v20 = bswap32(LODWORD(v184));
                *int v14 = bswap32(LODWORD(v183));
                goto LABEL_262;
              }
              *unsigned int v20 = bswap32(LODWORD(v186));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_262:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v180);
          --v181;
        }
        while (v181);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        int v9 = v26;
        if (!v10) {
          return;
        }
      }
    case 20:
      uint64_t v188 = 4 * v15;
      while (1)
      {
        int v189 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v190 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v191 = v7 * v190;
            if ((float)(v7 * v190) > 0.0)
            {
              float v192 = v190 * *(float *)v3.i32;
              if (v4)
              {
                float v193 = COERCE_FLOAT(bswap32(*v14));
                if (v193 <= 0.0) {
                  goto LABEL_275;
                }
              }
              else
              {
                float v193 = 1.0;
              }
              float v194 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v20)), v193, v192, v191);
              float v192 = v194;
              if (v4)
              {
                float v191 = v195;
                *(float *)v3.i32 = v372;
LABEL_275:
                *unsigned int v20 = bswap32(LODWORD(v192));
                *int v14 = bswap32(LODWORD(v191));
                goto LABEL_277;
              }
              *unsigned int v20 = bswap32(LODWORD(v194));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_277:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v188);
          --v189;
        }
        while (v189);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        int v9 = v26;
        if (!v10) {
          return;
        }
      }
    case 21:
      uint64_t v196 = 4 * v15;
      while (1)
      {
        int v197 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v198 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v199 = v7 * v198;
            if ((float)(v7 * v198) > 0.0)
            {
              float v200 = v198 * *(float *)v3.i32;
              if (v4)
              {
                float v201 = COERCE_FLOAT(bswap32(*v14));
                if (v201 <= 0.0) {
                  goto LABEL_290;
                }
              }
              else
              {
                float v201 = 1.0;
              }
              float v202 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v20)), v201, v200, v199);
              float v200 = v202;
              if (v4)
              {
                float v199 = v203;
                *(float *)v3.i32 = v372;
LABEL_290:
                *unsigned int v20 = bswap32(LODWORD(v200));
                *int v14 = bswap32(LODWORD(v199));
                goto LABEL_292;
              }
              *unsigned int v20 = bswap32(LODWORD(v202));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_292:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v196);
          --v197;
        }
        while (v197);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        int v9 = v26;
        if (!v10) {
          return;
        }
      }
    case 22:
      uint64_t v204 = 4 * v15;
      while (1)
      {
        int v205 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v206 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v207 = v7 * v206;
            if ((float)(v7 * v206) > 0.0)
            {
              float v208 = v206 * v18;
              if (v4)
              {
                float v209 = COERCE_FLOAT(bswap32(*v14));
                if (v209 <= 0.0) {
                  goto LABEL_307;
                }
              }
              else
              {
                float v209 = 1.0;
              }
              float v210 = COERCE_FLOAT(bswap32(*v20));
              float v211 = v208 + v210;
              float v212 = v208 * v209;
              float v213 = (float)(v207 * v210) - v212;
              float v214 = (float)(v211 - (float)(v207 * v210)) - v212;
              if (v213 < 0.0) {
                float v213 = -v213;
              }
              float v208 = v214 + v213;
              if (v4)
              {
                float v207 = (float)(v207 + v209) - (float)(v209 * v207);
LABEL_307:
                *unsigned int v20 = bswap32(LODWORD(v208));
                *int v14 = bswap32(LODWORD(v207));
                goto LABEL_309;
              }
              *unsigned int v20 = bswap32(LODWORD(v208));
            }
          }
LABEL_309:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v204);
          --v205;
        }
        while (v205);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 23:
      uint64_t v215 = 4 * v15;
      while (1)
      {
        int v216 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v217 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v218 = v7 * v217;
            if ((float)(v7 * v217) > 0.0)
            {
              float v219 = v217 * v18;
              if (v4)
              {
                float v220 = COERCE_FLOAT(bswap32(*v14));
                if (v220 <= 0.0) {
                  goto LABEL_322;
                }
              }
              else
              {
                float v220 = 1.0;
              }
              float v221 = COERCE_FLOAT(bswap32(*v20));
              float v219 = (float)(v219 + v221) + (float)((float)(v219 * v221) * -2.0);
              if (v4)
              {
                float v218 = (float)(v218 + v220) - (float)(v220 * v218);
LABEL_322:
                *unsigned int v20 = bswap32(LODWORD(v219));
                *int v14 = bswap32(LODWORD(v218));
                goto LABEL_324;
              }
              *unsigned int v20 = bswap32(LODWORD(v219));
            }
          }
LABEL_324:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v215);
          --v216;
        }
        while (v216);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 24:
      uint64_t v222 = 4 * v15;
      while (1)
      {
        int v223 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v224 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v225 = v7 * v224;
            if ((float)(v7 * v224) > 0.0)
            {
              float v226 = v224 * v18;
              if (v4)
              {
                float v227 = COERCE_FLOAT(bswap32(*v14));
                if (v227 <= 0.0) {
                  goto LABEL_342;
                }
              }
              else
              {
                float v227 = 1.0;
              }
              float v228 = COERCE_FLOAT(bswap32(*v20));
              float v229 = v228;
              if (v225 == 1.0)
              {
                float v230 = 0.0;
              }
              else
              {
                float v229 = v225 * v228;
                float v230 = v228 - (float)(v225 * v228);
              }
              float v231 = (float)(v226 + v230) - (float)(v226 * v227);
              if (v227 == 1.0) {
                float v231 = v230;
              }
              float v226 = v229 + v231;
              if (v4)
              {
                float v225 = (float)(v225 + v227) - (float)(v225 * v227);
LABEL_342:
                *unsigned int v20 = bswap32(LODWORD(v226));
                *int v14 = bswap32(LODWORD(v225));
                goto LABEL_344;
              }
              *unsigned int v20 = bswap32(LODWORD(v226));
            }
          }
LABEL_344:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v222);
          --v223;
        }
        while (v223);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 25:
      uint64_t v232 = 4 * v15;
      while (1)
      {
        int v233 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v234 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v235 = v7 * v234;
            if ((float)(v7 * v234) > 0.0)
            {
              float v236 = v234 * v18;
              if (v4)
              {
                float v237 = COERCE_FLOAT(bswap32(*v14));
                if (v237 <= 0.0) {
                  goto LABEL_362;
                }
              }
              else
              {
                float v237 = 1.0;
              }
              float v238 = COERCE_FLOAT(bswap32(*v20));
              float v239 = v238;
              if (v235 == 1.0)
              {
                float v240 = 0.0;
              }
              else
              {
                float v239 = v235 * v238;
                float v240 = v238 - (float)(v235 * v238);
              }
              float v241 = (float)(v236 + v240) - (float)(v236 * v237);
              if (v237 == 1.0) {
                float v241 = v240;
              }
              float v236 = v239 + v241;
              if (v4)
              {
                float v235 = (float)(v235 + v237) - (float)(v235 * v237);
LABEL_362:
                *unsigned int v20 = bswap32(LODWORD(v236));
                *int v14 = bswap32(LODWORD(v235));
                goto LABEL_364;
              }
              *unsigned int v20 = bswap32(LODWORD(v236));
            }
          }
LABEL_364:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v232);
          --v233;
        }
        while (v233);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 26:
      uint64_t v242 = 4 * v15;
      while (1)
      {
        int v243 = v9;
        do
        {
          if (*(unsigned char *)v22)
          {
            float v244 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            float v245 = v7 * v244;
            if ((float)(v7 * v244) > 0.0)
            {
              float v246 = v244 * v18;
              if (v4)
              {
                float v247 = COERCE_FLOAT(bswap32(*v14));
                if (v247 <= 0.0) {
                  goto LABEL_381;
                }
              }
              else
              {
                float v247 = 1.0;
              }
              float v248 = COERCE_FLOAT(bswap32(*v20));
              float v249 = v248;
              float v250 = v246 - (float)(v246 * v247);
              if (v247 == 1.0) {
                float v250 = 0.0;
              }
              if (v245 != 1.0)
              {
                float v249 = v245 * v248;
                float v250 = (float)(v250 + v248) - (float)(v245 * v248);
              }
              float v246 = v249 + v250;
              if (v4)
              {
                float v245 = (float)(v245 + v247) - (float)(v245 * v247);
LABEL_381:
                *unsigned int v20 = bswap32(LODWORD(v246));
                *int v14 = bswap32(LODWORD(v245));
                goto LABEL_383;
              }
              *unsigned int v20 = bswap32(LODWORD(v246));
            }
          }
LABEL_383:
          ++v22;
          ++v20;
          int v14 = (unsigned int *)((char *)v14 + v242);
          --v243;
        }
        while (v243);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10) {
          return;
        }
      }
    case 27:
      uint64_t v251 = 4 * v15;
      break;
    default:
      return;
  }
  do
  {
    int v252 = v9;
    do
    {
      if (*(unsigned char *)v22)
      {
        float v253 = (float)*(unsigned __int8 *)v22 * 0.0039216;
        float v254 = v7 * v253;
        if ((float)(v7 * v253) > 0.0)
        {
          float v255 = v253 * v18;
          if (v4)
          {
            float v256 = COERCE_FLOAT(bswap32(*v14));
            if (v256 <= 0.0) {
              goto LABEL_400;
            }
          }
          else
          {
            float v256 = 1.0;
          }
          float v257 = COERCE_FLOAT(bswap32(*v20));
          float v258 = v257 - (float)(v254 * v257);
          if (v254 == 1.0) {
            float v258 = 0.0;
          }
          float v259 = (float)(v255 + v258) - (float)(v255 * v256);
          if (v256 != 1.0)
          {
            float v255 = v255 * v256;
            float v258 = v259;
          }
          float v255 = v255 + v258;
          if (v4)
          {
            float v254 = (float)(v254 + v256) - (float)(v254 * v256);
LABEL_400:
            *unsigned int v20 = bswap32(LODWORD(v255));
            *int v14 = bswap32(LODWORD(v254));
            goto LABEL_402;
          }
          *unsigned int v20 = bswap32(LODWORD(v255));
        }
      }
LABEL_402:
      ++v22;
      ++v20;
      int v14 = (unsigned int *)((char *)v14 + v251);
      --v252;
    }
    while (v252);
    v22 += v23;
    v20 += v24;
    v14 += v17;
    --v10;
  }
  while (v10);
}

void WF_mark_pixelmask(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v5 = *(int *)(a1 + 12);
  uint64_t v4 = *(int *)(a1 + 16);
  if (v2)
  {
    unint64_t v6 = (unint64_t)*(int *)(a1 + 32) >> 2;
    float v7 = (unsigned int *)(v2 + 4 * (v5 + v6 * v4));
    int v8 = -1;
    if (!v3) {
      return;
    }
  }
  else
  {
    float v7 = 0;
    unint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return;
    }
  }
  int v10 = *(_DWORD *)(a1 + 4);
  int v9 = *(_DWORD *)(a1 + 8);
  unint64_t v12 = *(void *)(a1 + 88);
  uint64_t v11 = *(void *)(a1 + 96);
  unint64_t v13 = (unint64_t)*(int *)(a1 + 28) >> 2;
  int v14 = (unsigned int *)(*(void *)(a1 + 40) + 4 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(a1 + 124);
  unint64_t v16 = (unsigned char *)(v3 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(a1 + 56);
  uint64_t v18 = *(int *)(a1 + 60);
  unint64_t v19 = *(int *)(a1 + 76);
  if ((*(_DWORD *)a1 & 0xFF00) == 0x100)
  {
    uint64_t v20 = v19 >> 2;
    if (v11)
    {
      unint64_t v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
      v11 += 4 * (v17 + v21 * v18);
      int v738 = -1;
    }
    else
    {
      unint64_t v21 = 0;
      int v738 = 0;
    }
    unint64_t v24 = (unsigned int *)(v12 + 4 * (v17 + v20 * v18));
    if (v20 == v13 && (char *)v14 - (char *)v24 >= 1)
    {
      if (v10 >= (uint64_t)((unint64_t)((char *)v14 - (char *)v24) >> 2))
      {
        v14 += v10 - 1;
        v24 += v10 - 1;
        v16 += v10 - 1;
        v7 += v8 & (v10 - 1);
        int v26 = -1;
        uint64_t v20 = (unint64_t)*(int *)(a1 + 28) >> 2;
        v11 += 4 * (v738 & (v10 - 1));
        goto LABEL_16;
      }
      uint64_t v25 = v9 - 1;
      if (v14 <= &v24[v13 * v25 - 1 + v10])
      {
        v14 += v13 * v25;
        uint64_t v20 = -(uint64_t)v13;
        v16 += v15 * v25;
        uint64_t v15 = -v15;
        v7 += v6 * v25;
        unint64_t v6 = -(uint64_t)v6;
        v8 &= 1u;
        v11 += 4 * v21 * v25;
        unint64_t v21 = -(uint64_t)v21;
        v738 &= 1u;
        int v26 = 1;
        v24 += v13 * v25;
        unint64_t v13 = -(uint64_t)v13;
        goto LABEL_16;
      }
    }
    v8 &= 1u;
    v738 &= 1u;
    int v26 = 1;
LABEL_16:
    unint64_t v27 = 0;
    v736 = 0;
    unint64_t v12 = -1;
    int v23 = v21;
    int v22 = v20;
    goto LABEL_19;
  }
  int v22 = *(_DWORD *)(a1 + 64);
  int v23 = *(_DWORD *)(a1 + 68);
  uint64_t v20 = v19 >> 2;
  if (v11)
  {
    unint64_t v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
    int v738 = 1;
  }
  else
  {
    unint64_t v21 = 0;
    int v738 = 0;
  }
  unint64_t v27 = v12 + 4 * v20 * v23;
  v8 &= 1u;
  int v26 = 1;
  v736 = *(unsigned int **)(a1 + 88);
  unint64_t v24 = v736;
LABEL_19:
  int v737 = v8;
  int v28 = v26 * v10;
  if (v27)
  {
    uint64_t v29 = (int)v18 % v23;
    int v30 = &v24[v20 * v29];
    uint64_t v31 = (int)v17 % v22;
    unint64_t v24 = &v30[v31];
    unint64_t v12 = (unint64_t)&v30[v22];
    if (v738) {
      v11 += 4 * v21 * v29 + 4 * v31;
    }
    v736 = &v30[v31];
  }
  else
  {
    v20 -= v28;
    v21 -= v738 * v10;
  }
  uint64_t v32 = v15 - v28;
  unint64_t v33 = v13 - v28;
  unint64_t v735 = v6 - v737 * v10;
  uint64_t v712 = v20;
  int v713 = v10;
  unint64_t v710 = v33;
  uint64_t v711 = v32;
  unint64_t v714 = v27;
  switch(a2)
  {
    case 0:
      if (v737)
      {
        do
        {
          int v34 = v10;
          do
          {
            unsigned int v35 = *v16;
            if (*v16)
            {
              if (v35 == 255)
              {
                *float v7 = 0;
                *int v14 = 0;
              }
              else
              {
                float v36 = (float)((float)v35 * -0.0039216) + 1.0;
                unsigned int v37 = bswap32(COERCE_UNSIGNED_INT(v36 * COERCE_FLOAT(bswap32(*v7))));
                *int v14 = bswap32(COERCE_UNSIGNED_INT(v36 * COERCE_FLOAT(bswap32(*v14))));
                *float v7 = v37;
              }
            }
            v16 += v26;
            v7 += v737;
            v14 += v26;
            --v34;
          }
          while (v34);
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v601 = v10;
          do
          {
            unsigned int v602 = *v16;
            if (*v16)
            {
              if (v602 == 255) {
                *int v14 = 0;
              }
              else {
                *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v602 * -0.0039216) + 1.0) * COERCE_FLOAT(bswap32(*v14))));
              }
            }
            v16 += v26;
            v14 += v26;
            --v601;
          }
          while (v601);
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 1:
      if (v737)
      {
        uint64_t v38 = v26;
        if (v738)
        {
          uint64_t v39 = v23;
          uint64_t v40 = -(v20 * v23);
          uint64_t v41 = -(uint64_t)(v21 * v39);
          unsigned int v42 = (unsigned int *)v11;
          uint64_t v43 = -(uint64_t)v22;
          do
          {
            int v44 = v10;
            do
            {
              unsigned int v45 = *v16;
              if (*v16)
              {
                if (v45 == 255)
                {
                  *int v14 = *v24;
                  *float v7 = *v42;
                }
                else
                {
                  float v46 = (float)v45 * 0.0039216;
                  unsigned int v47 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v46) * COERCE_FLOAT(bswap32(*v7)))+ (float)(COERCE_FLOAT(bswap32(*v42)) * v46)));
                  *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v46) * COERCE_FLOAT(bswap32(*v14)))+ (float)(COERCE_FLOAT(bswap32(*v24)) * v46)));
                  *float v7 = v47;
                }
              }
              v16 += v38;
              unint64_t v48 = &v24[v38];
              long long v49 = &v42[v738];
              if ((unint64_t)v48 >= v12) {
                uint64_t v50 = v43;
              }
              else {
                uint64_t v50 = 0;
              }
              unsigned int v42 = &v49[v50];
              unint64_t v24 = &v48[v50];
              v7 += v737;
              v14 += v38;
              --v44;
            }
            while (v44);
            if (v27)
            {
              int v51 = &v736[v20];
              if ((unint64_t)v51 >= v27) {
                uint64_t v52 = v41;
              }
              else {
                uint64_t v52 = 0;
              }
              v11 += 4 * v21 + 4 * v52;
              if ((unint64_t)v51 >= v27) {
                uint64_t v53 = v40;
              }
              else {
                uint64_t v53 = 0;
              }
              unint64_t v24 = &v51[v53];
              v12 += 4 * v53 + 4 * v20;
              unsigned int v42 = (unsigned int *)v11;
              v736 = v24;
            }
            else
            {
              v24 += v20;
              v42 += v21;
            }
            v16 += v32;
            v14 += v33;
            v7 += v735;
            --v9;
          }
          while (v9);
        }
        else
        {
          uint64_t v686 = -(uint64_t)v22;
          uint64_t v687 = -(v20 * v23);
          do
          {
            int v688 = v10;
            do
            {
              unsigned int v689 = *v16;
              if (*v16)
              {
                if (v689 == 255)
                {
                  unsigned int v690 = *v24;
                  unsigned int v691 = 32831;
                }
                else
                {
                  float v692 = (float)v689 * 0.0039216;
                  unsigned int v690 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v692) * COERCE_FLOAT(bswap32(*v14)))+ (float)(COERCE_FLOAT(bswap32(*v24)) * v692)));
                  unsigned int v691 = bswap32(COERCE_UNSIGNED_INT(v692 + (float)((float)(1.0 - v692) * COERCE_FLOAT(bswap32(*v7)))));
                }
                *int v14 = v690;
                *float v7 = v691;
              }
              v16 += v38;
              uint64_t v693 = &v24[v38];
              if ((unint64_t)v693 >= v12) {
                uint64_t v694 = v686;
              }
              else {
                uint64_t v694 = 0;
              }
              unint64_t v24 = &v693[v694];
              v7 += v737;
              v14 += v38;
              --v688;
            }
            while (v688);
            v16 += v32;
            v14 += v33;
            uint64_t v695 = v736;
            v7 += v735;
            uint64_t v696 = &v736[v20];
            if ((unint64_t)v696 >= v27) {
              uint64_t v697 = v687;
            }
            else {
              uint64_t v697 = 0;
            }
            uint64_t v698 = &v696[v697];
            uint64_t v699 = v12 + 4 * v697 + 4 * v20;
            if (v27)
            {
              unint64_t v12 = v699;
              uint64_t v695 = v698;
            }
            v736 = v695;
            if (v27) {
              unint64_t v24 = v698;
            }
            else {
              v24 += v20;
            }
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        uint64_t v603 = v26;
        uint64_t v604 = -(uint64_t)v22;
        uint64_t v605 = -(v20 * v23);
        uint64_t v606 = 4 * v26;
        do
        {
          int v607 = v10;
          do
          {
            unsigned int v608 = *v16;
            if (*v16)
            {
              if (v608 == 255) {
                *int v14 = *v24;
              }
              else {
                *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - (float)((float)v608 * 0.0039216)) * COERCE_FLOAT(bswap32(*v14)))+ (float)(COERCE_FLOAT(bswap32(*v24)) * (float)((float)v608 * 0.0039216))));
              }
            }
            v16 += v603;
            uint64_t v609 = &v24[v603];
            if ((unint64_t)v609 >= v12) {
              uint64_t v610 = v604;
            }
            else {
              uint64_t v610 = 0;
            }
            unint64_t v24 = &v609[v610];
            int v14 = (unsigned int *)((char *)v14 + v606);
            --v607;
          }
          while (v607);
          v16 += v32;
          v14 += v33;
          uint64_t v611 = v736;
          uint64_t v612 = &v736[v20];
          if ((unint64_t)v612 >= v27) {
            uint64_t v613 = v605;
          }
          else {
            uint64_t v613 = 0;
          }
          uint64_t v614 = &v612[v613];
          uint64_t v615 = v12 + 4 * v613 + 4 * v20;
          if (v27)
          {
            unint64_t v12 = v615;
            uint64_t v611 = v614;
          }
          v736 = v611;
          if (v27) {
            unint64_t v24 = v614;
          }
          else {
            v24 += v20;
          }
          --v9;
        }
        while (v9);
      }
      return;
    case 2:
      uint64_t v54 = v26;
      if (v737)
      {
        uint64_t v55 = -(uint64_t)v22;
        uint64_t v56 = v23;
        uint64_t v57 = -(v20 * v23);
        uint64_t v58 = -(uint64_t)(v21 * v56);
        float v59 = (unsigned int *)v11;
        while (1)
        {
          int v60 = v10;
          do
          {
            unsigned int v61 = *v16;
            if (!*v16) {
              goto LABEL_72;
            }
            if (v61 == 255)
            {
              unsigned int v62 = *v59;
              float v63 = COERCE_FLOAT(bswap32(*v59));
              float v64 = v63;
              if (v63 >= 1.0)
              {
                unsigned int v67 = *v24;
                goto LABEL_71;
              }
              if (v63 <= 0.0) {
                goto LABEL_72;
              }
              float v65 = COERCE_FLOAT(bswap32(*v24));
            }
            else
            {
              float v66 = (float)v61 * 0.0039216;
              float v64 = v66 * COERCE_FLOAT(bswap32(*v59));
              if (v64 <= 0.0) {
                goto LABEL_72;
              }
              float v65 = v66 * COERCE_FLOAT(bswap32(*v24));
            }
            unsigned int v67 = bswap32(COERCE_UNSIGNED_INT(v65 + (float)(COERCE_FLOAT(bswap32(*v14)) * (float)(1.0 - v64))));
            unsigned int v62 = bswap32(COERCE_UNSIGNED_INT(v64 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v64))));
LABEL_71:
            *int v14 = v67;
            *float v7 = v62;
LABEL_72:
            v16 += v54;
            float v68 = &v24[v54];
            float v69 = &v59[v738];
            if ((unint64_t)v68 >= v12) {
              uint64_t v70 = v55;
            }
            else {
              uint64_t v70 = 0;
            }
            float v59 = &v69[v70];
            unint64_t v24 = &v68[v70];
            v7 += v737;
            v14 += v54;
            --v60;
          }
          while (v60);
          if (v27)
          {
            float v71 = &v736[v20];
            if ((unint64_t)v71 >= v27) {
              uint64_t v72 = v58;
            }
            else {
              uint64_t v72 = 0;
            }
            v11 += 4 * v21 + 4 * v72;
            if ((unint64_t)v71 >= v27) {
              uint64_t v73 = v57;
            }
            else {
              uint64_t v73 = 0;
            }
            unint64_t v24 = &v71[v73];
            v12 += 4 * v73 + 4 * v20;
            float v59 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v59 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          if (!--v9) {
            return;
          }
        }
      }
      uint64_t v616 = -(uint64_t)v22;
      uint64_t v617 = v23;
      uint64_t v618 = -(v20 * v23);
      uint64_t v619 = -(uint64_t)(v21 * v617);
      uint64_t v620 = (unsigned int *)v11;
LABEL_830:
      int v621 = v10;
      while (1)
      {
        unsigned int v622 = *v16;
        if (*v16)
        {
          if (v622 == 255)
          {
            float v623 = COERCE_FLOAT(bswap32(*v620));
            if (v623 >= 1.0)
            {
              *int v14 = *v24;
              goto LABEL_840;
            }
            if (v623 > 0.0)
            {
              float v624 = COERCE_FLOAT(bswap32(*v24)) + (float)(COERCE_FLOAT(bswap32(*v14)) * (float)(1.0 - v623));
LABEL_838:
              *int v14 = bswap32(LODWORD(v624));
            }
          }
          else
          {
            float v625 = (float)v622 * 0.0039216;
            float v626 = v625 * COERCE_FLOAT(bswap32(*v620));
            if (v626 > 0.0)
            {
              float v624 = (float)(v625 * COERCE_FLOAT(bswap32(*v24)))
                   + (float)(COERCE_FLOAT(bswap32(*v14)) * (float)(1.0 - v626));
              goto LABEL_838;
            }
          }
        }
LABEL_840:
        v16 += v54;
        uint64_t v627 = &v24[v54];
        uint64_t v628 = &v620[v738];
        if ((unint64_t)v627 >= v12) {
          uint64_t v629 = v616;
        }
        else {
          uint64_t v629 = 0;
        }
        uint64_t v620 = &v628[v629];
        unint64_t v24 = &v627[v629];
        v14 += v54;
        if (!--v621)
        {
          if (v27)
          {
            uint64_t v630 = &v736[v20];
            if ((unint64_t)v630 >= v27) {
              uint64_t v631 = v619;
            }
            else {
              uint64_t v631 = 0;
            }
            v11 += 4 * v21 + 4 * v631;
            if ((unint64_t)v630 >= v27) {
              uint64_t v632 = v618;
            }
            else {
              uint64_t v632 = 0;
            }
            unint64_t v24 = &v630[v632];
            v12 += 4 * v632 + 4 * v20;
            uint64_t v620 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v620 += v21;
          }
          v16 += v32;
          v14 += v33;
          if (!--v9) {
            return;
          }
          goto LABEL_830;
        }
      }
    case 3:
      uint64_t v74 = v26;
      uint64_t v75 = v23;
      uint64_t v76 = -(v20 * v23);
      uint64_t v77 = -(uint64_t)(v21 * v75);
      uint64_t v78 = 4 * v26;
      uint64_t v79 = -(uint64_t)v22;
      float v80 = (unsigned int *)v11;
      do
      {
        int v81 = v10;
        do
        {
          unsigned int v82 = *v16;
          if (*v16)
          {
            if (v82 == 255)
            {
              if (v738) {
                float v83 = COERCE_FLOAT(bswap32(*v80));
              }
              else {
                float v83 = 1.0;
              }
              float v85 = COERCE_FLOAT(bswap32(*v7));
              float v86 = COERCE_FLOAT(bswap32(*v24)) * v85;
              float v87 = v83 * v85;
            }
            else
            {
              if (v738) {
                float v84 = COERCE_FLOAT(bswap32(*v80));
              }
              else {
                float v84 = 1.0;
              }
              float v88 = (float)v82 * 0.0039216;
              float v89 = COERCE_FLOAT(bswap32(*v7));
              float v90 = v88 * v89;
              float v91 = 1.0 - v88;
              float v86 = (float)((float)(1.0 - v88) * COERCE_FLOAT(bswap32(*v14)))
                  + (float)(COERCE_FLOAT(bswap32(*v24)) * (float)(v88 * v89));
              float v87 = (float)(v91 * v89) + (float)(v84 * v90);
            }
            *int v14 = bswap32(LODWORD(v86));
            *float v7 = bswap32(LODWORD(v87));
          }
          v16 += v74;
          int v92 = &v24[v74];
          unsigned int v93 = &v80[v738];
          if ((unint64_t)v92 >= v12) {
            uint64_t v94 = v79;
          }
          else {
            uint64_t v94 = 0;
          }
          float v80 = &v93[v94];
          unint64_t v24 = &v92[v94];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v78);
          --v81;
        }
        while (v81);
        if (v27)
        {
          float v95 = &v736[v20];
          if ((unint64_t)v95 >= v27) {
            uint64_t v96 = v77;
          }
          else {
            uint64_t v96 = 0;
          }
          v11 += 4 * v21 + 4 * v96;
          if ((unint64_t)v95 >= v27) {
            uint64_t v97 = v76;
          }
          else {
            uint64_t v97 = 0;
          }
          unint64_t v24 = &v95[v97];
          v12 += 4 * v97 + 4 * v20;
          float v80 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v80 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 4:
      uint64_t v98 = v26;
      uint64_t v99 = v23;
      uint64_t v100 = -(v20 * v23);
      uint64_t v101 = -(uint64_t)(v21 * v99);
      uint64_t v102 = 4 * v26;
      uint64_t v103 = -(uint64_t)v22;
      uint64_t v104 = (unsigned int *)v11;
      do
      {
        int v105 = v10;
        do
        {
          unsigned int v106 = *v16;
          if (*v16)
          {
            if (v106 == 255)
            {
              if (v738) {
                float v107 = COERCE_FLOAT(bswap32(*v104));
              }
              else {
                float v107 = 1.0;
              }
              float v109 = 1.0 - COERCE_FLOAT(bswap32(*v7));
              float v110 = v109 * COERCE_FLOAT(bswap32(*v24));
              float v111 = v107 * v109;
            }
            else
            {
              if (v738) {
                float v108 = COERCE_FLOAT(bswap32(*v104));
              }
              else {
                float v108 = 1.0;
              }
              float v112 = (float)v106 * 0.0039216;
              float v113 = COERCE_FLOAT(bswap32(*v7));
              float v114 = v112 * (float)(1.0 - v113);
              float v115 = 1.0 - v112;
              float v110 = (float)((float)(1.0 - v112) * COERCE_FLOAT(bswap32(*v14)))
                   + (float)(COERCE_FLOAT(bswap32(*v24)) * v114);
              float v111 = (float)(v115 * v113) + (float)(v108 * v114);
            }
            *int v14 = bswap32(LODWORD(v110));
            *float v7 = bswap32(LODWORD(v111));
          }
          v16 += v98;
          float v116 = &v24[v98];
          uint64_t v117 = &v104[v738];
          if ((unint64_t)v116 >= v12) {
            uint64_t v118 = v103;
          }
          else {
            uint64_t v118 = 0;
          }
          uint64_t v104 = &v117[v118];
          unint64_t v24 = &v116[v118];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v102);
          --v105;
        }
        while (v105);
        if (v27)
        {
          float v119 = &v736[v20];
          if ((unint64_t)v119 >= v27) {
            uint64_t v120 = v101;
          }
          else {
            uint64_t v120 = 0;
          }
          v11 += 4 * v21 + 4 * v120;
          if ((unint64_t)v119 >= v27) {
            uint64_t v121 = v100;
          }
          else {
            uint64_t v121 = 0;
          }
          unint64_t v24 = &v119[v121];
          v12 += 4 * v121 + 4 * v20;
          uint64_t v104 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v104 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 5:
      uint64_t v122 = v26;
      uint64_t v123 = v23;
      uint64_t v124 = -(v20 * v23);
      uint64_t v125 = -(uint64_t)(v21 * v123);
      uint64_t v126 = 4 * v26;
      uint64_t v127 = -(uint64_t)v22;
      float v128 = (unsigned int *)v11;
      do
      {
        int v129 = v10;
        do
        {
          if (*v16)
          {
            float v130 = COERCE_FLOAT(bswap32(*v7));
            float v131 = (float)*v16 * 0.0039216;
            float v132 = v131 * COERCE_FLOAT(bswap32(*v24));
            float v133 = v131 * COERCE_FLOAT(bswap32(*v128));
            *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v133) * COERCE_FLOAT(bswap32(*v14))) + (float)(v132 * v130)));
            *float v7 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v133) * v130) + (float)(v133 * v130)));
          }
          v16 += v122;
          float v134 = &v24[v122];
          float v135 = &v128[v738];
          if ((unint64_t)v134 >= v12) {
            uint64_t v136 = v127;
          }
          else {
            uint64_t v136 = 0;
          }
          float v128 = &v135[v136];
          unint64_t v24 = &v134[v136];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v126);
          --v129;
        }
        while (v129);
        if (v27)
        {
          float v137 = &v736[v20];
          if ((unint64_t)v137 >= v27) {
            uint64_t v138 = v125;
          }
          else {
            uint64_t v138 = 0;
          }
          v11 += 4 * v21 + 4 * v138;
          if ((unint64_t)v137 >= v27) {
            uint64_t v139 = v124;
          }
          else {
            uint64_t v139 = 0;
          }
          unint64_t v24 = &v137[v139];
          v12 += 4 * v139 + 4 * v20;
          float v128 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v128 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 6:
      uint64_t v140 = v26;
      uint64_t v141 = v23;
      uint64_t v142 = -(v20 * v23);
      uint64_t v143 = -(uint64_t)(v21 * v141);
      uint64_t v144 = 4 * v26;
      uint64_t v145 = -(uint64_t)v22;
      uint64_t v146 = (unsigned int *)v11;
      while (1)
      {
        int v147 = v10;
        do
        {
          unsigned int v148 = *v16;
          if (!*v16) {
            goto LABEL_176;
          }
          float v149 = COERCE_FLOAT(bswap32(*v7));
          float v150 = 1.0 - v149;
          if ((float)(1.0 - v149) >= 1.0)
          {
            if (v738) {
              float v152 = COERCE_FLOAT(bswap32(*v146));
            }
            else {
              float v152 = 1.0;
            }
            float v153 = (float)v148 * 0.0039216;
            float v154 = v153 * COERCE_FLOAT(bswap32(*v24));
            float v155 = v153 * v152;
          }
          else
          {
            if (v150 <= 0.0) {
              goto LABEL_176;
            }
            if (v738) {
              float v151 = COERCE_FLOAT(bswap32(*v146));
            }
            else {
              float v151 = 1.0;
            }
            float v156 = (float)((float)v148 * 0.0039216) * v150;
            float v154 = COERCE_FLOAT(bswap32(*v14)) + (float)(COERCE_FLOAT(bswap32(*v24)) * v156);
            float v155 = v149 + (float)(v151 * v156);
          }
          *int v14 = bswap32(LODWORD(v154));
          *float v7 = bswap32(LODWORD(v155));
LABEL_176:
          v16 += v140;
          float v157 = &v24[v140];
          float v158 = &v146[v738];
          if ((unint64_t)v157 >= v12) {
            uint64_t v159 = v145;
          }
          else {
            uint64_t v159 = 0;
          }
          uint64_t v146 = &v158[v159];
          unint64_t v24 = &v157[v159];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v144);
          --v147;
        }
        while (v147);
        if (v27)
        {
          float v160 = &v736[v20];
          if ((unint64_t)v160 >= v27) {
            uint64_t v161 = v143;
          }
          else {
            uint64_t v161 = 0;
          }
          v11 += 4 * v21 + 4 * v161;
          if ((unint64_t)v160 >= v27) {
            uint64_t v162 = v142;
          }
          else {
            uint64_t v162 = 0;
          }
          unint64_t v24 = &v160[v162];
          v12 += 4 * v162 + 4 * v20;
          uint64_t v146 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v146 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 7:
      uint64_t v163 = v26;
      if (v737)
      {
        uint64_t v164 = v23;
        uint64_t v165 = -(v20 * v23);
        uint64_t v166 = -(uint64_t)(v21 * v164);
        uint64_t v167 = -(uint64_t)v22;
        float v168 = (unsigned int *)v11;
        do
        {
          int v169 = v10;
          do
          {
            unsigned int v170 = *v16;
            if (*v16)
            {
              if (v170 == 255)
              {
                float v171 = COERCE_FLOAT(bswap32(*v168));
                float v172 = COERCE_FLOAT(bswap32(*v14)) * v171;
                float v173 = COERCE_FLOAT(bswap32(*v7)) * v171;
              }
              else
              {
                float v174 = (float)v170 * 0.0039216;
                float v175 = COERCE_FLOAT(bswap32(*v7));
                float v176 = COERCE_FLOAT(bswap32(*v14));
                float v177 = COERCE_FLOAT(bswap32(*v168));
                float v178 = v174 * v177;
                float v179 = 1.0 - v174;
                float v172 = (float)((float)(1.0 - v174) * v176) + (float)(v176 * (float)(v174 * v177));
                float v173 = (float)(v179 * v175) + (float)(v175 * v178);
              }
              *int v14 = bswap32(LODWORD(v172));
              *float v7 = bswap32(LODWORD(v173));
            }
            v16 += v163;
            uint64_t v180 = &v24[v163];
            int v181 = &v168[v738];
            if ((unint64_t)v180 >= v12) {
              uint64_t v182 = v167;
            }
            else {
              uint64_t v182 = 0;
            }
            float v168 = &v181[v182];
            unint64_t v24 = &v180[v182];
            v7 += v737;
            v14 += v163;
            --v169;
          }
          while (v169);
          if (v27)
          {
            float v183 = &v736[v20];
            if ((unint64_t)v183 >= v27) {
              uint64_t v184 = v166;
            }
            else {
              uint64_t v184 = 0;
            }
            v11 += 4 * v21 + 4 * v184;
            if ((unint64_t)v183 >= v27) {
              uint64_t v185 = v165;
            }
            else {
              uint64_t v185 = 0;
            }
            unint64_t v24 = &v183[v185];
            v12 += 4 * v185 + 4 * v20;
            float v168 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v168 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v633 = -(uint64_t)v22;
        uint64_t v634 = v23;
        uint64_t v635 = -(v20 * v23);
        uint64_t v636 = -(uint64_t)(v21 * v634);
        unint64_t v637 = (unsigned int *)v11;
        do
        {
          int v638 = v10;
          do
          {
            unsigned int v639 = *v16;
            if (*v16)
            {
              if (v639 == 255)
              {
                float v640 = COERCE_FLOAT(bswap32(*v14)) * COERCE_FLOAT(bswap32(*v637));
              }
              else
              {
                float v641 = COERCE_FLOAT(bswap32(*v14));
                float v640 = (float)((float)(1.0 - (float)((float)v639 * 0.0039216)) * v641)
                     + (float)(v641 * (float)((float)((float)v639 * 0.0039216) * COERCE_FLOAT(bswap32(*v637))));
              }
              *int v14 = bswap32(LODWORD(v640));
            }
            v16 += v163;
            unint64_t v642 = &v24[v163];
            uint64_t v643 = &v637[v738];
            if ((unint64_t)v642 >= v12) {
              uint64_t v644 = v633;
            }
            else {
              uint64_t v644 = 0;
            }
            unint64_t v637 = &v643[v644];
            unint64_t v24 = &v642[v644];
            v14 += v163;
            --v638;
          }
          while (v638);
          if (v27)
          {
            int v645 = &v736[v20];
            if ((unint64_t)v645 >= v27) {
              uint64_t v646 = v636;
            }
            else {
              uint64_t v646 = 0;
            }
            v11 += 4 * v21 + 4 * v646;
            if ((unint64_t)v645 >= v27) {
              uint64_t v647 = v635;
            }
            else {
              uint64_t v647 = 0;
            }
            unint64_t v24 = &v645[v647];
            v12 += 4 * v647 + 4 * v20;
            unint64_t v637 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v637 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 8:
      uint64_t v186 = v26;
      if (v737)
      {
        uint64_t v187 = -(uint64_t)v22;
        uint64_t v188 = v23;
        uint64_t v189 = -(v20 * v23);
        uint64_t v190 = -(uint64_t)(v21 * v188);
        float v191 = (unsigned int *)v11;
        do
        {
          int v192 = v10;
          do
          {
            unsigned int v193 = *v16;
            if (*v16)
            {
              float v194 = COERCE_FLOAT(bswap32(*v14));
              float v195 = COERCE_FLOAT(bswap32(*v7));
              if (v193 == 255) {
                float v196 = 1.0 - COERCE_FLOAT(bswap32(*v191));
              }
              else {
                float v196 = (float)((float)((float)v193 * -0.0039216) * COERCE_FLOAT(bswap32(*v191))) + 1.0;
              }
              *int v14 = bswap32(COERCE_UNSIGNED_INT(v196 * v194));
              *float v7 = bswap32(COERCE_UNSIGNED_INT(v196 * v195));
            }
            v16 += v186;
            int v197 = &v24[v186];
            float v198 = &v191[v738];
            if ((unint64_t)v197 >= v12) {
              uint64_t v199 = v187;
            }
            else {
              uint64_t v199 = 0;
            }
            float v191 = &v198[v199];
            unint64_t v24 = &v197[v199];
            v7 += v737;
            v14 += v186;
            --v192;
          }
          while (v192);
          if (v27)
          {
            float v200 = &v736[v20];
            if ((unint64_t)v200 >= v27) {
              uint64_t v201 = v190;
            }
            else {
              uint64_t v201 = 0;
            }
            v11 += 4 * v21 + 4 * v201;
            if ((unint64_t)v200 >= v27) {
              uint64_t v202 = v189;
            }
            else {
              uint64_t v202 = 0;
            }
            unint64_t v24 = &v200[v202];
            v12 += 4 * v202 + 4 * v20;
            float v191 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v191 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v648 = -(uint64_t)v22;
        uint64_t v649 = v23;
        uint64_t v650 = -(v20 * v23);
        uint64_t v651 = -(uint64_t)(v21 * v649);
        unint64_t v652 = (unsigned int *)v11;
        do
        {
          int v653 = v10;
          do
          {
            unsigned int v654 = *v16;
            if (*v16)
            {
              float v655 = COERCE_FLOAT(bswap32(*v14));
              if (v654 == 255) {
                float v656 = COERCE_FLOAT(bswap32(*v652));
              }
              else {
                float v656 = (float)((float)v654 * 0.0039216) * COERCE_FLOAT(bswap32(*v652));
              }
              *int v14 = bswap32(COERCE_UNSIGNED_INT((float)(1.0 - v656) * v655));
            }
            v16 += v186;
            uint64_t v657 = &v24[v186];
            uint64_t v658 = &v652[v738];
            if ((unint64_t)v657 >= v12) {
              uint64_t v659 = v648;
            }
            else {
              uint64_t v659 = 0;
            }
            unint64_t v652 = &v658[v659];
            unint64_t v24 = &v657[v659];
            v14 += v186;
            --v653;
          }
          while (v653);
          if (v27)
          {
            int v660 = &v736[v20];
            if ((unint64_t)v660 >= v27) {
              uint64_t v661 = v651;
            }
            else {
              uint64_t v661 = 0;
            }
            v11 += 4 * v21 + 4 * v661;
            if ((unint64_t)v660 >= v27) {
              uint64_t v662 = v650;
            }
            else {
              uint64_t v662 = 0;
            }
            unint64_t v24 = &v660[v662];
            v12 += 4 * v662 + 4 * v20;
            unint64_t v652 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v652 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 9:
      uint64_t v203 = v26;
      uint64_t v204 = v23;
      uint64_t v205 = -(v20 * v23);
      uint64_t v206 = -(uint64_t)(v21 * v204);
      uint64_t v207 = 4 * v26;
      uint64_t v208 = -(uint64_t)v22;
      float v209 = (unsigned int *)v11;
      do
      {
        int v210 = v10;
        do
        {
          if (*v16)
          {
            float v211 = COERCE_FLOAT(bswap32(*v7));
            float v212 = (float)*v16 * 0.0039216;
            float v213 = v212 * COERCE_FLOAT(bswap32(*v24));
            float v214 = v212 * COERCE_FLOAT(bswap32(*v209));
            float v215 = (float)(1.0 - v212) + v214;
            *int v14 = bswap32(COERCE_UNSIGNED_INT((float)(v215 * COERCE_FLOAT(bswap32(*v14))) + (float)(v213 * (float)(1.0 - v211))));
            *float v7 = bswap32(COERCE_UNSIGNED_INT((float)(v215 * v211) + (float)(v214 * (float)(1.0 - v211))));
          }
          v16 += v203;
          int v216 = &v24[v203];
          float v217 = &v209[v738];
          if ((unint64_t)v216 >= v12) {
            uint64_t v218 = v208;
          }
          else {
            uint64_t v218 = 0;
          }
          float v209 = &v217[v218];
          unint64_t v24 = &v216[v218];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v207);
          --v210;
        }
        while (v210);
        if (v27)
        {
          float v219 = &v736[v20];
          if ((unint64_t)v219 >= v27) {
            uint64_t v220 = v206;
          }
          else {
            uint64_t v220 = 0;
          }
          v11 += 4 * v21 + 4 * v220;
          if ((unint64_t)v219 >= v27) {
            uint64_t v221 = v205;
          }
          else {
            uint64_t v221 = 0;
          }
          unint64_t v24 = &v219[v221];
          v12 += 4 * v221 + 4 * v20;
          float v209 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v209 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 10:
      uint64_t v222 = v26;
      uint64_t v223 = v23;
      uint64_t v224 = -(v20 * v23);
      uint64_t v225 = -(uint64_t)(v21 * v223);
      uint64_t v226 = 4 * v26;
      uint64_t v227 = -(uint64_t)v22;
      float v228 = (unsigned int *)v11;
      do
      {
        int v229 = v10;
        do
        {
          if (*v16)
          {
            float v230 = COERCE_FLOAT(bswap32(*v7));
            float v231 = (float)*v16 * 0.0039216;
            float v232 = v231 * COERCE_FLOAT(bswap32(*v24));
            float v233 = v231 * COERCE_FLOAT(bswap32(*v228));
            *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v233) * COERCE_FLOAT(bswap32(*v14))) + (float)(v232 * (float)(1.0 - v230))));
            *float v7 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v233) * v230) + (float)(v233 * (float)(1.0 - v230))));
          }
          v16 += v222;
          float v234 = &v24[v222];
          float v235 = &v228[v738];
          if ((unint64_t)v234 >= v12) {
            uint64_t v236 = v227;
          }
          else {
            uint64_t v236 = 0;
          }
          float v228 = &v235[v236];
          unint64_t v24 = &v234[v236];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v226);
          --v229;
        }
        while (v229);
        if (v27)
        {
          float v237 = &v736[v20];
          if ((unint64_t)v237 >= v27) {
            uint64_t v238 = v225;
          }
          else {
            uint64_t v238 = 0;
          }
          v11 += 4 * v21 + 4 * v238;
          if ((unint64_t)v237 >= v27) {
            uint64_t v239 = v224;
          }
          else {
            uint64_t v239 = 0;
          }
          unint64_t v24 = &v237[v239];
          v12 += 4 * v239 + 4 * v20;
          float v228 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v228 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 11:
      uint64_t v240 = v26;
      if (v737)
      {
        uint64_t v241 = v23;
        uint64_t v242 = -(v20 * v23);
        uint64_t v243 = -(uint64_t)(v21 * v241);
        uint64_t v244 = -(uint64_t)v22;
        float v245 = (unsigned int *)v11;
        do
        {
          int v246 = v10;
          do
          {
            if (*v16)
            {
              if (v738) {
                float v247 = COERCE_FLOAT(bswap32(*v245));
              }
              else {
                float v247 = 1.0;
              }
              float v248 = (float)*v16 * 0.0039216;
              float v249 = v248 * COERCE_FLOAT(bswap32(*v24));
              float v250 = v248 * v247;
              float v251 = COERCE_FLOAT(bswap32(*v14));
              float v252 = COERCE_FLOAT(bswap32(*v7));
              float v253 = v250 + v252;
              if ((float)(v250 + v252) > 1.0) {
                float v253 = 1.0;
              }
              *int v14 = bswap32(COERCE_UNSIGNED_INT((float)(v250 - v249) + (float)(v253 - (float)(v252 - v251))));
              *float v7 = bswap32(LODWORD(v253));
            }
            v16 += v240;
            float v254 = &v24[v240];
            float v255 = &v245[v738];
            if ((unint64_t)v254 >= v12) {
              uint64_t v256 = v244;
            }
            else {
              uint64_t v256 = 0;
            }
            float v245 = &v255[v256];
            unint64_t v24 = &v254[v256];
            v7 += v737;
            v14 += v240;
            --v246;
          }
          while (v246);
          if (v27)
          {
            float v257 = &v736[v20];
            if ((unint64_t)v257 >= v27) {
              uint64_t v258 = v243;
            }
            else {
              uint64_t v258 = 0;
            }
            v11 += 4 * v21 + 4 * v258;
            if ((unint64_t)v257 >= v27) {
              uint64_t v259 = v242;
            }
            else {
              uint64_t v259 = 0;
            }
            unint64_t v24 = &v257[v259];
            v12 += 4 * v259 + 4 * v20;
            float v245 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v245 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v663 = -(uint64_t)v22;
        uint64_t v664 = v23;
        uint64_t v665 = -(v20 * v23);
        uint64_t v666 = -(uint64_t)(v21 * v664);
        uint64_t v667 = (unsigned int *)v11;
        do
        {
          int v668 = v10;
          do
          {
            if (*v16)
            {
              if (v738) {
                float v669 = COERCE_FLOAT(bswap32(*v667));
              }
              else {
                float v669 = 1.0;
              }
              *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)((float)*v16 * 0.0039216) * v669)- (float)((float)((float)*v16 * 0.0039216) * COERCE_FLOAT(bswap32(*v24))))+ COERCE_FLOAT(bswap32(*v14))));
            }
            v16 += v240;
            uint64_t v670 = &v24[v240];
            int32x2_t v671 = &v667[v738];
            if ((unint64_t)v670 >= v12) {
              uint64_t v672 = v663;
            }
            else {
              uint64_t v672 = 0;
            }
            uint64_t v667 = &v671[v672];
            unint64_t v24 = &v670[v672];
            v14 += v240;
            --v668;
          }
          while (v668);
          if (v27)
          {
            uint64_t v673 = &v736[v20];
            if ((unint64_t)v673 >= v27) {
              uint64_t v674 = v666;
            }
            else {
              uint64_t v674 = 0;
            }
            v11 += 4 * v21 + 4 * v674;
            if ((unint64_t)v673 >= v27) {
              uint64_t v675 = v665;
            }
            else {
              uint64_t v675 = 0;
            }
            unint64_t v24 = &v673[v675];
            v12 += 4 * v675 + 4 * v20;
            uint64_t v667 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v667 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 12:
      uint64_t v260 = v26;
      if (v737)
      {
        uint64_t v261 = v23;
        uint64_t v262 = -(v20 * v23);
        uint64_t v263 = -(uint64_t)(v21 * v261);
        uint64_t v264 = -(uint64_t)v22;
        uint64_t v265 = (unsigned int *)v11;
        do
        {
          int v266 = v10;
          do
          {
            if (*v16)
            {
              if (v738) {
                float v267 = COERCE_FLOAT(bswap32(*v265));
              }
              else {
                float v267 = 1.0;
              }
              float v268 = (float)*v16 * 0.0039216;
              float v269 = (float)(v268 * v267) + COERCE_FLOAT(bswap32(*v7));
              float v270 = (float)(v268 * COERCE_FLOAT(bswap32(*v24))) + COERCE_FLOAT(bswap32(*v14));
              if (v269 > 1.0) {
                float v269 = 1.0;
              }
              *int v14 = bswap32(LODWORD(v270));
              *float v7 = bswap32(LODWORD(v269));
            }
            v16 += v260;
            int v271 = &v24[v260];
            char v272 = &v265[v738];
            if ((unint64_t)v271 >= v12) {
              uint64_t v273 = v264;
            }
            else {
              uint64_t v273 = 0;
            }
            uint64_t v265 = &v272[v273];
            unint64_t v24 = &v271[v273];
            v7 += v737;
            v14 += v260;
            --v266;
          }
          while (v266);
          if (v27)
          {
            uint64_t v274 = &v736[v20];
            if ((unint64_t)v274 >= v27) {
              uint64_t v275 = v263;
            }
            else {
              uint64_t v275 = 0;
            }
            v11 += 4 * v21 + 4 * v275;
            if ((unint64_t)v274 >= v27) {
              uint64_t v276 = v262;
            }
            else {
              uint64_t v276 = 0;
            }
            unint64_t v24 = &v274[v276];
            v12 += 4 * v276 + 4 * v20;
            uint64_t v265 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v265 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v676 = -(uint64_t)v22;
        uint64_t v677 = -(v20 * v23);
        do
        {
          int v678 = v10;
          do
          {
            if (*v16) {
              *int v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)*v16 * 0.0039216) * COERCE_FLOAT(bswap32(*v24)))+ COERCE_FLOAT(bswap32(*v14))));
            }
            v16 += v260;
            long long v679 = &v24[v260];
            if ((unint64_t)v679 >= v12) {
              uint64_t v680 = v676;
            }
            else {
              uint64_t v680 = 0;
            }
            unint64_t v24 = &v679[v680];
            v14 += v260;
            --v678;
          }
          while (v678);
          v16 += v32;
          v14 += v33;
          long long v681 = v736;
          long long v682 = &v736[v20];
          if ((unint64_t)v682 >= v27) {
            uint64_t v683 = v677;
          }
          else {
            uint64_t v683 = 0;
          }
          uint64_t v684 = &v682[v683];
          uint64_t v685 = v12 + 4 * v683 + 4 * v20;
          if (v27)
          {
            unint64_t v12 = v685;
            long long v681 = v684;
          }
          v736 = v681;
          if (v27) {
            unint64_t v24 = v684;
          }
          else {
            v24 += v20;
          }
          --v9;
        }
        while (v9);
      }
      return;
    case 13:
      uint64_t v277 = v26;
      uint64_t v278 = v23;
      uint64_t v279 = -(v20 * v23);
      uint64_t v280 = -(uint64_t)(v21 * v278);
      uint64_t v281 = 4 * v26;
      uint64_t v282 = -(uint64_t)v22;
      float v283 = (unsigned int *)v11;
      while (1)
      {
        int v284 = v10;
        do
        {
          if (*v16)
          {
            float v285 = v738 ? COERCE_FLOAT(bswap32(*v283)) : 1.0;
            float v286 = (float)*v16 * 0.0039216;
            float v287 = v286 * v285;
            if (v287 > 0.0)
            {
              float v288 = v286 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v289 = COERCE_FLOAT(bswap32(*v7));
                if (v289 <= 0.0) {
                  goto LABEL_342;
                }
              }
              else
              {
                float v289 = 1.0;
              }
              float v290 = COERCE_FLOAT(bswap32(*v14));
              float v291 = (float)(v288 * v290) + (float)(v290 * (float)(1.0 - v287));
              if (v287 == 1.0) {
                float v291 = v288 * v290;
              }
              float v288 = v291 + (float)(v288 * (float)(1.0 - v289));
              if (v289 == 1.0) {
                float v288 = v291;
              }
              if (v737)
              {
                float v287 = (float)(v287 + v289) - (float)(v289 * v287);
LABEL_342:
                *int v14 = bswap32(LODWORD(v288));
                *float v7 = bswap32(LODWORD(v287));
                goto LABEL_344;
              }
              *int v14 = bswap32(LODWORD(v288));
            }
          }
LABEL_344:
          v16 += v277;
          int v292 = &v24[v277];
          unsigned int v293 = &v283[v738];
          if ((unint64_t)v292 >= v12) {
            uint64_t v294 = v282;
          }
          else {
            uint64_t v294 = 0;
          }
          float v283 = &v293[v294];
          unint64_t v24 = &v292[v294];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v281);
          --v284;
        }
        while (v284);
        if (v27)
        {
          unsigned int v295 = &v736[v20];
          if ((unint64_t)v295 >= v27) {
            uint64_t v296 = v280;
          }
          else {
            uint64_t v296 = 0;
          }
          v11 += 4 * v21 + 4 * v296;
          if ((unint64_t)v295 >= v27) {
            uint64_t v297 = v279;
          }
          else {
            uint64_t v297 = 0;
          }
          unint64_t v24 = &v295[v297];
          v12 += 4 * v297 + 4 * v20;
          float v283 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v283 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 14:
      uint64_t v298 = v26;
      uint64_t v299 = v23;
      uint64_t v300 = -(v20 * v23);
      uint64_t v301 = -(uint64_t)(v21 * v299);
      uint64_t v302 = 4 * v26;
      uint64_t v303 = -(uint64_t)v22;
      float v304 = (unsigned int *)v11;
      while (1)
      {
        int v305 = v10;
        do
        {
          if (*v16)
          {
            float v306 = v738 ? COERCE_FLOAT(bswap32(*v304)) : 1.0;
            float v307 = (float)*v16 * 0.0039216;
            float v308 = v307 * v306;
            if (v308 > 0.0)
            {
              float v309 = v307 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v310 = COERCE_FLOAT(bswap32(*v7));
                if (v310 <= 0.0) {
                  goto LABEL_372;
                }
              }
              else
              {
                float v310 = 1.0;
              }
              float v311 = COERCE_FLOAT(bswap32(*v14));
              float v309 = v311 + (float)(v309 * (float)(1.0 - v311));
              if (v737)
              {
                float v308 = (float)(v308 + v310) - (float)(v310 * v308);
LABEL_372:
                *int v14 = bswap32(LODWORD(v309));
                *float v7 = bswap32(LODWORD(v308));
                goto LABEL_374;
              }
              *int v14 = bswap32(LODWORD(v309));
            }
          }
LABEL_374:
          v16 += v298;
          unsigned int v312 = &v24[v298];
          float v313 = &v304[v738];
          if ((unint64_t)v312 >= v12) {
            uint64_t v314 = v303;
          }
          else {
            uint64_t v314 = 0;
          }
          float v304 = &v313[v314];
          unint64_t v24 = &v312[v314];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v302);
          --v305;
        }
        while (v305);
        if (v27)
        {
          float v315 = &v736[v20];
          if ((unint64_t)v315 >= v27) {
            uint64_t v316 = v301;
          }
          else {
            uint64_t v316 = 0;
          }
          v11 += 4 * v21 + 4 * v316;
          if ((unint64_t)v315 >= v27) {
            uint64_t v317 = v300;
          }
          else {
            uint64_t v317 = 0;
          }
          unint64_t v24 = &v315[v317];
          v12 += 4 * v317 + 4 * v20;
          float v304 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v304 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 15:
      uint64_t v318 = v26;
      uint64_t v700 = -(uint64_t)(v21 * v23);
      uint64_t v705 = -(v20 * v23);
      uint64_t v319 = 4 * v26;
      uint64_t v320 = -(uint64_t)v22;
      int v321 = (unsigned int *)v11;
      uint64_t v715 = v320;
      uint64_t v720 = v26;
      while (1)
      {
        uint64_t v725 = v11;
        int v730 = v9;
        int v322 = v10;
        int v323 = v738;
        do
        {
          if (*v16)
          {
            float v324 = v323 ? COERCE_FLOAT(bswap32(*v321)) : 1.0;
            float v325 = (float)*v16 * 0.0039216;
            float v326 = v325 * v324;
            if ((float)(v325 * v324) > 0.0)
            {
              float v327 = v325 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v328 = COERCE_FLOAT(bswap32(*v7));
                if (v328 <= 0.0) {
                  goto LABEL_402;
                }
              }
              else
              {
                float v328 = 1.0;
              }
              float v329 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v14)), v328, v327, v326);
              float v327 = v329;
              if (v737)
              {
                float v326 = v330;
                int v323 = v738;
                uint64_t v320 = v715;
                uint64_t v318 = v720;
LABEL_402:
                *int v14 = bswap32(LODWORD(v327));
                *float v7 = bswap32(LODWORD(v326));
                goto LABEL_404;
              }
              *int v14 = bswap32(LODWORD(v329));
              int v323 = v738;
              uint64_t v320 = v715;
              uint64_t v318 = v720;
            }
          }
LABEL_404:
          v16 += v318;
          float v331 = &v24[v318];
          if ((unint64_t)v331 >= v12) {
            uint64_t v332 = v320;
          }
          else {
            uint64_t v332 = 0;
          }
          v321 += v738 + v332;
          unint64_t v24 = &v331[v332];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v319);
          --v322;
        }
        while (v322);
        if (v714)
        {
          int v10 = v713;
          float v333 = &v736[v712];
          int v334 = v730;
          uint64_t v335 = v700;
          if ((unint64_t)v333 < v714) {
            uint64_t v335 = 0;
          }
          uint64_t v11 = v725 + 4 * v21 + 4 * v335;
          uint64_t v336 = v705;
          if ((unint64_t)v333 < v714) {
            uint64_t v336 = 0;
          }
          unint64_t v24 = &v333[v336];
          v12 += 4 * v336 + 4 * v712;
          int v321 = (unsigned int *)(v725 + 4 * v21 + 4 * v335);
          v736 = v24;
          unint64_t v338 = v710;
          uint64_t v337 = v711;
        }
        else
        {
          int v10 = v713;
          v24 += v712;
          unint64_t v338 = v710;
          v321 += v21;
          uint64_t v11 = v725;
          int v334 = v730;
          uint64_t v337 = v711;
        }
        v16 += v337;
        v14 += v338;
        v7 += v735;
        int v9 = v334 - 1;
        if (!v9) {
          return;
        }
      }
    case 16:
      uint64_t v339 = v26;
      uint64_t v340 = v23;
      uint64_t v341 = -(v20 * v23);
      uint64_t v342 = -(uint64_t)(v21 * v340);
      uint64_t v343 = 4 * v26;
      uint64_t v344 = -(uint64_t)v22;
      float v345 = (unsigned int *)v11;
      while (1)
      {
        int v346 = v10;
        do
        {
          if (*v16)
          {
            float v347 = v738 ? COERCE_FLOAT(bswap32(*v345)) : 1.0;
            float v348 = (float)*v16 * 0.0039216;
            float v349 = v348 * v347;
            if (v349 > 0.0)
            {
              float v350 = v348 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v351 = COERCE_FLOAT(bswap32(*v7));
                if (v351 <= 0.0) {
                  goto LABEL_436;
                }
              }
              else
              {
                float v351 = 1.0;
              }
              float v352 = COERCE_FLOAT(bswap32(*v14));
              float v353 = v349 * v352;
              if ((float)(v350 * v351) < (float)(v349 * v352)) {
                float v353 = v350 * v351;
              }
              float v354 = v353 + (float)(v352 * (float)(1.0 - v349));
              if (v349 == 1.0) {
                float v354 = v353;
              }
              float v350 = v354 + (float)(v350 * (float)(1.0 - v351));
              if (v351 == 1.0) {
                float v350 = v354;
              }
              if (v737)
              {
                float v349 = (float)(v349 + v351) - (float)(v351 * v349);
LABEL_436:
                *int v14 = bswap32(LODWORD(v350));
                *float v7 = bswap32(LODWORD(v349));
                goto LABEL_438;
              }
              *int v14 = bswap32(LODWORD(v350));
            }
          }
LABEL_438:
          v16 += v339;
          unsigned int v355 = &v24[v339];
          unsigned int v356 = &v345[v738];
          if ((unint64_t)v355 >= v12) {
            uint64_t v357 = v344;
          }
          else {
            uint64_t v357 = 0;
          }
          float v345 = &v356[v357];
          unint64_t v24 = &v355[v357];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v343);
          --v346;
        }
        while (v346);
        if (v27)
        {
          int v358 = &v736[v20];
          if ((unint64_t)v358 >= v27) {
            uint64_t v359 = v342;
          }
          else {
            uint64_t v359 = 0;
          }
          v11 += 4 * v21 + 4 * v359;
          if ((unint64_t)v358 >= v27) {
            uint64_t v360 = v341;
          }
          else {
            uint64_t v360 = 0;
          }
          unint64_t v24 = &v358[v360];
          v12 += 4 * v360 + 4 * v20;
          float v345 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v345 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 17:
      uint64_t v361 = v26;
      uint64_t v362 = v23;
      uint64_t v363 = -(v20 * v23);
      uint64_t v364 = -(uint64_t)(v21 * v362);
      uint64_t v365 = 4 * v26;
      uint64_t v366 = -(uint64_t)v22;
      unsigned int v367 = (unsigned int *)v11;
      while (1)
      {
        int v368 = v10;
        do
        {
          if (*v16)
          {
            float v369 = v738 ? COERCE_FLOAT(bswap32(*v367)) : 1.0;
            float v370 = (float)*v16 * 0.0039216;
            float v371 = v370 * v369;
            if (v371 > 0.0)
            {
              float v372 = v370 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v373 = COERCE_FLOAT(bswap32(*v7));
                if (v373 <= 0.0) {
                  goto LABEL_472;
                }
              }
              else
              {
                float v373 = 1.0;
              }
              float v374 = COERCE_FLOAT(bswap32(*v14));
              float v375 = v371 * v374;
              if ((float)(v372 * v373) > (float)(v371 * v374)) {
                float v375 = v372 * v373;
              }
              float v376 = v375 + (float)(v374 * (float)(1.0 - v371));
              if (v371 == 1.0) {
                float v376 = v375;
              }
              float v372 = v376 + (float)(v372 * (float)(1.0 - v373));
              if (v373 == 1.0) {
                float v372 = v376;
              }
              if (v737)
              {
                float v371 = (float)(v371 + v373) - (float)(v373 * v371);
LABEL_472:
                *int v14 = bswap32(LODWORD(v372));
                *float v7 = bswap32(LODWORD(v371));
                goto LABEL_474;
              }
              *int v14 = bswap32(LODWORD(v372));
            }
          }
LABEL_474:
          v16 += v361;
          int v377 = &v24[v361];
          float v378 = &v367[v738];
          if ((unint64_t)v377 >= v12) {
            uint64_t v379 = v366;
          }
          else {
            uint64_t v379 = 0;
          }
          unsigned int v367 = &v378[v379];
          unint64_t v24 = &v377[v379];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v365);
          --v368;
        }
        while (v368);
        if (v27)
        {
          float v380 = &v736[v20];
          if ((unint64_t)v380 >= v27) {
            uint64_t v381 = v364;
          }
          else {
            uint64_t v381 = 0;
          }
          v11 += 4 * v21 + 4 * v381;
          if ((unint64_t)v380 >= v27) {
            uint64_t v382 = v363;
          }
          else {
            uint64_t v382 = 0;
          }
          unint64_t v24 = &v380[v382];
          v12 += 4 * v382 + 4 * v20;
          unsigned int v367 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v367 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 18:
      uint64_t v383 = v26;
      uint64_t v701 = -(uint64_t)(v21 * v23);
      uint64_t v706 = -(v20 * v23);
      uint64_t v384 = 4 * v26;
      uint64_t v385 = -(uint64_t)v22;
      uint64_t v386 = (unsigned int *)v11;
      uint64_t v716 = v385;
      uint64_t v721 = v26;
      while (1)
      {
        uint64_t v726 = v11;
        int v731 = v9;
        int v387 = v10;
        int v388 = v738;
        do
        {
          if (*v16)
          {
            float v389 = v388 ? COERCE_FLOAT(bswap32(*v386)) : 1.0;
            float v390 = (float)*v16 * 0.0039216;
            float v391 = v390 * v389;
            if ((float)(v390 * v389) > 0.0)
            {
              float v392 = v390 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v393 = COERCE_FLOAT(bswap32(*v7));
                if (v393 <= 0.0) {
                  goto LABEL_502;
                }
              }
              else
              {
                float v393 = 1.0;
              }
              float v394 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v14)), v393, v392, v391);
              float v392 = v394;
              if (v737)
              {
                float v391 = v395;
                int v388 = v738;
                uint64_t v385 = v716;
                uint64_t v383 = v721;
LABEL_502:
                *int v14 = bswap32(LODWORD(v392));
                *float v7 = bswap32(LODWORD(v391));
                goto LABEL_504;
              }
              *int v14 = bswap32(LODWORD(v394));
              int v388 = v738;
              uint64_t v385 = v716;
              uint64_t v383 = v721;
            }
          }
LABEL_504:
          v16 += v383;
          float v396 = &v24[v383];
          if ((unint64_t)v396 >= v12) {
            uint64_t v397 = v385;
          }
          else {
            uint64_t v397 = 0;
          }
          v386 += v738 + v397;
          unint64_t v24 = &v396[v397];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v384);
          --v387;
        }
        while (v387);
        if (v714)
        {
          int v10 = v713;
          uint64_t v398 = &v736[v712];
          int v399 = v731;
          uint64_t v400 = v701;
          if ((unint64_t)v398 < v714) {
            uint64_t v400 = 0;
          }
          uint64_t v11 = v726 + 4 * v21 + 4 * v400;
          uint64_t v401 = v706;
          if ((unint64_t)v398 < v714) {
            uint64_t v401 = 0;
          }
          unint64_t v24 = &v398[v401];
          v12 += 4 * v401 + 4 * v712;
          uint64_t v386 = (unsigned int *)(v726 + 4 * v21 + 4 * v400);
          v736 = v24;
          unint64_t v403 = v710;
          uint64_t v402 = v711;
        }
        else
        {
          int v10 = v713;
          v24 += v712;
          unint64_t v403 = v710;
          v386 += v21;
          uint64_t v11 = v726;
          int v399 = v731;
          uint64_t v402 = v711;
        }
        v16 += v402;
        v14 += v403;
        v7 += v735;
        int v9 = v399 - 1;
        if (!v9) {
          return;
        }
      }
    case 19:
      uint64_t v404 = v26;
      uint64_t v702 = -(uint64_t)(v21 * v23);
      uint64_t v707 = -(v20 * v23);
      uint64_t v405 = 4 * v26;
      uint64_t v406 = -(uint64_t)v22;
      float v407 = (unsigned int *)v11;
      uint64_t v717 = v406;
      uint64_t v722 = v26;
      while (1)
      {
        uint64_t v727 = v11;
        int v732 = v9;
        int v408 = v10;
        int v409 = v738;
        do
        {
          if (*v16)
          {
            float v410 = v409 ? COERCE_FLOAT(bswap32(*v407)) : 1.0;
            float v411 = (float)*v16 * 0.0039216;
            float v412 = v411 * v410;
            if ((float)(v411 * v410) > 0.0)
            {
              float v413 = v411 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v414 = COERCE_FLOAT(bswap32(*v7));
                if (v414 <= 0.0) {
                  goto LABEL_530;
                }
              }
              else
              {
                float v414 = 1.0;
              }
              double v415 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v14)), v414, v413, v412);
              float v413 = *(float *)&v415;
              if (v737)
              {
                float v412 = v416;
                int v409 = v738;
                uint64_t v406 = v717;
                uint64_t v404 = v722;
LABEL_530:
                *int v14 = bswap32(LODWORD(v413));
                *float v7 = bswap32(LODWORD(v412));
                goto LABEL_532;
              }
              *int v14 = bswap32(LODWORD(v415));
              int v409 = v738;
              uint64_t v406 = v717;
              uint64_t v404 = v722;
            }
          }
LABEL_532:
          v16 += v404;
          uint64_t v417 = &v24[v404];
          if ((unint64_t)v417 >= v12) {
            uint64_t v418 = v406;
          }
          else {
            uint64_t v418 = 0;
          }
          v407 += v738 + v418;
          unint64_t v24 = &v417[v418];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v405);
          --v408;
        }
        while (v408);
        if (v714)
        {
          int v10 = v713;
          uint64_t v419 = &v736[v712];
          int v420 = v732;
          uint64_t v421 = v702;
          if ((unint64_t)v419 < v714) {
            uint64_t v421 = 0;
          }
          uint64_t v11 = v727 + 4 * v21 + 4 * v421;
          uint64_t v422 = v707;
          if ((unint64_t)v419 < v714) {
            uint64_t v422 = 0;
          }
          unint64_t v24 = &v419[v422];
          v12 += 4 * v422 + 4 * v712;
          float v407 = (unsigned int *)(v727 + 4 * v21 + 4 * v421);
          v736 = v24;
          unint64_t v424 = v710;
          uint64_t v423 = v711;
        }
        else
        {
          int v10 = v713;
          v24 += v712;
          unint64_t v424 = v710;
          v407 += v21;
          uint64_t v11 = v727;
          int v420 = v732;
          uint64_t v423 = v711;
        }
        v16 += v423;
        v14 += v424;
        v7 += v735;
        int v9 = v420 - 1;
        if (!v9) {
          return;
        }
      }
    case 20:
      uint64_t v425 = v26;
      uint64_t v703 = -(uint64_t)(v21 * v23);
      uint64_t v708 = -(v20 * v23);
      uint64_t v426 = 4 * v26;
      uint64_t v427 = -(uint64_t)v22;
      uint64_t v428 = (unsigned int *)v11;
      uint64_t v718 = v427;
      uint64_t v723 = v26;
      while (1)
      {
        uint64_t v728 = v11;
        int v733 = v9;
        int v429 = v10;
        int v430 = v738;
        do
        {
          if (*v16)
          {
            float v431 = v430 ? COERCE_FLOAT(bswap32(*v428)) : 1.0;
            float v432 = (float)*v16 * 0.0039216;
            float v433 = v432 * v431;
            if ((float)(v432 * v431) > 0.0)
            {
              float v434 = v432 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v435 = COERCE_FLOAT(bswap32(*v7));
                if (v435 <= 0.0) {
                  goto LABEL_558;
                }
              }
              else
              {
                float v435 = 1.0;
              }
              float v436 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v14)), v435, v434, v433);
              float v434 = v436;
              if (v737)
              {
                float v433 = v437;
                int v430 = v738;
                uint64_t v427 = v718;
                uint64_t v425 = v723;
LABEL_558:
                *int v14 = bswap32(LODWORD(v434));
                *float v7 = bswap32(LODWORD(v433));
                goto LABEL_560;
              }
              *int v14 = bswap32(LODWORD(v436));
              int v430 = v738;
              uint64_t v427 = v718;
              uint64_t v425 = v723;
            }
          }
LABEL_560:
          v16 += v425;
          float v438 = &v24[v425];
          if ((unint64_t)v438 >= v12) {
            uint64_t v439 = v427;
          }
          else {
            uint64_t v439 = 0;
          }
          v428 += v738 + v439;
          unint64_t v24 = &v438[v439];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v426);
          --v429;
        }
        while (v429);
        if (v714)
        {
          int v10 = v713;
          unint64_t v440 = &v736[v712];
          int v441 = v733;
          uint64_t v442 = v703;
          if ((unint64_t)v440 < v714) {
            uint64_t v442 = 0;
          }
          uint64_t v11 = v728 + 4 * v21 + 4 * v442;
          uint64_t v443 = v708;
          if ((unint64_t)v440 < v714) {
            uint64_t v443 = 0;
          }
          unint64_t v24 = &v440[v443];
          v12 += 4 * v443 + 4 * v712;
          uint64_t v428 = (unsigned int *)(v728 + 4 * v21 + 4 * v442);
          v736 = v24;
          unint64_t v445 = v710;
          uint64_t v444 = v711;
        }
        else
        {
          int v10 = v713;
          v24 += v712;
          unint64_t v445 = v710;
          v428 += v21;
          uint64_t v11 = v728;
          int v441 = v733;
          uint64_t v444 = v711;
        }
        v16 += v444;
        v14 += v445;
        v7 += v735;
        int v9 = v441 - 1;
        if (!v9) {
          return;
        }
      }
    case 21:
      uint64_t v446 = v26;
      uint64_t v704 = -(uint64_t)(v21 * v23);
      uint64_t v709 = -(v20 * v23);
      uint64_t v447 = 4 * v26;
      uint64_t v448 = -(uint64_t)v22;
      uint64_t v449 = (unsigned int *)v11;
      uint64_t v719 = v448;
      uint64_t v724 = v26;
      do
      {
        uint64_t v729 = v11;
        int v734 = v9;
        int v450 = v10;
        int v451 = v738;
        do
        {
          if (*v16)
          {
            float v452 = v451 ? COERCE_FLOAT(bswap32(*v449)) : 1.0;
            float v453 = (float)*v16 * 0.0039216;
            float v454 = v453 * v452;
            if ((float)(v453 * v452) > 0.0)
            {
              float v455 = v453 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v456 = COERCE_FLOAT(bswap32(*v7));
                if (v456 <= 0.0) {
                  goto LABEL_586;
                }
              }
              else
              {
                float v456 = 1.0;
              }
              float v457 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v14)), v456, v455, v454);
              float v455 = v457;
              if (v737)
              {
                float v454 = v458;
                int v451 = v738;
                uint64_t v448 = v719;
                uint64_t v446 = v724;
LABEL_586:
                *int v14 = bswap32(LODWORD(v455));
                *float v7 = bswap32(LODWORD(v454));
                goto LABEL_588;
              }
              *int v14 = bswap32(LODWORD(v457));
              int v451 = v738;
              uint64_t v448 = v719;
              uint64_t v446 = v724;
            }
          }
LABEL_588:
          v16 += v446;
          uint64_t v459 = &v24[v446];
          if ((unint64_t)v459 >= v12) {
            uint64_t v460 = v448;
          }
          else {
            uint64_t v460 = 0;
          }
          v449 += v738 + v460;
          unint64_t v24 = &v459[v460];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v447);
          --v450;
        }
        while (v450);
        if (v714)
        {
          int v10 = v713;
          uint64_t v461 = &v736[v712];
          int v462 = v734;
          uint64_t v463 = v704;
          if ((unint64_t)v461 < v714) {
            uint64_t v463 = 0;
          }
          uint64_t v11 = v729 + 4 * v21 + 4 * v463;
          uint64_t v464 = v709;
          if ((unint64_t)v461 < v714) {
            uint64_t v464 = 0;
          }
          unint64_t v24 = &v461[v464];
          v12 += 4 * v464 + 4 * v712;
          uint64_t v449 = (unsigned int *)(v729 + 4 * v21 + 4 * v463);
          v736 = v24;
          unint64_t v466 = v710;
          uint64_t v465 = v711;
        }
        else
        {
          int v10 = v713;
          v24 += v712;
          unint64_t v466 = v710;
          v449 += v21;
          uint64_t v11 = v729;
          int v462 = v734;
          uint64_t v465 = v711;
        }
        v16 += v465;
        v14 += v466;
        v7 += v735;
        int v9 = v462 - 1;
      }
      while (v9);
      return;
    case 22:
      uint64_t v467 = v26;
      uint64_t v468 = v23;
      uint64_t v469 = -(v20 * v23);
      uint64_t v470 = -(uint64_t)(v21 * v468);
      uint64_t v471 = 4 * v26;
      uint64_t v472 = -(uint64_t)v22;
      unsigned int v473 = (unsigned int *)v11;
      while (1)
      {
        int v474 = v10;
        do
        {
          if (*v16)
          {
            float v475 = v738 ? COERCE_FLOAT(bswap32(*v473)) : 1.0;
            float v476 = (float)*v16 * 0.0039216;
            float v477 = v476 * v475;
            if (v477 > 0.0)
            {
              float v478 = v476 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v479 = COERCE_FLOAT(bswap32(*v7));
                if (v479 <= 0.0) {
                  goto LABEL_616;
                }
              }
              else
              {
                float v479 = 1.0;
              }
              float v480 = COERCE_FLOAT(bswap32(*v14));
              float v481 = v478 + v480;
              float v482 = v478 * v479;
              float v483 = (float)(v477 * v480) - v482;
              float v484 = (float)(v481 - (float)(v477 * v480)) - v482;
              if (v483 < 0.0) {
                float v483 = -v483;
              }
              float v478 = v484 + v483;
              if (v737)
              {
                float v477 = (float)(v477 + v479) - (float)(v479 * v477);
LABEL_616:
                *int v14 = bswap32(LODWORD(v478));
                *float v7 = bswap32(LODWORD(v477));
                goto LABEL_618;
              }
              *int v14 = bswap32(LODWORD(v478));
            }
          }
LABEL_618:
          v16 += v467;
          unsigned int v485 = &v24[v467];
          int v486 = &v473[v738];
          if ((unint64_t)v485 >= v12) {
            uint64_t v487 = v472;
          }
          else {
            uint64_t v487 = 0;
          }
          unsigned int v473 = &v486[v487];
          unint64_t v24 = &v485[v487];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v471);
          --v474;
        }
        while (v474);
        if (v27)
        {
          v488 = &v736[v20];
          if ((unint64_t)v488 >= v27) {
            uint64_t v489 = v470;
          }
          else {
            uint64_t v489 = 0;
          }
          v11 += 4 * v21 + 4 * v489;
          if ((unint64_t)v488 >= v27) {
            uint64_t v490 = v469;
          }
          else {
            uint64_t v490 = 0;
          }
          unint64_t v24 = &v488[v490];
          v12 += 4 * v490 + 4 * v20;
          unsigned int v473 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v473 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 23:
      uint64_t v491 = v26;
      uint64_t v492 = v23;
      uint64_t v493 = -(v20 * v23);
      uint64_t v494 = -(uint64_t)(v21 * v492);
      uint64_t v495 = 4 * v26;
      uint64_t v496 = -(uint64_t)v22;
      float v497 = (unsigned int *)v11;
      while (1)
      {
        int v498 = v10;
        do
        {
          if (*v16)
          {
            float v499 = v738 ? COERCE_FLOAT(bswap32(*v497)) : 1.0;
            float v500 = (float)*v16 * 0.0039216;
            float v501 = v500 * v499;
            if (v501 > 0.0)
            {
              float v502 = v500 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v503 = COERCE_FLOAT(bswap32(*v7));
                if (v503 <= 0.0) {
                  goto LABEL_646;
                }
              }
              else
              {
                float v503 = 1.0;
              }
              float v504 = COERCE_FLOAT(bswap32(*v14));
              float v502 = (float)(v502 + v504) + (float)((float)(v502 * v504) * -2.0);
              if (v737)
              {
                float v501 = (float)(v501 + v503) - (float)(v503 * v501);
LABEL_646:
                *int v14 = bswap32(LODWORD(v502));
                *float v7 = bswap32(LODWORD(v501));
                goto LABEL_648;
              }
              *int v14 = bswap32(LODWORD(v502));
            }
          }
LABEL_648:
          v16 += v491;
          uint64_t v505 = &v24[v491];
          int v506 = &v497[v738];
          if ((unint64_t)v505 >= v12) {
            uint64_t v507 = v496;
          }
          else {
            uint64_t v507 = 0;
          }
          float v497 = &v506[v507];
          unint64_t v24 = &v505[v507];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v495);
          --v498;
        }
        while (v498);
        if (v27)
        {
          float v508 = &v736[v20];
          if ((unint64_t)v508 >= v27) {
            uint64_t v509 = v494;
          }
          else {
            uint64_t v509 = 0;
          }
          v11 += 4 * v21 + 4 * v509;
          if ((unint64_t)v508 >= v27) {
            uint64_t v510 = v493;
          }
          else {
            uint64_t v510 = 0;
          }
          unint64_t v24 = &v508[v510];
          v12 += 4 * v510 + 4 * v20;
          float v497 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v497 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 24:
      uint64_t v511 = v26;
      uint64_t v512 = v23;
      uint64_t v513 = -(v20 * v23);
      uint64_t v514 = -(uint64_t)(v21 * v512);
      uint64_t v515 = 4 * v26;
      uint64_t v516 = -(uint64_t)v22;
      uint64_t v517 = (unsigned int *)v11;
      while (1)
      {
        int v518 = v10;
        do
        {
          if (*v16)
          {
            float v519 = v738 ? COERCE_FLOAT(bswap32(*v517)) : 1.0;
            float v520 = (float)*v16 * 0.0039216;
            float v521 = v520 * v519;
            if (v521 > 0.0)
            {
              float v522 = v520 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v523 = COERCE_FLOAT(bswap32(*v7));
                if (v523 <= 0.0) {
                  goto LABEL_681;
                }
              }
              else
              {
                float v523 = 1.0;
              }
              float v524 = COERCE_FLOAT(bswap32(*v14));
              float v525 = v524;
              if (v521 == 1.0)
              {
                float v526 = 0.0;
              }
              else
              {
                float v525 = v521 * v524;
                float v526 = v524 - (float)(v521 * v524);
              }
              float v527 = (float)(v522 + v526) - (float)(v522 * v523);
              if (v523 == 1.0) {
                float v527 = v526;
              }
              float v522 = v525 + v527;
              if (v737)
              {
                float v521 = (float)(v521 + v523) - (float)(v521 * v523);
LABEL_681:
                *int v14 = bswap32(LODWORD(v522));
                *float v7 = bswap32(LODWORD(v521));
                goto LABEL_683;
              }
              *int v14 = bswap32(LODWORD(v522));
            }
          }
LABEL_683:
          v16 += v511;
          float v528 = &v24[v511];
          unsigned int v529 = &v517[v738];
          if ((unint64_t)v528 >= v12) {
            uint64_t v530 = v516;
          }
          else {
            uint64_t v530 = 0;
          }
          uint64_t v517 = &v529[v530];
          unint64_t v24 = &v528[v530];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v515);
          --v518;
        }
        while (v518);
        if (v27)
        {
          uint64_t v531 = &v736[v20];
          if ((unint64_t)v531 >= v27) {
            uint64_t v532 = v514;
          }
          else {
            uint64_t v532 = 0;
          }
          v11 += 4 * v21 + 4 * v532;
          if ((unint64_t)v531 >= v27) {
            uint64_t v533 = v513;
          }
          else {
            uint64_t v533 = 0;
          }
          unint64_t v24 = &v531[v533];
          v12 += 4 * v533 + 4 * v20;
          uint64_t v517 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v517 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 25:
      uint64_t v534 = v26;
      uint64_t v535 = v23;
      uint64_t v536 = -(v20 * v23);
      uint64_t v537 = -(uint64_t)(v21 * v535);
      uint64_t v538 = 4 * v26;
      uint64_t v539 = -(uint64_t)v22;
      float v540 = (unsigned int *)v11;
      while (1)
      {
        int v541 = v10;
        do
        {
          if (*v16)
          {
            float v542 = v738 ? COERCE_FLOAT(bswap32(*v540)) : 1.0;
            float v543 = (float)*v16 * 0.0039216;
            float v544 = v543 * v542;
            if (v544 > 0.0)
            {
              float v545 = v543 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v546 = COERCE_FLOAT(bswap32(*v7));
                if (v546 <= 0.0) {
                  goto LABEL_716;
                }
              }
              else
              {
                float v546 = 1.0;
              }
              float v547 = COERCE_FLOAT(bswap32(*v14));
              float v548 = v547;
              if (v544 == 1.0)
              {
                float v549 = 0.0;
              }
              else
              {
                float v548 = v544 * v547;
                float v549 = v547 - (float)(v544 * v547);
              }
              float v550 = (float)(v545 + v549) - (float)(v545 * v546);
              if (v546 == 1.0) {
                float v550 = v549;
              }
              float v545 = v548 + v550;
              if (v737)
              {
                float v544 = (float)(v544 + v546) - (float)(v544 * v546);
LABEL_716:
                *int v14 = bswap32(LODWORD(v545));
                *float v7 = bswap32(LODWORD(v544));
                goto LABEL_718;
              }
              *int v14 = bswap32(LODWORD(v545));
            }
          }
LABEL_718:
          v16 += v534;
          float v551 = &v24[v534];
          uint64_t v552 = &v540[v738];
          if ((unint64_t)v551 >= v12) {
            uint64_t v553 = v539;
          }
          else {
            uint64_t v553 = 0;
          }
          float v540 = &v552[v553];
          unint64_t v24 = &v551[v553];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v538);
          --v541;
        }
        while (v541);
        if (v27)
        {
          uint64_t v554 = &v736[v20];
          if ((unint64_t)v554 >= v27) {
            uint64_t v555 = v537;
          }
          else {
            uint64_t v555 = 0;
          }
          v11 += 4 * v21 + 4 * v555;
          if ((unint64_t)v554 >= v27) {
            uint64_t v556 = v536;
          }
          else {
            uint64_t v556 = 0;
          }
          unint64_t v24 = &v554[v556];
          v12 += 4 * v556 + 4 * v20;
          float v540 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v540 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 26:
      uint64_t v557 = v26;
      uint64_t v558 = v23;
      uint64_t v559 = -(v20 * v23);
      uint64_t v560 = -(uint64_t)(v21 * v558);
      uint64_t v561 = 4 * v26;
      uint64_t v562 = -(uint64_t)v22;
      int v563 = (unsigned int *)v11;
      while (1)
      {
        int v564 = v10;
        do
        {
          if (*v16)
          {
            float v565 = v738 ? COERCE_FLOAT(bswap32(*v563)) : 1.0;
            float v566 = (float)*v16 * 0.0039216;
            float v567 = v566 * v565;
            if (v567 > 0.0)
            {
              float v568 = v566 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                float v569 = COERCE_FLOAT(bswap32(*v7));
                if (v569 <= 0.0) {
                  goto LABEL_750;
                }
              }
              else
              {
                float v569 = 1.0;
              }
              float v570 = COERCE_FLOAT(bswap32(*v14));
              float v571 = v570;
              float v572 = v568 - (float)(v568 * v569);
              if (v569 == 1.0) {
                float v572 = 0.0;
              }
              if (v567 != 1.0)
              {
                float v571 = v567 * v570;
                float v572 = (float)(v572 + v570) - (float)(v567 * v570);
              }
              float v568 = v571 + v572;
              if (v737)
              {
                float v567 = (float)(v567 + v569) - (float)(v567 * v569);
LABEL_750:
                *int v14 = bswap32(LODWORD(v568));
                *float v7 = bswap32(LODWORD(v567));
                goto LABEL_752;
              }
              *int v14 = bswap32(LODWORD(v568));
            }
          }
LABEL_752:
          v16 += v557;
          uint64_t v573 = &v24[v557];
          uint64_t v574 = &v563[v738];
          if ((unint64_t)v573 >= v12) {
            uint64_t v575 = v562;
          }
          else {
            uint64_t v575 = 0;
          }
          int v563 = &v574[v575];
          unint64_t v24 = &v573[v575];
          v7 += v737;
          int v14 = (unsigned int *)((char *)v14 + v561);
          --v564;
        }
        while (v564);
        if (v27)
        {
          uint64_t v576 = &v736[v20];
          if ((unint64_t)v576 >= v27) {
            uint64_t v577 = v560;
          }
          else {
            uint64_t v577 = 0;
          }
          v11 += 4 * v21 + 4 * v577;
          if ((unint64_t)v576 >= v27) {
            uint64_t v578 = v559;
          }
          else {
            uint64_t v578 = 0;
          }
          unint64_t v24 = &v576[v578];
          v12 += 4 * v578 + 4 * v20;
          int v563 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v563 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9) {
          return;
        }
      }
    case 27:
      uint64_t v579 = v26;
      uint64_t v580 = v23;
      uint64_t v581 = -(v20 * v23);
      uint64_t v582 = -(uint64_t)(v21 * v580);
      uint64_t v583 = 4 * v26;
      uint64_t v584 = -(uint64_t)v22;
      int v585 = (unsigned int *)v11;
      break;
    default:
      return;
  }
LABEL_768:
  int v586 = v10;
  while (1)
  {
    if (!*v16) {
      goto LABEL_786;
    }
    float v587 = v738 ? COERCE_FLOAT(bswap32(*v585)) : 1.0;
    float v588 = (float)*v16 * 0.0039216;
    float v589 = v588 * v587;
    if (v589 <= 0.0) {
      goto LABEL_786;
    }
    float v590 = v588 * COERCE_FLOAT(bswap32(*v24));
    if (v737)
    {
      float v591 = COERCE_FLOAT(bswap32(*v7));
      if (v591 <= 0.0) {
        goto LABEL_784;
      }
    }
    else
    {
      float v591 = 1.0;
    }
    float v592 = COERCE_FLOAT(bswap32(*v14));
    float v593 = v592 - (float)(v589 * v592);
    if (v589 == 1.0) {
      float v593 = 0.0;
    }
    float v594 = (float)(v590 + v593) - (float)(v590 * v591);
    if (v591 != 1.0)
    {
      float v590 = v590 * v591;
      float v593 = v594;
    }
    float v590 = v590 + v593;
    if (!v737)
    {
      *int v14 = bswap32(LODWORD(v590));
      goto LABEL_786;
    }
    float v589 = (float)(v589 + v591) - (float)(v589 * v591);
LABEL_784:
    *int v14 = bswap32(LODWORD(v590));
    *float v7 = bswap32(LODWORD(v589));
LABEL_786:
    v16 += v579;
    uint64_t v595 = &v24[v579];
    int v596 = &v585[v738];
    if ((unint64_t)v595 >= v12) {
      uint64_t v597 = v584;
    }
    else {
      uint64_t v597 = 0;
    }
    int v585 = &v596[v597];
    unint64_t v24 = &v595[v597];
    v7 += v737;
    int v14 = (unsigned int *)((char *)v14 + v583);
    if (!--v586)
    {
      if (v27)
      {
        uint64_t v598 = &v736[v20];
        if ((unint64_t)v598 >= v27) {
          uint64_t v599 = v582;
        }
        else {
          uint64_t v599 = 0;
        }
        v11 += 4 * v21 + 4 * v599;
        if ((unint64_t)v598 >= v27) {
          uint64_t v600 = v581;
        }
        else {
          uint64_t v600 = 0;
        }
        unint64_t v24 = &v598[v600];
        v12 += 4 * v600 + 4 * v20;
        int v585 = (unsigned int *)v11;
        v736 = v24;
      }
      else
      {
        v24 += v20;
        v585 += v21;
      }
      v16 += v32;
      v14 += v33;
      v7 += v735;
      if (!--v9) {
        return;
      }
      goto LABEL_768;
    }
  }
}

uint64_t WF_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (int *)*a1;
  memset(v37, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v31, (uint64_t)v37) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  unsigned int v19 = *(_DWORD *)a3;
  unsigned int v32 = v19;
  int v33 = v18;
  if (v19 != 136319237)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        int v22 = 255;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
        int v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v21 = 0;
            int v22 = 16;
            break;
          case 5u:
            char v21 = 0;
            int v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v21 = 0;
            int v22 = 32;
            break;
          case 8u:
            char v21 = 0;
            int v22 = 8;
            break;
          case 9u:
            char v21 = 0;
            int v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      int v23 = WF_image_sample;
      uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&WF_image_sample[2 * v20 + 2];
      if (v31)
      {
LABEL_28:
        unsigned int v32 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v35 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = WF_image_mark_RGB32;
              goto LABEL_50;
            case 1u:
              unsigned int v32 = *(_DWORD *)a3;
              int v26 = WF_image_mark_RGB32;
              goto LABEL_52;
            case 2u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = WF_image_mark_W8;
              goto LABEL_50;
            case 3u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = WF_image_mark_RGB24;
              goto LABEL_50;
            case 4u:
              unsigned int v32 = *(_DWORD *)a3;
              uint64_t v25 = WF_image_mark_rgb32;
LABEL_50:
              unint64_t v27 = v25;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 0;
              break;
            case 5u:
              unsigned int v32 = *(_DWORD *)a3;
              int v26 = WF_image_mark_rgb32;
LABEL_52:
              unint64_t v27 = v26;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 8;
              break;
            default:
              goto LABEL_36;
          }
          WF_image_mark_image(v28, (uint64_t)&v31, v29, v30, (void (*)(uint64_t, _DWORD *))v27);
          return 1;
        }
        goto LABEL_36;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        int v23 = W8_image_sample;
        uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W8_image_sample[2 * v20 + 2];
        if (v31)
        {
LABEL_27:
          int v34 = 4;
          goto LABEL_28;
        }
      }
      int v23 = W16_image_sample;
      uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W16_image_sample[2 * v20 + 2];
      if (v31) {
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v36 && (~v35 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v35 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      WF_mark_inner(*(void *)(*a1 + 56), v17);
      return 1;
    }
  }
  uint64_t v31 = Wf_sample_WF_inner;
LABEL_36:
  WF_image_mark((uint64_t)a2, (uint64_t)&v31, v8, v17);
  return 1;
}

void WF_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  v56[0] = a3;
  v56[1] = a4;
  v56[2] = *(_DWORD *)(a2 + 184);
  unint64_t v8 = (unint64_t)*(int *)(a1 + 28) >> 2;
  unint64_t v58 = v8;
  if (*(void *)(a1 + 48)) {
    unint64_t v9 = (unint64_t)*(int *)(a1 + 32) >> 2;
  }
  else {
    unint64_t v9 = 0;
  }
  unint64_t v60 = v9;
  uint64_t v10 = *(void *)(a2 + 120);
  unsigned int v11 = *(_DWORD *)(a2 + 20);
  if (v10)
  {
    unsigned int v12 = HIBYTE(v11);
    unint64_t v13 = *(int *)(a2 + 24);
    uint64_t v14 = (uint64_t *)(a2 + 104);
    uint64_t v15 = (uint64_t *)(a2 + 72);
    uint64_t v16 = (uint64_t *)(a2 + 88);
  }
  else
  {
    unsigned int v12 = BYTE2(v11);
    unint64_t v13 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    uint64_t v14 = (uint64_t *)(a2 + 96);
    uint64_t v15 = (uint64_t *)(a2 + 64);
    uint64_t v16 = (uint64_t *)(a2 + 80);
    uint64_t v10 = *(void *)(a2 + 112);
  }
  uint64_t v17 = *v16;
  uint64_t v18 = *v15;
  uint64_t v19 = *v14;
  char v20 = v12;
  uint64_t v63 = v12;
  uint64_t v61 = v19;
  unint64_t v71 = v13;
  uint64_t v69 = v17;
  uint64_t v67 = v18;
  uint64_t v65 = v10;
  uint64_t v21 = *(void *)(a2 + 128);
  uint64_t v54 = v18;
  uint64_t v55 = v17;
  if (v21)
  {
    unsigned int v22 = BYTE2(v11);
    unint64_t v23 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    unint64_t v24 = (uint64_t *)(a2 + 96);
    uint64_t v25 = (uint64_t *)(a2 + 64);
    int v26 = (uint64_t *)(a2 + 80);
  }
  else
  {
    unsigned int v22 = HIBYTE(v11);
    unint64_t v23 = *(int *)(a2 + 24);
    unint64_t v24 = (uint64_t *)(a2 + 104);
    uint64_t v25 = (uint64_t *)(a2 + 72);
    int v26 = (uint64_t *)(a2 + 88);
    uint64_t v21 = *(void *)(a2 + 136);
  }
  uint64_t v27 = *v26;
  uint64_t v28 = *v25;
  uint64_t v29 = *v24;
  uint64_t v64 = v22;
  uint64_t v62 = v29;
  unint64_t v72 = v23;
  uint64_t v70 = v27;
  uint64_t v68 = v28;
  uint64_t v66 = v21;
  uint64_t v30 = *(unsigned int *)(a1 + 4);
  if ((v30 & 0x80000000) == 0)
  {
    uint64_t v31 = malloc_type_malloc(16 * v30, 0x379E47uLL);
    uint64_t v73 = v31;
    if (v31)
    {
      if (*(void *)(a2 + 176))
      {
        if (v30)
        {
          int v33 = v31 + 1;
          uint64_t v34 = v55 - v19;
          do
          {
            if (((v19 - v54) | v34) < 0)
            {
              unint64_t v37 = 0;
              uint64_t v38 = 0;
            }
            else
            {
              unint64_t v35 = ((v19 & (unint64_t)~(-1 << v20)) >> (v20 - 4)) & 0xF;
              char v36 = weights_21383[v35];
              if (v35 - 7 >= 9) {
                unint64_t v37 = -(uint64_t)v13;
              }
              else {
                unint64_t v37 = v13;
              }
              uint64_t v38 = v36 & 0xF;
            }
            *(v33 - 1) = v13 * (v19 >> v20);
            *int v33 = v38 | (16 * v37);
            v33 += 2;
            v19 += v10;
            v34 -= v10;
            --v30;
          }
          while (v30);
        }
      }
      else if (v30)
      {
        uint64_t v39 = v31 + 1;
        do
        {
          *(v39 - 1) = v13 * (v19 >> v20);
          *uint64_t v39 = 0;
          v39 += 2;
          v19 += v10;
          --v30;
        }
        while (v30);
      }
      uint64_t v40 = v31;
      int v41 = *(_DWORD *)(a1 + 4);
      int v42 = *(_DWORD *)(a1 + 8);
      int v74 = v42;
      int v75 = v41;
      uint64_t v43 = *(int **)(a1 + 136);
      if (v43)
      {
        int v44 = *(_DWORD *)(a1 + 104);
        v76[0] = *(_DWORD *)(a1 + 108);
        v76[1] = v44;
        shape_enum_clip_alloc((uint64_t)v31, v32, v43, 1, 1, 1, v44, v76[0], v41, v42);
        float v46 = v45;
        if (v45) {
          goto LABEL_32;
        }
      }
      int v47 = 0;
      int v48 = 0;
      float v46 = 0;
      *(void *)uint64_t v76 = 0;
      while (1)
      {
        uint64_t v49 = *(int *)(a1 + 16) + (uint64_t)v48;
        uint64_t v50 = *(void *)(a1 + 48);
        int v51 = v47 + *(_DWORD *)(a1 + 12);
        uint64_t v52 = *(void *)(a1 + 40) + 4 * v8 * v49 + 4 * v51;
        uint64_t v53 = v50 + 4 * v9 * v49 + 4 * v51;
        if (!v50) {
          uint64_t v53 = 0;
        }
        uint64_t v57 = v52;
        uint64_t v59 = v53;
        a5(a2, v56);
        if (!v46) {
          break;
        }
LABEL_32:
        if (!shape_enum_clip_next((uint64_t)v46, &v76[1], v76, &v75, &v74))
        {
          free(v46);
          break;
        }
        int v48 = v76[0];
        int v47 = v76[1];
        unint64_t v8 = v58;
        unint64_t v9 = v60;
      }
      free(v40);
    }
  }
}

void WF_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v417 = a3;
  uint64_t v429 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  uint64_t v415 = (int)v4;
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 <= 0x1FFFFFF)
  {
    unint64_t v7 = *(int *)(a1 + 28);
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 48);
    a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
    __n128 v423 = a4;
    uint64_t v425 = *(int **)(a1 + 136);
    uint64_t v10 = *(void *)(a2 + 104);
    uint64_t v418 = *(void *)(a2 + 96);
    uint64_t v419 = v10;
    uint64_t v12 = *(int *)(a1 + 12);
    uint64_t v11 = *(int *)(a1 + 16);
    int v427 = *(_DWORD *)(a1 + 8);
    float v416 = (void *)a2;
    uint64_t v13 = *(int *)(a2 + 16);
    uint64_t v14 = (v13 + 10) * v5;
    if (v14 > 65439)
    {
      uint64_t v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0xD472E71uLL);
      uint64_t v16 = v17;
      uint64_t v19 = v17;
      char v20 = v416;
      if (!v17) {
        return;
      }
    }
    else
    {
      MEMORY[0x1F4188790](a1, a4);
      uint64_t v16 = (char *)&v411 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v16, v15);
      uint64_t v19 = 0;
      char v20 = v416;
    }
    float v412 = v19;
    unint64_t v21 = v7 >> 2;
    unint64_t v22 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
    unint64_t v23 = v22 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
    if (v13) {
      uint64_t v24 = 8 * v5;
    }
    else {
      uint64_t v24 = 0;
    }
    unint64_t v25 = v23 + v24;
    v20[18] = v22;
    v20[19] = v23 + v24;
    v20[20] = v23;
    if (v8)
    {
      unint64_t v26 = (unint64_t)*(int *)(a1 + 32) >> 2;
      uint64_t v27 = (unsigned int *)(v8 + 4 * (v12 + v26 * v11));
      uint64_t v28 = v415;
      uint64_t v424 = v26 - v415;
      uint64_t v29 = 1;
    }
    else
    {
      uint64_t v27 = 0;
      uint64_t v424 = 0;
      uint64_t v29 = 0;
      uint64_t v28 = v415;
    }
    uint64_t v30 = v418;
    uint64_t v31 = (unsigned int *)(v9 + 4 * (v12 + v21 * v11));
    uint64_t v422 = v21 - v28;
    uint64_t v32 = *(int *)(a1 + 104);
    int v33 = *(_DWORD *)(a1 + 108);
    int v34 = *(unsigned __int8 *)(a1 + 2);
    if (v34 == 6 || v34 == 1)
    {
      int v35 = v417;
      char v36 = v416;
      uint64_t v37 = v419;
      if (v425)
      {
        unint64_t v411 = v21;
        uint64_t v38 = 0;
        int v428 = 0;
        uint64_t v39 = *(int *)(a1 + 124);
        uint64_t v40 = (unsigned __int8 *)v425 + v32 + (int)v39 * (uint64_t)v33;
        uint64_t v28 = v415;
        uint64_t v421 = v39 - v415;
        goto LABEL_21;
      }
LABEL_596:
      if (v412) {
        free(v412);
      }
      return;
    }
    unint64_t v411 = v21;
    if (!v425)
    {
      uint64_t v421 = 0;
      uint64_t v38 = 0;
      uint64_t v40 = 0;
      int v428 = 0;
      int v35 = v417;
      char v36 = v416;
      uint64_t v37 = v419;
      goto LABEL_21;
    }
    uint64_t v426 = v29;
    shape_enum_clip_alloc((uint64_t)v17, v18, v425, 1, 1, 1, v32, v33, v4, v427);
    if (!v41) {
      goto LABEL_596;
    }
    int v42 = 0;
    uint64_t v43 = (int)((v13 * v5 + 15) & 0xFFFFFFF0);
    if (!v13) {
      uint64_t v43 = 8 * v5;
    }
    uint64_t v44 = v415;
    char v36 = v416;
    uint64_t v421 = -v415;
    uint64_t v40 = (unsigned __int8 *)(v25 + v43 + 16);
    int v35 = v417;
    uint64_t v38 = v41;
LABEL_584:
    uint64_t v406 = v424 + v44;
    while (1)
    {
      int v428 = v42;
      while (1)
      {
        int v407 = *((_DWORD *)v40 - 4);
        int v408 = v407 - v42;
        if (v407 > v42) {
          break;
        }
        if (v42 < *((_DWORD *)v40 - 3) + v407)
        {
          uint64_t v28 = v415;
          uint64_t v37 = v419;
          uint64_t v29 = v426;
LABEL_21:
          uint64_t v413 = -v28;
          uint64_t v414 = (v4 - 1) + 1;
          uint64_t v45 = 4 * v29;
          float v46 = v38;
          uint64_t v420 = v4;
          uint64_t v426 = v29;
LABEL_22:
          uint64_t v425 = v46;
          ((void (*)(void *, uint64_t, uint64_t, uint64_t))*v36)(v36, v30, v37, v4);
          int v47 = (float32x2_t *)v36[20];
          int v48 = (unsigned __int8 *)v36[18];
          unsigned int v49 = *((_DWORD *)v36 + 2);
          if (v49 == *((_DWORD *)v36 + 3))
          {
            float v50 = v423.n128_f32[0];
            if (v423.n128_f32[0] >= 1.0)
            {
              int v53 = v426;
            }
            else
            {
              int v51 = v4;
              uint64_t v52 = (unsigned char *)v36[18];
              int v53 = v426;
              do
              {
                if (*v52) {
                  *int v47 = vmul_n_f32(*v47, v50);
                }
                ++v52;
                ++v47;
                --v51;
              }
              while (v51);
              v47 += v413;
              v48 += v414 + v413;
            }
          }
          else
          {
            uint64_t v54 = v36[19];
            int v55 = HIWORD(v49) & 0x3F;
            float v56 = v423.n128_f32[0];
            if (v55 == 16)
            {
              int v53 = v426;
              uint64_t v59 = 0;
              unint64_t v60 = (float *)v47 + 1;
              if (v423.n128_f32[0] >= 1.0)
              {
                do
                {
                  if (v48[v59])
                  {
                    unint64_t v62 = *(unsigned int *)(v54 + 4 * v59);
                    *(v60 - 1) = *(float *)&_blt_float[v62 + 256]
                               + *(float *)&_blt_float[BYTE1(v62) + 512];
                    *unint64_t v60 = *(float *)&_blt_float[BYTE2(v62) + 256]
                         + *(float *)((char *)&_blt_float[512] + ((v62 >> 22) & 0x3FC));
                  }
                  ++v59;
                  v60 += 2;
                }
                while (v4 != v59);
              }
              else
              {
                do
                {
                  if (v48[v59])
                  {
                    unint64_t v61 = *(unsigned int *)(v54 + 4 * v59);
                    *(v60 - 1) = v56
                               * (float)(*(float *)&_blt_float[v61 + 256]
                                       + *(float *)&_blt_float[BYTE1(v61) + 512]);
                    *unint64_t v60 = v56
                         * (float)(*(float *)&_blt_float[BYTE2(v61) + 256]
                                 + *(float *)((char *)&_blt_float[512] + ((v61 >> 22) & 0x3FC)));
                  }
                  ++v59;
                  v60 += 2;
                }
                while (v4 != v59);
              }
            }
            else
            {
              BOOL v57 = v55 == 32;
              int v53 = v426;
              uint64_t v58 = 0;
              if (v57)
              {
                if (v423.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v48[v58]) {
                      v47[v58] = *(float32x2_t *)(v54 + 8 * v58);
                    }
                    ++v58;
                  }
                  while (v4 != v58);
                }
                else
                {
                  do
                  {
                    if (v48[v58]) {
                      v47[v58] = vmul_n_f32(*(float32x2_t *)(v54 + 8 * v58), v56);
                    }
                    ++v58;
                  }
                  while (v4 != v58);
                }
              }
              else
              {
                uint64_t v63 = (float *)v47 + 1;
                if (v423.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v48[v58])
                    {
                      unint64_t v65 = *(unsigned int *)(v54 + 4 * v58);
                      *(v63 - 1) = *(float *)&_blt_float[*(_DWORD *)(v54 + 4 * v58)];
                      float *v63 = *(float *)((char *)_blt_float + ((v65 >> 22) & 0x3FC));
                    }
                    ++v58;
                    v63 += 2;
                  }
                  while (v4 != v58);
                }
                else
                {
                  do
                  {
                    if (v48[v58])
                    {
                      unint64_t v64 = *(unsigned int *)(v54 + 4 * v58);
                      *(v63 - 1) = v56 * *(float *)&_blt_float[*(_DWORD *)(v54 + 4 * v58)];
                      float *v63 = v56 * *(float *)((char *)_blt_float + ((v64 >> 22) & 0x3FC));
                    }
                    ++v58;
                    v63 += 2;
                  }
                  while (v4 != v58);
                }
              }
            }
          }
          uint64_t v66 = &xmmword_1850CE000;
          switch(v35)
          {
            case 0:
              uint64_t v67 = v40 != 0;
              int v68 = v4;
              uint64_t v69 = v40;
              if (v53)
              {
                do
                {
                  unsigned int v70 = *v48;
                  if (*v48)
                  {
                    if (v40) {
                      unsigned int v70 = (*v69 * v70 + ((*v69 * v70) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v70)
                    {
                      if (v70 == 255)
                      {
                        *uint64_t v27 = 0;
                        *uint64_t v31 = 0;
                      }
                      else
                      {
                        float v71 = (float)((float)v70 * -0.0039216) + 1.0;
                        *(float *)&unsigned int v72 = v71 * COERCE_FLOAT(bswap32(*v27));
                        *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT(v71 * COERCE_FLOAT(bswap32(*v31))));
                        *uint64_t v27 = bswap32(v72);
                      }
                    }
                  }
                  ++v48;
                  v69 += v67;
                  ++v31;
                  ++v27;
                  --v68;
                }
                while (v68);
              }
              else
              {
                do
                {
                  unsigned int v73 = *v48;
                  if (*v48)
                  {
                    if (v40) {
                      unsigned int v73 = (*v69 * v73 + ((*v69 * v73) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v73)
                    {
                      if (v73 == 255) {
                        *uint64_t v31 = 0;
                      }
                      else {
                        *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v73 * -0.0039216) + 1.0)* COERCE_FLOAT(bswap32(*v31))));
                      }
                    }
                  }
                  ++v48;
                  v69 += v67;
                  ++v31;
                  --v68;
                }
                while (v68);
              }
              goto LABEL_499;
            case 1:
              unsigned __int8 v74 = *v48;
              if (v53)
              {
                int v75 = v31 - 1;
                uint64_t v76 = (float *)v47 + 1;
                uint64_t v77 = v48 + 1;
                uint64_t v78 = v27 - 1;
                int v79 = v4;
                if (v40)
                {
                  uint64_t v38 = v425;
                  do
                  {
                    if (v74)
                    {
                      unsigned int v80 = ((unsigned __int16)(*v40 * v74 + ((*v40 * v74) >> 8) + 1) >> 8);
                      if (v80)
                      {
                        if (v80 == 255)
                        {
                          float v81 = *v76;
                          unsigned int v82 = bswap32(*((_DWORD *)v76 - 1));
                        }
                        else
                        {
                          float v83 = (float)v80 * 0.0039216;
                          unsigned int v82 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v83) * COERCE_FLOAT(bswap32(v75[1])))+ (float)(*(v76 - 1) * v83)));
                          float v81 = (float)((float)(1.0 - v83) * COERCE_FLOAT(bswap32(v78[1]))) + (float)(*v76 * v83);
                        }
                        v75[1] = v82;
                        v78[1] = bswap32(LODWORD(v81));
                      }
                    }
                    unsigned __int8 v84 = *v77++;
                    unsigned __int8 v74 = v84;
                    ++v40;
                    ++v75;
                    v76 += 2;
                    ++v78;
                    --v79;
                  }
                  while (v79);
                  v40 += v421;
                }
                else
                {
                  uint64_t v38 = v425;
                  do
                  {
                    if (v74)
                    {
                      if (v74 == 255)
                      {
                        float v387 = *v76;
                        unsigned int v388 = bswap32(*((_DWORD *)v76 - 1));
                      }
                      else
                      {
                        float v389 = (float)v74 * 0.0039216;
                        unsigned int v388 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v389) * COERCE_FLOAT(bswap32(v75[1])))+ (float)(*(v76 - 1) * v389)));
                        float v387 = (float)((float)(1.0 - v389) * COERCE_FLOAT(bswap32(v78[1]))) + (float)(*v76 * v389);
                      }
                      v75[1] = v388;
                      v78[1] = bswap32(LODWORD(v387));
                    }
                    unsigned __int8 v390 = *v77++;
                    unsigned __int8 v74 = v390;
                    ++v75;
                    v76 += 2;
                    ++v78;
                    --v79;
                  }
                  while (v79);
                  uint64_t v40 = 0;
                }
                float v391 = &v75[v422];
                goto LABEL_561;
              }
              float v369 = v48 + 1;
              float v370 = v31 - 1;
              int v371 = v4;
              if (v40)
              {
                uint64_t v38 = v425;
                do
                {
                  if (v74)
                  {
                    unsigned int v372 = ((unsigned __int16)(*v40 * v74 + ((*v40 * v74) >> 8) + 1) >> 8);
                    if (v372)
                    {
                      if (v372 == 255) {
                        float v373 = v47->f32[0];
                      }
                      else {
                        float v373 = (float)((float)(1.0 - (float)((float)v372 * 0.0039216)) * COERCE_FLOAT(bswap32(v370[1])))
                      }
                             + (float)(v47->f32[0] * (float)((float)v372 * 0.0039216));
                      v370[1] = bswap32(LODWORD(v373));
                    }
                  }
                  unsigned __int8 v374 = *v369++;
                  unsigned __int8 v74 = v374;
                  ++v47;
                  ++v40;
                  ++v370;
                  --v371;
                }
                while (v371);
                goto LABEL_529;
              }
              uint64_t v38 = v425;
              do
              {
                if (v74)
                {
                  if (v74 == 255) {
                    float v399 = v47->f32[0];
                  }
                  else {
                    float v399 = (float)((float)(1.0 - (float)((float)v74 * 0.0039216)) * COERCE_FLOAT(bswap32(v370[1])))
                  }
                         + (float)(v47->f32[0] * (float)((float)v74 * 0.0039216));
                  v370[1] = bswap32(LODWORD(v399));
                }
                unsigned __int8 v400 = *v369++;
                unsigned __int8 v74 = v400;
                ++v47;
                ++v370;
                --v371;
              }
              while (v371);
              goto LABEL_582;
            case 2:
              unsigned __int8 v85 = *v48;
              if (v53)
              {
                uint64_t v86 = 0;
                float v87 = v48 + 1;
                if (v40)
                {
                  uint64_t v88 = 0x3FFFFFFFFFFFFFFFLL;
                  uint64_t v38 = v425;
                  while (1)
                  {
                    if (!v85) {
                      goto LABEL_104;
                    }
                    unsigned int v89 = ((unsigned __int16)(v40[v86] * v85 + ((v40[v86] * v85) >> 8) + 1) >> 8);
                    if (!v89) {
                      goto LABEL_104;
                    }
                    if (v89 == 255)
                    {
                      float v90 = v47->f32[1];
                      if (v90 >= 1.0)
                      {
                        unsigned int v95 = v47->i32[0];
                        goto LABEL_103;
                      }
                      if (v90 > 0.0)
                      {
                        unsigned int v91 = v31[v86];
                        float v92 = v47->f32[0];
                        goto LABEL_101;
                      }
                    }
                    else
                    {
                      float v93 = (float)v89 * 0.0039216;
                      float v90 = v93 * v47->f32[1];
                      if (v90 > 0.0)
                      {
                        unsigned int v91 = v31[v86];
                        float v92 = v93 * v47->f32[0];
LABEL_101:
                        *(float *)&unsigned int v94 = v92 + (float)(COERCE_FLOAT(bswap32(v91)) * (float)(1.0 - v90));
                        float v90 = v90 + (float)(COERCE_FLOAT(bswap32(v27[v86])) * (float)(1.0 - v90));
                        unsigned int v95 = v94;
LABEL_103:
                        v31[v86] = bswap32(v95);
                        v27[v86] = bswap32(LODWORD(v90));
                      }
                    }
LABEL_104:
                    unsigned __int8 v85 = v87[v86];
                    ++v47;
                    ++v86;
                    ++v88;
                    if (v4 == v86)
                    {
                      uint64_t v96 = &v31[v88];
                      uint64_t v78 = &v27[v88];
                      v40 += v86 + v421;
LABEL_560:
                      float v391 = &v96[v422];
LABEL_561:
                      uint64_t v31 = v391 + 1;
                      uint64_t v27 = &v78[v424 + 1];
LABEL_502:
                      if (v427 == 1) {
                        goto LABEL_594;
                      }
                      --v427;
                      float v46 = 0;
                      ++v428;
                      v30 += v36[16];
                      v37 += v36[17];
                      if (v38)
                      {
                        uint64_t v419 = v37;
                        uint64_t v44 = v415;
                        int v42 = v428;
                        goto LABEL_584;
                      }
                      goto LABEL_22;
                    }
                  }
                }
                uint64_t v392 = 4;
                uint64_t v38 = v425;
                while (1)
                {
                  if (v85)
                  {
                    if (v85 == 255)
                    {
                      float v393 = v47->f32[1];
                      if (v393 >= 1.0)
                      {
                        unsigned int v398 = v47->i32[0];
                        goto LABEL_557;
                      }
                      if (v393 > 0.0)
                      {
                        unsigned int v394 = v31[v86];
                        float v395 = v47->f32[0];
                        goto LABEL_555;
                      }
                    }
                    else
                    {
                      float v396 = (float)v85 * 0.0039216;
                      float v393 = v396 * v47->f32[1];
                      if (v393 > 0.0)
                      {
                        unsigned int v394 = v31[v86];
                        float v395 = v396 * v47->f32[0];
LABEL_555:
                        *(float *)&unsigned int v397 = v395 + (float)(COERCE_FLOAT(bswap32(v394)) * (float)(1.0 - v393));
                        float v393 = v393 + (float)(COERCE_FLOAT(bswap32(v27[v86])) * (float)(1.0 - v393));
                        unsigned int v398 = v397;
LABEL_557:
                        v31[v86] = bswap32(v398);
                        v27[v86] = bswap32(LODWORD(v393));
                      }
                    }
                  }
                  unsigned __int8 v85 = v87[v86];
                  ++v47;
                  ++v86;
                  v392 -= 4;
                  if (v4 == v86)
                  {
                    uint64_t v40 = 0;
                    uint64_t v78 = &v27[v392 / 0xFFFFFFFFFFFFFFFCLL];
                    uint64_t v96 = &v31[v392 / 0xFFFFFFFFFFFFFFFCLL];
                    goto LABEL_560;
                  }
                }
              }
              float v375 = v48 + 1;
              float v370 = v31 - 1;
              int v376 = v4;
              if (v40)
              {
                uint64_t v38 = v425;
                while (1)
                {
                  if (!v85) {
                    goto LABEL_528;
                  }
                  unsigned int v377 = ((unsigned __int16)(*v40 * v85 + ((*v40 * v85) >> 8) + 1) >> 8);
                  if (!v377) {
                    goto LABEL_528;
                  }
                  if (v377 == 255)
                  {
                    float v378 = v47->f32[1];
                    if (v378 >= 1.0)
                    {
                      float v381 = v47->f32[0];
                      goto LABEL_527;
                    }
                    if (v378 > 0.0)
                    {
                      float v379 = v47->f32[0];
                      goto LABEL_525;
                    }
                  }
                  else
                  {
                    float v380 = (float)v377 * 0.0039216;
                    float v378 = v380 * v47->f32[1];
                    if (v378 > 0.0)
                    {
                      float v379 = v380 * v47->f32[0];
LABEL_525:
                      float v381 = v379 + (float)(COERCE_FLOAT(bswap32(v370[1])) * (float)(1.0 - v378));
LABEL_527:
                      v370[1] = bswap32(LODWORD(v381));
                    }
                  }
LABEL_528:
                  unsigned __int8 v382 = *v375++;
                  unsigned __int8 v85 = v382;
                  ++v47;
                  ++v40;
                  ++v370;
                  if (!--v376)
                  {
LABEL_529:
                    v40 += v421;
LABEL_583:
                    uint64_t v31 = &v370[v422 + 1];
                    v27 += v424;
                    goto LABEL_502;
                  }
                }
              }
              uint64_t v38 = v425;
              while (1)
              {
                if (v85)
                {
                  if (v85 == 255)
                  {
                    float v401 = v47->f32[1];
                    if (v401 >= 1.0)
                    {
                      float v404 = v47->f32[0];
                      goto LABEL_580;
                    }
                    if (v401 > 0.0)
                    {
                      float v402 = v47->f32[0];
                      goto LABEL_578;
                    }
                  }
                  else
                  {
                    float v403 = (float)v85 * 0.0039216;
                    float v401 = v403 * v47->f32[1];
                    if (v401 > 0.0)
                    {
                      float v402 = v403 * v47->f32[0];
LABEL_578:
                      float v404 = v402 + (float)(COERCE_FLOAT(bswap32(v370[1])) * (float)(1.0 - v401));
LABEL_580:
                      v370[1] = bswap32(LODWORD(v404));
                    }
                  }
                }
                unsigned __int8 v405 = *v375++;
                unsigned __int8 v85 = v405;
                ++v47;
                ++v370;
                if (!--v376)
                {
LABEL_582:
                  uint64_t v40 = 0;
                  goto LABEL_583;
                }
              }
            case 3:
              uint64_t v97 = (float *)v47 + 1;
              int v98 = v4;
              uint64_t v69 = v40;
              do
              {
                unsigned int v99 = *v48;
                if (*v48)
                {
                  if (v40) {
                    unsigned int v99 = (*v69 * v99 + ((*v69 * v99) >> 8) + 1) >> 8;
                  }
                  if ((_BYTE)v99)
                  {
                    if (v99 == 255)
                    {
                      float v100 = COERCE_FLOAT(bswap32(*v27));
                      float v101 = *(v97 - 1) * v100;
                      float v102 = *v97 * v100;
                    }
                    else
                    {
                      float v103 = (float)v99 * 0.0039216;
                      float v104 = COERCE_FLOAT(bswap32(*v27));
                      float v105 = v103 * v104;
                      float v106 = 1.0 - v103;
                      float v101 = (float)((float)(1.0 - v103) * COERCE_FLOAT(bswap32(*v31)))
                           + (float)(*(v97 - 1) * (float)(v103 * v104));
                      float v102 = (float)(v106 * v104) + (float)(*v97 * v105);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v101));
                    *uint64_t v27 = bswap32(LODWORD(v102));
                  }
                }
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v97 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                --v98;
              }
              while (v98);
              goto LABEL_499;
            case 4:
              float v107 = (float *)v47 + 1;
              int v108 = v4;
              uint64_t v69 = v40;
              do
              {
                unsigned int v109 = *v48;
                if (*v48)
                {
                  if (v40) {
                    unsigned int v109 = (*v69 * v109 + ((*v69 * v109) >> 8) + 1) >> 8;
                  }
                  if ((_BYTE)v109)
                  {
                    if (v109 == 255)
                    {
                      float v110 = 1.0 - COERCE_FLOAT(bswap32(*v27));
                      float v111 = *(v107 - 1) * v110;
                      float v112 = *v107 * v110;
                    }
                    else
                    {
                      float v113 = (float)v109 * 0.0039216;
                      float v114 = COERCE_FLOAT(bswap32(*v27));
                      float v115 = v113 * (float)(1.0 - v114);
                      float v116 = 1.0 - v113;
                      float v111 = (float)((float)(1.0 - v113) * COERCE_FLOAT(bswap32(*v31))) + (float)(*(v107 - 1) * v115);
                      float v112 = (float)(v116 * v114) + (float)(*v107 * v115);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v111));
                    *uint64_t v27 = bswap32(LODWORD(v112));
                  }
                }
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v107 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                --v108;
              }
              while (v108);
              goto LABEL_499;
            case 5:
              uint64_t v117 = (float *)v47 + 1;
              int v118 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v119 = *v48;
                if (*v48)
                {
                  if (!v40) {
                    goto LABEL_133;
                  }
                  unsigned int v120 = *v69 * v119 + ((*v69 * v119) >> 8) + 1;
                  if (BYTE1(v120)) {
                    break;
                  }
                }
LABEL_134:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v117 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v118) {
                  goto LABEL_499;
                }
              }
              unsigned int v119 = v120 >> 8;
LABEL_133:
              float v121 = COERCE_FLOAT(bswap32(*v27));
              float v122 = (float)v119 * 0.0039216;
              float v123 = *(v117 - 1) * v122;
              float v124 = v122 * *v117;
              *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v124) * COERCE_FLOAT(bswap32(*v31))) + (float)(v123 * v121)));
              *uint64_t v27 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v124) * v121) + (float)(v124 * v121)));
              goto LABEL_134;
            case 6:
              uint64_t v125 = (float *)v47 + 1;
              int v126 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v127 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v128 = *v69 * v127 + ((*v69 * v127) >> 8) + 1;
                    if (!BYTE1(v128)) {
                      goto LABEL_146;
                    }
                    unsigned int v127 = v128 >> 8;
                  }
                  float v129 = COERCE_FLOAT(bswap32(*v27));
                  float v130 = 1.0 - v129;
                  if ((float)(1.0 - v129) >= 1.0)
                  {
                    float v134 = (float)v127 * 0.0039216;
                    float v132 = v134 * *(v125 - 1);
                    float v133 = v134 * *v125;
                    goto LABEL_145;
                  }
                  if (v130 > 0.0)
                  {
                    float v131 = (float)((float)v127 * 0.0039216) * v130;
                    float v132 = COERCE_FLOAT(bswap32(*v31)) + (float)(*(v125 - 1) * v131);
                    float v133 = v129 + (float)(*v125 * v131);
LABEL_145:
                    *uint64_t v31 = bswap32(LODWORD(v132));
                    *uint64_t v27 = bswap32(LODWORD(v133));
                  }
                }
LABEL_146:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v125 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v126) {
                  goto LABEL_499;
                }
              }
            case 7:
              uint64_t v135 = v40 != 0;
              uint64_t v136 = (float *)v47 + 1;
              int v137 = v4;
              uint64_t v69 = v40;
              if (v53)
              {
                do
                {
                  unsigned int v138 = *v48;
                  if (*v48)
                  {
                    if (v40) {
                      unsigned int v138 = (*v69 * v138 + ((*v69 * v138) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v138)
                    {
                      if (v138 == 255)
                      {
                        float v139 = *v136 * COERCE_FLOAT(bswap32(*v31));
                        float v140 = *v136 * COERCE_FLOAT(bswap32(*v27));
                      }
                      else
                      {
                        float v141 = (float)v138 * 0.0039216;
                        float v142 = COERCE_FLOAT(bswap32(*v27));
                        float v143 = COERCE_FLOAT(bswap32(*v31));
                        float v144 = v141 * *v136;
                        float v145 = 1.0 - v141;
                        float v139 = (float)((float)(1.0 - v141) * v143) + (float)(v143 * v144);
                        float v140 = (float)(v145 * v142) + (float)(v142 * v144);
                      }
                      *uint64_t v31 = bswap32(LODWORD(v139));
                      *uint64_t v27 = bswap32(LODWORD(v140));
                    }
                  }
                  ++v48;
                  v69 += v135;
                  ++v31;
                  ++v27;
                  v136 += 2;
                  --v137;
                }
                while (v137);
              }
              else
              {
                do
                {
                  unsigned int v146 = *v48;
                  if (*v48)
                  {
                    if (v40) {
                      unsigned int v146 = (*v69 * v146 + ((*v69 * v146) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v146)
                    {
                      if (v146 == 255)
                      {
                        float v147 = *v136 * COERCE_FLOAT(bswap32(*v31));
                      }
                      else
                      {
                        float v148 = COERCE_FLOAT(bswap32(*v31));
                        float v147 = (float)((float)(1.0 - (float)((float)v146 * 0.0039216)) * v148)
                             + (float)(v148 * (float)((float)((float)v146 * 0.0039216) * *v136));
                      }
                      *uint64_t v31 = bswap32(LODWORD(v147));
                    }
                  }
                  ++v48;
                  v69 += v135;
                  ++v31;
                  v136 += 2;
                  --v137;
                }
                while (v137);
              }
              goto LABEL_499;
            case 8:
              uint64_t v149 = v40 != 0;
              float v150 = (float *)v47 + 1;
              int v151 = v4;
              uint64_t v69 = v40;
              if (v53)
              {
                do
                {
                  unsigned int v152 = *v48;
                  if (*v48)
                  {
                    if (v40) {
                      unsigned int v152 = (*v69 * v152 + ((*v69 * v152) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v152)
                    {
                      if (v152 == 255)
                      {
                        float v153 = 1.0 - *v150;
                        float v154 = v153 * COERCE_FLOAT(bswap32(*v31));
                        float v155 = v153 * COERCE_FLOAT(bswap32(*v27));
                      }
                      else
                      {
                        float v156 = (float)v152 * 0.0039216;
                        float v157 = COERCE_FLOAT(bswap32(*v27));
                        float v158 = COERCE_FLOAT(bswap32(*v31));
                        float v159 = v156 * (float)(1.0 - *v150);
                        float v160 = 1.0 - v156;
                        float v154 = (float)((float)(1.0 - v156) * v158) + (float)(v158 * v159);
                        float v155 = (float)(v160 * v157) + (float)(v157 * v159);
                      }
                      *uint64_t v31 = bswap32(LODWORD(v154));
                      *uint64_t v27 = bswap32(LODWORD(v155));
                    }
                  }
                  ++v48;
                  v69 += v149;
                  ++v31;
                  ++v27;
                  v150 += 2;
                  --v151;
                }
                while (v151);
              }
              else
              {
                do
                {
                  unsigned int v161 = *v48;
                  if (*v48)
                  {
                    if (v40) {
                      unsigned int v161 = (*v69 * v161 + ((*v69 * v161) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v161)
                    {
                      if (v161 == 255)
                      {
                        float v162 = (float)(1.0 - *v150) * COERCE_FLOAT(bswap32(*v31));
                      }
                      else
                      {
                        float v163 = COERCE_FLOAT(bswap32(*v31));
                        float v162 = (float)((float)(1.0 - (float)((float)v161 * 0.0039216)) * v163)
                             + (float)(v163
                                     * (float)((float)((float)v161 * 0.0039216) * (float)(1.0 - *v150)));
                      }
                      *uint64_t v31 = bswap32(LODWORD(v162));
                    }
                  }
                  ++v48;
                  v69 += v149;
                  ++v31;
                  v150 += 2;
                  --v151;
                }
                while (v151);
              }
              goto LABEL_499;
            case 9:
              uint64_t v164 = (float *)v47 + 1;
              int v165 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v166 = *v48;
                if (*v48)
                {
                  if (!v40) {
                    goto LABEL_195;
                  }
                  unsigned int v167 = *v69 * v166 + ((*v69 * v166) >> 8) + 1;
                  if (BYTE1(v167)) {
                    break;
                  }
                }
LABEL_196:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v164 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v165) {
                  goto LABEL_499;
                }
              }
              unsigned int v166 = v167 >> 8;
LABEL_195:
              float v168 = COERCE_FLOAT(bswap32(*v27));
              float v169 = (float)v166 * 0.0039216;
              float v170 = *(v164 - 1) * v169;
              float v171 = v169 * *v164;
              float v172 = (float)(1.0 - v169) + v171;
              *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT((float)(v172 * COERCE_FLOAT(bswap32(*v31))) + (float)(v170 * (float)(1.0 - v168))));
              *uint64_t v27 = bswap32(COERCE_UNSIGNED_INT((float)(v172 * v168) + (float)(v171 * (float)(1.0 - v168))));
              goto LABEL_196;
            case 10:
              float v173 = (float *)v47 + 1;
              int v174 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v175 = *v48;
                if (*v48)
                {
                  if (!v40) {
                    goto LABEL_203;
                  }
                  unsigned int v176 = *v69 * v175 + ((*v69 * v175) >> 8) + 1;
                  if (BYTE1(v176)) {
                    break;
                  }
                }
LABEL_204:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v173 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v174) {
                  goto LABEL_499;
                }
              }
              unsigned int v175 = v176 >> 8;
LABEL_203:
              float v177 = COERCE_FLOAT(bswap32(*v27));
              float v178 = (float)v175 * 0.0039216;
              float v179 = *(v173 - 1) * v178;
              float v180 = v178 * *v173;
              *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v180) * COERCE_FLOAT(bswap32(*v31)))+ (float)(v179 * (float)(1.0 - v177))));
              *uint64_t v27 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v180) * v177) + (float)(v180 * (float)(1.0 - v177))));
              goto LABEL_204;
            case 11:
              uint64_t v181 = v40 != 0;
              uint64_t v182 = (float *)v47 + 1;
              int v183 = v4;
              uint64_t v69 = v40;
              if (v53)
              {
                while (1)
                {
                  unsigned int v184 = *v48;
                  if (*v48)
                  {
                    if (!v40) {
                      goto LABEL_211;
                    }
                    unsigned int v185 = *v69 * v184 + ((*v69 * v184) >> 8) + 1;
                    if (BYTE1(v185)) {
                      break;
                    }
                  }
LABEL_214:
                  ++v48;
                  v69 += v181;
                  ++v31;
                  ++v27;
                  v182 += 2;
                  if (!--v183) {
                    goto LABEL_499;
                  }
                }
                unsigned int v184 = v185 >> 8;
LABEL_211:
                float v186 = (float)v184 * 0.0039216;
                float v187 = *(v182 - 1) * v186;
                float v188 = *v182 * v186;
                float v189 = COERCE_FLOAT(bswap32(*v31));
                float v190 = COERCE_FLOAT(bswap32(*v27));
                float v191 = v188 + v190;
                if ((float)(v188 + v190) > 1.0) {
                  float v191 = 1.0;
                }
                *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT((float)(v188 - v187) + (float)(v191 - (float)(v190 - v189))));
                *uint64_t v27 = bswap32(LODWORD(v191));
                goto LABEL_214;
              }
              while (1)
              {
                unsigned int v192 = *v48;
                if (*v48)
                {
                  if (!v40) {
                    goto LABEL_220;
                  }
                  unsigned int v193 = *v69 * v192 + ((*v69 * v192) >> 8) + 1;
                  if (BYTE1(v193)) {
                    break;
                  }
                }
LABEL_221:
                ++v48;
                v69 += v181;
                ++v31;
                v182 += 2;
                if (!--v183) {
                  goto LABEL_499;
                }
              }
              unsigned int v192 = v193 >> 8;
LABEL_220:
              *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)(*v182 * (float)((float)v192 * 0.0039216))- (float)(*(v182 - 1) * (float)((float)v192 * 0.0039216)))+ COERCE_FLOAT(bswap32(*v31))));
              goto LABEL_221;
            case 12:
              uint64_t v194 = v40 != 0;
              if (v53)
              {
                float v195 = (float *)v47 + 1;
                int v196 = v4;
                uint64_t v69 = v40;
                while (1)
                {
                  unsigned int v197 = *v48;
                  if (*v48)
                  {
                    if (!v40) {
                      goto LABEL_229;
                    }
                    unsigned int v198 = *v69 * v197 + ((*v69 * v197) >> 8) + 1;
                    if (BYTE1(v198)) {
                      break;
                    }
                  }
LABEL_232:
                  ++v48;
                  v69 += v194;
                  ++v31;
                  ++v27;
                  v195 += 2;
                  if (!--v196) {
                    goto LABEL_499;
                  }
                }
                unsigned int v197 = v198 >> 8;
LABEL_229:
                float v199 = (float)v197 * 0.0039216;
                float v200 = *(v195 - 1) * v199;
                float v201 = (float)(*v195 * v199) + COERCE_FLOAT(bswap32(*v27));
                float v202 = v200 + COERCE_FLOAT(bswap32(*v31));
                if (v201 > 1.0) {
                  float v201 = 1.0;
                }
                *uint64_t v31 = bswap32(LODWORD(v202));
                *uint64_t v27 = bswap32(LODWORD(v201));
                goto LABEL_232;
              }
              int v383 = v4;
              uint64_t v384 = v40;
              while (1)
              {
                unsigned int v385 = *v48;
                if (*v48)
                {
                  if (!v40) {
                    goto LABEL_535;
                  }
                  unsigned int v386 = *v384 * v385 + ((*v384 * v385) >> 8) + 1;
                  if (BYTE1(v386)) {
                    break;
                  }
                }
LABEL_536:
                ++v48;
                ++v47;
                v384 += v194;
                ++v31;
                if (!--v383)
                {
                  uint64_t v40 = &v384[v421];
LABEL_500:
                  v31 += v422;
                  v27 += v424;
LABEL_501:
                  uint64_t v38 = v425;
                  goto LABEL_502;
                }
              }
              unsigned int v385 = v386 >> 8;
LABEL_535:
              *uint64_t v31 = bswap32(COERCE_UNSIGNED_INT((float)(v47->f32[0] * (float)((float)v385 * 0.0039216))+ COERCE_FLOAT(bswap32(*v31))));
              goto LABEL_536;
            case 13:
              uint64_t v203 = (float *)v47 + 1;
              int v204 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v205 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v206 = *v69 * v205 + ((*v69 * v205) >> 8) + 1;
                    if (!BYTE1(v206)) {
                      goto LABEL_250;
                    }
                    unsigned int v205 = v206 >> 8;
                  }
                  float v207 = (float)v205 * 0.0039216;
                  float v208 = *v203 * v207;
                  if (v208 > 0.0)
                  {
                    float v209 = *(v203 - 1) * v207;
                    float v210 = 1.0;
                    if (!v53 || (float v210 = COERCE_FLOAT(bswap32(*v27)), v210 > 0.0))
                    {
                      float v211 = COERCE_FLOAT(bswap32(*v31));
                      float v212 = (float)(v209 * v211) + (float)(v211 * (float)(1.0 - v208));
                      if (v208 == 1.0) {
                        float v212 = v209 * v211;
                      }
                      float v209 = v212 + (float)(v209 * (float)(1.0 - v210));
                      if (v210 == 1.0) {
                        float v209 = v212;
                      }
                      if (!v53)
                      {
                        *uint64_t v31 = bswap32(LODWORD(v209));
                        goto LABEL_250;
                      }
                      float v208 = (float)(v208 + v210) - (float)(v210 * v208);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v209));
                    *uint64_t v27 = bswap32(LODWORD(v208));
                  }
                }
LABEL_250:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v203 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v204) {
                  goto LABEL_499;
                }
              }
            case 14:
              float v213 = (float *)v47 + 1;
              int v214 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v215 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v216 = *v69 * v215 + ((*v69 * v215) >> 8) + 1;
                    if (!BYTE1(v216)) {
                      goto LABEL_264;
                    }
                    unsigned int v215 = v216 >> 8;
                  }
                  float v217 = (float)v215 * 0.0039216;
                  float v218 = *v213 * v217;
                  if (v218 > 0.0)
                  {
                    float v219 = *(v213 - 1) * v217;
                    float v220 = 1.0;
                    if (!v53 || (float v220 = COERCE_FLOAT(bswap32(*v27)), v220 > 0.0))
                    {
                      float v221 = COERCE_FLOAT(bswap32(*v31));
                      float v219 = v221 + (float)(v219 * (float)(1.0 - v221));
                      if (!v53)
                      {
                        *uint64_t v31 = bswap32(LODWORD(v219));
                        goto LABEL_264;
                      }
                      float v218 = (float)(v218 + v220) - (float)(v220 * v218);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v219));
                    *uint64_t v27 = bswap32(LODWORD(v218));
                  }
                }
LABEL_264:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v213 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v214) {
                  goto LABEL_499;
                }
              }
            case 15:
              uint64_t v418 = v30;
              uint64_t v419 = v37;
              uint64_t v222 = (float *)v47 + 1;
              int v223 = v4;
              uint64_t v224 = v40;
              while (1)
              {
                unsigned int v225 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v226 = *v224 * v225 + ((*v224 * v225) >> 8) + 1;
                    if (!BYTE1(v226)) {
                      goto LABEL_280;
                    }
                    unsigned int v225 = v226 >> 8;
                  }
                  float v227 = (float)v225 * *((float *)v66 + 677);
                  float v228 = *v222 * v227;
                  if (v228 > 0.0)
                  {
                    float v229 = *(v222 - 1) * v227;
                    if (v53)
                    {
                      float v230 = COERCE_FLOAT(bswap32(*v27));
                      if (v230 <= 0.0)
                      {
LABEL_278:
                        *uint64_t v31 = bswap32(LODWORD(v229));
                        *uint64_t v27 = bswap32(LODWORD(v228));
                        goto LABEL_280;
                      }
                    }
                    else
                    {
                      float v230 = 1.0;
                    }
                    float v231 = v66;
                    float v232 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v31)), v230, v229, v228);
                    int v53 = v426;
                    float v229 = v232;
                    if (!v426)
                    {
                      *uint64_t v31 = bswap32(LODWORD(v232));
                      uint64_t v66 = v231;
                      uint64_t v4 = v420;
                      goto LABEL_280;
                    }
                    float v228 = v233;
                    uint64_t v66 = v231;
                    uint64_t v4 = v420;
                    goto LABEL_278;
                  }
                }
LABEL_280:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v222 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v223) {
                  goto LABEL_385;
                }
              }
            case 16:
              float v234 = (float *)v47 + 1;
              int v235 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v236 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v237 = *v69 * v236 + ((*v69 * v236) >> 8) + 1;
                    if (!BYTE1(v237)) {
                      goto LABEL_300;
                    }
                    unsigned int v236 = v237 >> 8;
                  }
                  float v238 = (float)v236 * 0.0039216;
                  float v239 = *v234 * v238;
                  if (v239 > 0.0)
                  {
                    float v240 = *(v234 - 1) * v238;
                    float v241 = 1.0;
                    if (!v53 || (float v241 = COERCE_FLOAT(bswap32(*v27)), v241 > 0.0))
                    {
                      float v242 = COERCE_FLOAT(bswap32(*v31));
                      float v243 = v239 * v242;
                      if ((float)(v240 * v241) < (float)(v239 * v242)) {
                        float v243 = v240 * v241;
                      }
                      float v244 = v243 + (float)(v242 * (float)(1.0 - v239));
                      if (v239 == 1.0) {
                        float v244 = v243;
                      }
                      float v240 = v244 + (float)(v240 * (float)(1.0 - v241));
                      if (v241 == 1.0) {
                        float v240 = v244;
                      }
                      if (!v53)
                      {
                        *uint64_t v31 = bswap32(LODWORD(v240));
                        goto LABEL_300;
                      }
                      float v239 = (float)(v239 + v241) - (float)(v241 * v239);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v240));
                    *uint64_t v27 = bswap32(LODWORD(v239));
                  }
                }
LABEL_300:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v234 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v235) {
                  goto LABEL_499;
                }
              }
            case 17:
              float v245 = (float *)v47 + 1;
              int v246 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v247 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v248 = *v69 * v247 + ((*v69 * v247) >> 8) + 1;
                    if (!BYTE1(v248)) {
                      goto LABEL_320;
                    }
                    unsigned int v247 = v248 >> 8;
                  }
                  float v249 = (float)v247 * 0.0039216;
                  float v250 = *v245 * v249;
                  if (v250 > 0.0)
                  {
                    float v251 = *(v245 - 1) * v249;
                    float v252 = 1.0;
                    if (!v53 || (float v252 = COERCE_FLOAT(bswap32(*v27)), v252 > 0.0))
                    {
                      float v253 = COERCE_FLOAT(bswap32(*v31));
                      float v254 = v250 * v253;
                      if ((float)(v251 * v252) > (float)(v250 * v253)) {
                        float v254 = v251 * v252;
                      }
                      float v255 = v254 + (float)(v253 * (float)(1.0 - v250));
                      if (v250 == 1.0) {
                        float v255 = v254;
                      }
                      float v251 = v255 + (float)(v251 * (float)(1.0 - v252));
                      if (v252 == 1.0) {
                        float v251 = v255;
                      }
                      if (!v53)
                      {
                        *uint64_t v31 = bswap32(LODWORD(v251));
                        goto LABEL_320;
                      }
                      float v250 = (float)(v250 + v252) - (float)(v252 * v250);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v251));
                    *uint64_t v27 = bswap32(LODWORD(v250));
                  }
                }
LABEL_320:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v245 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v246) {
                  goto LABEL_499;
                }
              }
            case 18:
              uint64_t v418 = v30;
              uint64_t v419 = v37;
              uint64_t v256 = (float *)v47 + 1;
              int v257 = v4;
              uint64_t v224 = v40;
              while (1)
              {
                unsigned int v258 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v259 = *v224 * v258 + ((*v224 * v258) >> 8) + 1;
                    if (!BYTE1(v259)) {
                      goto LABEL_336;
                    }
                    unsigned int v258 = v259 >> 8;
                  }
                  float v260 = (float)v258 * *((float *)v66 + 677);
                  float v261 = *v256 * v260;
                  if (v261 > 0.0)
                  {
                    float v262 = *(v256 - 1) * v260;
                    if (v53)
                    {
                      float v263 = COERCE_FLOAT(bswap32(*v27));
                      if (v263 <= 0.0)
                      {
LABEL_334:
                        *uint64_t v31 = bswap32(LODWORD(v262));
                        *uint64_t v27 = bswap32(LODWORD(v261));
                        goto LABEL_336;
                      }
                    }
                    else
                    {
                      float v263 = 1.0;
                    }
                    uint64_t v264 = v66;
                    float v265 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v31)), v263, v262, v261);
                    int v53 = v426;
                    float v262 = v265;
                    if (!v426)
                    {
                      *uint64_t v31 = bswap32(LODWORD(v265));
                      uint64_t v66 = v264;
                      uint64_t v4 = v420;
                      goto LABEL_336;
                    }
                    float v261 = v266;
                    uint64_t v66 = v264;
                    uint64_t v4 = v420;
                    goto LABEL_334;
                  }
                }
LABEL_336:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v256 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v257) {
                  goto LABEL_385;
                }
              }
            case 19:
              uint64_t v418 = v30;
              uint64_t v419 = v37;
              float v267 = (float *)v47 + 1;
              int v268 = v4;
              uint64_t v224 = v40;
              while (1)
              {
                unsigned int v269 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v270 = *v224 * v269 + ((*v224 * v269) >> 8) + 1;
                    if (!BYTE1(v270)) {
                      goto LABEL_352;
                    }
                    unsigned int v269 = v270 >> 8;
                  }
                  float v271 = (float)v269 * *((float *)v66 + 677);
                  float v272 = *v267 * v271;
                  if (v272 > 0.0)
                  {
                    float v273 = *(v267 - 1) * v271;
                    if (v53)
                    {
                      float v274 = COERCE_FLOAT(bswap32(*v27));
                      if (v274 <= 0.0)
                      {
LABEL_350:
                        *uint64_t v31 = bswap32(LODWORD(v273));
                        *uint64_t v27 = bswap32(LODWORD(v272));
                        goto LABEL_352;
                      }
                    }
                    else
                    {
                      float v274 = 1.0;
                    }
                    uint64_t v275 = v66;
                    double v276 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v31)), v274, v273, v272);
                    int v53 = v426;
                    float v273 = *(float *)&v276;
                    if (!v426)
                    {
                      *uint64_t v31 = bswap32(LODWORD(v276));
                      uint64_t v66 = v275;
                      uint64_t v4 = v420;
                      goto LABEL_352;
                    }
                    float v272 = v277;
                    uint64_t v66 = v275;
                    uint64_t v4 = v420;
                    goto LABEL_350;
                  }
                }
LABEL_352:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v267 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v268) {
                  goto LABEL_385;
                }
              }
            case 20:
              uint64_t v418 = v30;
              uint64_t v419 = v37;
              uint64_t v278 = (float *)v47 + 1;
              int v279 = v4;
              uint64_t v224 = v40;
              while (1)
              {
                unsigned int v280 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v281 = *v224 * v280 + ((*v224 * v280) >> 8) + 1;
                    if (!BYTE1(v281)) {
                      goto LABEL_368;
                    }
                    unsigned int v280 = v281 >> 8;
                  }
                  float v282 = (float)v280 * *((float *)v66 + 677);
                  float v283 = *v278 * v282;
                  if (v283 > 0.0)
                  {
                    float v284 = *(v278 - 1) * v282;
                    if (v53)
                    {
                      float v285 = COERCE_FLOAT(bswap32(*v27));
                      if (v285 <= 0.0)
                      {
LABEL_366:
                        *uint64_t v31 = bswap32(LODWORD(v284));
                        *uint64_t v27 = bswap32(LODWORD(v283));
                        goto LABEL_368;
                      }
                    }
                    else
                    {
                      float v285 = 1.0;
                    }
                    float v286 = v66;
                    float v287 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v31)), v285, v284, v283);
                    int v53 = v426;
                    float v284 = v287;
                    if (!v426)
                    {
                      *uint64_t v31 = bswap32(LODWORD(v287));
                      uint64_t v66 = v286;
                      uint64_t v4 = v420;
                      goto LABEL_368;
                    }
                    float v283 = v288;
                    uint64_t v66 = v286;
                    uint64_t v4 = v420;
                    goto LABEL_366;
                  }
                }
LABEL_368:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v278 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v279) {
                  goto LABEL_385;
                }
              }
            case 21:
              uint64_t v418 = v30;
              uint64_t v419 = v37;
              float v289 = (float *)v47 + 1;
              int v290 = v4;
              uint64_t v224 = v40;
              while (1)
              {
                unsigned int v291 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v292 = *v224 * v291 + ((*v224 * v291) >> 8) + 1;
                    if (!BYTE1(v292)) {
                      goto LABEL_384;
                    }
                    unsigned int v291 = v292 >> 8;
                  }
                  float v293 = (float)v291 * *((float *)v66 + 677);
                  float v294 = *v289 * v293;
                  if (v294 > 0.0)
                  {
                    float v295 = *(v289 - 1) * v293;
                    if (v53)
                    {
                      float v296 = COERCE_FLOAT(bswap32(*v27));
                      if (v296 <= 0.0)
                      {
LABEL_382:
                        *uint64_t v31 = bswap32(LODWORD(v295));
                        *uint64_t v27 = bswap32(LODWORD(v294));
                        goto LABEL_384;
                      }
                    }
                    else
                    {
                      float v296 = 1.0;
                    }
                    uint64_t v297 = v66;
                    float v298 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v31)), v296, v295, v294);
                    int v53 = v426;
                    float v295 = v298;
                    if (!v426)
                    {
                      *uint64_t v31 = bswap32(LODWORD(v298));
                      uint64_t v66 = v297;
                      uint64_t v4 = v420;
                      goto LABEL_384;
                    }
                    float v294 = v299;
                    uint64_t v66 = v297;
                    uint64_t v4 = v420;
                    goto LABEL_382;
                  }
                }
LABEL_384:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v289 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v290)
                {
LABEL_385:
                  uint64_t v40 = &v224[v421];
                  v31 += v422;
                  v27 += v424;
                  int v35 = v417;
                  char v36 = v416;
                  uint64_t v30 = v418;
                  uint64_t v37 = v419;
                  goto LABEL_501;
                }
              }
            case 22:
              uint64_t v300 = (float *)v47 + 1;
              int v301 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v302 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v303 = *v69 * v302 + ((*v69 * v302) >> 8) + 1;
                    if (!BYTE1(v303)) {
                      goto LABEL_402;
                    }
                    unsigned int v302 = v303 >> 8;
                  }
                  float v304 = (float)v302 * 0.0039216;
                  float v305 = *v300 * v304;
                  if (v305 > 0.0)
                  {
                    float v306 = *(v300 - 1) * v304;
                    if (v53)
                    {
                      float v307 = COERCE_FLOAT(bswap32(*v27));
                      if (v307 <= 0.0)
                      {
LABEL_400:
                        *uint64_t v31 = bswap32(LODWORD(v306));
                        *uint64_t v27 = bswap32(LODWORD(v305));
                        goto LABEL_402;
                      }
                    }
                    else
                    {
                      float v307 = 1.0;
                    }
                    float v308 = COERCE_FLOAT(bswap32(*v31));
                    float v309 = v306 + v308;
                    float v310 = v306 * v307;
                    float v311 = (float)(v305 * v308) - v310;
                    float v312 = (float)(v309 - (float)(v305 * v308)) - v310;
                    if (v311 < 0.0) {
                      float v311 = -v311;
                    }
                    float v306 = v312 + v311;
                    if (!v53)
                    {
                      *uint64_t v31 = bswap32(LODWORD(v306));
                      goto LABEL_402;
                    }
                    float v305 = (float)(v305 + v307) - (float)(v307 * v305);
                    goto LABEL_400;
                  }
                }
LABEL_402:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v300 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v301) {
                  goto LABEL_499;
                }
              }
            case 23:
              float v313 = (float *)v47 + 1;
              int v314 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v315 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v316 = *v69 * v315 + ((*v69 * v315) >> 8) + 1;
                    if (!BYTE1(v316)) {
                      goto LABEL_418;
                    }
                    unsigned int v315 = v316 >> 8;
                  }
                  float v317 = (float)v315 * 0.0039216;
                  float v318 = *v313 * v317;
                  if (v318 > 0.0)
                  {
                    float v319 = *(v313 - 1) * v317;
                    if (v53)
                    {
                      float v320 = COERCE_FLOAT(bswap32(*v27));
                      if (v320 <= 0.0)
                      {
LABEL_416:
                        *uint64_t v31 = bswap32(LODWORD(v319));
                        *uint64_t v27 = bswap32(LODWORD(v318));
                        goto LABEL_418;
                      }
                    }
                    else
                    {
                      float v320 = 1.0;
                    }
                    float v321 = COERCE_FLOAT(bswap32(*v31));
                    float v319 = (float)(v319 + v321) + (float)((float)(v319 * v321) * -2.0);
                    if (!v53)
                    {
                      *uint64_t v31 = bswap32(LODWORD(v319));
                      goto LABEL_418;
                    }
                    float v318 = (float)(v318 + v320) - (float)(v320 * v318);
                    goto LABEL_416;
                  }
                }
LABEL_418:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v313 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v314) {
                  goto LABEL_499;
                }
              }
            case 24:
              int v322 = (float *)v47 + 1;
              int v323 = v4;
              uint64_t v69 = v40;
              while (1)
              {
                unsigned int v324 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v325 = *v69 * v324 + ((*v69 * v324) >> 8) + 1;
                    if (!BYTE1(v325)) {
                      goto LABEL_438;
                    }
                    unsigned int v324 = v325 >> 8;
                  }
                  float v326 = (float)v324 * 0.0039216;
                  float v327 = *v322 * v326;
                  if (v327 > 0.0)
                  {
                    float v328 = *(v322 - 1) * v326;
                    float v329 = 1.0;
                    if (!v53 || (float v329 = COERCE_FLOAT(bswap32(*v27)), v329 > 0.0))
                    {
                      float v330 = COERCE_FLOAT(bswap32(*v31));
                      float v331 = v330;
                      if (v327 != 1.0) {
                        float v331 = v327 * v330;
                      }
                      float v332 = 0.0;
                      if (v327 != 1.0) {
                        float v332 = v330 - (float)(v327 * v330);
                      }
                      float v333 = (float)(v328 + v332) - (float)(v328 * v329);
                      if (v329 == 1.0) {
                        float v333 = v332;
                      }
                      float v328 = v331 + v333;
                      if (!v53)
                      {
                        *uint64_t v31 = bswap32(LODWORD(v328));
                        goto LABEL_438;
                      }
                      float v327 = (float)(v327 + v329) - (float)(v327 * v329);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v328));
                    *uint64_t v27 = bswap32(LODWORD(v327));
                  }
                }
LABEL_438:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v322 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v323) {
                  goto LABEL_499;
                }
              }
            case 25:
              int v334 = (float *)v47 + 1;
              uint64_t v69 = v40;
              int v335 = v4;
              while (1)
              {
                unsigned int v336 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v337 = *v69 * v336 + ((*v69 * v336) >> 8) + 1;
                    if (!BYTE1(v337)) {
                      goto LABEL_458;
                    }
                    unsigned int v336 = v337 >> 8;
                  }
                  float v338 = (float)v336 * 0.0039216;
                  float v339 = *v334 * v338;
                  if (v339 > 0.0)
                  {
                    float v340 = *(v334 - 1) * v338;
                    float v341 = 1.0;
                    if (!v53 || (float v341 = COERCE_FLOAT(bswap32(*v27)), v341 > 0.0))
                    {
                      float v342 = COERCE_FLOAT(bswap32(*v31));
                      float v343 = v342;
                      if (v339 != 1.0) {
                        float v343 = v339 * v342;
                      }
                      float v344 = 0.0;
                      if (v339 != 1.0) {
                        float v344 = v342 - (float)(v339 * v342);
                      }
                      float v345 = (float)(v340 + v344) - (float)(v340 * v341);
                      if (v341 == 1.0) {
                        float v345 = v344;
                      }
                      float v340 = v343 + v345;
                      if (!v53)
                      {
                        *uint64_t v31 = bswap32(LODWORD(v340));
                        goto LABEL_458;
                      }
                      float v339 = (float)(v339 + v341) - (float)(v339 * v341);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v340));
                    *uint64_t v27 = bswap32(LODWORD(v339));
                  }
                }
LABEL_458:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v334 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v335) {
                  goto LABEL_499;
                }
              }
            case 26:
              int v346 = (float *)v47 + 1;
              uint64_t v69 = v40;
              int v347 = v4;
              while (1)
              {
                unsigned int v348 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    unsigned int v349 = *v69 * v348 + ((*v69 * v348) >> 8) + 1;
                    if (!BYTE1(v349)) {
                      goto LABEL_479;
                    }
                    unsigned int v348 = v349 >> 8;
                  }
                  float v350 = (float)v348 * 0.0039216;
                  float v351 = *v346 * v350;
                  if (v351 > 0.0)
                  {
                    float v352 = *(v346 - 1) * v350;
                    float v353 = 1.0;
                    if (!v53 || (float v353 = COERCE_FLOAT(bswap32(*v27)), v353 > 0.0))
                    {
                      float v354 = COERCE_FLOAT(bswap32(*v31));
                      float v355 = v352 - (float)(v352 * v353);
                      if (v353 == 1.0) {
                        float v355 = 0.0;
                      }
                      if (v351 == 1.0) {
                        float v356 = v354;
                      }
                      else {
                        float v356 = v351 * v354;
                      }
                      if (v351 != 1.0) {
                        float v355 = (float)(v355 + v354) - (float)(v351 * v354);
                      }
                      float v352 = v356 + v355;
                      if (!v53)
                      {
                        *uint64_t v31 = bswap32(LODWORD(v352));
                        goto LABEL_479;
                      }
                      float v351 = (float)(v351 + v353) - (float)(v351 * v353);
                    }
                    *uint64_t v31 = bswap32(LODWORD(v352));
                    *uint64_t v27 = bswap32(LODWORD(v351));
                  }
                }
LABEL_479:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v346 += 2;
                uint64_t v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v347) {
                  goto LABEL_499;
                }
              }
            case 27:
              uint64_t v357 = (float *)v47 + 1;
              uint64_t v69 = v40;
              int v358 = v4;
              break;
            default:
              goto LABEL_501;
          }
          while (2)
          {
            unsigned int v359 = *v48;
            if (*v48)
            {
              if (!v40) {
                goto LABEL_486;
              }
              unsigned int v360 = *v69 * v359 + ((*v69 * v359) >> 8) + 1;
              if (BYTE1(v360))
              {
                unsigned int v359 = v360 >> 8;
LABEL_486:
                float v361 = (float)v359 * 0.0039216;
                float v362 = *v357 * v361;
                if (v362 > 0.0)
                {
                  float v363 = *(v357 - 1) * v361;
                  float v364 = 1.0;
                  if (v53 && (float v364 = COERCE_FLOAT(bswap32(*v27)), v364 <= 0.0))
                  {
LABEL_496:
                    *uint64_t v31 = bswap32(LODWORD(v363));
                    *uint64_t v27 = bswap32(LODWORD(v362));
                  }
                  else
                  {
                    float v365 = COERCE_FLOAT(bswap32(*v31));
                    float v366 = v365 - (float)(v362 * v365);
                    if (v362 == 1.0) {
                      float v366 = 0.0;
                    }
                    float v367 = (float)(v363 + v366) - (float)(v363 * v364);
                    if (v364 == 1.0)
                    {
                      float v368 = v366;
                    }
                    else
                    {
                      float v363 = v363 * v364;
                      float v368 = v367;
                    }
                    float v363 = v363 + v368;
                    if (v53)
                    {
                      float v362 = (float)(v362 + v364) - (float)(v362 * v364);
                      goto LABEL_496;
                    }
                    *uint64_t v31 = bswap32(LODWORD(v363));
                  }
                }
              }
            }
            ++v48;
            v69 += v40 != 0;
            ++v31;
            v357 += 2;
            uint64_t v27 = (unsigned int *)((char *)v27 + v45);
            if (!--v358)
            {
LABEL_499:
              uint64_t v40 = &v69[v421];
              goto LABEL_500;
            }
            continue;
          }
        }
        int v409 = shape_enum_clip_scan((uint64_t)v38, (_DWORD *)v40 - 4);
        int v42 = v428;
        if (!v409) {
          goto LABEL_594;
        }
      }
      v427 -= v408;
      if (v427 < 1)
      {
LABEL_594:
        if (v38) {
          free(v38);
        }
        goto LABEL_596;
      }
      v30 += v36[16] * v408;
      v419 += v36[17] * v408;
      v31 += v411 * v408;
      uint64_t v410 = v406 * v408;
      if (!v426) {
        uint64_t v410 = 0;
      }
      v27 += v410;
      int v42 = v407;
    }
  }
}

uint64_t WF_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  unint64_t v7 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v8 = (unsigned int *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v112 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v112 = 0;
  }
  float v9 = *((float *)a2 + 2);
  int v10 = a2[1];
  int v111 = *a2;
  uint64_t v110 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v109 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v109 * a4;
  size_t v15 = *(unsigned int **)(a1 + 32);
  uint64_t v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 4 * (v8 != 0);
  if (v17)
  {
    uint64_t v108 = *((void *)a2 + 13);
    uint64_t v107 = *((void *)a2 + 15);
    char v19 = 32 - v10;
    float v20 = v9 * 0.3;
    float v21 = v9 * 0.59;
    float v22 = v9 * 0.11;
    uint64_t v106 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v107 - v14) | (v14 - v108)) < 0)
      {
        int v25 = 0;
        uint64_t v24 = 0;
      }
      else
      {
        unint64_t v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        if (v23 - 7 >= 9) {
          uint64_t v24 = -v12;
        }
        else {
          uint64_t v24 = v12;
        }
        int v25 = weights_21383[v23] & 0xF;
      }
      unint64_t v26 = (char *)v15 + (v14 >> v13) * v12;
      if (v111 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v27 = (uint64_t *)v106;
          uint64_t v28 = a5;
          do
          {
            uint64_t v29 = *(v27 - 1);
            uint64_t v30 = *v27;
            uint64_t v31 = &v26[v29];
            if (v16 >= (unsigned int *)&v26[v29]) {
              uint64_t v32 = (unsigned int *)&v26[v29];
            }
            else {
              uint64_t v32 = v16;
            }
            if (v15 > v32) {
              uint64_t v32 = v15;
            }
            unsigned int v33 = *v32;
            if ((v30 & 0xF) != 0)
            {
              int v34 = (unsigned int *)&v31[v30 >> 4];
              if (v16 < v34) {
                int v34 = v16;
              }
              if (v15 > v34) {
                int v34 = v15;
              }
              unsigned int v35 = *v34;
              if (v25)
              {
                char v36 = (unsigned int *)&v31[v24];
                if (v16 >= v36) {
                  uint64_t v37 = v36;
                }
                else {
                  uint64_t v37 = v16;
                }
                if (v15 > v37) {
                  uint64_t v37 = v15;
                }
                unsigned int v38 = *v37;
                uint64_t v39 = (unsigned int *)((char *)v36 + (v30 >> 4));
                if (v16 < v39) {
                  uint64_t v39 = v16;
                }
                if (v15 > v39) {
                  uint64_t v39 = v15;
                }
                unsigned int v40 = BLEND8_21385[v25];
                unsigned int v33 = v33 - ((v40 & v33) >> v25) + ((v40 & v38) >> v25);
                unsigned int v35 = v35 - ((v40 & v35) >> v25) + ((v40 & *v39) >> v25);
              }
              unsigned int v33 = v33
                  - ((BLEND8_21385[*v27 & 0xF] & v33) >> (*v27 & 0xF))
                  + ((BLEND8_21385[*v27 & 0xF] & v35) >> (*v27 & 0xF));
            }
            else if (v25)
            {
              int v41 = (unsigned int *)&v31[v24];
              if (v16 < (unsigned int *)&v31[v24]) {
                int v41 = v16;
              }
              if (v15 > v41) {
                int v41 = v15;
              }
              unsigned int v33 = v33 - ((BLEND8_21385[v25] & v33) >> v25) + ((BLEND8_21385[v25] & *v41) >> v25);
            }
            unsigned int v42 = __ROL4__(v33, v10);
            float v43 = *(float *)&_blt_float[HIBYTE(v42)];
            float v44 = *(float *)&_blt_float[BYTE2(v42)];
            float v45 = *(float *)&_blt_float[BYTE1(v42)];
            float v46 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
            if (v9 >= 1.0)
            {
              float v47 = v43 * 0.3;
              float v48 = v44 * 0.59;
              float v49 = v45 * 0.11;
            }
            else
            {
              float v47 = v20 * v43;
              float v48 = v21 * v44;
              float v49 = v22 * v45;
              float v46 = v9 * v46;
            }
            *unint64_t v7 = bswap32(COERCE_UNSIGNED_INT((float)(v47 + v48) + v49));
            if (v8) {
              *uint64_t v8 = bswap32(LODWORD(v46));
            }
            v27 += 2;
            ++v7;
            uint64_t v8 = (unsigned int *)((char *)v8 + result);
            --v28;
          }
          while (v28);
        }
        goto LABEL_97;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_97:
      v7 += v110;
      v14 += v109;
      v8 += v112;
      if (!--a6) {
        return result;
      }
    }
    int v51 = (uint64_t *)v106;
    uint64_t v50 = a5;
    while (1)
    {
      uint64_t v52 = *(v51 - 1);
      uint64_t v53 = *v51;
      uint64_t v54 = &v26[v52];
      if (v16 >= (unsigned int *)&v26[v52]) {
        int v55 = (unsigned int *)&v26[v52];
      }
      else {
        int v55 = v16;
      }
      if (v15 > v55) {
        int v55 = v15;
      }
      unsigned int v56 = *v55;
      if ((v53 & 0xF) != 0)
      {
        BOOL v57 = (unsigned int *)&v54[v53 >> 4];
        if (v16 < v57) {
          BOOL v57 = v16;
        }
        if (v15 > v57) {
          BOOL v57 = v15;
        }
        unsigned int v58 = *v57;
        if (v25)
        {
          uint64_t v59 = (unsigned int *)&v54[v24];
          if (v16 >= v59) {
            unint64_t v60 = v59;
          }
          else {
            unint64_t v60 = v16;
          }
          if (v15 > v60) {
            unint64_t v60 = v15;
          }
          unsigned int v61 = *v60;
          unint64_t v62 = (unsigned int *)((char *)v59 + (v53 >> 4));
          if (v16 < v62) {
            unint64_t v62 = v16;
          }
          if (v15 > v62) {
            unint64_t v62 = v15;
          }
          unsigned int v63 = BLEND8_21385[v25];
          unsigned int v56 = v56 - ((v63 & v56) >> v25) + ((v63 & v61) >> v25);
          unsigned int v58 = v58 - ((v63 & v58) >> v25) + ((v63 & *v62) >> v25);
        }
        unsigned int v56 = v56
            - ((BLEND8_21385[*v51 & 0xF] & v56) >> (*v51 & 0xF))
            + ((BLEND8_21385[*v51 & 0xF] & v58) >> (*v51 & 0xF));
      }
      else if (v25)
      {
        unint64_t v64 = (unsigned int *)&v54[v24];
        if (v16 < (unsigned int *)&v54[v24]) {
          unint64_t v64 = v16;
        }
        if (v15 > v64) {
          unint64_t v64 = v15;
        }
        unsigned int v56 = v56 - ((BLEND8_21385[v25] & v56) >> v25) + ((BLEND8_21385[v25] & *v64) >> v25);
      }
      unsigned int v65 = __ROL4__(v56, v10);
      float v66 = *(float *)&_blt_float[HIBYTE(v65)];
      float v67 = *(float *)&_blt_float[BYTE2(v65)];
      float v68 = *(float *)&_blt_float[BYTE1(v65)];
      float v69 = *(float *)&_blt_float[(((_BYTE)v56 << v10) | (v56 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        float v70 = v66 * 0.3;
        float v71 = v67 * 0.59;
        float v72 = v68 * 0.11;
      }
      else
      {
        float v70 = v20 * v66;
        float v71 = v21 * v67;
        float v72 = v22 * v68;
        float v69 = v9 * v69;
      }
      float v73 = (float)(v70 + v71) + v72;
      if (v8)
      {
        if (v69 >= 1.0) {
          goto LABEL_90;
        }
        if (v69 > 0.0)
        {
          float v73 = v73 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v69));
          float v69 = v69 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v69));
LABEL_90:
          *unint64_t v7 = bswap32(LODWORD(v73));
          *uint64_t v8 = bswap32(LODWORD(v69));
        }
      }
      else
      {
        if (v69 >= 1.0)
        {
          float v74 = v73;
LABEL_95:
          *unint64_t v7 = bswap32(LODWORD(v74));
          goto LABEL_96;
        }
        if (v69 > 0.0)
        {
          float v74 = v73 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v69));
          goto LABEL_95;
        }
      }
LABEL_96:
      v51 += 2;
      ++v7;
      uint64_t v8 = (unsigned int *)((char *)v8 + result);
      if (!--v50) {
        goto LABEL_97;
      }
    }
  }
  int v75 = (uint64_t *)(v11 + 16 * a3);
  float v76 = v9 * 0.3;
  float v77 = v9 * 0.59;
  float v78 = v9 * 0.11;
  do
  {
    int v79 = (char *)v15 + (v14 >> v13) * v12;
    if (v111 != 1)
    {
      float v92 = v75;
      uint64_t v93 = a5;
      if (a5 < 1) {
        goto LABEL_133;
      }
      while (1)
      {
        uint64_t v94 = *v92;
        v92 += 2;
        unsigned int v95 = (unsigned int *)&v79[v94];
        if (v16 < (unsigned int *)&v79[v94]) {
          unsigned int v95 = v16;
        }
        if (v15 > v95) {
          unsigned int v95 = v15;
        }
        unsigned int v96 = __ROL4__(*v95, v10);
        float v97 = *(float *)&_blt_float[HIBYTE(v96)];
        float v98 = *(float *)&_blt_float[BYTE2(v96)];
        float v99 = *(float *)&_blt_float[BYTE1(v96)];
        float v100 = *(float *)&_blt_float[v96 | v6];
        if (v9 >= 1.0)
        {
          float v101 = v97 * 0.3;
          float v102 = v98 * 0.59;
          float v103 = v99 * 0.11;
        }
        else
        {
          float v101 = v76 * v97;
          float v102 = v77 * v98;
          float v103 = v78 * v99;
          float v100 = v9 * v100;
        }
        float v104 = (float)(v101 + v102) + v103;
        if (v8)
        {
          if (v100 >= 1.0) {
            goto LABEL_126;
          }
          if (v100 > 0.0)
          {
            float v104 = v104 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v100));
            float v100 = v100 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v100));
LABEL_126:
            *unint64_t v7 = bswap32(LODWORD(v104));
            *uint64_t v8 = bswap32(LODWORD(v100));
          }
        }
        else
        {
          if (v100 >= 1.0)
          {
            float v105 = v104;
LABEL_131:
            *unint64_t v7 = bswap32(LODWORD(v105));
            goto LABEL_132;
          }
          if (v100 > 0.0)
          {
            float v105 = v104 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v100));
            goto LABEL_131;
          }
        }
LABEL_132:
        ++v7;
        uint64_t v8 = (unsigned int *)((char *)v8 + result);
        if (!--v93) {
          goto LABEL_133;
        }
      }
    }
    if (a5 >= 1)
    {
      unsigned int v80 = v75;
      uint64_t v81 = a5;
      do
      {
        uint64_t v82 = *v80;
        v80 += 2;
        float v83 = (unsigned int *)&v79[v82];
        if (v16 < (unsigned int *)&v79[v82]) {
          float v83 = v16;
        }
        if (v15 > v83) {
          float v83 = v15;
        }
        unsigned int v84 = __ROL4__(*v83, v10);
        float v85 = *(float *)&_blt_float[HIBYTE(v84)];
        float v86 = *(float *)&_blt_float[BYTE2(v84)];
        float v87 = *(float *)&_blt_float[BYTE1(v84)];
        float v88 = *(float *)&_blt_float[v84 | v6];
        if (v9 >= 1.0)
        {
          float v89 = v85 * 0.3;
          float v90 = v86 * 0.59;
          float v91 = v87 * 0.11;
        }
        else
        {
          float v89 = v76 * v85;
          float v90 = v77 * v86;
          float v91 = v78 * v87;
          float v88 = v9 * v88;
        }
        *unint64_t v7 = bswap32(COERCE_UNSIGNED_INT((float)(v89 + v90) + v91));
        if (v8) {
          *uint64_t v8 = bswap32(LODWORD(v88));
        }
        ++v7;
        uint64_t v8 = (unsigned int *)((char *)v8 + result);
        --v81;
      }
      while (v81);
    }
LABEL_133:
    v7 += v110;
    v14 += v109;
    v8 += v112;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t WF_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  unint64_t v7 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v8 = (unsigned int *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v111 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v111 = 0;
  }
  float v9 = *((float *)a2 + 2);
  int v10 = a2[1];
  int v110 = *a2;
  uint64_t v109 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v108 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v108 * a4;
  size_t v15 = *(unsigned int **)(a1 + 32);
  uint64_t v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 4 * (v8 != 0);
  if (v17)
  {
    uint64_t v107 = *((void *)a2 + 13);
    uint64_t v106 = *((void *)a2 + 15);
    char v19 = 32 - v10;
    float v20 = v9 * 0.3;
    float v21 = v9 * 0.59;
    float v22 = v9 * 0.11;
    uint64_t v105 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v106 - v14) | (v14 - v107)) < 0)
      {
        int v25 = 0;
        uint64_t v24 = 0;
      }
      else
      {
        unint64_t v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        if (v23 - 7 >= 9) {
          uint64_t v24 = -v12;
        }
        else {
          uint64_t v24 = v12;
        }
        int v25 = weights_21383[v23] & 0xF;
      }
      unint64_t v26 = (char *)v15 + (v14 >> v13) * v12;
      if (v110 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v27 = (uint64_t *)v105;
          uint64_t v28 = a5;
          do
          {
            uint64_t v29 = *(v27 - 1);
            uint64_t v30 = *v27;
            uint64_t v31 = &v26[v29];
            if (v16 >= (unsigned int *)&v26[v29]) {
              uint64_t v32 = (unsigned int *)&v26[v29];
            }
            else {
              uint64_t v32 = v16;
            }
            if (v15 > v32) {
              uint64_t v32 = v15;
            }
            unsigned int v33 = bswap32(*v32);
            if ((v30 & 0xF) != 0)
            {
              int v34 = (unsigned int *)&v31[v30 >> 4];
              if (v16 < v34) {
                int v34 = v16;
              }
              if (v15 > v34) {
                int v34 = v15;
              }
              unsigned int v35 = bswap32(*v34);
              if (v25)
              {
                char v36 = (unsigned int *)&v31[v24];
                if (v16 >= v36) {
                  uint64_t v37 = v36;
                }
                else {
                  uint64_t v37 = v16;
                }
                if (v15 > v37) {
                  uint64_t v37 = v15;
                }
                unsigned int v38 = bswap32(*v37);
                uint64_t v39 = (unsigned int *)((char *)v36 + (v30 >> 4));
                if (v16 < v39) {
                  uint64_t v39 = v16;
                }
                if (v15 > v39) {
                  uint64_t v39 = v15;
                }
                int v40 = BLEND8_21385[v25];
                unsigned int v33 = v33 - ((v40 & v33) >> v25) + ((v40 & v38) >> v25);
                unsigned int v35 = v35 - ((v40 & v35) >> v25) + ((bswap32(*v39) & v40) >> v25);
              }
              unsigned int v33 = v33
                  - ((BLEND8_21385[*v27 & 0xF] & v33) >> (*v27 & 0xF))
                  + ((BLEND8_21385[*v27 & 0xF] & v35) >> (*v27 & 0xF));
            }
            else if (v25)
            {
              int v41 = (unsigned int *)&v31[v24];
              if (v16 < (unsigned int *)&v31[v24]) {
                int v41 = v16;
              }
              if (v15 > v41) {
                int v41 = v15;
              }
              unsigned int v33 = v33 - ((BLEND8_21385[v25] & v33) >> v25) + ((bswap32(*v41) & BLEND8_21385[v25]) >> v25);
            }
            unsigned int v42 = __ROL4__(v33, v10);
            float v43 = *(float *)&_blt_float[HIBYTE(v42)];
            float v44 = *(float *)&_blt_float[BYTE2(v42)];
            float v45 = *(float *)&_blt_float[BYTE1(v42)];
            float v46 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
            if (v9 >= 1.0)
            {
              float v47 = v43 * 0.3;
              float v48 = v44 * 0.59;
              float v49 = v45 * 0.11;
            }
            else
            {
              float v47 = v20 * v43;
              float v48 = v21 * v44;
              float v49 = v22 * v45;
              float v46 = v9 * v46;
            }
            *unint64_t v7 = bswap32(COERCE_UNSIGNED_INT((float)(v47 + v48) + v49));
            if (v8) {
              *uint64_t v8 = bswap32(LODWORD(v46));
            }
            v27 += 2;
            ++v7;
            uint64_t v8 = (unsigned int *)((char *)v8 + result);
            --v28;
          }
          while (v28);
        }
        goto LABEL_97;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_97:
      v7 += v109;
      v14 += v108;
      v8 += v111;
      if (!--a6) {
        return result;
      }
    }
    int v51 = (uint64_t *)v105;
    uint64_t v50 = a5;
    while (1)
    {
      uint64_t v52 = *(v51 - 1);
      uint64_t v53 = *v51;
      uint64_t v54 = &v26[v52];
      if (v16 >= (unsigned int *)&v26[v52]) {
        int v55 = (unsigned int *)&v26[v52];
      }
      else {
        int v55 = v16;
      }
      if (v15 > v55) {
        int v55 = v15;
      }
      unsigned int v56 = bswap32(*v55);
      if ((v53 & 0xF) != 0)
      {
        BOOL v57 = (unsigned int *)&v54[v53 >> 4];
        if (v16 < v57) {
          BOOL v57 = v16;
        }
        if (v15 > v57) {
          BOOL v57 = v15;
        }
        unsigned int v58 = bswap32(*v57);
        if (v25)
        {
          if (v16 >= (unsigned int *)&v54[v24]) {
            uint64_t v59 = (unsigned int *)&v54[v24];
          }
          else {
            uint64_t v59 = v16;
          }
          if (v15 > v59) {
            uint64_t v59 = v15;
          }
          unsigned int v60 = bswap32(*v59);
          unsigned int v61 = (unsigned int *)&v54[v24 + (v53 >> 4)];
          if (v16 < v61) {
            unsigned int v61 = v16;
          }
          if (v15 > v61) {
            unsigned int v61 = v15;
          }
          int v62 = BLEND8_21385[v25];
          unsigned int v56 = v56 - ((v62 & v56) >> v25) + ((v62 & v60) >> v25);
          unsigned int v58 = v58 - ((v62 & v58) >> v25) + ((bswap32(*v61) & v62) >> v25);
        }
        unsigned int v56 = v56
            - ((BLEND8_21385[*v51 & 0xF] & v56) >> (*v51 & 0xF))
            + ((BLEND8_21385[*v51 & 0xF] & v58) >> (*v51 & 0xF));
      }
      else if (v25)
      {
        unsigned int v63 = (unsigned int *)&v54[v24];
        if (v16 < (unsigned int *)&v54[v24]) {
          unsigned int v63 = v16;
        }
        if (v15 > v63) {
          unsigned int v63 = v15;
        }
        unsigned int v56 = v56 - ((BLEND8_21385[v25] & v56) >> v25) + ((bswap32(*v63) & BLEND8_21385[v25]) >> v25);
      }
      unsigned int v64 = __ROL4__(v56, v10);
      float v65 = *(float *)&_blt_float[HIBYTE(v64)];
      float v66 = *(float *)&_blt_float[BYTE2(v64)];
      float v67 = *(float *)&_blt_float[BYTE1(v64)];
      float v68 = *(float *)&_blt_float[(((_BYTE)v56 << v10) | (v56 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        float v69 = v65 * 0.3;
        float v70 = v66 * 0.59;
        float v71 = v67 * 0.11;
      }
      else
      {
        float v69 = v20 * v65;
        float v70 = v21 * v66;
        float v71 = v22 * v67;
        float v68 = v9 * v68;
      }
      float v72 = (float)(v69 + v70) + v71;
      if (v8)
      {
        if (v68 >= 1.0) {
          goto LABEL_90;
        }
        if (v68 > 0.0)
        {
          float v72 = v72 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v68));
          float v68 = v68 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v68));
LABEL_90:
          *unint64_t v7 = bswap32(LODWORD(v72));
          *uint64_t v8 = bswap32(LODWORD(v68));
        }
      }
      else
      {
        if (v68 >= 1.0)
        {
          float v73 = v72;
LABEL_95:
          *unint64_t v7 = bswap32(LODWORD(v73));
          goto LABEL_96;
        }
        if (v68 > 0.0)
        {
          float v73 = v72 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v68));
          goto LABEL_95;
        }
      }
LABEL_96:
      v51 += 2;
      ++v7;
      uint64_t v8 = (unsigned int *)((char *)v8 + result);
      if (!--v50) {
        goto LABEL_97;
      }
    }
  }
  float v74 = (uint64_t *)(v11 + 16 * a3);
  float v75 = v9 * 0.3;
  float v76 = v9 * 0.59;
  float v77 = v9 * 0.11;
  do
  {
    float v78 = (char *)v15 + (v14 >> v13) * v12;
    if (v110 != 1)
    {
      float v91 = v74;
      uint64_t v92 = a5;
      if (a5 < 1) {
        goto LABEL_133;
      }
      while (1)
      {
        uint64_t v93 = *v91;
        v91 += 2;
        uint64_t v94 = (unsigned int *)&v78[v93];
        if (v16 < (unsigned int *)&v78[v93]) {
          uint64_t v94 = v16;
        }
        if (v15 > v94) {
          uint64_t v94 = v15;
        }
        unsigned int v95 = __ROL4__(bswap32(*v94), v10);
        float v96 = *(float *)&_blt_float[HIBYTE(v95)];
        float v97 = *(float *)&_blt_float[BYTE2(v95)];
        float v98 = *(float *)&_blt_float[BYTE1(v95)];
        float v99 = *(float *)&_blt_float[v95 | v6];
        if (v9 >= 1.0)
        {
          float v100 = v96 * 0.3;
          float v101 = v97 * 0.59;
          float v102 = v98 * 0.11;
        }
        else
        {
          float v100 = v75 * v96;
          float v101 = v76 * v97;
          float v102 = v77 * v98;
          float v99 = v9 * v99;
        }
        float v103 = (float)(v100 + v101) + v102;
        if (v8)
        {
          if (v99 >= 1.0) {
            goto LABEL_126;
          }
          if (v99 > 0.0)
          {
            float v103 = v103 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v99));
            float v99 = v99 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v99));
LABEL_126:
            *unint64_t v7 = bswap32(LODWORD(v103));
            *uint64_t v8 = bswap32(LODWORD(v99));
          }
        }
        else
        {
          if (v99 >= 1.0)
          {
            float v104 = v103;
LABEL_131:
            *unint64_t v7 = bswap32(LODWORD(v104));
            goto LABEL_132;
          }
          if (v99 > 0.0)
          {
            float v104 = v103 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v99));
            goto LABEL_131;
          }
        }
LABEL_132:
        ++v7;
        uint64_t v8 = (unsigned int *)((char *)v8 + result);
        if (!--v92) {
          goto LABEL_133;
        }
      }
    }
    if (a5 >= 1)
    {
      int v79 = v74;
      uint64_t v80 = a5;
      do
      {
        uint64_t v81 = *v79;
        v79 += 2;
        uint64_t v82 = (unsigned int *)&v78[v81];
        if (v16 < (unsigned int *)&v78[v81]) {
          uint64_t v82 = v16;
        }
        if (v15 > v82) {
          uint64_t v82 = v15;
        }
        unsigned int v83 = __ROL4__(bswap32(*v82), v10);
        float v84 = *(float *)&_blt_float[HIBYTE(v83)];
        float v85 = *(float *)&_blt_float[BYTE2(v83)];
        float v86 = *(float *)&_blt_float[BYTE1(v83)];
        float v87 = *(float *)&_blt_float[v83 | v6];
        if (v9 >= 1.0)
        {
          float v88 = v84 * 0.3;
          float v89 = v85 * 0.59;
          float v90 = v86 * 0.11;
        }
        else
        {
          float v88 = v75 * v84;
          float v89 = v76 * v85;
          float v90 = v77 * v86;
          float v87 = v9 * v87;
        }
        *unint64_t v7 = bswap32(COERCE_UNSIGNED_INT((float)(v88 + v89) + v90));
        if (v8) {
          *uint64_t v8 = bswap32(LODWORD(v87));
        }
        ++v7;
        uint64_t v8 = (unsigned int *)((char *)v8 + result);
        --v80;
      }
      while (v80);
    }
LABEL_133:
    v7 += v109;
    v14 += v108;
    v8 += v111;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t WF_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (unsigned int *)*((void *)a2 + 2);
  unint64_t v7 = (unsigned int *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v91 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v91 = 0;
  }
  float v8 = *((float *)a2 + 2);
  int v90 = *a2;
  uint64_t v9 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 17);
  uint64_t v10 = *((void *)a2 + 18);
  uint64_t v12 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v13 * a4;
  size_t v15 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 4 * (v7 != 0);
  if (v17)
  {
    uint64_t v88 = *((void *)a2 + 15);
    uint64_t v89 = *((void *)a2 + 13);
    float v19 = v8 * 0.3;
    float v20 = v8 * 0.59;
    float v21 = v8 * 0.11;
    uint64_t v87 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v88 - v14) | (v14 - v89)) < 0)
      {
        int v24 = 0;
        uint64_t v23 = 0;
      }
      else
      {
        unint64_t v22 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v22 - 7 >= 9) {
          uint64_t v23 = -v11;
        }
        else {
          uint64_t v23 = v11;
        }
        int v24 = weights_21383[v22] & 0xF;
      }
      int v25 = &v15[(v14 >> v12) * v11];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          unint64_t v26 = (uint64_t *)v87;
          uint64_t v27 = a5;
          do
          {
            uint64_t v28 = *(v26 - 1);
            uint64_t v29 = *v26;
            uint64_t v30 = &v25[v28];
            if (v16 >= &v25[v28]) {
              uint64_t v31 = &v25[v28];
            }
            else {
              uint64_t v31 = v16;
            }
            if (v15 > v31) {
              uint64_t v31 = v15;
            }
            unsigned int v32 = (*v31 << 24) | (v31[1] << 16) | (v31[2] << 8);
            if ((v29 & 0xF) != 0)
            {
              unsigned int v33 = &v30[v29 >> 4];
              if (v16 < v33) {
                unsigned int v33 = v16;
              }
              if (v15 > v33) {
                unsigned int v33 = v15;
              }
              int v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
              if (v24)
              {
                if (v16 >= &v30[v23]) {
                  unsigned int v35 = &v30[v23];
                }
                else {
                  unsigned int v35 = v16;
                }
                if (v15 > v35) {
                  unsigned int v35 = v15;
                }
                int v36 = (*v35 << 24) | (v35[1] << 16) | (v35[2] << 8);
                uint64_t v37 = &v30[v23 + (v29 >> 4)];
                if (v16 < v37) {
                  uint64_t v37 = v16;
                }
                if (v15 > v37) {
                  uint64_t v37 = v15;
                }
                unsigned int v38 = BLEND8_21385[v24];
                unsigned int v32 = v32 - ((v38 & v32) >> v24) + ((v38 & v36) >> v24);
                int v34 = v34 - ((v38 & v34) >> v24) + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v24);
              }
              unsigned int v32 = v32
                  - ((BLEND8_21385[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_21385[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v24)
            {
              uint64_t v39 = &v30[v23];
              if (v16 < &v30[v23]) {
                uint64_t v39 = v16;
              }
              if (v15 > v39) {
                uint64_t v39 = v15;
              }
              unsigned int v32 = v32
                  - ((BLEND8_21385[v24] & v32) >> v24)
                  + ((((*v39 << 24) | (v39[1] << 16) | (v39[2] << 8)) & BLEND8_21385[v24]) >> v24);
            }
            float v40 = *(float *)&_blt_float[HIBYTE(v32)];
            float v41 = *(float *)&_blt_float[BYTE2(v32)];
            float v42 = *(float *)&_blt_float[BYTE1(v32)];
            if (v8 >= 1.0)
            {
              float v43 = (float)((float)(v40 * 0.3) + (float)(v41 * 0.59)) + (float)(v42 * 0.11);
              unsigned int v44 = 1.0;
            }
            else
            {
              float v43 = (float)((float)(v19 * v40) + (float)(v20 * v41)) + (float)(v21 * v42);
              unsigned int v44 = LODWORD(v8);
            }
            *int v6 = bswap32(LODWORD(v43));
            if (v7) {
              *unint64_t v7 = bswap32(v44);
            }
            v26 += 2;
            ++v6;
            unint64_t v7 = (unsigned int *)((char *)v7 + result);
            --v27;
          }
          while (v27);
        }
        goto LABEL_93;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_93:
      v6 += v9;
      v14 += v13;
      v7 += v91;
      if (!--a6) {
        return result;
      }
    }
    float v46 = (uint64_t *)v87;
    uint64_t v45 = a5;
    while (1)
    {
      uint64_t v47 = *(v46 - 1);
      uint64_t v48 = *v46;
      float v49 = &v25[v47];
      if (v16 >= &v25[v47]) {
        uint64_t v50 = &v25[v47];
      }
      else {
        uint64_t v50 = v16;
      }
      if (v15 > v50) {
        uint64_t v50 = v15;
      }
      unsigned int v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      if ((v48 & 0xF) != 0)
      {
        uint64_t v52 = &v49[v48 >> 4];
        if (v16 < v52) {
          uint64_t v52 = v16;
        }
        if (v15 > v52) {
          uint64_t v52 = v15;
        }
        int v53 = (*v52 << 24) | (v52[1] << 16) | (v52[2] << 8);
        if (v24)
        {
          if (v16 >= &v49[v23]) {
            uint64_t v54 = &v49[v23];
          }
          else {
            uint64_t v54 = v16;
          }
          if (v15 > v54) {
            uint64_t v54 = v15;
          }
          int v55 = (*v54 << 24) | (v54[1] << 16) | (v54[2] << 8);
          unsigned int v56 = &v49[v23 + (v48 >> 4)];
          if (v16 < v56) {
            unsigned int v56 = v16;
          }
          if (v15 > v56) {
            unsigned int v56 = v15;
          }
          unsigned int v57 = BLEND8_21385[v24];
          unsigned int v51 = v51 - ((v57 & v51) >> v24) + ((v57 & v55) >> v24);
          int v53 = v53 - ((v57 & v53) >> v24) + ((((*v56 << 24) | (v56[1] << 16) | (v56[2] << 8)) & v57) >> v24);
        }
        unsigned int v51 = v51
            - ((BLEND8_21385[*v46 & 0xF] & v51) >> (*v46 & 0xF))
            + ((BLEND8_21385[*v46 & 0xF] & v53) >> (*v46 & 0xF));
      }
      else if (v24)
      {
        unsigned int v58 = &v49[v23];
        if (v16 < &v49[v23]) {
          unsigned int v58 = v16;
        }
        if (v15 > v58) {
          unsigned int v58 = v15;
        }
        unsigned int v51 = v51
            - ((BLEND8_21385[v24] & v51) >> v24)
            + ((((*v58 << 24) | (v58[1] << 16) | (v58[2] << 8)) & BLEND8_21385[v24]) >> v24);
      }
      float v59 = *(float *)&_blt_float[HIBYTE(v51)];
      float v60 = *(float *)&_blt_float[BYTE2(v51)];
      float v61 = *(float *)&_blt_float[BYTE1(v51)];
      if (v8 >= 1.0)
      {
        float v62 = (float)((float)(v59 * 0.3) + (float)(v60 * 0.59)) + (float)(v61 * 0.11);
        float v63 = 1.0;
      }
      else
      {
        float v62 = (float)((float)(v19 * v59) + (float)(v20 * v60)) + (float)(v21 * v61);
        float v63 = v8;
      }
      if (v7)
      {
        if (v63 >= 1.0) {
          goto LABEL_87;
        }
        if (v63 > 0.0)
        {
          float v62 = v62 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v63));
          float v63 = v63 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v63));
LABEL_87:
          *int v6 = bswap32(LODWORD(v62));
          *unint64_t v7 = bswap32(LODWORD(v63));
        }
      }
      else
      {
        if (v63 >= 1.0) {
          goto LABEL_91;
        }
        if (v63 > 0.0)
        {
          float v62 = v62 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v63));
LABEL_91:
          *int v6 = bswap32(LODWORD(v62));
        }
      }
      v46 += 2;
      ++v6;
      unint64_t v7 = (unsigned int *)((char *)v7 + result);
      if (!--v45) {
        goto LABEL_93;
      }
    }
  }
  unsigned int v64 = (uint64_t *)(v10 + 16 * a3);
  float v65 = v8 * 0.3;
  float v66 = v8 * 0.59;
  float v67 = v8 * 0.11;
  do
  {
    float v68 = &v15[(v14 >> v12) * v11];
    if (v90 != 1)
    {
      float v78 = v64;
      uint64_t v79 = a5;
      if (a5 < 1) {
        goto LABEL_128;
      }
      while (1)
      {
        uint64_t v80 = *v78;
        v78 += 2;
        uint64_t v81 = &v68[v80];
        if (v16 < &v68[v80]) {
          uint64_t v81 = v16;
        }
        if (v15 > v81) {
          uint64_t v81 = v15;
        }
        float v82 = *(float *)&_blt_float[*v81];
        float v83 = *(float *)&_blt_float[v81[1]];
        float v84 = *(float *)&_blt_float[v81[2]];
        if (v8 >= 1.0)
        {
          float v85 = (float)((float)(v82 * 0.3) + (float)(v83 * 0.59)) + (float)(v84 * 0.11);
          float v86 = 1.0;
        }
        else
        {
          float v85 = (float)((float)(v65 * v82) + (float)(v66 * v83)) + (float)(v67 * v84);
          float v86 = v8;
        }
        if (v7)
        {
          if (v86 >= 1.0) {
            goto LABEL_122;
          }
          if (v86 > 0.0)
          {
            float v85 = v85 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v86));
            float v86 = v86 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v86));
LABEL_122:
            *int v6 = bswap32(LODWORD(v85));
            *unint64_t v7 = bswap32(LODWORD(v86));
          }
        }
        else
        {
          if (v86 >= 1.0) {
            goto LABEL_126;
          }
          if (v86 > 0.0)
          {
            float v85 = v85 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v86));
LABEL_126:
            *int v6 = bswap32(LODWORD(v85));
          }
        }
        ++v6;
        unint64_t v7 = (unsigned int *)((char *)v7 + result);
        if (!--v79) {
          goto LABEL_128;
        }
      }
    }
    if (a5 >= 1)
    {
      float v69 = v64;
      uint64_t v70 = a5;
      do
      {
        uint64_t v71 = *v69;
        v69 += 2;
        float v72 = &v68[v71];
        if (v16 < &v68[v71]) {
          float v72 = v16;
        }
        if (v15 > v72) {
          float v72 = v15;
        }
        float v73 = *(float *)&_blt_float[*v72];
        float v74 = *(float *)&_blt_float[v72[1]];
        float v75 = *(float *)&_blt_float[v72[2]];
        if (v8 >= 1.0)
        {
          float v76 = (float)((float)(v73 * 0.3) + (float)(v74 * 0.59)) + (float)(v75 * 0.11);
          unsigned int v77 = 1.0;
        }
        else
        {
          float v76 = (float)((float)(v65 * v73) + (float)(v66 * v74)) + (float)(v67 * v75);
          unsigned int v77 = LODWORD(v8);
        }
        *int v6 = bswap32(LODWORD(v76));
        if (v7) {
          *unint64_t v7 = bswap32(v77);
        }
        ++v6;
        unint64_t v7 = (unsigned int *)((char *)v7 + result);
        --v70;
      }
      while (v70);
    }
LABEL_128:
    v6 += v9;
    v14 += v13;
    v7 += v91;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t WF_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (unsigned int *)*((void *)a2 + 2);
  unint64_t v7 = (unsigned int *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v74 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v74 = 0;
  }
  float v8 = *((float *)a2 + 2);
  int v73 = *a2;
  uint64_t v9 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v12 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v13 * a4;
  size_t v15 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v17 = 4 * (v7 != 0);
  if (*(void *)(a1 + 176))
  {
    uint64_t v71 = *((void *)a2 + 15);
    uint64_t v72 = *((void *)a2 + 13);
    float v18 = fminf(v8, 1.0);
    unsigned int v19 = bswap32(LODWORD(v18));
    float v20 = 1.0 - v18;
    uint64_t v70 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v71 - v14) | (v14 - v72)) < 0)
      {
        unsigned int v23 = 0;
        uint64_t v22 = 0;
      }
      else
      {
        unint64_t v21 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v21 - 7 >= 9) {
          uint64_t v22 = -v10;
        }
        else {
          uint64_t v22 = v10;
        }
        unsigned int v23 = weights_21383[v21] & 0xF;
      }
      uint64_t result = v14 >> v12;
      int v25 = &v15[(v14 >> v12) * v10];
      if (v73 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t result = v23;
          unint64_t v26 = (uint64_t *)v70;
          uint64_t v27 = a5;
          do
          {
            uint64_t v28 = *(v26 - 1);
            uint64_t v29 = *v26;
            uint64_t v30 = &v25[v28];
            if (v16 >= &v25[v28]) {
              uint64_t v31 = &v25[v28];
            }
            else {
              uint64_t v31 = v16;
            }
            if (v15 > v31) {
              uint64_t v31 = v15;
            }
            unsigned int v32 = *v31;
            if ((v29 & 0xF) != 0)
            {
              unsigned int v33 = &v30[v29 >> 4];
              if (v16 < v33) {
                unsigned int v33 = v16;
              }
              if (v15 > v33) {
                unsigned int v33 = v15;
              }
              unsigned int v34 = *v33;
              if (v23)
              {
                unsigned int v35 = &v30[v22];
                if (v16 >= v35) {
                  int v36 = v35;
                }
                else {
                  int v36 = v16;
                }
                if (v15 > v36) {
                  int v36 = v15;
                }
                unsigned int v37 = *v36;
                unsigned int v38 = &v35[v29 >> 4];
                if (v16 < v38) {
                  unsigned int v38 = v16;
                }
                if (v15 > v38) {
                  unsigned int v38 = v15;
                }
                int v39 = BLEND8_21385[v23];
                unsigned int v32 = v32 - ((v39 & v32) >> v23) + ((v39 & v37) >> v23);
                unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
              }
              unsigned int v32 = v32
                  - ((BLEND8_21385[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_21385[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v23)
            {
              float v40 = &v30[v22];
              if (v16 < &v30[v22]) {
                float v40 = v16;
              }
              if (v15 > v40) {
                float v40 = v15;
              }
              unsigned int v32 = v32 - ((BLEND8_21385[v23] & v32) >> v23) + ((BLEND8_21385[v23] & *v40) >> v23);
            }
            *int v6 = bswap32(COERCE_UNSIGNED_INT(*(float *)&_blt_float[v32] * v18));
            if (v7) {
              *unint64_t v7 = v19;
            }
            v26 += 2;
            ++v6;
            unint64_t v7 = (unsigned int *)((char *)v7 + v17);
            --v27;
          }
          while (v27);
        }
        goto LABEL_87;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_87:
      v6 += v9;
      v14 += v13;
      v7 += v74;
      if (!--a6) {
        return result;
      }
    }
    float v41 = (uint64_t *)v70;
    uint64_t result = a5;
    while (1)
    {
      uint64_t v42 = *(v41 - 1);
      uint64_t v43 = *v41;
      unsigned int v44 = &v25[v42];
      if (v16 >= &v25[v42]) {
        uint64_t v45 = &v25[v42];
      }
      else {
        uint64_t v45 = v16;
      }
      if (v15 > v45) {
        uint64_t v45 = v15;
      }
      unsigned int v46 = *v45;
      if ((v43 & 0xF) != 0)
      {
        uint64_t v47 = &v44[v43 >> 4];
        if (v16 < v47) {
          uint64_t v47 = v16;
        }
        if (v15 > v47) {
          uint64_t v47 = v15;
        }
        unsigned int v48 = *v47;
        if (v23)
        {
          if (v16 >= &v44[v22]) {
            float v49 = &v44[v22];
          }
          else {
            float v49 = v16;
          }
          if (v15 > v49) {
            float v49 = v15;
          }
          unsigned int v50 = *v49;
          unsigned int v51 = &v44[v22 + (v43 >> 4)];
          if (v16 < v51) {
            unsigned int v51 = v16;
          }
          if (v15 > v51) {
            unsigned int v51 = v15;
          }
          int v52 = BLEND8_21385[v23];
          unsigned int v46 = v46 - ((v52 & v46) >> v23) + ((v52 & v50) >> v23);
          unsigned int v48 = v48 - ((v52 & v48) >> v23) + ((v52 & *v51) >> v23);
        }
        unsigned int v46 = v46
            - ((BLEND8_21385[*v41 & 0xF] & v46) >> (*v41 & 0xF))
            + ((BLEND8_21385[*v41 & 0xF] & v48) >> (*v41 & 0xF));
      }
      else if (v23)
      {
        int v53 = &v44[v22];
        if (v16 < &v44[v22]) {
          int v53 = v16;
        }
        if (v15 > v53) {
          int v53 = v15;
        }
        unsigned int v46 = v46 - ((BLEND8_21385[v23] & v46) >> v23) + ((BLEND8_21385[v23] & *v53) >> v23);
      }
      float v54 = *(float *)&_blt_float[v46] * v18;
      if (v7)
      {
        if (v18 < 1.0)
        {
          if (v18 > 0.0)
          {
            unsigned int v55 = bswap32(COERCE_UNSIGNED_INT(v18 + (float)(COERCE_FLOAT(bswap32(*v7)) * v20)));
            *int v6 = bswap32(COERCE_UNSIGNED_INT(v54 + (float)(COERCE_FLOAT(bswap32(*v6)) * v20)));
            *unint64_t v7 = v55;
          }
        }
        else
        {
          *int v6 = bswap32(LODWORD(v54));
          *unint64_t v7 = v19;
        }
        goto LABEL_86;
      }
      if (v18 >= 1.0) {
        goto LABEL_85;
      }
      if (v18 > 0.0) {
        break;
      }
LABEL_86:
      v41 += 2;
      ++v6;
      unint64_t v7 = (unsigned int *)((char *)v7 + v17);
      if (!--result) {
        goto LABEL_87;
      }
    }
    float v54 = v54 + (float)(COERCE_FLOAT(bswap32(*v6)) * v20);
LABEL_85:
    *int v6 = bswap32(LODWORD(v54));
    goto LABEL_86;
  }
  unsigned int v56 = (uint64_t *)(v11 + 16 * a3);
  float v57 = fminf(v8, 1.0);
  unsigned int v58 = bswap32(LODWORD(v57));
  float v59 = 1.0 - v57;
  do
  {
    uint64_t result = (uint64_t)&v15[(v14 >> v12) * v10];
    if (v73 != 1)
    {
      unsigned int v64 = v56;
      uint64_t v65 = a5;
      if (a5 < 1) {
        goto LABEL_116;
      }
      while (1)
      {
        uint64_t v66 = *v64;
        v64 += 2;
        float v67 = (unsigned __int8 *)(result + v66);
        if ((unint64_t)v16 < result + v66) {
          float v67 = v16;
        }
        if (v15 > v67) {
          float v67 = v15;
        }
        float v68 = *(float *)&_blt_float[*v67] * v57;
        if (v7)
        {
          if (v57 < 1.0)
          {
            if (v57 > 0.0)
            {
              unsigned int v69 = bswap32(COERCE_UNSIGNED_INT(v57 + (float)(COERCE_FLOAT(bswap32(*v7)) * v59)));
              *int v6 = bswap32(COERCE_UNSIGNED_INT(v68 + (float)(COERCE_FLOAT(bswap32(*v6)) * v59)));
              *unint64_t v7 = v69;
            }
          }
          else
          {
            *int v6 = bswap32(LODWORD(v68));
            *unint64_t v7 = v58;
          }
          goto LABEL_115;
        }
        if (v57 >= 1.0) {
          goto LABEL_114;
        }
        if (v57 > 0.0) {
          break;
        }
LABEL_115:
        ++v6;
        unint64_t v7 = (unsigned int *)((char *)v7 + v17);
        if (!--v65) {
          goto LABEL_116;
        }
      }
      float v68 = v68 + (float)(COERCE_FLOAT(bswap32(*v6)) * v59);
LABEL_114:
      *int v6 = bswap32(LODWORD(v68));
      goto LABEL_115;
    }
    if (a5 >= 1)
    {
      float v60 = v56;
      uint64_t v61 = a5;
      do
      {
        uint64_t v62 = *v60;
        v60 += 2;
        float v63 = (unsigned __int8 *)(result + v62);
        if ((unint64_t)v16 < result + v62) {
          float v63 = v16;
        }
        if (v15 > v63) {
          float v63 = v15;
        }
        *int v6 = bswap32(COERCE_UNSIGNED_INT(*(float *)&_blt_float[*v63] * v57));
        if (v7) {
          *unint64_t v7 = v58;
        }
        ++v6;
        unint64_t v7 = (unsigned int *)((char *)v7 + v17);
        --v61;
      }
      while (v61);
    }
LABEL_116:
    v6 += v9;
    v14 += v13;
    v7 += v74;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t WF_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x1000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    uint64_t v12 = Wf_shade_radial_W;
  }
  else if (*(void *)(v5 + 24))
  {
    uint64_t v12 = Wf_shade_conic_W;
  }
  else if (v16 < 2)
  {
    uint64_t v12 = Wf_shade_axial_W;
  }
  else
  {
    uint64_t v12 = Wf_shade_custom_W;
  }
  uint64_t v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  WF_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

uint64_t (**cg_cmap_library_link_symbol())()
{
  return &cg_cmap_vtable;
}

void *zapf_table(void *a1)
{
  v1 = a1;
  if (a1)
  {
    uint64_t v2 = CFWriteStreamCreateWithAllocatedBuffers(0, 0);
    if (v2)
    {
      uint64_t v3 = v2;
      CFWriteStreamOpen(v2);
      *(_WORD *)buffer = 512;
      CFWriteStreamWrite(v3, buffer, 2);
      *(_WORD *)buffer = 0;
      CFWriteStreamWrite(v3, buffer, 2);
      *(_DWORD *)buffer = 0;
      CFWriteStreamWrite(v3, buffer, 4);
      uint64_t v4 = v1[6];
      if (v4)
      {
        if (*(void *)(v4 + 16))
        {
          *(_WORD *)buffer = 1536;
          CFWriteStreamWrite(v3, buffer, 2);
          uint64_t v5 = *(int **)(v4 + 16);
          int v6 = *v5;
          unint64_t v7 = (unsigned __int16 *)malloc_type_malloc(2 * *((void *)v5 + 5), 0x1000040BDFB0063uLL);
          if (v7)
          {
            uint64_t v13 = v7;
            unsigned int v14 = 0;
            unsigned __int16 v15 = 0;
            do
            {
              if (cmap_bf_set_get_unichars(*(void *)(v4 + 16), v15, (uint64_t)v13, v8, v9, v10, v11, v12)) {
                ++v14;
              }
              ++v15;
            }
            while (v15 <= (unsigned __int16)v6);
            unsigned int v55 = (unsigned __int16 *)malloc_type_malloc(2 * (unsigned __int16)v14, 0x1000040BDFB0063uLL);
            if (v55)
            {
              unsigned __int16 v21 = 0;
              uint64_t v22 = 0;
              do
              {
                if (cmap_bf_set_get_unichars(*(void *)(v4 + 16), v21, (uint64_t)v13, v16, v17, v18, v19, v20)) {
                  v55[v22++] = v21;
                }
                ++v21;
              }
              while (v21 <= (unsigned __int16)v6);
              *(_WORD *)buffer = 1536;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = bswap32(v14) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              uint64_t v54 = (unsigned __int16)v14;
              if ((unsigned __int16)v14 <= 0x8000u)
              {
                if ((unsigned __int16)v14 < 2u)
                {
                  int v24 = 0;
                  unsigned int v23 = 0xFFFF;
                }
                else
                {
                  unsigned int v25 = 0;
                  LOWORD(v26) = 1;
                  do
                  {
                    unsigned int v23 = v25++;
                    unsigned int v26 = 2 * (v26 & 0x7FFF);
                  }
                  while (v26 < (unsigned __int16)v14);
                  int v24 = v26 >> 1;
                }
              }
              else
              {
                unsigned int v23 = 15;
                int v24 = 0x8000;
              }
              *(_WORD *)buffer = bswap32(6 * v24) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = bswap32(v23) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = bswap32(6 * (v14 - v24)) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              int v27 = 6 * (unsigned __int16)v14 + 26;
              int v28 = v27 & 2;
              int v29 = v28 + v27;
              if ((_WORD)v14)
              {
                uint64_t v30 = (unsigned __int16)v14;
                uint64_t v31 = v55;
                unsigned int v32 = v28 + v27;
                do
                {
                  unsigned int v33 = *v31++;
                  *(_WORD *)buffer = __rev16(v33);
                  CFWriteStreamWrite(v3, buffer, 2);
                  *(_DWORD *)buffer = bswap32(v32);
                  CFWriteStreamWrite(v3, buffer, 4);
                  int v39 = v32
                      + 2 * cmap_bf_set_get_unichars(*(void *)(v4 + 16), v33, (uint64_t)v13, v34, v35, v36, v37, v38)
                      + 12;
                  LOWORD(v40) = v39 & 3;
                  if (v39 <= 0) {
                    int v40 = -(-v39 & 3);
                  }
                  unsigned int v32 = v39 + (unsigned __int16)v40;
                  --v30;
                }
                while (v30);
              }
              *(_WORD *)buffer = -1;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = -1;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = -1;
              CFWriteStreamWrite(v3, buffer, 2);
              for (; v28; --v28)
              {
                buffer[0] = 0;
                CFWriteStreamWrite(v3, buffer, 1);
              }
              if ((_WORD)v14)
              {
                uint64_t v46 = 0;
                do
                {
                  unint64_t unichars = cmap_bf_set_get_unichars(*(void *)(v4 + 16), v55[v46], (uint64_t)v13, v41, v42, v43, v44, v45);
                  *(_DWORD *)buffer = -1;
                  CFWriteStreamWrite(v3, buffer, 4);
                  *(_DWORD *)buffer = -1;
                  CFWriteStreamWrite(v3, buffer, 4);
                  *(_WORD *)buffer = bswap32(unichars) >> 16;
                  CFWriteStreamWrite(v3, buffer, 2);
                  if (unichars)
                  {
                    unint64_t v48 = unichars;
                    float v49 = v13;
                    do
                    {
                      unsigned int v50 = *v49++;
                      *(_WORD *)buffer = bswap32(v50) >> 16;
                      CFWriteStreamWrite(v3, buffer, 2);
                      --v48;
                    }
                    while (v48);
                  }
                  *(_WORD *)buffer = 0;
                  CFWriteStreamWrite(v3, buffer, 2);
                  int v51 = v29 + 2 * unichars + 12;
                  if ((v51 & 3) != 0)
                  {
                    int v52 = v51 & 3;
                    do
                    {
                      buffer[0] = 0;
                      CFWriteStreamWrite(v3, buffer, 1);
                      --v52;
                    }
                    while ((_WORD)v52);
                  }
                  int v29 = (v51 & 3) + v51;
                  ++v46;
                }
                while (v46 != v54);
              }
              free(v55);
              free(v13);
            }
          }
        }
      }
      v1 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
      CFWriteStreamClose(v3);
      CFRelease(v3);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t get_index_for_unicodes(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(int8x8_t **)(v3 + 16);
  if (v4) {
    BOOL v5 = a3 == 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    int8x8_t v6 = v4[7];
    if (v6)
    {
      unint64_t v7 = *a2;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8(v6);
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        unint64_t v9 = *a2;
        if (*(void *)&v6 <= v7) {
          unint64_t v9 = v7 % *(void *)&v6;
        }
      }
      else
      {
        unint64_t v9 = (v6.i32[0] - 1) & v7;
      }
      uint64_t v11 = *(uint64_t ****)(*(void *)&v4[6] + 8 * v9);
      if (v11)
      {
        for (i = *v11; i; i = (uint64_t **)*i)
        {
          unint64_t v13 = (unint64_t)i[1];
          if (v13 == v7)
          {
            if (*((unsigned __int16 *)i + 8) == v7) {
              return *((unsigned __int16 *)i + 9);
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v13 >= *(void *)&v6) {
                v13 %= *(void *)&v6;
              }
            }
            else
            {
              v13 &= *(void *)&v6 - 1;
            }
            if (v13 != v9) {
              return 0xFFFFFFFFLL;
            }
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

unint64_t get_unicodes_for_index(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 48);
  if (v8) {
    return cmap_bf_set_get_unichars(*(void *)(v8 + 16), a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 0;
  }
}

uint64_t get_max_unicodes(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 16)) != 0) {
    return *(void *)(v2 + 40);
  }
  else {
    return 0;
  }
}

uint64_t get_wmode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t get_ros(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t get_name(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t create_with_data(const void *a1)
{
  uint64_t v241 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x10800407411B482uLL);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  *uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  uint64_t v4 = malloc_type_calloc(1uLL, 0x38uLL, 0x10300405646078BuLL);
  uint64_t v5 = (uint64_t)v4;
  if (!v4) {
    goto LABEL_361;
  }
  *(_DWORD *)uint64_t v4 = 1;
  v4[41] = 0;
  int8x8_t v6 = malloc_type_malloc(0xA0uLL, 0x8B871889uLL);
  if (!v6)
  {
    *__error() = 12;
    goto LABEL_360;
  }
  uint64_t v7 = (uint64_t)v6;
  v6[8] = 0u;
  v6[9] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  *int8x8_t v6 = 0u;
  v6[1] = 0u;
  *(void *)int8x8_t v6 = CFRetain(a1);
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  CFIndex Length = CFDataGetLength((CFDataRef)a1);
  uint64_t v10 = (int)Length;
  uint64_t v11 = malloc_type_malloc((int)Length + 2, 0x8B871889uLL);
  if (!v11) {
    goto LABEL_368;
  }
  uint64_t v12 = v11;
  if (Length << 32)
  {
    unint64_t v13 = v11;
    uint64_t v14 = (int)Length;
    do
    {
      char v15 = *BytePtr++;
      *v13++ = v15;
      --v14;
    }
    while (v14);
    *(_WORD *)&v11[(int)Length] = 0;
    if ((unint64_t)(Length << 32) > 0xFFFFFFFD00000000) {
      goto LABEL_368;
    }
  }
  else
  {
    *(_WORD *)&v11[(int)Length] = 0;
  }
  uint64_t v16 = malloc_type_malloc(0x48uLL, 0x8B871889uLL);
  if (!v16) {
    goto LABEL_368;
  }
  uint64_t v17 = v16;
  v16[2] = v12;
  v16[3] = v10;
  *uint64_t v16 = 0;
  v16[1] = v12;
  v16[4] = v10;
  v16[5] = 0;
  *((_DWORD *)v16 + 12) = 1;
  *(void *)((char *)v16 + 60) = 0;
  cmap_yyensure_buffer_stack((void *)v7);
  uint64_t v18 = *(void *)(v7 + 40);
  uint64_t v19 = *(void *)(v7 + 24);
  uint64_t v20 = *(void **)(v18 + 8 * v19);
  if (v20 != v17)
  {
    if (v20)
    {
      **(unsigned char **)(v7 + 72) = *(unsigned char *)(v7 + 48);
      uint64_t v18 = *(void *)(v7 + 40);
      uint64_t v19 = *(void *)(v7 + 24);
      *(void *)(*(void *)(v18 + 8 * v19) + 16) = *(void *)(v7 + 72);
      *(void *)(*(void *)(v18 + 8 * v19) + 32) = *(void *)(v7 + 56);
    }
    *(void *)(v18 + 8 * v19) = v17;
    uint64_t v21 = *(void *)(v7 + 40);
    uint64_t v22 = *(void *)(v21 + 8 * v19);
    *(void *)(v7 + 56) = *(void *)(v22 + 32);
    unsigned int v23 = *(unsigned char **)(v22 + 16);
    *(void *)(v7 + 72) = v23;
    *(void *)(v7 + 136) = v23;
    *(void *)(v7 + 8) = **(void **)(v21 + 8 * v19);
    *(unsigned char *)(v7 + 48) = *v23;
    *(_DWORD *)(v7 + 88) = 1;
  }
  *(void *)unsigned int v225 = v5;
  *((_DWORD *)v17 + 10) = 1;
  v3[1] = get_used_cmap;
  unsigned int v24 = *(_DWORD *)v3;
  cmap_yydebug = *(_DWORD *)v3 & 1;
  *(_DWORD *)(v7 + 132) = (v24 >> 1) & 1;
  long long v236 = 0uLL;
  unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
  if (v24) {
    fwrite("Starting parse\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
  }
  unint64_t v26 = 0u;
  LODWORD(v224) = 0;
  uint64_t v222 = (unint64_t *)(v7 + 120);
  int v223 = (unint64_t *)(v7 + 72);
  unsigned int v226 = v238;
  unint64_t v27 = 200;
  int v28 = "nterm %s (";
  int v29 = yy_def;
  uint64_t v30 = yy_meta;
  __src = v239;
  unint64_t v31 = (unint64_t)v239;
  unsigned int v32 = (unint64_t *)v238;
  LODWORD(v228) = -2;
  uint64_t v227 = v7;
  while (1)
  {
    *(_WORD *)unint64_t v31 = v26;
    unint64_t v233 = v26;
    if ((unint64_t)__src + 2 * v27 - 2 <= v31)
    {
      if (v27 >> 4 > 0x270
        || (2 * v27 >= 0x2710 ? (uint64_t v33 = 10000) : (uint64_t v33 = 2 * v27),
            (uint64_t v34 = (char *)malloc_type_malloc(18 * v33 + 15, 0x50DDE130uLL)) == 0))
      {
        float v231 = (char *)v31;
        int v220 = 0;
        LODWORD(v31) = 0;
        float v219 = v240;
        goto LABEL_325;
      }
      uint64_t v35 = v34;
      uint64_t v36 = __src;
      uint64_t v37 = (uint64_t)(v31 - (void)__src) >> 1;
      uint64_t v38 = v37 + 1;
      memcpy(v34, __src, 2 * (v37 + 1));
      int64_t v39 = v33;
      int v40 = &v35[(2 * v33 + 15) & 0xFFFFFFFFFFFFFFF0];
      memcpy(v40, v226, 16 * (v37 + 1));
      if (v36 != v239) {
        free(v36);
      }
      if (cmap_yydebug) {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Stack size increased to %lu\n", v39);
      }
      unint64_t v31 = (unint64_t)&v35[2 * v37];
      unsigned int v32 = (unint64_t *)&v40[16 * v38 - 16];
      if (v39 <= v38)
      {
        float v231 = (char *)v31;
        int v220 = 0;
        LODWORD(v31) = 0;
        float v219 = v240;
        __src = v35;
        uint64_t v7 = v227;
        goto LABEL_325;
      }
      __src = v35;
      unsigned int v226 = v40;
      unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
      unint64_t v27 = v39;
      uint64_t v7 = v227;
      int v28 = "nterm %s (";
      int v29 = yy_def;
      uint64_t v30 = yy_meta;
      LODWORD(v26) = v233;
    }
    if (cmap_yydebug)
    {
      fprintf(*v25, "Entering state %d\n", v26);
      LODWORD(v26) = v233;
      uint64_t v30 = yy_meta;
      int v29 = yy_def;
    }
    int v41 = yypact[(int)v26];
    int v235 = v32;
    unint64_t v232 = v27;
    if (v41 != -31)
    {
      int v42 = (int)v228;
      int v230 = v41;
      if (v228 == -2)
      {
        if (cmap_yydebug)
        {
          fwrite("Reading a token: ", 0x11uLL, 1uLL, *v25);
          uint64_t v30 = yy_meta;
          int v29 = yy_def;
        }
        *(void *)(v7 + 152) = &v236;
        if (!*(_DWORD *)(v7 + 80))
        {
          *(_DWORD *)(v7 + 80) = 1;
          if (!*(_DWORD *)(v7 + 84)) {
            *(_DWORD *)(v7 + 84) = 1;
          }
          if (!*(void *)(v7 + 8)) {
            *(void *)(v7 + 8) = *MEMORY[0x1E4F143D0];
          }
          if (!*(void *)(v7 + 16)) {
            *(void *)(v7 + 16) = *MEMORY[0x1E4F143D8];
          }
          uint64_t v43 = *(void *)(v7 + 40);
          if (!v43 || (uint64_t v44 = *(void *)(v7 + 24), (v45 = *(void *)(v43 + 8 * v44)) == 0))
          {
            cmap_yyensure_buffer_stack((void *)v7);
            uint64_t buffer = cmap_yy_create_buffer(*(void *)(v7 + 8), v7);
            uint64_t v30 = yy_meta;
            int v29 = yy_def;
            uint64_t v44 = *(void *)(v7 + 24);
            *(void *)(*(void *)(v7 + 40) + 8 * v44) = buffer;
            uint64_t v43 = *(void *)(v7 + 40);
            uint64_t v45 = *(void *)(v43 + 8 * v44);
          }
          *(void *)(v7 + 56) = *(void *)(v45 + 32);
          uint64_t v47 = *(unsigned char **)(v45 + 16);
          *(void *)(v7 + 72) = v47;
          *(void *)(v7 + 136) = v47;
          *(void *)(v7 + 8) = **(void **)(v43 + 8 * v44);
          *(unsigned char *)(v7 + 48) = *v47;
        }
LABEL_51:
        unint64_t v48 = *(unsigned char **)(v7 + 72);
        *unint64_t v48 = *(unsigned char *)(v7 + 48);
        int v49 = *(_DWORD *)(v7 + 84);
        float v228 = v48;
        while (1)
        {
          while (1)
          {
            do
            {
              uint64_t v50 = yy_ec[*v48];
              if (yy_accept[v49])
              {
                *(_DWORD *)(v7 + 112) = v49;
                *(void *)(v7 + 120) = v48;
              }
              uint64_t v51 = v49;
              uint64_t v52 = yy_base[v49] + v50;
              if (v49 != (__int16)yy_chk[v52])
              {
                do
                {
                  uint64_t v51 = yy_def[v51];
                  if (v51 >= 253) {
                    uint64_t v50 = yy_meta[v50];
                  }
                  uint64_t v52 = yy_base[v51] + v50;
                }
                while (yy_chk[v52] != (unsigned __int16)v51);
              }
              int v49 = yy_nxt[v52];
              ++v48;
            }
            while (v49 != 252);
LABEL_59:
            while (2)
            {
              int v53 = *(_DWORD *)(v7 + 112);
              uint64_t v54 = v222;
LABEL_60:
              unsigned int v55 = (unsigned char *)*v54;
              int v56 = (__int16)yy_accept[v53];
              float v57 = v228;
              *(void *)(v7 + 136) = v228;
              *(void *)(v7 + 64) = v55 - v57;
              *(unsigned char *)(v7 + 48) = *v55;
              *unsigned int v55 = 0;
              float v229 = v55;
              *(void *)(v7 + 72) = v55;
LABEL_61:
              if (!*(_DWORD *)(v7 + 132)) {
                goto LABEL_70;
              }
              if (!v56)
              {
                fwrite("--scanner backing up\n", 0x15uLL, 1uLL, *v25);
                uint64_t v30 = yy_meta;
                int v29 = yy_def;
LABEL_142:
                *float v229 = *(unsigned char *)(v7 + 48);
                continue;
              }
              break;
            }
            if (v56 <= 43)
            {
              fprintf(*v25, "--accepting rule at line %ld (\"%s\")\n", yy_rule_linenum[v56], *(const char **)(v7 + 136));
              uint64_t v30 = yy_meta;
              int v29 = yy_def;
              goto LABEL_70;
            }
            if (v56 != 45)
            {
              if (v56 == 44)
              {
                fprintf(*v25, "--accepting default rule (\"%s\")\n", *(const char **)(v7 + 136));
                fatal_scanner_error();
              }
              int v58 = *(_DWORD *)(v7 + 84);
              if (v58 >= 1) {
                --v58;
              }
              fprintf(*v25, "--EOF (start condition %d)\n", v58 >> 1);
              int v29 = yy_def;
              uint64_t v30 = yy_meta;
LABEL_70:
              switch(yytname)
              {
                case 0u:
                  goto LABEL_142;
                case 1u:
                case 7u:
                case 0x29u:
                case 0x2Au:
                  goto LABEL_51;
                case 2u:
                case 3u:
                  int v42 = **(char **)(v7 + 136);
                  goto LABEL_152;
                case 4u:
                  uint64_t v111 = v28;
                  int v42 = 0x11Fu;
                  goto LABEL_154;
                case 5u:
                  uint64_t v111 = v28;
                  int v42 = 0x120u;
                  goto LABEL_154;
                case 6u:
                  uint64_t v111 = v28;
                  unsigned int v237 = 0;
                  int v178 = strtol_l(*(const char **)(v7 + 136), &v237, 10, 0);
                  uint64_t v30 = yy_meta;
                  int v29 = yy_def;
                  **(_DWORD **)(v7 + 152) = v178;
                  int v42 = 0x122u;
                  goto LABEL_154;
                case 8u:
                  unint64_t v179 = *(void *)(v7 + 64);
                  if (v179 <= 1) {
                    goto LABEL_371;
                  }
                  uint64_t v111 = v28;
                  size_t v180 = v179 - 2;
                  **(void **)(v7 + 152) = malloc_type_malloc(v179 - 1, 0x142A60F1uLL);
                  strncpy(**(char ***)(v7 + 152), (const char *)(*(void *)(v7 + 136) + 1), v180);
                  *(unsigned char *)(**(void **)(v7 + 152) + v180) = 0;
                  int v42 = 0x124u;
                  int v29 = yy_def;
                  uint64_t v30 = yy_meta;
                  goto LABEL_154;
                case 9u:
                  unint64_t v181 = *(void *)(v7 + 64);
                  if (v181 <= 1) {
LABEL_371:
                  }
                    abort();
                  *(void *)(*(void *)(v7 + 152) + 8) = malloc_type_malloc(v181 + 1, 0xEAA13950uLL);
                  uint64_t v182 = *(void *)(v7 + 64);
                  if ((unint64_t)(v182 - 3) > 0xFFFFFFFFFFFFFFFDLL)
                  {
                    int v183 = 0;
                    int v29 = yy_def;
                    uint64_t v30 = yy_meta;
                  }
                  else
                  {
                    int v183 = 0;
                    int v184 = 0;
                    char v185 = 0;
                    unint64_t v186 = 1;
                    int v29 = yy_def;
                    uint64_t v30 = yy_meta;
                    do
                    {
                      int v187 = *(unsigned __int8 *)(*(void *)(v7 + 136) + v186);
                      char v188 = v187 - 48;
                      if (v187 - 48) <= 0x36 && ((0x7E0000007E03FFuLL >> v188))
                      {
                        int v184 = (dword_185296BF8[v188] + v187) | (16 * v184);
                        if (v185)
                        {
                          *(unsigned char *)(*(void *)(*(void *)(v7 + 152) + 8) + v183++) = v184;
                          uint64_t v182 = *(void *)(v7 + 64);
                        }
                        ++v185;
                      }
                      ++v186;
                    }
                    while (v186 < v182 - 1);
                    if (v185) {
                      *(unsigned char *)(*(void *)(*(void *)(v7 + 152) + 8) + v183++) = 16 * v184;
                    }
                  }
                  uint64_t v111 = v28;
                  **(void **)(v7 + 152) = v183;
                  int v42 = 0x125u;
                  goto LABEL_154;
                case 0xAu:
                  uint64_t v111 = v28;
                  int v42 = 0x118u;
                  goto LABEL_154;
                case 0xBu:
                  uint64_t v111 = v28;
                  int v42 = 0x119u;
                  goto LABEL_154;
                case 0xCu:
                  uint64_t v111 = v28;
                  int v42 = 0x11Bu;
                  goto LABEL_154;
                case 0xDu:
                  uint64_t v111 = v28;
                  int v42 = 0x11Cu;
                  goto LABEL_154;
                case 0xEu:
                  uint64_t v111 = v28;
                  int v42 = 0x11Du;
                  goto LABEL_154;
                case 0xFu:
                  uint64_t v111 = v28;
                  int v42 = 0x11Au;
                  goto LABEL_154;
                case 0x10u:
                  uint64_t v111 = v28;
                  **(void **)(v7 + 152) = malloc_type_malloc(*(void *)(v7 + 64) + 1, 0x591FCFE5uLL);
                  float v189 = **(char ***)(v7 + 152);
                  float v190 = (const char *)(*(void *)(v7 + 136) + 1);
                  goto LABEL_296;
                case 0x11u:
                  uint64_t v111 = v28;
                  int v42 = 0x102u;
                  goto LABEL_154;
                case 0x12u:
                  uint64_t v111 = v28;
                  int v42 = 0x103u;
                  goto LABEL_154;
                case 0x13u:
                  uint64_t v111 = v28;
                  int v42 = 0x104u;
                  goto LABEL_154;
                case 0x14u:
                  uint64_t v111 = v28;
                  int v42 = 0x105u;
                  goto LABEL_154;
                case 0x15u:
                  uint64_t v111 = v28;
                  int v42 = 0x106u;
                  goto LABEL_154;
                case 0x16u:
                  uint64_t v111 = v28;
                  int v42 = 0x107u;
                  goto LABEL_154;
                case 0x17u:
                  uint64_t v111 = v28;
                  int v42 = 0x108u;
                  goto LABEL_154;
                case 0x18u:
                  uint64_t v111 = v28;
                  int v42 = 0x109u;
                  goto LABEL_154;
                case 0x19u:
                  uint64_t v111 = v28;
                  int v42 = 0x10Au;
                  goto LABEL_154;
                case 0x1Au:
                  uint64_t v111 = v28;
                  int v42 = 0x10Bu;
                  goto LABEL_154;
                case 0x1Bu:
                  uint64_t v111 = v28;
                  int v42 = 0x10Cu;
                  goto LABEL_154;
                case 0x1Cu:
                  uint64_t v111 = v28;
                  int v42 = 0x10Du;
                  goto LABEL_154;
                case 0x1Du:
                  uint64_t v111 = v28;
                  int v42 = 0x10Eu;
                  goto LABEL_154;
                case 0x1Eu:
                  uint64_t v111 = v28;
                  int v42 = 0x10Fu;
                  goto LABEL_154;
                case 0x1Fu:
                  uint64_t v111 = v28;
                  int v42 = 0x110u;
                  goto LABEL_154;
                case 0x20u:
                  uint64_t v111 = v28;
                  int v42 = 0x111u;
                  goto LABEL_154;
                case 0x21u:
                  uint64_t v111 = v28;
                  int v42 = 0x112u;
                  goto LABEL_154;
                case 0x22u:
                  uint64_t v111 = v28;
                  int v42 = 0x113u;
                  goto LABEL_154;
                case 0x23u:
                  uint64_t v111 = v28;
                  int v42 = 0x114u;
                  goto LABEL_154;
                case 0x24u:
                  uint64_t v111 = v28;
                  int v42 = 0x115u;
                  goto LABEL_154;
                case 0x25u:
                  uint64_t v111 = v28;
                  int v42 = 0x116u;
                  goto LABEL_154;
                case 0x26u:
                  uint64_t v111 = v28;
                  int v42 = 0x117u;
                  goto LABEL_154;
                case 0x27u:
                  uint64_t v111 = v28;
                  int v42 = 0x11Eu;
                  goto LABEL_154;
                case 0x28u:
                  uint64_t v111 = v28;
                  **(void **)(v7 + 152) = malloc_type_malloc(*(void *)(v7 + 64) + 1, 0x39DB8847uLL);
                  float v189 = **(char ***)(v7 + 152);
                  float v190 = *(const char **)(v7 + 136);
LABEL_296:
                  strcpy(v189, v190);
                  uint64_t v30 = yy_meta;
                  int v29 = yy_def;
                  int v42 = 0x123u;
                  goto LABEL_154;
                case 0x2Bu:
                  uint64_t v111 = v28;
                  int v42 = 0x121u;
                  goto LABEL_154;
                case 0x2Du:
                  goto LABEL_72;
                case 0x2Eu:
                  goto LABEL_155;
                default:
                  goto LABEL_368;
              }
            }
            fwrite("--(end of buffer or a NUL)\n", 0x1BuLL, 1uLL, *v25);
            uint64_t v30 = yy_meta;
            int v29 = yy_def;
LABEL_72:
            uint64_t v59 = *(void *)(v7 + 136);
            *float v229 = *(unsigned char *)(v7 + 48);
            uint64_t v60 = *(void *)(v7 + 40);
            uint64_t v61 = *(void *)(v7 + 24);
            uint64_t v62 = *(void *)(v60 + 8 * v61);
            if (*(_DWORD *)(v62 + 64))
            {
              uint64_t v63 = *(void *)(v7 + 56);
            }
            else
            {
              uint64_t v63 = *(void *)(v62 + 32);
              *(void *)(v7 + 56) = v63;
              *(void *)uint64_t v62 = *(void *)(v7 + 8);
              uint64_t v62 = *(void *)(v60 + 8 * v61);
              *(_DWORD *)(v62 + 64) = 1;
            }
            unint64_t v64 = *v223;
            uint64_t v65 = *(unsigned char **)(v62 + 8);
            if (*v223 > (unint64_t)&v65[v63]) {
              break;
            }
            *(void *)(v7 + 72) = *(void *)(v7 + 136) + ~v59 + (int)v229;
            int previous_state = yy_get_previous_state(v7);
            if (yy_accept[previous_state])
            {
              uint64_t v106 = *(void *)(v7 + 72);
              *(_DWORD *)(v7 + 112) = previous_state;
              *(void *)(v7 + 120) = v106;
            }
            uint64_t v107 = previous_state;
            uint64_t v108 = yy_base[previous_state] + 2;
            unint64_t v27 = v232;
            int v29 = yy_def;
            uint64_t v30 = yy_meta;
            if (previous_state != (__int16)yy_chk[v108])
            {
              do
              {
                int v109 = (unsigned __int16)yy_def[v107];
                uint64_t v107 = (__int16)v109;
                uint64_t v108 = yy_base[(__int16)v109] + 2;
              }
              while (v109 != yy_chk[v108]);
            }
            float v228 = *(unsigned char **)(v7 + 136);
            if (!v108) {
              goto LABEL_59;
            }
            int v110 = (unsigned __int16)yy_nxt[v108];
            if (v110 == 252) {
              goto LABEL_59;
            }
            int v49 = (__int16)v110;
            unint64_t v48 = (unsigned char *)(*v223 + 1);
            *int v223 = (unint64_t)v48;
          }
          uint64_t v224 = v59;
          if (v64 > (unint64_t)&v65[v63 + 1]) {
            goto LABEL_368;
          }
          uint64_t v66 = *(char **)(v7 + 136);
          if (!*(_DWORD *)(v62 + 60))
          {
            unint64_t v27 = v232;
            if (v64 - (void)v66 == 1) {
              goto LABEL_133;
            }
            goto LABEL_140;
          }
          int v67 = ~v66 + v64;
          if (v67 >= 1)
          {
            int v68 = ~v66 + v64;
            do
            {
              char v69 = *v66++;
              *v65++ = v69;
              --v68;
            }
            while (v68);
            uint64_t v60 = *(void *)(v7 + 40);
            uint64_t v61 = *(void *)(v7 + 24);
            uint64_t v62 = *(void *)(v60 + 8 * v61);
          }
          uint64_t v70 = v67;
          if (*(_DWORD *)(v62 + 64) == 2)
          {
            *(void *)(v7 + 56) = 0;
            goto LABEL_84;
          }
          uint64_t v71 = ~(uint64_t)v67;
          unint64_t v72 = *(void *)(v62 + 24);
          unint64_t v73 = v72 + v71;
          int v221 = v67;
          if (!(v72 + v71))
          {
            float v231 = (char *)v31;
            uint64_t v74 = (char *)*v223;
            do
            {
              if (!*(_DWORD *)(v62 + 40))
              {
                *(void *)(v62 + 8) = 0;
                fatal_scanner_error();
              }
              float v75 = *(void **)(v62 + 8);
              uint64_t v76 = 2 * v72;
              uint64_t v77 = v72 + (v72 >> 3);
              if (v76) {
                uint64_t v77 = v76;
              }
              *(void *)(v62 + 24) = v77;
              float v78 = (char *)malloc_type_realloc(v75, v77 + 2, 0xF93AD230uLL);
              *(void *)(v62 + 8) = v78;
              if (!v78) {
                goto LABEL_368;
              }
              uint64_t v74 = &v78[(int)v74 - (int)v75];
              *(void *)(v7 + 72) = v74;
              uint64_t v62 = *(void *)(*(void *)(v7 + 40) + 8 * *(void *)(v7 + 24));
              unint64_t v72 = *(void *)(v62 + 24);
              unint64_t v73 = v72 + v71;
            }
            while (!(v72 + v71));
            unint64_t v31 = (unint64_t)v231;
          }
          if (v73 >= 0x2000) {
            size_t v79 = 0x2000;
          }
          else {
            size_t v79 = v73;
          }
          if (*(_DWORD *)(v62 + 44))
          {
            size_t v80 = 0;
            do
            {
              int v81 = getc(*(FILE **)(v7 + 8));
              BOOL v82 = v81 == -1 || v81 == 10;
              if (v82) {
                goto LABEL_106;
              }
              *(unsigned char *)(*(void *)(*(void *)(*(void *)(v7 + 40) + 8 * *(void *)(v7 + 24)) + 8) + v70 + v80++) = v81;
            }
            while (v79 != v80);
            size_t v80 = v79;
LABEL_106:
            if (v81 == -1)
            {
              int v84 = ferror(*(FILE **)(v7 + 8));
              int v29 = yy_def;
              uint64_t v30 = yy_meta;
              if (v84) {
                goto LABEL_368;
              }
            }
            else
            {
              if (v81 == 10) {
                *(unsigned char *)(*(void *)(*(void *)(*(void *)(v7 + 40) + 8 * *(void *)(v7 + 24)) + 8)
              }
                         + v70
                         + v80++) = 10;
              int v29 = yy_def;
              uint64_t v30 = yy_meta;
            }
            *(void *)(v7 + 56) = v80;
LABEL_118:
            uint64_t v60 = *(void *)(v7 + 40);
            uint64_t v61 = *(void *)(v7 + 24);
            uint64_t v62 = *(void *)(v60 + 8 * v61);
            *(void *)(v62 + 32) = v80;
            int v67 = v221;
            if (!v80) {
              goto LABEL_120;
            }
            int v85 = 0;
            goto LABEL_128;
          }
          *__error() = 0;
          while (1)
          {
            size_t v83 = fread((void *)(*(void *)(*(void *)(*(void *)(v7 + 40) + 8 * *(void *)(v7 + 24)) + 8) + v70), 1uLL, v79, *(FILE **)(v7 + 8));
            size_t v80 = (int)v83;
            *(void *)(v7 + 56) = (int)v83;
            if (v83 << 32)
            {
              int v29 = yy_def;
              uint64_t v30 = yy_meta;
              goto LABEL_118;
            }
            if (!ferror(*(FILE **)(v7 + 8))) {
              break;
            }
            if (*__error() != 4) {
              goto LABEL_368;
            }
            *__error() = 0;
            clearerr(*(FILE **)(v7 + 8));
          }
          uint64_t v60 = *(void *)(v7 + 40);
          uint64_t v61 = *(void *)(v7 + 24);
          uint64_t v62 = *(void *)(v60 + 8 * v61);
          int v29 = yy_def;
          uint64_t v30 = yy_meta;
          int v67 = v221;
LABEL_84:
          *(void *)(v62 + 32) = 0;
LABEL_120:
          if (v67)
          {
            size_t v80 = 0;
            int v85 = 2;
            *(_DWORD *)(v62 + 64) = 2;
          }
          else
          {
            uint64_t v86 = *(void *)(v7 + 8);
            uint64_t v87 = *(void *)(v60 + 8 * v61);
            if (!v87)
            {
              cmap_yyensure_buffer_stack((void *)v7);
              uint64_t v88 = cmap_yy_create_buffer(*(void *)(v7 + 8), v7);
              uint64_t v89 = *(void *)(v7 + 24);
              *(void *)(*(void *)(v7 + 40) + 8 * v89) = v88;
              uint64_t v90 = *(void *)(v7 + 40);
              if (v90) {
                uint64_t v87 = *(void *)(v90 + 8 * v89);
              }
              else {
                uint64_t v87 = 0;
              }
            }
            cmap_yy_init_buffer(v87, v86, v7);
            uint64_t v91 = *(void *)(v7 + 40);
            uint64_t v92 = *(void *)(v7 + 24);
            uint64_t v93 = *(void *)(v91 + 8 * v92);
            size_t v80 = *(void *)(v93 + 32);
            *(void *)(v7 + 56) = v80;
            uint64_t v94 = *(unsigned char **)(v93 + 16);
            *(void *)(v7 + 72) = v94;
            *(void *)(v7 + 136) = v94;
            *(void *)(v7 + 8) = **(void **)(v91 + 8 * v92);
            *(unsigned char *)(v7 + 48) = *v94;
            uint64_t v62 = *(void *)(v91 + 8 * v92);
            int v85 = 1;
            int v29 = yy_def;
            uint64_t v30 = yy_meta;
            int v67 = 0;
          }
LABEL_128:
          size_t v95 = v80 + v67;
          if (v95 > *(void *)(v62 + 24))
          {
            size_t v96 = v95 + (v80 >> 1);
            float v97 = malloc_type_realloc(*(void **)(v62 + 8), v96, 0xF93AD230uLL);
            uint64_t v98 = *(void *)(v7 + 40);
            uint64_t v99 = *(void *)(v7 + 24);
            *(void *)(*(void *)(v98 + 8 * v99) + 8) = v97;
            uint64_t v100 = *(void *)(v98 + 8 * v99);
            uint64_t v101 = *(void *)(v100 + 8);
            if (v101)
            {
              *(void *)(v100 + 24) = (int)v96 - 2;
              size_t v95 = *(void *)(v7 + 56) + v70;
              unint64_t v27 = v232;
              int v29 = yy_def;
              uint64_t v30 = yy_meta;
              goto LABEL_132;
            }
LABEL_368:
            fatal_scanner_error();
          }
          uint64_t v101 = *(void *)(v62 + 8);
          unint64_t v27 = v232;
LABEL_132:
          *(void *)(v7 + 56) = v95;
          *(unsigned char *)(v101 + v95) = 0;
          *(unsigned char *)(*(void *)(v7 + 56)
                   + *(void *)(*(void *)(*(void *)(v7 + 40) + 8 * *(void *)(v7 + 24)) + 8)
                   + 1) = 0;
          uint64_t v102 = *(void *)(v7 + 40);
          uint64_t v103 = *(void *)(v7 + 24);
          uint64_t v66 = *(char **)(*(void *)(v102 + 8 * v103) + 8);
          *(void *)(v7 + 136) = v66;
          unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
          if (v85 == 1)
          {
LABEL_133:
            *(_DWORD *)(v7 + 88) = 0;
            *(void *)(v7 + 72) = v66;
            int v104 = *(_DWORD *)(v7 + 84);
            if (v104 >= 1) {
              --v104;
            }
            int v56 = (v104 >> 1) + 46;
            unsigned int v32 = v235;
            goto LABEL_61;
          }
          if (v85)
          {
            BOOL v82 = v85 == 2;
            unsigned int v32 = v235;
            if (!v82) {
              goto LABEL_51;
            }
            uint64_t v65 = *(unsigned char **)(*(void *)(v102 + 8 * v103) + 8);
            uint64_t v63 = *(void *)(v7 + 56);
LABEL_140:
            *(void *)(v7 + 72) = &v65[v63];
            int v53 = yy_get_previous_state(v7);
            uint64_t v30 = yy_meta;
            int v29 = yy_def;
            float v228 = *(unsigned char **)(v7 + 136);
            uint64_t v54 = v223;
            unsigned int v32 = v235;
            goto LABEL_60;
          }
          *(void *)(v7 + 72) = &v66[~v224 + (int)v229];
          int v49 = yy_get_previous_state(v7);
          uint64_t v30 = yy_meta;
          int v29 = yy_def;
          unint64_t v48 = *(unsigned char **)(v7 + 72);
          float v228 = *(unsigned char **)(v7 + 136);
          unsigned int v32 = v235;
        }
      }
LABEL_152:
      if (v42 <= 0)
      {
LABEL_155:
        uint64_t v111 = v28;
        if (cmap_yydebug)
        {
          fwrite("Now at end of input.\n", 0x15uLL, 1uLL, *v25);
          uint64_t v30 = yy_meta;
          int v29 = yy_def;
        }
        unsigned int v112 = 0;
        LODWORD(v228) = 0;
      }
      else
      {
        uint64_t v111 = v28;
        if (v42 >= 0x127) {
          unsigned int v112 = 2;
        }
        else {
LABEL_154:
        }
          unsigned int v112 = yytranslate[v42];
        LODWORD(v228) = v42;
        if (cmap_yydebug)
        {
          fprintf(*v25, "%s ", "Next token is");
          float v113 = (FILE *)*MEMORY[0x1E4F143C8];
          if (v112 >= 0x2A) {
            fprintf(v113, v111, yytname[v112]);
          }
          else {
            fprintf(v113, "token %s (");
          }
          float v114 = v113;
          unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
          fputc(41, v114);
          fputc(10, *v25);
          uint64_t v30 = yy_meta;
          int v29 = yy_def;
        }
      }
      LODWORD(v26) = v233;
      uint64_t v115 = v112 + v230;
      LODWORD(v224) = v112;
      if (v115 <= 0x72 && v112 == yycheck[v115]) {
        break;
      }
    }
    uint64_t v120 = yydefact[(int)v26];
    if (!yydefact[(int)v26])
    {
      unsigned int v32 = v235;
LABEL_302:
      uint64_t v191 = yysyntax_error(0, v26, v228);
      uint64_t v192 = v191;
      float v219 = v240;
      if ((unint64_t)v191 < 0x81)
      {
        unint64_t v195 = 128;
      }
      else
      {
        if (v191 < 0) {
          size_t v193 = -1;
        }
        else {
          size_t v193 = 2 * v191;
        }
        uint64_t v194 = malloc_type_malloc(v193, 0x93DF3029uLL);
        if (v194) {
          float v219 = v194;
        }
        unint64_t v195 = 128;
        if (v194) {
          unint64_t v195 = v193;
        }
      }
      int v196 = (int)v228;
      if (v192 - 1 < v195)
      {
        yysyntax_error(v219, v233, v228);
        goto LABEL_314;
      }
      if (v192)
      {
        float v231 = (char *)v31;
        int v220 = 0;
        LODWORD(v31) = 0;
        goto LABEL_326;
      }
LABEL_317:
      if ((void *)v31 == __src)
      {
        int v220 = 0;
        LODWORD(v31) = 0;
        float v231 = (char *)__src;
      }
      else
      {
        int v197 = v196;
        unsigned int v198 = (__int16 *)(v31 - 2);
        int v199 = v233;
        float v200 = (__int16 *)__src;
        do
        {
          yydestruct("Error: popping", yystos[v199], (void **)v32);
          int v199 = *v198;
          if (cmap_yydebug)
          {
            int v201 = *v198;
            yy_stack_print(v200, (unint64_t)v198);
            int v199 = v201;
          }
          v32 -= 2;
          BOOL v82 = v198-- == v200;
        }
        while (!v82);
        int v220 = 0;
        LODWORD(v31) = 0;
        float v231 = (char *)__src;
        int v196 = v197;
      }
      goto LABEL_326;
    }
    float v231 = (char *)v31;
    unint64_t v121 = yyr2[v120];
    float v122 = &v235[2 * (1 - v121)];
    unint64_t v233 = *v122;
    int v123 = *((_DWORD *)v122 + 2);
    LODWORD(v122) = *((_DWORD *)v122 + 3);
    int v230 = v123;
    LODWORD(v229) = v122;
    uint64_t v124 = v120;
    if (cmap_yydebug)
    {
      fprintf(*v25, "Reducing stack by rule %d (line %lu):\n", v120 - 1, yyrline[v120]);
      if (v121)
      {
        uint64_t v125 = 0;
        do
        {
          int v126 = v125 + 1;
          fprintf(*v25, "   $%d = ", v125 + 1);
          unsigned int v127 = (FILE *)*MEMORY[0x1E4F143C8];
          if (yyrhs[yyprhs[v124] + v125] < 42) {
            fprintf(v127, "token %s (");
          }
          else {
            fprintf(v127, "nterm %s (");
          }
          unsigned int v128 = v127;
          unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
          fputc(41, v128);
          fputc(10, *v25);
          ++v125;
        }
        while (v121 != v126);
      }
    }
    int v129 = v124 - 21;
    uint64_t v130 = v124;
    int v28 = "nterm %s (";
    uint64_t v7 = v227;
    unint64_t v31 = v121;
    int v131 = v230;
    switch(v129)
    {
      case 0:
      case 2:
        float v132 = v235;
        cmap_set_name(*(uint64_t *)v225, (char *)*(v235 - 2));
        float v133 = (void *)*(v132 - 2);
        goto LABEL_210;
      case 1:
        uint64_t v135 = (void **)v235;
        cmap_set_name(*(uint64_t *)v225, (char *)*v235);
        float v133 = *v135;
        goto LABEL_210;
      case 3:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 18:
      case 19:
      case 20:
      case 22:
      case 27:
      case 28:
      case 29:
      case 31:
      case 33:
      case 34:
      case 35:
      case 37:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
        goto LABEL_211;
      case 4:
        uint64_t v136 = v235;
        cmap_set_ros(*(uint64_t *)v225, (char *)*(v235 - 10), (const char *)*(v235 - 6), *((_DWORD *)v235 - 4));
        goto LABEL_192;
      case 5:
        uint64_t v136 = v235;
        cmap_set_ros(*(uint64_t *)v225, (char *)*(v235 - 14), (const char *)*(v235 - 10), *((_DWORD *)v235 - 4));
        free((void *)*(v136 - 14));
LABEL_192:
        free((void *)*(v136 - 10));
        float v133 = (void *)*(v136 - 6);
        goto LABEL_210;
      case 6:
      case 9:
        float v134 = v235;
        cmap_set_ros(*(uint64_t *)v225, (char *)*(v235 - 16), (const char *)*(v235 - 10), *((_DWORD *)v235 - 8));
        free((void *)*(v134 - 16));
        float v133 = (void *)*(v134 - 10);
        goto LABEL_210;
      case 7:
        float v133 = (void *)*(v235 - 6);
        goto LABEL_210;
      case 8:
        int v137 = v235;
        cmap_set_ros(*(uint64_t *)v225, (char *)*(v235 - 14), (const char *)*(v235 - 8), *((_DWORD *)v235 - 4));
        free((void *)*(v137 - 14));
        float v133 = (void *)*(v137 - 8);
        goto LABEL_210;
      case 10:
        *(_DWORD *)(*(void *)v225 + 24) = *((_DWORD *)v235 - 4);
        goto LABEL_211;
      case 11:
        unsigned int v138 = (uint64_t (*)(void *, __int16 *, unsigned __int8 *))v3[1];
        float v139 = v235;
        float v133 = (void *)*(v235 - 2);
        if (!v138) {
          goto LABEL_210;
        }
        uint64_t v140 = v138(v133, v29, v30);
        free((void *)*(v139 - 2));
        if (v140)
        {
          cmap_set_used_cmap(*(uint64_t *)v225, v140);
          cmap_release(v140);
        }
LABEL_230:
        unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
        goto LABEL_211;
      case 17:
        uint64_t v141 = *(v235 - 2);
        if (v141 == *v235)
        {
          unsigned int v142 = *((_DWORD *)v235 - 2);
          unsigned int v143 = *((_DWORD *)v235 + 2);
          float v144 = *(unsigned __int8 **)(*(void *)v225 + 48);
          if (!v144)
          {
            float v144 = (unsigned __int8 *)cmap_csr_set_create();
            *(void *)(*(void *)v225 + 48) = v144;
          }
          cmap_csr_set_add_codespace_range(v144, v141, v142, v143);
        }
        goto LABEL_230;
      case 21:
        float v145 = v235;
        unint64_t v146 = *(v235 - 2);
        if (v146 <= 2) {
          add_bf_range(*(uint64_t *)v225, v146, *(v235 - 1), *(v235 - 2), *(v235 - 1), v235);
        }
        float v133 = (void *)v145[1];
        goto LABEL_210;
      case 23:
        unint64_t v147 = *(v235 - 4);
        if (v147 == *(v235 - 2) && v147 <= 2) {
          add_bf_range(*(uint64_t *)v225, v147, *(v235 - 3), *(v235 - 4), *(v235 - 1), v235);
        }
        goto LABEL_209;
      case 24:
        unint64_t v154 = *(v235 - 8);
        if (v154 == *(v235 - 6) && v154 <= 2)
        {
          unint64_t v155 = *(v235 - 5);
          float v156 = v235 - 2;
          uint64_t v157 = -1;
          float v158 = v235 - 2;
          do
          {
            float v158 = (unint64_t *)*v158;
            ++v157;
          }
          while (v158);
          if (v157 + *((unsigned int *)v235 - 14) - 1 == v155)
          {
            float v159 = (void *)*v156;
            if (*v156)
            {
              do
              {
                add_bf_range(*(uint64_t *)v225, v154, v155, v154, v155, v159 + 1);
                unint64_t v155 = (v155 - 1) | v155 & 0xFFFFFFFF00000000;
                float v159 = (void *)*v159;
              }
              while (v159);
            }
          }
        }
        float v160 = (void **)*(v235 - 2);
        if (v160)
        {
          do
          {
            unsigned int v161 = (void **)*v160;
            free(v160[2]);
            free(v160);
            float v160 = v161;
          }
          while (v161);
        }
        goto LABEL_230;
      case 25:
        unint64_t v233 = 0;
        goto LABEL_211;
      case 26:
        float v162 = (char *)malloc_type_malloc(0x18uLL, 0x1030040CE42941AuLL);
        float v163 = v235;
        *(void *)float v162 = *(v235 - 2);
        long long v164 = *(_OWORD *)v163;
        unint64_t v233 = (unint64_t)v162;
        *(_OWORD *)(v162 + 8) = v164;
        goto LABEL_211;
      case 30:
        uint64_t v165 = *(v235 - 2);
        unsigned int v166 = *((_DWORD *)v235 - 2);
        int v167 = *(unsigned __int16 *)v235;
        uint64_t v168 = *(void *)(*(void *)v225 + 48);
        uint64_t v169 = v166;
        goto LABEL_236;
      case 32:
        uint64_t v165 = *(v235 - 4);
        if (v165 != *(v235 - 2)) {
          goto LABEL_211;
        }
        unsigned int v166 = *((_DWORD *)v235 - 6);
        uint64_t v169 = *((unsigned int *)v235 - 2);
        int v167 = *(unsigned __int16 *)v235;
        uint64_t v168 = *(void *)(*(void *)v225 + 48);
LABEL_236:
        cmap_add_cid_range(v168, v165, v166, v169, v167);
        goto LABEL_211;
      case 36:
        uint64_t v170 = *(v235 - 2);
        unsigned int v171 = *((_DWORD *)v235 - 2);
        int v172 = *(unsigned __int16 *)v235;
        uint64_t v173 = *(void *)(*(void *)v225 + 48);
        uint64_t v174 = v171;
        goto LABEL_240;
      case 38:
        uint64_t v170 = *(v235 - 4);
        if (v170 != *(v235 - 2)) {
          goto LABEL_211;
        }
        unsigned int v171 = *((_DWORD *)v235 - 6);
        uint64_t v174 = *((unsigned int *)v235 - 2);
        int v172 = *(unsigned __int16 *)v235;
        uint64_t v173 = *(void *)(*(void *)v225 + 48);
LABEL_240:
        cmap_add_notdef_range(v173, v170, v171, v174, v172);
        goto LABEL_211;
      case 39:
        unint64_t v175 = *v235;
        if (*v235 > 4)
        {
          float v218 = &v235[-2 * v121];
          unint64_t v31 = (unint64_t)&v231[-2 * v121];
          if (cmap_yydebug) {
            yy_stack_print((__int16 *)__src, v31);
          }
          unint64_t v233 = *(__int16 *)v31;
          float v219 = v240;
          unsigned int v32 = v218;
LABEL_314:
          int v196 = (int)v228;
          goto LABEL_317;
        }
        int v131 = 0;
        if (v175)
        {
          unsigned int v176 = (unsigned __int8 *)v235[1];
          do
          {
            int v177 = *v176++;
            int v131 = v177 | (v131 << 8);
            --v175;
          }
          while (v175);
        }
        free((void *)v235[1]);
        unint64_t v233 = *v235;
LABEL_211:
        if (cmap_yydebug)
        {
          fprintf(*v25, "%s ", "-> $$ =");
          float v148 = (FILE *)*MEMORY[0x1E4F143C8];
          uint64_t v149 = yyr1[v130];
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "nterm %s (", yytname[v149]);
          float v150 = v148;
          unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
          fputc(41, v150);
          fputc(10, *v25);
          int v151 = &v235[-2 * v31];
          unint64_t v31 = (unint64_t)&v231[-2 * v31];
          if (cmap_yydebug) {
            yy_stack_print((__int16 *)__src, v31);
          }
        }
        else
        {
          uint64_t v149 = yyr1[v130];
          int v151 = &v235[-2 * v31];
          unint64_t v31 = (unint64_t)&v231[-2 * v31];
        }
        int v152 = (int)v229;
        v151[2] = v233;
        unsigned int v32 = v151 + 2;
        *((_DWORD *)v32 + 2) = v131;
        *((_DWORD *)v32 + 3) = v152;
        uint64_t v153 = (*(__int16 *)v31 + yypgoto[v149 - 42]);
        int v29 = yy_def;
        uint64_t v30 = yy_meta;
        if (v153 <= 0x72 && *(unsigned __int16 *)v31 == (unsigned __int16)yycheck[v153]) {
          unint64_t v26 = yytable[v153];
        }
        else {
          unint64_t v26 = yydefgoto[v149 - 42];
        }
        unint64_t v27 = v232;
LABEL_220:
        v31 += 2;
        break;
      case 45:
      case 46:
        float v133 = (void *)*v235;
        goto LABEL_210;
      case 47:
LABEL_209:
        float v133 = (void *)v235[1];
LABEL_210:
        free(v133);
        goto LABEL_211;
      default:
        int v28 = "nterm %s (";
        uint64_t v7 = v227;
        unint64_t v31 = (unint64_t)yy_chk;
        int v131 = v230;
        if (v130 != 2) {
          goto LABEL_211;
        }
        float v219 = v240;
        int v220 = 1;
        unsigned int v32 = v235;
        goto LABEL_325;
    }
  }
  unint64_t v116 = yytable[v115];
  if (!yytable[v115]) {
    goto LABEL_302;
  }
  if (v115 != 8)
  {
    int v28 = v111;
    if (cmap_yydebug)
    {
      fprintf(*v25, "%s ", "Shifting");
      uint64_t v117 = (FILE *)*MEMORY[0x1E4F143C8];
      if (v224 >= 0x2A) {
        fprintf(v117, v111, yytname[v224]);
      }
      else {
        fprintf(v117, "token %s (");
      }
      int v118 = v117;
      unsigned int v25 = (FILE **)MEMORY[0x1E4F143C8];
      fputc(41, v118);
      fputc(10, *v25);
      uint64_t v30 = yy_meta;
      int v29 = yy_def;
    }
    if (v228) {
      int v119 = -2;
    }
    else {
      int v119 = 0;
    }
    LODWORD(v228) = v119;
    *((_OWORD *)v32 + 1) = v236;
    v32 += 2;
    unint64_t v26 = v116;
    goto LABEL_220;
  }
  float v231 = (char *)v31;
  LODWORD(v31) = 0;
  float v219 = v240;
  int v220 = 1;
LABEL_325:
  int v196 = (int)v228;
LABEL_326:
  if (v196 != -2 && v196) {
    yydestruct("Cleanup: discarding lookahead", v224, (void **)&v236);
  }
  float v202 = &v231[-2 * v31];
  uint64_t v203 = (char *)__src;
  if (cmap_yydebug) {
    yy_stack_print((__int16 *)__src, (unint64_t)&v231[-2 * v31]);
  }
  if (v202 != v203)
  {
    int v204 = (void **)&v32[-2 * v31];
    do
    {
      uint64_t v205 = *(__int16 *)v202;
      v202 -= 2;
      yydestruct("Cleanup: popping", yystos[v205], v204);
      v204 -= 2;
    }
    while (v202 != v203);
  }
  if (v203 != v239) {
    free(v203);
  }
  uint64_t v5 = *(void *)v225;
  if (v219 != v240) {
    free(v219);
  }
  if (*(void *)v7) {
    CFRelease(*(CFTypeRef *)v7);
  }
  unsigned int v206 = *(void ****)(v7 + 40);
  if (v206)
  {
    uint64_t v207 = *(void *)(v7 + 24);
    while (v206[v207])
    {
      cmap_yy_delete_buffer(v206[v207], v7);
      uint64_t v207 = *(void *)(v7 + 24);
      *(void *)(*(void *)(v7 + 40) + 8 * v207) = 0;
      unsigned int v206 = *(void ****)(v7 + 40);
      if (!v206) {
        break;
      }
      if (v206[v207])
      {
        cmap_yy_delete_buffer(v206[v207], v7);
        uint64_t v208 = *(void *)(v7 + 24);
        *(void *)(*(void *)(v7 + 40) + 8 * v208) = 0;
        if (v208)
        {
          uint64_t v207 = v208 - 1;
          *(void *)(v7 + 24) = v208 - 1;
        }
        else
        {
          uint64_t v207 = 0;
        }
        unsigned int v206 = *(void ****)(v7 + 40);
        if (!v206) {
          break;
        }
        float v209 = v206[v207];
        if (v209)
        {
          *(void *)(v7 + 56) = v209[4];
          float v210 = v209[2];
          *(void *)(v7 + 72) = v210;
          *(void *)(v7 + 136) = v210;
          *(void *)(v7 + 8) = *v206[v207];
          *(unsigned char *)(v7 + 48) = *v210;
          *(_DWORD *)(v7 + 88) = 1;
        }
      }
    }
  }
  free(v206);
  *(void *)(v7 + 40) = 0;
  free(*(void **)(v7 + 104));
  free((void *)v7);
  if (!v220)
  {
LABEL_360:
    cmap_release(v5);
    uint64_t v5 = 0;
    goto LABEL_361;
  }
  uint64_t v211 = *(void *)(v5 + 48);
  if (v211)
  {
    CFArrayRef v212 = *(const __CFArray **)(v211 + 8);
    if (v212)
    {
      CFIndex Count = CFArrayGetCount(v212);
      if (Count)
      {
        CFIndex v214 = Count;
        for (CFIndex i = 0; i != v214; ++i)
        {
          uint64_t v216 = *((void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v211 + 8), i) + 2);
          if (v216) {
            cmap_cid_set_normalize(v216);
          }
        }
      }
    }
  }
LABEL_361:
  free(v3);
  return v5;
}

uint64_t color_space_state_create_with_profile_sets(unint64_t a1, unint64_t theArray)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (!(a1 | theArray)) {
    return 0;
  }
  profile_from_set_f = (void *)a1;
  if (a1)
  {
    CFIndex v4 = 0;
  }
  else
  {
    CFIndex v4 = CFArrayGetCount((CFArrayRef)theArray) - 1;
    a1 = theArray;
  }
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, v4);
  if (!ValueAtIndex) {
    return 0;
  }
  Value = CFDictionaryGetValue(ValueAtIndex, @"ColorSyncProfile");
  if (profile_sets_get_number_of_components_cglibrarypredicate != -1) {
    dispatch_once(&profile_sets_get_number_of_components_cglibrarypredicate, &__block_literal_global_14_5405);
  }
  CFDataRef number_of_components_f = (const __CFData *)profile_sets_get_number_of_components_f(Value);
  uint64_t v8 = (uint64_t)number_of_components_f;
  if (number_of_components_f)
  {
    int v9 = *((_DWORD *)CFDataGetBytePtr(number_of_components_f) + 4);
    if (v9 > 1213421087)
    {
      if (v9 <= 1296255028)
      {
        if (v9 != 1213421088 && v9 != 1281450528 && v9 != 1282766368) {
          goto LABEL_101;
        }
        goto LABEL_41;
      }
      if (v9 <= 1380401695)
      {
        switch(v9)
        {
          case 1296255029:
            goto LABEL_19;
          case 1296255030:
            goto LABEL_59;
          case 1296255031:
            goto LABEL_60;
          case 1296255032:
            goto LABEL_61;
          default:
            goto LABEL_101;
        }
      }
      if (v9 == 1380401696 || v9 == 1501067552)
      {
LABEL_41:
        uint64_t v10 = 3;
        goto LABEL_42;
      }
      int v11 = 1482250784;
    }
    else
    {
      if (v9 <= 943934545)
      {
        if (v9 > 893602897)
        {
          switch(v9)
          {
            case 893602898:
LABEL_19:
              uint64_t v10 = 5;
              break;
            case 910380114:
LABEL_59:
              uint64_t v10 = 6;
              break;
            case 927157330:
LABEL_60:
              uint64_t v10 = 7;
              break;
            default:
              goto LABEL_101;
          }
LABEL_42:
          CFRelease((CFTypeRef)v8);
          uint64_t v14 = (char *)malloc_type_calloc(0x78uLL, 1uLL, 0xC37FA958uLL);
          uint64_t v8 = (uint64_t)v14;
          if (!v14) {
            return v8;
          }
          *(_DWORD *)uint64_t v14 = 1;
          *((_WORD *)v14 + 4) = 0;
          v14[10] = theArray != 0;
          *((void *)v14 + 3) = -4294967286;
          v14[11] = 0;
          *((void *)v14 + 6) = v10;
          uint64_t v22 = (uint64_t *)(v14 + 48);
          *((_WORD *)v14 + 7) = 0;
          *((void *)v14 + 14) = profile_sets_vtable;
          *((_DWORD *)v14 + 8) = -1;
          *((void *)v14 + 10) = 0;
          *((void *)v14 + 11) = 0;
          *((void *)v14 + 5) = icc_get_default_color_components(v10, v15, v16, v17, v18, v19, v20, v21);
          unsigned int v23 = (char *)malloc_type_calloc(0x90uLL, 1uLL, 0x2D9ADD68uLL);
          *(void *)(v8 + 96) = v23;
          if (!v23)
          {
            free((void *)v8);
            return 0;
          }
          unsigned int v24 = v23;
          if (profile_from_set_f) {
            CFTypeRef v25 = CFRetain(profile_from_set_f);
          }
          else {
            CFTypeRef v25 = 0;
          }
          *((void *)v24 + 1) = v25;
          if (theArray) {
            CFTypeRef v26 = CFRetain((CFTypeRef)theArray);
          }
          else {
            CFTypeRef v26 = 0;
          }
          *((void *)v24 + 2) = v26;
          if (profile_from_set_f)
          {
            CFTypeID v27 = CFGetTypeID(profile_from_set_f);
            if (v27 == CFArrayGetTypeID())
            {
              if (CFArrayGetCount((CFArrayRef)profile_from_set_f) < 2)
              {
                CFDictionaryRef v29 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)profile_from_set_f, 0);
                uint64_t v30 = (void *)CFDictionaryGetValue(v29, @"ColorSyncProfile");
                profile_from_set_f = v30;
                if (v30) {
                  CFRetain(v30);
                }
              }
              else
              {
                *(_OWORD *)keys = xmmword_1E52B36D0;
                *(_OWORD *)&keys[2] = *(_OWORD *)off_1E52B36E0;
                values[0] = @"concatenate";
                values[1] = profile_from_set_f;
                unsigned int v55 = @"scnr";
                int v56 = @"CG Platform Set Input Profile";
                CFDictionaryRef v28 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (create_profile_from_set_cglibrarypredicate != -1) {
                  dispatch_once(&create_profile_from_set_cglibrarypredicate, &__block_literal_global_64_5409);
                }
                profile_from_set_f = (void *)create_profile_from_set_f(v28);
                if (v28) {
                  CFRelease(v28);
                }
              }
            }
            else
            {
              profile_from_set_f = 0;
            }
          }
          if (color_space_state_create_with_profile_sets_cglibrarypredicate != -1) {
            dispatch_once(&color_space_state_create_with_profile_sets_cglibrarypredicate, &__block_literal_global_5410);
          }
          CFDataRef v31 = (const __CFData *)color_space_state_create_with_profile_sets_f(profile_from_set_f, 0);
          CGDataProviderRef v32 = CGDataProviderCreateWithCFData(v31);
          *(void *)unsigned int v24 = v32;
          if (v31)
          {
            CFRelease(v31);
            CGDataProviderRef v32 = *(CGDataProviderRef *)v24;
          }
          if (v32)
          {
            if (color_space_state_create_with_profile_sets_cglibrarypredicate_3 != -1) {
              dispatch_once(&color_space_state_create_with_profile_sets_cglibrarypredicate_3, &__block_literal_global_6_5411);
            }
            *((void *)v24 + 7) = color_space_state_create_with_profile_sets_f_2(profile_from_set_f);
            memcpy(keys, &CGICCProfileInfoInitializer, 0x128uLL);
            CGCMSUtilsGetICCProfileInfo(profile_from_set_f, (uint64_t)keys, 0, v33, v34, v35, v36, v37);
            if (profile_from_set_f) {
              CFRelease(profile_from_set_f);
            }
            int v38 = (int)keys[0];
            *(_DWORD *)(v8 + 28) = keys[0];
            *(_DWORD *)(v8 + 32) = v38;
            *(unsigned char *)(v8 + 12) = 0;
            *(_OWORD *)(v24 + 24) = *(_OWORD *)((char *)keys + 4);
            switch(v10)
            {
              case 4:
                CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
                break;
              case 3:
                CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceRGB();
                break;
              case 1:
                CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceGray();
                break;
              default:
                CGColorSpaceRef DeviceCMYK = 0;
                break;
            }
            *((void *)v24 + 6) = DeviceCMYK;
            size_t v40 = 16 * v10;
            int v41 = (char *)malloc_type_malloc(v40, 0x100004000313F17uLL);
            *((void *)v24 + 8) = v41;
            if (v41)
            {
              unint64_t v42 = 0;
              do
              {
                uint64_t v43 = &v41[v42];
                *(void *)uint64_t v43 = keys[v42 / 8 + 3];
                *((void *)v43 + 1) = keys[v42 / 8 + 4];
                v42 += 16;
              }
              while (v40 != v42);
              values[0] = 0;
              values[1] = 0;
              MD5 = CGDigesterCreateMD5();
              uint64_t v45 = MD5;
              if (MD5)
              {
                CC_MD5_Update(MD5, (const void *)(v8 + 24), 4u);
                CC_MD5_Update(v45, (const void *)(v8 + 48), 8u);
                uint64_t v46 = *(void *)(v8 + 96);
                CC_MD5_Update(v45, (const void *)(v46 + 24), 0x10u);
              }
              else
              {
                uint64_t v46 = *(void *)(v8 + 96);
              }
              if (*(void *)(v46 + 64))
              {
                uint64_t v47 = *v22;
                if ((*v22 & 0x7FFFFFFFFFFFFFFFLL) != 0)
                {
                  uint64_t v48 = 0;
                  unint64_t v49 = 0;
                  do
                  {
                    if (v45)
                    {
                      CC_MD5_Update(v45, (const void *)(*(void *)(v46 + 64) + v48), 8u);
                      uint64_t v47 = *v22;
                    }
                    ++v49;
                    v48 += 8;
                  }
                  while (v49 < 2 * v47);
                }
              }
              if (v45)
              {
                CC_MD5_Final((unsigned __int8 *)values, v45);
                long long v50 = *(_OWORD *)values;
              }
              else
              {
                long long v50 = 0uLL;
              }
              long long v52 = v50;
              free(v45);
              *(_OWORD *)(v8 + 64) = v52;
              return v8;
            }
          }
          else if (profile_from_set_f)
          {
            CFRelease(profile_from_set_f);
          }
          if (atomic_fetch_add_explicit((atomic_uint *volatile)v8, 0xFFFFFFFF, memory_order_relaxed) == 1) {
            color_space_state_dealloc(v8);
          }
          return 0;
        }
        if (v9 != 860048466)
        {
          if (v9 == 876825682) {
            goto LABEL_37;
          }
LABEL_101:
          CFRelease((CFTypeRef)v8);
          return 0;
        }
        goto LABEL_41;
      }
      if (v9 <= 1129142602)
      {
        if (v9 == 943934546)
        {
LABEL_61:
          uint64_t v10 = 8;
          goto LABEL_42;
        }
        int v11 = 1129142560;
      }
      else
      {
        if (v9 == 1129142603)
        {
LABEL_37:
          uint64_t v10 = 4;
          goto LABEL_42;
        }
        if (v9 == 1196573017)
        {
          uint64_t v10 = 1;
          goto LABEL_42;
        }
        int v11 = 1212961568;
      }
    }
    if (v9 != v11) {
      goto LABEL_101;
    }
    goto LABEL_41;
  }
  return v8;
}

uint64_t (*__color_space_state_create_with_profile_sets_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyDescriptionString");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_5417;
  }
  color_space_state_create_with_profile_sets_f_2 = (uint64_t (*)(void))v1;
  return result;
}

uint64_t colorsync_smart_null_5417()
{
  return 0;
}

uint64_t (*__color_space_state_create_with_profile_sets_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyData");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_5417;
  }
  color_space_state_create_with_profile_sets_f = (uint64_t (*)(void, void))v1;
  return result;
}

uint64_t (*__create_profile_from_set_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncMakeProfile");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_5417;
  }
  create_profile_from_set_f = (uint64_t (*)(void))v1;
  return result;
}

__CFString *copy_debug_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v8 = *(void *)(a1 + 24);
    if (*(_DWORD *)(v8 + 24) != 10) {
      _CGHandleAssert("copy_debug_description", 70, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ProfileSets.c", "space->state->type == kCGColorSpaceProfileSets", "type %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
    }
    uint64_t v9 = *(void *)(v8 + 96);
    if (v9)
    {
      if (*(void *)(v9 + 8) && os_variant_has_internal_content())
      {
        Mutable = CFStringCreateMutable(0, 0);
        int v11 = 0;
        uint64_t v12 = 0;
        for (char i = 1; ; char i = 0)
        {
          char v14 = i;
          uint64_t v15 = v9 + 8 * v12;
          CFArrayRef v16 = *(const __CFArray **)(v15 + 8);
          if (v16)
          {
            uint64_t v17 = off_1E52B36A0[v12];
            CFTypeID v18 = CFGetTypeID(*(CFTypeRef *)(v15 + 8));
            if (v18 == CFArrayGetTypeID())
            {
              CFIndex Count = CFArrayGetCount(v16);
              uint64_t v20 = Count;
              uint64_t v21 = "profiles";
              if (Count == 1) {
                uint64_t v21 = "profile";
              }
              CFStringAppendFormat(Mutable, 0, @"\n\t\t%ld %s in %s set:\n\t\t\t", Count, v21, v17);
              int v11 = Mutable;
              if (v20 >= 1) {
                break;
              }
            }
          }
LABEL_28:
          uint64_t v12 = 1;
          if ((v14 & 1) == 0) {
            return v11;
          }
        }
        CFIndex v22 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, v22);
          if (ValueAtIndex)
          {
            CFDictionaryRef v24 = ValueAtIndex;
            CFTypeID v25 = CFGetTypeID(ValueAtIndex);
            CFTypeID TypeID = CFDictionaryGetTypeID();
            CFStringRef v27 = @";?;";
            if (v25 == TypeID)
            {
              Value = CFDictionaryGetValue(v24, @"ColorSyncProfile");
              if (copy_debug_description_cglibrarypredicate != -1) {
                dispatch_once(&copy_debug_description_cglibrarypredicate, &__block_literal_global_31_5449);
              }
              CFDictionaryRef v29 = (__CFString *)copy_debug_description_f(Value);
              uint64_t v30 = v29;
              CFStringRef v31 = v29 ? v29 : @"no profile description";
              CFStringAppend(Mutable, v31);
              if (v30) {
                CFRelease(v30);
              }
              CFStringRef v27 = @"; ";
              if (v22 >= v20 - 1) {
                goto LABEL_26;
              }
            }
          }
          else
          {
            CFStringRef v27 = @";?;";
          }
          CFStringAppend(Mutable, v27);
LABEL_26:
          if (v20 == ++v22)
          {
            int v11 = Mutable;
            goto LABEL_28;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t (*__copy_debug_description_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyDescriptionString");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_5417;
  }
  copy_debug_description_f = (uint64_t (*)(void))v1;
  return result;
}

CFTypeRef profile_sets_create_icc_profile_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v8 + 24) != 10) {
    _CGHandleAssert("profile_sets_create_icc_profile_description", 122, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ProfileSets.c", "space->state->type == kCGColorSpaceProfileSets", "type %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
  }
  uint64_t v9 = *(void *)(v8 + 96);
  uint64_t v10 = *(const void **)(v9 + 40);
  if (!v10)
  {
    if (*(void *)(v9 + 56)) {
      int v11 = *(__CFString **)(v9 + 56);
    }
    else {
      int v11 = @"<no description>";
    }
    CFTypeRef v12 = CFRetain(v11);
    uint64_t v13 = 0;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v9 + 40), (unint64_t *)&v13, (unint64_t)v12, memory_order_relaxed, memory_order_relaxed);
    if (v13 && v12) {
      CFRelease(v12);
    }
    uint64_t v10 = *(const void **)(v9 + 40);
    if (!v10) {
      return 0;
    }
  }

  return CFRetain(v10);
}

uint64_t profile_sets_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

void profile_sets_finalize(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 96);
  if (v1)
  {
    CGDataProviderRelease(*(CGDataProviderRef *)v1);
    uint64_t v2 = *(const void **)(v1 + 8);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = *(const void **)(v1 + 16);
    if (v3) {
      CFRelease(v3);
    }
    CFIndex v4 = *(const void **)(v1 + 40);
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = *(const void **)(v1 + 48);
    if (v5) {
      CFRelease(v5);
    }
    int8x8_t v6 = *(const void **)(v1 + 56);
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = *(void **)(v1 + 64);
    free(v7);
  }
}

uint64_t (*__profile_sets_get_number_of_components_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyHeader");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_5417;
  }
  profile_sets_get_CFDataRef number_of_components_f = (uint64_t (*)(void))v1;
  return result;
}

CGColorSpaceRef CGColorSpaceConcatenate(CGColorSpace *a1, uint64_t a2, CGColorSpace *a3)
{
  uint64_t Pattern = 0;
  if (!a3) {
    return (CGColorSpaceRef)Pattern;
  }
  CFIndex v4 = a1;
  if (!a1) {
    return (CGColorSpaceRef)Pattern;
  }
  while (1)
  {
    unsigned int Type = CGColorSpaceGetType(a3);
    if (Type < 0xA && ((0x387u >> Type) & 1) != 0) {
      return 0;
    }
    unsigned int v8 = CGColorSpaceGetType(v4);
    if (v8 != 8) {
      break;
    }
    uint64_t v9 = *((void *)v4 + 3);
    int v10 = *(_DWORD *)(v9 + 24);
    switch(v10)
    {
      case 6:
        int v11 = (CGColorSpace **)(*(void *)(v9 + 96) + 56);
        break;
      case 10:
        int v11 = (CGColorSpace **)(*(void *)(v9 + 96) + 48);
        break;
      case 8:
        int v11 = (CGColorSpace **)(*(void *)(v9 + 96) + 8);
        break;
      default:
        return 0;
    }
    CFIndex v4 = *v11;
    if (!*v11) {
      return 0;
    }
  }
  uint64_t Pattern = 0;
  if (v8 > 0xB) {
    return (CGColorSpaceRef)Pattern;
  }
  if (((1 << v8) & 0xC78) != 0)
  {
    CFArrayRef ProfileSetForColorSpace = CGCMSUtilsCreateProfileSetForColorSpace(v4, @"ColorSyncTransformDeviceToPCS", 0, 0, *(unsigned __int8 *)(*((void *)v4 + 3) + 13), 0);
    CFArrayRef v13 = CGCMSUtilsCreateProfileSetForColorSpace(a3, @"ColorSyncTransformPCSToPCS", 0, 0, *(unsigned __int8 *)(*((void *)a3 + 3) + 13), 0);
    char v14 = concatenate_sets(ProfileSetForColorSpace, v13);
    if (ProfileSetForColorSpace) {
      CFRelease(ProfileSetForColorSpace);
    }
    if (v13) {
      CFRelease(v13);
    }
    CFArrayRef v15 = CGCMSUtilsCreateProfileSetForColorSpace(a3, @"ColorSyncTransformPCSToPCS", 0, 0, *(unsigned __int8 *)(*((void *)a3 + 3) + 13), 1u);
    CFArrayRef v16 = CGCMSUtilsCreateProfileSetForColorSpace(v4, @"ColorSyncTransformPCSToDevice", 0, 0, *(unsigned __int8 *)(*((void *)v4 + 3) + 13), 1u);
    uint64_t v17 = concatenate_sets(v15, v16);
    if (v15) {
      CFRelease(v15);
    }
    if (v16) {
      CFRelease(v16);
    }
    CFTypeID v25 = (atomic_uint *)color_space_state_create_with_profile_sets((unint64_t)v14, (unint64_t)v17);
    if (v14) {
      CFRelease(v14);
    }
    if (v17) {
      CFRelease(v17);
    }
    uint64_t Pattern = CGColorSpaceCreateWithState(v25, v18, v19, v20, v21, v22, v23, v24);
    if (v25)
    {
      if (atomic_fetch_add_explicit(v25, 0xFFFFFFFF, memory_order_relaxed) == 1) {
        color_space_state_dealloc((uint64_t)v25);
      }
    }
    return (CGColorSpaceRef)Pattern;
  }
  if (v8 != 7)
  {
    if (v8 != 9) {
      return (CGColorSpaceRef)Pattern;
    }
    uint64_t v26 = *((void *)v4 + 3);
    if ((*(_DWORD *)(v26 + 28) - 5) <= 1)
    {
      uint64_t v27 = **(void **)(v26 + 96);
      if (v27)
      {
        CFDictionaryRef v28 = (CGColorSpace *)CGColorSpaceConcatenate(v27, a2, a3);
        uint64_t Pattern = (uint64_t)CGColorSpaceCreatePattern(v28);
        if (v28) {
          CFRelease(v28);
        }
        return (CGColorSpaceRef)Pattern;
      }
    }
    return 0;
  }
  uint64_t v29 = *((void *)v4 + 3);
  if ((*(_DWORD *)(v29 + 28) - 5) > 1) {
    uint64_t v30 = 0;
  }
  else {
    uint64_t v30 = **(void **)(v29 + 96);
  }
  uint64_t v31 = CGColorSpaceConcatenate(v30, a2, a3);
  if (!v31) {
    return 0;
  }
  CGDataProviderRef v32 = (CGColorSpace *)v31;
  CFDataRef v33 = CGColorSpaceCopyColorTable((uint64_t)v4);
  CFDataRef v34 = v33;
  uint64_t v35 = *((void *)v4 + 3);
  if (*(_DWORD *)(v35 + 28) == 5) {
    size_t v36 = *(void *)(*(void *)(v35 + 96) + 8);
  }
  else {
    size_t v36 = -1;
  }
  BytePtr = CFDataGetBytePtr(v33);
  CGColorSpaceRef Indexed = CGColorSpaceCreateIndexed(v32, v36, BytePtr);
  CFRelease(v34);
  CFRelease(v32);
  return Indexed;
}

__CFArray *concatenate_sets(const __CFArray *a1, const __CFArray *a2)
{
  if (!((unint64_t)a1 | (unint64_t)a2)) {
    return 0;
  }
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    if (a1)
    {
      v6.length = CFArrayGetCount(a1);
      v6.location = 0;
      CFArrayAppendArray(Mutable, a1, v6);
    }
    if (a2)
    {
      v7.length = CFArrayGetCount(a2);
      v7.location = 0;
      CFArrayAppendArray(Mutable, a2, v7);
    }
  }
  return Mutable;
}

const void *CGColorSpaceProfileSetsGetDestinationProfile(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v1 + 24) != 10) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 96);
  CFArrayRef v3 = *(const __CFArray **)(v2 + 16);
  if (!v3) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(*(CFTypeRef *)(v2 + 16));
  if (v4 != CFArrayGetTypeID()) {
    return 0;
  }
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, 0);
  if (!ValueAtIndex) {
    return 0;
  }
  CFDictionaryRef v6 = ValueAtIndex;
  CFTypeID v7 = CFGetTypeID(ValueAtIndex);
  if (v7 != CFDictionaryGetTypeID()) {
    return 0;
  }

  return CFDictionaryGetValue(v6, @"ColorSyncProfile");
}

uint64_t device_gray_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t device_rgb_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t device_cmyk_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t CGSCombineDeepMaskToDeepMask(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8)
{
  if (a8 < 1) {
    return 0xFFFFFFFFLL;
  }
  int v9 = 0;
  uint64_t result = 0;
  do
  {
    if (a7 >= 1)
    {
      uint64_t v11 = 0;
      unsigned int v12 = a7 + 1;
      do
      {
        unsigned int v13 = *(unsigned __int16 *)(a1 + 2 * v11);
        int v14 = *(unsigned __int8 *)(a3 + v11);
        v9 |= v14;
        unsigned int v15 = ((((v13 >> 5) & 0x1F) * v14 + ((((v13 >> 5) & 0x1F) * v14) >> 8) + 1) >> 3) & 0x3E0 | (((v13 & 0x1F) * v14 + (((v13 & 0x1F) * v14) >> 8) + 1) >> 8) | (4 * (((*(_WORD *)(a1 + 2 * v11) >> 10) & 0x1F) * (_WORD)v14 + (unsigned __int16)((((v13 >> 10) & 0x1F) * v14) >> 8)) + 4) & 0x7C00;
        uint64_t result = v15 ^ v13 | result;
        *(_WORD *)(a5 + 2 * v11) = v15;
        --v12;
        ++v11;
      }
      while (v12 > 1);
    }
    a5 += a6;
    a1 += a2;
    a3 += a4;
  }
  while (a8-- > 1);
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CGSCombineDeepMask(char *a1, int a2, char *a3, int a4, int a5, int a6, unsigned int a7)
{
  int v9 = a2;
  int v10 = a1;
  unsigned int v11 = HIBYTE(a7);
  if (a5 == 1)
  {
    unsigned int v12 = BYTE1(a7) + v11;
    unsigned int v13 = 255;
    if (v12 <= 0xFE) {
      unsigned int v14 = 255 - v12;
    }
    else {
      unsigned int v14 = 0;
    }
    int v15 = v14 > 0xFE;
  }
  else
  {
    if (a5 < 2) {
      return 0;
    }
    unsigned int v14 = v11 ^ 0xFF;
    unsigned int v13 = BYTE1(a7) ^ 0xFF;
    if (v11) {
      int v16 = -2;
    }
    else {
      int v16 = -1;
    }
    int v17 = v16 + a5;
    if (BYTE1(a7)) {
      int v15 = v17;
    }
    else {
      int v15 = v17 + 1;
    }
  }
  if (a6 != 1)
  {
    if (a6 >= 2)
    {
      unsigned int v20 = BYTE2(a7) ^ 0xFF;
      unsigned int v19 = a7 ^ 0xFF;
      if ((_BYTE)a7) {
        int v22 = -2;
      }
      else {
        int v22 = -1;
      }
      int v23 = v22 + a6;
      if (BYTE2(a7)) {
        int v21 = v23;
      }
      else {
        int v21 = v23 + 1;
      }
      goto LABEL_25;
    }
    return 0;
  }
  unsigned int v18 = BYTE2(a7) + a7;
  unsigned int v19 = 255;
  if (v18 <= 0xFE) {
    unsigned int v20 = 255 - v18;
  }
  else {
    unsigned int v20 = 0;
  }
  int v21 = v20 > 0xFE;
LABEL_25:
  if (a1 != a3 || a2 != a4)
  {
    CGBlt_copyBytes(2 * a5, a6, a1, a3, a2, a4);
    int v9 = a4;
    int v10 = a3;
  }
  if (v20 <= 0xFE)
  {
    uint64_t v24 = a3;
    CFTypeID v25 = v10;
    if (v14 <= 0xFE)
    {
      CFTypeID v25 = v10 + 2;
      unsigned int v26 = *(unsigned __int16 *)v10;
      unsigned int v27 = (v20 * v14 + ((v20 * v14) >> 8) + 1) >> 8;
      *(_WORD *)a3 = ((((v26 >> 5) & 0x1F) * v27 + ((((v26 >> 5) & 0x1F) * v27) >> 8) + 1) >> 3) & 0x3E0 | (((v26 & 0x1F) * v27 + (((v26 & 0x1F) * v27) >> 8) + 1) >> 8) | (4 * (((v26 >> 10) & 0x1F) * v27 + ((((v26 >> 10) & 0x1F) * v27) >> 8)) + 4) & 0x7C00;
      uint64_t v24 = a3 + 2;
    }
    if (v15)
    {
      unsigned int v28 = v15 + 1;
      do
      {
        unsigned int v29 = *(unsigned __int16 *)v25;
        v25 += 2;
        *(_WORD *)uint64_t v24 = ((((v29 >> 5) & 0x1F) * v20 + ((((v29 >> 5) & 0x1F) * v20) >> 8) + 1) >> 3) & 0x3E0 | (((v29 & 0x1F) * v20 + (((v29 & 0x1F) * v20) >> 8) + 1) >> 8) & 0x1F | (4 * (((v29 >> 10) & 0x1F) * v20 + ((((v29 >> 10) & 0x1F) * v20) >> 8)) + 4) & 0x7C00;
        v24 += 2;
        --v28;
      }
      while (v28 > 1);
    }
    if (v13 <= 0xFE)
    {
      unsigned int v30 = *(unsigned __int16 *)v25;
      unsigned int v31 = (v20 * v13 + ((v20 * v13) >> 8) + 1) >> 8;
      *(_WORD *)uint64_t v24 = ((((v30 >> 5) & 0x1F) * v31 + ((((v30 >> 5) & 0x1F) * v31) >> 8) + 1) >> 3) & 0x3E0 | (((v30 & 0x1F) * v31 + (((v30 & 0x1F) * v31) >> 8) + 1) >> 8) & 0x1F | (4 * (((v30 >> 10) & 0x1F) * v31 + ((((v30 >> 10) & 0x1F) * v31) >> 8)) + 4) & 0x7C00;
    }
    v10 += v9;
    a3 += a4;
  }
  if (v21 >= 1)
  {
    CGDataProviderRef v32 = (unsigned __int16 *)v10;
    CFDataRef v33 = a3;
    if (v14 <= 0xFE)
    {
      unsigned int v34 = v21 + 1;
      uint64_t v35 = (unsigned __int16 *)v10;
      size_t v36 = a3;
      do
      {
        unsigned int v37 = *v35;
        uint64_t v35 = (unsigned __int16 *)((char *)v35 + v9);
        *size_t v36 = ((((v37 >> 5) & 0x1F) * v14 + ((((v37 >> 5) & 0x1F) * v14) >> 8) + 1) >> 3) & 0x3E0 | (((v37 & 0x1F) * v14 + (((v37 & 0x1F) * v14) >> 8) + 1) >> 8) & 0x1F | (4 * (((v37 >> 10) & 0x1F) * v14 + ((((v37 >> 10) & 0x1F) * v14) >> 8)) + 4) & 0x7C00;
        size_t v36 = (_WORD *)((char *)v36 + a4);
        --v34;
      }
      while (v34 > 1);
      CGDataProviderRef v32 = (unsigned __int16 *)(v10 + 2);
      CFDataRef v33 = a3 + 2;
    }
    if (v13 <= 0xFE)
    {
      unsigned int v38 = v15 & ~(v15 >> 31);
      int64_t v39 = &v33[2 * v38];
      int v40 = v21 + 1;
      int v41 = &v32[v38];
      do
      {
        unsigned int v42 = *v41;
        int v41 = (unsigned __int16 *)((char *)v41 + v9);
        *(_WORD *)int64_t v39 = ((((v42 >> 5) & 0x1F) * v13 + ((((v42 >> 5) & 0x1F) * v13) >> 8) + 1) >> 3) & 0x3E0 | (((v42 & 0x1F) * v13 + (((v42 & 0x1F) * v13) >> 8) + 1) >> 8) & 0x1F | (4 * (((v42 >> 10) & 0x1F) * v13 + ((((v42 >> 10) & 0x1F) * v13) >> 8)) + 4) & 0x7C00;
        v39 += a4;
        --v40;
      }
      while (v40 > 1);
    }
    v10 += v9 * v21;
    a3 += v21 * a4;
  }
  if (v19 <= 0xFE)
  {
    if (v14 <= 0xFE)
    {
      unsigned int v43 = *(unsigned __int16 *)v10;
      v10 += 2;
      unsigned int v44 = (v19 * v14 + ((v19 * v14) >> 8) + 1) >> 8;
      *(_WORD *)a3 = ((((v43 >> 5) & 0x1F) * v44 + ((((v43 >> 5) & 0x1F) * v44) >> 8) + 1) >> 3) & 0x3E0 | (((v43 & 0x1F) * v44 + (((v43 & 0x1F) * v44) >> 8) + 1) >> 8) | (4 * (((v43 >> 10) & 0x1F) * v44 + ((((v43 >> 10) & 0x1F) * v44) >> 8)) + 4) & 0x7C00;
      a3 += 2;
    }
    if (v15 >= 1)
    {
      unsigned int v45 = v15 + 1;
      do
      {
        unsigned int v46 = *(unsigned __int16 *)v10;
        v10 += 2;
        *(_WORD *)a3 = ((((v46 >> 5) & 0x1F) * v19 + ((((v46 >> 5) & 0x1F) * v19) >> 8) + 1) >> 3) & 0x3E0 | (((v46 & 0x1F) * v19 + (((v46 & 0x1F) * v19) >> 8) + 1) >> 8) & 0x1F | (4 * (((v46 >> 10) & 0x1F) * v19 + ((((v46 >> 10) & 0x1F) * v19) >> 8)) + 4) & 0x7C00;
        a3 += 2;
        --v45;
      }
      while (v45 > 1);
    }
    if (v13 <= 0xFE)
    {
      unsigned int v47 = *(unsigned __int16 *)v10;
      unsigned int v48 = (v19 * v13 + ((v19 * v13) >> 8) + 1) >> 8;
      *(_WORD *)a3 = ((((v47 >> 5) & 0x1F) * v48 + ((((v47 >> 5) & 0x1F) * v48) >> 8) + 1) >> 3) & 0x3E0 | (((v47 & 0x1F) * v48 + (((v47 & 0x1F) * v48) >> 8) + 1) >> 8) & 0x1F | (4 * (((v47 >> 10) & 0x1F) * v48 + ((((v47 >> 10) & 0x1F) * v48) >> 8)) + 4) & 0x7C00;
    }
  }
  return 1;
}

char *CGClipMaskCreate(const CGAffineTransform *a1, const void *a2, double a3, double a4, double a5, double a6)
{
  if (!a2) {
    return 0;
  }
  unsigned int v12 = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
  unsigned int v13 = v12;
  *(_DWORD *)unsigned int v12 = 1;
  unsigned int v14 = &CGAffineTransformIdentity;
  if (a1) {
    unsigned int v14 = a1;
  }
  long long v16 = *(_OWORD *)&v14->c;
  long long v15 = *(_OWORD *)&v14->tx;
  *(_OWORD *)(v12 + 8) = *(_OWORD *)&v14->a;
  *(_OWORD *)(v12 + 24) = v16;
  *(_OWORD *)(v12 + 40) = v15;
  CFRetain(a2);
  *((void *)v13 + 7) = a2;
  *((double *)v13 + 8) = a3;
  *((double *)v13 + 9) = a4;
  *((double *)v13 + 10) = a5;
  *((double *)v13 + 11) = a6;
  return v13;
}

atomic_uint *CGClipMaskCreateCopy(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

atomic_uint *CGClipMaskRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

char *CGClipMaskCreateCopyByApplyingTransform(char *result, double *a2)
{
  if (result)
  {
    if (a2)
    {
      double v2 = *((double *)result + 1);
      double v3 = *((double *)result + 2);
      double v4 = *((double *)result + 3);
      double v5 = *((double *)result + 4);
      double v6 = *((double *)result + 5);
      double v7 = *((double *)result + 6);
      double v8 = *a2;
      double v9 = a2[1];
      double v10 = a2[2];
      double v11 = a2[3];
      double v12 = a2[4];
      double v13 = a2[5];
      v14.a = v3 * v10 + v2 * *a2;
      v14.b = v3 * v11 + v2 * v9;
      v14.c = v5 * v10 + v4 * v8;
      v14.d = v5 * v11 + v4 * v9;
      v14.tx = v12 + v10 * v7 + v6 * v8;
      v14.ty = v11 * v7 + v6 * v9 + v13;
      return CGClipMaskCreate(&v14, *((const void **)result + 7), *((double *)result + 8), *((double *)result + 9), *((double *)result + 10), *((double *)result + 11));
    }
    else
    {
      atomic_fetch_add_explicit((atomic_uint *volatile)result, 1u, memory_order_relaxed);
    }
  }
  return result;
}

BOOL CGClipMaskEqualToClipMask(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 56) != *(void *)(a2 + 56)) {
      return 0;
    }
    BOOL result = CGRectEqualToRect(*(CGRect *)(a1 + 64), *(CGRect *)(a2 + 64));
    if (result)
    {
      if (*(double *)(a1 + 8) != *(double *)(a2 + 8)) {
        return 0;
      }
      return vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 16), *(float64x2_t *)(a2 + 16)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)(a2 + 32)))), 0xFuLL))) & (*(double *)(a1 + 48) == *(double *)(a2 + 48));
    }
  }
  return result;
}

__n128 CGClipMaskGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double v2 = (const CGAffineTransform *)(a1 + 8);
  if (!a1) {
    double v2 = &CGAffineTransformIdentity;
  }
  long long v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CGClipMaskGetImage(uint64_t result)
{
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

CGFloat CGClipMaskGetRect(const CGRect *a1)
{
  uint64_t v1 = &CGRectNull;
  if (a1) {
    uint64_t v1 = a1 + 2;
  }
  return v1->origin.x;
}

uint64_t __CGSRegionEnumeratorGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGSRegionEnumeratorGetTypeID_region_enumerator_class);
  CGSRegionEnumeratorGetTypeID_region_enumerator_type_id = result;
  return result;
}

CFStringRef region_enumerator_copy_debug_description(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CGSRegionEnumerator %p>", a1);
}

CFStringRef region_enumerator_copy_format_description(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<CGSRegionEnumerator %p>", a1);
}

void region_enumerator_finalize(void *a1)
{
  CFAllocatorRef v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  long long v3 = (void *)a1[3];
  if (v3) {
    free(v3);
  }
  CFAllocatorRef v4 = (void *)a1[4];
  if (v4)
  {
    free(v4);
  }
}

void *CGSRegionEnumerator(_DWORD **a1)
{
  return CGSRegionEnumeratorWithDirection(a1, 0, 0);
}

void *CGSRegionEnumeratorWithDirection(_DWORD **a1, int a2, int a3)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v13 = CFGetTypeID(a1);
  if (CGRegionGetTypeID_initOnce != -1) {
    dispatch_once(&CGRegionGetTypeID_initOnce, &__block_literal_global_14714);
  }
  if (v13 != __kCGRegionTypeID)
  {
    CFTypeID v17 = CFGetTypeID(a1);
    CFStringRef v18 = CFCopyTypeIDDescription(v17);
    char CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
    _CGHandleAssert("CGSRegionEnumeratorWithDirection", 108, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "CFGetTypeID(region) == CGRegionGetTypeID()", "CFType %s %p is not a CGRegion", v20, v21, v22, CStringPtr);
  }
  CGAffineTransform v14 = (void *)CGSRegionEnumeratorCreate(a1, v6, v7, v8, v9, v10, v11, v12);
  shape_enum_alloc((uint64_t)v14, a1[2], a3, a2);
  v14[3] = v15;
  if (!v15)
  {
    CGSReleaseRegionEnumerator(v14);
    return 0;
  }
  return v14;
}

uint64_t CGSRegionEnumeratorCreate(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_block_invoke_once_5494 != -1) {
    dispatch_once(&_block_invoke_once_5494, &__block_literal_global_5_5495);
  }
  uint64_t Instance = CGTypeCreateInstance(CGSRegionEnumeratorGetTypeID_region_enumerator_type_id, 56, a3, a4, a5, a6, a7, a8);
  if (a1) {
    CFRetain(a1);
  }
  *(void *)(Instance + 24) = 0;
  *(void *)(Instance + 32) = 0;
  *(void *)(Instance + 16) = a1;
  *(CGRect *)(Instance + 40) = CGRectNull;
  return Instance;
}

uint64_t CGSReleaseRegionEnumerator(const void *a1)
{
  if (a1)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (_block_invoke_once_5494 != -1) {
      dispatch_once(&_block_invoke_once_5494, &__block_literal_global_5_5495);
    }
    if (v5 != CGSRegionEnumeratorGetTypeID_region_enumerator_type_id) {
      _CGHandleAssert("CGSReleaseRegionEnumerator", 165, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "REGION_IS_REGION_ENUM(e)", "enumerator: %p", v2, v3, v4, (char)a1);
    }
    CFRelease(a1);
  }
  return 0;
}

uint64_t CGSRegionPathEnumerator(void *a1)
{
  CFTypeID v9 = CFGetTypeID(a1);
  if (CGRegionGetTypeID_initOnce != -1) {
    dispatch_once(&CGRegionGetTypeID_initOnce, &__block_literal_global_14714);
  }
  if (v9 != __kCGRegionTypeID)
  {
    CFTypeID v27 = CFGetTypeID(a1);
    CFStringRef v28 = CFCopyTypeIDDescription(v27);
    char CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
    _CGHandleAssert("CGSRegionPathEnumerator", 124, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "CFGetTypeID(region) == CGRegionGetTypeID()", "CFType %s %p is not a CGRegion", v30, v31, v32, CStringPtr);
  }
  uint64_t v10 = CGSRegionEnumeratorCreate(a1, v2, v3, v4, v5, v6, v7, v8);
  uint64_t v11 = (_DWORD *)a1[2];
  if (v11 && *v11 == 0x80000000 && (uint64_t v12 = v11[1], (int)v12 >= 1))
  {
    if (v11 == (_DWORD *)&the_empty_shape || v11[v12] == 0x7FFFFFFF)
    {
      CFTypeID v13 = malloc_type_malloc(0x200uLL, 0x705560E0uLL);
      if (v13)
      {
        v13[8] = 0;
        *(void *)CFTypeID v13 = 0;
        *((void *)v13 + 1) = 0;
      }
    }
    else
    {
      int v15 = 0;
      long long v16 = v11;
      do
      {
        uint64_t v17 = (int)v16[1];
        int v15 = v15 + v17 - 2;
        v16 += v17;
      }
      while (*v16 != 0x7FFFFFFF);
      CFTypeID v13 = malloc_type_malloc((32 * v15 + 551) & 0xFFFFFFFFFFFFFE00, 0x705560E0uLL);
      if (v13)
      {
        CFStringRef v18 = (char *)(v13 + 10);
        *(void *)CFTypeID v13 = v13 + 10;
        *((void *)v13 + 1) = v13 + 10;
        v13[8] = 0;
        *((void *)v13 + 2) = 0x8000000080000000;
        unsigned int v19 = &v11[v11[1]];
        int v20 = *v19;
        if (*v19 != 0x7FFFFFFF)
        {
          uint64_t v21 = 0;
          do
          {
            int v22 = v20;
            uint64_t v23 = v19[1];
            uint64_t v24 = &v19[v23];
            int v20 = *v24;
            if ((int)v23 >= 3)
            {
              CFTypeID v25 = v19 + 2;
              do
              {
                int v26 = v25[1];
                *((_DWORD *)v18 + 4) = *v25;
                *((_DWORD *)v18 + 5) = v20;
                *(void *)CFStringRef v18 = v21;
                *((_DWORD *)v18 + 6) = v22;
                *((_DWORD *)v18 + 7) = 0;
                if (v21) {
                  *((void *)v21 + 1) = v18;
                }
                uint64_t v21 = v18 + 32;
                *((_DWORD *)v18 + 12) = v26;
                *((_DWORD *)v18 + 13) = v22;
                *((void *)v18 + 4) = v18;
                *((void *)v18 + 5) = 0;
                *((_DWORD *)v18 + 14) = v20;
                *((_DWORD *)v18 + 15) = 0;
                *((void *)v18 + 1) = v18 + 32;
                v18 += 64;
                v25 += 2;
              }
              while (v25 < v24);
              uint64_t v21 = v18 - 32;
            }
            unsigned int v19 = v24;
          }
          while (v20 != 0x7FFFFFFF);
        }
      }
    }
  }
  else
  {
    CFTypeID v13 = 0;
  }
  *(void *)(v10 + 32) = v13;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 56) = 0u;
  return v10;
}

double *CGSNextRect(double *cf)
{
  uint64_t v1 = cf;
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (_block_invoke_once_5494 != -1) {
      dispatch_once(&_block_invoke_once_5494, &__block_literal_global_5_5495);
    }
    if (v5 != CGSRegionEnumeratorGetTypeID_region_enumerator_type_id || (uint64_t v6 = *((void *)v1 + 3)) == 0) {
      _CGHandleAssert("CGSNextRect", 138, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "REGION_IS_REGION_ENUM(e) && e->shape_enumerator != NULL", "enumerator: %p", v2, v3, v4, (char)v1);
    }
    int v13 = 0;
    int v12 = 0;
    uint64_t v11 = 0;
    if (shape_enum_next(v6, &v13, &v12, (_DWORD *)&v11 + 1, &v11))
    {
      double v7 = (double)v12;
      double v8 = (double)(HIDWORD(v11) - v13);
      double v9 = (double)((int)v11 - v12);
      v1[5] = (double)v13;
      v1[6] = v7;
      v1 += 5;
      v1[2] = v8;
      v1[3] = v9;
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t CGSNextPoint(uint64_t result, double *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v7 = CFGetTypeID((CFTypeRef)result);
    if (_block_invoke_once_5494 != -1) {
      dispatch_once(&_block_invoke_once_5494, &__block_literal_global_5_5495);
    }
    if (v7 != CGSRegionEnumeratorGetTypeID_region_enumerator_type_id || (double v8 = *(uint64_t **)(v3 + 32)) == 0) {
      _CGHandleAssert("CGSNextPoint", 152, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "REGION_IS_REGION_ENUM(e) && e->path_enumerator != NULL", "enumerator: %p", v4, v5, v6, v3);
    }
    if (*((_DWORD *)v8 + 8))
    {
      int v9 = *((_DWORD *)v8 + 6);
      int v10 = *((_DWORD *)v8 + 7);
      *((_DWORD *)v8 + 4) = v9;
      *((_DWORD *)v8 + 5) = v10;
      *((_DWORD *)v8 + 8) = 0;
      uint64_t result = 1;
LABEL_8:
      *a2 = (double)v9;
      a2[1] = (double)v10;
      *(double *)(v3 + 40) = (double)v9;
      *(double *)(v3 + 48) = (double)v10;
      return result;
    }
    uint64_t v11 = *v8;
    if (!*v8) {
      return 0;
    }
    int v12 = (_DWORD *)v8[1];
    int v9 = *(_DWORD *)(v11 + 16);
    if ((_DWORD *)v11 == v12)
    {
      int v13 = *(_DWORD *)(v11 + 20);
      int v15 = *(_DWORD *)(v11 + 24);
      *((_DWORD *)v8 + 4) = v9;
      *((_DWORD *)v8 + 5) = v13;
      *((_DWORD *)v8 + 6) = v9;
      *((_DWORD *)v8 + 7) = v15;
      *((_DWORD *)v8 + 9) = v15 < v13;
      uint64_t result = 0xFFFFFFFFLL;
      int v14 = 1;
    }
    else
    {
      int v13 = *(_DWORD *)(v11 + 20);
      if (v9 == *((_DWORD *)v8 + 4) && v13 == *((_DWORD *)v8 + 5))
      {
        int v14 = 0;
        int v15 = *(_DWORD *)(v11 + 24);
        *((_DWORD *)v8 + 4) = v9;
        *((_DWORD *)v8 + 5) = v15;
        uint64_t result = 1;
        int v10 = v15;
        goto LABEL_19;
      }
      *((_DWORD *)v8 + 4) = v9;
      *((_DWORD *)v8 + 5) = v13;
      int v15 = *(_DWORD *)(v11 + 24);
      *((_DWORD *)v8 + 6) = v9;
      *((_DWORD *)v8 + 7) = v15;
      int v14 = 1;
      uint64_t result = 1;
    }
    int v10 = v13;
LABEL_19:
    *((_DWORD *)v8 + 8) = v14;
    uint64_t v16 = *(void *)(v11 + 8);
    if (v16)
    {
      uint64_t v17 = 0;
      CFStringRef v18 = 0;
      unsigned int v19 = 0;
      int v20 = 0;
      uint64_t v21 = 0;
      signed int v22 = 0x80000000;
      int v23 = 0x7FFFFFFF;
      int v24 = 0x7FFFFFFF;
      signed int v25 = 0x80000000;
      do
      {
        int v26 = *(_DWORD *)(v16 + 20);
        if (v26 != v15 && *(_DWORD *)(v16 + 24) != v15) {
          break;
        }
        int v27 = *(_DWORD *)(v16 + 16);
        int v28 = v27 - v9;
        if (v26 == v13 || *(_DWORD *)(v16 + 24) == v13)
        {
          if (v28 >= 1 && v28 <= v24)
          {
            unsigned int v19 = (_DWORD *)v16;
            int v24 = v28;
          }
          if (v28 < 0 && v28 >= v25)
          {
            uint64_t v21 = (_DWORD *)v16;
            signed int v25 = v28;
          }
        }
        else
        {
          if (v28 >= 1 && v28 <= v23)
          {
            CFStringRef v18 = (_DWORD *)v16;
            int v23 = v27 - v9;
          }
          if (v28 < 0 && v28 >= v22)
          {
            int v20 = (_DWORD *)v16;
            signed int v22 = v27 - v9;
          }
          if (v27 == v9) {
            uint64_t v17 = (_DWORD *)v16;
          }
        }
        uint64_t v16 = *(void *)(v16 + 8);
      }
      while (v16);
    }
    else
    {
      uint64_t v21 = 0;
      int v20 = 0;
      unsigned int v19 = 0;
      CFStringRef v18 = 0;
      uint64_t v17 = 0;
      int v24 = 0x7FFFFFFF;
      signed int v25 = 0x80000000;
      signed int v22 = 0x80000000;
      int v23 = 0x7FFFFFFF;
    }
    unsigned int v37 = *(_DWORD **)v11;
    if (*(void *)v11)
    {
      do
      {
        int v38 = v37[5];
        if (v38 != v15 && v37[6] != v15) {
          break;
        }
        int v39 = v37[4];
        int v40 = v39 - v9;
        if (v38 == v13 || v37[6] == v13)
        {
          if (v40 >= 1 && v40 <= v24)
          {
            unsigned int v19 = v37;
            int v24 = v40;
          }
          if (v40 < 0 && v40 >= v25)
          {
            uint64_t v21 = v37;
            signed int v25 = v40;
          }
        }
        else
        {
          if (v40 >= 1 && v40 <= v23)
          {
            CFStringRef v18 = v37;
            int v23 = v39 - v9;
          }
          if (v40 < 0 && v40 >= v22)
          {
            int v20 = v37;
            signed int v22 = v39 - v9;
          }
          if (v39 == v9) {
            uint64_t v17 = v37;
          }
        }
        unsigned int v37 = *(_DWORD **)v37;
      }
      while (v37);
    }
    if (v17 && v15 <= v13)
    {
      signed int v22 = 0;
    }
    else
    {
      if (v17)
      {
        int v23 = 0;
        CFStringRef v18 = v17;
      }
      if (!v20)
      {
        uint64_t v17 = 0;
        char v49 = 1;
        goto LABEL_123;
      }
      uint64_t v17 = v20;
    }
    char v49 = 0;
    if (v17[5] == v15 && v22 >= v25)
    {
      char v49 = 0;
      BOOL v50 = v22 > v25 || v15 <= v13;
      BOOL v51 = !v50;
      if (!v17[7])
      {
        long long v52 = v17;
        if (!v51)
        {
LABEL_149:
          *double v8 = (uint64_t)v52;
          if ((_DWORD *)v11 != v12) {
            *(_DWORD *)(v11 + 28) = 1;
          }
          if (v52 == v12)
          {
            v12[7] = 1;
            for (uint64_t i = v8[1]; i; uint64_t i = *(void *)(i + 8))
            {
              if (!*(_DWORD *)(i + 28)) {
                break;
              }
            }
            *double v8 = i;
            v8[1] = i;
          }
          goto LABEL_8;
        }
      }
    }
LABEL_123:
    if (!v18
      || (v18[5] == v15 ? (BOOL v53 = v23 <= v24) : (BOOL v53 = 0),
          !v53
       || (v23 >= v24 ? (BOOL v54 = v15 <= v13) : (BOOL v54 = 0),
           v54 ? (char v55 = 0) : (char v55 = 1),
           v18[7] || (long long v52 = v18, (v55 & 1) == 0))))
    {
      BOOL v56 = (v49 & 1) == 0 && v17[6] < v17[5];
      BOOL v57 = !v56;
      if (v56) {
        int v58 = v21;
      }
      else {
        int v58 = v19;
      }
      if (v57) {
        unsigned int v19 = v21;
      }
      if (v15 > v13) {
        long long v52 = v19;
      }
      else {
        long long v52 = v58;
      }
    }
    goto LABEL_149;
  }
  return result;
}

uint64_t CGPDFArrayFinalize(uint64_t a1)
{
  CGPDFAssociationRelease(*(const void ***)(a1 + 56));
  uint64_t v2 = *(_DWORD **)(a1 + 24);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(_DWORD **)v2;
      if ((v2[2] - 5) <= 4) {
        pdf_object_release_compound_value((uint64_t)v2);
      }
      free(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }

  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 64));
}

CFTypeRef CGPDFArrayRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void CGPDFArrayRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

size_t CGPDFArrayGetCount(size_t array)
{
  if (array) {
    return *(void *)(array + 16);
  }
  return array;
}

BOOL CGPDFArrayGetNull(CGPDFArrayRef array, size_t index)
{
  CGPDFObjectRef value = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &value);
  if (Object)
  {
    if (value) {
      LOBYTE(Object) = *((_DWORD *)value + 2) == 1;
    }
    else {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetBoolean(CGPDFArrayRef array, size_t index, CGPDFBoolean *value)
{
  CGPDFObjectRef valuea = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 2)
    {
      if (value) {
        *CGPDFObjectRef value = *((unsigned char *)valuea + 32);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetInteger(CGPDFArrayRef array, size_t index, CGPDFInteger *value)
{
  CGPDFObjectRef valuea = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && ((int v5 = *((_DWORD *)valuea + 2), v5 != 12) ? (v6 = v5 == 3) : (v6 = 1), v6))
    {
      if (value) {
        *CGPDFObjectRef value = *((void *)valuea + 4);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetString(CGPDFArrayRef array, size_t index, CGPDFStringRef *value)
{
  CGPDFObjectRef valuea = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 6)
    {
      if (value) {
        *CGPDFObjectRef value = (CGPDFStringRef)*((void *)valuea + 4);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetArray(CGPDFArrayRef array, size_t index, CGPDFArrayRef *value)
{
  CGPDFObjectRef valuea = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 7)
    {
      if (value) {
        *CGPDFObjectRef value = (CGPDFArrayRef)*((void *)valuea + 4);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

void CGPDFArrayApplyBlock(CGPDFArrayRef array, CGPDFArrayApplierBlock block, void *info)
{
  if (array)
  {
    if (block)
    {
      uint64_t v5 = *((void *)array + 2);
      if (v5)
      {
        for (size_t i = 0; i != v5; ++i)
        {
          CGPDFObjectRef value = 0;
          if (CGPDFArrayGetObject(array, i, &value)
            && !(*((unsigned int (**)(CGPDFArrayApplierBlock, size_t, CGPDFObjectRef, void *))block + 2))(block, i, value, info))
          {
            break;
          }
        }
      }
    }
  }
}

BOOL CGPDFArrayGetOffset(CGPDFArray *a1, size_t a2, void *a3)
{
  CGPDFObjectRef value = 0;
  BOOL result = CGPDFArrayGetObject(a1, a2, &value);
  if (result)
  {
    if (value && ((int v5 = *((_DWORD *)value + 2), v5 != 12) ? (v6 = v5 == 3) : (v6 = 1), v6))
    {
      if (a3) {
        *a3 = *((void *)value + 4);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFArrayGetIntegers(uint64_t array, uint64_t a2, uint64_t a3)
{
  if (array)
  {
    uint64_t v4 = (CGPDFArray *)array;
    if (*(void *)(array + 16) == a3)
    {
      if (a3)
      {
        size_t v6 = 0;
        CGPDFInteger value = 0;
        do
        {
          array = CGPDFArrayGetInteger(v4, v6, &value);
          if (!array) {
            break;
          }
          *(void *)(a2 + 8 * v6++) = value;
        }
        while (a3 != v6);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return array;
}

uint64_t CGPDFArrayGetNumbers(uint64_t array, uint64_t a2, uint64_t a3)
{
  if (array)
  {
    uint64_t v4 = (CGPDFArray *)array;
    if (*(void *)(array + 16) == a3)
    {
      if (a3)
      {
        size_t v6 = 0;
        CGPDFReal value = 0.0;
        do
        {
          array = CGPDFArrayGetNumber(v4, v6, &value);
          if (!array) {
            break;
          }
          *(CGPDFReal *)(a2 + 8 * v6++) = value;
        }
        while (a3 != v6);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return array;
}

uint64_t CGPDFArrayPrint(uint64_t a1, FILE *a2)
{
  return CGPDFArrayPrintWithIndent(a1, a2, 0);
}

uint64_t CGPDFArrayPrintWithIndent(uint64_t result, FILE *a2, int a3)
{
  if (result)
  {
    uint64_t v4 = result;
    if (a2) {
      int v5 = a2;
    }
    else {
      int v5 = (FILE *)*MEMORY[0x1E4F143C8];
    }
    fwrite("[\n", 2uLL, 1uLL, v5);
    for (size_t i = *(void **)(v4 + 24); i; size_t i = (void *)*i)
    {
      fprintf(v5, "%*s", a3 + 2, "");
      CGPDFObjectPrintWithIndent(i, v5, (a3 + 2));
      fputc(10, v5);
    }
    return fprintf(v5, "%*s]", a3, "");
  }
  return result;
}

uint64_t compareLayoutReadingOrder(void *a1, void *a2)
{
  double v4 = keyPointOfLayoutArea(a1);
  double v6 = v5;
  objc_msgSend((id)objc_msgSend(a1, "firstChild"), "normalizedBounds");
  double width = v9;
  if (v9 < 0.0 || v10 < 0.0)
  {
    CGRect v20 = CGRectStandardize(*(CGRect *)&v7);
    double width = v20.size.width;
  }
  double v12 = keyPointOfLayoutArea(a2);
  double v14 = v13;
  objc_msgSend((id)objc_msgSend(a2, "firstChild"), "normalizedBounds");
  if (v4 + width * 0.5 < v12) {
    return -1;
  }
  if (v17 < 0.0 || v18 < 0.0) {
    *(CGRect *)(&v17 - 2) = CGRectStandardize(*(CGRect *)&v15);
  }
  if (v12 + v17 * 0.5 < v4) {
    return 1;
  }
  if (v6 <= v14) {
    return v6 < v14;
  }
  return -1;
}

double keyPointOfLayoutArea(void *a1)
{
  objc_msgSend((id)objc_msgSend(a1, "firstChild"), "normalizedBounds");
  CGFloat v5 = v1;
  CGFloat v6 = v2;
  CGFloat v7 = v3;
  CGFloat v8 = v4;
  if (v3 >= 0.0 && v4 >= 0.0) {
    return v1;
  }
  *(void *)&double v9 = (unint64_t)CGRectStandardize(*(CGRect *)&v1);
  v11.origin.x = v5;
  v11.origin.y = v6;
  v11.size.double width = v7;
  v11.size.height = v8;
  CGRectStandardize(v11);
  return v9;
}

uint64_t compareZoneReadingOrder(void *a1, void *a2)
{
  int v4 = [a1 count];
  int v5 = [a2 count];
  if (v4 | v5) {
    uint64_t v6 = -1;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v4) {
    uint64_t result = 1;
  }
  else {
    uint64_t result = v6;
  }
  if (v4 && v5)
  {
    double v8 = keyPointOfZone(a1);
    double v10 = v9;
    double v11 = keyPointOfZone(a2);
    uint64_t v13 = 1;
    uint64_t v14 = -1;
    if (v8 >= v11) {
      uint64_t v14 = v8 > v11;
    }
    if (v10 >= v12) {
      uint64_t v13 = v14;
    }
    if (v10 <= v12) {
      return v13;
    }
    else {
      return -1;
    }
  }
  return result;
}

double keyPointOfZone(void *a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = [a1 vertexCount];
  if (v2)
  {
    unsigned int v3 = v2;
    int v4 = (double *)[a1 outerVertices];
    double v6 = *v4;
    double v5 = v4[1];
    if (v3 == 1)
    {
      return *v4;
    }
    else
    {
      uint64_t v35 = v3 - 1;
      size_t v36 = v4 + 3;
      do
      {
        double v7 = *(v36 - 1);
        double v37 = *v36;
        if (v7 >= v6 && (v7 != v6 || v37 <= v5))
        {
          double v7 = v6;
          double v37 = v5;
        }
        v36 += 2;
        double v5 = v37;
        double v6 = v7;
        --v35;
      }
      while (v35);
    }
  }
  else
  {
    double v8 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:1];
    [a1 descendantsOfClass:objc_opt_class() to:v8];
    unsigned int v9 = [v8 count];
    if (v9)
    {
      objc_msgSend((id)objc_msgSend(v8, "objectAtIndex:", 0), "normalizedBounds");
      double v11 = v10;
      double v13 = v12;
      double v15 = v14;
      double height = v16;
      if (v9 != 1)
      {
        uint64_t v18 = v9;
        for (uint64_t i = 1; i != v18; ++i)
        {
          objc_msgSend((id)objc_msgSend(v8, "objectAtIndex:", i), "normalizedBounds");
          v64.origin.x = v20;
          v64.origin.double y = v21;
          v64.size.double width = v22;
          v64.size.double height = v23;
          v56.origin.x = v11;
          v56.origin.double y = v13;
          v56.size.double width = v15;
          v56.size.double height = height;
          *(CGRect *)&double v10 = CGRectUnion(v56, v64);
          double v11 = v10;
          double v13 = v24;
          double v15 = v25;
          double height = v26;
        }
      }
      BOOL v27 = height < 0.0 || v15 < 0.0;
      double v7 = v11;
      double v28 = v13;
      double v29 = height;
      if (v27)
      {
        v57.origin.x = v11;
        v57.origin.double y = v13;
        v57.size.double width = v15;
        v57.size.double height = height;
        *(void *)&double v7 = (unint64_t)CGRectStandardize(v57);
        v58.origin.x = v11;
        v58.origin.double y = v13;
        v58.size.double width = v15;
        v58.size.double height = height;
        *(CGRect *)&double v10 = CGRectStandardize(v58);
      }
      double v30 = v28 + v29;
      objc_msgSend(a1, "rotationAngle", v10);
      if (v31 != 0.0)
      {
        __double2 v32 = __sincos_stret(v31);
        double __base = v11;
        double v46 = v13;
        double v47 = v7;
        double v48 = v30;
        if (v27)
        {
          v59.origin.x = v11;
          v59.origin.double y = v13;
          v59.size.double width = v15;
          v59.size.double height = height;
          CGRect v60 = CGRectStandardize(v59);
          CGFloat v33 = v60.origin.x + v60.size.width;
          v60.origin.x = v11;
          v60.origin.double y = v13;
          v60.size.double width = v15;
          v60.size.double height = height;
          CGRect v61 = CGRectStandardize(v60);
          double v49 = v33;
          double y = v61.origin.y;
          v61.origin.x = v11;
          v61.origin.double y = v13;
          v61.size.double width = v15;
          v61.size.double height = height;
          CGRect v62 = CGRectStandardize(v61);
          double v34 = v62.origin.x + v62.size.width;
          v62.origin.x = v11;
          v62.origin.double y = v13;
          v62.size.double width = v15;
          v62.size.double height = height;
          CGRect v63 = CGRectStandardize(v62);
          double v13 = v63.origin.y;
          double height = v63.size.height;
        }
        else
        {
          double v34 = v11 + v15;
          double v49 = v11 + v15;
          double y = v13;
        }
        uint64_t v38 = 0;
        double v51 = v34;
        double v52 = v13 + height;
        float64x2_t v39 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.__cosval, 0);
        float64x2_t v40 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.__sinval, 0);
        do
        {
          int v41 = (double *)((char *)&__base + v38);
          float64x2x2_t v54 = vld2q_f64(v41);
          v55.val[0] = vaddq_f64(vmlaq_f64(vmulq_n_f64(v54.val[1], -v32.__sinval), v54.val[0], v39), (float64x2_t)0);
          v55.val[1] = vaddq_f64(vmlaq_f64(vmulq_n_f64(v54.val[1], v32.__cosval), v54.val[0], v40), (float64x2_t)0);
          vst2q_f64(v41, v55);
          v38 += 32;
        }
        while (v38 != 64);
        qsort(&__base, 4uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))left);
        double v7 = __base;
        double v42 = v47;
        if (__base == v47)
        {
          double v43 = v48;
          if (v46 >= v48)
          {
            double v43 = v46;
            double v42 = __base;
          }
          if (v42 == v49 && v43 < y) {
            double v7 = v49;
          }
          else {
            double v7 = v42;
          }
        }
      }
    }
    else
    {

      return 0.0;
    }
  }
  return v7;
}

std::ios_base *__cdecl left(std::ios_base *__str)
{
  if (*(double *)&__str->__vftable < *v1) {
    return (std::ios_base *)0xFFFFFFFFLL;
  }
  else {
    return (std::ios_base *)(*v1 < *(double *)&__str->__vftable);
  }
}

uint64_t compareKeyOrder(void *a1, void *a2)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass()))
  {
    return compareLayoutReadingOrder(a1, a2);
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass()))
    {
      return compareZoneReadingOrder(a1, a2);
    }
    else
    {
      double v5 = keyPoint(a1);
      double v7 = v6;
      double v8 = keyPoint(a2);
      if (v7 <= v9)
      {
        if (v7 >= v9)
        {
          if (v5 >= v8) {
            return v5 > v8;
          }
          else {
            return -1;
          }
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return -1;
      }
    }
  }
}

CGFloat keyPoint(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return keyPointOfZone(a1);
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    unsigned int v3 = a1;
    return keyPointOfLayoutArea(v3);
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    unsigned int v3 = (void *)[a1 firstChild];
    return keyPointOfLayoutArea(v3);
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    [a1 tableBounds];
  }
  else {
    [a1 renderedBounds];
  }
  CGFloat v10 = v6;
  CGFloat v11 = v7;
  CGFloat v12 = v8;
  CGFloat v13 = v9;
  if (v8 >= 0.0 && v9 >= 0.0) {
    return v6;
  }
  *(void *)&double v4 = (unint64_t)CGRectStandardize(*(CGRect *)&v6);
  v14.origin.x = v10;
  v14.origin.double y = v11;
  v14.size.double width = v12;
  v14.size.double height = v13;
  CGRectStandardize(v14);
  return v4;
}

uint64_t cmyk32_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 40);
  uint64_t v15 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v90 = *(void *)(result + 88);
  uint64_t v100 = *(void *)(result + 120);
  uint64_t v101 = *(void *)(result + 112);
  double v16 = (unint64_t *)(*(void *)(result + 152) - 8);
  uint64_t v91 = *(void *)(result + 144) - 1;
  int v17 = *(_DWORD *)(result + 260) - 1;
  int v98 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  int v18 = *(_DWORD *)(result + 256);
  int v93 = *(_DWORD *)(result + 28);
  unint64_t v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  int v86 = *(_DWORD *)(result + 188);
  unint64_t v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v89 = *(void *)(result + 64);
  uint64_t v96 = v14;
  uint64_t v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      uint64_t v23 = v90;
      if (a3 <= v90)
      {
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        int v22 = a4;
        uint64_t v24 = v89;
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = *(void *)(result + 224) + v90;
        uint64_t v28 = v27 - a3 + (v26 >> 1);
        int v22 = a4;
        uint64_t v24 = v89;
        if (v28 < 1) {
          goto LABEL_37;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        unsigned int v31 = v86 | v29;
        uint64_t v32 = v27 - 0x1000000;
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v88 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      uint64_t v24 = v89;
      uint64_t v23 = v90;
      if (v21 < 1) {
        goto LABEL_37;
      }
      if (v21 >= v19) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      unsigned int v31 = v86 | v25;
      uint64_t v32 = v20 + 0x1000000;
      uint64_t v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v36 = a2;
      }
      else
      {
        uint64_t v38 = *(void *)(result + 192);
        uint64_t v39 = *(void *)(result + 200) + v87;
        uint64_t v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1) {
          goto LABEL_37;
        }
        if (v40 < v38) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v86;
        }
        uint64_t v36 = v39 - 0x1000000;
        uint64_t v37 = 28;
      }
    }
    else
    {
      uint64_t v33 = *(void *)(result + 192);
      uint64_t v34 = v24 - *(void *)(result + 200);
      uint64_t v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1) {
        goto LABEL_37;
      }
      if (v35 < v33) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v86;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = 32;
    }
    if (v31 >= 0x400000) {
      break;
    }
LABEL_37:
    int v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    ++v16;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50) {
      return result;
    }
  }
  uint64_t v41 = v32 >> 32;
  unint64_t v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  unsigned int v44 = *(float32x4_t **)(result + 32);
  unsigned int v45 = (float32x4_t *)v99;
  if (v99 >= v43) {
    unsigned int v45 = (float32x4_t *)v43;
  }
  if (v45 < v44) {
    unsigned int v45 = *(float32x4_t **)(result + 32);
  }
  if (v14)
  {
    unint64_t v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    double v47 = *(float **)(result + 40);
    double v48 = (float *)v94;
    unint64_t v92 = v46;
    if (v94 >= v46) {
      double v48 = (float *)v46;
    }
    if (v48 >= v47) {
      double v47 = v48;
    }
    float v49 = *v47;
  }
  else
  {
    unint64_t v92 = 0;
    float v49 = 1.0;
  }
  float32x4_t v51 = *v45;
  if (v15)
  {
    unsigned int v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    int v53 = v52 & 0xF;
    int v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      int v68 = (float32x4_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68) {
        int v68 = (float32x4_t *)v99;
      }
      if (v68 >= v44) {
        unsigned int v44 = v68;
      }
      float32x4_t v69 = *v44;
      float v70 = 1.0;
      if (v14)
      {
        uint64_t v71 = (float *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71) {
          uint64_t v71 = (float *)v94;
        }
        if ((unint64_t)v71 < *(void *)(result + 40)) {
          uint64_t v71 = *(float **)(result + 40);
        }
        float v70 = *v71;
      }
      unint64_t v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          int64_t v55 = (unint64_t)HIWORD(v52) << 56;
          CGRect v56 = (float32x4_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56) {
            CGRect v57 = v56;
          }
          else {
            CGRect v57 = (float32x4_t *)v99;
          }
          if (v57 < v44) {
            CGRect v57 = v44;
          }
          CGRect v58 = (float32x4_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58) {
            CGRect v58 = (float32x4_t *)v99;
          }
          if (v58 >= v44) {
            unsigned int v44 = v58;
          }
          float32x4_t v59 = *v57;
          float32x4_t v60 = *v44;
          float v61 = 1.0;
          float v62 = 1.0;
          if (v14)
          {
            unint64_t v63 = v92 + (v55 >> 54);
            unint64_t v64 = *(void *)(result + 40);
            if (v94 >= v63) {
              uint64_t v65 = (float *)(v92 + (v55 >> 54));
            }
            else {
              uint64_t v65 = (float *)v94;
            }
            if ((unint64_t)v65 < v64) {
              uint64_t v65 = *(float **)(result + 40);
            }
            float v61 = *v65;
            uint64_t v66 = (float *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66) {
              uint64_t v66 = (float *)v94;
            }
            if ((unint64_t)v66 < v64) {
              uint64_t v66 = *(float **)(result + 40);
            }
            float v62 = *v66;
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          float32x4_t v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          float v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      int64_t v73 = (unint64_t)HIWORD(v52) << 56;
      uint64_t v74 = (float32x4_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74) {
        uint64_t v74 = (float32x4_t *)v99;
      }
      if (v74 >= v44) {
        unsigned int v44 = v74;
      }
      float32x4_t v69 = *v44;
      float v70 = 1.0;
      if (v14)
      {
        float v75 = (float *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75) {
          float v75 = (float *)v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          float v75 = *(float **)(result + 40);
        }
        float v70 = *v75;
      }
      unint64_t v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    float v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  uint64_t v76 = 0;
  ++v16;
  int v85 = v22;
  int v77 = v22 - 1;
  a3 += v100;
  uint64_t v78 = v23 - a3;
  a2 += v101;
  uint64_t v79 = v87 - a2;
  while (1)
  {
    float32x4_t v102 = v51;
    float v103 = v49;
    CMYKF(v16, v102.f32);
    *(unsigned char *)(v91 + 1 + v76) = v31 >> 22;
    uint64_t v14 = v96;
    uint64_t result = v97;
    if (v77 == v76) {
      return result;
    }
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      int v50 = ~v76 + v85;
      goto LABEL_38;
    }
    size_t v80 = (float32x4_t *)v99;
    unint64_t v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    unsigned int v44 = *(float32x4_t **)(v97 + 32);
    if (v99 >= v43) {
      size_t v80 = (float32x4_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    }
    if (v80 < v44) {
      size_t v80 = *(float32x4_t **)(v97 + 32);
    }
    if (v96)
    {
      unint64_t v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      size_t v83 = *(float **)(v97 + 40);
      int v84 = (float *)v94;
      unint64_t v92 = v82;
      if (v94 >= v82) {
        int v84 = (float *)v82;
      }
      if (v84 >= v83) {
        size_t v83 = v84;
      }
      float v49 = *v83;
    }
    else
    {
      float v49 = 1.0;
    }
    float32x4_t v51 = *v80;
    if (v15)
    {
      unsigned int v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        uint64_t v23 = v90;
        v91 += v76 + 1;
        int v22 = ~v76 + v85;
        unsigned int v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    ++v16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    unsigned int v31 = -1;
  }
}

unint64_t *CMYKF(unint64_t *result, float *a2)
{
  float v2 = a2[4];
  if (v2 <= 0.0)
  {
    unint64_t v12 = 0;
  }
  else
  {
    float v3 = *a2;
    float v4 = a2[1];
    LODWORD(v5) = (int)(float)((float)(v2 * 255.0) + 0.5);
    float v6 = a2[2];
    float v7 = a2[3];
    if (v2 <= 1.0) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = 255;
    }
    if (v2 > 1.0) {
      float v2 = 1.0;
    }
    int v8 = (int)(float)((float)(v3 * 255.0) + 0.5);
    if (v3 < 0.0) {
      int v8 = 0;
    }
    if (v3 > v2) {
      int v8 = v5;
    }
    int v9 = (int)(float)((float)(v4 * 255.0) + 0.5);
    if (v4 < 0.0) {
      int v9 = 0;
    }
    if (v4 > v2) {
      int v9 = v5;
    }
    int v10 = (int)(float)((float)(v6 * 255.0) + 0.5);
    if (v6 < 0.0) {
      int v10 = 0;
    }
    if (v6 > v2) {
      int v10 = v5;
    }
    int v11 = (int)(float)((float)(v7 * 255.0) + 0.5);
    if (v7 < 0.0) {
      int v11 = 0;
    }
    if (v7 > v2) {
      int v11 = v5;
    }
    unint64_t v12 = (v9 << 16) | (v8 << 24) | (v10 << 8) | v11 | (unint64_t)(v5 << 32);
  }
  *uint64_t result = v12;
  return result;
}

uint64_t cmyk32_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 40);
  uint64_t v15 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v90 = *(void *)(result + 88);
  uint64_t v100 = *(void *)(result + 120);
  uint64_t v101 = *(void *)(result + 112);
  double v16 = (unint64_t *)(*(void *)(result + 152) - 8);
  uint64_t v91 = *(void *)(result + 144) - 1;
  int v17 = *(_DWORD *)(result + 260) - 1;
  int v98 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  int v18 = *(_DWORD *)(result + 256);
  int v93 = *(_DWORD *)(result + 28);
  unint64_t v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  int v86 = *(_DWORD *)(result + 188);
  unint64_t v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v89 = *(void *)(result + 64);
  uint64_t v96 = v14;
  uint64_t v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      uint64_t v23 = v90;
      if (a3 <= v90)
      {
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        int v22 = a4;
        uint64_t v24 = v89;
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = *(void *)(result + 224) + v90;
        uint64_t v28 = v27 - a3 + (v26 >> 1);
        int v22 = a4;
        uint64_t v24 = v89;
        if (v28 < 1) {
          goto LABEL_37;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        unsigned int v31 = v86 | v29;
        uint64_t v32 = v27 - 0x1000000;
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v88 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      uint64_t v24 = v89;
      uint64_t v23 = v90;
      if (v21 < 1) {
        goto LABEL_37;
      }
      if (v21 >= v19) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      unsigned int v31 = v86 | v25;
      uint64_t v32 = v20 + 0x1000000;
      uint64_t v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v36 = a2;
      }
      else
      {
        uint64_t v38 = *(void *)(result + 192);
        uint64_t v39 = *(void *)(result + 200) + v87;
        uint64_t v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1) {
          goto LABEL_37;
        }
        if (v40 < v38) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v86;
        }
        uint64_t v36 = v39 - 0x1000000;
        uint64_t v37 = 28;
      }
    }
    else
    {
      uint64_t v33 = *(void *)(result + 192);
      uint64_t v34 = v24 - *(void *)(result + 200);
      uint64_t v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1) {
        goto LABEL_37;
      }
      if (v35 < v33) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v86;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = 32;
    }
    if (v31 >= 0x400000) {
      break;
    }
LABEL_37:
    int v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    ++v16;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50) {
      return result;
    }
  }
  uint64_t v41 = v32 >> 32;
  unint64_t v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  unsigned int v44 = *(int8x16_t **)(result + 32);
  unsigned int v45 = (int8x16_t *)v99;
  if (v99 >= v43) {
    unsigned int v45 = (int8x16_t *)v43;
  }
  if (v45 < v44) {
    unsigned int v45 = *(int8x16_t **)(result + 32);
  }
  if (v14)
  {
    unint64_t v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    double v47 = *(unsigned int **)(result + 40);
    double v48 = (unsigned int *)v94;
    unint64_t v92 = v46;
    if (v94 >= v46) {
      double v48 = (unsigned int *)v46;
    }
    if (v48 >= v47) {
      double v47 = v48;
    }
    float v49 = COERCE_FLOAT(bswap32(*v47));
  }
  else
  {
    unint64_t v92 = 0;
    float v49 = 1.0;
  }
  float32x4_t v51 = (float32x4_t)vrev32q_s8(*v45);
  if (v15)
  {
    unsigned int v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    int v53 = v52 & 0xF;
    int v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      int v68 = (int8x16_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68) {
        int v68 = (int8x16_t *)v99;
      }
      if (v68 >= v44) {
        unsigned int v44 = v68;
      }
      float32x4_t v69 = (float32x4_t)vrev32q_s8(*v44);
      float v70 = 1.0;
      if (v14)
      {
        uint64_t v71 = (unsigned int *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71) {
          uint64_t v71 = (unsigned int *)v94;
        }
        if ((unint64_t)v71 < *(void *)(result + 40)) {
          uint64_t v71 = *(unsigned int **)(result + 40);
        }
        float v70 = COERCE_FLOAT(bswap32(*v71));
      }
      unint64_t v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          int64_t v55 = (unint64_t)HIWORD(v52) << 56;
          CGRect v56 = (int8x16_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56) {
            CGRect v57 = v56;
          }
          else {
            CGRect v57 = (int8x16_t *)v99;
          }
          if (v57 < v44) {
            CGRect v57 = v44;
          }
          CGRect v58 = (int8x16_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58) {
            CGRect v58 = (int8x16_t *)v99;
          }
          if (v58 >= v44) {
            unsigned int v44 = v58;
          }
          float32x4_t v59 = (float32x4_t)vrev32q_s8(*v57);
          float32x4_t v60 = (float32x4_t)vrev32q_s8(*v44);
          float v61 = 1.0;
          float v62 = 1.0;
          if (v14)
          {
            unint64_t v63 = v92 + (v55 >> 54);
            unint64_t v64 = *(void *)(result + 40);
            if (v94 >= v63) {
              uint64_t v65 = (unsigned int *)(v92 + (v55 >> 54));
            }
            else {
              uint64_t v65 = (unsigned int *)v94;
            }
            if ((unint64_t)v65 < v64) {
              uint64_t v65 = *(unsigned int **)(result + 40);
            }
            float v61 = COERCE_FLOAT(bswap32(*v65));
            uint64_t v66 = (unsigned int *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66) {
              uint64_t v66 = (unsigned int *)v94;
            }
            if ((unint64_t)v66 < v64) {
              uint64_t v66 = *(unsigned int **)(result + 40);
            }
            float v62 = COERCE_FLOAT(bswap32(*v66));
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          float32x4_t v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          float v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      int64_t v73 = (unint64_t)HIWORD(v52) << 56;
      uint64_t v74 = (int8x16_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74) {
        uint64_t v74 = (int8x16_t *)v99;
      }
      if (v74 >= v44) {
        unsigned int v44 = v74;
      }
      float32x4_t v69 = (float32x4_t)vrev32q_s8(*v44);
      float v70 = 1.0;
      if (v14)
      {
        float v75 = (unsigned int *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75) {
          float v75 = (unsigned int *)v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          float v75 = *(unsigned int **)(result + 40);
        }
        float v70 = COERCE_FLOAT(bswap32(*v75));
      }
      unint64_t v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    float v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  uint64_t v76 = 0;
  ++v16;
  int v85 = v22;
  int v77 = v22 - 1;
  a3 += v100;
  uint64_t v78 = v23 - a3;
  a2 += v101;
  uint64_t v79 = v87 - a2;
  while (1)
  {
    float32x4_t v102 = v51;
    float v103 = v49;
    CMYKF(v16, v102.f32);
    *(unsigned char *)(v91 + 1 + v76) = v31 >> 22;
    uint64_t v14 = v96;
    uint64_t result = v97;
    if (v77 == v76) {
      return result;
    }
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      int v50 = ~v76 + v85;
      goto LABEL_38;
    }
    size_t v80 = (int8x16_t *)v99;
    unint64_t v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    unsigned int v44 = *(int8x16_t **)(v97 + 32);
    if (v99 >= v43) {
      size_t v80 = (int8x16_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    }
    if (v80 < v44) {
      size_t v80 = *(int8x16_t **)(v97 + 32);
    }
    if (v96)
    {
      unint64_t v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      size_t v83 = *(unsigned int **)(v97 + 40);
      int v84 = (unsigned int *)v94;
      unint64_t v92 = v82;
      if (v94 >= v82) {
        int v84 = (unsigned int *)v82;
      }
      if (v84 >= v83) {
        size_t v83 = v84;
      }
      float v49 = COERCE_FLOAT(bswap32(*v83));
    }
    else
    {
      float v49 = 1.0;
    }
    float32x4_t v51 = (float32x4_t)vrev32q_s8(*v80);
    if (v15)
    {
      unsigned int v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        uint64_t v23 = v90;
        v91 += v76 + 1;
        int v22 = ~v76 + v85;
        unsigned int v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    ++v16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    unsigned int v31 = -1;
  }
}

uint64_t cmyk32_sample_cmyk64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v105 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v109 = *(void *)(result + 152) - 8;
  uint64_t v107 = *(void *)(result + 88);
  uint64_t v108 = *(void *)(result + 144) - 1;
  int v11 = *(_DWORD *)(result + 260) - 1;
  uint64_t v12 = *(unsigned int *)(result + 256);
  int v103 = *(_DWORD *)(result + 188);
  unint64_t v13 = v5 + (v11 * v7) + 2 * (v12 - 1);
  unint64_t v14 = v4 + (v11 * v6) + 8 * v12 - 16;
  uint64_t v106 = *(void *)(result + 72);
  uint64_t v104 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v106)
    {
      if (a3 <= v107)
      {
        uint64_t v23 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        uint64_t v25 = a3;
        uint64_t v26 = v104;
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v107;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_39;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        uint64_t v26 = v104;
        unsigned int v24 = v103 | v22;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v106 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_39;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      uint64_t v26 = v104;
      unsigned int v24 = v103 | v18;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v26) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v26 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v103;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v108 = 0;
    v109 += 8;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v105)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_26;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v105;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_39;
  }
  if (v34 < v32) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v103;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_26:
  if (v24 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v35 = v25 >> 32;
  uint64_t v36 = v30 >> 32;
  uint64_t v37 = v4 + SHIDWORD(v25) * (uint64_t)v6;
  unint64_t v38 = v37 + 8 * v36;
  uint64_t v39 = *(unint64_t **)(result + 32);
  if (v14 >= v38) {
    uint64_t v40 = (unint64_t *)(v37 + 8 * v36);
  }
  else {
    uint64_t v40 = (unint64_t *)v14;
  }
  if (v40 < v39) {
    uint64_t v40 = *(unint64_t **)(result + 32);
  }
  if (v5)
  {
    unint64_t v41 = v5 + (int)v35 * (uint64_t)v7 + 2 * v36;
    unint64_t v42 = *(unsigned __int16 **)(result + 40);
    if (v13 >= v41) {
      unint64_t v43 = (unsigned __int16 *)v41;
    }
    else {
      unint64_t v43 = (unsigned __int16 *)v13;
    }
    if (v43 >= v42) {
      unint64_t v42 = v43;
    }
    int v44 = *v42;
  }
  else
  {
    unint64_t v41 = 0;
    int v44 = 0xFFFF;
  }
  unint64_t v45 = *v40;
  if (!v8) {
    goto LABEL_101;
  }
  unsigned int v46 = *(_DWORD *)(v8 + (v31 | v23));
LABEL_45:
  int v47 = v46 & 0xF;
  unsigned int v48 = HIBYTE(v46) & 3;
  switch(v47)
  {
    case 1:
      uint64_t v78 = (unint64_t *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      if (v14 < (unint64_t)v78) {
        uint64_t v78 = (unint64_t *)v14;
      }
      if (v78 < v39) {
        uint64_t v78 = v39;
      }
      unint64_t v79 = *v78;
      int v80 = 0xFFFF;
      if (v5)
      {
        unint64_t v81 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v7);
        if (v13 < (unint64_t)v81) {
          unint64_t v81 = (unsigned __int16 *)v13;
        }
        if ((unint64_t)v81 < *(void *)(result + 40)) {
          unint64_t v81 = *(unsigned __int16 **)(result + 40);
        }
        int v80 = *v81;
      }
      unint64_t v82 = (char *)&interpolate_cmyk64 + 16 * v48;
      uint64_t v83 = *(void *)v82;
      char v84 = v48 + 1;
      unint64_t v85 = v45 - ((*(void *)v82 & v45) >> v84);
      LODWORD(v82) = *((unsigned __int16 *)v82 + 4);
      unsigned int v76 = v44 - ((v82 & v44) >> v84);
      unint64_t v86 = (v83 & v79) >> v84;
      unsigned int v77 = (v82 & v80) >> v84;
      unint64_t v45 = v85 + v86;
LABEL_88:
      LOWORD(v87) = v76 + v77;
      goto LABEL_100;
    case 2:
      int64_t v88 = (unint64_t)HIWORD(v46) << 56;
      uint64_t v89 = (unint64_t *)(v38 + (v88 >> 53));
      if (v14 < (unint64_t)v89) {
        uint64_t v89 = (unint64_t *)v14;
      }
      if (v89 < v39) {
        uint64_t v89 = v39;
      }
      unint64_t v90 = *v89;
      __int16 v91 = -1;
      if (v5)
      {
        unint64_t v92 = (__int16 *)(v41 + (v88 >> 55));
        if (v13 < (unint64_t)v92) {
          unint64_t v92 = (__int16 *)v13;
        }
        if ((unint64_t)v92 < *(void *)(result + 40)) {
          unint64_t v92 = *(__int16 **)(result + 40);
        }
        __int16 v91 = *v92;
      }
      unsigned int v93 = (v46 >> 28) & 3;
      unint64_t v94 = (char *)&interpolate_cmyk64 + 16 * v93;
      LOBYTE(v93) = v93 + 1;
      unint64_t v45 = v45 - ((*(void *)v94 & v45) >> v93) + ((*(void *)v94 & v90) >> v93);
      int v87 = v44
          - ((unsigned __int16)(*((_WORD *)v94 + 4) & v44) >> v93)
          + ((unsigned __int16)(*((_WORD *)v94 + 4) & v91) >> v93);
LABEL_100:
      BYTE1(v44) = BYTE1(v87);
      break;
    case 3:
      int64_t v49 = (unint64_t)HIWORD(v46) << 56;
      int v50 = (unint64_t *)(v38 + (v49 >> 53));
      if (v14 < (unint64_t)v50) {
        int v50 = (unint64_t *)v14;
      }
      if (v50 < v39) {
        int v50 = v39;
      }
      unint64_t v51 = *v50;
      unint64_t v52 = v38 + SBYTE1(v46) * (uint64_t)v6;
      if (v14 >= v52) {
        int v53 = (unint64_t *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      }
      else {
        int v53 = (unint64_t *)v14;
      }
      if (v53 < v39) {
        int v53 = v39;
      }
      unint64_t v102 = *v53;
      int v54 = (unint64_t *)(v52 + (v49 >> 53));
      if (v14 < (unint64_t)v54) {
        int v54 = (unint64_t *)v14;
      }
      if (v54 < v39) {
        int v54 = v39;
      }
      unint64_t v55 = *v54;
      int v56 = 0xFFFF;
      int v57 = 0xFFFF;
      int v58 = 0xFFFF;
      if (v5)
      {
        float32x4_t v59 = (unsigned __int16 *)(v41 + (v49 >> 55));
        unint64_t v60 = *(void *)(result + 40);
        if (v13 < (unint64_t)v59) {
          float32x4_t v59 = (unsigned __int16 *)v13;
        }
        if ((unint64_t)v59 < v60) {
          float32x4_t v59 = *(unsigned __int16 **)(result + 40);
        }
        int v56 = *v59;
        unint64_t v61 = v41 + SBYTE1(v46) * (uint64_t)v7;
        if (v13 >= v61) {
          float v62 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v7);
        }
        else {
          float v62 = (unsigned __int16 *)v13;
        }
        if ((unint64_t)v62 < v60) {
          float v62 = *(unsigned __int16 **)(result + 40);
        }
        int v57 = *v62;
        unint64_t v63 = (unsigned __int16 *)(v61 + (v49 >> 55));
        if (v13 < (unint64_t)v63) {
          unint64_t v63 = (unsigned __int16 *)v13;
        }
        if ((unint64_t)v63 < v60) {
          unint64_t v63 = *(unsigned __int16 **)(result + 40);
        }
        int v58 = *v63;
      }
      unint64_t v64 = (char *)&interpolate_cmyk64 + 16 * v48;
      uint64_t v65 = *(void *)v64;
      char v66 = v48 + 1;
      unint64_t v67 = v45 - ((*(void *)v64 & v45) >> v66);
      LODWORD(v64) = *((unsigned __int16 *)v64 + 4);
      unint64_t v68 = v67 + ((v65 & v102) >> v66);
      unsigned int v69 = v44 - ((v64 & v44) >> v66) + ((v64 & v57) >> v66);
      unint64_t v70 = v51 - ((v65 & v51) >> v66) + ((v65 & v55) >> v66);
      unsigned int v71 = v56 - ((v64 & v56) >> v66) + ((v64 & v58) >> v66);
      unsigned int v72 = (v46 >> 28) & 3;
      int64_t v73 = (char *)&interpolate_cmyk64 + 16 * v72;
      unint64_t v74 = *(void *)v73;
      LOBYTE(v72) = v72 + 1;
      unint64_t v75 = v68 - ((v68 & *(void *)v73) >> v72);
      LODWORD(v73) = *((unsigned __int16 *)v73 + 4);
      unsigned int v76 = v69 - ((v69 & v73) >> v72);
      unsigned int v77 = (v71 & v73) >> v72;
      unint64_t v45 = v75 + ((v70 & v74) >> v72);
      goto LABEL_88;
  }
LABEL_101:
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  a3 += v9;
  uint64_t v97 = v107 - a3;
  a2 += v10;
  uint64_t v98 = v105 - a2;
  while (1)
  {
    *(void *)(v109 + 8 + 8 * v95) = (v45 >> 8) & 0xFF0000 | HIBYTE(v45) | (BYTE1(v45) << 24) | HIDWORD(v45) & 0xFF00 | ((unint64_t)BYTE1(v44) << 32);
    *(unsigned char *)(v108 + 1 + v95) = v24 >> 22;
    if (a4 - 1 == v95) {
      return result;
    }
    if ((v97 | v98 | (a3 - v106) | (a2 - v104)) < 0)
    {
      v108 += v95 + 1;
      uint64_t v109 = v109 - v96 + 8;
      a4 += ~v95;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32);
    uint64_t v39 = *(unint64_t **)(result + 32);
    if (v14 >= v38) {
      unint64_t v99 = (unint64_t *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32));
    }
    else {
      unint64_t v99 = (unint64_t *)v14;
    }
    if (v99 < v39) {
      unint64_t v99 = *(unint64_t **)(result + 32);
    }
    if (v5)
    {
      unint64_t v41 = v5 + SHIDWORD(a3) * (uint64_t)v7 + 2 * (a2 >> 32);
      uint64_t v100 = *(unsigned __int16 **)(result + 40);
      if (v13 >= v41) {
        unint64_t v101 = v5 + SHIDWORD(a3) * (uint64_t)v7 + 2 * (a2 >> 32);
      }
      else {
        unint64_t v101 = v13;
      }
      if (v101 >= (unint64_t)v100) {
        uint64_t v100 = (unsigned __int16 *)v101;
      }
      int v44 = *v100;
    }
    else
    {
      int v44 = 0xFFFF;
    }
    unint64_t v45 = *v99;
    if (v8)
    {
      unsigned int v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v108 += v95 + 1;
        uint64_t v109 = v109 - v96 + 8;
        a4 += ~v95;
        unsigned int v24 = -1;
        goto LABEL_45;
      }
    }
    v96 -= 8;
    ++v95;
    a3 += v9;
    v97 -= v9;
    a2 += v10;
    v98 -= v10;
    unsigned int v24 = -1;
  }
}

uint64_t cmyk32_sample_CMYK64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v103 = *(void *)(result + 88);
  uint64_t v104 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v8 = *(void *)(result + 120);
  uint64_t v105 = *(void *)(result + 144) - 1;
  uint64_t v106 = *(void *)(result + 152) - 8;
  int v10 = *(_DWORD *)(result + 260) - 1;
  uint64_t v11 = *(unsigned int *)(result + 256);
  int v107 = *(_DWORD *)(result + 28);
  int v100 = *(_DWORD *)(result + 188);
  unint64_t v12 = v5 + (v10 * v107) + 2 * (v11 - 1);
  unint64_t v13 = v4 + (v10 * v6) + 8 * v11 - 16;
  uint64_t v101 = *(void *)(result + 64);
  uint64_t v102 = *(void *)(result + 72);
  while (1)
  {
LABEL_2:
    if (a3 >= v102)
    {
      if (a3 <= v103)
      {
        uint64_t v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        uint64_t v24 = a3;
        uint64_t v25 = v101;
        uint64_t v26 = v104;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v103;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_39;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v101;
        uint64_t v26 = v104;
        unsigned int v23 = v100 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v102 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_39;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v101;
      uint64_t v26 = v104;
      unsigned int v23 = v100 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v25 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v100;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v9;
    a3 += v8;
    v106 += 8;
    *(unsigned char *)++uint64_t v105 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v26)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_26;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v26;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_39;
  }
  if (v34 < v32) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v100;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_26:
  if (v23 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v35 = v24 >> 32;
  uint64_t v36 = v30 >> 32;
  uint64_t v37 = v4 + SHIDWORD(v24) * (uint64_t)v6;
  unint64_t v38 = v37 + 8 * v36;
  uint64_t v39 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v38) {
    uint64_t v40 = (unsigned __int16 *)(v37 + 8 * v36);
  }
  else {
    uint64_t v40 = (unsigned __int16 *)v13;
  }
  if (v40 < v39) {
    uint64_t v40 = *(unsigned __int16 **)(result + 32);
  }
  if (v5)
  {
    unint64_t v41 = v5 + (int)v35 * (uint64_t)v107 + 2 * v36;
    unint64_t v42 = *(unsigned __int16 **)(result + 40);
    if (v12 >= v41) {
      unint64_t v43 = (unsigned __int16 *)v41;
    }
    else {
      unint64_t v43 = (unsigned __int16 *)v12;
    }
    if (v43 >= v42) {
      unint64_t v42 = v43;
    }
    unsigned int v44 = bswap32(*v42) >> 16;
  }
  else
  {
    unint64_t v41 = 0;
    unsigned int v44 = 0xFFFF;
  }
  unint64_t v45 = ((unint64_t)(bswap32(v40[2]) >> 16) << 32) | ((unint64_t)(bswap32(v40[3]) >> 16) << 48) | bswap32(v40[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v40) >> 16);
  if (!v7) {
    goto LABEL_101;
  }
  unsigned int v46 = *(_DWORD *)(v7 + (v31 | v22));
LABEL_45:
  int v47 = v46 & 0xF;
  unsigned int v48 = HIBYTE(v46) & 3;
  switch(v47)
  {
    case 1:
      unsigned int v76 = (unsigned __int16 *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      if (v13 < (unint64_t)v76) {
        unsigned int v76 = (unsigned __int16 *)v13;
      }
      if (v76 < v39) {
        unsigned int v76 = v39;
      }
      unint64_t v77 = ((unint64_t)(bswap32(v76[2]) >> 16) << 32) | ((unint64_t)(bswap32(v76[3]) >> 16) << 48) | bswap32(v76[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v76) >> 16);
      LOWORD(v78) = -1;
      if (v5)
      {
        unint64_t v79 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v107);
        if (v12 < (unint64_t)v79) {
          unint64_t v79 = (unsigned __int16 *)v12;
        }
        if ((unint64_t)v79 < *(void *)(result + 40)) {
          unint64_t v79 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v78 = bswap32(*v79) >> 16;
      }
      int v80 = (char *)&interpolate_cmyk64 + 16 * v48;
      unint64_t v45 = v45
          - ((*(void *)v80 & v45) >> (v48 + 1))
          + ((*(void *)v80 & v77) >> (v48 + 1));
      int v81 = v44 - ((*((_WORD *)v80 + 4) & v44) >> (v48 + 1)) + ((*((_WORD *)v80 + 4) & v78) >> (v48 + 1));
LABEL_100:
      BYTE1(v44) = BYTE1(v81);
      break;
    case 2:
      int64_t v82 = (unint64_t)HIWORD(v46) << 56;
      uint64_t v83 = (unsigned __int16 *)(v38 + (v82 >> 53));
      if (v13 < (unint64_t)v83) {
        uint64_t v83 = (unsigned __int16 *)v13;
      }
      if (v83 < v39) {
        uint64_t v83 = v39;
      }
      unint64_t v84 = ((unint64_t)(bswap32(v83[2]) >> 16) << 32) | ((unint64_t)(bswap32(v83[3]) >> 16) << 48) | bswap32(v83[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v83) >> 16);
      unsigned int v85 = 0xFFFF;
      if (v5)
      {
        unint64_t v86 = (unsigned __int16 *)(v41 + (v82 >> 55));
        if (v12 < (unint64_t)v86) {
          unint64_t v86 = (unsigned __int16 *)v12;
        }
        if ((unint64_t)v86 < *(void *)(result + 40)) {
          unint64_t v86 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v85 = bswap32(*v86) >> 16;
      }
      unsigned int v87 = (v46 >> 28) & 3;
      int64_t v88 = (char *)&interpolate_cmyk64 + 16 * v87;
      uint64_t v89 = *(void *)v88;
      LOBYTE(v87) = v87 + 1;
      unint64_t v90 = v45 - ((*(void *)v88 & v45) >> v87);
      LODWORD(v88) = *((unsigned __int16 *)v88 + 4);
      unsigned int v74 = v44 - ((v88 & v44) >> v87);
      unint64_t v91 = (v89 & v84) >> v87;
      unsigned int v75 = (v88 & v85) >> v87;
      unint64_t v45 = v90 + v91;
LABEL_99:
      LOWORD(v81) = v74 + v75;
      goto LABEL_100;
    case 3:
      int64_t v49 = (unint64_t)HIWORD(v46) << 56;
      int v50 = (unsigned __int16 *)(v38 + (v49 >> 53));
      if (v13 < (unint64_t)v50) {
        int v50 = (unsigned __int16 *)v13;
      }
      if (v50 < v39) {
        int v50 = v39;
      }
      unint64_t v51 = ((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16);
      unint64_t v52 = v38 + SBYTE1(v46) * (uint64_t)v6;
      if (v13 >= v52) {
        int v53 = (unsigned __int16 *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      }
      else {
        int v53 = (unsigned __int16 *)v13;
      }
      if (v53 < v39) {
        int v53 = v39;
      }
      unint64_t v99 = ((unint64_t)(bswap32(v53[2]) >> 16) << 32) | ((unint64_t)(bswap32(v53[3]) >> 16) << 48) | bswap32(v53[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v53) >> 16);
      int v54 = (unsigned __int16 *)(v52 + (v49 >> 53));
      if (v13 < (unint64_t)v54) {
        int v54 = (unsigned __int16 *)v13;
      }
      if (v54 < v39) {
        int v54 = v39;
      }
      unint64_t v55 = ((unint64_t)(bswap32(v54[2]) >> 16) << 32) | ((unint64_t)(bswap32(v54[3]) >> 16) << 48) | bswap32(v54[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v54) >> 16);
      unsigned int v56 = 0xFFFF;
      unsigned int v57 = 0xFFFF;
      unsigned int v58 = 0xFFFF;
      if (v5)
      {
        float32x4_t v59 = (unsigned __int16 *)(v41 + (v49 >> 55));
        unint64_t v60 = *(void *)(result + 40);
        if (v12 < (unint64_t)v59) {
          float32x4_t v59 = (unsigned __int16 *)v12;
        }
        if ((unint64_t)v59 < v60) {
          float32x4_t v59 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v56 = bswap32(*v59) >> 16;
        unint64_t v61 = v41 + SBYTE1(v46) * (uint64_t)v107;
        if (v12 >= v61) {
          float v62 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v107);
        }
        else {
          float v62 = (unsigned __int16 *)v12;
        }
        if ((unint64_t)v62 < v60) {
          float v62 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v57 = bswap32(*v62) >> 16;
        unint64_t v63 = (unsigned __int16 *)(v61 + (v49 >> 55));
        if (v12 < (unint64_t)v63) {
          unint64_t v63 = (unsigned __int16 *)v12;
        }
        if ((unint64_t)v63 < v60) {
          unint64_t v63 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v58 = bswap32(*v63) >> 16;
      }
      unint64_t v64 = (char *)&interpolate_cmyk64 + 16 * v48;
      uint64_t v65 = *(void *)v64;
      char v66 = v48 + 1;
      unint64_t v67 = v45 - ((*(void *)v64 & v45) >> v66);
      LODWORD(v64) = *((unsigned __int16 *)v64 + 4);
      unint64_t v68 = v67 + ((v65 & v99) >> v66);
      unsigned int v69 = v44 - ((v64 & v44) >> v66) + ((v64 & v57) >> v66);
      unint64_t v70 = v51 - ((v65 & v51) >> v66) + ((v65 & v55) >> v66);
      LODWORD(v64) = v56 - ((v64 & v56) >> v66) + ((v64 & v58) >> v66);
      LODWORD(v65) = (v46 >> 28) & 3;
      unsigned int v71 = (char *)&interpolate_cmyk64 + 16 * v65;
      uint64_t v72 = *(void *)v71;
      LOBYTE(v65) = v65 + 1;
      unint64_t v73 = v68 - ((v68 & *(void *)v71) >> v65);
      LODWORD(v71) = *((unsigned __int16 *)v71 + 4);
      unsigned int v74 = v69 - ((v69 & v71) >> v65);
      unsigned int v75 = (v64 & v71) >> v65;
      unint64_t v45 = v73 + ((v70 & v72) >> v65);
      goto LABEL_99;
  }
LABEL_101:
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  a3 += v8;
  uint64_t v94 = v103 - a3;
  a2 += v9;
  uint64_t v95 = v104 - a2;
  while (1)
  {
    *(void *)(v106 + 8 + 8 * v93) = HIBYTE(v45) & 0xFFFFFF0000FFFFFFLL | ((unint64_t)BYTE1(v44) << 32) | (v45 >> 8) & 0xFF0000 | ((unint64_t)BYTE1(v45) << 24) | HIDWORD(v45) & 0xFF00;
    *(unsigned char *)(v105 + 1 + v93) = v23 >> 22;
    if (a4 - 1 == v93) {
      return result;
    }
    if ((v94 | v95 | (a3 - v102) | (a2 - v101)) < 0)
    {
      v105 += v93 + 1;
      uint64_t v106 = v106 - v92 + 8;
      a4 += ~v93;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32);
    uint64_t v39 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v38) {
      uint64_t v96 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32));
    }
    else {
      uint64_t v96 = (unsigned __int16 *)v13;
    }
    if (v96 < v39) {
      uint64_t v96 = *(unsigned __int16 **)(result + 32);
    }
    if (v5)
    {
      unint64_t v41 = v5 + SHIDWORD(a3) * (uint64_t)v107 + 2 * (a2 >> 32);
      uint64_t v97 = *(unsigned __int16 **)(result + 40);
      if (v12 >= v41) {
        unint64_t v98 = v5 + SHIDWORD(a3) * (uint64_t)v107 + 2 * (a2 >> 32);
      }
      else {
        unint64_t v98 = v12;
      }
      if (v98 >= (unint64_t)v97) {
        uint64_t v97 = (unsigned __int16 *)v98;
      }
      unsigned int v44 = bswap32(*v97) >> 16;
    }
    else
    {
      unsigned int v44 = 0xFFFF;
    }
    unint64_t v45 = ((unint64_t)(bswap32(v96[2]) >> 16) << 32) | ((unint64_t)(bswap32(v96[3]) >> 16) << 48) | bswap32(v96[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v96) >> 16);
    if (v7)
    {
      unsigned int v46 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v105 += v93 + 1;
        uint64_t v106 = v106 - v92 + 8;
        a4 += ~v93;
        unsigned int v23 = -1;
        goto LABEL_45;
      }
    }
    ++v93;
    v92 -= 8;
    a3 += v8;
    v94 -= v8;
    a2 += v9;
    v95 -= v9;
    unsigned int v23 = -1;
  }
}

uint64_t cmyk32_sample_cmyk32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v134 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v133 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v133 = v5 % v6;
    }
  }
  else
  {
    uint64_t v133 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v135 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v132 = v11;
  }
  else
  {
    uint64_t v132 = 0;
  }
  uint64_t v131 = *(void *)(result + 80);
  uint64_t v129 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 152) - 8;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (v9) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = 0xFF00000000;
  }
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  int v127 = *(_DWORD *)(result + 188);
  unint64_t v17 = (unsigned __int8 *)(v9 + (v16 - 1) + (v15 * v134));
  unint64_t v18 = v135 + (v15 * v4) + 4 * v16 - 8;
  uint64_t v128 = *(void *)(result + 64);
  uint64_t v130 = *(void *)(result + 72);
  while (1)
  {
    if (a3 >= v130)
    {
      int v22 = a4;
      if (a3 <= v129)
      {
        uint64_t v28 = 0;
        uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v30 = 0x3FFFFFFF;
        uint64_t v31 = a3;
        uint64_t v32 = v128;
        uint64_t v33 = v131;
      }
      else
      {
        uint64_t v24 = *(void *)(result + 216);
        uint64_t v25 = *(void *)(result + 224) + v129;
        uint64_t v26 = v25 - a3 + (v24 >> 1);
        if (v26 < 1) {
          goto LABEL_60;
        }
        if (v26 >= v24) {
          LODWORD(v27) = 0x3FFFFFFF;
        }
        else {
          unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
        }
        uint64_t v32 = v128;
        uint64_t v33 = v131;
        unsigned int v30 = v127 | v27;
        uint64_t v31 = v25 - 0x1000000;
        uint64_t v28 = a3 - (v25 - 0x1000000);
        uint64_t v29 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v130 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      if (v21 < 1) {
        goto LABEL_60;
      }
      if (v21 >= v19) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      uint64_t v32 = v128;
      uint64_t v33 = v131;
      unsigned int v30 = v127 | v23;
      uint64_t v31 = v20 + 0x1000000;
      uint64_t v28 = a3 - (v20 + 0x1000000);
      uint64_t v29 = 512;
    }
    if (a2 >= v32) {
      break;
    }
    uint64_t v34 = *(void *)(result + 192);
    uint64_t v35 = v32 - *(void *)(result + 200);
    uint64_t v36 = a2 - v35 + (v34 >> 1);
    if (v36 >= 1)
    {
      if (v36 < v34) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v127;
      }
      uint64_t v37 = v35 + 0x1000000;
      uint64_t v38 = a2 - (v35 + 0x1000000);
      uint64_t v39 = 32;
      goto LABEL_38;
    }
LABEL_60:
    int v57 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 8;
    *(unsigned char *)++uint64_t v13 = 0;
LABEL_61:
    a4 = v57;
    if (!v57) {
      return result;
    }
  }
  if (a2 <= v33)
  {
    uint64_t v38 = 0;
    uint64_t v39 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v37 = a2;
    goto LABEL_38;
  }
  uint64_t v40 = *(void *)(result + 192);
  uint64_t v41 = *(void *)(result + 200) + v33;
  uint64_t v42 = v41 - a2 + (v40 >> 1);
  if (v42 < 1) {
    goto LABEL_60;
  }
  if (v42 < v40) {
    unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v127;
  }
  uint64_t v37 = v41 - 0x1000000;
  uint64_t v38 = a2 - (v41 - 0x1000000);
  uint64_t v39 = 28;
LABEL_38:
  if (v30 < 0x400000) {
    goto LABEL_60;
  }
  if (v6)
  {
    uint64_t v43 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    uint64_t v44 = (v6 & ((v37 % v6) >> 63)) + v37 % v6;
    if (v43 >= v7) {
      uint64_t v45 = v7;
    }
    else {
      uint64_t v45 = 0;
    }
    uint64_t v31 = v43 - v45;
    if (v44 >= v6) {
      uint64_t v46 = v6;
    }
    else {
      uint64_t v46 = 0;
    }
    uint64_t v37 = v44 - v46;
    v28 += v31;
    v38 += v37;
  }
  uint64_t v47 = v31 >> 32;
  uint64_t v48 = v37 >> 32;
  uint64_t v49 = v135 + SHIDWORD(v31) * (uint64_t)v4;
  unint64_t v50 = v49 + 4 * v48;
  unint64_t v51 = *(unsigned int **)(result + 32);
  if (v18 >= v50) {
    unint64_t v52 = (unsigned int *)(v49 + 4 * v48);
  }
  else {
    unint64_t v52 = (unsigned int *)v18;
  }
  if (v52 < v51) {
    unint64_t v52 = *(unsigned int **)(result + 32);
  }
  unint64_t v53 = *v52;
  if (!v9)
  {
    unint64_t v54 = 0;
    if (!v8) {
      goto LABEL_139;
    }
LABEL_64:
    unsigned int v58 = *(_DWORD *)(v8 + (v39 | v29));
LABEL_66:
    int v59 = v58 & 0xF;
    uint64_t v60 = v58 >> 8;
    unsigned int v61 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      LODWORD(v88) = SBYTE1(v58);
      if (v6)
      {
        uint64_t v89 = v60 << 56;
        uint64_t v90 = v28 + (v89 >> 24);
        uint64_t v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7) {
          uint64_t v92 = v7;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      uint64_t v93 = (unsigned int *)(v50 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93) {
        uint64_t v93 = (unsigned int *)v18;
      }
      if (v93 < v51) {
        uint64_t v93 = v51;
      }
      unint64_t v94 = *v93;
      if (v9)
      {
        uint64_t v95 = (unsigned __int8 *)(v54 + (int)v88 * (uint64_t)v134);
        if (v17 < v95) {
          uint64_t v95 = v17;
        }
        if ((unint64_t)v95 < *(void *)(result + 40)) {
          uint64_t v95 = *(unsigned __int8 **)(result + 40);
        }
        v94 |= (unint64_t)*v95 << 32;
      }
      uint64_t v96 = interpolate_cif10a[v61];
      unint64_t v97 = v53 - ((v96 & v53) >> (v61 + 1));
      unint64_t v98 = (v96 & v94) >> (v61 + 1);
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          unsigned int v62 = HIBYTE(v58) & 3;
          unsigned int v126 = v30;
          int v125 = v22;
          LODWORD(v63) = SBYTE1(v58);
          uint64_t v64 = SBYTE2(v58);
          if (v6)
          {
            uint64_t v65 = v60 << 56;
            int64_t v66 = (unint64_t)HIWORD(v58) << 56;
            uint64_t v67 = v28 + (v65 >> 24);
            uint64_t v68 = v38 + (v66 >> 24);
            uint64_t v69 = v7 & (v67 >> 63);
            uint64_t v70 = v6 & (v68 >> 63);
            uint64_t v71 = v70 + v68;
            if (v69 + v67 >= v7) {
              uint64_t v72 = v7;
            }
            else {
              uint64_t v72 = 0;
            }
            if (v71 >= v6) {
              uint64_t v73 = v6;
            }
            else {
              uint64_t v73 = 0;
            }
            uint64_t v63 = (v69 + (v65 >> 24) - v72) >> 32;
            uint64_t v64 = (v70 + (v66 >> 24) - v73) >> 32;
          }
          unsigned int v74 = (unsigned int *)(v50 + 4 * v64);
          if (v18 < (unint64_t)v74) {
            unsigned int v74 = (unsigned int *)v18;
          }
          if (v74 < v51) {
            unsigned int v74 = v51;
          }
          unint64_t v75 = *v74;
          unint64_t v76 = v50 + (int)v63 * (uint64_t)v4;
          if (v18 >= v76) {
            unint64_t v77 = (unsigned int *)(v50 + (int)v63 * (uint64_t)v4);
          }
          else {
            unint64_t v77 = (unsigned int *)v18;
          }
          if (v77 < v51) {
            unint64_t v77 = v51;
          }
          unint64_t v78 = *v77;
          unint64_t v79 = (unsigned int *)(v76 + 4 * v64);
          if (v18 < (unint64_t)v79) {
            unint64_t v79 = (unsigned int *)v18;
          }
          if (v79 >= v51) {
            unint64_t v51 = v79;
          }
          unint64_t v80 = *v51;
          if (v9)
          {
            int v81 = (unsigned __int8 *)(v54 + v64);
            unint64_t v82 = *(void *)(result + 40);
            if ((unint64_t)v17 < v54 + v64) {
              int v81 = v17;
            }
            if ((unint64_t)v81 < v82) {
              int v81 = *(unsigned __int8 **)(result + 40);
            }
            v75 |= (unint64_t)*v81 << 32;
            unint64_t v83 = v54 + (int)v63 * (uint64_t)v134;
            if ((unint64_t)v17 >= v83) {
              unint64_t v84 = (unsigned __int8 *)(v54 + (int)v63 * (uint64_t)v134);
            }
            else {
              unint64_t v84 = v17;
            }
            if ((unint64_t)v84 < v82) {
              unint64_t v84 = *(unsigned __int8 **)(result + 40);
            }
            v78 |= (unint64_t)*v84 << 32;
            unsigned int v85 = (unsigned __int8 *)(v83 + v64);
            if (v17 < v85) {
              unsigned int v85 = v17;
            }
            if ((unint64_t)v85 < v82) {
              unsigned int v85 = *(unsigned __int8 **)(result + 40);
            }
            v80 |= (unint64_t)*v85 << 32;
          }
          uint64_t v86 = interpolate_cif10a[v62];
          unint64_t v87 = v53 - ((v86 & v53) >> (v62 + 1)) + ((v86 & v78) >> (v62 + 1));
          unint64_t v53 = v87
              - ((v87 & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1))
              + (((v75 - ((v86 & v75) >> (v62 + 1)) + ((v86 & v80) >> (v62 + 1))) & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1));
          int v22 = v125;
          unsigned int v30 = v126;
        }
        goto LABEL_139;
      }
      uint64_t v99 = SBYTE2(v58);
      if (v6)
      {
        int64_t v100 = (unint64_t)HIWORD(v58) << 56;
        uint64_t v101 = v38 + (v100 >> 24);
        uint64_t v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6) {
          uint64_t v103 = v6;
        }
        else {
          uint64_t v103 = 0;
        }
        uint64_t v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      uint64_t v104 = (unsigned int *)(v50 + 4 * v99);
      if (v18 < (unint64_t)v104) {
        uint64_t v104 = (unsigned int *)v18;
      }
      if (v104 < v51) {
        uint64_t v104 = v51;
      }
      unint64_t v105 = *v104;
      if (v9)
      {
        uint64_t v106 = (unsigned __int8 *)(v54 + v99);
        if (v17 < v106) {
          uint64_t v106 = v17;
        }
        if ((unint64_t)v106 < *(void *)(result + 40)) {
          uint64_t v106 = *(unsigned __int8 **)(result + 40);
        }
        v105 |= (unint64_t)*v106 << 32;
      }
      unsigned int v107 = (v58 >> 28) & 3;
      uint64_t v108 = interpolate_cif10a[v107];
      LOBYTE(v107) = v107 + 1;
      unint64_t v97 = v53 - ((v108 & v53) >> v107);
      unint64_t v98 = (v108 & v105) >> v107;
    }
    unint64_t v53 = v97 + v98;
    goto LABEL_139;
  }
  unint64_t v54 = v9 + (int)v47 * (uint64_t)v134 + v48;
  unint64_t v55 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v17 >= v54) {
    unsigned int v56 = (unsigned __int8 *)v54;
  }
  else {
    unsigned int v56 = v17;
  }
  if (v56 >= v55) {
    unint64_t v55 = v56;
  }
  v53 |= (unint64_t)*v55 << 32;
  if (v8) {
    goto LABEL_64;
  }
LABEL_139:
  *(void *)(v12 + 8) = v53 | v14;
  *(unsigned char *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    int v109 = v22;
    uint64_t v110 = 0;
    a2 += v5;
    uint64_t v111 = v131 - a2;
    a3 += v10;
    uint64_t v112 = v129 - a3;
    uint64_t v113 = -8;
    while (((v112 | v111 | (a3 - v130) | (a2 - v128)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        uint64_t v115 = (v6 & ((v38 + v133) >> 63)) + v38 + v133;
        if (v114 >= v7) {
          uint64_t v116 = v7;
        }
        else {
          uint64_t v116 = 0;
        }
        uint64_t v117 = v114 - v116;
        if (v115 >= v6) {
          uint64_t v118 = v6;
        }
        else {
          uint64_t v118 = 0;
        }
        uint64_t v119 = v115 - v118;
        uint64_t v38 = v119;
        uint64_t v28 = v117;
      }
      else
      {
        uint64_t v119 = a2;
        uint64_t v117 = a3;
      }
      uint64_t v120 = v117 >> 32;
      uint64_t v121 = v119 >> 32;
      unint64_t v50 = v135 + SHIDWORD(v117) * (uint64_t)v4 + 4 * (v119 >> 32);
      unint64_t v51 = *(unsigned int **)(result + 32);
      if (v18 >= v50) {
        float v122 = (unsigned int *)v50;
      }
      else {
        float v122 = (unsigned int *)v18;
      }
      if (v122 < v51) {
        float v122 = *(unsigned int **)(result + 32);
      }
      unint64_t v53 = *v122;
      if (v9)
      {
        unint64_t v54 = v9 + (int)v120 * (uint64_t)v134 + v121;
        int v123 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v17 >= v54) {
          uint64_t v124 = (unsigned __int8 *)v54;
        }
        else {
          uint64_t v124 = v17;
        }
        if (v124 >= v123) {
          int v123 = v124;
        }
        v53 |= (unint64_t)*v123 << 32;
      }
      if (v8)
      {
        unsigned int v58 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v58 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          int v22 = ~v110 + v109;
          unsigned int v30 = -1;
          goto LABEL_66;
        }
      }
      *(void *)(v12 + 8 * v110 + 16) = v53 | v14;
      *(unsigned char *)(v13 + v110++ + 2) = -1;
      v113 -= 8;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == v110) {
        return result;
      }
    }
    v13 += v110 + 1;
    v12 -= v113;
    int v57 = ~v110 + v109;
    goto LABEL_61;
  }
  return result;
}

uint64_t cmyk32_sample_CMYK32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v134 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v133 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v133 = v5 % v6;
    }
  }
  else
  {
    uint64_t v133 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v135 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v132 = v11;
  }
  else
  {
    uint64_t v132 = 0;
  }
  uint64_t v131 = *(void *)(result + 80);
  uint64_t v129 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 152) - 8;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (v9) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = 0xFF00000000;
  }
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  int v127 = *(_DWORD *)(result + 188);
  unint64_t v17 = (unsigned __int8 *)(v9 + (v16 - 1) + (v15 * v134));
  unint64_t v18 = v135 + (v15 * v4) + 4 * v16 - 8;
  uint64_t v128 = *(void *)(result + 64);
  uint64_t v130 = *(void *)(result + 72);
  while (1)
  {
    if (a3 >= v130)
    {
      int v22 = a4;
      if (a3 <= v129)
      {
        uint64_t v28 = 0;
        uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v30 = 0x3FFFFFFF;
        uint64_t v31 = a3;
        uint64_t v32 = v128;
        uint64_t v33 = v131;
      }
      else
      {
        uint64_t v24 = *(void *)(result + 216);
        uint64_t v25 = *(void *)(result + 224) + v129;
        uint64_t v26 = v25 - a3 + (v24 >> 1);
        if (v26 < 1) {
          goto LABEL_60;
        }
        if (v26 >= v24) {
          LODWORD(v27) = 0x3FFFFFFF;
        }
        else {
          unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
        }
        uint64_t v32 = v128;
        uint64_t v33 = v131;
        unsigned int v30 = v127 | v27;
        uint64_t v31 = v25 - 0x1000000;
        uint64_t v28 = a3 - v31;
        uint64_t v29 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v130 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      if (v21 < 1) {
        goto LABEL_60;
      }
      if (v21 >= v19) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      uint64_t v32 = v128;
      uint64_t v33 = v131;
      unsigned int v30 = v127 | v23;
      uint64_t v31 = v20 + 0x1000000;
      uint64_t v28 = a3 - v31;
      uint64_t v29 = 512;
    }
    if (a2 >= v32) {
      break;
    }
    uint64_t v34 = *(void *)(result + 192);
    uint64_t v35 = v32 - *(void *)(result + 200);
    uint64_t v36 = a2 - v35 + (v34 >> 1);
    if (v36 >= 1)
    {
      if (v36 < v34) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v127;
      }
      uint64_t v37 = v35 + 0x1000000;
      uint64_t v38 = a2 - (v35 + 0x1000000);
      uint64_t v39 = 32;
      goto LABEL_38;
    }
LABEL_60:
    int v57 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 8;
    *(unsigned char *)++uint64_t v13 = 0;
LABEL_61:
    a4 = v57;
    if (!v57) {
      return result;
    }
  }
  if (a2 <= v33)
  {
    uint64_t v38 = 0;
    uint64_t v39 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v37 = a2;
    goto LABEL_38;
  }
  uint64_t v40 = *(void *)(result + 192);
  uint64_t v41 = *(void *)(result + 200) + v33;
  uint64_t v42 = v41 - a2 + (v40 >> 1);
  if (v42 < 1) {
    goto LABEL_60;
  }
  if (v42 < v40) {
    unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v127;
  }
  uint64_t v37 = v41 - 0x1000000;
  uint64_t v38 = a2 - (v41 - 0x1000000);
  uint64_t v39 = 28;
LABEL_38:
  if (v30 < 0x400000) {
    goto LABEL_60;
  }
  if (v6)
  {
    uint64_t v43 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    uint64_t v44 = (v6 & ((v37 % v6) >> 63)) + v37 % v6;
    if (v43 >= v7) {
      uint64_t v45 = v7;
    }
    else {
      uint64_t v45 = 0;
    }
    uint64_t v31 = v43 - v45;
    if (v44 >= v6) {
      uint64_t v46 = v6;
    }
    else {
      uint64_t v46 = 0;
    }
    uint64_t v37 = v44 - v46;
    v28 += v31;
    v38 += v37;
  }
  uint64_t v47 = v31 >> 32;
  uint64_t v48 = v37 >> 32;
  uint64_t v49 = v135 + (int)v47 * (uint64_t)v4;
  unint64_t v50 = v49 + 4 * v48;
  unint64_t v51 = *(unsigned int **)(result + 32);
  if (v18 >= v50) {
    unint64_t v52 = (unsigned int *)(v49 + 4 * v48);
  }
  else {
    unint64_t v52 = (unsigned int *)v18;
  }
  if (v52 < v51) {
    unint64_t v52 = *(unsigned int **)(result + 32);
  }
  unint64_t v53 = bswap32(*v52);
  if (!v9)
  {
    unint64_t v54 = 0;
    if (!v8) {
      goto LABEL_139;
    }
LABEL_64:
    unsigned int v58 = *(_DWORD *)(v8 + (v39 | v29));
LABEL_66:
    int v59 = v58 & 0xF;
    uint64_t v60 = v58 >> 8;
    int v61 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      LODWORD(v88) = SBYTE1(v58);
      if (v6)
      {
        uint64_t v89 = v60 << 56;
        uint64_t v90 = v28 + (v89 >> 24);
        uint64_t v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7) {
          uint64_t v92 = v7;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      uint64_t v93 = (unsigned int *)(v50 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93) {
        uint64_t v93 = (unsigned int *)v18;
      }
      if (v93 < v51) {
        uint64_t v93 = v51;
      }
      unint64_t v94 = bswap32(*v93);
      if (v9)
      {
        uint64_t v95 = (unsigned __int8 *)(v54 + (int)v88 * (uint64_t)v134);
        if (v17 < v95) {
          uint64_t v95 = v17;
        }
        if ((unint64_t)v95 < *(void *)(result + 40)) {
          uint64_t v95 = *(unsigned __int8 **)(result + 40);
        }
        v94 |= (unint64_t)*v95 << 32;
      }
      uint64_t v96 = interpolate_cif10a[v61];
      unint64_t v97 = v53 - ((v96 & v53) >> (v61 + 1));
      unint64_t v98 = (v96 & v94) >> (v61 + 1);
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          int v62 = HIBYTE(v58) & 3;
          unsigned int v126 = v30;
          int v125 = v22;
          LODWORD(v63) = SBYTE1(v58);
          uint64_t v64 = SBYTE2(v58);
          if (v6)
          {
            uint64_t v65 = v60 << 56;
            int64_t v66 = (unint64_t)HIWORD(v58) << 56;
            uint64_t v67 = v28 + (v65 >> 24);
            uint64_t v68 = v38 + (v66 >> 24);
            uint64_t v69 = v7 & (v67 >> 63);
            uint64_t v70 = v6 & (v68 >> 63);
            uint64_t v71 = v70 + v68;
            if (v69 + v67 >= v7) {
              uint64_t v72 = v7;
            }
            else {
              uint64_t v72 = 0;
            }
            if (v71 >= v6) {
              uint64_t v73 = v6;
            }
            else {
              uint64_t v73 = 0;
            }
            uint64_t v63 = (v69 + (v65 >> 24) - v72) >> 32;
            uint64_t v64 = (v70 + (v66 >> 24) - v73) >> 32;
          }
          unsigned int v74 = (unsigned int *)(v50 + 4 * v64);
          if (v18 < (unint64_t)v74) {
            unsigned int v74 = (unsigned int *)v18;
          }
          if (v74 < v51) {
            unsigned int v74 = v51;
          }
          unint64_t v75 = bswap32(*v74);
          unint64_t v76 = v50 + (int)v63 * (uint64_t)v4;
          if (v18 >= v76) {
            unint64_t v77 = (unsigned int *)(v50 + (int)v63 * (uint64_t)v4);
          }
          else {
            unint64_t v77 = (unsigned int *)v18;
          }
          if (v77 < v51) {
            unint64_t v77 = v51;
          }
          unint64_t v78 = bswap32(*v77);
          unint64_t v79 = (unsigned int *)(v76 + 4 * v64);
          if (v18 < (unint64_t)v79) {
            unint64_t v79 = (unsigned int *)v18;
          }
          if (v79 >= v51) {
            unint64_t v51 = v79;
          }
          unint64_t v80 = bswap32(*v51);
          if (v9)
          {
            int v81 = (unsigned __int8 *)(v54 + v64);
            unint64_t v82 = *(void *)(result + 40);
            if ((unint64_t)v17 < v54 + v64) {
              int v81 = v17;
            }
            if ((unint64_t)v81 < v82) {
              int v81 = *(unsigned __int8 **)(result + 40);
            }
            v75 |= (unint64_t)*v81 << 32;
            unint64_t v83 = v54 + (int)v63 * (uint64_t)v134;
            if ((unint64_t)v17 >= v83) {
              unint64_t v84 = (unsigned __int8 *)(v54 + (int)v63 * (uint64_t)v134);
            }
            else {
              unint64_t v84 = v17;
            }
            if ((unint64_t)v84 < v82) {
              unint64_t v84 = *(unsigned __int8 **)(result + 40);
            }
            v78 |= (unint64_t)*v84 << 32;
            unsigned int v85 = (unsigned __int8 *)(v83 + v64);
            if (v17 < v85) {
              unsigned int v85 = v17;
            }
            if ((unint64_t)v85 < v82) {
              unsigned int v85 = *(unsigned __int8 **)(result + 40);
            }
            v80 |= (unint64_t)*v85 << 32;
          }
          uint64_t v86 = interpolate_cif10a[v62];
          unint64_t v87 = v53 - ((v86 & v53) >> (v62 + 1)) + ((v86 & v78) >> (v62 + 1));
          unint64_t v53 = v87
              - ((v87 & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1))
              + (((v75 - ((v86 & v75) >> (v62 + 1)) + ((v86 & v80) >> (v62 + 1))) & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1));
          int v22 = v125;
          unsigned int v30 = v126;
        }
        goto LABEL_139;
      }
      uint64_t v99 = SBYTE2(v58);
      if (v6)
      {
        int64_t v100 = (unint64_t)HIWORD(v58) << 56;
        uint64_t v101 = v38 + (v100 >> 24);
        uint64_t v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6) {
          uint64_t v103 = v6;
        }
        else {
          uint64_t v103 = 0;
        }
        uint64_t v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      uint64_t v104 = (unsigned int *)(v50 + 4 * v99);
      if (v18 < (unint64_t)v104) {
        uint64_t v104 = (unsigned int *)v18;
      }
      if (v104 < v51) {
        uint64_t v104 = v51;
      }
      unint64_t v105 = bswap32(*v104);
      if (v9)
      {
        uint64_t v106 = (unsigned __int8 *)(v54 + v99);
        if (v17 < v106) {
          uint64_t v106 = v17;
        }
        if ((unint64_t)v106 < *(void *)(result + 40)) {
          uint64_t v106 = *(unsigned __int8 **)(result + 40);
        }
        v105 |= (unint64_t)*v106 << 32;
      }
      int v107 = (v58 >> 28) & 3;
      uint64_t v108 = interpolate_cif10a[v107];
      LOBYTE(v107) = v107 + 1;
      unint64_t v97 = v53 - ((v108 & v53) >> v107);
      unint64_t v98 = (v108 & v105) >> v107;
    }
    unint64_t v53 = v97 + v98;
    goto LABEL_139;
  }
  unint64_t v54 = v9 + (int)v47 * (uint64_t)v134 + v48;
  unint64_t v55 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v17 >= v54) {
    unsigned int v56 = (unsigned __int8 *)v54;
  }
  else {
    unsigned int v56 = v17;
  }
  if (v56 >= v55) {
    unint64_t v55 = v56;
  }
  v53 |= (unint64_t)*v55 << 32;
  if (v8) {
    goto LABEL_64;
  }
LABEL_139:
  *(void *)(v12 + 8) = v53 | v14;
  *(unsigned char *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    int v109 = v22;
    uint64_t v110 = 0;
    a2 += v5;
    uint64_t v111 = v131 - a2;
    a3 += v10;
    uint64_t v112 = v129 - a3;
    uint64_t v113 = -8;
    while (((v112 | v111 | (a3 - v130) | (a2 - v128)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        uint64_t v115 = (v6 & ((v38 + v133) >> 63)) + v38 + v133;
        if (v114 >= v7) {
          uint64_t v116 = v7;
        }
        else {
          uint64_t v116 = 0;
        }
        uint64_t v117 = v114 - v116;
        if (v115 >= v6) {
          uint64_t v118 = v6;
        }
        else {
          uint64_t v118 = 0;
        }
        uint64_t v119 = v115 - v118;
        uint64_t v38 = v119;
        uint64_t v28 = v117;
      }
      else
      {
        uint64_t v119 = a2;
        uint64_t v117 = a3;
      }
      uint64_t v120 = v117 >> 32;
      uint64_t v121 = v119 >> 32;
      unint64_t v50 = v135 + SHIDWORD(v117) * (uint64_t)v4 + 4 * (v119 >> 32);
      unint64_t v51 = *(unsigned int **)(result + 32);
      if (v18 >= v50) {
        float v122 = (unsigned int *)v50;
      }
      else {
        float v122 = (unsigned int *)v18;
      }
      if (v122 < v51) {
        float v122 = *(unsigned int **)(result + 32);
      }
      unint64_t v53 = bswap32(*v122);
      if (v9)
      {
        unint64_t v54 = v9 + (int)v120 * (uint64_t)v134 + v121;
        int v123 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v17 >= v54) {
          uint64_t v124 = (unsigned __int8 *)v54;
        }
        else {
          uint64_t v124 = v17;
        }
        if (v124 >= v123) {
          int v123 = v124;
        }
        v53 |= (unint64_t)*v123 << 32;
      }
      if (v8)
      {
        unsigned int v58 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v58 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          int v22 = ~v110 + v109;
          unsigned int v30 = -1;
          goto LABEL_66;
        }
      }
      *(void *)(v12 + 8 * v110 + 16) = v53 | v14;
      *(unsigned char *)(v13 + v110++ + 2) = -1;
      v113 -= 8;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == v110) {
        return result;
      }
    }
    v13 += v110 + 1;
    v12 -= v113;
    int v57 = ~v110 + v109;
    goto LABEL_61;
  }
  return result;
}

unint64_t *cmyk32_sample_argb32(unint64_t *result, uint64_t a2, int64_t a3, int a4)
{
  unint64_t v6 = result[22];
  uint64_t v68 = result[10];
  int64_t v71 = result[11];
  unint64_t v78 = result[14];
  unint64_t v77 = result[15];
  int v67 = *((_DWORD *)result + 47);
  uint64_t v7 = (unint64_t *)(result[19] - 8);
  uint64_t v72 = result[18] - 1;
  if (result[5]) {
    int v8 = 0;
  }
  else {
    int v8 = -16777216;
  }
  int v74 = v8;
  int v75 = *((_DWORD *)result + 6);
  unint64_t v73 = result[4];
  unint64_t v79 = result;
  unint64_t v76 = v73 + ((*((_DWORD *)result + 65) - 1) * v75) + 4 * *((unsigned int *)result + 64) - 4;
  unint64_t v69 = result[8];
  int64_t v70 = result[9];
  while (1)
  {
    if (a3 >= v70)
    {
      if (a3 <= v71)
      {
        uint64_t v19 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        int v12 = a4;
        uint64_t v13 = v69;
      }
      else
      {
        uint64_t v15 = v79[27];
        unint64_t v16 = v79[28] + v71;
        uint64_t v17 = v16 - a3 + (v15 >> 1);
        int v12 = a4;
        uint64_t v13 = v69;
        if (v17 < 1) {
          goto LABEL_36;
        }
        if (v17 >= v15) {
          LODWORD(v18) = 0x3FFFFFFF;
        }
        else {
          unint64_t v18 = (v79[29] * v17) >> 32;
        }
        unsigned int v20 = v67 | v18;
        unint64_t v21 = v16 - 0x1000000;
        uint64_t v19 = 448;
      }
    }
    else
    {
      uint64_t v9 = v79[27];
      unint64_t v10 = v70 - v79[28];
      uint64_t v11 = a3 - v10 + (v9 >> 1);
      int v12 = a4;
      uint64_t v13 = v69;
      if (v11 < 1) {
        goto LABEL_36;
      }
      if (v11 >= v9) {
        LODWORD(v14) = 0x3FFFFFFF;
      }
      else {
        unint64_t v14 = (v79[29] * v11) >> 32;
      }
      unsigned int v20 = v67 | v14;
      unint64_t v21 = v10 + 0x1000000;
      uint64_t v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v68)
      {
        uint64_t v26 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v25 = a2;
      }
      else
      {
        uint64_t v27 = v79[24];
        unint64_t v28 = v79[25] + v68;
        uint64_t v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1) {
          goto LABEL_36;
        }
        if (v29 < v27) {
          unsigned int v20 = ((v20 >> 15) * (((v79[26] * v29) >> 32) >> 15)) | v67;
        }
        uint64_t v25 = v28 - 0x1000000;
        uint64_t v26 = 28;
      }
    }
    else
    {
      uint64_t v22 = v79[24];
      unint64_t v23 = v13 - v79[25];
      uint64_t v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_36;
      }
      if (v24 < v22) {
        unsigned int v20 = ((v20 >> 15) * (((v79[26] * v24) >> 32) >> 15)) | v67;
      }
      uint64_t v25 = v23 + 0x1000000;
      uint64_t v26 = 32;
    }
    if (v20 >= 0x400000) {
      break;
    }
LABEL_36:
    int v35 = v12 - 1;
    a2 += v78;
    a3 += v77;
    ++v7;
    *(unsigned char *)++uint64_t v72 = 0;
LABEL_37:
    a4 = v35;
    if (!v35) {
      return result;
    }
  }
  unint64_t v30 = v73 + SHIDWORD(v21) * (uint64_t)v75 + 4 * (v25 >> 32);
  uint64_t v31 = (unsigned int *)v79[4];
  uint64_t v32 = (unsigned int *)v76;
  if (v76 >= v30) {
    uint64_t v32 = (unsigned int *)v30;
  }
  if (v32 < v31) {
    uint64_t v32 = (unsigned int *)v79[4];
  }
  unsigned int v33 = *v32;
  if (!v6) {
    goto LABEL_69;
  }
  unsigned int v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_40:
  int v36 = v34 & 0xF;
  int v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      unint64_t v54 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 < (unint64_t)v54) {
        unint64_t v54 = (unsigned int *)v76;
      }
      if (v54 >= v31) {
        uint64_t v31 = v54;
      }
      unsigned int v55 = interpolate_8888_21358[v37];
      char v56 = v37 + 1;
      unsigned int v52 = v33 - ((v55 & v33) >> v56);
      unsigned int v57 = (v55 & *v31) >> v56;
LABEL_68:
      unsigned int v33 = v52 + v57;
      break;
    case 2:
      unsigned int v58 = (unsigned int *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 54));
      if (v76 < (unint64_t)v58) {
        unsigned int v58 = (unsigned int *)v76;
      }
      if (v58 >= v31) {
        uint64_t v31 = v58;
      }
      int v59 = (v34 >> 28) & 3;
      int v60 = interpolate_8888_21358[v59];
      char v51 = v59 + 1;
      unsigned int v52 = v33 - ((v60 & v33) >> v51);
      unsigned int v53 = v60 & *v31;
LABEL_67:
      unsigned int v57 = v53 >> v51;
      goto LABEL_68;
    case 3:
      int64_t v38 = (unint64_t)HIWORD(v34) << 56;
      uint64_t v39 = (unsigned int *)(v30 + (v38 >> 54));
      if (v76 < (unint64_t)v39) {
        uint64_t v39 = (unsigned int *)v76;
      }
      if (v39 < v31) {
        uint64_t v39 = v31;
      }
      unsigned int v40 = *v39;
      uint64_t v41 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 >= (unint64_t)v41) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = (unsigned int *)v76;
      }
      if (v42 < v31) {
        uint64_t v42 = v31;
      }
      unsigned int v43 = *v42;
      uint64_t v44 = (unsigned int *)((char *)v41 + (v38 >> 54));
      if (v76 < (unint64_t)v44) {
        uint64_t v44 = (unsigned int *)v76;
      }
      if (v44 >= v31) {
        uint64_t v31 = v44;
      }
      unsigned int v45 = interpolate_8888_21358[v37];
      char v46 = v37 + 1;
      unsigned int v47 = v33 - ((v45 & v33) >> v46) + ((v45 & v43) >> v46);
      unsigned int v48 = v40 - ((v45 & v40) >> v46) + ((v45 & *v31) >> v46);
      int v49 = (v34 >> 28) & 3;
      int v50 = interpolate_8888_21358[v49];
      char v51 = v49 + 1;
      unsigned int v52 = v47 - ((v47 & v50) >> v51);
      unsigned int v53 = v48 & v50;
      goto LABEL_67;
  }
LABEL_69:
  uint64_t v61 = 0;
  ++v7;
  int v66 = v12;
  int v62 = v12 - 1;
  a3 += v77;
  int64_t v63 = v71 - a3;
  a2 += v78;
  uint64_t v64 = v68 - a2;
  while (1)
  {
    uint64_t result = ARGB32(v7, v33 | v74);
    *(unsigned char *)(v72 + 1 + v61) = v20 >> 22;
    if (v62 == v61) {
      return result;
    }
    if (((v63 | v64 | (a3 - v70) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v72 += v61 + 1;
      int v35 = ~v61 + v66;
      goto LABEL_37;
    }
    unint64_t v30 = v73 + SHIDWORD(a3) * (uint64_t)v75 + 4 * (a2 >> 32);
    uint64_t v31 = (unsigned int *)v79[4];
    uint64_t v65 = (unsigned int *)v76;
    if (v76 >= v30) {
      uint64_t v65 = (unsigned int *)(v73 + SHIDWORD(a3) * (uint64_t)v75 + 4 * (a2 >> 32));
    }
    if (v65 < v31) {
      uint64_t v65 = (unsigned int *)v79[4];
    }
    unsigned int v33 = *v65;
    if (v6)
    {
      unsigned int v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v72 += v61 + 1;
        int v12 = ~v61 + v66;
        unsigned int v20 = -1;
        goto LABEL_40;
      }
    }
    ++v7;
    ++v61;
    a3 += v77;
    v63 -= v77;
    a2 += v78;
    v64 -= v78;
    unsigned int v20 = -1;
  }
}

unint64_t *ARGB32(unint64_t *result, int a2)
{
  HIDWORD(v3) = a2;
  LODWORD(v3) = a2;
  unsigned int v2 = v3 >> 24;
  unsigned int v4 = HIBYTE(v2);
  if (HIBYTE(v2) <= BYTE2(v2)) {
    unsigned int v4 = BYTE2(v2);
  }
  if (v4 <= BYTE1(v2)) {
    unsigned int v4 = BYTE1(v2);
  }
  *uint64_t result = (int)((v2 - v4) | ((v4 - BYTE2(v2)) << 16) | ((v4 - HIBYTE(v2)) << 24) | ((v4 - BYTE1(v2)) << 8)) | ((unint64_t)v2 << 32);
  return result;
}

unint64_t *cmyk32_sample_ARGB32(unint64_t *result, uint64_t a2, int64_t a3, int a4)
{
  unint64_t v6 = result[22];
  uint64_t v65 = result[10];
  int64_t v68 = result[11];
  unint64_t v75 = result[14];
  unint64_t v74 = result[15];
  int v64 = *((_DWORD *)result + 47);
  uint64_t v7 = (unint64_t *)(result[19] - 8);
  uint64_t v69 = result[18] - 1;
  if (result[5]) {
    int v8 = 0;
  }
  else {
    int v8 = -16777216;
  }
  int v71 = v8;
  int v72 = *((_DWORD *)result + 6);
  unint64_t v70 = result[4];
  unint64_t v76 = result;
  unint64_t v73 = v70 + ((*((_DWORD *)result + 65) - 1) * v72) + 4 * *((unsigned int *)result + 64) - 4;
  unint64_t v66 = result[8];
  int64_t v67 = result[9];
  while (1)
  {
    if (a3 >= v67)
    {
      if (a3 <= v68)
      {
        uint64_t v19 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        int v12 = a4;
        uint64_t v13 = v66;
      }
      else
      {
        uint64_t v15 = v76[27];
        unint64_t v16 = v76[28] + v68;
        uint64_t v17 = v16 - a3 + (v15 >> 1);
        int v12 = a4;
        uint64_t v13 = v66;
        if (v17 < 1) {
          goto LABEL_36;
        }
        if (v17 >= v15) {
          LODWORD(v18) = 0x3FFFFFFF;
        }
        else {
          unint64_t v18 = (v76[29] * v17) >> 32;
        }
        unsigned int v20 = v64 | v18;
        unint64_t v21 = v16 - 0x1000000;
        uint64_t v19 = 448;
      }
    }
    else
    {
      uint64_t v9 = v76[27];
      unint64_t v10 = v67 - v76[28];
      uint64_t v11 = a3 - v10 + (v9 >> 1);
      int v12 = a4;
      uint64_t v13 = v66;
      if (v11 < 1) {
        goto LABEL_36;
      }
      if (v11 >= v9) {
        LODWORD(v14) = 0x3FFFFFFF;
      }
      else {
        unint64_t v14 = (v76[29] * v11) >> 32;
      }
      unsigned int v20 = v64 | v14;
      unint64_t v21 = v10 + 0x1000000;
      uint64_t v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v65)
      {
        uint64_t v26 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v25 = a2;
      }
      else
      {
        uint64_t v27 = v76[24];
        unint64_t v28 = v76[25] + v65;
        uint64_t v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1) {
          goto LABEL_36;
        }
        if (v29 < v27) {
          unsigned int v20 = ((v20 >> 15) * (((v76[26] * v29) >> 32) >> 15)) | v64;
        }
        uint64_t v25 = v28 - 0x1000000;
        uint64_t v26 = 28;
      }
    }
    else
    {
      uint64_t v22 = v76[24];
      unint64_t v23 = v13 - v76[25];
      uint64_t v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_36;
      }
      if (v24 < v22) {
        unsigned int v20 = ((v20 >> 15) * (((v76[26] * v24) >> 32) >> 15)) | v64;
      }
      uint64_t v25 = v23 + 0x1000000;
      uint64_t v26 = 32;
    }
    if (v20 >= 0x400000) {
      break;
    }
LABEL_36:
    int v35 = v12 - 1;
    a2 += v75;
    a3 += v74;
    ++v7;
    *(unsigned char *)++uint64_t v69 = 0;
LABEL_37:
    a4 = v35;
    if (!v35) {
      return result;
    }
  }
  unint64_t v30 = v70 + SHIDWORD(v21) * (uint64_t)v72 + 4 * (v25 >> 32);
  uint64_t v31 = (unsigned int *)v76[4];
  uint64_t v32 = (unsigned int *)v73;
  if (v73 >= v30) {
    uint64_t v32 = (unsigned int *)v30;
  }
  if (v32 < v31) {
    uint64_t v32 = (unsigned int *)v76[4];
  }
  unsigned int v33 = bswap32(*v32);
  if (!v6) {
    goto LABEL_69;
  }
  unsigned int v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_40:
  int v36 = v34 & 0xF;
  int v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      char v51 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 < (unint64_t)v51) {
        char v51 = (unsigned int *)v73;
      }
      if (v51 >= v31) {
        uint64_t v31 = v51;
      }
      int v52 = interpolate_8888_21358[v37];
      char v53 = v37 + 1;
      unsigned int v54 = v33 - ((v52 & v33) >> v53);
      unsigned int v55 = (bswap32(*v31) & v52) >> v53;
LABEL_68:
      unsigned int v33 = v54 + v55;
      break;
    case 2:
      char v56 = (unsigned int *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 54));
      if (v73 < (unint64_t)v56) {
        char v56 = (unsigned int *)v73;
      }
      if (v56 >= v31) {
        uint64_t v31 = v56;
      }
      unsigned int v47 = bswap32(*v31);
      int v48 = (v34 >> 28) & 3;
      int v49 = interpolate_8888_21358[v48];
      unsigned int v50 = v49 & v33;
LABEL_67:
      char v57 = v48 + 1;
      unsigned int v54 = v33 - (v50 >> v57);
      unsigned int v55 = (v47 & v49) >> v57;
      goto LABEL_68;
    case 3:
      int64_t v38 = (unint64_t)HIWORD(v34) << 56;
      uint64_t v39 = (unsigned int *)(v30 + (v38 >> 54));
      if (v73 < (unint64_t)v39) {
        uint64_t v39 = (unsigned int *)v73;
      }
      if (v39 < v31) {
        uint64_t v39 = v31;
      }
      unsigned int v40 = bswap32(*v39);
      uint64_t v41 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 >= (unint64_t)v41) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = (unsigned int *)v73;
      }
      if (v42 < v31) {
        uint64_t v42 = v31;
      }
      unsigned int v43 = bswap32(*v42);
      uint64_t v44 = (unsigned int *)((char *)v41 + (v38 >> 54));
      if (v73 < (unint64_t)v44) {
        uint64_t v44 = (unsigned int *)v73;
      }
      if (v44 >= v31) {
        uint64_t v31 = v44;
      }
      int v45 = interpolate_8888_21358[v37];
      char v46 = v37 + 1;
      unsigned int v33 = v33 - ((v45 & v33) >> v46) + ((v45 & v43) >> v46);
      unsigned int v47 = v40 - ((v45 & v40) >> v46) + ((bswap32(*v31) & v45) >> v46);
      int v48 = (v34 >> 28) & 3;
      int v49 = interpolate_8888_21358[v48];
      unsigned int v50 = v33 & v49;
      goto LABEL_67;
  }
LABEL_69:
  uint64_t v58 = 0;
  ++v7;
  int v63 = v12;
  int v59 = v12 - 1;
  a3 += v74;
  int64_t v60 = v68 - a3;
  a2 += v75;
  uint64_t v61 = v65 - a2;
  while (1)
  {
    uint64_t result = ARGB32(v7, v33 | v71);
    *(unsigned char *)(v69 + 1 + v58) = v20 >> 22;
    if (v59 == v58) {
      return result;
    }
    if (((v60 | v61 | (a3 - v67) | (a2 - v66)) & 0x8000000000000000) != 0)
    {
      v69 += v58 + 1;
      int v35 = ~v58 + v63;
      goto LABEL_37;
    }
    unint64_t v30 = v70 + SHIDWORD(a3) * (uint64_t)v72 + 4 * (a2 >> 32);
    uint64_t v31 = (unsigned int *)v76[4];
    int v62 = (unsigned int *)v73;
    if (v73 >= v30) {
      int v62 = (unsigned int *)(v70 + SHIDWORD(a3) * (uint64_t)v72 + 4 * (a2 >> 32));
    }
    if (v62 < v31) {
      int v62 = (unsigned int *)v76[4];
    }
    unsigned int v33 = bswap32(*v62);
    if (v6)
    {
      unsigned int v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v69 += v58 + 1;
        int v12 = ~v58 + v63;
        unsigned int v20 = -1;
        goto LABEL_40;
      }
    }
    ++v7;
    ++v58;
    a3 += v74;
    v60 -= v74;
    a2 += v75;
    v61 -= v75;
    unsigned int v20 = -1;
  }
}

uint64_t cmyk32_sample_rgba32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v74 = *(void *)(result + 80);
  uint64_t v77 = *(void *)(result + 72);
  uint64_t v78 = *(void *)(result + 88);
  uint64_t v6 = *(void *)(result + 112);
  uint64_t v7 = *(void *)(result + 120);
  uint64_t v8 = *(void *)(result + 152) - 8;
  uint64_t v9 = *(void *)(result + 144) - 1;
  uint64_t v11 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 40);
  int v75 = *(_DWORD *)(result + 188);
  unint64_t v12 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  uint64_t v76 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v77)
    {
      if ((uint64_t)a3 <= v78)
      {
        uint64_t v21 = (a3 >> 22) & 0x3C0;
        unsigned int v22 = 0x3FFFFFFF;
        HIDWORD(v23) = HIDWORD(a3);
        uint64_t v24 = v76;
      }
      else
      {
        uint64_t v17 = *(void *)(result + 216);
        uint64_t v18 = *(void *)(result + 224) + v78;
        uint64_t v19 = v18 - a3 + (v17 >> 1);
        if (v19 < 1) {
          goto LABEL_34;
        }
        if (v19 >= v17) {
          LODWORD(v20) = 0x3FFFFFFF;
        }
        else {
          unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
        }
        uint64_t v24 = v76;
        unsigned int v22 = v75 | v20;
        uint64_t v23 = v18 - 0x1000000;
        uint64_t v21 = 448;
      }
    }
    else
    {
      uint64_t v13 = *(void *)(result + 216);
      uint64_t v14 = v77 - *(void *)(result + 224);
      uint64_t v15 = a3 - v14 + (v13 >> 1);
      if (v15 < 1) {
        goto LABEL_34;
      }
      if (v15 >= v13) {
        LODWORD(v16) = 0x3FFFFFFF;
      }
      else {
        unint64_t v16 = (unint64_t)(*(void *)(result + 232) * v15) >> 32;
      }
      uint64_t v24 = v76;
      unsigned int v22 = v75 | v16;
      uint64_t v23 = v14 + 0x1000000;
      uint64_t v21 = 512;
    }
    if (a2 >= v24) {
      break;
    }
    uint64_t v25 = *(void *)(result + 192);
    uint64_t v26 = v24 - *(void *)(result + 200);
    uint64_t v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25) {
        unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v75;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v6;
    a3 += v7;
    v8 += 8;
    *(unsigned char *)++uint64_t v9 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v74)
  {
    uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v28 = a2;
    goto LABEL_26;
  }
  uint64_t v30 = *(void *)(result + 192);
  uint64_t v31 = *(void *)(result + 200) + v74;
  uint64_t v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1) {
    goto LABEL_34;
  }
  if (v32 < v30) {
    unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v75;
  }
  uint64_t v28 = v31 - 0x1000000;
  uint64_t v29 = 28;
LABEL_26:
  if (v22 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v33 = v11 + SHIDWORD(v23) * (uint64_t)v4;
  uint64_t v34 = v28 >> 32;
  unint64_t v35 = v33 + 4 * v34;
  int v36 = *(unsigned int **)(result + 32);
  if (v12 >= v35) {
    int v37 = (unsigned int *)(v33 + 4 * v34);
  }
  else {
    int v37 = (unsigned int *)v12;
  }
  if (v37 < v36) {
    int v37 = *(unsigned int **)(result + 32);
  }
  unsigned int v38 = *v37;
  if (!v5)
  {
    uint64_t v40 = v74;
    goto LABEL_67;
  }
  unsigned int v39 = *(_DWORD *)(v5 + (v29 | v21));
LABEL_38:
  int v41 = v39 & 0xF;
  int v42 = HIBYTE(v39) & 3;
  uint64_t v40 = v74;
  switch(v41)
  {
    case 1:
      int v59 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v12 < (unint64_t)v59) {
        int v59 = (unsigned int *)v12;
      }
      if (v59 < v36) {
        int v59 = v36;
      }
      unsigned int v60 = interpolate_8888_21358[v42];
      char v61 = v42 + 1;
      unsigned int v57 = v38 - ((v60 & v38) >> v61);
      unsigned int v62 = (v60 & *v59) >> v61;
LABEL_66:
      unsigned int v38 = v57 + v62;
      break;
    case 2:
      int v63 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v39) << 56) >> 54));
      if (v12 < (unint64_t)v63) {
        int v63 = (unsigned int *)v12;
      }
      if (v63 < v36) {
        int v63 = v36;
      }
      int v64 = (v39 >> 28) & 3;
      int v65 = interpolate_8888_21358[v64];
      char v56 = v64 + 1;
      unsigned int v57 = v38 - ((v65 & v38) >> v56);
      unsigned int v58 = v65 & *v63;
LABEL_65:
      unsigned int v62 = v58 >> v56;
      goto LABEL_66;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v39) << 56;
      uint64_t v44 = (unsigned int *)(v35 + (v43 >> 54));
      if (v12 < (unint64_t)v44) {
        uint64_t v44 = (unsigned int *)v12;
      }
      if (v44 < v36) {
        uint64_t v44 = v36;
      }
      unsigned int v45 = *v44;
      unint64_t v46 = v35 + SBYTE1(v39) * (uint64_t)v4;
      if (v12 >= v46) {
        unsigned int v47 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      }
      else {
        unsigned int v47 = (unsigned int *)v12;
      }
      if (v47 < v36) {
        unsigned int v47 = v36;
      }
      unsigned int v48 = *v47;
      int v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v12 < (unint64_t)v49) {
        int v49 = (unsigned int *)v12;
      }
      if (v49 < v36) {
        int v49 = v36;
      }
      unsigned int v50 = interpolate_8888_21358[v42];
      char v51 = v42 + 1;
      unsigned int v52 = v38 - ((v50 & v38) >> v51) + ((v50 & v48) >> v51);
      unsigned int v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      int v54 = (v39 >> 28) & 3;
      int v55 = interpolate_8888_21358[v54];
      char v56 = v54 + 1;
      unsigned int v57 = v52 - ((v52 & v55) >> v56);
      unsigned int v58 = v53 & v55;
      goto LABEL_65;
  }
LABEL_67:
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  a3 += v7;
  uint64_t v68 = v78 - a3;
  a2 += v6;
  uint64_t v69 = v40 - a2;
  while (1)
  {
    unsigned int v70 = HIBYTE(v38);
    if (HIBYTE(v38) <= BYTE2(v38)) {
      unsigned int v70 = BYTE2(v38);
    }
    if (v70 <= BYTE1(v38)) {
      unsigned int v70 = BYTE1(v38);
    }
    uint64_t v71 = v10 ? v38 : 255;
    *(void *)(v8 + 8 + 8 * v66) = (int)((v71 - v70) | ((v70 - BYTE2(v38)) << 16) | ((v70 - HIBYTE(v38)) << 24) | ((v70 - BYTE1(v38)) << 8)) | (unint64_t)(v71 << 32);
    *(unsigned char *)(v9 + 1 + v66) = v22 >> 22;
    if (a4 - 1 == v66) {
      return result;
    }
    if (((v68 | v69 | (a3 - v77) | (a2 - v76)) & 0x8000000000000000) != 0)
    {
      uint64_t v8 = v8 - v67 + 8;
      v9 += v66 + 1;
      a4 += ~v66;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v72 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v35 = v72 + 4 * (a2 >> 32);
    int v36 = *(unsigned int **)(result + 32);
    if (v12 >= v35) {
      unint64_t v73 = (unsigned int *)(v72 + 4 * (a2 >> 32));
    }
    else {
      unint64_t v73 = (unsigned int *)v12;
    }
    if (v73 < v36) {
      unint64_t v73 = *(unsigned int **)(result + 32);
    }
    unsigned int v38 = *v73;
    if (v5)
    {
      unsigned int v39 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        uint64_t v8 = v8 - v67 + 8;
        v9 += v66 + 1;
        a4 += ~v66;
        unsigned int v22 = -1;
        goto LABEL_38;
      }
    }
    v67 -= 8;
    ++v66;
    a3 += v7;
    v68 -= v7;
    a2 += v6;
    v69 -= v6;
    unsigned int v22 = -1;
  }
}

uint64_t cmyk32_sample_RGBA32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v72 = *(void *)(result + 80);
  uint64_t v75 = *(void *)(result + 72);
  uint64_t v76 = *(void *)(result + 88);
  uint64_t v6 = *(void *)(result + 112);
  uint64_t v7 = *(void *)(result + 120);
  uint64_t v8 = *(void *)(result + 152) - 8;
  uint64_t v9 = *(void *)(result + 144) - 1;
  uint64_t v11 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 40);
  int v73 = *(_DWORD *)(result + 188);
  unint64_t v12 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  uint64_t v74 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v75)
    {
      if ((uint64_t)a3 <= v76)
      {
        uint64_t v21 = (a3 >> 22) & 0x3C0;
        unsigned int v22 = 0x3FFFFFFF;
        HIDWORD(v23) = HIDWORD(a3);
        uint64_t v24 = v74;
      }
      else
      {
        uint64_t v17 = *(void *)(result + 216);
        uint64_t v18 = *(void *)(result + 224) + v76;
        uint64_t v19 = v18 - a3 + (v17 >> 1);
        if (v19 < 1) {
          goto LABEL_34;
        }
        if (v19 >= v17) {
          LODWORD(v20) = 0x3FFFFFFF;
        }
        else {
          unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
        }
        uint64_t v24 = v74;
        unsigned int v22 = v73 | v20;
        uint64_t v23 = v18 - 0x1000000;
        uint64_t v21 = 448;
      }
    }
    else
    {
      uint64_t v13 = *(void *)(result + 216);
      uint64_t v14 = v75 - *(void *)(result + 224);
      uint64_t v15 = a3 - v14 + (v13 >> 1);
      if (v15 < 1) {
        goto LABEL_34;
      }
      if (v15 >= v13) {
        LODWORD(v16) = 0x3FFFFFFF;
      }
      else {
        unint64_t v16 = (unint64_t)(*(void *)(result + 232) * v15) >> 32;
      }
      uint64_t v24 = v74;
      unsigned int v22 = v73 | v16;
      uint64_t v23 = v14 + 0x1000000;
      uint64_t v21 = 512;
    }
    if (a2 >= v24) {
      break;
    }
    uint64_t v25 = *(void *)(result + 192);
    uint64_t v26 = v24 - *(void *)(result + 200);
    uint64_t v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25) {
        unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v73;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v6;
    a3 += v7;
    v8 += 8;
    *(unsigned char *)++uint64_t v9 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v72)
  {
    uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v28 = a2;
    goto LABEL_26;
  }
  uint64_t v30 = *(void *)(result + 192);
  uint64_t v31 = *(void *)(result + 200) + v72;
  uint64_t v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1) {
    goto LABEL_34;
  }
  if (v32 < v30) {
    unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v73;
  }
  uint64_t v28 = v31 - 0x1000000;
  uint64_t v29 = 28;
LABEL_26:
  if (v22 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v33 = v11 + SHIDWORD(v23) * (uint64_t)v4;
  uint64_t v34 = v28 >> 32;
  unint64_t v35 = v33 + 4 * v34;
  int v36 = *(unsigned int **)(result + 32);
  if (v12 >= v35) {
    int v37 = (unsigned int *)(v33 + 4 * v34);
  }
  else {
    int v37 = (unsigned int *)v12;
  }
  if (v37 < v36) {
    int v37 = *(unsigned int **)(result + 32);
  }
  unsigned int v38 = bswap32(*v37);
  if (!v5)
  {
    uint64_t v40 = v72;
    goto LABEL_67;
  }
  unsigned int v39 = *(_DWORD *)(v5 + (v29 | v21));
LABEL_38:
  int v41 = v39 & 0xF;
  int v42 = HIBYTE(v39) & 3;
  uint64_t v40 = v72;
  switch(v41)
  {
    case 1:
      unsigned int v58 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v12 < (unint64_t)v58) {
        unsigned int v58 = (unsigned int *)v12;
      }
      if (v58 < v36) {
        unsigned int v58 = v36;
      }
      int v59 = interpolate_8888_21358[v42];
      char v60 = v42 + 1;
      unsigned int v57 = v38 - ((v59 & v38) >> v60);
      unsigned int v61 = (bswap32(*v58) & v59) >> v60;
LABEL_66:
      unsigned int v38 = v57 + v61;
      break;
    case 2:
      unsigned int v62 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v39) << 56) >> 54));
      if (v12 < (unint64_t)v62) {
        unsigned int v62 = (unsigned int *)v12;
      }
      if (v62 < v36) {
        unsigned int v62 = v36;
      }
      unsigned int v53 = bswap32(*v62);
      int v63 = (v39 >> 28) & 3;
      int v55 = interpolate_8888_21358[v63];
      char v56 = v63 + 1;
      unsigned int v57 = v38 - ((v55 & v38) >> v56);
LABEL_65:
      unsigned int v61 = (v53 & v55) >> v56;
      goto LABEL_66;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v39) << 56;
      uint64_t v44 = (unsigned int *)(v35 + (v43 >> 54));
      if (v12 < (unint64_t)v44) {
        uint64_t v44 = (unsigned int *)v12;
      }
      if (v44 < v36) {
        uint64_t v44 = v36;
      }
      unsigned int v45 = bswap32(*v44);
      unint64_t v46 = v35 + SBYTE1(v39) * (uint64_t)v4;
      if (v12 >= v46) {
        unsigned int v47 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      }
      else {
        unsigned int v47 = (unsigned int *)v12;
      }
      if (v47 < v36) {
        unsigned int v47 = v36;
      }
      unsigned int v48 = bswap32(*v47);
      int v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v12 < (unint64_t)v49) {
        int v49 = (unsigned int *)v12;
      }
      if (v49 < v36) {
        int v49 = v36;
      }
      int v50 = interpolate_8888_21358[v42];
      char v51 = v42 + 1;
      unsigned int v52 = v38 - ((v50 & v38) >> v51) + ((v50 & v48) >> v51);
      unsigned int v53 = v45 - ((v50 & v45) >> v51) + ((bswap32(*v49) & v50) >> v51);
      int v54 = (v39 >> 28) & 3;
      int v55 = interpolate_8888_21358[v54];
      char v56 = v54 + 1;
      unsigned int v57 = v52 - ((v52 & v55) >> v56);
      goto LABEL_65;
  }
LABEL_67:
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  a3 += v7;
  uint64_t v66 = v76 - a3;
  a2 += v6;
  uint64_t v67 = v40 - a2;
  while (1)
  {
    unsigned int v68 = HIBYTE(v38);
    if (HIBYTE(v38) <= BYTE2(v38)) {
      unsigned int v68 = BYTE2(v38);
    }
    if (v68 <= BYTE1(v38)) {
      unsigned int v68 = BYTE1(v38);
    }
    uint64_t v69 = v10 ? v38 : 255;
    *(void *)(v8 + 8 + 8 * v64) = (int)((v69 - v68) | ((v68 - BYTE2(v38)) << 16) | ((v68 - HIBYTE(v38)) << 24) | ((v68 - BYTE1(v38)) << 8)) | (unint64_t)(v69 << 32);
    *(unsigned char *)(v9 + 1 + v64) = v22 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v66 | v67 | (a3 - v75) | (a2 - v74)) & 0x8000000000000000) != 0)
    {
      uint64_t v8 = v8 - v65 + 8;
      v9 += v64 + 1;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v70 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v35 = v70 + 4 * (a2 >> 32);
    int v36 = *(unsigned int **)(result + 32);
    if (v12 >= v35) {
      uint64_t v71 = (unsigned int *)(v70 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v71 = (unsigned int *)v12;
    }
    if (v71 < v36) {
      uint64_t v71 = *(unsigned int **)(result + 32);
    }
    unsigned int v38 = bswap32(*v71);
    if (v5)
    {
      unsigned int v39 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        uint64_t v8 = v8 - v65 + 8;
        v9 += v64 + 1;
        a4 += ~v64;
        unsigned int v22 = -1;
        goto LABEL_38;
      }
    }
    v65 -= 8;
    ++v64;
    a3 += v7;
    v66 -= v7;
    a2 += v6;
    v67 -= v6;
    unsigned int v22 = -1;
  }
}

uint64_t cmyk32_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v74 = *(void *)(result + 80);
  uint64_t v75 = *(void *)(result + 88);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v10 = *(void *)(result + 152) - 8;
  uint64_t v11 = *(void *)(result + 144) - 1;
  int v72 = *(_DWORD *)(result + 188);
  unint64_t v12 = v4 + (3 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v5) - 3;
  uint64_t v73 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v75)
      {
        uint64_t v21 = (a3 >> 22) & 0x3C0;
        unsigned int v22 = 0x3FFFFFFF;
        HIDWORD(v23) = HIDWORD(a3);
        uint64_t v24 = v73;
      }
      else
      {
        uint64_t v17 = *(void *)(result + 216);
        uint64_t v18 = *(void *)(result + 224) + v75;
        uint64_t v19 = v18 - a3 + (v17 >> 1);
        if (v19 < 1) {
          goto LABEL_34;
        }
        if (v19 >= v17) {
          LODWORD(v20) = 0x3FFFFFFF;
        }
        else {
          unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
        }
        uint64_t v24 = v73;
        unsigned int v22 = v72 | v20;
        uint64_t v23 = v18 - 0x1000000;
        uint64_t v21 = 448;
      }
    }
    else
    {
      uint64_t v13 = *(void *)(result + 216);
      uint64_t v14 = v7 - *(void *)(result + 224);
      uint64_t v15 = a3 - v14 + (v13 >> 1);
      if (v15 < 1) {
        goto LABEL_34;
      }
      if (v15 >= v13) {
        LODWORD(v16) = 0x3FFFFFFF;
      }
      else {
        unint64_t v16 = (unint64_t)(*(void *)(result + 232) * v15) >> 32;
      }
      uint64_t v24 = v73;
      unsigned int v22 = v72 | v16;
      uint64_t v23 = v14 + 0x1000000;
      uint64_t v21 = 512;
    }
    if (a2 >= v24) {
      break;
    }
    uint64_t v25 = *(void *)(result + 192);
    uint64_t v26 = v24 - *(void *)(result + 200);
    uint64_t v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25) {
        unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v72;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 8;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v74)
  {
    uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v28 = a2;
    goto LABEL_26;
  }
  uint64_t v30 = *(void *)(result + 192);
  uint64_t v31 = *(void *)(result + 200) + v74;
  uint64_t v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1) {
    goto LABEL_34;
  }
  if (v32 < v30) {
    unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v72;
  }
  uint64_t v28 = v31 - 0x1000000;
  uint64_t v29 = 28;
LABEL_26:
  if (v22 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v33 = v4 + SHIDWORD(v23) * (uint64_t)v5;
  uint64_t v34 = 3 * (v28 >> 32);
  uint64_t v35 = v33 + v34;
  int v36 = *(unsigned __int8 **)(result + 32);
  if (v12 >= v33 + v34) {
    int v37 = (unsigned __int8 *)(v33 + v34);
  }
  else {
    int v37 = (unsigned __int8 *)v12;
  }
  if (v37 < v36) {
    int v37 = *(unsigned __int8 **)(result + 32);
  }
  unsigned int v38 = (v37[1] << 16) | (*v37 << 24) | (v37[2] << 8) | 0xFF;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v39 = *(_DWORD *)(v6 + (v29 | v21));
LABEL_37:
  int v40 = v39 & 0xF;
  int v41 = HIBYTE(v39) & 3;
  switch(v40)
  {
    case 1:
      unsigned int v57 = (unsigned __int8 *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      if (v12 < (unint64_t)v57) {
        unsigned int v57 = (unsigned __int8 *)v12;
      }
      if (v57 < v36) {
        unsigned int v57 = v36;
      }
      unsigned int v58 = interpolate_8888_21358[v41];
      char v59 = v41 + 1;
      unsigned int v56 = v38 - ((v58 & v38) >> v59);
      unsigned int v60 = (((v57[1] << 16) | (*v57 << 24) | (v57[2] << 8) | 0xFF) & v58) >> v59;
LABEL_65:
      unsigned int v38 = v56 + v60;
      break;
    case 2:
      unsigned int v61 = (unsigned __int8 *)(v35 + 3 * SBYTE2(v39));
      if (v12 < (unint64_t)v61) {
        unsigned int v61 = (unsigned __int8 *)v12;
      }
      if (v61 < v36) {
        unsigned int v61 = v36;
      }
      int v52 = (v61[1] << 16) | (*v61 << 24) | (v61[2] << 8) | 0xFF;
      int v62 = (v39 >> 28) & 3;
      unsigned int v54 = interpolate_8888_21358[v62];
      char v55 = v62 + 1;
      unsigned int v56 = v38 - ((v54 & v38) >> v55);
LABEL_64:
      unsigned int v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      uint64_t v42 = 3 * SBYTE2(v39);
      int64_t v43 = (unsigned __int8 *)(v35 + v42);
      if (v12 < v35 + v42) {
        int64_t v43 = (unsigned __int8 *)v12;
      }
      if (v43 < v36) {
        int64_t v43 = v36;
      }
      int v44 = (v43[1] << 16) | (*v43 << 24) | (v43[2] << 8) | 0xFF;
      unint64_t v45 = v35 + SBYTE1(v39) * (uint64_t)v5;
      if (v12 >= v45) {
        unint64_t v46 = (unsigned __int8 *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned __int8 *)v12;
      }
      if (v46 < v36) {
        unint64_t v46 = v36;
      }
      int v47 = (v46[1] << 16) | (*v46 << 24) | (v46[2] << 8) | 0xFF;
      unsigned int v48 = (unsigned __int8 *)(v45 + v42);
      if (v12 < (unint64_t)v48) {
        unsigned int v48 = (unsigned __int8 *)v12;
      }
      if (v48 < v36) {
        unsigned int v48 = v36;
      }
      unsigned int v49 = interpolate_8888_21358[v41];
      char v50 = v41 + 1;
      unsigned int v51 = v38 - ((v49 & v38) >> v50) + ((v47 & v49) >> v50);
      int v52 = v44 - ((v49 & v44) >> v50) + ((((v48[1] << 16) | (*v48 << 24) | (v48[2] << 8) | 0xFF) & v49) >> v50);
      int v53 = (v39 >> 28) & 3;
      unsigned int v54 = interpolate_8888_21358[v53];
      char v55 = v53 + 1;
      unsigned int v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  a3 += v9;
  uint64_t v65 = v75 - a3;
  a2 += v8;
  uint64_t v66 = v74 - a2;
  while (1)
  {
    unsigned int v67 = HIBYTE(v38);
    unsigned int v68 = BYTE1(v38);
    if (HIBYTE(v38) <= BYTE2(v38)) {
      unsigned int v67 = BYTE2(v38);
    }
    if (v67 > BYTE1(v38)) {
      unsigned int v68 = v67;
    }
    *(void *)(v10 + 8 + 8 * v64) = (int)((v38 - v68) | ((v68 - BYTE2(v38)) << 16) | ((v68 - HIBYTE(v38)) << 24) | ((v68 - BYTE1(v38)) << 8)) | ((unint64_t)v38 << 32);
    *(unsigned char *)(v11 + 1 + v64) = v22 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v65 | v66 | (a3 - v7) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v11 += v64 + 1;
      uint64_t v10 = v10 - v63 + 8;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v69 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    uint64_t v70 = 3 * (a2 >> 32);
    uint64_t v35 = v69 + v70;
    int v36 = *(unsigned __int8 **)(result + 32);
    if (v12 >= v69 + v70) {
      uint64_t v71 = (unsigned __int8 *)(v69 + v70);
    }
    else {
      uint64_t v71 = (unsigned __int8 *)v12;
    }
    if (v71 < v36) {
      uint64_t v71 = *(unsigned __int8 **)(result + 32);
    }
    unsigned int v38 = (v71[1] << 16) | (*v71 << 24) | (v71[2] << 8) | 0xFF;
    if (v6)
    {
      unsigned int v39 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        v11 += v64 + 1;
        uint64_t v10 = v10 - v63 + 8;
        a4 += ~v64;
        unsigned int v22 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 8;
    a3 += v9;
    v65 -= v9;
    a2 += v8;
    v66 -= v8;
    unsigned int v22 = -1;
  }
}

uint64_t cmyk32_sample_rgb555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v88 = *(void *)(result + 88);
  uint64_t v101 = *(void *)(result + 120);
  uint64_t v102 = *(void *)(result + 112);
  uint64_t v8 = (unint64_t *)(*(void *)(result + 152) - 8);
  uint64_t v91 = *(void *)(result + 144) - 1;
  if (v6) {
    int v9 = 0;
  }
  else {
    int v9 = -16777216;
  }
  int v96 = v9;
  int v10 = *(_DWORD *)(result + 260) - 1;
  int v99 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  uint64_t v11 = *(unsigned int *)(result + 256);
  int v86 = *(_DWORD *)(result + 188);
  int v93 = *(_DWORD *)(result + 28);
  unint64_t v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  unint64_t v100 = v95 + (v10 * v99) + 2 * v11 - 4;
  uint64_t v89 = *(void *)(result + 72);
  uint64_t v90 = *(void *)(result + 64);
  uint64_t v97 = *(void *)(result + 40);
  uint64_t v98 = result;
  while (1)
  {
    if (a3 >= v89)
    {
      if (a3 <= v88)
      {
        uint64_t v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        uint64_t v24 = a3;
        int v15 = a4;
        uint64_t v16 = v90;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v88;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        int v15 = a4;
        uint64_t v16 = v90;
        if (v20 < 1) {
          goto LABEL_41;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v23 = v86 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v12 = *(void *)(result + 216);
      uint64_t v13 = v89 - *(void *)(result + 224);
      uint64_t v14 = a3 - v13 + (v12 >> 1);
      int v15 = a4;
      uint64_t v16 = v90;
      if (v14 < 1) {
        goto LABEL_41;
      }
      if (v14 >= v12) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v14) >> 32;
      }
      unsigned int v23 = v86 | v17;
      uint64_t v24 = v13 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v28 = a2;
      }
      else
      {
        uint64_t v30 = *(void *)(result + 192);
        uint64_t v31 = *(void *)(result + 200) + v87;
        uint64_t v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1) {
          goto LABEL_41;
        }
        if (v32 < v30) {
          unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v86;
        }
        uint64_t v28 = v31 - 0x1000000;
        uint64_t v29 = 28;
      }
    }
    else
    {
      uint64_t v25 = *(void *)(result + 192);
      uint64_t v26 = v16 - *(void *)(result + 200);
      uint64_t v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1) {
        goto LABEL_41;
      }
      if (v27 < v25) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v86;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
    }
    if (v23 >= 0x400000) {
      break;
    }
LABEL_41:
    int v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_42:
    a4 = v42;
    if (!v42) {
      return result;
    }
  }
  uint64_t v33 = v24 >> 32;
  uint64_t v34 = v28 >> 32;
  unint64_t v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 2 * (v28 >> 32);
  int v36 = *(unsigned __int16 **)(result + 32);
  int v37 = (unsigned __int16 *)v100;
  if (v100 >= v35) {
    int v37 = (unsigned __int16 *)v35;
  }
  if (v37 < v36) {
    int v37 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v38 = *v37;
  if (v6)
  {
    unint64_t v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    int v40 = *(unsigned __int8 **)(result + 40);
    int v41 = v94;
    unint64_t v92 = v39;
    if ((unint64_t)v94 >= v39) {
      int v41 = (unsigned __int8 *)v39;
    }
    if (v41 >= v40) {
      int v40 = v41;
    }
    v38 |= *v40 << 24;
    if (!v7) {
      goto LABEL_103;
    }
  }
  else
  {
    unint64_t v92 = 0;
    if (!v7) {
      goto LABEL_103;
    }
  }
  unsigned int v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_47:
  int v44 = v43 & 0xF;
  int v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    unsigned int v67 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67) {
      unsigned int v67 = (unsigned __int16 *)v100;
    }
    if (v67 >= v36) {
      int v36 = v67;
    }
    unsigned int v68 = *v36;
    if (v6)
    {
      uint64_t v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69) {
        uint64_t v69 = v94;
      }
      if ((unint64_t)v69 < *(void *)(result + 40)) {
        uint64_t v69 = *(unsigned __int8 **)(result + 40);
      }
      v68 |= *v69 << 24;
    }
    int v70 = interpolate_8555_21359[v45];
    char v71 = v45 + 1;
    unsigned int v65 = v38 - ((v70 & v38) >> v71);
    unsigned int v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      uint64_t v73 = (unsigned __int16 *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 55));
      if (v100 < (unint64_t)v73) {
        uint64_t v73 = (unsigned __int16 *)v100;
      }
      if (v73 >= v36) {
        int v36 = v73;
      }
      int v74 = *v36;
      if (v6)
      {
        uint64_t v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75) {
          uint64_t v75 = v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          uint64_t v75 = *(unsigned __int8 **)(result + 40);
        }
        v74 |= *v75 << 24;
      }
      int v76 = (v43 >> 28) & 3;
      int v77 = interpolate_8555_21359[v76];
      char v64 = v76 + 1;
      unsigned int v65 = v38 - ((v77 & v38) >> v64);
      unsigned int v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3) {
        goto LABEL_103;
      }
      int64_t v46 = (unint64_t)HIWORD(v43) << 56;
      int v47 = (unsigned __int16 *)(v35 + (v46 >> 55));
      if (v100 < (unint64_t)v47) {
        int v47 = (unsigned __int16 *)v100;
      }
      if (v47 < v36) {
        int v47 = v36;
      }
      unsigned int v48 = *v47;
      unint64_t v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49) {
        char v50 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      }
      else {
        char v50 = (unsigned __int16 *)v100;
      }
      if (v50 < v36) {
        char v50 = v36;
      }
      unsigned int v51 = *v50;
      int v52 = (unsigned __int16 *)(v49 + (v46 >> 55));
      if (v100 < (unint64_t)v52) {
        int v52 = (unsigned __int16 *)v100;
      }
      if (v52 >= v36) {
        int v36 = v52;
      }
      unsigned int v53 = *v36;
      if (v6)
      {
        unsigned int v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        unint64_t v55 = *(void *)(result + 40);
        if (v94 < v54) {
          unsigned int v54 = v94;
        }
        if ((unint64_t)v54 < v55) {
          unsigned int v54 = *(unsigned __int8 **)(result + 40);
        }
        v48 |= *v54 << 24;
        unint64_t v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56) {
          unsigned int v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        }
        else {
          unsigned int v57 = v94;
        }
        if ((unint64_t)v57 < v55) {
          unsigned int v57 = *(unsigned __int8 **)(result + 40);
        }
        v51 |= *v57 << 24;
        unsigned int v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58) {
          unsigned int v58 = v94;
        }
        if ((unint64_t)v58 < v55) {
          unsigned int v58 = *(unsigned __int8 **)(result + 40);
        }
        v53 |= *v58 << 24;
      }
      int v59 = interpolate_8555_21359[v45];
      char v60 = v45 + 1;
      unsigned int v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      int v62 = (v43 >> 28) & 3;
      int v63 = interpolate_8555_21359[v62];
      char v64 = v62 + 1;
      unsigned int v65 = v61 - ((v61 & v63) >> v64);
      unsigned int v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    unsigned int v72 = v66 >> v64;
  }
  unsigned int v38 = v65 + v72;
LABEL_103:
  uint64_t v78 = 0;
  ++v8;
  int v85 = v15;
  int v79 = v15 - 1;
  a3 += v101;
  uint64_t v80 = v88 - a3;
  a2 += v102;
  uint64_t v81 = v87 - a2;
  while (1)
  {
    RGB555(v8, v96 | (v38 >> 29 << 24) | v38);
    *(unsigned char *)(v91 + 1 + v78) = v23 >> 22;
    uint64_t v6 = v97;
    uint64_t result = v98;
    if (v79 == v78) {
      return result;
    }
    if ((v80 | v81 | (a3 - v89) | (a2 - v90)) < 0)
    {
      v91 += v78 + 1;
      int v42 = ~v78 + v85;
      goto LABEL_42;
    }
    unint64_t v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32);
    int v36 = *(unsigned __int16 **)(v98 + 32);
    unint64_t v82 = (unsigned __int16 *)v100;
    if (v100 >= v35) {
      unint64_t v82 = (unsigned __int16 *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32));
    }
    if (v82 < v36) {
      unint64_t v82 = *(unsigned __int16 **)(v98 + 32);
    }
    unsigned int v38 = *v82;
    if (v97)
    {
      unint64_t v83 = *(unsigned __int8 **)(v98 + 40);
      unint64_t v84 = (unint64_t)v94;
      unint64_t v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92) {
        unint64_t v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      }
      if (v84 >= (unint64_t)v83) {
        unint64_t v83 = (unsigned __int8 *)v84;
      }
      v38 |= *v83 << 24;
    }
    if (v7)
    {
      unsigned int v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        int v15 = ~v78 + v85;
        unsigned int v23 = -1;
        goto LABEL_47;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    unsigned int v23 = -1;
  }
}

unint64_t *RGB555(unint64_t *result, unsigned int a2)
{
  unsigned int v2 = (a2 << 14) & 0xF80000 | ((a2 >> 10) << 27) | ((a2 & 0x1F) << 11);
  unsigned int v3 = (v2 >> 5) & 0x3F3F3F3F | HIBYTE(a2) | v2;
  unsigned int v4 = HIBYTE(v3);
  if (HIBYTE(v3) <= BYTE2(v3)) {
    unsigned int v4 = BYTE2(v3);
  }
  if (v4 <= BYTE1(v3)) {
    unsigned int v4 = BYTE1(v3);
  }
  *uint64_t result = (int)((HIBYTE(a2) - v4) | ((v4 - BYTE2(v3)) << 16) | ((v4 - HIBYTE(v3)) << 24) | ((v4 - BYTE1(v3)) << 8)) | ((unint64_t)HIBYTE(a2) << 32);
  return result;
}

uint64_t cmyk32_sample_RGB555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v88 = *(void *)(result + 88);
  uint64_t v101 = *(void *)(result + 120);
  uint64_t v102 = *(void *)(result + 112);
  uint64_t v8 = (unint64_t *)(*(void *)(result + 152) - 8);
  uint64_t v91 = *(void *)(result + 144) - 1;
  if (v6) {
    int v9 = 0;
  }
  else {
    int v9 = -16777216;
  }
  int v96 = v9;
  int v10 = *(_DWORD *)(result + 260) - 1;
  int v99 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  uint64_t v11 = *(unsigned int *)(result + 256);
  int v86 = *(_DWORD *)(result + 188);
  int v93 = *(_DWORD *)(result + 28);
  unint64_t v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  unint64_t v100 = v95 + (v10 * v99) + 2 * v11 - 4;
  uint64_t v89 = *(void *)(result + 72);
  uint64_t v90 = *(void *)(result + 64);
  uint64_t v97 = *(void *)(result + 40);
  uint64_t v98 = result;
  while (1)
  {
    if (a3 >= v89)
    {
      if (a3 <= v88)
      {
        uint64_t v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        uint64_t v24 = a3;
        int v15 = a4;
        uint64_t v16 = v90;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v88;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        int v15 = a4;
        uint64_t v16 = v90;
        if (v20 < 1) {
          goto LABEL_41;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v23 = v86 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v12 = *(void *)(result + 216);
      uint64_t v13 = v89 - *(void *)(result + 224);
      uint64_t v14 = a3 - v13 + (v12 >> 1);
      int v15 = a4;
      uint64_t v16 = v90;
      if (v14 < 1) {
        goto LABEL_41;
      }
      if (v14 >= v12) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v14) >> 32;
      }
      unsigned int v23 = v86 | v17;
      uint64_t v24 = v13 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v28 = a2;
      }
      else
      {
        uint64_t v30 = *(void *)(result + 192);
        uint64_t v31 = *(void *)(result + 200) + v87;
        uint64_t v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1) {
          goto LABEL_41;
        }
        if (v32 < v30) {
          unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v86;
        }
        uint64_t v28 = v31 - 0x1000000;
        uint64_t v29 = 28;
      }
    }
    else
    {
      uint64_t v25 = *(void *)(result + 192);
      uint64_t v26 = v16 - *(void *)(result + 200);
      uint64_t v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1) {
        goto LABEL_41;
      }
      if (v27 < v25) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v86;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
    }
    if (v23 >= 0x400000) {
      break;
    }
LABEL_41:
    int v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_42:
    a4 = v42;
    if (!v42) {
      return result;
    }
  }
  uint64_t v33 = v24 >> 32;
  uint64_t v34 = v28 >> 32;
  unint64_t v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 2 * (v28 >> 32);
  int v36 = *(unsigned __int16 **)(result + 32);
  int v37 = (unsigned __int16 *)v100;
  if (v100 >= v35) {
    int v37 = (unsigned __int16 *)v35;
  }
  if (v37 < v36) {
    int v37 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v38 = bswap32(*v37) >> 16;
  if (v6)
  {
    unint64_t v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    int v40 = *(unsigned __int8 **)(result + 40);
    int v41 = v94;
    unint64_t v92 = v39;
    if ((unint64_t)v94 >= v39) {
      int v41 = (unsigned __int8 *)v39;
    }
    if (v41 >= v40) {
      int v40 = v41;
    }
    v38 |= *v40 << 24;
    if (!v7) {
      goto LABEL_103;
    }
  }
  else
  {
    unint64_t v92 = 0;
    if (!v7) {
      goto LABEL_103;
    }
  }
  unsigned int v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_47:
  int v44 = v43 & 0xF;
  int v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    unsigned int v67 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67) {
      unsigned int v67 = (unsigned __int16 *)v100;
    }
    if (v67 >= v36) {
      int v36 = v67;
    }
    unsigned int v68 = bswap32(*v36) >> 16;
    if (v6)
    {
      uint64_t v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69) {
        uint64_t v69 = v94;
      }
      if ((unint64_t)v69 < *(void *)(result + 40)) {
        uint64_t v69 = *(unsigned __int8 **)(result + 40);
      }
      v68 |= *v69 << 24;
    }
    int v70 = interpolate_8555_21359[v45];
    char v71 = v45 + 1;
    unsigned int v65 = v38 - ((v70 & v38) >> v71);
    unsigned int v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      uint64_t v73 = (unsigned __int16 *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 55));
      if (v100 < (unint64_t)v73) {
        uint64_t v73 = (unsigned __int16 *)v100;
      }
      if (v73 >= v36) {
        int v36 = v73;
      }
      unsigned int v74 = bswap32(*v36) >> 16;
      if (v6)
      {
        uint64_t v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75) {
          uint64_t v75 = v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          uint64_t v75 = *(unsigned __int8 **)(result + 40);
        }
        v74 |= *v75 << 24;
      }
      int v76 = (v43 >> 28) & 3;
      int v77 = interpolate_8555_21359[v76];
      char v64 = v76 + 1;
      unsigned int v65 = v38 - ((v77 & v38) >> v64);
      unsigned int v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3) {
        goto LABEL_103;
      }
      int64_t v46 = (unint64_t)HIWORD(v43) << 56;
      int v47 = (unsigned __int16 *)(v35 + (v46 >> 55));
      if (v100 < (unint64_t)v47) {
        int v47 = (unsigned __int16 *)v100;
      }
      if (v47 < v36) {
        int v47 = v36;
      }
      unsigned int v48 = bswap32(*v47) >> 16;
      unint64_t v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49) {
        char v50 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      }
      else {
        char v50 = (unsigned __int16 *)v100;
      }
      if (v50 < v36) {
        char v50 = v36;
      }
      unsigned int v51 = bswap32(*v50) >> 16;
      int v52 = (unsigned __int16 *)(v49 + (v46 >> 55));
      if (v100 < (unint64_t)v52) {
        int v52 = (unsigned __int16 *)v100;
      }
      if (v52 >= v36) {
        int v36 = v52;
      }
      unsigned int v53 = bswap32(*v36) >> 16;
      if (v6)
      {
        unsigned int v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        unint64_t v55 = *(void *)(result + 40);
        if (v94 < v54) {
          unsigned int v54 = v94;
        }
        if ((unint64_t)v54 < v55) {
          unsigned int v54 = *(unsigned __int8 **)(result + 40);
        }
        v48 |= *v54 << 24;
        unint64_t v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56) {
          unsigned int v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        }
        else {
          unsigned int v57 = v94;
        }
        if ((unint64_t)v57 < v55) {
          unsigned int v57 = *(unsigned __int8 **)(result + 40);
        }
        v51 |= *v57 << 24;
        unsigned int v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58) {
          unsigned int v58 = v94;
        }
        if ((unint64_t)v58 < v55) {
          unsigned int v58 = *(unsigned __int8 **)(result + 40);
        }
        v53 |= *v58 << 24;
      }
      int v59 = interpolate_8555_21359[v45];
      char v60 = v45 + 1;
      unsigned int v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      int v62 = (v43 >> 28) & 3;
      int v63 = interpolate_8555_21359[v62];
      char v64 = v62 + 1;
      unsigned int v65 = v61 - ((v61 & v63) >> v64);
      unsigned int v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    unsigned int v72 = v66 >> v64;
  }
  unsigned int v38 = v65 + v72;
LABEL_103:
  uint64_t v78 = 0;
  ++v8;
  int v85 = v15;
  int v79 = v15 - 1;
  a3 += v101;
  uint64_t v80 = v88 - a3;
  a2 += v102;
  uint64_t v81 = v87 - a2;
  while (1)
  {
    RGB555(v8, v96 | (v38 >> 29 << 24) | v38);
    *(unsigned char *)(v91 + 1 + v78) = v23 >> 22;
    uint64_t v6 = v97;
    uint64_t result = v98;
    if (v79 == v78) {
      return result;
    }
    if ((v80 | v81 | (a3 - v89) | (a2 - v90)) < 0)
    {
      v91 += v78 + 1;
      int v42 = ~v78 + v85;
      goto LABEL_42;
    }
    unint64_t v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32);
    int v36 = *(unsigned __int16 **)(v98 + 32);
    unint64_t v82 = (unsigned __int16 *)v100;
    if (v100 >= v35) {
      unint64_t v82 = (unsigned __int16 *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32));
    }
    if (v82 < v36) {
      unint64_t v82 = *(unsigned __int16 **)(v98 + 32);
    }
    unsigned int v38 = bswap32(*v82) >> 16;
    if (v97)
    {
      unint64_t v83 = *(unsigned __int8 **)(v98 + 40);
      unint64_t v84 = (unint64_t)v94;
      unint64_t v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92) {
        unint64_t v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      }
      if (v84 >= (unint64_t)v83) {
        unint64_t v83 = (unsigned __int8 *)v84;
      }
      v38 |= *v83 << 24;
    }
    if (v7)
    {
      unsigned int v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        int v15 = ~v78 + v85;
        unsigned int v23 = -1;
        goto LABEL_47;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    unsigned int v23 = -1;
  }
}

uint64_t cmyk32_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v90 = *(void *)(result + 80);
  uint64_t v92 = *(void *)(result + 88);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 8;
  uint64_t v12 = *(void *)(result + 144) - 1;
  if (v5) {
    int v13 = 0;
  }
  else {
    int v13 = -16777216;
  }
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  uint64_t v16 = (unsigned __int8 *)(v5 + (v15 - 1) + (v14 * v7));
  int v89 = *(_DWORD *)(result + 188);
  unint64_t v17 = v4 + v15 + (v14 * v6) - 1;
  uint64_t v91 = *(void *)(result + 64);
  uint64_t v93 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v93)
      {
        if (a3 <= v92)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
          uint64_t v29 = v91;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v92;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_43;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          uint64_t v29 = v91;
          unsigned int v27 = v89 | v25;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v93 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_43;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v29 = v91;
        unsigned int v27 = v89 | v21;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v29) {
        break;
      }
      uint64_t v30 = *(void *)(result + 192);
      uint64_t v31 = v29 - *(void *)(result + 200);
      uint64_t v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v89;
        }
        uint64_t v33 = v31 + 0x1000000;
        uint64_t v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 8;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v90)
    {
      uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v33 = a2;
      goto LABEL_29;
    }
    uint64_t v35 = *(void *)(result + 192);
    uint64_t v36 = *(void *)(result + 200) + v90;
    uint64_t v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1) {
      goto LABEL_43;
    }
    if (v37 < v35) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v89;
    }
    uint64_t v33 = v36 - 0x1000000;
    uint64_t v34 = 28;
LABEL_29:
    if (v27 < 0x400000) {
      goto LABEL_43;
    }
    uint64_t v38 = v28 >> 32;
    uint64_t v39 = v4 + (int)v38 * (uint64_t)v6;
    unint64_t v40 = v39 + (v33 >> 32);
    int v41 = *(unsigned __int8 **)(result + 32);
    if (v17 >= v40) {
      int v42 = (unsigned __int8 *)(v39 + (v33 >> 32));
    }
    else {
      int v42 = (unsigned __int8 *)v17;
    }
    if (v42 < v41) {
      int v42 = *(unsigned __int8 **)(result + 32);
    }
    unsigned int v43 = *v42;
    if (v5)
    {
      unint64_t v44 = v5 + (int)v38 * (uint64_t)v7 + (v33 >> 32);
      int v45 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v44) {
        int64_t v46 = (unsigned __int8 *)v44;
      }
      else {
        int64_t v46 = v16;
      }
      if (v46 >= v45) {
        int v45 = v46;
      }
      v43 |= *v45 << 24;
      if (!v8) {
        goto LABEL_104;
      }
    }
    else
    {
      unint64_t v44 = 0;
      if (!v8) {
        goto LABEL_104;
      }
    }
    unsigned int v47 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    int v48 = v47 & 0xF;
    int v49 = HIBYTE(v47) & 3;
    switch(v48)
    {
      case 1:
        int v70 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        if (v17 < (unint64_t)v70) {
          int v70 = (unsigned __int8 *)v17;
        }
        if (v70 < v41) {
          int v70 = v41;
        }
        unsigned int v71 = *v70;
        if (v5)
        {
          unsigned int v72 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          if (v16 < v72) {
            unsigned int v72 = v16;
          }
          if ((unint64_t)v72 < *(void *)(result + 40)) {
            unsigned int v72 = *(unsigned __int8 **)(result + 40);
          }
          v71 |= *v72 << 24;
        }
        int v73 = interpolate_8888_21358[v49];
        char v74 = v49 + 1;
        unsigned int v68 = v43 - ((v73 & v43) >> v74);
        unsigned int v75 = (v73 & v71) >> v74;
        goto LABEL_103;
      case 2:
        int v76 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v76) {
          int v76 = (unsigned __int8 *)v17;
        }
        if (v76 < v41) {
          int v76 = v41;
        }
        int v77 = *v76;
        if (v5)
        {
          uint64_t v78 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          if (v16 < v78) {
            uint64_t v78 = v16;
          }
          if ((unint64_t)v78 < *(void *)(result + 40)) {
            uint64_t v78 = *(unsigned __int8 **)(result + 40);
          }
          v77 |= *v78 << 24;
        }
        int v79 = (v47 >> 28) & 3;
        int v80 = interpolate_8888_21358[v79];
        char v67 = v79 + 1;
        unsigned int v68 = v43 - ((v80 & v43) >> v67);
        unsigned int v69 = v80 & v77;
        goto LABEL_102;
      case 3:
        char v50 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v50) {
          char v50 = (unsigned __int8 *)v17;
        }
        if (v50 < v41) {
          char v50 = v41;
        }
        unsigned int v51 = *v50;
        unint64_t v52 = v40 + SBYTE1(v47) * (uint64_t)v6;
        if (v17 >= v52) {
          unsigned int v53 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        }
        else {
          unsigned int v53 = (unsigned __int8 *)v17;
        }
        if (v53 < v41) {
          unsigned int v53 = v41;
        }
        unsigned int v88 = *v53;
        unsigned int v54 = (unsigned __int8 *)(v52 + SBYTE2(v47));
        if (v17 < (unint64_t)v54) {
          unsigned int v54 = (unsigned __int8 *)v17;
        }
        if (v54 < v41) {
          unsigned int v54 = v41;
        }
        unsigned int v55 = *v54;
        if (v5)
        {
          unint64_t v56 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          unint64_t v57 = *(void *)(result + 40);
          if (v16 < v56) {
            unint64_t v56 = v16;
          }
          if ((unint64_t)v56 < v57) {
            unint64_t v56 = *(unsigned __int8 **)(result + 40);
          }
          v51 |= *v56 << 24;
          unint64_t v58 = v44 + SBYTE1(v47) * (uint64_t)v7;
          if ((unint64_t)v16 >= v58) {
            int v59 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          }
          else {
            int v59 = v16;
          }
          if ((unint64_t)v59 < v57) {
            int v59 = *(unsigned __int8 **)(result + 40);
          }
          v88 |= *v59 << 24;
          char v60 = (unsigned __int8 *)(v58 + SBYTE2(v47));
          if (v16 < v60) {
            char v60 = v16;
          }
          if ((unint64_t)v60 < v57) {
            char v60 = *(unsigned __int8 **)(result + 40);
          }
          v55 |= *v60 << 24;
        }
        int v61 = interpolate_8888_21358[v49];
        char v62 = v49 + 1;
        unsigned int v63 = v43 - ((v61 & v43) >> v62) + ((v61 & v88) >> v62);
        unsigned int v64 = v51 - ((v61 & v51) >> v62) + ((v61 & v55) >> v62);
        int v65 = (v47 >> 28) & 3;
        int v66 = interpolate_8888_21358[v65];
        char v67 = v65 + 1;
        unsigned int v68 = v63 - ((v63 & v66) >> v67);
        unsigned int v69 = v64 & v66;
LABEL_102:
        unsigned int v75 = v69 >> v67;
LABEL_103:
        unsigned int v43 = v68 + v75;
        break;
    }
LABEL_104:
    *(void *)(v11 + 8) = (((v43 | v13) >> 24) - ((v43 | v13) != 0)) | ((unint64_t)((v43 | v13) >> 24) << 32);
    *(unsigned char *)(v12 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v81 = 0;
    a2 += v10;
    uint64_t v82 = v90 - a2;
    a3 += v9;
    uint64_t v83 = v92 - a3;
    uint64_t v84 = -8;
    while (((v83 | v82 | (a3 - v93) | (a2 - v91)) & 0x8000000000000000) == 0)
    {
      unint64_t v40 = v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32);
      int v41 = *(unsigned __int8 **)(result + 32);
      if (v17 >= v40) {
        int v85 = (unsigned __int8 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32));
      }
      else {
        int v85 = (unsigned __int8 *)v17;
      }
      if (v85 < v41) {
        int v85 = *(unsigned __int8 **)(result + 32);
      }
      unsigned int v43 = *v85;
      if (v5)
      {
        unint64_t v44 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        int v86 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v44) {
          unint64_t v87 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        }
        else {
          unint64_t v87 = (unint64_t)v16;
        }
        if (v87 >= (unint64_t)v86) {
          int v86 = (unsigned __int8 *)v87;
        }
        v43 |= *v86 << 24;
      }
      if (v8)
      {
        unsigned int v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v47 & 0xF) != 0)
        {
          v12 += v81 + 1;
          v11 -= v84;
          a4 += ~v81;
          unsigned int v27 = -1;
          goto LABEL_48;
        }
      }
      *(void *)(v11 + 8 * v81 + 16) = (((v43 | v13) >> 24) - ((v43 | v13) != 0)) | ((unint64_t)((v43 | v13) >> 24) << 32);
      *(unsigned char *)(v12 + v81++ + 2) = -1;
      v84 -= 8;
      a2 += v10;
      v82 -= v10;
      a3 += v9;
      v83 -= v9;
      if (a4 - 1 == v81) {
        return result;
      }
    }
    v12 += v81 + 1;
    v11 -= v84;
    a4 += ~v81;
  }
  while (a4);
  return result;
}

uint64_t cmyk32_shade(uint64_t a1, __n128 a2)
{
  unsigned int v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(void *)(v5 + 16))
    {
      int v14 = cmyk32_shade_radial_CMYK;
    }
    else if (*(void *)(v5 + 24))
    {
      int v14 = cmyk32_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      int v14 = cmyk32_shade_axial_CMYK;
    }
    else
    {
      int v14 = cmyk32_shade_custom_CMYK;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 384)
    {
      uint64_t v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 2, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    uint64_t v16 = malloc_type_malloc(10 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  cmyk32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

void cmyk32_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v433 = a3;
  uint64_t v441 = *MEMORY[0x1E4F143B8];
  uint64_t v427 = a1;
  uint64_t v438 = *(unsigned int *)(a1 + 4);
  uint64_t v422 = (int)v438;
  unint64_t v4 = ((int)v438 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 > 0x1FFFFFF) {
    return;
  }
  uint64_t v6 = *(void *)(v427 + 40);
  uint64_t v428 = *(void *)(v427 + 48);
  float v7 = *(float *)(a2 + 184);
  uint64_t v8 = *(int **)(v427 + 136);
  uint64_t v435 = *(void *)(a2 + 96);
  uint64_t v418 = *(void *)(a2 + 104);
  uint64_t v10 = *(int *)(v427 + 24);
  unint64_t v9 = *(int *)(v427 + 28);
  uint64_t v11 = *(int *)(v427 + 16);
  uint64_t v437 = *(int *)(v427 + 20);
  uint64_t v12 = *(int *)(v427 + 12);
  int v434 = *(_DWORD *)(v427 + 8);
  uint64_t v13 = *(int *)(a2 + 16);
  uint64_t v14 = (v13 + 10) * v4;
  if (v14 > 65439)
  {
    unint64_t v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x3023562EuLL);
    uint64_t v16 = v17;
    long long v19 = v17;
    if (!v17) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    uint64_t v16 = (char *)&v415 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    long long v19 = 0;
  }
  int v417 = v19;
  int v439 = (int)(float)((float)(v7 * 255.0) + 0.5);
  unint64_t v20 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v21 = v20 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(void *)(a2 + 160) = v21;
  if (v13) {
    uint64_t v22 = 8 * v4;
  }
  else {
    uint64_t v22 = 0;
  }
  uint64_t v23 = a2;
  unint64_t v24 = v21 + v22;
  uint64_t v25 = v6 + (v10 - 1) * v9;
  unint64_t v26 = v9 >> 2;
  *(void *)(v23 + 144) = v20;
  *(void *)(v23 + 152) = v24;
  uint64_t v430 = v23;
  uint64_t v27 = v428;
  if (v428)
  {
    uint64_t v28 = v427;
    uint64_t v29 = *(int *)(v427 + 32);
    long long v30 = (char *)(v428 + v12 + (int)v29 * (uint64_t)(int)v11);
    uint64_t v432 = v29 - v422;
    uint64_t v31 = v422;
    uint64_t v440 = 1;
  }
  else
  {
    long long v30 = 0;
    uint64_t v432 = 0;
    uint64_t v440 = 0;
    uint64_t v28 = v427;
    uint64_t v31 = v422;
  }
  uint64_t v32 = v25 + 4 * v437;
  long long v33 = (unsigned int *)(v6 + 4 * (v12 + v26 * v11));
  uint64_t v431 = v26 - v31;
  uint64_t v34 = *(int *)(v28 + 104);
  int v35 = *(_DWORD *)(v28 + 108);
  int v36 = *(unsigned __int8 *)(v28 + 2);
  if (v36 == 6 || v36 == 1)
  {
    uint64_t v37 = v430;
    uint64_t v38 = v435;
    if (!v8) {
      goto LABEL_34;
    }
    unint64_t v415 = v26;
    uint64_t v39 = 0;
    int v40 = 0;
    uint64_t v41 = *(int *)(v28 + 124);
    int v42 = (unsigned __int8 *)v8 + v34 + (int)v41 * (uint64_t)v35;
    uint64_t v31 = v422;
    uint64_t v429 = v41 - v422;
    uint64_t v43 = v438;
    goto LABEL_21;
  }
  unint64_t v415 = v26;
  if (!v8)
  {
    int v42 = 0;
    uint64_t v39 = 0;
    uint64_t v429 = 0;
    int v40 = 0;
    uint64_t v37 = v430;
    uint64_t v43 = v438;
    uint64_t v38 = v435;
LABEL_21:
    uint64_t v47 = v418;
LABEL_38:
    LODWORD(v437) = v40;
    uint64_t v421 = (v43 - 1) + 1;
    uint64_t v420 = -v31;
    uint64x2_t v426 = (uint64x2_t)xmmword_1850CDB70;
    uint64_t v416 = v32;
    unint64_t v419 = v32 - 4;
    uint64x2_t v425 = (uint64x2_t)xmmword_1850CDB80;
    int8x16_t v424 = (int8x16_t)xmmword_1850CDB90;
    int8x16_t v423 = (int8x16_t)xmmword_1850CDBA0;
    uint64_t v53 = v39;
    while (2)
    {
      uint64_t v435 = v38;
      float v436 = (void *)v53;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))v37)(v37, v38, v47, v43);
      unsigned int v54 = *(unint64_t **)(v37 + 160);
      unsigned int v55 = *(unsigned __int8 **)(v37 + 144);
      unsigned int v57 = *(_DWORD *)(v37 + 8);
      int v56 = *(_DWORD *)(v37 + 12);
      if (v57 == v56)
      {
        if (v439 == 255) {
          goto LABEL_47;
        }
        int v58 = v43;
        int v59 = *(unsigned char **)(v37 + 144);
        do
        {
          if (*v59) {
            unint64_t *v54 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v439);
          }
          ++v59;
          ++v54;
          --v58;
        }
        while (v58);
        v54 += v420;
        v55 += v421 + v420;
        goto LABEL_46;
      }
      uint64_t v66 = *(void *)(v37 + 152);
      int v67 = HIWORD(v57) & 0x3F;
      if (v67 == 16)
      {
        if (v56 == 134759428)
        {
          if (v439 != 255)
          {
            uint64_t v81 = 0;
            uint64_t v82 = v66 + 8;
            do
            {
              if (v55[v81]) {
                v54[v81] = PDAM_5699(HIDWORD(*(void *)(v82 - 8)) & 0xFF000000 | (*(void *)(v82 - 8) >> 24) & 0xFF0000 | WORD1(*(void *)(v82 - 8)) & 0xFF00 | BYTE1(*(void *)(v82 - 8)), *(unsigned __int8 *)(v82 + 1), v439);
              }
              v82 += 16;
              ++v81;
            }
            while (v43 != v81);
            goto LABEL_46;
          }
          uint64_t v113 = 0;
          uint64_t v114 = (unsigned __int16 *)(v66 + 8);
          do
          {
            if (v55[v113])
            {
              uint64_t v115 = (const double *)(v114 - 4);
              uint64x2_t v116 = (uint64x2_t)vld1q_dup_f64(v115);
              int8x16_t v117 = vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v116, v426), v423), vandq_s8((int8x16_t)vshlq_u64(v116, v425), v424));
              v54[v113] = *(void *)&vorr_s8(*(int8x8_t *)v117.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v117, v117, 8uLL)) | ((unint64_t)*v114 << 24) & 0xFF00000000;
            }
            v114 += 8;
            ++v113;
          }
          while (v43 != v113);
        }
        else
        {
          if (v439 != 255)
          {
            uint64_t v97 = 0;
            uint64_t v98 = v66 + 8;
            do
            {
              if (v55[v97]) {
                v54[v97] = PDAM_5699((HIBYTE(*(void *)(v98 - 8)) | (BYTE3(*(void *)(v98 - 8)) << 16)) & 0xFFFFFF | (BYTE1(*(void *)(v98 - 8)) << 24) | HIDWORD(*(void *)(v98 - 8)) & 0xFF00, *(unsigned __int8 *)(v98 + 1), v439);
              }
              v98 += 16;
              ++v97;
            }
            while (v43 != v97);
            goto LABEL_46;
          }
          uint64_t v132 = 0;
          uint64_t v133 = (_WORD *)(v66 + 8);
          do
          {
            if (v55[v132]) {
              v54[v132] = (*((void *)v133 - 1) >> 8) & 0xFF0000 | HIBYTE(*((void *)v133 - 1)) | (BYTE1(*((void *)v133 - 1)) << 24) | HIDWORD(*((void *)v133 - 1)) & 0xFF00 | ((unint64_t)HIBYTE(*v133) << 32);
            }
            v133 += 8;
            ++v132;
          }
          while (v43 != v132);
        }
      }
      else if (v67 == 32)
      {
        if (v56 == 134759428)
        {
          if (v439 != 255)
          {
            uint64_t v68 = 0;
            unsigned int v69 = (float *)(v66 + 8);
            do
            {
              if (v55[v68])
              {
                float v70 = v69[2];
                if (v70 <= 0.0)
                {
                  unint64_t v80 = 0;
                }
                else
                {
                  float v71 = *(v69 - 2);
                  float v72 = *(v69 - 1);
                  float v73 = *v69;
                  float v74 = v69[1];
                  int v75 = (int)(float)((float)(v70 * 255.0) + 0.5);
                  if (v70 > 1.0)
                  {
                    int v75 = 255;
                    float v70 = 1.0;
                  }
                  int v76 = (int)(float)((float)(v71 * 255.0) + 0.5);
                  if (v71 < 0.0) {
                    int v76 = 0;
                  }
                  if (v71 > v70) {
                    int v76 = v75;
                  }
                  int v77 = (int)(float)((float)(v72 * 255.0) + 0.5);
                  if (v72 < 0.0) {
                    int v77 = 0;
                  }
                  if (v72 > v70) {
                    int v77 = v75;
                  }
                  int v78 = (int)(float)((float)(v73 * 255.0) + 0.5);
                  if (v73 < 0.0) {
                    int v78 = 0;
                  }
                  if (v73 > v70) {
                    int v78 = v75;
                  }
                  int v79 = (int)(float)((float)(v74 * 255.0) + 0.5);
                  if (v74 < 0.0) {
                    int v79 = 0;
                  }
                  if (v74 > v70) {
                    int v79 = v75;
                  }
                  unint64_t v80 = PDAM_5699(v76 | (v77 << 8) | (v78 << 16) | (v79 << 24), v75, v439);
                }
                v54[v68] = v80;
              }
              ++v68;
              v69 += 5;
            }
            while (v43 != v68);
LABEL_46:
            uint64_t v27 = v428;
            goto LABEL_47;
          }
          uint64_t v100 = 0;
          uint64_t v101 = (float *)(v66 + 8);
          do
          {
            if (v55[v100])
            {
              float v102 = v101[2];
              if (v102 <= 0.0)
              {
                unint64_t v112 = 0;
              }
              else
              {
                float v103 = *(v101 - 2);
                float v104 = *(v101 - 1);
                float v105 = *v101;
                float v106 = v101[1];
                LODWORD(v107) = (int)(float)((float)(v102 * 255.0) + 0.5);
                if (v102 <= 1.0) {
                  uint64_t v107 = v107;
                }
                else {
                  uint64_t v107 = 255;
                }
                if (v102 > 1.0) {
                  float v102 = 1.0;
                }
                int v108 = (int)(float)((float)(v103 * 255.0) + 0.5);
                if (v103 < 0.0) {
                  int v108 = 0;
                }
                if (v103 > v102) {
                  int v108 = v107;
                }
                int v109 = (int)(float)((float)(v104 * 255.0) + 0.5);
                if (v104 < 0.0) {
                  int v109 = 0;
                }
                if (v104 > v102) {
                  int v109 = v107;
                }
                int v110 = (int)(float)((float)(v105 * 255.0) + 0.5);
                if (v105 < 0.0) {
                  int v110 = 0;
                }
                if (v105 > v102) {
                  int v110 = v107;
                }
                int v111 = (int)(float)((float)(v106 * 255.0) + 0.5);
                if (v106 < 0.0) {
                  int v111 = 0;
                }
                if (v106 > v102) {
                  int v111 = v107;
                }
                unint64_t v112 = v108 | (v109 << 8) | (v110 << 16) | (v111 << 24) | (unint64_t)(v107 << 32);
              }
              v54[v100] = v112;
            }
            ++v100;
            v101 += 5;
          }
          while (v43 != v100);
        }
        else if (v439 == 255)
        {
          uint64_t v119 = 0;
          uint64_t v120 = (float *)(v66 + 8);
          do
          {
            if (v55[v119])
            {
              float v121 = v120[2];
              if (v121 <= 0.0)
              {
                unint64_t v131 = 0;
              }
              else
              {
                float v122 = *(v120 - 2);
                float v123 = *(v120 - 1);
                float v124 = *v120;
                float v125 = v120[1];
                LODWORD(v126) = (int)(float)((float)(v121 * 255.0) + 0.5);
                if (v121 <= 1.0)
                {
                  uint64_t v126 = v126;
                }
                else
                {
                  float v121 = 1.0;
                  uint64_t v126 = 255;
                }
                int v127 = (int)(float)((float)(v122 * 255.0) + 0.5);
                if (v122 < 0.0) {
                  int v127 = 0;
                }
                if (v122 > v121) {
                  int v127 = v126;
                }
                int v128 = (int)(float)((float)(v123 * 255.0) + 0.5);
                if (v123 < 0.0) {
                  int v128 = 0;
                }
                if (v123 > v121) {
                  int v128 = v126;
                }
                int v129 = (int)(float)((float)(v124 * 255.0) + 0.5);
                if (v124 < 0.0) {
                  int v129 = 0;
                }
                if (v124 > v121) {
                  int v129 = v126;
                }
                int v130 = (int)(float)((float)(v125 * 255.0) + 0.5);
                if (v125 < 0.0) {
                  int v130 = 0;
                }
                if (v125 > v121) {
                  int v130 = v126;
                }
                unint64_t v131 = (v128 << 16) | (v127 << 24) | (v129 << 8) | v130 | (unint64_t)(v126 << 32);
              }
              v54[v119] = v131;
            }
            ++v119;
            v120 += 5;
          }
          while (v43 != v119);
        }
        else
        {
          uint64_t v84 = 0;
          int v85 = (float *)(v66 + 8);
          do
          {
            if (v55[v84])
            {
              float v86 = v85[2];
              if (v86 <= 0.0)
              {
                unint64_t v96 = 0;
              }
              else
              {
                float v87 = *(v85 - 2);
                float v88 = *(v85 - 1);
                int v89 = (int)(float)((float)(v86 * 255.0) + 0.5);
                float v90 = *v85;
                float v91 = v85[1];
                if (v86 > 1.0)
                {
                  float v86 = 1.0;
                  int v89 = 255;
                }
                int v92 = (int)(float)((float)(v87 * 255.0) + 0.5);
                if (v87 < 0.0) {
                  int v92 = 0;
                }
                if (v87 > v86) {
                  int v92 = v89;
                }
                int v93 = (int)(float)((float)(v88 * 255.0) + 0.5);
                if (v88 < 0.0) {
                  int v93 = 0;
                }
                if (v88 > v86) {
                  int v93 = v89;
                }
                int v94 = (int)(float)((float)(v90 * 255.0) + 0.5);
                if (v90 < 0.0) {
                  int v94 = 0;
                }
                if (v90 > v86) {
                  int v94 = v89;
                }
                int v95 = (int)(float)((float)(v91 * 255.0) + 0.5);
                if (v91 < 0.0) {
                  int v95 = 0;
                }
                if (v91 > v86) {
                  int v95 = v89;
                }
                unint64_t v96 = PDAM_5699((v93 << 16) | (v92 << 24) | (v94 << 8) | v95, v89, v439);
              }
              v54[v84] = v96;
            }
            ++v84;
            v85 += 5;
          }
          while (v438 != v84);
          uint64_t v43 = v438;
        }
      }
      else if (v56 == 134759428)
      {
        if (v439 != 255)
        {
          uint64_t v83 = 0;
          do
          {
            if (v55[v83]) {
              v54[v83] = PDAM_5699(bswap32(*(_DWORD *)(v66 + 8 * v83)), *(unsigned __int8 *)(v66 + 8 * v83 + 4), v439);
            }
            ++v83;
          }
          while (v43 != v83);
          goto LABEL_46;
        }
        uint64_t v118 = 0;
        do
        {
          if (v55[v118]) {
            v54[v118] = *(void *)(v66 + 8 * v118) & 0xFF00000000 | bswap32(*(void *)(v66 + 8 * v118));
          }
          ++v118;
        }
        while (v43 != v118);
      }
      else
      {
        if (v439 != 255)
        {
          uint64_t v99 = 0;
          do
          {
            if (v55[v99]) {
              v54[v99] = PDAM_5699(*(_DWORD *)(v66 + 8 * v99), *(unsigned __int8 *)(v66 + 8 * v99 + 4), v439);
            }
            ++v99;
          }
          while (v43 != v99);
          goto LABEL_46;
        }
        uint64_t v134 = 0;
        do
        {
          if (v55[v134]) {
            v54[v134] = *(unsigned int *)(v66 + 8 * v134);
          }
          ++v134;
        }
        while (v43 != v134);
      }
LABEL_47:
      switch(v433)
      {
        case 0:
          uint64_t v60 = v42 != 0;
          if (v27)
          {
            int v61 = v43;
            char v62 = v42;
            do
            {
              unsigned int v63 = *v55;
              if (*v55)
              {
                if (v42) {
                  unsigned int v63 = (*v62 * v63 + ((*v62 * v63) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v63)
                {
                  if (v63 == 255)
                  {
                    LOBYTE(v64) = 0;
                    *long long v33 = 0;
                  }
                  else
                  {
                    unint64_t v65 = PDAM_5699(*v33, *v30, ~(_BYTE)v63);
                    *long long v33 = v65;
                    unint64_t v64 = HIDWORD(v65);
                  }
                  *long long v30 = v64;
                }
              }
              ++v55;
              v62 += v60;
              ++v33;
              ++v30;
              --v61;
            }
            while (v61);
            int v42 = &v62[v429];
            v33 += v431;
            v30 += v432;
            goto LABEL_657;
          }
          int v368 = v43;
          float v369 = v42;
          uint64_t v188 = v435;
          do
          {
            int v370 = *v55;
            if (*v55)
            {
              if (v42) {
                int v370 = ((unsigned __int16)(*v369 * (_WORD)v370 + ((*v369 * v370) >> 8) + 1) >> 8);
              }
              if (v370)
              {
                if (v370 == 255) {
                  unsigned int v371 = 0;
                }
                else {
                  unsigned int v371 = (((*v33 & 0xFF00FF) * (v370 ^ 0xFF)
                }
                         + 65537
                         + ((((*v33 & 0xFF00FF) * (v370 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v33 >> 8) & 0xFF00FF) * (v370 ^ 0xFF) + 65537 + (((((*v33 >> 8) & 0xFF00FF) * (v370 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                *long long v33 = v371;
              }
            }
            ++v55;
            v369 += v60;
            ++v33;
            --v368;
          }
          while (v368);
          int v42 = &v369[v429];
          v33 += v431;
          v30 += v432;
          goto LABEL_606;
        case 1:
          unsigned __int8 v135 = *v55;
          if (v27)
          {
            uint64_t v136 = 0;
            if (v42)
            {
              int v137 = v55 + 1;
              unsigned int v138 = v33;
              do
              {
                float v139 = v138;
                if (v135)
                {
                  unsigned int v140 = v42[v136] * v135 + ((v42[v136] * v135) >> 8) + 1;
                  if (BYTE1(v140))
                  {
                    uint64_t v141 = (unsigned __int8 *)&v30[v136];
                    if (BYTE1(v140) == 255)
                    {
                      unint64_t v142 = v54[v136];
                      v33[v136] = v142;
                      unsigned __int8 *v141 = BYTE4(v142);
                    }
                    else
                    {
                      DAMplusDAM(v138, v141, v54[v136], BYTE4(v54[v136]), BYTE1(v140), v33[v136], *v141, ~(v140 >> 8));
                    }
                  }
                }
                unsigned __int8 v135 = v137[v136];
                unsigned int v138 = v139 + 1;
                ++v136;
              }
              while (v43 != v136);
              uint64_t v143 = (uint64_t)&v30[v136 - 1];
              uint64_t v27 = v428;
              v42 += v136 + v429;
            }
            else
            {
              float v395 = v55 + 1;
              float v396 = v33;
              do
              {
                if (v135)
                {
                  unsigned int v397 = (unsigned __int8 *)&v30[v136];
                  if (v135 == 255)
                  {
                    unint64_t v398 = v54[v136];
                    v33[v136] = v398;
                    *unsigned int v397 = BYTE4(v398);
                  }
                  else
                  {
                    DAMplusDAM(v396, v397, v54[v136], BYTE4(v54[v136]), v135, v33[v136], *v397, ~v135);
                  }
                }
                unsigned __int8 v135 = v395[v136];
                ++v396;
                ++v136;
              }
              while (v43 != v136);
              int v42 = 0;
              uint64_t v143 = (uint64_t)&v30[v136 - 1];
              float v139 = v396 - 1;
            }
            long long v33 = &v139[v431 + 1];
            long long v30 = (char *)(v143 + v432 + 1);
            goto LABEL_605;
          }
          unsigned int v372 = v55 + 1;
          if (v42)
          {
            int v373 = v43;
            do
            {
              if (v135)
              {
                unsigned int v374 = *v42 * v135 + ((*v42 * v135) >> 8) + 1;
                float v375 = (unsigned int *)v419;
                if (v419 >= (unint64_t)v33) {
                  float v375 = v33;
                }
                if ((unint64_t)v375 >= *(void *)(v427 + 40)) {
                  int v376 = v375;
                }
                else {
                  int v376 = *(unsigned int **)(v427 + 40);
                }
                if (BYTE1(v374))
                {
                  if (BYTE1(v374) == 255) {
                    *int v376 = *v54;
                  }
                  else {
                    DMplusDM(v376, *(_DWORD *)v54, BYTE1(v374), *v376, ~(v374 >> 8));
                  }
                }
              }
              else
              {
                int v376 = v33;
              }
              unsigned __int8 v377 = *v372++;
              unsigned __int8 v135 = v377;
              ++v54;
              ++v42;
              long long v33 = v376 + 1;
              --v373;
            }
            while (v373);
            uint64_t v27 = v428;
            v42 += v429;
          }
          else
          {
            int v404 = v43;
            do
            {
              unsigned __int8 v405 = (unsigned int *)v419;
              if (v419 >= (unint64_t)v33) {
                unsigned __int8 v405 = v33;
              }
              if ((unint64_t)v405 >= *(void *)(v427 + 40)) {
                int v376 = v405;
              }
              else {
                int v376 = *(unsigned int **)(v427 + 40);
              }
              if (v135)
              {
                if (v135 == 255) {
                  *int v376 = *v54;
                }
                else {
                  DMplusDM(v376, *(_DWORD *)v54, v135, *v376, ~v135);
                }
              }
              unsigned __int8 v406 = *v372++;
              unsigned __int8 v135 = v406;
              ++v54;
              long long v33 = v376 + 1;
              --v404;
            }
            while (v404);
            int v42 = 0;
          }
          int v407 = &v376[v431];
          goto LABEL_710;
        case 2:
          unsigned __int8 v144 = *v55;
          if (v27)
          {
            uint64_t v145 = 0;
            if (v42)
            {
              unint64_t v146 = v55 + 1;
              unint64_t v147 = v33;
              while (1)
              {
                float v148 = v147;
                if (!v144) {
                  goto LABEL_241;
                }
                unsigned int v149 = v42[v145] * v144 + ((v42[v145] * v144) >> 8) + 1;
                if (!BYTE1(v149)) {
                  goto LABEL_241;
                }
                float v150 = (unsigned __int8 *)&v30[v145];
                if (BYTE1(v149) == 255)
                {
                  unint64_t v151 = v54[v145];
                  if (BYTE4(v151))
                  {
                    if (BYTE4(v151) != 255) {
                      goto LABEL_240;
                    }
                    v33[v145] = v151;
                    unsigned __int8 *v150 = -1;
                  }
                }
                else
                {
                  unint64_t v152 = PDAM_5699(v54[v145], BYTE4(v54[v145]), BYTE1(v149));
                  if (BYTE4(v152))
                  {
                    unint64_t v151 = v152;
LABEL_240:
                    DAplusDAM(v148, &v30[v145], v151, SBYTE4(v151), v33[v145], *v150, ~BYTE4(v151));
                  }
                }
LABEL_241:
                unsigned __int8 v144 = v146[v145];
                unint64_t v147 = v148 + 1;
                if (v438 == ++v145)
                {
                  uint64_t v153 = (uint64_t)&v30[v145 - 1];
                  uint64_t v37 = v430;
                  v42 += v145 + v429;
LABEL_684:
                  long long v33 = &v148[v431 + 1];
                  long long v30 = (char *)(v153 + v432 + 1);
                  goto LABEL_604;
                }
              }
            }
            float v399 = v55 + 1;
            unsigned __int8 v400 = v33;
            while (1)
            {
              if (v144)
              {
                float v401 = (unsigned __int8 *)&v30[v145];
                if (v144 == 255)
                {
                  unint64_t v402 = v54[v145];
                  if (BYTE4(v402))
                  {
                    if (BYTE4(v402) != 255) {
                      goto LABEL_681;
                    }
                    v33[v145] = v402;
                    *float v401 = -1;
                  }
                }
                else
                {
                  unint64_t v403 = PDAM_5699(v54[v145], BYTE4(v54[v145]), v144);
                  if (BYTE4(v403))
                  {
                    unint64_t v402 = v403;
LABEL_681:
                    DAplusDAM(v400, &v30[v145], v402, SBYTE4(v402), v33[v145], *v401, ~BYTE4(v402));
                  }
                }
              }
              unsigned __int8 v144 = v399[v145];
              ++v400;
              if (v438 == ++v145)
              {
                int v42 = 0;
                uint64_t v153 = (uint64_t)&v30[v145 - 1];
                float v148 = v400 - 1;
                goto LABEL_684;
              }
            }
          }
          if (!v42)
          {
            int v408 = v55 + 1;
            float v379 = v33 - 1;
            int v409 = v43;
            while (1)
            {
              if (v144)
              {
                if (v144 == 255)
                {
                  unint64_t v410 = *v54;
                  if (BYTE4(*v54))
                  {
                    if (BYTE4(*v54) != 255)
                    {
                      unsigned int v411 = v379[1];
                      LODWORD(v410) = ((((v411 >> 8) & 0xFF00FF) * ~BYTE4(v410)
                                      + 65537
                                      + (((((v411 >> 8) & 0xFF00FF) * ~BYTE4(v410)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                    + v410
                                    + ((((v411 & 0xFF00FF) * ~BYTE4(v410)
                                       + 65537
                                       + ((((v411 & 0xFF00FF) * ~BYTE4(v410)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                    }
                    goto LABEL_706;
                  }
                }
                else
                {
                  unint64_t v412 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v144);
                  if (BYTE4(v412))
                  {
                    unsigned int v413 = v379[1];
                    LODWORD(v410) = ((((v413 >> 8) & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)
                                    + 65537
                                    + (((((v413 >> 8) & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                  + v412
                                  + ((((v413 & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)
                                     + 65537
                                     + ((((v413 & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
LABEL_706:
                    v379[1] = v410;
                  }
                }
              }
              unsigned __int8 v414 = *v408++;
              unsigned __int8 v144 = v414;
              ++v54;
              ++v379;
              if (!--v409)
              {
                int v42 = 0;
                goto LABEL_709;
              }
            }
          }
          float v378 = v55 + 1;
          float v379 = v33 - 1;
          int v380 = v43;
          do
          {
            if (v144)
            {
              unsigned int v381 = *v42 * v144 + ((*v42 * v144) >> 8) + 1;
              if (BYTE1(v381))
              {
                if (BYTE1(v381) == 255)
                {
                  unint64_t v382 = *v54;
                  if (!BYTE4(*v54)) {
                    goto LABEL_646;
                  }
                  if (BYTE4(*v54) != 255)
                  {
                    unsigned int v383 = v379[1];
                    LODWORD(v382) = ((((v383 >> 8) & 0xFF00FF) * ~BYTE4(v382)
                                    + 65537
                                    + (((((v383 >> 8) & 0xFF00FF) * ~BYTE4(v382)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                  + v382
                                  + ((((v383 & 0xFF00FF) * ~BYTE4(v382)
                                     + 65537
                                     + ((((v383 & 0xFF00FF) * ~BYTE4(v382)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                  }
                }
                else
                {
                  unint64_t v384 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), BYTE1(v381));
                  if (!BYTE4(v384)) {
                    goto LABEL_646;
                  }
                  unsigned int v385 = v379[1];
                  LODWORD(v382) = ((((v385 >> 8) & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)
                                  + 65537
                                  + (((((v385 >> 8) & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                + v384
                                + ((((v385 & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)
                                   + 65537
                                   + ((((v385 & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                }
                v379[1] = v382;
              }
            }
LABEL_646:
            unsigned __int8 v386 = *v378++;
            unsigned __int8 v144 = v386;
            ++v54;
            ++v42;
            ++v379;
            --v380;
          }
          while (v380);
          v42 += v429;
LABEL_709:
          int v407 = &v379[v431];
LABEL_710:
          long long v33 = v407 + 1;
LABEL_711:
          v30 += v432;
LABEL_605:
          uint64_t v188 = v435;
LABEL_606:
          unint64_t v52 = v436;
          if (v434 == 1) {
            goto LABEL_32;
          }
          --v434;
          uint64_t v53 = 0;
          LODWORD(v437) = v437 + 1;
          uint64_t v38 = *(void *)(v37 + 128) + v188;
          v47 += *(void *)(v37 + 136);
          if (v436)
          {
            uint64_t v46 = v422;
            goto LABEL_22;
          }
          continue;
        case 3:
          unint64_t v154 = v42;
          do
          {
            unsigned int v155 = *v55;
            if (*v55)
            {
              if (v42) {
                unsigned int v155 = (*v154 * v155 + ((*v154 * v155) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v155)
              {
                if (v155 == 255)
                {
                  unint64_t v156 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), *v30);
                  *long long v33 = v156;
                  *long long v30 = BYTE4(v156);
                }
                else
                {
                  DAMplusDAM(v33, v30, *(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), (unsigned __int16)(*v30 * v155+ ((*v30 * v155) >> 8)+ 1) >> 8, *v33, *v30, ~(_BYTE)v155);
                }
              }
            }
            ++v55;
            ++v54;
            v154 += v42 != 0;
            ++v33;
            v30 += v440;
            LODWORD(v43) = v43 - 1;
          }
          while (v43);
          goto LABEL_355;
        case 4:
          unint64_t v154 = v42;
          do
          {
            unsigned int v157 = *v55;
            if (*v55)
            {
              if (v42) {
                unsigned int v157 = (*v154 * v157 + ((*v154 * v157) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v157)
              {
                if (v157 == 255)
                {
                  unint64_t v158 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), *v30 ^ 0xFFu);
                  *long long v33 = v158;
                  *long long v30 = BYTE4(v158);
                }
                else
                {
                  DAMplusDAM(v33, v30, *(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), (unsigned __int16)((*v30 ^ 0xFF) * v157+ (((*v30 ^ 0xFF) * v157) >> 8)+ 1) >> 8, *v33, *v30, ~(_BYTE)v157);
                }
              }
            }
            ++v55;
            ++v54;
            v154 += v42 != 0;
            ++v33;
            v30 += v440;
            LODWORD(v43) = v43 - 1;
          }
          while (v43);
          goto LABEL_355;
        case 5:
          int v159 = v43;
          float v160 = v42;
          while (1)
          {
            unsigned int v161 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_268;
              }
              unsigned int v162 = *v160 * v161 + ((*v160 * v161) >> 8) + 1;
              if (BYTE1(v162)) {
                break;
              }
            }
LABEL_269:
            ++v55;
            ++v54;
            v160 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v159) {
              goto LABEL_335;
            }
          }
          unsigned int v161 = v162 >> 8;
LABEL_268:
          int v163 = *v30;
          unint64_t v164 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v161);
          DAMplusDAM(v33, v30, v164, BYTE4(v164), v163, *v33, v163, ~BYTE4(v164));
          goto LABEL_269;
        case 6:
          unint64_t v154 = v42;
          while (1)
          {
            unsigned int v165 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_276;
              }
              unsigned int v166 = *v154 * v165 + ((*v154 * v165) >> 8) + 1;
              if (BYTE1(v166)) {
                break;
              }
            }
LABEL_280:
            ++v55;
            ++v54;
            v154 += v42 != 0;
            ++v33;
            v30 += v440;
            LODWORD(v43) = v43 - 1;
            if (!v43)
            {
LABEL_355:
              int v42 = &v154[v429];
              goto LABEL_603;
            }
          }
          unsigned int v165 = v166 >> 8;
LABEL_276:
          if (*v30 != -1)
          {
            if (~*v30 == 255)
            {
              unint64_t v167 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v165);
              *long long v33 = v167;
              *long long v30 = BYTE4(v167);
            }
            else
            {
              DAplusDAM(v33, v30, *v33, *v30, *(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), (unsigned __int16)(~*v30 * v165+ ((~*v30 * v165) >> 8)+ 1) >> 8);
            }
          }
          goto LABEL_280;
        case 7:
          uint64_t v168 = v42 != 0;
          unint64_t v154 = v42;
          if (v27)
          {
            do
            {
              unsigned int v169 = *v55;
              if (*v55)
              {
                if (v42) {
                  unsigned int v169 = (*v154 * v169 + ((*v154 * v169) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v169)
                {
                  if (v169 == 255)
                  {
                    unint64_t v170 = PDAM_5699(*v33, *v30, *((unsigned __int8 *)v54 + 4));
                    *long long v33 = v170;
                    *long long v30 = BYTE4(v170);
                  }
                  else
                  {
                    unsigned int v171 = *((unsigned __int8 *)v54 + 4) * v169;
                    DAMplusDAM(v33, v30, *v33, *v30, (unsigned __int16)(v171 + (v171 >> 8) + 1) >> 8, *v33, *v30, ~(_BYTE)v169);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v168;
              ++v33;
              ++v30;
              LODWORD(v43) = v43 - 1;
            }
            while (v43);
          }
          else
          {
            do
            {
              unsigned int v172 = *v55;
              if (*v55)
              {
                if (v42) {
                  unsigned int v172 = (*v154 * v172 + ((*v154 * v172) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v172)
                {
                  if (v172 == 255)
                  {
                    int v173 = *((unsigned __int8 *)v54 + 4);
                    *long long v33 = ((v173 * (*v33 & 0xFF00FF) + 65537 + (((v173 * (*v33 & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v173 * ((*v33 >> 8) & 0xFF00FF) + 65537 + (((v173 * ((*v33 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  }
                  else
                  {
                    unsigned int v174 = *((unsigned __int8 *)v54 + 4) * v172;
                    DMplusDM(v33, *v33, (unsigned __int16)(v174 + (v174 >> 8) + 1) >> 8, *v33, ~(_BYTE)v172);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v168;
              ++v33;
              LODWORD(v43) = v43 - 1;
            }
            while (v43);
          }
          goto LABEL_355;
        case 8:
          uint64_t v175 = v42 != 0;
          unint64_t v154 = v42;
          if (v27)
          {
            do
            {
              unsigned int v176 = *v55;
              if (*v55)
              {
                if (v42) {
                  unsigned int v176 = (*v154 * v176 + ((*v154 * v176) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v176)
                {
                  if (v176 == 255)
                  {
                    unint64_t v177 = PDAM_5699(*v33, *v30, *((unsigned __int8 *)v54 + 4) ^ 0xFFu);
                    *long long v33 = v177;
                    *long long v30 = BYTE4(v177);
                  }
                  else
                  {
                    unsigned int v178 = (*((unsigned __int8 *)v54 + 4) ^ 0xFF) * v176;
                    DAMplusDAM(v33, v30, *v33, *v30, (unsigned __int16)(v178 + (v178 >> 8) + 1) >> 8, *v33, *v30, ~(_BYTE)v176);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v175;
              ++v33;
              ++v30;
              LODWORD(v43) = v43 - 1;
            }
            while (v43);
          }
          else
          {
            do
            {
              unsigned int v179 = *v55;
              if (*v55)
              {
                if (v42) {
                  unsigned int v179 = (*v154 * v179 + ((*v154 * v179) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v179)
                {
                  if (v179 == 255)
                  {
                    int v180 = *((unsigned __int8 *)v54 + 4) ^ 0xFF;
                    *long long v33 = ((v180 * (*v33 & 0xFF00FF) + 65537 + (((v180 * (*v33 & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v180 * ((*v33 >> 8) & 0xFF00FF) + 65537 + (((v180 * ((*v33 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  }
                  else
                  {
                    unsigned int v181 = (*((unsigned __int8 *)v54 + 4) ^ 0xFF) * v179;
                    DMplusDM(v33, *v33, (unsigned __int16)(v181 + (v181 >> 8) + 1) >> 8, *v33, ~(_BYTE)v179);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v175;
              ++v33;
              LODWORD(v43) = v43 - 1;
            }
            while (v43);
          }
          goto LABEL_355;
        case 9:
          uint64_t v418 = v47;
          uint64_t v182 = v42;
          int v183 = v43;
          while (1)
          {
            unsigned int v184 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_325;
              }
              unsigned int v185 = *v182 * v184 + ((*v182 * v184) >> 8) + 1;
              if (BYTE1(v185)) {
                break;
              }
            }
LABEL_326:
            ++v55;
            ++v54;
            v182 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v183)
            {
              uint64_t v27 = v428;
              int v42 = &v182[v429];
              uint64_t v37 = v430;
              v33 += v431;
              v30 += v432;
              uint64_t v43 = v438;
              uint64_t v188 = v435;
              uint64_t v47 = v418;
              goto LABEL_606;
            }
          }
          unsigned int v184 = v185 >> 8;
LABEL_325:
          int v186 = *v30;
          unint64_t v187 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v184);
          DAMplusDAM(v33, v30, v187, BYTE4(v187), v186 ^ 0xFF, *v33, v186, (BYTE4(v187) + ~(_BYTE)v184));
          goto LABEL_326;
        case 10:
          float v160 = v42;
          int v189 = v43;
          while (1)
          {
            unsigned int v190 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_333;
              }
              unsigned int v191 = *v160 * v190 + ((*v160 * v190) >> 8) + 1;
              if (BYTE1(v191)) {
                break;
              }
            }
LABEL_334:
            ++v55;
            ++v54;
            v160 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v189)
            {
LABEL_335:
              int v42 = &v160[v429];
              uint64_t v37 = v430;
              uint64_t v194 = v431;
              goto LABEL_656;
            }
          }
          unsigned int v190 = v191 >> 8;
LABEL_333:
          int v192 = *v30;
          unint64_t v193 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v190);
          DAMplusDAM(v33, v30, v193, BYTE4(v193), v192 ^ 0xFF, *v33, v192, ~BYTE4(v193));
          goto LABEL_334;
        case 11:
          uint64_t v195 = v42 != 0;
          if (v27)
          {
            int v196 = v42;
            while (1)
            {
              unsigned int v197 = *v55;
              if (*v55)
              {
                if (!v42) {
                  goto LABEL_342;
                }
                unsigned int v198 = *v196 * v197 + ((*v196 * v197) >> 8) + 1;
                if (BYTE1(v198)) {
                  break;
                }
              }
LABEL_343:
              ++v55;
              ++v54;
              v196 += v195;
              ++v33;
              ++v30;
              LODWORD(v43) = v43 - 1;
              if (!v43) {
                goto LABEL_655;
              }
            }
            unsigned int v197 = v198 >> 8;
LABEL_342:
            unint64_t v199 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v197);
            DAplusdDA(v33, v30, *v33, *v30, v199, BYTE4(v199));
            goto LABEL_343;
          }
          int v196 = v42;
          while (1)
          {
            unsigned int v387 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_653;
              }
              unsigned int v388 = *v196 * v387 + ((*v196 * v387) >> 8) + 1;
              if (BYTE1(v388)) {
                break;
              }
            }
LABEL_654:
            ++v55;
            ++v54;
            v196 += v195;
            ++v33;
            LODWORD(v43) = v43 - 1;
            if (!v43)
            {
LABEL_655:
              int v42 = &v196[v429];
              uint64_t v194 = v431;
LABEL_656:
              v33 += v194;
              v30 += v432;
              uint64_t v43 = v438;
LABEL_657:
              uint64_t v27 = v428;
              goto LABEL_605;
            }
          }
          unsigned int v387 = v388 >> 8;
LABEL_653:
          unint64_t v389 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v387);
          DplusdDA(v33, *v33, v389, BYTE4(v389));
          goto LABEL_654;
        case 12:
          uint64_t v200 = v42 != 0;
          if (!v27)
          {
            unsigned __int8 v390 = v42;
            int v391 = v43;
            do
            {
              int v392 = *v55;
              if (*v55)
              {
                if (!v42
                  || (int v392 = ((unsigned __int16)(*v390 * (_WORD)v392
                                                                + ((*v390 * v392) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  unsigned int v393 = (((((*(_DWORD *)v54 >> 8) & 0xFF00FF) * v392
                          + 65537
                          + (((((*(_DWORD *)v54 >> 8) & 0xFF00FFu) * v392) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + ((*v33 >> 8) & 0xFF00FF);
                  unsigned int v394 = ((((*(_DWORD *)v54 & 0xFF00FF) * v392
                          + 65537
                          + ((((*(_DWORD *)v54 & 0xFF00FFu) * v392) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (*v33 & 0xFF00FF);
                  *long long v33 = (v393 << 8) & 0xFF00FF00 | v394 & 0xFF00FF | (15 * (v393 & 0x1000100 | (v394 >> 8) & 0x10001)) | (240 * (v393 & 0x1000100 | (v394 >> 8) & 0x10001));
                }
              }
              ++v55;
              ++v54;
              v390 += v200;
              ++v33;
              --v391;
            }
            while (v391);
            int v42 = &v390[v429];
            v33 += v431;
            goto LABEL_711;
          }
          unint64_t v154 = v42;
          while (1)
          {
            unsigned int v201 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_351;
              }
              unsigned int v202 = *v154 * v201 + ((*v154 * v201) >> 8) + 1;
              if (BYTE1(v202)) {
                break;
              }
            }
LABEL_354:
            ++v55;
            ++v54;
            v154 += v200;
            ++v33;
            ++v30;
            LODWORD(v43) = v43 - 1;
            if (!v43) {
              goto LABEL_355;
            }
          }
          unsigned int v201 = v202 >> 8;
LABEL_351:
          unint64_t v203 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v201);
          unsigned int v204 = ((v203 >> 8) & 0xFF00FF) + ((*v33 >> 8) & 0xFF00FF);
          unsigned int v205 = *v30 + HIDWORD(v203);
          unsigned int v206 = (v204 << 8) & 0xFF00FF00 | ((v203 & 0xFF00FF) + (*v33 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                                * (v204 & 0x1000100 | (((v203 & 0xFF00FF) + (*v33 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v204 & 0x1000100 | (((v203 & 0xFF00FF) + (*v33 & 0xFF00FF)) >> 8) & 0x10001));
          if (v205 >= 0xFF) {
            LOBYTE(v205) = -1;
          }
          *long long v30 = v205;
          *long long v33 = v206;
          goto LABEL_354;
        case 13:
          int v207 = v43;
          uint64_t v208 = v42;
          int v209 = v207;
          while (1)
          {
            unsigned int v210 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_361;
              }
              unsigned int v211 = *v208 * v210 + ((*v208 * v210) >> 8) + 1;
              if (BYTE1(v211)) {
                break;
              }
            }
LABEL_367:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v209) {
              goto LABEL_602;
            }
          }
          unsigned int v210 = v211 >> 8;
LABEL_361:
          unint64_t v212 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v210);
          if (BYTE4(v212))
          {
            unsigned int v213 = v212;
            unint64_t v214 = HIDWORD(v212);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v215 = PDAmultiplyPDA_5700(*v33, *v30, v212, BYTE4(v212));
                unsigned int v213 = v215;
                unint64_t v214 = HIDWORD(v215);
              }
              *long long v33 = v213;
              *long long v30 = v214;
            }
            else
            {
              *long long v33 = PDAmultiplyPDA_5700(*v33, 255, v212, BYTE4(v212));
            }
          }
          goto LABEL_367;
        case 14:
          int v216 = v43;
          uint64_t v208 = v42;
          int v217 = v216;
          while (1)
          {
            unsigned int v218 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_374;
              }
              unsigned int v219 = *v208 * v218 + ((*v208 * v218) >> 8) + 1;
              if (BYTE1(v219)) {
                break;
              }
            }
LABEL_380:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v217) {
              goto LABEL_602;
            }
          }
          unsigned int v218 = v219 >> 8;
LABEL_374:
          unint64_t v220 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v218);
          if (BYTE4(v220))
          {
            unsigned int v221 = v220;
            unint64_t v222 = HIDWORD(v220);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v223 = PDAscreenPDA_5701(*v33, *v30, v220, BYTE4(v220));
                unsigned int v221 = v223;
                unint64_t v222 = HIDWORD(v223);
              }
              *long long v33 = v221;
              *long long v30 = v222;
            }
            else
            {
              *long long v33 = PDAscreenPDA_5701(*v33, 0xFFu, v220, BYTE4(v220));
            }
          }
          goto LABEL_380;
        case 15:
          int v224 = v43;
          uint64_t v208 = v42;
          int v225 = v224;
          while (1)
          {
            unsigned int v226 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_387;
              }
              unsigned int v227 = *v208 * v226 + ((*v208 * v226) >> 8) + 1;
              if (BYTE1(v227)) {
                break;
              }
            }
LABEL_393:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v225) {
              goto LABEL_602;
            }
          }
          unsigned int v226 = v227 >> 8;
LABEL_387:
          unint64_t v228 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v226);
          if (BYTE4(v228))
          {
            unsigned int v229 = v228;
            unint64_t v230 = HIDWORD(v228);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v231 = PDAoverlayPDA_5702(*v33, *v30, v228, BYTE4(v228));
                unsigned int v229 = v231;
                unint64_t v230 = HIDWORD(v231);
              }
              *long long v33 = v229;
              *long long v30 = v230;
            }
            else
            {
              *long long v33 = PDAoverlayPDA_5702(*v33, 255, v228, BYTE4(v228));
            }
          }
          goto LABEL_393;
        case 16:
          int v232 = v43;
          uint64_t v208 = v42;
          int v233 = v232;
          while (1)
          {
            unsigned int v234 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_400;
              }
              unsigned int v235 = *v208 * v234 + ((*v208 * v234) >> 8) + 1;
              if (BYTE1(v235)) {
                break;
              }
            }
LABEL_406:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v233) {
              goto LABEL_602;
            }
          }
          unsigned int v234 = v235 >> 8;
LABEL_400:
          unint64_t v236 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v234);
          if (BYTE4(v236))
          {
            unsigned int v243 = v236;
            unint64_t v244 = HIDWORD(v236);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v245 = PDAdarkenPDA_5704(*v33, *v30, v236, BYTE4(v236), v237, v238, v239, v240, v241, v242);
                unsigned int v243 = v245;
                unint64_t v244 = HIDWORD(v245);
              }
              *long long v33 = v243;
              *long long v30 = v244;
            }
            else
            {
              *long long v33 = PDAdarkenPDA_5704(*v33, 0xFFu, v236, BYTE4(v236), v237, v238, v239, v240, v241, v242);
            }
          }
          goto LABEL_406;
        case 17:
          int v246 = v43;
          uint64_t v208 = v42;
          int v247 = v246;
          while (1)
          {
            unsigned int v248 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_413;
              }
              unsigned int v249 = *v208 * v248 + ((*v208 * v248) >> 8) + 1;
              if (BYTE1(v249)) {
                break;
              }
            }
LABEL_419:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v247) {
              goto LABEL_602;
            }
          }
          unsigned int v248 = v249 >> 8;
LABEL_413:
          unint64_t v250 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v248);
          if (BYTE4(v250))
          {
            unsigned int v257 = v250;
            unint64_t v258 = HIDWORD(v250);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v259 = PDAlightenPDA_5703(*v33, *v30, v250, BYTE4(v250), v251, v252, v253, v254, v255, v256);
                unsigned int v257 = v259;
                unint64_t v258 = HIDWORD(v259);
              }
              *long long v33 = v257;
              *long long v30 = v258;
            }
            else
            {
              *long long v33 = PDAlightenPDA_5703(*v33, 0xFFu, v250, BYTE4(v250), v251, v252, v253, v254, v255, v256);
            }
          }
          goto LABEL_419;
        case 18:
          int v260 = v43;
          uint64_t v208 = v42;
          int v261 = v260;
          while (1)
          {
            unsigned int v262 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_426;
              }
              unsigned int v263 = *v208 * v262 + ((*v208 * v262) >> 8) + 1;
              if (BYTE1(v263)) {
                break;
              }
            }
LABEL_432:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v261) {
              goto LABEL_602;
            }
          }
          unsigned int v262 = v263 >> 8;
LABEL_426:
          unint64_t v264 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v262);
          if (BYTE4(v264))
          {
            unsigned int v265 = v264;
            unint64_t v266 = HIDWORD(v264);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v267 = PDAcolordodgePDA_5705(*v33, *v30, v264, BYTE4(v264));
                unsigned int v265 = v267;
                unint64_t v266 = HIDWORD(v267);
              }
              *long long v33 = v265;
              *long long v30 = v266;
            }
            else
            {
              *long long v33 = PDAcolordodgePDA_5705(*v33, 255, v264, BYTE4(v264));
            }
          }
          goto LABEL_432;
        case 19:
          int v268 = v43;
          uint64_t v208 = v42;
          int v269 = v268;
          while (1)
          {
            unsigned int v270 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_439;
              }
              unsigned int v271 = *v208 * v270 + ((*v208 * v270) >> 8) + 1;
              if (BYTE1(v271)) {
                break;
              }
            }
LABEL_445:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v269) {
              goto LABEL_602;
            }
          }
          unsigned int v270 = v271 >> 8;
LABEL_439:
          unint64_t v272 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v270);
          if (BYTE4(v272))
          {
            unsigned int v273 = v272;
            unint64_t v274 = HIDWORD(v272);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v275 = PDAcolorburnPDA_5706(*v33, *v30, v272, BYTE4(v272));
                unsigned int v273 = v275;
                unint64_t v274 = HIDWORD(v275);
              }
              *long long v33 = v273;
              *long long v30 = v274;
            }
            else
            {
              *long long v33 = PDAcolorburnPDA_5706(*v33, 255, v272, BYTE4(v272));
            }
          }
          goto LABEL_445;
        case 20:
          int v276 = v43;
          uint64_t v208 = v42;
          int v277 = v276;
          while (1)
          {
            unsigned int v278 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_452;
              }
              unsigned int v279 = *v208 * v278 + ((*v208 * v278) >> 8) + 1;
              if (BYTE1(v279)) {
                break;
              }
            }
LABEL_458:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v277) {
              goto LABEL_602;
            }
          }
          unsigned int v278 = v279 >> 8;
LABEL_452:
          unint64_t v280 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v278);
          if (BYTE4(v280))
          {
            unsigned int v281 = v280;
            unint64_t v282 = HIDWORD(v280);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v283 = PDAsoftlightPDA_5708(*v33, *v30, v280, BYTE4(v280));
                unsigned int v281 = v283;
                unint64_t v282 = HIDWORD(v283);
              }
              *long long v33 = v281;
              *long long v30 = v282;
            }
            else
            {
              *long long v33 = PDAsoftlightPDA_5708(*v33, 255, v280, BYTE4(v280));
            }
          }
          goto LABEL_458;
        case 21:
          int v284 = v43;
          uint64_t v208 = v42;
          int v285 = v284;
          while (1)
          {
            unsigned int v286 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_465;
              }
              unsigned int v287 = *v208 * v286 + ((*v208 * v286) >> 8) + 1;
              if (BYTE1(v287)) {
                break;
              }
            }
LABEL_471:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v285) {
              goto LABEL_602;
            }
          }
          unsigned int v286 = v287 >> 8;
LABEL_465:
          unint64_t v288 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v286);
          if (BYTE4(v288))
          {
            unsigned int v289 = v288;
            unint64_t v290 = HIDWORD(v288);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v291 = PDAhardlightPDA_5707(*v33, *v30, v288, BYTE4(v288));
                unsigned int v289 = v291;
                unint64_t v290 = HIDWORD(v291);
              }
              *long long v33 = v289;
              *long long v30 = v290;
            }
            else
            {
              *long long v33 = PDAhardlightPDA_5707(*v33, 255, v288, BYTE4(v288));
            }
          }
          goto LABEL_471;
        case 22:
          int v292 = v43;
          uint64_t v208 = v42;
          int v293 = v292;
          while (1)
          {
            unsigned int v294 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_478;
              }
              unsigned int v295 = *v208 * v294 + ((*v208 * v294) >> 8) + 1;
              if (BYTE1(v295)) {
                break;
              }
            }
LABEL_484:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v293) {
              goto LABEL_602;
            }
          }
          unsigned int v294 = v295 >> 8;
LABEL_478:
          unint64_t v296 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v294);
          if (BYTE4(v296))
          {
            unsigned int v297 = v296;
            unint64_t v298 = HIDWORD(v296);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v299 = PDAdifferencePDA_5709(*v33, *v30, v296, BYTE4(v296));
                unsigned int v297 = v299;
                unint64_t v298 = HIDWORD(v299);
              }
              *long long v33 = v297;
              *long long v30 = v298;
            }
            else
            {
              *long long v33 = PDAdifferencePDA_5709(*v33, 0xFFu, v296, BYTE4(v296));
            }
          }
          goto LABEL_484;
        case 23:
          int v300 = v43;
          uint64_t v208 = v42;
          int v301 = v300;
          while (1)
          {
            unsigned int v302 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_491;
              }
              unsigned int v303 = *v208 * v302 + ((*v208 * v302) >> 8) + 1;
              if (BYTE1(v303)) {
                break;
              }
            }
LABEL_497:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v301) {
              goto LABEL_602;
            }
          }
          unsigned int v302 = v303 >> 8;
LABEL_491:
          unint64_t v304 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v302);
          if (BYTE4(v304))
          {
            unsigned int v305 = v304;
            unint64_t v306 = HIDWORD(v304);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v307 = PDAexclusionPDA_5710(*v33, *v30, v304, BYTE4(v304));
                unsigned int v305 = v307;
                unint64_t v306 = HIDWORD(v307);
              }
              *long long v33 = v305;
              *long long v30 = v306;
            }
            else
            {
              *long long v33 = PDAexclusionPDA_5710(*v33, 255, v304, BYTE4(v304));
            }
          }
          goto LABEL_497;
        case 24:
          int v308 = v43;
          uint64_t v208 = v42;
          int v309 = v308;
          while (1)
          {
            unsigned int v310 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_504;
              }
              unsigned int v311 = *v208 * v310 + ((*v208 * v310) >> 8) + 1;
              if (BYTE1(v311)) {
                break;
              }
            }
LABEL_510:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v309) {
              goto LABEL_602;
            }
          }
          unsigned int v310 = v311 >> 8;
LABEL_504:
          unint64_t v312 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v310);
          if (BYTE4(v312))
          {
            unsigned int v313 = v312;
            unint64_t v314 = HIDWORD(v312);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v315 = PDAhuePDA_5711(*v33, *v30, v312, BYTE4(v312));
                unsigned int v313 = v315;
                unint64_t v314 = HIDWORD(v315);
              }
              *long long v33 = v313;
              *long long v30 = v314;
            }
            else
            {
              *long long v33 = PDAhuePDA_5711(*v33, 255, v312, BYTE4(v312));
            }
          }
          goto LABEL_510;
        case 25:
          int v316 = v43;
          uint64_t v208 = v42;
          int v317 = v316;
          while (1)
          {
            unsigned int v318 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_517;
              }
              unsigned int v319 = *v208 * v318 + ((*v208 * v318) >> 8) + 1;
              if (BYTE1(v319)) {
                break;
              }
            }
LABEL_523:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v317) {
              goto LABEL_602;
            }
          }
          unsigned int v318 = v319 >> 8;
LABEL_517:
          unint64_t v320 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v318);
          if (BYTE4(v320))
          {
            unsigned int v321 = v320;
            unint64_t v322 = HIDWORD(v320);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v323 = PDAsaturationPDA_5712(*v33, *v30, v320, BYTE4(v320));
                unsigned int v321 = v323;
                unint64_t v322 = HIDWORD(v323);
              }
              *long long v33 = v321;
              *long long v30 = v322;
            }
            else
            {
              *long long v33 = PDAsaturationPDA_5712(*v33, 255, v320, BYTE4(v320));
            }
          }
          goto LABEL_523;
        case 26:
          int v324 = v43;
          uint64_t v208 = v42;
          int v325 = v324;
          while (1)
          {
            unsigned int v326 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_530;
              }
              unsigned int v327 = *v208 * v326 + ((*v208 * v326) >> 8) + 1;
              if (BYTE1(v327)) {
                break;
              }
            }
LABEL_536:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v325) {
              goto LABEL_602;
            }
          }
          unsigned int v326 = v327 >> 8;
LABEL_530:
          unint64_t v328 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v326);
          if (BYTE4(v328))
          {
            unint64_t v329 = HIDWORD(v328);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v328 = PDAluminosityPDA_5713(v328, BYTE4(v328), *v33, *v30);
                unint64_t v329 = HIDWORD(v328);
              }
              *long long v33 = v328;
              *long long v30 = v329;
            }
            else
            {
              *long long v33 = PDAluminosityPDA_5713(v328, BYTE4(v328), *v33, 255);
            }
          }
          goto LABEL_536;
        case 27:
          int v330 = v43;
          uint64_t v208 = v42;
          int v331 = v330;
          while (1)
          {
            unsigned int v332 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_543;
              }
              unsigned int v333 = *v208 * v332 + ((*v208 * v332) >> 8) + 1;
              if (BYTE1(v333)) {
                break;
              }
            }
LABEL_549:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v331) {
              goto LABEL_602;
            }
          }
          unsigned int v332 = v333 >> 8;
LABEL_543:
          unint64_t v334 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v332);
          if (BYTE4(v334))
          {
            unsigned int v335 = v334;
            unint64_t v336 = HIDWORD(v334);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v337 = PDAluminosityPDA_5713(*v33, *v30, v334, BYTE4(v334));
                unsigned int v335 = v337;
                unint64_t v336 = HIDWORD(v337);
              }
              *long long v33 = v335;
              *long long v30 = v336;
            }
            else
            {
              *long long v33 = PDAluminosityPDA_5713(*v33, 255, v334, BYTE4(v334));
            }
          }
          goto LABEL_549;
        case 28:
          int v338 = v43;
          uint64_t v208 = v42;
          int v339 = v338;
          while (1)
          {
            unsigned int v340 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_556;
              }
              unsigned int v341 = *v208 * v340 + ((*v208 * v340) >> 8) + 1;
              if (BYTE1(v341)) {
                break;
              }
            }
LABEL_562:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v339) {
              goto LABEL_602;
            }
          }
          unsigned int v340 = v341 >> 8;
LABEL_556:
          unint64_t v342 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v340);
          if (BYTE4(v342))
          {
            unsigned int v343 = v342;
            unint64_t v344 = HIDWORD(v342);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v345 = PDAtranspose_huePDA(*v33, *v30, v342, BYTE4(v342));
                unsigned int v343 = v345;
                unint64_t v344 = HIDWORD(v345);
              }
              *long long v33 = v343;
              *long long v30 = v344;
            }
            else
            {
              *long long v33 = PDAtranspose_huePDA(*v33, 255, v342, BYTE4(v342));
            }
          }
          goto LABEL_562;
        case 29:
          int v346 = v43;
          uint64_t v208 = v42;
          int v347 = v346;
          while (1)
          {
            unsigned int v348 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_569;
              }
              unsigned int v349 = *v208 * v348 + ((*v208 * v348) >> 8) + 1;
              if (BYTE1(v349)) {
                break;
              }
            }
LABEL_575:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v347) {
              goto LABEL_602;
            }
          }
          unsigned int v348 = v349 >> 8;
LABEL_569:
          unint64_t v350 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v348);
          if (BYTE4(v350))
          {
            unsigned int v351 = v350;
            unint64_t v352 = HIDWORD(v350);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v353 = PDAtranspose_saturationPDA(*v33, *v30, v350, BYTE4(v350));
                unsigned int v351 = v353;
                unint64_t v352 = HIDWORD(v353);
              }
              *long long v33 = v351;
              *long long v30 = v352;
            }
            else
            {
              *long long v33 = PDAtranspose_saturationPDA(*v33, 255, v350, BYTE4(v350));
            }
          }
          goto LABEL_575;
        case 30:
          int v354 = v43;
          uint64_t v208 = v42;
          int v355 = v354;
          while (1)
          {
            unsigned int v356 = *v55;
            if (*v55)
            {
              if (!v42) {
                goto LABEL_582;
              }
              unsigned int v357 = *v208 * v356 + ((*v208 * v356) >> 8) + 1;
              if (BYTE1(v357)) {
                break;
              }
            }
LABEL_588:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v355) {
              goto LABEL_602;
            }
          }
          unsigned int v356 = v357 >> 8;
LABEL_582:
          unint64_t v358 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v356);
          if (BYTE4(v358))
          {
            unint64_t v359 = HIDWORD(v358);
            if (v27)
            {
              if (*v30)
              {
                unint64_t v358 = PDAtranspose_luminosityPDA(v358, BYTE4(v358), *v33, *v30);
                unint64_t v359 = HIDWORD(v358);
              }
              *long long v33 = v358;
              *long long v30 = v359;
            }
            else
            {
              *long long v33 = PDAtranspose_luminosityPDA(v358, BYTE4(v358), *v33, 255);
            }
          }
          goto LABEL_588;
        case 31:
          int v360 = v43;
          uint64_t v208 = v42;
          int v361 = v360;
          break;
        default:
          goto LABEL_605;
      }
      break;
    }
    while (1)
    {
      unsigned int v362 = *v55;
      if (*v55)
      {
        if (!v42) {
          goto LABEL_595;
        }
        unsigned int v363 = *v208 * v362 + ((*v208 * v362) >> 8) + 1;
        if (BYTE1(v363)) {
          break;
        }
      }
LABEL_601:
      ++v55;
      ++v54;
      v208 += v42 != 0;
      ++v33;
      v30 += v440;
      if (!--v361)
      {
LABEL_602:
        int v42 = &v208[v429];
LABEL_603:
        uint64_t v37 = v430;
        v33 += v431;
        v30 += v432;
LABEL_604:
        uint64_t v43 = v438;
        goto LABEL_605;
      }
    }
    unsigned int v362 = v363 >> 8;
LABEL_595:
    unint64_t v364 = PDAM_5699(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v362);
    if (BYTE4(v364))
    {
      unsigned int v365 = v364;
      unint64_t v366 = HIDWORD(v364);
      if (v27)
      {
        if (*v30)
        {
          unint64_t v367 = PDAtranspose_luminosityPDA(*v33, *v30, v364, BYTE4(v364));
          unsigned int v365 = v367;
          unint64_t v366 = HIDWORD(v367);
        }
        *long long v33 = v365;
        *long long v30 = v366;
      }
      else
      {
        *long long v33 = PDAtranspose_luminosityPDA(*v33, 255, v364, BYTE4(v364));
      }
    }
    goto LABEL_601;
  }
  uint64_t v416 = v32;
  shape_enum_clip_alloc((uint64_t)v17, v18, v8, 1, 1, 1, v34, v35, v438, v434);
  if (!v44) {
    goto LABEL_34;
  }
  float v436 = (void *)v44;
  LODWORD(v437) = 0;
  uint64_t v45 = (int)((v13 * v4 + 15) & 0xFFFFFFF0);
  if (!v13) {
    uint64_t v45 = 8 * v4;
  }
  uint64_t v46 = v422;
  uint64_t v429 = -v422;
  int v42 = (unsigned __int8 *)(v24 + v45 + 16);
  uint64_t v37 = v430;
  uint64_t v43 = v438;
  uint64_t v38 = v435;
  uint64_t v47 = v418;
LABEL_22:
  uint64_t v48 = v432 + v46;
  while (1)
  {
    while (1)
    {
      int v49 = *((_DWORD *)v42 - 4);
      int v40 = v437;
      int v50 = v49 - v437;
      if (v49 > (int)v437) {
        break;
      }
      if ((int)v437 < *((_DWORD *)v42 - 3) + v49)
      {
        uint64_t v31 = v422;
        uint64_t v32 = v416;
        uint64_t v39 = (uint64_t)v436;
        goto LABEL_38;
      }
      if (!shape_enum_clip_scan((uint64_t)v436, (_DWORD *)v42 - 4)) {
        goto LABEL_31;
      }
    }
    v434 -= v50;
    if (v434 < 1) {
      break;
    }
    v38 += *(void *)(v37 + 128) * v50;
    v47 += *(void *)(v37 + 136) * v50;
    v33 += v415 * v50;
    uint64_t v51 = v48 * v50;
    if (!v27) {
      uint64_t v51 = 0;
    }
    v30 += v51;
    LODWORD(v437) = v49;
  }
LABEL_31:
  unint64_t v52 = v436;
LABEL_32:
  if (v52) {
    free(v52);
  }
LABEL_34:
  if (v417) {
    free(v417);
  }
}

unint64_t PDAM_5699(unsigned int a1, int a2, int a3)
{
  return (((a1 & 0xFF00FF) * a3 + 65537 + ((((a1 & 0xFF00FF) * a3) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((a1 >> 8) & 0xFF00FF) * a3 + 65537 + (((((a1 >> 8) & 0xFF00FF) * a3) >> 8) & 0xFF00FF)) & 0xFF00FF00 | ((unint64_t)((a3 * a2 + ((a3 * a2) >> 8) + 1) >> 8) << 32);
}

unsigned int *DAMplusDAM(unsigned int *result, unsigned char *a2, unsigned int a3, int a4, int a5, unsigned int a6, int a7, int a8)
{
  unsigned int v8 = ((a3 >> 8) & 0xFF00FF) * a5 + ((a6 >> 8) & 0xFF00FF) * a8;
  unsigned int v9 = (a3 & 0xFF00FF) * a5 + (a6 & 0xFF00FF) * a8;
  *a2 = (unsigned __int16)(a5 * a4 + a8 * a7 + ((a5 * a4 + a8 * a7) >> 8) + 1) >> 8;
  *uint64_t result = ((v9 + 65537 + ((v9 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v8 + 65537 + ((v8 >> 8) & 0xFF00FF)) & 0xFF00FF00;
  return result;
}

unsigned int *DMplusDM(unsigned int *result, unsigned int a2, int a3, unsigned int a4, int a5)
{
  unsigned int v5 = ((a2 >> 8) & 0xFF00FF) * a3 + ((a4 >> 8) & 0xFF00FF) * a5;
  unsigned int v6 = (a2 & 0xFF00FF) * a3 + (a4 & 0xFF00FF) * a5;
  *uint64_t result = ((v6 + 65537 + ((v6 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v5 + 65537 + ((v5 >> 8) & 0xFF00FF)) & 0xFF00FF00;
  return result;
}

_DWORD *DAplusDAM(_DWORD *result, unsigned char *a2, int a3, char a4, unsigned int a5, int a6, int a7)
{
  *a2 = a4 + ((unsigned __int16)(a7 * a6 + ((a7 * a6) >> 8) + 1) >> 8);
  *uint64_t result = ((((a5 >> 8) & 0xFF00FF) * a7 + 65537 + (((((a5 >> 8) & 0xFF00FF) * a7) >> 8) & 0xFF00FF)) & 0xFF00FF00)
          + a3
          + ((((a5 & 0xFF00FF) * a7 + 65537 + ((((a5 & 0xFF00FF) * a7) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
  return result;
}

_DWORD *DAplusdDA(_DWORD *result, unsigned char *a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6 = ((a4 << 16) | (a4 << 24) | (((a4 << 16) | (a4 << 24)) >> 16)) - a3;
  unsigned int v7 = ((a6 << 16) | (a6 << 24) | (((a6 << 16) | (a6 << 24)) >> 16)) - a5;
  int v8 = ((v7 >> 8) & 0xFF00FF) + ((v6 >> 8) & 0xFF00FF);
  unsigned int v9 = (v7 & 0xFF00FF) + (v6 & 0xFF00FF);
  int v10 = v8 & 0x1000100 | (v9 >> 8) & 0x10001;
  int v11 = a6 + a4;
  int v12 = 15 * v10;
  int v13 = 240 * v10;
  if ((a6 + a4) > 0xFF) {
    int v11 = -1;
  }
  HIDWORD(v14) = v11;
  LODWORD(v14) = v11 << 24;
  *a2 = v11;
  *uint64_t result = ((v14 >> 8) | ((v14 >> 8) >> 16)) - ((v8 << 8) & 0xFF00FF00 | v9 & 0xFF00FF | v12 | v13);
  return result;
}

unsigned int *DplusdDA(unsigned int *result, int a2, int a3, int a4)
{
  unsigned int v4 = ((a4 << 16) | (a4 << 24) | (((a4 << 16) | (a4 << 24)) >> 16)) - a3;
  unsigned int v5 = ((v4 >> 8) & 0xFF00FF) + ((~a2 >> 8) & 0xFF00FF);
  *uint64_t result = ~((v5 << 8) & 0xFF00FF00 | ((v4 & 0xFF00FF) + (~a2 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                        * (v5 & 0x1000100 | (((v4 & 0xFF00FF) + (~a2 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v5 & 0x1000100 | (((v4 & 0xFF00FF) + (~a2 & 0xFF00FF)) >> 8) & 0x10001)));
  return result;
}

unint64_t PDAmultiplyPDA_5700(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = a2 - HIBYTE(a1);
  int v5 = a2 - BYTE2(a1);
  int v6 = a2 - BYTE1(a1);
  int v7 = a2 - a1;
  int v8 = a4 - HIBYTE(a3);
  int v9 = a4 - BYTE2(a3);
  int v10 = a4 - BYTE1(a3);
  int v11 = a4 - a3;
  int v12 = v8 + (a4 ^ 0xFF);
  int v13 = v9 + (a4 ^ 0xFF);
  int v14 = v10 + (a4 ^ 0xFF);
  int v15 = v11 + (a4 ^ 0xFF);
  if (a4 == 255)
  {
    int v12 = v8;
    int v13 = v9;
    int v14 = v10;
    int v15 = v11;
  }
  int v16 = v15 * v7;
  int v17 = v14 * v6;
  int v18 = v13 * v5;
  int v19 = v12 * v4;
  int v20 = v19 + v8 * (a2 ^ 0xFF);
  int v21 = v18 + v9 * (a2 ^ 0xFF);
  int v22 = v17 + v10 * (a2 ^ 0xFF);
  int v23 = v16 + v11 * (a2 ^ 0xFF);
  if (a2 != 255)
  {
    int v19 = v20;
    int v18 = v21;
    int v17 = v22;
    int v16 = v23;
  }
  int v24 = 255 * (a4 + a2) - a4 * a2;
  if (v19 >= 65152) {
    unsigned int v25 = 65152;
  }
  else {
    unsigned int v25 = v19 + 128;
  }
  unsigned int v26 = v25 + (v25 >> 8);
  if (v18 >= 65152) {
    unsigned int v27 = 65152;
  }
  else {
    unsigned int v27 = v18 + 128;
  }
  unsigned int v28 = v27 + (v27 >> 8);
  if (v17 >= 65152) {
    unsigned int v29 = 65152;
  }
  else {
    unsigned int v29 = v17 + 128;
  }
  unsigned int v30 = v29 + (v29 >> 8);
  if (v16 >= 65152) {
    unsigned int v31 = 65152;
  }
  else {
    unsigned int v31 = v16 + 128;
  }
  unsigned int v32 = v31 + (v31 >> 8);
  if (v24 >= 65152) {
    int v33 = 65152;
  }
  else {
    int v33 = v24 + 128;
  }
  int v34 = (v33 + (v33 >> 8)) >> 8;
  return ((v34 - (v26 >> 8)) << 24) | ((v34 - BYTE1(v28)) << 16) | ((v34 - BYTE1(v30)) << 8) | (v34 - BYTE1(v32)) | ((unint64_t)v34 << 32);
}

unint64_t PDAscreenPDA_5701(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int32x2_t v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  int8x8_t v5 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
  int v6 = HIBYTE(a1) - a2 + (a4 - HIBYTE(a3)) * (255 - (a2 - HIBYTE(a1))) + ((a2 - HIBYTE(a1)) << 8);
  int v7 = a1
     - a2
     + (a4 - a3) * (255 - (a2 - a1))
     + ((a2 - a1) << 8);
  int v8 = 255 * (a4 + a2) - a4 * a2;
  if (v6 >= 65152) {
    unsigned int v9 = 65152;
  }
  else {
    unsigned int v9 = v6 + 128;
  }
  unsigned int v10 = v9 + (v9 >> 8);
  if (v7 >= 65152) {
    unsigned int v11 = 65152;
  }
  else {
    unsigned int v11 = v7 + 128;
  }
  unsigned int v12 = v11 + (v11 >> 8);
  if (v8 >= 65152) {
    int v13 = 65152;
  }
  else {
    int v13 = v8 + 128;
  }
  unsigned int v14 = (v13 + (v13 >> 8)) >> 8;
  int32x2_t v15 = vsub_s32(vdup_n_s32(a2), v4);
  int32x2_t v16 = vmla_s32(vmul_s32(v15, (int32x2_t)0xFF000000FFLL), vsub_s32(vdup_n_s32(a4), (int32x2_t)vand_s8(v5, (int8x8_t)0xFF000000FFLL)), vsub_s32((int32x2_t)0xFF000000FFLL, v15));
  int32x2_t v17 = vdup_n_s32(0xFE80u);
  uint32x2_t v18 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v17, v16), (int8x8_t)vadd_s32(v16, (int32x2_t)0x8000000080), (int8x8_t)v17);
  int8x8_t v19 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v14), (int32x2_t)vshr_n_u32(vsra_n_u32(v18, v18, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v19.i32[0] | ((v14 - (v10 >> 8)) << 24) | (v14 - BYTE1(v12)) | v19.i32[1] | ((unint64_t)v14 << 32);
}

unint64_t PDAoverlayPDA_5702(unsigned int a1, signed int a2, unsigned int a3, int a4)
{
  signed int v4 = a2 - BYTE1(a1);
  signed int v5 = a2 - a1;
  int v6 = a4 - BYTE2(a3);
  int v7 = a4 - BYTE1(a3);
  int v8 = a4 - a3;
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    int v9 = a4;
  }
  else {
    int v9 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    signed int v10 = a2;
  }
  else {
    signed int v10 = a2 - HIBYTE(a1);
  }
  int v11 = 2 * v10 * v9;
  if (v6 >= a4) {
    int v12 = a4;
  }
  else {
    int v12 = v6;
  }
  if (a2 - BYTE2(a1) >= a2) {
    signed int v13 = a2;
  }
  else {
    signed int v13 = a2 - BYTE2(a1);
  }
  int v14 = 2 * v13 * v12;
  if (v7 >= a4) {
    int v15 = a4;
  }
  else {
    int v15 = v7;
  }
  if (v4 >= a2) {
    signed int v16 = a2;
  }
  else {
    signed int v16 = v4;
  }
  int v17 = 2 * v16 * v15;
  if (v8 >= a4) {
    int v18 = a4;
  }
  else {
    int v18 = v8;
  }
  if (v5 >= a2) {
    signed int v19 = a2;
  }
  else {
    signed int v19 = v5;
  }
  int v20 = 2 * v19 * v18;
  int v21 = a4 * a2;
  signed int v22 = (a2 + 1) >> 1;
  if (v10 >= v22) {
    int v23 = v9 * (a2 + 255) + (a4 + 255) * v10 - (v21 + v11);
  }
  else {
    int v23 = (a4 ^ 0xFF) * v10 + v9 * (a2 ^ 0xFF) + v11;
  }
  int v24 = a4 + 255;
  int v25 = a2 + 255;
  int v26 = v12 * (a2 + 255) + (a4 + 255) * v13 - (v21 + v14);
  int v27 = a4 ^ 0xFF;
  int v28 = a2 ^ 0xFF;
  int v29 = (a4 ^ 0xFF) * v13 + v12 * (a2 ^ 0xFF) + v14;
  if (v13 >= v22) {
    int v29 = v26;
  }
  int v30 = v15 * v25 + v24 * v16 - (v21 + v17);
  int v31 = v27 * v16 + v15 * v28 + v17;
  if (v16 >= v22) {
    int v31 = v30;
  }
  int v32 = v18 * v25 + v24 * v19 - (v21 + v20);
  int v33 = v27 * v19 + v18 * v28 + v20;
  if (v19 >= v22) {
    int v33 = v32;
  }
  int v34 = 255 * (a4 + a2) - v21;
  unsigned int v35 = v23 + 128;
  if (v23 >= 65152) {
    unsigned int v35 = 65152;
  }
  unsigned int v36 = v35 + (v35 >> 8);
  int8x8_t v37 = (int8x8_t)vadd_s32((int32x2_t)__PAIR64__(v29, v31), (int32x2_t)0x8000000080);
  int32x2_t v38 = vdup_n_s32(0xFE80u);
  int8x8_t v39 = (int8x8_t)vcgt_s32(v38, (int32x2_t)__PAIR64__(v29, v31));
  if (v33 >= 65152) {
    unsigned int v40 = 65152;
  }
  else {
    unsigned int v40 = v33 + 128;
  }
  unsigned int v41 = v40 + (v40 >> 8);
  if (v34 >= 65152) {
    int v42 = 65152;
  }
  else {
    int v42 = v34 + 128;
  }
  unsigned int v43 = (v42 + (v42 >> 8)) >> 8;
  uint32x2_t v44 = (uint32x2_t)vbsl_s8(v39, v37, (int8x8_t)v38);
  int8x8_t v45 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v43), (int32x2_t)vshr_n_u32(vsra_n_u32(v44, v44, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return (v43 - BYTE1(v41)) | v45.i32[0] | v45.i32[1] | ((v43 - (v36 >> 8)) << 24) | ((unint64_t)v43 << 32);
}

unint64_t PDAlightenPDA_5703(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, double a5, int8x16_t a6, double a7, double a8, double a9, int8x16_t a10)
{
  a6.i32[0] = a1;
  a6.i32[1] = a1 >> 8;
  a6.i32[2] = HIWORD(a1);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  int32x4_t v11 = (int32x4_t)vandq_s8(a6, v10);
  v11.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a1), (uint32x4_t)xmmword_1850CDBB0).i32[3];
  int32x4_t v12 = vdupq_n_s32(a2);
  int32x4_t v13 = vsubq_s32(v12, v11);
  a10.i32[0] = a3;
  a10.i32[1] = a3 >> 8;
  a10.i32[2] = HIWORD(a3);
  int32x4_t v14 = (int32x4_t)vandq_s8(a10, v10);
  v14.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a3), (uint32x4_t)xmmword_1850CDBB0).i32[3];
  int32x4_t v15 = vdupq_n_s32(a4);
  int32x4_t v16 = vminq_s32(vsubq_s32(v15, v14), v15);
  int32x4_t v17 = vminq_s32(v13, v12);
  int32x4_t v18 = vmaxq_s32(vmulq_s32(v16, v12), vmulq_s32(v17, v15));
  if (a4 != 255) {
    int32x4_t v18 = vmlaq_s32(v18, vdupq_n_s32(a4 ^ 0xFF), v17);
  }
  if (a2 != 255) {
    int32x4_t v18 = vmlaq_s32(v18, v16, vdupq_n_s32(a2 ^ 0xFF));
  }
  int v19 = 255 * (a4 + a2) - a4 * a2;
  if (v18.i32[3] >= 65152) {
    unsigned int v20 = 65152;
  }
  else {
    unsigned int v20 = v18.i32[3] + 128;
  }
  unsigned int v21 = v20 + (v20 >> 8);
  if (v18.i32[0] >= 65152) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v18.i32[0] + 128;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v19 >= 65152) {
    int v24 = 65152;
  }
  else {
    int v24 = v19 + 128;
  }
  unsigned int v25 = (v24 + (v24 >> 8)) >> 8;
  v18.i32[0] = vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL).u32[0];
  int32x2_t v26 = vdup_n_s32(0xFE80u);
  uint32x2_t v27 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v26, *(int32x2_t *)v18.i8), (int8x8_t)vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x8000000080), (int8x8_t)v26);
  int8x8_t v28 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v25), (int32x2_t)vshr_n_u32(vsra_n_u32(v27, v27, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v28.i32[0] | ((v25 - (v21 >> 8)) << 24) | (v25 - BYTE1(v23)) | v28.i32[1] | ((unint64_t)v25 << 32);
}

unint64_t PDAdarkenPDA_5704(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, double a5, int8x16_t a6, double a7, double a8, double a9, int8x16_t a10)
{
  a6.i32[0] = a1;
  a6.i32[1] = a1 >> 8;
  a6.i32[2] = HIWORD(a1);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  int32x4_t v11 = (int32x4_t)vandq_s8(a6, v10);
  v11.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a1), (uint32x4_t)xmmword_1850CDBB0).i32[3];
  int32x4_t v12 = vdupq_n_s32(a2);
  int32x4_t v13 = vsubq_s32(v12, v11);
  a10.i32[0] = a3;
  a10.i32[1] = a3 >> 8;
  a10.i32[2] = HIWORD(a3);
  int32x4_t v14 = (int32x4_t)vandq_s8(a10, v10);
  v14.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a3), (uint32x4_t)xmmword_1850CDBB0).i32[3];
  int32x4_t v15 = vdupq_n_s32(a4);
  int32x4_t v16 = vminq_s32(vsubq_s32(v15, v14), v15);
  int32x4_t v17 = vminq_s32(v13, v12);
  int32x4_t v18 = vminq_s32(vmulq_s32(v16, v12), vmulq_s32(v17, v15));
  if (a4 != 255) {
    int32x4_t v18 = vmlaq_s32(v18, vdupq_n_s32(a4 ^ 0xFF), v17);
  }
  if (a2 != 255) {
    int32x4_t v18 = vmlaq_s32(v18, v16, vdupq_n_s32(a2 ^ 0xFF));
  }
  int v19 = 255 * (a4 + a2) - a4 * a2;
  if (v18.i32[3] >= 65152) {
    unsigned int v20 = 65152;
  }
  else {
    unsigned int v20 = v18.i32[3] + 128;
  }
  unsigned int v21 = v20 + (v20 >> 8);
  if (v18.i32[0] >= 65152) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v18.i32[0] + 128;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v19 >= 65152) {
    int v24 = 65152;
  }
  else {
    int v24 = v19 + 128;
  }
  unsigned int v25 = (v24 + (v24 >> 8)) >> 8;
  v18.i32[0] = vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL).u32[0];
  int32x2_t v26 = vdup_n_s32(0xFE80u);
  uint32x2_t v27 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v26, *(int32x2_t *)v18.i8), (int8x8_t)vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x8000000080), (int8x8_t)v26);
  int8x8_t v28 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v25), (int32x2_t)vshr_n_u32(vsra_n_u32(v27, v27, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v28.i32[0] | ((v25 - (v21 >> 8)) << 24) | (v25 - BYTE1(v23)) | v28.i32[1] | ((unint64_t)v25 << 32);
}

unint64_t PDAcolordodgePDA_5705(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = a2 - HIBYTE(a1);
  int v5 = a2 - BYTE2(a1);
  int v6 = a4 * a4;
  if (v4 >= a2) {
    int v4 = a2;
  }
  if (v4)
  {
    if (HIBYTE(a3)) {
      int v7 = v6 * v4 / (int)HIBYTE(a3);
    }
    else {
      int v7 = 65025;
    }
  }
  else
  {
    int v7 = 0;
  }
  int v8 = a2 - BYTE1(a1);
  if (v5 >= a2) {
    int v5 = a2;
  }
  if (v5)
  {
    if (BYTE2(a3)) {
      int v9 = v6 * v5 / BYTE2(a3);
    }
    else {
      int v9 = 65025;
    }
  }
  else
  {
    int v9 = 0;
  }
  int v10 = a2 - a1;
  if (v8 >= a2) {
    int v8 = a2;
  }
  if (v8)
  {
    if (BYTE1(a3)) {
      int v11 = v6 * v8 / BYTE1(a3);
    }
    else {
      int v11 = 65025;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (v10 >= a2) {
    int v12 = a2;
  }
  else {
    int v12 = v10;
  }
  if (v12)
  {
    if ((_BYTE)a3) {
      int v13 = v6 * v12 / a3;
    }
    else {
      int v13 = 65025;
    }
  }
  else
  {
    int v13 = 0;
  }
  int v14 = v7 + (a4 ^ 0xFF) * v4;
  int v15 = v9 + (a4 ^ 0xFF) * v5;
  int v16 = v11 + (a4 ^ 0xFF) * v8;
  if (a4 == 255) {
    int v16 = v11;
  }
  else {
    v13 += (a4 ^ 0xFF) * v12;
  }
  if (a4 == 255)
  {
    int v15 = v9;
    int v14 = v7;
  }
  int v17 = v13 + (a4 - a3) * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    int v17 = v13;
    int v18 = v16;
  }
  else
  {
    int v18 = v16 + (a4 - BYTE1(a3)) * (a2 ^ 0xFF);
  }
  if (a2 != 255)
  {
    v15 += (a4 - BYTE2(a3)) * (a2 ^ 0xFF);
    v14 += (a4 - HIBYTE(a3)) * (a2 ^ 0xFF);
  }
  int v19 = 255 * (a4 + a2) - a4 * a2;
  if (v14 >= v19) {
    int v14 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v15 >= v19) {
    int v15 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v18 >= v19) {
    int v18 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v17 >= v19) {
    int v17 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v18 >= 65152) {
    unsigned int v20 = 65152;
  }
  else {
    unsigned int v20 = v18 + 128;
  }
  unsigned int v21 = v20 + (v20 >> 8);
  if (v15 >= 65152) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v15 + 128;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v14 >= 65152) {
    unsigned int v24 = 65152;
  }
  else {
    unsigned int v24 = v14 + 128;
  }
  unsigned int v25 = v24 + (v24 >> 8);
  if (v17 >= 65152) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v17 + 128;
  }
  unsigned int v27 = v26 + (v26 >> 8);
  if (v19 >= 65152) {
    int v28 = 65152;
  }
  else {
    int v28 = v19 + 128;
  }
  int v29 = (v28 + (v28 >> 8)) >> 8;
  return ((v29 - BYTE1(v23)) << 16) | ((v29 - (v25 >> 8)) << 24) | ((v29 - BYTE1(v21)) << 8) | (v29 - BYTE1(v27)) | ((unint64_t)v29 << 32);
}

unint64_t PDAcolorburnPDA_5706(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = a4 - BYTE2(a3);
  int v5 = a4 - BYTE1(a3);
  int v6 = a4 - a3;
  int v7 = a4 * a2;
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    int v8 = a4;
  }
  else {
    int v8 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    int v9 = a2;
  }
  else {
    int v9 = a2 - HIBYTE(a1);
  }
  if (v4 >= a4) {
    int v10 = a4;
  }
  else {
    int v10 = v4;
  }
  if (a2 - BYTE2(a1) >= a2) {
    int v11 = a2;
  }
  else {
    int v11 = a2 - BYTE2(a1);
  }
  if (v5 >= a4) {
    int v12 = a4;
  }
  else {
    int v12 = v5;
  }
  if (a2 - BYTE1(a1) >= a2) {
    int v13 = a2;
  }
  else {
    int v13 = a2 - BYTE1(a1);
  }
  if (v6 >= a4) {
    int v14 = a4;
  }
  else {
    int v14 = v6;
  }
  if (a2 - a1 >= a2) {
    int v15 = a2;
  }
  else {
    int v15 = a2 - a1;
  }
  int v16 = v7 + (a4 ^ 0xFF) * v13;
  int v17 = v7 + (a4 ^ 0xFF) * v15;
  if (a4 == 255)
  {
    int v17 = a4 * a2;
    int v16 = 255 * a2;
    int v18 = 255 * a2;
  }
  else
  {
    int v18 = v7 + (a4 ^ 0xFF) * v11;
  }
  if (a4 == 255) {
    int v19 = 255 * a2;
  }
  else {
    int v19 = v7 + (a4 ^ 0xFF) * v9;
  }
  if (a2 == 255) {
    int v20 = v17;
  }
  else {
    int v20 = v17 + v14 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    int v21 = v16;
  }
  else {
    int v21 = v16 + v12 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    int v22 = v18;
  }
  else {
    int v22 = v18 + v10 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    int v23 = v19;
  }
  else {
    int v23 = v19 + v8 * (a2 ^ 0xFF);
  }
  int v24 = a2 - v9;
  int v25 = a4 * a4;
  int v26 = (v23 - v25 * v24 / v8) & ~((v23 - v25 * v24 / v8) >> 31);
  if (v8) {
    int v27 = v26;
  }
  else {
    int v27 = 0;
  }
  if (HIBYTE(a1)) {
    int v23 = v27;
  }
  if (BYTE2(a1))
  {
    if (v10) {
      int v22 = (v22 - v25 * (a2 - v11) / v10) & ~((v22 - v25 * (a2 - v11) / v10) >> 31);
    }
    else {
      int v22 = 0;
    }
  }
  if (BYTE1(a1))
  {
    if (v12) {
      int v21 = (v21 - v25 * (a2 - v13) / v12) & ~((v21 - v25 * (a2 - v13) / v12) >> 31);
    }
    else {
      int v21 = 0;
    }
  }
  if (v14) {
    int v28 = (v20 - v25 * (a2 - v15) / v14) & ~((v20 - v25 * (a2 - v15) / v14) >> 31);
  }
  else {
    int v28 = 0;
  }
  if (!(_BYTE)a1) {
    int v28 = v20;
  }
  int v29 = 255 * (a4 + a2) - v7;
  unsigned int v30 = v23 + 128;
  if (v23 >= 65152) {
    unsigned int v30 = 65152;
  }
  unsigned int v31 = v30 + (v30 >> 8);
  int8x8_t v32 = (int8x8_t)vadd_s32((int32x2_t)__PAIR64__(v22, v21), (int32x2_t)0x8000000080);
  int32x2_t v33 = vdup_n_s32(0xFE80u);
  int8x8_t v34 = (int8x8_t)vcgt_s32(v33, (int32x2_t)__PAIR64__(v22, v21));
  if (v28 >= 65152) {
    unsigned int v35 = 65152;
  }
  else {
    unsigned int v35 = v28 + 128;
  }
  unsigned int v36 = v35 + (v35 >> 8);
  if (v29 >= 65152) {
    int v37 = 65152;
  }
  else {
    int v37 = v29 + 128;
  }
  unsigned int v38 = (v37 + (v37 >> 8)) >> 8;
  uint32x2_t v39 = (uint32x2_t)vbsl_s8(v34, v32, (int8x8_t)v33);
  int8x8_t v40 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v38), (int32x2_t)vshr_n_u32(vsra_n_u32(v39, v39, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return (v38 - BYTE1(v36)) | v40.i32[0] | v40.i32[1] | ((v38 - (v31 >> 8)) << 24) | ((unint64_t)v38 << 32);
}

unint64_t PDAhardlightPDA_5707(unsigned int a1, int a2, unsigned int a3, signed int a4)
{
  int v4 = a2 - BYTE1(a1);
  int v5 = a2 - a1;
  signed int v6 = a4 - BYTE2(a3);
  signed int v7 = a4 - BYTE1(a3);
  signed int v8 = a4 - a3;
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    signed int v9 = a4;
  }
  else {
    signed int v9 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    int v10 = a2;
  }
  else {
    int v10 = a2 - HIBYTE(a1);
  }
  int v11 = 2 * v10 * v9;
  if (v6 >= a4) {
    signed int v6 = a4;
  }
  if (a2 - BYTE2(a1) >= a2) {
    int v12 = a2;
  }
  else {
    int v12 = a2 - BYTE2(a1);
  }
  int v13 = 2 * v12 * v6;
  if (v7 >= a4) {
    signed int v14 = a4;
  }
  else {
    signed int v14 = v7;
  }
  if (v4 >= a2) {
    int v15 = a2;
  }
  else {
    int v15 = v4;
  }
  int v16 = 2 * v15 * v14;
  if (v8 >= a4) {
    signed int v17 = a4;
  }
  else {
    signed int v17 = v8;
  }
  if (v5 >= a2) {
    int v18 = a2;
  }
  else {
    int v18 = v5;
  }
  int v19 = 2 * v18 * v17;
  int v20 = a4 * a2;
  signed int v21 = (a4 + 1) >> 1;
  if (v9 <= v21) {
    int v22 = (a4 ^ 0xFF) * v10 + v9 * (a2 ^ 0xFF) + v11;
  }
  else {
    int v22 = v9 * (a2 + 255) + (a4 + 255) * v10 - (v20 + v11);
  }
  int v23 = a4 ^ 0xFF;
  int v24 = a2 ^ 0xFF;
  int v25 = (a4 ^ 0xFF) * v12 + v6 * (a2 ^ 0xFF) + v13;
  int v26 = a4 + 255;
  int v27 = a2 + 255;
  int v28 = v6 * (a2 + 255) + (a4 + 255) * v12 - (v20 + v13);
  if (v6 > v21) {
    int v29 = v28;
  }
  else {
    int v29 = v25;
  }
  int v30 = v23 * v15 + v14 * v24 + v16;
  int v31 = v14 * v27 + v26 * v15 - (v20 + v16);
  if (v14 > v21) {
    int v32 = v31;
  }
  else {
    int v32 = v30;
  }
  int v33 = v23 * v18 + v17 * v24 + v19;
  int v34 = v17 * v27 + v26 * v18 - (v20 + v19);
  if (v17 > v21) {
    int v35 = v34;
  }
  else {
    int v35 = v33;
  }
  int v36 = 255 * (a4 + a2) - v20;
  unsigned int v37 = v22 + 128;
  if (v22 >= 65152) {
    unsigned int v37 = 65152;
  }
  unsigned int v38 = v37 + (v37 >> 8);
  int8x8_t v39 = (int8x8_t)vadd_s32((int32x2_t)__PAIR64__(v29, v32), (int32x2_t)0x8000000080);
  int32x2_t v40 = vdup_n_s32(0xFE80u);
  int8x8_t v41 = (int8x8_t)vcgt_s32(v40, (int32x2_t)__PAIR64__(v29, v32));
  if (v35 >= 65152) {
    unsigned int v42 = 65152;
  }
  else {
    unsigned int v42 = v35 + 128;
  }
  unsigned int v43 = v42 + (v42 >> 8);
  if (v36 >= 65152) {
    int v44 = 65152;
  }
  else {
    int v44 = v36 + 128;
  }
  unsigned int v45 = (v44 + (v44 >> 8)) >> 8;
  uint32x2_t v46 = (uint32x2_t)vbsl_s8(v41, v39, (int8x8_t)v40);
  int8x8_t v47 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v45), (int32x2_t)vshr_n_u32(vsra_n_u32(v46, v46, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return (v45 - BYTE1(v43)) | v47.i32[0] | v47.i32[1] | ((v45 - (v38 >> 8)) << 24) | ((unint64_t)v45 << 32);
}

unint64_t PDAsoftlightPDA_5708(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = a2 - HIBYTE(a1);
  int v5 = a4 - HIBYTE(a3);
  if (v5 >= a4) {
    int v5 = a4;
  }
  if (v4 >= a2) {
    int v4 = a2;
  }
  int v6 = a4 - a3;
  int v7 = a4 - BYTE1(a3);
  int v8 = a4 - BYTE2(a3);
  int v9 = a2 - a1;
  int v10 = a2 - BYTE1(a1);
  int v11 = a2 - BYTE2(a1);
  int v12 = v4 * v4 * (2 * v5 - a4) / a2;
  int v13 = (2 * v4 * v5 - v12) & ~((2 * v4 * v5 - v12) >> 31);
  if (v8 >= a4) {
    int v8 = a4;
  }
  if (v11 >= a2) {
    int v11 = a2;
  }
  int v14 = v11 * v11 * (2 * v8 - a4) / a2;
  int v15 = (2 * v11 * v8 - v14) & ~((2 * v11 * v8 - v14) >> 31);
  if (v7 >= a4) {
    int v7 = a4;
  }
  if (v10 >= a2) {
    int v10 = a2;
  }
  int v16 = v10 * v10 * (2 * v7 - a4) / a2;
  int v17 = (2 * v10 * v7 - v16) & ~((2 * v10 * v7 - v16) >> 31);
  if (v6 >= a4) {
    int v6 = a4;
  }
  if (v9 >= a2) {
    int v9 = a2;
  }
  int v18 = 2 * v9 * v6 - v9 * v9 * (2 * v6 - a4) / a2;
  int v19 = v18 & ~(v18 >> 31);
  int v20 = v13 + (a4 ^ 0xFF) * v4;
  int v21 = v15 + v11 * (a4 ^ 0xFF);
  int v22 = v17 + v10 * (a4 ^ 0xFF);
  int v23 = v19 + v9 * (a4 ^ 0xFF);
  if (a4 == 255)
  {
    int v23 = v19;
    int v22 = v17;
    int v21 = v15;
    int v20 = v13;
  }
  int v24 = v20 + v5 * (a2 ^ 0xFF);
  int v25 = v21 + v8 * (a2 ^ 0xFF);
  int v26 = v22 + v7 * (a2 ^ 0xFF);
  int v27 = v23 + v6 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    int v27 = v23;
    int v26 = v22;
    int v25 = v21;
    int v24 = v20;
  }
  int v28 = 255 * (a4 + a2) - a4 * a2;
  if (v24 >= 65152) {
    unsigned int v29 = 65152;
  }
  else {
    unsigned int v29 = v24 + 128;
  }
  unsigned int v30 = v29 + (v29 >> 8);
  if (v25 >= 65152) {
    unsigned int v31 = 65152;
  }
  else {
    unsigned int v31 = v25 + 128;
  }
  unsigned int v32 = v31 + (v31 >> 8);
  if (v26 >= 65152) {
    unsigned int v33 = 65152;
  }
  else {
    unsigned int v33 = v26 + 128;
  }
  unsigned int v34 = v33 + (v33 >> 8);
  if (v27 >= 65152) {
    unsigned int v35 = 65152;
  }
  else {
    unsigned int v35 = v27 + 128;
  }
  unsigned int v36 = v35 + (v35 >> 8);
  if (v28 >= 65152) {
    int v37 = 65152;
  }
  else {
    int v37 = v28 + 128;
  }
  int v38 = (v37 + (v37 >> 8)) >> 8;
  return ((v38 - BYTE1(v32)) << 16) | ((v38 - (v30 >> 8)) << 24) | ((v38 - BYTE1(v34)) << 8) | (v38 - BYTE1(v36)) | ((unint64_t)v38 << 32);
}

unint64_t PDAdifferencePDA_5709(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int32x2_t v4 = vdup_n_s32(a4);
  uint32x2_t v5 = (uint32x2_t)vdup_n_s32(a1);
  v6.i32[0] = a1;
  v6.i32[1] = vshl_u32(v5, (uint32x2_t)0xFFFFFFE8FFFFFF01).i32[1];
  uint32x2_t v7 = (uint32x2_t)vdup_n_s32(a3);
  v8.i32[0] = a3;
  v8.i32[1] = vshl_u32(v7, (uint32x2_t)0xFFFFFFE8FFFFFF01).i32[1];
  int32x2_t v9 = vmin_s32(vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32(v7, (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v4);
  int32x2_t v10 = vdup_n_s32(a2);
  int32x2_t v11 = vmin_s32(vsub_s32(v10, (int32x2_t)vand_s8((int8x8_t)vshl_u32(v5, (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v10);
  int32x2_t v12 = vmin_s32(vsub_s32(v4, v8), v4);
  int32x2_t v13 = vmin_s32(vsub_s32(v10, v6), v10);
  v4.i32[0] = v13.i32[0];
  v4.i32[1] = v12.i32[1];
  int32x2_t v14 = vmul_s32(v4, (int32x2_t)__PAIR64__(a2, a4));
  int32x2_t v15 = vrev64_s32((int32x2_t)__PAIR64__(a2, a4));
  int32x2_t v16 = vadd_s32(v9, v11);
  int32x2_t v17 = (int32x2_t)__PAIR64__(v11.u32[1], v9.u32[0]);
  v11.i32[1] = v9.i32[1];
  int32x2_t v18 = vmul_s32(v11, (int32x2_t)__PAIR64__(a2, a4));
  int32x2_t v19 = vadd_s32(v12, v13);
  v12.i32[1] = v13.i32[1];
  int32x2_t v20 = vmul_s32(v12, v15);
  v13.i32[0] = v20.i32[0];
  v13.i32[1] = v14.i32[1];
  int v21 = 255 * (a4 + a2) - a4 * a2;
  int32x2_t v22 = vneg_s32(v14);
  v14.i32[1] = v20.i32[1];
  int32x2_t v23 = vaba_s32(vsub_s32(vmla_s32(v22, v19, (int32x2_t)0xFF000000FFLL), v20), v14, v13);
  unsigned int v24 = v23.i32[1] + 128;
  int32x2_t v25 = vdup_n_s32(0xFE80u);
  int32x2_t v26 = vcgt_s32(v25, v23);
  if ((v26.i8[4] & 1) == 0) {
    unsigned int v24 = 65152;
  }
  unsigned int v27 = v24 + (v24 >> 8);
  unsigned int v28 = v23.i32[0] + 128;
  if ((v26.i8[0] & 1) == 0) {
    unsigned int v28 = 65152;
  }
  unsigned int v29 = v28 + (v28 >> 8);
  if (v21 >= 65152) {
    int v30 = 65152;
  }
  else {
    int v30 = v21 + 128;
  }
  unsigned int v31 = (v30 + (v30 >> 8)) >> 8;
  int32x2_t v32 = vmul_s32(v17, v15);
  int32x2_t v33 = (int32x2_t)__PAIR64__(v18.u32[1], v32.u32[0]);
  int32x2_t v34 = vneg_s32(v18);
  v18.i32[1] = v32.i32[1];
  int32x2_t v35 = vaba_s32(vsub_s32(vmla_s32(v34, v16, (int32x2_t)0xFF000000FFLL), v32), v18, v33);
  uint32x2_t v36 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v25, v35), (int8x8_t)vadd_s32(v35, (int32x2_t)0x8000000080), (int8x8_t)v25);
  int8x8_t v37 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v31), (int32x2_t)vshr_n_u32(vsra_n_u32(v36, v36, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v37.i32[0] | ((v31 - (v27 >> 8)) << 24) | v37.i32[1] | (v31 - BYTE1(v29)) | ((unint64_t)v31 << 32);
}

unint64_t PDAexclusionPDA_5710(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  signed int v4 = a2 - HIBYTE(a1);
  int32x2_t v5 = vdup_n_s32(a2);
  int32x2_t v6 = vsub_s32(v5, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  signed int v7 = a2 - a1;
  signed int v8 = a4 - HIBYTE(a3);
  int32x2_t v9 = vdup_n_s32(a4);
  int32x2_t v10 = vsub_s32(v9, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if (v8 >= a4) {
    signed int v8 = a4;
  }
  if (v4 >= a2) {
    signed int v4 = a2;
  }
  int v11 = 255 * (v8 + v4) - 2 * v4 * v8;
  if (a4 - a3 >= a4) {
    signed int v12 = a4;
  }
  else {
    signed int v12 = a4 - a3;
  }
  if (v7 >= a2) {
    signed int v7 = a2;
  }
  int v13 = 255 * (v12 + v7) - 2 * v7 * v12;
  int v14 = 255 * (a4 + a2) - a4 * a2;
  if (v11 >= 65152) {
    unsigned int v15 = 65152;
  }
  else {
    unsigned int v15 = v11 + 128;
  }
  unsigned int v16 = v15 + (v15 >> 8);
  if (v13 >= 65152) {
    unsigned int v17 = 65152;
  }
  else {
    unsigned int v17 = v13 + 128;
  }
  unsigned int v18 = v17 + (v17 >> 8);
  if (v14 >= 65152) {
    int v19 = 65152;
  }
  else {
    int v19 = v14 + 128;
  }
  unsigned int v20 = (v19 + (v19 >> 8)) >> 8;
  int32x2_t v21 = vmin_s32(v10, v9);
  int32x2_t v22 = vmin_s32(v6, v5);
  int32x2_t v23 = vmul_s32(vadd_s32(v21, v22), (int32x2_t)0xFF000000FFLL);
  int32x2_t v24 = vmul_s32(v22, v21);
  int32x2_t v25 = vsub_s32(v23, vadd_s32(v24, v24));
  int32x2_t v26 = vdup_n_s32(0xFE80u);
  uint32x2_t v27 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v26, v25), (int8x8_t)vadd_s32(v25, (int32x2_t)0x8000000080), (int8x8_t)v26);
  int8x8_t v28 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v20), (int32x2_t)vshr_n_u32(vsra_n_u32(v27, v27, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v28.i32[0] | ((v20 - (v16 >> 8)) << 24) | (v20 - BYTE1(v18)) | v28.i32[1] | ((unint64_t)v20 << 32);
}

unint64_t PDAhuePDA_5711(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  int32x2_t v4 = vdup_n_s32(a2);
  int32x2_t v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    int v8 = a4;
  }
  else {
    int v8 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    int v9 = a2;
  }
  else {
    int v9 = a2 - HIBYTE(a1);
  }
  int32x2_t v10 = vmin_s32(v7, v6);
  int32x2_t v11 = vmin_s32(v5, v4);
  if (a4 - a3 >= a4) {
    signed int v12 = a4;
  }
  else {
    signed int v12 = a4 - a3;
  }
  if (a2 - a1 >= a2) {
    int v13 = a2;
  }
  else {
    int v13 = a2 - a1;
  }
  if (a4 == 255)
  {
    int v17 = 0;
    int v14 = 0;
    double v15 = 0.0;
  }
  else
  {
    int v14 = (a4 ^ 0xFF) * v9;
    int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    double v15 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11));
    int32x2_t v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    int32x2_t v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    int v17 = (a4 ^ 0xFF) * v13;
    int v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
  }
  double v18 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v15, v10, vdup_n_s32(a2 ^ 0xFFu)));
  int32x2_t v19 = vmla_s32((int32x2_t)0x8000000080, v10, v4);
  double v20 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v19, v19, 8uLL), 8uLL));
  int v21 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    int v22 = v14;
  }
  else
  {
    int v17 = v21;
    int v22 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    *(double *)&int32x2_t v23 = v15;
  }
  else
  {
    int v8 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
    *(double *)&int32x2_t v10 = v20;
    *(double *)&int32x2_t v23 = v18;
  }
  __int32 v56 = v8;
  int32x2_t v57 = v10;
  uint64_t v24 = v8 < v10.i32[0];
  uint64_t v25 = v8 >= v10.i32[0];
  if (v10.i32[1] >= *(&v56 + v25))
  {
    int v27 = *(&v56 + v24);
    uint64_t v26 = v25;
    if (v10.i32[1] <= v27) {
      uint64_t v25 = 2;
    }
    else {
      uint64_t v25 = v24;
    }
    if (v10.i32[1] > v27) {
      uint64_t v24 = 2;
    }
  }
  else
  {
    uint64_t v26 = 2;
  }
  int v28 = *(&v56 + v24);
  int v29 = *(&v56 + v26);
  BOOL v30 = __OFSUB__(v28, v29);
  int v31 = v28 - v29;
  if ((v31 < 0) ^ v30 | (v31 == 0))
  {
    *(&v56 + v24) = 0;
    *(&v56 + v25) = 0;
  }
  else
  {
    int v32 = v11.i32[0];
    if (v9 >= v11.i32[0]) {
      int v33 = v11.i32[0];
    }
    else {
      int v33 = v9;
    }
    if (v9 > v11.i32[0]) {
      int v32 = v9;
    }
    if (v11.i32[1] <= v32) {
      __int32 v34 = v32;
    }
    else {
      __int32 v34 = v11.i32[1];
    }
    if (v11.i32[1] >= v33) {
      int v32 = v34;
    }
    else {
      int v33 = v11.i32[1];
    }
    int v35 = v32 - v33;
    *(&v56 + v24) = v35;
    *(&v56 + v25) = ((*(&v56 + v25) - *(&v56 + v26)) * ((v35 << 16) / v31) + 0x8000) >> 16;
  }
  *(&v56 + v26) = 0;
  int32x2_t v36 = vmul_s32(vsub_s32(v11, v57), (int32x2_t)0x1C00000097);
  signed int v37 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v38 = v36.i32[0] + 77 * (v9 - v56) + v36.i32[1];
  __int32 v39 = v56 + ((v38 + 128) >> 8);
  int32x2_t v40 = vadd_s32(vdup_n_s32((v38 + 128) >> 8), v57);
  if (v38 != (char)v38)
  {
    int v41 = v56 >= v57.i32[0] ? v40.i32[0] : v56 + ((v38 + 128) >> 8);
    int v42 = v56 >= v57.i32[0] ? v56 + ((v38 + 128) >> 8) : v40.i32[0];
    int v43 = v40.i32[1] <= v42 ? v42 : v40.i32[1];
    if (v40.i32[1] >= v41) {
      int v42 = v43;
    }
    else {
      int v41 = v40.i32[1];
    }
    if (v42 > v37 || v41 < 0)
    {
      unsigned int v44 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      if (v38 > -129)
      {
        signed int v45 = v42 - v44;
        if (v42 == v44) {
          goto LABEL_64;
        }
        int v46 = v37 - v44;
      }
      else
      {
        signed int v45 = v44 - v41;
        if (v44 == v41) {
          goto LABEL_64;
        }
        int v46 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      }
      unsigned int v47 = (v46 << 16) / v45;
      __int32 v39 = v44 + ((int)(v47 * (v39 - v44) + 0x8000) >> 16);
      int32x2_t v48 = vdup_n_s32(v44);
      int32x2_t v40 = vsra_n_s32(v48, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v47), vsub_s32(v40, v48)), 0x10uLL);
    }
  }
LABEL_64:
  if (v17 >= 65152) {
    unsigned int v49 = 65152;
  }
  else {
    unsigned int v49 = v17 + 128;
  }
  if (v22 >= 65152) {
    unsigned int v50 = 65152;
  }
  else {
    unsigned int v50 = v22 + 128;
  }
  unsigned int v51 = a4 + a2 - v37;
  int32x2_t v52 = vdup_n_s32(0xFE80u);
  uint32x2_t v53 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v52, v23), (int8x8_t)vadd_s32(v23, (int32x2_t)0x8000000080), (int8x8_t)v52);
  int8x8_t v54 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v51), (int32x2_t)vsra_n_u32((uint32x2_t)v40, vsra_n_u32(v53, v53, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v54.i32[0] | ((v51 - (v39 + ((v50 + (v50 >> 8)) >> 8))) << 24) | (v51
                                                                                          - (v13
                                                                                           + ((unsigned __int16)(v49 + (v49 >> 8)) >> 8))) | v54.i32[1] | ((unint64_t)v51 << 32);
}

unint64_t PDAsaturationPDA_5712(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  int32x2_t v4 = vdup_n_s32(a2);
  int32x2_t v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    signed int v8 = a4;
  }
  else {
    signed int v8 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    int v9 = a2;
  }
  else {
    int v9 = a2 - HIBYTE(a1);
  }
  double v10 = COERCE_DOUBLE(vmin_s32(v7, v6));
  int32x2_t v11 = vmin_s32(v5, v4);
  if (a4 - a3 >= a4) {
    signed int v12 = a4;
  }
  else {
    signed int v12 = a4 - a3;
  }
  if (a2 - a1 >= a2) {
    int v13 = a2;
  }
  else {
    int v13 = a2 - a1;
  }
  if (a4 == 255)
  {
    int v17 = 0;
    int v14 = 0;
    double v15 = 0.0;
  }
  else
  {
    int v14 = (a4 ^ 0xFF) * v9;
    int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    double v15 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11));
    int32x2_t v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    int32x2_t v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    int v17 = (a4 ^ 0xFF) * v13;
    int v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
  }
  double v18 = COERCE_DOUBLE(vadd_s32(vrev64_s32(vmul_s32(*(int32x2_t *)&v10, vdup_n_s32(a2 ^ 0xFFu))), *(int32x2_t *)&v15));
  int32x2_t v19 = vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v10, v4);
  double v20 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v19, v19, 8uLL), 8uLL));
  int v21 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    int v22 = v14;
  }
  else
  {
    int v17 = v21;
    int v22 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    int v23 = v8;
  }
  else {
    int v23 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
  }
  if (a2 == 255)
  {
    *(double *)&int32x2_t v24 = v15;
  }
  else
  {
    double v10 = v20;
    *(double *)&int32x2_t v24 = v18;
  }
  __int32 v57 = v9;
  int32x2_t v58 = v11;
  uint64_t v25 = v9 < v11.i32[0];
  uint64_t v26 = v9 >= v11.i32[0];
  if (v11.i32[1] >= *(&v57 + v26))
  {
    int v28 = *(&v57 + v25);
    uint64_t v27 = v9 >= v11.i32[0];
    if (v11.i32[1] <= v28) {
      uint64_t v26 = 2;
    }
    else {
      uint64_t v26 = v9 < v11.i32[0];
    }
    if (v11.i32[1] > v28) {
      uint64_t v25 = 2;
    }
  }
  else
  {
    uint64_t v27 = 2;
  }
  int v29 = *(&v57 + v25);
  int v30 = *(&v57 + v27);
  BOOL v31 = __OFSUB__(v29, v30);
  int v32 = v29 - v30;
  if ((v32 < 0) ^ v31 | (v32 == 0))
  {
    *(&v57 + v25) = 0;
    *(&v57 + v26) = 0;
  }
  else
  {
    if (v23 >= SHIDWORD(v10)) {
      int v33 = HIDWORD(v10);
    }
    else {
      int v33 = v23;
    }
    if (v23 <= SHIDWORD(v10)) {
      int v23 = HIDWORD(v10);
    }
    int v34 = LODWORD(v10);
    if (SLODWORD(v10) <= v23) {
      int v35 = v23;
    }
    else {
      int v35 = LODWORD(v10);
    }
    if (SLODWORD(v10) >= v33)
    {
      int v34 = v33;
      int v23 = v35;
    }
    __int32 v36 = v23 - v34;
    *(&v57 + v25) = v36;
    *(&v57 + v26) = ((*(&v57 + v26) - *(&v57 + v27)) * ((v36 << 16) / v32) + 0x8000) >> 16;
  }
  *(&v57 + v27) = 0;
  int32x2_t v37 = vmul_s32(vsub_s32(v11, v58), (int32x2_t)0x1C00000097);
  signed int v38 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v39 = v37.i32[0] + 77 * (v9 - v57) + v37.i32[1];
  __int32 v40 = v57 + ((v39 + 128) >> 8);
  int32x2_t v41 = vadd_s32(vdup_n_s32((v39 + 128) >> 8), v58);
  if (v39 != (char)v39)
  {
    int v42 = v57 >= v58.i32[0] ? v41.i32[0] : v57 + ((v39 + 128) >> 8);
    int v43 = v57 >= v58.i32[0] ? v57 + ((v39 + 128) >> 8) : v41.i32[0];
    int v44 = v41.i32[1] <= v43 ? v43 : v41.i32[1];
    if (v41.i32[1] >= v42) {
      int v43 = v44;
    }
    else {
      int v42 = v41.i32[1];
    }
    if (v43 > v38 || v42 < 0)
    {
      unsigned int v45 = (77 * v40 + 151 * v41.i32[0] + 28 * v41.i32[1] + 128) >> 8;
      if (v39 > -129)
      {
        signed int v46 = v43 - v45;
        if (v43 == v45) {
          goto LABEL_66;
        }
        int v47 = v38 - v45;
      }
      else
      {
        signed int v46 = v45 - v42;
        if (v45 == v42) {
          goto LABEL_66;
        }
        int v47 = (77 * v40 + 151 * v41.i32[0] + 28 * v41.i32[1] + 128) >> 8;
      }
      unsigned int v48 = (v47 << 16) / v46;
      __int32 v40 = v45 + ((int)(v48 * (v40 - v45) + 0x8000) >> 16);
      int32x2_t v49 = vdup_n_s32(v45);
      int32x2_t v41 = vsra_n_s32(v49, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v48), vsub_s32(v41, v49)), 0x10uLL);
    }
  }
LABEL_66:
  if (v17 >= 65152) {
    unsigned int v50 = 65152;
  }
  else {
    unsigned int v50 = v17 + 128;
  }
  if (v22 >= 65152) {
    unsigned int v51 = 65152;
  }
  else {
    unsigned int v51 = v22 + 128;
  }
  unsigned int v52 = a4 + a2 - v38;
  int32x2_t v53 = vdup_n_s32(0xFE80u);
  uint32x2_t v54 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v53, v24), (int8x8_t)vadd_s32(v24, (int32x2_t)0x8000000080), (int8x8_t)v53);
  int8x8_t v55 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v52), (int32x2_t)vsra_n_u32((uint32x2_t)v41, vsra_n_u32(v54, v54, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v55.i32[0] | ((v52 - (v40 + ((v51 + (v51 >> 8)) >> 8))) << 24) | (v52
                                                                                          - (v13
                                                                                           + ((unsigned __int16)(v50 + (v50 >> 8)) >> 8))) | v55.i32[1] | ((unint64_t)v52 << 32);
}

unint64_t PDAluminosityPDA_5713(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  int32x2_t v4 = vdup_n_s32(a2);
  int32x2_t v5 = vdup_n_s32(a4);
  int32x2_t v6 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  int32x2_t v7 = vsub_s32(v5, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    int v8 = a4;
  }
  else {
    int v8 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    int v9 = a2;
  }
  else {
    int v9 = a2 - HIBYTE(a1);
  }
  int32x2_t v10 = vmin_s32(v6, v4);
  if (a4 - a3 >= a4) {
    int v11 = a4;
  }
  else {
    int v11 = a4 - a3;
  }
  if (a4 == 255)
  {
    int v16 = 0;
    int v13 = 0;
    int32x2_t v14 = 0;
  }
  else
  {
    if (a2 - a1 >= a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = a2 - a1;
    }
    int v13 = (a4 ^ 0xFF) * v9;
    int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    int32x2_t v14 = vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v10);
    int32x2_t v15 = vmla_s32((int32x2_t)0x8000000080, v10, v5);
    int32x2_t v10 = vshr_n_s32(vsra_n_s32(v15, v15, 8uLL), 8uLL);
    int v16 = (a4 ^ 0xFF) * v12;
  }
  int32x2_t v17 = vmin_s32(v7, v5);
  if (a2 != 255)
  {
    v13 += v8 * (a2 ^ 0xFF);
    int v8 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
    int32x2_t v14 = vmla_s32(v14, v17, vdup_n_s32(a2 ^ 0xFFu));
    int32x2_t v18 = vmla_s32((int32x2_t)0x8000000080, v17, v4);
    int32x2_t v17 = vshr_n_s32(vsra_n_s32(v18, v18, 8uLL), 8uLL);
    v16 += v11 * (a2 ^ 0xFF);
    int v11 = (v11 * a2 + 128 + ((v11 * a2 + 128) >> 8)) >> 8;
  }
  signed int v19 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int32x2_t v20 = vmul_s32(vsub_s32(v17, v10), (int32x2_t)0x1C00000097);
  signed __int32 v21 = vadd_s32(v20, vdup_lane_s32(v20, 1)).u32[0] + 77 * (v8 - v9);
  signed __int32 v22 = v9 + ((v21 + 128) >> 8);
  int32x2_t v23 = vadd_s32(vdup_n_s32((v21 + 128) >> 8), v10);
  if (v21 != (char)v21)
  {
    int v24 = v9 >= v10.i32[0] ? v23.i32[0] : v9 + ((v21 + 128) >> 8);
    int v25 = v9 >= v10.i32[0] ? v9 + ((v21 + 128) >> 8) : v23.i32[0];
    int v26 = v23.i32[1] <= v25 ? v25 : v23.i32[1];
    if (v23.i32[1] >= v24) {
      int v25 = v26;
    }
    else {
      int v24 = v23.i32[1];
    }
    if (v25 > v19 || v24 < 0)
    {
      unsigned int v27 = (77 * v22 + 151 * v23.i32[0] + 28 * v23.i32[1] + 128) >> 8;
      if (v21 > -129)
      {
        signed int v28 = v25 - v27;
        if (v25 == v27) {
          goto LABEL_39;
        }
        int v29 = v19 - v27;
      }
      else
      {
        signed int v28 = v27 - v24;
        if (v27 == v24) {
          goto LABEL_39;
        }
        int v29 = (77 * v22 + 151 * v23.i32[0] + 28 * v23.i32[1] + 128) >> 8;
      }
      unsigned int v30 = (v29 << 16) / v28;
      signed __int32 v22 = v27 + ((int)(v30 * (v22 - v27) + 0x8000) >> 16);
      int32x2_t v31 = vdup_n_s32(v27);
      int32x2_t v23 = vsra_n_s32(v31, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v30), vsub_s32(v23, v31)), 0x10uLL);
    }
  }
LABEL_39:
  if (v16 >= 65152) {
    unsigned int v32 = 65152;
  }
  else {
    unsigned int v32 = v16 + 128;
  }
  unsigned int v33 = v32 + (v32 >> 8);
  int32x2_t v34 = vdup_n_s32(0xFE80u);
  int8x8_t v35 = (int8x8_t)vcgt_s32(v34, v14);
  int8x8_t v36 = (int8x8_t)vadd_s32(v14, (int32x2_t)0x8000000080);
  if (v13 >= 65152) {
    unsigned int v37 = 65152;
  }
  else {
    unsigned int v37 = v13 + 128;
  }
  uint32x2_t v38 = (uint32x2_t)vbsl_s8(v35, v36, (int8x8_t)v34);
  int8x8_t v39 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(a4 + a2 - v19), (int32x2_t)vsra_n_u32((uint32x2_t)v23, vsra_n_u32(v38, v38, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v39.i32[0] | ((a4 + a2 - v19 - (v22 + ((v37 + (v37 >> 8)) >> 8))) << 24) | (a4 + a2 - v19 - (v11 + BYTE1(v33))) | v39.i32[1] | ((unint64_t)(a4 + a2 - v19) << 32);
}

unint64_t PDAtranspose_huePDA(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  int32x2_t v4 = vdup_n_s32(a2);
  int32x2_t v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  if (a4 - a3 >= a4) {
    int v8 = a4;
  }
  else {
    int v8 = a4 - a3;
  }
  if (a2 - a1 >= a2) {
    int v9 = a2;
  }
  else {
    int v9 = a2 - a1;
  }
  int32x2_t v10 = vmin_s32(v7, v6);
  int32x2_t v11 = vmin_s32(v5, v4);
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    signed int v12 = a4;
  }
  else {
    signed int v12 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    int v13 = a2;
  }
  else {
    int v13 = a2 - HIBYTE(a1);
  }
  if (a4 == 255)
  {
    int v17 = 0;
    int v14 = 0;
    double v15 = 0.0;
  }
  else
  {
    int v14 = (a4 ^ 0xFF) * v9;
    int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    double v15 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11));
    int32x2_t v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    int32x2_t v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    int v17 = (a4 ^ 0xFF) * v13;
    int v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
  }
  double v18 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v15, v10, vdup_n_s32(a2 ^ 0xFFu)));
  int32x2_t v19 = vmla_s32((int32x2_t)0x8000000080, v10, v4);
  double v20 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v19, v19, 8uLL), 8uLL));
  int v21 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    int v22 = v14;
  }
  else
  {
    int v17 = v21;
    int v22 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    *(double *)&int32x2_t v23 = v15;
  }
  else
  {
    int v8 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
    *(double *)&int32x2_t v10 = v20;
    *(double *)&int32x2_t v23 = v18;
  }
  __int32 v56 = v8;
  int32x2_t v57 = v10;
  uint64_t v24 = v8 < v10.i32[0];
  uint64_t v25 = v8 >= v10.i32[0];
  if (v10.i32[1] >= *(&v56 + v25))
  {
    int v27 = *(&v56 + v24);
    uint64_t v26 = v25;
    if (v10.i32[1] <= v27) {
      uint64_t v25 = 2;
    }
    else {
      uint64_t v25 = v24;
    }
    if (v10.i32[1] > v27) {
      uint64_t v24 = 2;
    }
  }
  else
  {
    uint64_t v26 = 2;
  }
  int v28 = *(&v56 + v24);
  int v29 = *(&v56 + v26);
  BOOL v30 = __OFSUB__(v28, v29);
  int v31 = v28 - v29;
  if ((v31 < 0) ^ v30 | (v31 == 0))
  {
    *(&v56 + v24) = 0;
    *(&v56 + v25) = 0;
  }
  else
  {
    int v32 = v11.i32[0];
    if (v9 >= v11.i32[0]) {
      int v33 = v11.i32[0];
    }
    else {
      int v33 = v9;
    }
    if (v9 > v11.i32[0]) {
      int v32 = v9;
    }
    if (v11.i32[1] <= v32) {
      __int32 v34 = v32;
    }
    else {
      __int32 v34 = v11.i32[1];
    }
    if (v11.i32[1] >= v33) {
      int v32 = v34;
    }
    else {
      int v33 = v11.i32[1];
    }
    int v35 = v32 - v33;
    *(&v56 + v24) = v35;
    *(&v56 + v25) = ((*(&v56 + v25) - *(&v56 + v26)) * ((v35 << 16) / v31) + 0x8000) >> 16;
  }
  *(&v56 + v26) = 0;
  int32x2_t v36 = vmul_s32(vsub_s32(v11, v57), (int32x2_t)0x1C00000097);
  signed int v37 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v38 = v36.i32[0] + 77 * (v9 - v56) + v36.i32[1];
  __int32 v39 = v56 + ((v38 + 128) >> 8);
  int32x2_t v40 = vadd_s32(vdup_n_s32((v38 + 128) >> 8), v57);
  if (v38 != (char)v38)
  {
    int v41 = v56 >= v57.i32[0] ? v40.i32[0] : v56 + ((v38 + 128) >> 8);
    int v42 = v56 >= v57.i32[0] ? v56 + ((v38 + 128) >> 8) : v40.i32[0];
    int v43 = v40.i32[1] <= v42 ? v42 : v40.i32[1];
    if (v40.i32[1] >= v41) {
      int v42 = v43;
    }
    else {
      int v41 = v40.i32[1];
    }
    if (v42 > v37 || v41 < 0)
    {
      unsigned int v44 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      if (v38 > -129)
      {
        signed int v45 = v42 - v44;
        if (v42 == v44) {
          goto LABEL_64;
        }
        int v46 = v37 - v44;
      }
      else
      {
        signed int v45 = v44 - v41;
        if (v44 == v41) {
          goto LABEL_64;
        }
        int v46 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      }
      unsigned int v47 = (v46 << 16) / v45;
      __int32 v39 = v44 + ((int)(v47 * (v39 - v44) + 0x8000) >> 16);
      int32x2_t v48 = vdup_n_s32(v44);
      int32x2_t v40 = vsra_n_s32(v48, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v47), vsub_s32(v40, v48)), 0x10uLL);
    }
  }
LABEL_64:
  if (v17 >= 65152) {
    unsigned int v49 = 65152;
  }
  else {
    unsigned int v49 = v17 + 128;
  }
  if (v22 >= 65152) {
    unsigned int v50 = 65152;
  }
  else {
    unsigned int v50 = v22 + 128;
  }
  unsigned int v51 = a4 + a2 - v37;
  int32x2_t v52 = vdup_n_s32(0xFE80u);
  uint32x2_t v53 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v52, v23), (int8x8_t)vadd_s32(v23, (int32x2_t)0x8000000080), (int8x8_t)v52);
  int8x8_t v54 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v51), (int32x2_t)vsra_n_u32((uint32x2_t)v40, vsra_n_u32(v53, v53, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return v54.i32[1] | ((v51 - (v13 + ((v49 + (v49 >> 8)) >> 8))) << 24) | v54.i32[0] | (v51 - (v39 + ((unsigned __int16)(v50 + (v50 >> 8)) >> 8))) | ((unint64_t)v51 << 32);
}

unint64_t PDAtranspose_saturationPDA(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  int32x2_t v4 = vdup_n_s32(a2);
  int32x2_t v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if (a4 - a3 >= a4) {
    signed int v8 = a4;
  }
  else {
    signed int v8 = a4 - a3;
  }
  if (a2 - a1 >= a2) {
    int v9 = a2;
  }
  else {
    int v9 = a2 - a1;
  }
  double v10 = COERCE_DOUBLE(vmin_s32(v7, v6));
  int32x2_t v11 = vmin_s32(v5, v4);
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    signed int v12 = a4;
  }
  else {
    signed int v12 = a4 - HIBYTE(a3);
  }
  if ((int)(a2 - HIBYTE(a1)) >= a2) {
    int v13 = a2;
  }
  else {
    int v13 = a2 - HIBYTE(a1);
  }
  if (a4 == 255)
  {
    int v17 = 0;
    int v14 = 0;
    double v18 = 0.0;
  }
  else
  {
    int v14 = (a4 ^ 0xFF) * v9;
    int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    int32x2_t v15 = vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11);
    int32x2_t v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    int32x2_t v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    int v17 = (a4 ^ 0xFF) * v13;
    int v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
    double v18 = COERCE_DOUBLE(vrev64_s32(v15));
  }
  double v19 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v18, *(int32x2_t *)&v10, vdup_n_s32(a2 ^ 0xFFu)));
  int32x2_t v20 = vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v10, v4);
  double v21 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v20, v20, 8uLL), 8uLL));
  int v22 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    int v23 = v14;
  }
  else
  {
    int v17 = v22;
    int v23 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    int v24 = v8;
  }
  else {
    int v24 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
  }
  if (a2 == 255)
  {
    *(double *)&int32x2_t v25 = v18;
  }
  else
  {
    double v10 = v21;
    *(double *)&int32x2_t v25 = v19;
  }
  __int32 v59 = v9;
  int32x2_t v60 = v11;
  uint64_t v26 = v9 < v11.i32[0];
  uint64_t v27 = v9 >= v11.i32[0];
  if (v11.i32[1] >= *(&v59 + v27))
  {
    int v29 = *(&v59 + v26);
    uint64_t v28 = v9 >= v11.i32[0];
    if (v11.i32[1] <= v29) {
      uint64_t v27 = 2;
    }
    else {
      uint64_t v27 = v9 < v11.i32[0];
    }
    if (v11.i32[1] > v29) {
      uint64_t v26 = 2;
    }
  }
  else
  {
    uint64_t v28 = 2;
  }
  int v30 = *(&v59 + v26);
  int v31 = *(&v59 + v28);
  BOOL v32 = __OFSUB__(v30, v31);
  int v33 = v30 - v31;
  if ((v33 < 0) ^ v32 | (v33 == 0))
  {
    *(&v59 + v26) = 0;
    *(&v59 + v27) = 0;
  }
  else
  {
    if (v24 >= SHIDWORD(v10)) {
      int v34 = HIDWORD(v10);
    }
    else {
      int v34 = v24;
    }
    if (v24 <= SHIDWORD(v10)) {
      int v24 = HIDWORD(v10);
    }
    int v35 = LODWORD(v10);
    if (SLODWORD(v10) <= v24) {
      int v36 = v24;
    }
    else {
      int v36 = LODWORD(v10);
    }
    if (SLODWORD(v10) >= v34)
    {
      int v35 = v34;
      int v24 = v36;
    }
    __int32 v37 = v24 - v35;
    *(&v59 + v26) = v37;
    *(&v59 + v27) = ((*(&v59 + v27) - *(&v59 + v28)) * ((v37 << 16) / v33) + 0x8000) >> 16;
  }
  *(&v59 + v28) = 0;
  int32x2_t v38 = vmul_s32(vsub_s32(v11, v60), (int32x2_t)0x1C00000097);
  signed int v39 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v40 = v38.i32[0] + 77 * (v9 - v59) + v38.i32[1];
  __int32 v41 = v59 + ((v40 + 128) >> 8);
  int32x2_t v42 = vadd_s32(vdup_n_s32((v40 + 128) >> 8), v60);
  int32x2_t v43 = vrev64_s32(v42);
  if (v40 != (char)v40)
  {
    int v44 = v59 >= v60.i32[0] ? v42.i32[0] : v59 + ((v40 + 128) >> 8);
    int v45 = v59 >= v60.i32[0] ? v59 + ((v40 + 128) >> 8) : v42.i32[0];
    int v46 = v42.i32[1] <= v45 ? v45 : v42.i32[1];
    if (v42.i32[1] >= v44) {
      int v45 = v46;
    }
    else {
      int v44 = v42.i32[1];
    }
    if (v45 > v39 || v44 < 0)
    {
      unsigned int v47 = (77 * v41 + 151 * v42.i32[0] + 28 * v42.i32[1] + 128) >> 8;
      if (v40 > -129)
      {
        signed int v48 = v45 - v47;
        if (v45 == v47) {
          goto LABEL_66;
        }
        int v49 = v39 - v47;
      }
      else
      {
        signed int v48 = v47 - v44;
        if (v47 == v44) {
          goto LABEL_66;
        }
        int v49 = (77 * v41 + 151 * v42.i32[0] + 28 * v42.i32[1] + 128) >> 8;
      }
      unsigned int v50 = (v49 << 16) / v48;
      __int32 v41 = v47 + ((int)(v50 * (v41 - v47) + 0x8000) >> 16);
      int32x2_t v51 = vdup_n_s32(v47);
      int32x2_t v43 = vsra_n_s32(v51, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v50), vsub_s32(v43, v51)), 0x10uLL);
    }
  }
LABEL_66:
  if (v17 >= 65152) {
    unsigned int v52 = 65152;
  }
  else {
    unsigned int v52 = v17 + 128;
  }
  if (v23 >= 65152) {
    unsigned int v53 = 65152;
  }
  else {
    unsigned int v53 = v23 + 128;
  }
  unsigned int v54 = a4 + a2 - v39;
  int32x2_t v55 = vdup_n_s32(0xFE80u);
  uint32x2_t v56 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v55, v25), (int8x8_t)vadd_s32(v25, (int32x2_t)0x8000000080), (int8x8_t)v55);
  int8x8_t v57 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v54), (int32x2_t)vsra_n_u32((uint32x2_t)v43, vsra_n_u32(v56, v56, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v57.i32[0] | ((v54 - (v13 + ((v52 + (v52 >> 8)) >> 8))) << 24) | (v54
                                                                                          - (v41
                                                                                           + ((unsigned __int16)(v53 + (v53 >> 8)) >> 8))) | v57.i32[1] | ((unint64_t)v54 << 32);
}

unint64_t PDAtranspose_luminosityPDA(unsigned __int32 a1, signed int a2, unsigned __int32 a3, signed int a4)
{
  v4.i32[0] = a1 >> 8;
  v4.i32[1] = a1;
  int32x2_t v5 = vdup_n_s32(a2);
  v6.i32[0] = a3 >> 8;
  v6.i32[1] = a3;
  int32x2_t v7 = (int32x2_t)vand_s8(v6, (int8x8_t)0xFF000000FFLL);
  int32x2_t v8 = vdup_n_s32(a4);
  int32x2_t v9 = vsub_s32(v8, v7);
  int32x2_t v10 = vmin_s32(vsub_s32(v5, (int32x2_t)vand_s8(v4, (int8x8_t)0xFF000000FFLL)), v5);
  if (a4 - BYTE2(a3) >= a4) {
    int v11 = a4;
  }
  else {
    int v11 = a4 - BYTE2(a3);
  }
  if (a2 - BYTE2(a1) >= a2) {
    int v12 = a2;
  }
  else {
    int v12 = a2 - BYTE2(a1);
  }
  if ((int)(a4 - HIBYTE(a3)) >= a4) {
    int v13 = a4;
  }
  else {
    int v13 = a4 - HIBYTE(a3);
  }
  if (a4 == 255)
  {
    int v20 = 0;
    int v15 = 0;
    int32x2_t v19 = 0;
  }
  else
  {
    if ((int)(a2 - HIBYTE(a1)) >= a2) {
      signed int v14 = a2;
    }
    else {
      signed int v14 = a2 - HIBYTE(a1);
    }
    int v15 = (a4 ^ 0xFF) * v10.i32[1];
    int32x2_t v16 = vmla_s32((int32x2_t)0x8000000080, v10, v8);
    int32x2_t v17 = vdup_lane_s32(v10, 0);
    int32x2_t v18 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    v17.i32[0] = v12;
    int32x2_t v19 = vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v17);
    int v12 = (v12 * a4 + 128 + ((v12 * a4 + 128) >> 8)) >> 8;
    int v20 = (a4 ^ 0xFF) * v14;
    int32x2_t v10 = v18;
  }
  int32x2_t v21 = vmin_s32(v9, v8);
  if (a2 != 255)
  {
    v15 += v21.i32[1] * (a2 ^ 0xFF);
    int32x2_t v22 = vmla_s32((int32x2_t)0x8000000080, v21, v5);
    int32x2_t v23 = vdup_lane_s32(v21, 0);
    v23.i32[0] = v11;
    int32x2_t v21 = vshr_n_s32(vsra_n_s32(v22, v22, 8uLL), 8uLL);
    int32x2_t v19 = vmla_s32(v19, v23, vdup_n_s32(a2 ^ 0xFFu));
    int v11 = (v11 * a2 + 128 + ((v11 * a2 + 128) >> 8)) >> 8;
    v20 += v13 * (a2 ^ 0xFF);
    int v13 = (v13 * a2 + 128 + ((v13 * a2 + 128) >> 8)) >> 8;
  }
  signed int v24 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int32x2_t v25 = vmul_s32(vsub_s32(v21, v10), (int32x2_t)0x4D00000097);
  int v26 = v25.i32[0] + 28 * (v11 - v12) + v25.i32[1];
  int v27 = v10.i32[1] + ((v26 + 128) >> 8);
  int32x2_t v28 = vdup_lane_s32(v10, 0);
  v28.i32[0] = v12;
  int32x2_t v29 = vadd_s32(vdup_n_s32((v26 + 128) >> 8), v28);
  if (v26 != (char)v26)
  {
    int v30 = v10.i32[1] >= v10.i32[0] ? v29.i32[1] : v10.i32[1] + ((v26 + 128) >> 8);
    int v31 = v10.i32[1] >= v10.i32[0] ? v10.i32[1] + ((v26 + 128) >> 8) : v29.i32[1];
    int v32 = v29.i32[0] <= v31 ? v31 : v29.i32[0];
    if (v29.i32[0] >= v30) {
      int v31 = v32;
    }
    else {
      int v30 = v29.i32[0];
    }
    if (v31 > v24 || v30 < 0)
    {
      unsigned int v33 = (77 * v27 + 151 * v29.i32[1] + 28 * v29.i32[0] + 128) >> 8;
      if (v26 > -129)
      {
        signed int v34 = v31 - v33;
        if (v31 == v33) {
          goto LABEL_39;
        }
        int v35 = v24 - v33;
      }
      else
      {
        signed int v34 = v33 - v30;
        if (v33 == v30) {
          goto LABEL_39;
        }
        int v35 = (77 * v27 + 151 * v29.i32[1] + 28 * v29.i32[0] + 128) >> 8;
      }
      unsigned int v36 = (v35 << 16) / v34;
      int v27 = v33 + ((int)(v36 * (v27 - v33) + 0x8000) >> 16);
      int32x2_t v37 = vdup_n_s32(v33);
      int32x2_t v29 = vsra_n_s32(v37, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v36), vsub_s32(v29, v37)), 0x10uLL);
    }
  }
LABEL_39:
  if (v20 >= 65152) {
    unsigned int v38 = 65152;
  }
  else {
    unsigned int v38 = v20 + 128;
  }
  unsigned int v39 = v38 + (v38 >> 8);
  int32x2_t v40 = vdup_n_s32(0xFE80u);
  int8x8_t v41 = (int8x8_t)vcgt_s32(v40, v19);
  int8x8_t v42 = (int8x8_t)vadd_s32(v19, (int32x2_t)0x8000000080);
  if (v15 >= 65152) {
    unsigned int v43 = 65152;
  }
  else {
    unsigned int v43 = v15 + 128;
  }
  uint32x2_t v44 = (uint32x2_t)vbsl_s8(v41, v42, (int8x8_t)v40);
  int8x8_t v45 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(a4 + a2 - v24), (int32x2_t)vsra_n_u32((uint32x2_t)v29, vsra_n_u32(v44, v44, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v45.i32[0] | ((a4 + a2 - v24 - (v13 + (v39 >> 8))) << 24) | (a4
                                                                                     + a2
                                                                                     - v24
                                                                                     - (v27
                                                                                      + ((unsigned __int16)(v43 + (v43 >> 8)) >> 8))) | v45.i32[1] | ((unint64_t)(a4 + a2 - v24) << 32);
}

void cmyk32_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  float v6 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
             + (float)(v5 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  uint64_t v7 = a1 + 368;
  uint64_t v8 = *(void *)(a1 + 368);
  uint64_t v9 = ((unint64_t)a3 >> 4) & 0xF0;
  uint64_t v10 = v8 + v9;
  if (v8) {
    uint64_t v11 = v8 + v9;
  }
  else {
    uint64_t v11 = a1 + 368;
  }
  if (v8) {
    char v12 = 15;
  }
  else {
    char v12 = 0;
  }
  float v14 = *(float *)(a1 + 336);
  float v15 = *(float *)(a1 + 344);
  float v16 = *(float *)(a1 + 304);
  float v17 = *(float *)(a1 + 308);
  int v18 = *(_DWORD *)(a1 + 320);
  int v19 = *(_DWORD *)(a1 + 324);
  uint64_t v22 = a1 + 144;
  int v20 = *(_DWORD **)(a1 + 144);
  int32x2_t v21 = *(int8x16_t **)(v22 + 8);
  int32x2_t v23 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v24 = *(void *)(a1 + 360);
  if (v5 != 0.0)
  {
    if (v8) {
      unsigned int v30 = (a2 >> 8) & 0xF;
    }
    else {
      LOBYTE(v30) = 0;
    }
    while (1)
    {
      int v31 = v18;
      if (v6 >= v16)
      {
        int v31 = v19;
        if (v6 <= v17) {
          int v31 = (int)(float)(v15 * (float)(v6 - v14));
        }
      }
      if (v31 < 0)
      {
        if (!v23)
        {
          char v39 = 0;
          goto LABEL_40;
        }
        int v33 = v23[1];
        unsigned __int16 v34 = v23[2];
        unsigned __int16 v35 = v23[3];
        int v36 = *(unsigned __int8 *)(v11 + v30);
        int v37 = v36 + *v23;
        unsigned __int16 v38 = v23[4];
      }
      else
      {
        int v32 = (unsigned __int16 *)(v24 + 10 * v31);
        int v33 = v32[1];
        unsigned __int16 v34 = v32[2];
        unsigned __int16 v35 = v32[3];
        int v36 = *(unsigned __int8 *)(v11 + v30);
        int v37 = v36 + *v32;
        unsigned __int16 v38 = v32[4];
      }
      v21->i64[0] = (v37 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v36 + v38) & 0xFF00) >> 8) << 32) | ((v36 + v33) << 8) & 0xFF0000 | (unint64_t)((unsigned __int16)(v36 + v34) & 0xFF00) | ((unsigned __int16)(v36 + v35) >> 8);
      char v39 = -1;
LABEL_40:
      LOBYTE(v30) = (v30 + 1) & v12;
      float v6 = v5 + v6;
      int32x2_t v21 = (int8x16_t *)((char *)v21 + 8);
      *(unsigned char *)int v20 = v39;
      int v20 = (_DWORD *)((char *)v20 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v8) {
    uint64_t v25 = v10;
  }
  else {
    uint64_t v25 = v7;
  }
  if (v8) {
    LODWORD(v26) = ((a2 >> 8) + 1) & 0xF;
  }
  else {
    LODWORD(v26) = 0;
  }
  if (v8) {
    unsigned int v27 = (a2 >> 8) & 0xF;
  }
  else {
    unsigned int v27 = 0;
  }
  if (v8) {
    int v28 = 15;
  }
  else {
    int v28 = 0;
  }
  if (v6 >= v16)
  {
    int v18 = v19;
    if (v6 <= v17) {
      int v18 = (int)(float)(v15 * (float)(v6 - v14));
    }
  }
  if ((v18 & 0x80000000) == 0 || v23)
  {
    int32x2_t v40 = (unsigned __int16 *)(v24 + 10 * v18);
    if (v18 < 0) {
      int8x8_t v41 = v23;
    }
    else {
      int8x8_t v41 = v40;
    }
    unsigned int v42 = *v41;
    unsigned int v43 = v41[1];
    unsigned int v44 = v41[2];
    unint64_t v45 = v41[3];
    unsigned int v46 = v41[4];
    if (v8)
    {
      int32x2_t v47 = vdup_n_s32(v42);
      int32x2_t v48 = vdup_n_s32(v43);
      int v49 = a4 + 4;
      int32x2_t v50 = vdup_n_s32(v44);
      int32x2_t v51 = vdup_n_s32(v45);
      int32x2_t v52 = vdup_n_s32(v46);
      do
      {
        v4.i8[0] = *(unsigned char *)(v25 + v27);
        v4.i8[4] = *(unsigned char *)(v25 + v26);
        int32x2_t v53 = (int32x2_t)vand_s8(*(int8x8_t *)v4.i8, (int8x8_t)0xFF000000FFLL);
        int32x2_t v54 = vadd_s32(v48, v53);
        int8x8_t v55 = (int8x8_t)vadd_s32(v50, v53);
        uint32x2_t v56 = (uint32x2_t)vadd_s32(v51, v53);
        int32x2_t v57 = vshl_n_s32(vadd_s32(v47, v53), 0x10uLL);
        v58.i64[0] = v57.i32[0] & 0xFF00FFFF;
        v58.i64[1] = v57.i32[1] & 0xFF00FFFF;
        int8x16_t v59 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v52, v53), (int8x8_t)0xFF000000FF00), 0x18uLL), v58);
        int8x8_t v60 = vand_s8((int8x8_t)vshl_n_s32(v54, 8uLL), (int8x8_t)0xFF000000FF0000);
        v58.i64[0] = v60.u32[0];
        v58.i64[1] = v60.u32[1];
        int8x16_t v61 = v58;
        int8x8_t v62 = vand_s8(v55, (int8x8_t)0xFF000000FF00);
        v58.i64[0] = v62.u32[0];
        v58.i64[1] = v62.u32[1];
        int8x16_t v63 = vorrq_s8(v59, vorrq_s8(v61, v58));
        *(uint32x2_t *)v61.i8 = vshr_n_u32(v56, 8uLL);
        v58.i64[0] = v61.i32[0] & 0xFFFFFEFF;
        v58.i64[1] = v61.i32[1] & 0xFFFFFEFF;
        int8x16_t v64 = vorrq_s8(v63, v58);
        *int32x2_t v21 = v64;
        uint64_t v26 = (v26 + 1) & v28;
        v64.i8[0] = *(unsigned char *)(v25 + ((v27 + 1) & v28));
        v64.i8[4] = *(unsigned char *)(v25 + v26);
        *(int8x8_t *)v64.i8 = vand_s8(*(int8x8_t *)v64.i8, (int8x8_t)0xFF000000FFLL);
        int32x2_t v65 = vadd_s32(v48, *(int32x2_t *)v64.i8);
        int8x8_t v66 = (int8x8_t)vadd_s32(v50, *(int32x2_t *)v64.i8);
        uint32x2_t v67 = (uint32x2_t)vadd_s32(v51, *(int32x2_t *)v64.i8);
        *(int32x2_t *)v61.i8 = vshl_n_s32(vadd_s32(v47, *(int32x2_t *)v64.i8), 0x10uLL);
        v58.i64[0] = v61.i32[0] & 0xFF00FFFF;
        v58.i64[1] = v61.i32[1] & 0xFF00FFFF;
        int8x16_t v68 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v52, *(int32x2_t *)v64.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v58);
        *(int8x8_t *)v61.i8 = vand_s8((int8x8_t)vshl_n_s32(v65, 8uLL), (int8x8_t)0xFF000000FF0000);
        v58.i64[0] = v61.u32[0];
        v58.i64[1] = v61.u32[1];
        int8x16_t v69 = v58;
        int8x8_t v70 = vand_s8(v66, (int8x8_t)0xFF000000FF00);
        v58.i64[0] = v70.u32[0];
        v58.i64[1] = v70.u32[1];
        int8x16_t v71 = vorrq_s8(v68, vorrq_s8(v69, v58));
        *(uint32x2_t *)v69.i8 = vshr_n_u32(v67, 8uLL);
        v58.i64[0] = v69.i32[0] & 0xFFFFFEFF;
        v58.i64[1] = v69.i32[1] & 0xFFFFFEFF;
        *v20++ = -1;
        v49 -= 4;
        int8x16_t v4 = vorrq_s8(v71, v58);
        v21[1] = v4;
        v21 += 2;
        unsigned int v27 = (v27 + 1) & v28;
      }
      while (v49 > 4);
    }
    else
    {
      unint64_t v72 = (v42 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v46 & 0xFF00) >> 8) << 32) | ((unint64_t)BYTE1(v43) << 16) | (unsigned __int16)v44 & 0xFF00 | (v45 >> 8);
      int v73 = a4 + 4;
      do
      {
        v21->i64[0] = v72;
        v21->i64[1] = v72;
        v21[1].i64[0] = v72;
        v21[1].i64[1] = v72;
        v73 -= 4;
        v21 += 2;
        *v20++ = -1;
      }
      while (v73 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v29 = 4;
    }
    else {
      int v29 = a4;
    }
    bzero(v20, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

unint64_t cmyk32_shade_custom_CMYK(unint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(result + 280);
  float v5 = *(float *)(*(void *)(result + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  unint64_t v9 = result + 368;
  uint64_t v10 = *(void *)(result + 368);
  int v11 = 15;
  if (v10) {
    unint64_t v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(result + 284);
  float v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  float v14 = *(float *)(result + 304);
  float v15 = *(float *)(result + 308);
  float v16 = *(float *)(result + 312);
  float v17 = *(float *)(result + 316);
  float v18 = *(float *)(result + 336);
  float v19 = *(float *)(result + 348);
  float v20 = *(float *)(result + 344);
  float v21 = *(float *)(result + 356);
  uint64_t v22 = *(unsigned __int16 **)(result + 376);
  uint64_t v23 = *(void *)(result + 360);
  int v24 = 5 * *(_DWORD *)(result + 48);
  if (v10) {
    uint64_t v25 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v25 = 0;
  }
  unsigned int v27 = *(char **)(result + 144);
  uint64_t v26 = *(unint64_t **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      int v37 = (unsigned __int16 *)(v23
                               + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19))
                               + 10 * (int)(float)(v20 * (float)(v8 - v18)));
      int v31 = v37[1];
      unsigned __int16 v32 = v37[2];
      unsigned __int16 v33 = v37[3];
      int v34 = *(unsigned __int8 *)(v9 + v25);
      int v35 = v34 + *v37;
      unsigned __int16 v36 = v37[4];
      goto LABEL_21;
    }
    if (v22)
    {
      int v31 = v22[1];
      unsigned __int16 v32 = v22[2];
      unsigned __int16 v33 = v22[3];
      int v34 = *(unsigned __int8 *)(v9 + v25);
      int v35 = v34 + *v22;
      unsigned __int16 v36 = v22[4];
LABEL_21:
      int v38 = v34 + v31;
      uint64_t result = (unsigned __int16)(v34 + v32) & 0xFF00;
      *uint64_t v26 = (v35 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v34 + v36) & 0xFF00) >> 8) << 32) | (v38 << 8) & 0xFF0000 | result | ((unsigned __int16)(v34 + v33) >> 8);
      char v39 = -1;
      goto LABEL_22;
    }
    char v39 = 0;
LABEL_22:
    uint64_t v25 = (v25 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    ++v26;
    *v27++ = v39;
    --a4;
  }
  while (a4);
  return result;
}

uint64_t cmyk32_shade_conic_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = *(void *)(a1 + 368);
  if (v9) {
    uint64_t v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v10 = a1 + 368;
  }
  if (v9) {
    int v11 = 15;
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(a1 + 284);
  float v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  float v41 = *(float *)(a1 + 336);
  float v42 = *(float *)(a1 + 304);
  float v15 = *(float *)(a1 + 344);
  uint64_t v16 = *(void *)(a1 + 360);
  float v18 = *(unsigned char **)(a1 + 144);
  float v17 = *(unint64_t **)(a1 + 152);
  if (v9) {
    uint64_t v19 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v19 = 0;
  }
  float v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    float v21 = v15 * (float)((float)(v42 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v41);
    unsigned int v22 = vcvtms_s32_f32(v21);
    float v23 = ceilf(v21);
    float v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    unsigned int v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0) {
      unsigned int v22 = v25;
    }
    float v26 = ceilf(v21 - v15);
    if (v21 <= v15) {
      float v27 = v23;
    }
    else {
      float v27 = v26;
    }
    int v28 = (unsigned __int16 *)(v16 + 2 * (int)(5 * v22));
    int v29 = *v28;
    int v30 = v28[1];
    int v31 = v28[2];
    int v32 = v28[3];
    unsigned __int16 v33 = (unsigned __int16 *)(v16 + 10 * (int)v27);
    int v34 = 255 - (int)v24;
    int v35 = v33[1];
    uint64_t result = v33[2];
    int v37 = v33[3];
    LODWORD(v28) = v33[4] * (int)v24 + v34 * v28[4];
    LODWORD(v33) = (int)v24 * *v33 + v34 * v29;
    int v38 = (int)v24 * v35 + v34 * v30;
    unsigned int v39 = (int)v24 * result + v34 * v31;
    int v40 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = ((v40 + (v33 >> 8)) << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v40 + (v28 >> 8)) & 0xFF00) >> 8) << 32) | (v38 + (v40 << 8)) & 0xFF0000 | (unint64_t)((unsigned __int16)(v40 + (v39 >> 8)) & 0xFF00) | ((unsigned __int16)(v40 + ((v37 * (int)v24 + v34 * v32) >> 8)) >> 8);
    uint64_t v19 = (v19 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
  return result;
}

void cmyk32_shade_radial_CMYK(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  float v6 = *(float *)(a1 + 280);
  float v7 = *(float *)(a1 + 284);
  float v8 = *(float *)(*(void *)(a1 + 272) + 4);
  float v9 = v8 * (float)(uint64_t)a2;
  float v10 = v8 * (float)(uint64_t)a3;
  float v11 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v10) + (float)(v6 * v9));
  float v12 = *(float *)(a1 + 300) + (float)((float)(v10 * *(float *)(a1 + 292)) + (float)(v7 * v9));
  uint64_t v14 = *(void *)(a1 + 400);
  float v15 = *(float *)(a1 + 336);
  float v16 = *(float *)(a1 + 344);
  float v17 = *(float *)(a1 + 304);
  float v18 = *(float *)(a1 + 308);
  int v19 = *(_DWORD *)(a1 + 324);
  float v20 = *(float *)(v14 + 8);
  float v21 = *(float *)(v14 + 16);
  v5.i32[0] = *(_DWORD *)(v14 + 20);
  float v22 = *(float *)(v14 + 28);
  uint64_t v25 = a1 + 144;
  float v23 = *(char **)(a1 + 144);
  float v24 = *(int8x16_t **)(v25 + 8);
  float v26 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v27 = *(void *)(a1 + 360);
  uint64_t v28 = (a2 >> 8) & 0xF;
  if (v20 != 0.0 || v22 != 0.0 || v7 != 0.0)
  {
    int v39 = *(_DWORD *)(a1 + 320);
    float v40 = *(float *)(v14 + 12);
    float v41 = *(float *)(v14 + 24);
    float v42 = *(float *)(v14 + 32);
    uint64_t v43 = a1 + 368;
    uint64_t v44 = *(void *)(a1 + 368);
    uint64_t v45 = v44 + ((a3 >> 4) & 0xF0);
    BOOL v32 = v44 == 0;
    int v46 = 15;
    if (v32)
    {
      int v46 = 0;
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v43 = v45;
    }
    float v47 = -v41;
    float v48 = v18 - v17;
    while (1)
    {
      float v49 = v47 + (float)((float)(v11 + v11) * v20);
      float v50 = (float)((float)(v12 * v12) + (float)(v11 * v11)) - v22;
      if (*(float *)v5.i32 == 0.0)
      {
        float v57 = v50 / v49;
      }
      else
      {
        float v51 = (float)((float)(*(float *)v5.i32 * -4.0) * v50) + (float)(v49 * v49);
        if (v51 < 0.0) {
          goto LABEL_53;
        }
        float v52 = sqrtf(v51);
        float v53 = v42 * (float)(v49 - v52);
        float v54 = v49 + v52;
        float v55 = v42 * v54;
        BOOL v56 = (float)(v42 * v54) <= v53;
        if ((float)(v42 * v54) <= v53) {
          float v57 = v42 * v54;
        }
        else {
          float v57 = v53;
        }
        if (v56) {
          float v55 = v53;
        }
        if (v55 < 0.0)
        {
          BOOL v58 = v55 < v40;
LABEL_39:
          int v59 = v39;
          if (v58) {
            goto LABEL_53;
          }
LABEL_40:
          if ((v59 & 0x80000000) == 0) {
            goto LABEL_52;
          }
          goto LABEL_53;
        }
        if (v55 <= 1.0)
        {
          float v60 = v17 + (float)(v55 * v48);
          goto LABEL_51;
        }
        if ((v19 & 0x80000000) == 0)
        {
          int v59 = v19;
          if (v55 <= v21)
          {
LABEL_52:
            int8x16_t v61 = (unsigned __int16 *)(v27 + 10 * v59);
            int v62 = v61[1];
            unsigned __int16 v63 = v61[2];
            unsigned __int16 v64 = v61[3];
            int v65 = *(unsigned __int8 *)(v43 + v28);
            int v66 = v65 + *v61;
            unsigned __int16 v67 = v61[4];
            goto LABEL_55;
          }
        }
      }
      if (v57 < 0.0)
      {
        BOOL v58 = v57 < v40;
        goto LABEL_39;
      }
      if (v57 > 1.0)
      {
        int v59 = v19;
        if (v57 > v21) {
          goto LABEL_53;
        }
        goto LABEL_40;
      }
      float v60 = v17 + (float)(v57 * v48);
LABEL_51:
      int v59 = (int)(float)(v16 * (float)(v60 - v15));
      if ((v59 & 0x80000000) == 0) {
        goto LABEL_52;
      }
LABEL_53:
      if (!v26)
      {
        char v68 = 0;
        goto LABEL_57;
      }
      int v62 = v26[1];
      unsigned __int16 v63 = v26[2];
      unsigned __int16 v64 = v26[3];
      int v65 = *(unsigned __int8 *)(v43 + v28);
      int v66 = v65 + *v26;
      unsigned __int16 v67 = v26[4];
LABEL_55:
      v24->i64[0] = (v66 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v65 + v67) & 0xFF00) >> 8) << 32) | ((v65 + v62) << 8) & 0xFF0000 | (unint64_t)((unsigned __int16)(v65 + v63) & 0xFF00) | ((unsigned __int16)(v65 + v64) >> 8);
      char v68 = -1;
LABEL_57:
      uint64_t v28 = (v28 + 1) & v46;
      float v11 = v6 + v11;
      float v12 = v7 + v12;
      float v24 = (int8x16_t *)((char *)v24 + 8);
      *v23++ = v68;
      if (!--a4) {
        return;
      }
    }
  }
  uint64_t v29 = a1 + 368;
  uint64_t v30 = *(void *)(a1 + 368);
  LODWORD(v31) = (BYTE1(a2) + 1) & 0xF;
  BOOL v32 = v30 == 0;
  if (v30) {
    uint64_t v33 = v30 + ((a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v33 = v29;
  }
  if (v32)
  {
    LODWORD(v31) = 0;
    int v34 = 0;
  }
  else
  {
    int v34 = (a2 >> 8) & 0xF;
  }
  if (v32) {
    int v35 = 0;
  }
  else {
    int v35 = 15;
  }
  float v36 = v12 * v12;
  float v37 = -*(float *)v5.i32;
  if (v36 <= (float)-*(float *)v5.i32)
  {
    float v69 = fabsf(*(float *)(v14 + 32));
    float v70 = *(float *)v5.i32 * -4.0;
    float v71 = v18 - v17;
    unint64_t v72 = (unsigned __int16 *)(v27 + 10 * v19);
    int v73 = a4 + 2;
    while (1)
    {
      float v74 = v36 + (float)(v11 * v11);
      float v75 = v6 + v11;
      float v76 = v36 + (float)(v75 * v75);
      if (v74 > v37 && v76 > v37)
      {
        if (v19 < 0)
        {
          if (!v26)
          {
            char v117 = 0;
            char v116 = 0;
            goto LABEL_81;
          }
          int v85 = *v26;
          int v86 = v26[1];
          unsigned __int16 v87 = v26[2];
          unsigned __int16 v88 = v26[3];
          unsigned __int16 v89 = v26[4];
        }
        else
        {
          int v85 = *v72;
          int v86 = v72[1];
          unsigned __int16 v87 = v72[2];
          unsigned __int16 v88 = v72[3];
          unsigned __int16 v89 = v72[4];
        }
        int v109 = *(unsigned __int8 *)(v33 + v34);
        int v110 = v109 + v85;
        int v111 = v109 + v86;
        unsigned __int16 v112 = v109 + v87;
        __int16 v113 = v109 + v88;
        __int16 v114 = v109 + v89;
        int v115 = *(unsigned __int8 *)(v33 + v31);
        int v102 = v115 + v85;
        int v103 = v115 + v86;
        unsigned __int16 v104 = v115 + v87;
        __int16 v105 = v115 + v88;
        __int16 v106 = v115 + v89;
        unint64_t v107 = (v110 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v114 & 0xFF00) >> 8) << 32) | (v111 << 8) & 0xFF0000 | (unint64_t)(v112 & 0xFF00);
        uint64_t v108 = HIBYTE(v113);
        goto LABEL_79;
      }
      float v78 = sqrtf(v70 * v76);
      float v79 = v69 * sqrtf(v70 * v74);
      float v80 = v69 * v78;
      int v81 = (int)(float)(v16 * (float)((float)(v17 + (float)(v79 * v71)) - v15));
      int v82 = (int)(float)(v16 * (float)((float)(v17 + (float)((float)(v69 * v78) * v71)) - v15));
      if (v79 <= 1.0 && v80 <= 1.0)
      {
        float v90 = (unsigned __int16 *)(v27 + 10 * v81);
        float v91 = (unsigned __int16 *)(v27 + 10 * v82);
        int v92 = *v91;
        int v93 = v91[1];
        unsigned __int16 v94 = v91[2];
        unsigned __int16 v95 = v91[3];
        unsigned __int16 v96 = v91[4];
        LODWORD(v91) = *(unsigned __int8 *)(v33 + v34);
        int v97 = v91 + *v90;
        int v98 = v91 + v90[1];
        unsigned __int16 v99 = (_WORD)v91 + v90[2];
        __int16 v100 = (_WORD)v91 + v90[3];
        LOWORD(v90) = (_WORD)v91 + v90[4];
        int v101 = *(unsigned __int8 *)(v33 + v31);
        int v102 = v101 + v92;
        int v103 = v101 + v93;
        unsigned __int16 v104 = v101 + v94;
        __int16 v105 = v101 + v95;
        __int16 v106 = v101 + v96;
        unint64_t v107 = (v97 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((unsigned __int16)v90 & 0xFF00) >> 8) << 32) | (v98 << 8) & 0xFF0000 | (unint64_t)(v99 & 0xFF00);
        uint64_t v108 = HIBYTE(v100);
LABEL_79:
        v24->i64[0] = v107 | v108;
        char v116 = -1;
        goto LABEL_80;
      }
      if (v79 <= 1.0)
      {
        if ((v81 & 0x80000000) == 0)
        {
          uint64_t v84 = 5 * v81;
LABEL_85:
          uint64_t v118 = (unsigned __int16 *)(v27 + 2 * v84);
          int v119 = v118[1];
          unsigned __int16 v120 = v118[2];
          unsigned __int16 v121 = v118[3];
          int v122 = *(unsigned __int8 *)(v33 + v34);
          int v123 = v122 + *v118;
          unsigned __int16 v124 = v118[4];
          goto LABEL_88;
        }
      }
      else if (v79 <= v21)
      {
        uint64_t v84 = 5 * v19;
        if ((v19 & 0x80000000) == 0) {
          goto LABEL_85;
        }
      }
      if (!v26)
      {
        char v116 = 0;
        goto LABEL_89;
      }
      int v119 = v26[1];
      unsigned __int16 v120 = v26[2];
      unsigned __int16 v121 = v26[3];
      int v122 = *(unsigned __int8 *)(v33 + v34);
      int v123 = v122 + *v26;
      unsigned __int16 v124 = v26[4];
LABEL_88:
      v24->i64[0] = (v123 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v122 + v124) & 0xFF00) >> 8) << 32) | ((v122 + v119) << 8) & 0xFF0000 | (unint64_t)((unsigned __int16)(v122 + v120) & 0xFF00) | ((unsigned __int16)(v122 + v121) >> 8);
      char v116 = -1;
LABEL_89:
      if (v80 <= 1.0)
      {
        if (v82 < 0) {
          goto LABEL_96;
        }
        uint64_t v125 = 5 * v82;
      }
      else if (v80 > v21 || (uint64_t v125 = 5 * v19, v19 < 0))
      {
LABEL_96:
        if (!v26)
        {
          char v117 = 0;
          goto LABEL_81;
        }
        int v131 = *(unsigned __int8 *)(v33 + v31);
        int v102 = v131 + *v26;
        int v103 = v131 + v26[1];
        unsigned __int16 v104 = v131 + v26[2];
        __int16 v105 = v131 + v26[3];
        __int16 v106 = v131 + v26[4];
        goto LABEL_80;
      }
      uint64_t v126 = (unsigned __int16 *)(v27 + 2 * v125);
      unsigned __int16 v127 = v126[2];
      unsigned __int16 v128 = v126[3];
      int v129 = *(unsigned __int8 *)(v33 + v31);
      int v102 = v129 + *v126;
      unsigned __int16 v130 = v126[4];
      int v103 = v129 + v126[1];
      unsigned __int16 v104 = v129 + v127;
      __int16 v105 = v129 + v128;
      __int16 v106 = v129 + v130;
LABEL_80:
      v24->i64[1] = (v102 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v106 & 0xFF00) >> 8) << 32) | (v103 << 8) & 0xFF0000 | (unint64_t)(v104 & 0xFF00) | HIBYTE(v105);
      char v117 = -1;
LABEL_81:
      float v11 = v6 + v75;
      LOBYTE(v34) = (v34 + 1) & v35;
      LOBYTE(v31) = (v31 + 1) & v35;
      ++v24;
      *float v23 = v116;
      v23[1] = v117;
      v23 += 2;
      v73 -= 2;
      if (v73 <= 2) {
        return;
      }
    }
  }
  if (v26 || (v19 & 0x80000000) == 0)
  {
    uint64_t v132 = (unsigned __int16 *)(v27 + 10 * v19);
    if (v19 >= 0) {
      uint64_t v133 = v132;
    }
    else {
      uint64_t v133 = v26;
    }
    int32x2_t v134 = vdup_n_s32(v133[4]);
    int32x2_t v135 = vdup_n_s32(*v133);
    int32x2_t v136 = vdup_n_s32(v133[1]);
    int32x2_t v137 = vdup_n_s32(v133[2]);
    int32x2_t v138 = vdup_n_s32(v133[3]);
    int v139 = a4 + 4;
    do
    {
      v5.i8[0] = *(unsigned char *)(v33 + v34);
      v5.i8[4] = *(unsigned char *)(v33 + v31);
      int32x2_t v140 = (int32x2_t)vand_s8(*(int8x8_t *)v5.i8, (int8x8_t)0xFF000000FFLL);
      int32x2_t v141 = vadd_s32(v136, v140);
      int8x8_t v142 = (int8x8_t)vadd_s32(v137, v140);
      uint32x2_t v143 = (uint32x2_t)vadd_s32(v138, v140);
      int32x2_t v144 = vshl_n_s32(vadd_s32(v135, v140), 0x10uLL);
      v145.i64[0] = v144.i32[0] & 0xFF00FFFF;
      v145.i64[1] = v144.i32[1] & 0xFF00FFFF;
      int8x16_t v146 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v134, v140), (int8x8_t)0xFF000000FF00), 0x18uLL), v145);
      int8x8_t v147 = vand_s8((int8x8_t)vshl_n_s32(v141, 8uLL), (int8x8_t)0xFF000000FF0000);
      v145.i64[0] = v147.u32[0];
      v145.i64[1] = v147.u32[1];
      int8x16_t v148 = v145;
      int8x8_t v149 = vand_s8(v142, (int8x8_t)0xFF000000FF00);
      v145.i64[0] = v149.u32[0];
      v145.i64[1] = v149.u32[1];
      int8x16_t v150 = vorrq_s8(v146, vorrq_s8(v148, v145));
      *(uint32x2_t *)v148.i8 = vshr_n_u32(v143, 8uLL);
      v145.i64[0] = v148.i32[0] & 0xFFFFFEFF;
      v145.i64[1] = v148.i32[1] & 0xFFFFFEFF;
      int8x16_t v151 = vorrq_s8(v150, v145);
      *float v24 = v151;
      uint64_t v31 = (v31 + 1) & v35;
      v151.i8[0] = *(unsigned char *)(v33 + ((v34 + 1) & v35));
      v151.i8[4] = *(unsigned char *)(v33 + v31);
      *(int8x8_t *)v151.i8 = vand_s8(*(int8x8_t *)v151.i8, (int8x8_t)0xFF000000FFLL);
      int32x2_t v152 = vadd_s32(v136, *(int32x2_t *)v151.i8);
      int8x8_t v153 = (int8x8_t)vadd_s32(v137, *(int32x2_t *)v151.i8);
      uint32x2_t v154 = (uint32x2_t)vadd_s32(v138, *(int32x2_t *)v151.i8);
      *(int32x2_t *)v148.i8 = vshl_n_s32(vadd_s32(v135, *(int32x2_t *)v151.i8), 0x10uLL);
      v145.i64[0] = v148.i32[0] & 0xFF00FFFF;
      v145.i64[1] = v148.i32[1] & 0xFF00FFFF;
      int8x16_t v155 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v134, *(int32x2_t *)v151.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v145);
      *(int8x8_t *)v148.i8 = vand_s8((int8x8_t)vshl_n_s32(v152, 8uLL), (int8x8_t)0xFF000000FF0000);
      v145.i64[0] = v148.u32[0];
      v145.i64[1] = v148.u32[1];
      int8x16_t v156 = v145;
      int8x8_t v157 = vand_s8(v153, (int8x8_t)0xFF000000FF00);
      v145.i64[0] = v157.u32[0];
      v145.i64[1] = v157.u32[1];
      int8x16_t v158 = vorrq_s8(v155, vorrq_s8(v156, v145));
      *(uint32x2_t *)v156.i8 = vshr_n_u32(v154, 8uLL);
      v145.i64[0] = v156.i32[0] & 0xFFFFFEFF;
      v145.i64[1] = v156.i32[1] & 0xFFFFFEFF;
      *(_DWORD *)float v23 = -1;
      v23 += 4;
      v139 -= 4;
      int8x16_t v5 = vorrq_s8(v158, v145);
      v24[1] = v5;
      v24 += 2;
      int v34 = (v34 + 1) & v35;
    }
    while (v139 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v38 = 4;
    }
    else {
      int v38 = a4;
    }
    bzero(v23, ((a4 - v38 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t cmyk32_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  memset(v48, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v31, (uint64_t)v48) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = 134759444;
  unsigned int v19 = *(_DWORD *)a3;
  *((void *)&v31 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 134759444)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        int v22 = 255;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
        int v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v21 = 0;
            int v22 = 16;
            break;
          case 5u:
            char v21 = 0;
            int v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v21 = 0;
            int v22 = 32;
            break;
          case 8u:
            char v21 = 0;
            int v22 = 8;
            break;
          case 9u:
            char v21 = 0;
            int v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(void *)&long long v31 = *(void *)&CMYK8_image_sample[2 * v20 + 2];
      if ((void)v31)
      {
LABEL_28:
        DWORD2(v31) = v18;
        if ((v21 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v32) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              DWORD2(v31) = *(_DWORD *)a3;
              uint64_t v25 = cmyk32_image_mark_RGB32;
              goto LABEL_51;
            case 1u:
              DWORD2(v31) = *(_DWORD *)a3;
              float v26 = cmyk32_image_mark_RGB32;
              goto LABEL_53;
            case 2u:
              DWORD2(v31) = *(_DWORD *)a3;
              uint64_t v25 = (unint64_t (*)(unint64_t, int *, int, int, int, int))cmyk32_image_mark_W8;
              goto LABEL_51;
            case 3u:
              DWORD2(v31) = *(_DWORD *)a3;
              uint64_t v25 = cmyk32_image_mark_RGB24;
              goto LABEL_51;
            case 4u:
              DWORD2(v31) = *(_DWORD *)a3;
              uint64_t v25 = cmyk32_image_mark_rgb32;
LABEL_51:
              uint64_t v27 = v25;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 0;
              break;
            case 5u:
              DWORD2(v31) = *(_DWORD *)a3;
              float v26 = cmyk32_image_mark_rgb32;
LABEL_53:
              uint64_t v27 = v26;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 8;
              break;
            default:
              goto LABEL_29;
          }
          cmyk32_image_mark_image(v28, (uint64_t)&v31, v29, v30, (void (*)(void, void))v27);
          return 1;
        }
        goto LABEL_29;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 0x10)
      {
        *(void *)&long long v31 = *(void *)&CMYK16_image_sample[2 * v20 + 2];
        if ((void)v31)
        {
          int v18 = 269501476;
          int v23 = 16;
LABEL_27:
          LODWORD(v32) = v23;
          goto LABEL_28;
        }
      }
      *(void *)&long long v31 = *(void *)&CMYKF_image_sample[2 * v20 + 2];
      if ((void)v31)
      {
        int v18 = 538985509;
        int v23 = 20;
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(void)v42 && (~DWORD1(v32) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((BYTE4(v32) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      cmyk32_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(void *)&long long v31 = cmyk32_sample_cmyk32;
LABEL_29:
  cmyk32_image_mark((uint64_t)a2, (uint64_t)&v31, v8, v17);
  return 1;
}

uint64_t cmyk32_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v867 = *MEMORY[0x1E4F143B8];
  int v10 = *(_DWORD *)v3;
  uint64_t v11 = *(unsigned __int8 **)(v3 + 96);
  uint64_t v12 = *(void *)(v3 + 48);
  int v13 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                  + 16 * *(_DWORD *)v3
                  + 8 * (v11 == 0)
                  + 4 * (v12 == 0));
  if (v13 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v15 = v3;
  unint64_t v16 = *(unsigned int *)(v3 + 4);
  unsigned int v17 = v16 - 1;
  if ((int)v16 < 1) {
    return 0;
  }
  int v18 = *(_DWORD *)(v15 + 8);
  uint64_t v19 = (v18 - 1);
  if (v18 < 1) {
    return 0;
  }
  if (v13 >= 24 && **(_DWORD **)v2 == 134759428) {
    v13 += 4;
  }
  unsigned int v20 = *(uint16x4_t **)(v15 + 136);
  if ((v10 & 0xFF0000) == 0x50000 || !v20)
  {
    int v22 = v10 & 0xFF00;
    int v792 = v13;
    unint64_t v787 = v15;
    if (v22 == 1024)
    {
      v866[0] = v16;
      v856[0] = v18;
      if (v11) {
        int v23 = *v11;
      }
      else {
        int v23 = 255;
      }
      unsigned int v34 = **(_DWORD **)(v15 + 88);
      uint64_t v36 = *(int *)(v15 + 12);
      uint64_t v35 = *(int *)(v15 + 16);
      unint64_t v37 = (unint64_t)*(int *)(v15 + 28) >> 2;
      if (v12)
      {
        uint64_t v837 = *(int *)(v15 + 32);
        v835 = (char *)(v12 + v36 + (int)v837 * (uint64_t)(int)v35);
        unsigned int v831 = 1;
      }
      else
      {
        v835 = 0;
        uint64_t v837 = 0;
        unsigned int v831 = 0;
      }
      unsigned __int8 v43 = ~(_BYTE)v23;
      long long v44 = (uint32x4_t *)(*(void *)(v15 + 40) + 4 * (v36 + v35 * v37));
      v833 = v44;
      unint64_t v799 = (unint64_t)*(int *)(v15 + 28) >> 2;
      if (!v20)
      {
        v842 = 0;
        if (v12) {
          unint64_t v47 = v16;
        }
        else {
          unint64_t v47 = 0;
        }
        long long v46 = v835;
        uint64_t v853 = v837 - v47;
        unint64_t v48 = v16;
        goto LABEL_69;
      }
      shape_enum_clip_alloc(v2, v16, (int *)v20, 1, 1, 1, *(_DWORD *)(v15 + 104), *(_DWORD *)(v15 + 108), v16, v18);
      long long v46 = v835;
      uint64_t v853 = v837;
      if (!v45) {
        return 1;
      }
      while (1)
      {
        v842 = (void *)v45;
        if (!shape_enum_clip_next(v45, (int *)&v855 + 1, &v855, v866, v856)) {
          break;
        }
        long long v44 = (uint32x4_t *)((char *)v44 + 4 * v37 * (int)v855 + 4 * SHIDWORD(v855));
        unint64_t v48 = v866[0];
        if (v12) {
          long long v46 = &v835[(int)v837 * (uint64_t)(int)v855 + SHIDWORD(v855)];
        }
        uint64_t v186 = v853;
        if (v12) {
          uint64_t v186 = v837 - v866[0];
        }
        uint64_t v853 = v186;
        LODWORD(v16) = v866[0];
LABEL_69:
        unint64_t v851 = v37 - v48;
        int v804 = v16;
        switch(v13)
        {
          case 0:
            uint64_t v71 = v851 + (int)v16;
            int v72 = v16;
            int v73 = v856[0];
            uint64_t v852 = v856[0] - 1;
            float v74 = &v44->i8[4 * ((v71 * v852) & (v71 >> 63))];
            if (v71 < 0) {
              uint64_t v71 = -v71;
            }
            CGBlt_fillBytes(4 * v16, v856[0], 0, v74, 4 * v71);
            if (v12)
            {
              uint64_t v75 = v853 + v72;
              v46 += (v75 * v852) & (v75 >> 63);
              if (v75 >= 0) {
                uint64_t v76 = v853 + v72;
              }
              else {
                uint64_t v76 = -v75;
              }
              int v77 = v72;
              unsigned int v78 = v73;
              int v79 = 0;
              goto LABEL_88;
            }
            break;
          case 1:
            uint64_t v840 = (int)v16;
            uint64_t v80 = v851 + (int)v16;
            if (v80 < 0)
            {
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v80 * (v856[0] - 1));
              uint64_t v80 = -v80;
            }
            int v81 = 0;
            int v82 = *(int **)(v787 + 88);
            if (v82) {
              int v81 = *v82;
            }
            int v83 = v16;
            int v84 = v856[0];
            CGBlt_fillBytes(4 * v16, v856[0], v81, v44->i8, 4 * v80);
            if (v12)
            {
              unsigned int v78 = v84;
              int v85 = *(int **)(v787 + 96);
              if (!v85) {
                int v85 = (int *)&PIXELALPHAPLANARCONSTANT_17534;
              }
              v46 += ((v853 + v840) * (v84 - 1)) & ((v853 + v840) >> 63);
              if (v853 + v840 >= 0) {
                uint64_t v76 = v853 + v840;
              }
              else {
                uint64_t v76 = -(v853 + v840);
              }
              int v79 = *v85;
              int v77 = v83;
LABEL_88:
              uint64_t v853 = v76;
              CGBlt_fillBytes(v77, v78, v79, v46, v76);
            }
            break;
          case 2:
            uint64_t v86 = 4 * v831;
            if (v12)
            {
              int v826 = v16 & 3;
              int v87 = v856[0];
              unsigned int v801 = (v16 >> 2) + 1;
              do
              {
                int v841 = v87;
                if ((int)v16 < 4)
                {
                  int v92 = v16;
                }
                else
                {
                  unsigned __int16 v88 = v46 + 3;
                  unsigned int v89 = v801;
                  do
                  {
                    DAplusDAM(v44, v88 - 3, v34, v23, v44->i32[0], *(v88 - 3), ~(_BYTE)v23);
                    DAplusDAM(&v44->i32[1], v88 - 2, v34, v23, v44->u32[1], *(v88 - 2), ~(_BYTE)v23);
                    DAplusDAM(&v44->i32[2], v88 - 1, v34, v23, v44->u32[2], *(v88 - 1), ~(_BYTE)v23);
                    unsigned int v91 = v44->u32[3];
                    float v90 = &v44->i32[3];
                    DAplusDAM(v90, v88, v34, v23, v91, *v88, ~(_BYTE)v23);
                    long long v44 = (uint32x4_t *)(v90 + 1);
                    v88 += v86;
                    --v89;
                  }
                  while (v89 > 1);
                  long long v46 = v88 - 3;
                  int v92 = v826;
                }
                if (v92 < 1)
                {
                  unsigned __int16 v94 = (unsigned int *)v44;
                }
                else
                {
                  unsigned int v93 = v92 + 1;
                  unsigned __int16 v94 = (unsigned int *)v44;
                  do
                  {
                    unsigned int v95 = *v94++;
                    DAplusDAM(v44, v46, v34, v23, v95, *v46, ~(_BYTE)v23);
                    v46 += v831;
                    --v93;
                    long long v44 = (uint32x4_t *)v94;
                  }
                  while (v93 > 1);
                }
                long long v44 = (uint32x4_t *)&v94[v851];
                v46 += v853;
                int v87 = v841 - 1;
                v856[0] = v841 - 1;
                LODWORD(v16) = v804;
              }
              while (v841 != 1);
              goto LABEL_404;
            }
            int32x4_t v168 = vdupq_n_s32(~(_BYTE)v23);
            int32x4_t v169 = vdupq_n_s32(v34);
            v170.i64[0] = 0x1000100010001;
            v170.i64[1] = 0x1000100010001;
            do
            {
              int v171 = v866[0];
              if (v866[0] >= 4)
              {
                unsigned int v172 = (v866[0] >> 2) + 1;
                do
                {
                  v173.i16[0] = v44->u8[0];
                  v173.i16[1] = BYTE2(v44->u32[0]);
                  v173.i16[2] = BYTE4(v44->i64[0]);
                  v173.i16[3] = BYTE6(v44->i64[0]);
                  v173.i16[4] = v44->i64[1];
                  v173.i16[5] = BYTE2(v44->i64[1]);
                  v173.i16[6] = BYTE12(*(unsigned long long *)v44);
                  v173.i16[7] = BYTE14(*(unsigned long long *)v44);
                  int32x4_t v174 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v44, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v168);
                  int32x4_t v175 = vmulq_s32(v173, v168);
                  *(int32x4_t *)v44++ = vaddq_s32(vaddq_s32((int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v174, v170), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v174, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00)), v169), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v175, v170), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v175, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)));
                  v46 += v86;
                  --v172;
                }
                while (v172 > 1);
                v171 &= 3u;
              }
              if (v171 >= 1)
              {
                unsigned int v176 = v171 + 1;
                do
                {
                  v44->i32[0] = (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43
                                + 65537
                                + ((((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                              + v34
                              + ((((v44->i32[0] & 0xFF00FF) * v43
                                 + 65537
                                 + ((((v44->i32[0] & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                  long long v44 = (uint32x4_t *)((char *)v44 + 4);
                  --v176;
                }
                while (v176 > 1);
                v46 += v171 * v831;
              }
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            int v13 = v792;
            break;
          case 3:
            unint64_t v96 = v37;
            do
            {
              int v97 = v866[0];
              do
              {
                int v98 = *v46;
                if (v98 == 255)
                {
                  v44->i32[0] = v34;
                  LOBYTE(v99) = v23;
                }
                else if (*v46)
                {
                  unint64_t v100 = PDAM_5699(v34, v23, v98);
                  v44->i32[0] = v100;
                  unint64_t v99 = HIDWORD(v100);
                }
                else
                {
                  LOBYTE(v99) = 0;
                  v44->i32[0] = 0;
                }
                char *v46 = v99;
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v97;
              }
              while (v97);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 4:
            unint64_t v96 = v37;
            do
            {
              int v101 = v866[0];
              do
              {
                if (~*v46 == 255)
                {
                  v44->i32[0] = v34;
                  LOBYTE(v102) = v23;
                }
                else if (*v46 == -1)
                {
                  LOBYTE(v102) = 0;
                  v44->i32[0] = 0;
                }
                else
                {
                  unint64_t v103 = PDAM_5699(v34, v23, ~*v46);
                  v44->i32[0] = v103;
                  unint64_t v102 = HIDWORD(v103);
                }
                char *v46 = v102;
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v101;
              }
              while (v101);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_136;
          case 5:
            int v104 = v856[0];
            do
            {
              int v105 = v16;
              __int16 v106 = (unsigned int *)v44;
              do
              {
                unsigned int v107 = *v106++;
                DAMplusDAM((unsigned int *)v44, v46, v34, v23, *v46, v107, *v46, ~(_BYTE)v23);
                v46 += v831;
                long long v44 = (uint32x4_t *)v106;
                --v105;
              }
              while (v105);
              long long v44 = (uint32x4_t *)&v106[v851];
              v46 += v853;
              v856[0] = --v104;
              LODWORD(v16) = v804;
            }
            while (v104);
            goto LABEL_404;
          case 6:
            unint64_t v96 = v37;
            do
            {
              int v108 = v866[0];
              do
              {
                if (*v46 != -1)
                {
                  if (~*v46 == 255)
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                  else
                  {
                    DAplusDAM(v44, v46, v44->i32[0], *v46, v34, v23, ~*v46);
                  }
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v108;
              }
              while (v108);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
LABEL_136:
            int v13 = v792;
            goto LABEL_380;
          case 7:
            if (v12)
            {
              unint64_t v96 = v37;
              do
              {
                int v109 = v866[0];
                do
                {
                  unint64_t v110 = PDAM_5699(v44->i32[0], *v46, v23);
                  v44->i32[0] = v110;
                  long long v44 = (uint32x4_t *)((char *)v44 + 4);
                  char *v46 = BYTE4(v110);
                  v46 += v831;
                  --v109;
                }
                while (v109);
                long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_380;
            }
            do
            {
              int v177 = v866[0];
              unsigned int v178 = v866[0] - 1;
              do
              {
                v44->i32[0] = (((v44->i32[0] & 0xFF00FF) * v23
                              + 65537
                              + ((((v44->i32[0] & 0xFF00FFu) * v23) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | ((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v23 + 65537 + ((((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v23) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                --v177;
              }
              while (v177);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853 + v831 + v831 * (unint64_t)v178;
              --v856[0];
            }
            while (v856[0]);
            break;
          case 8:
            if (v12)
            {
              unint64_t v96 = v37;
              do
              {
                int v111 = v866[0];
                do
                {
                  unint64_t v112 = PDAM_5699(v44->i32[0], *v46, ~(_BYTE)v23);
                  v44->i32[0] = v112;
                  long long v44 = (uint32x4_t *)((char *)v44 + 4);
                  char *v46 = BYTE4(v112);
                  v46 += v831;
                  --v111;
                }
                while (v111);
                long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853;
                --v856[0];
              }
              while (v856[0]);
LABEL_380:
              unint64_t v37 = v96;
            }
            else
            {
              do
              {
                int v179 = v866[0];
                unsigned int v180 = v866[0] - 1;
                do
                {
                  v44->i32[0] = (((v44->i32[0] & 0xFF00FF) * v43
                                + 65537
                                + ((((v44->i32[0] & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | ((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43 + 65537 + ((((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  long long v44 = (uint32x4_t *)((char *)v44 + 4);
                  --v179;
                }
                while (v179);
                long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853 + v831 + v831 * (unint64_t)v180;
                --v856[0];
              }
              while (v856[0]);
            }
            break;
          case 9:
            int v113 = v856[0];
            do
            {
              int v114 = v16;
              int v115 = (unsigned int *)v44;
              do
              {
                unsigned int v116 = *v115++;
                DAMplusDAM((unsigned int *)v44, v46, v34, v23, *v46 ^ 0xFF, v116, *v46, v23);
                v46 += v831;
                long long v44 = (uint32x4_t *)v115;
                --v114;
              }
              while (v114);
              long long v44 = (uint32x4_t *)&v115[v851];
              v46 += v853;
              v856[0] = --v113;
              LODWORD(v16) = v804;
            }
            while (v113);
            goto LABEL_404;
          case 10:
            int v117 = v856[0];
            do
            {
              int v118 = v16;
              int v119 = (unsigned int *)v44;
              do
              {
                unsigned int v120 = *v119++;
                DAMplusDAM((unsigned int *)v44, v46, v34, v23, *v46 ^ 0xFF, v120, *v46, ~(_BYTE)v23);
                v46 += v831;
                long long v44 = (uint32x4_t *)v119;
                --v118;
              }
              while (v118);
              long long v44 = (uint32x4_t *)&v119[v851];
              v46 += v853;
              v856[0] = --v117;
              LODWORD(v16) = v804;
            }
            while (v117);
            goto LABEL_404;
          case 11:
            if (v12)
            {
              int v121 = v856[0];
              do
              {
                int v122 = v16;
                int v123 = (int *)v44;
                do
                {
                  int v124 = *v123++;
                  DAplusdDA(v44, v46, v124, *v46, v34, v23);
                  v46 += v831;
                  long long v44 = (uint32x4_t *)v123;
                  --v122;
                }
                while (v122);
                long long v44 = (uint32x4_t *)&v123[v851];
                v46 += v853;
                v856[0] = --v121;
                LODWORD(v16) = v804;
              }
              while (v121);
            }
            else
            {
              unint64_t v181 = v831 + v831 * (unint64_t)(v16 - 1);
              int v182 = v856[0];
              do
              {
                int v183 = v16;
                unsigned int v184 = (int *)v44;
                do
                {
                  int v185 = *v184++;
                  DplusdDA((unsigned int *)v44, v185, v34, v23);
                  long long v44 = (uint32x4_t *)v184;
                  --v183;
                }
                while (v183);
                long long v44 = (uint32x4_t *)&v184[v851];
                v46 += v181 + v853;
                v856[0] = --v182;
                LODWORD(v16) = v804;
              }
              while (v182);
            }
LABEL_404:
            int v13 = v792;
            unint64_t v37 = v799;
            break;
          case 12:
            int v125 = (v34 >> 8) & 0xFF00FF;
            int v126 = v34 & 0xFF00FF;
            if (v12)
            {
              do
              {
                int v127 = v866[0];
                do
                {
                  unsigned int v128 = *v46 + v23;
                  unsigned int v129 = (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) << 8) & 0xFF00FF00 | ((v44->i32[0] & 0xFF00FF) + v126) & 0xFF00FF | (15 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001)) | (240 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001));
                  if (v128 >= 0xFF) {
                    LOBYTE(v128) = -1;
                  }
                  char *v46 = v128;
                  v44->i32[0] = v129;
                  long long v44 = (uint32x4_t *)((char *)v44 + 4);
                  v46 += v831;
                  --v127;
                }
                while (v127);
                long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853;
                --v856[0];
              }
              while (v856[0]);
            }
            else
            {
              do
              {
                int v187 = v866[0];
                unsigned int v188 = v866[0] - 1;
                do
                {
                  v44->i32[0] = (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) << 8) & 0xFF00FF00 | ((v44->i32[0] & 0xFF00FF) + v126) & 0xFF00FF | (15 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001)) | (240 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001));
                  long long v44 = (uint32x4_t *)((char *)v44 + 4);
                  --v187;
                }
                while (v187);
                long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853 + v831 + v831 * (unint64_t)v188;
                --v856[0];
              }
              while (v856[0]);
            }
            break;
          case 13:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v130 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v131 = PDAmultiplyPDA_5700(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v131;
                    char *v46 = BYTE4(v131);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAmultiplyPDA_5700(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v130;
              }
              while (v130);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 14:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v132 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v133 = PDAscreenPDA_5701(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v133;
                    char *v46 = BYTE4(v133);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAscreenPDA_5701(v44->i32[0], 0xFFu, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v132;
              }
              while (v132);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 15:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v134 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v135 = PDAoverlayPDA_5702(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v135;
                    char *v46 = BYTE4(v135);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAoverlayPDA_5702(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v134;
              }
              while (v134);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 16:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v136 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v137 = PDAdarkenPDA_5704(v44->i32[0], *v46, v34, v23, v4, v5, v6, v7, v8, v9);
                    v44->i32[0] = v137;
                    char *v46 = BYTE4(v137);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAdarkenPDA_5704(v44->i32[0], 0xFFu, v34, v23, v4, v5, v6, v7, v8, v9);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v136;
              }
              while (v136);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 17:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v138 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v139 = PDAlightenPDA_5703(v44->i32[0], *v46, v34, v23, v4, v5, v6, v7, v8, v9);
                    v44->i32[0] = v139;
                    char *v46 = BYTE4(v139);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAlightenPDA_5703(v44->i32[0], 0xFFu, v34, v23, v4, v5, v6, v7, v8, v9);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v138;
              }
              while (v138);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 18:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v140 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v141 = PDAcolordodgePDA_5705(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v141;
                    char *v46 = BYTE4(v141);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAcolordodgePDA_5705(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v140;
              }
              while (v140);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 19:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v142 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v143 = PDAcolorburnPDA_5706(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v143;
                    char *v46 = BYTE4(v143);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAcolorburnPDA_5706(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v142;
              }
              while (v142);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 20:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v144 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v145 = PDAsoftlightPDA_5708(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v145;
                    char *v46 = BYTE4(v145);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAsoftlightPDA_5708(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v144;
              }
              while (v144);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 21:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v146 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v147 = PDAhardlightPDA_5707(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v147;
                    char *v46 = BYTE4(v147);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAhardlightPDA_5707(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v146;
              }
              while (v146);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 22:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v148 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v149 = PDAdifferencePDA_5709(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v149;
                    char *v46 = BYTE4(v149);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAdifferencePDA_5709(v44->i32[0], 0xFFu, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v148;
              }
              while (v148);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 23:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v150 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v151 = PDAexclusionPDA_5710(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v151;
                    char *v46 = BYTE4(v151);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAexclusionPDA_5710(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v150;
              }
              while (v150);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 24:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v152 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v153 = PDAhuePDA_5711(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v153;
                    char *v46 = BYTE4(v153);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAhuePDA_5711(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v152;
              }
              while (v152);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 25:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v154 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v155 = PDAsaturationPDA_5712(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v155;
                    char *v46 = BYTE4(v155);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAsaturationPDA_5712(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v154;
              }
              while (v154);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 26:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v156 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v157 = PDAluminosityPDA_5713(v34, v23, v44->i32[0], *v46);
                    v44->i32[0] = v157;
                    char *v46 = BYTE4(v157);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAluminosityPDA_5713(v34, v23, v44->i32[0], 255);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v156;
              }
              while (v156);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 27:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v158 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v159 = PDAluminosityPDA_5713(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v159;
                    char *v46 = BYTE4(v159);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAluminosityPDA_5713(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v158;
              }
              while (v158);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 28:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v160 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v161 = PDAtranspose_huePDA(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v161;
                    char *v46 = BYTE4(v161);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_huePDA(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v160;
              }
              while (v160);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 29:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v162 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v163 = PDAtranspose_saturationPDA(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v163;
                    char *v46 = BYTE4(v163);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_saturationPDA(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v162;
              }
              while (v162);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 30:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v164 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v165 = PDAtranspose_luminosityPDA(v34, v23, v44->i32[0], *v46);
                    v44->i32[0] = v165;
                    char *v46 = BYTE4(v165);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_luminosityPDA(v34, v23, v44->i32[0], 255);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v164;
              }
              while (v164);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 31:
            if (!v23) {
              break;
            }
            unint64_t v96 = v37;
            do
            {
              int v166 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    unint64_t v167 = PDAtranspose_luminosityPDA(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v167;
                    char *v46 = BYTE4(v167);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    char *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_luminosityPDA(v44->i32[0], 255, v34, v23);
                }
                long long v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v166;
              }
              while (v166);
              long long v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          default:
            break;
        }
        long long v44 = v833;
        uint64_t v45 = (uint64_t)v842;
        if (!v842) {
          return 1;
        }
        uint64_t v855 = 0;
      }
      float v54 = v842;
      goto LABEL_1120;
    }
    v866[0] = v16;
    v856[0] = v18;
    uint64_t v24 = *(void *)(v15 + 88);
    uint64_t v26 = *(int *)(v15 + 12);
    uint64_t v25 = *(int *)(v15 + 16);
    unint64_t v27 = (unint64_t)*(int *)(v15 + 28) >> 2;
    if (v12)
    {
      uint64_t v790 = *(int *)(v15 + 32);
      v791 = (char *)(v12 + v26 + (int)v790 * (uint64_t)(int)v25);
      uint64_t v850 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v790 = 0;
      v791 = 0;
      uint64_t v850 = 0;
    }
    unint64_t v789 = *(void *)(v15 + 40) + 4 * (v26 + v25 * v27);
    int v38 = *(_DWORD *)(v15 + 56);
    int v39 = *(_DWORD *)(v15 + 60);
    unint64_t v40 = (unint64_t)*(int *)(v15 + 76) >> 2;
    if (v22 != 256)
    {
      int v797 = *(_DWORD *)(v15 + 64);
      int v796 = *(_DWORD *)(v15 + 68);
      if (v11)
      {
        uint64_t v41 = *(int *)(v15 + 80);
        int v42 = 1;
      }
      else
      {
        uint64_t v41 = 0;
        int v42 = 0;
      }
      unint64_t v58 = v24 + 4 * v40 * v796;
      uint64_t v59 = v850 & 1;
      if (v20)
      {
        unint64_t v836 = (unint64_t)*(int *)(v15 + 76) >> 2;
        v838 = *(int **)(v15 + 88);
        int v785 = *(_DWORD *)(v15 + 60);
        int v786 = *(_DWORD *)(v15 + 56);
        v850 &= 1u;
        int v854 = v42;
        int v57 = 1;
        float v55 = v838;
        goto LABEL_57;
      }
      uint64_t v832 = v790 - (v59 * v16);
      if (v24)
      {
        int v803 = v16;
        unint64_t v834 = v24 + 4 * v40 * v796;
        unint64_t v836 = (unint64_t)*(int *)(v15 + 76) >> 2;
        uint64_t v66 = v39 % v796;
        int v785 = v39 % v796;
        uint64_t v788 = *(void *)(v15 + 88);
        unint64_t v67 = v24 + 4 * v40 * v66;
        int v68 = v38 % v797;
        float v55 = (int *)(v67 + 4 * v68);
        unint64_t v65 = v67 + 4 * v797;
        int v786 = v68;
        uint64_t v798 = 0;
        if (v11)
        {
          int v793 = 1;
          int v42 = 1;
          float v69 = (unsigned int *)v789;
          int v62 = v791;
          v838 = (int *)(v67 + 4 * v68);
          uint64_t v839 = (uint64_t)&v11[(int)v41 * (uint64_t)(int)v66 + v68];
          unsigned __int16 v63 = (unsigned __int8 *)v839;
        }
        else
        {
          unsigned __int16 v63 = 0;
          v838 = (int *)(v67 + 4 * v68);
          uint64_t v839 = 0;
          int v793 = 1;
          float v69 = (unsigned int *)v789;
          int v62 = v791;
        }
        unint64_t v64 = v16;
        goto LABEL_418;
      }
      int v785 = *(_DWORD *)(v15 + 60);
      int v786 = *(_DWORD *)(v15 + 56);
      float v55 = 0;
      unint64_t v65 = 0;
      int v793 = 1;
      unint64_t v64 = v16;
LABEL_65:
      uint64_t v798 = 0;
      v838 = 0;
      uint64_t v839 = (uint64_t)v11;
      unint64_t v834 = 0;
      unint64_t v836 = v40 - v64;
      int v803 = v16;
      v41 -= v42 * (int)v16;
      uint64_t v788 = (uint64_t)v55;
      float v69 = (unsigned int *)v789;
      int v62 = v791;
      unsigned __int16 v63 = v11;
      goto LABEL_418;
    }
    if (v11)
    {
      uint64_t v41 = *(int *)(v15 + 80);
      v11 += v38 + (int)v41 * (uint64_t)v39;
      int v42 = -1;
    }
    else
    {
      uint64_t v41 = 0;
      int v42 = 0;
    }
    float v55 = (int *)(v24 + 4 * (v38 + v39 * v40));
    if (v40 == v27 && (uint64_t)(v789 - (void)v55) >= 1)
    {
      if (v16 >= (v789 - (unint64_t)v55) >> 2)
      {
        v789 += 4 * v17;
        v791 += v850 & v17;
        v11 += v42 & v17;
        int v57 = -1;
        unint64_t v40 = (unint64_t)*(int *)(v15 + 28) >> 2;
        v55 += v17;
        goto LABEL_52;
      }
      unint64_t v56 = v27 * v19;
      if (v789 <= (unint64_t)&v55[v27 * v19 + v17])
      {
        unint64_t v40 = -(uint64_t)v27;
        float v70 = &v791[v790 * v19];
        uint64_t v790 = -v790;
        v791 = v70;
        v850 &= 1u;
        v11 += v41 * v19;
        uint64_t v41 = -v41;
        v42 &= 1u;
        int v57 = 1;
        v55 += v27 * v19;
        unint64_t v27 = -(uint64_t)v27;
        v789 += 4 * v56;
        goto LABEL_52;
      }
    }
    v850 &= 1u;
    v42 &= 1u;
    int v57 = 1;
LABEL_52:
    int v785 = *(_DWORD *)(v15 + 60);
    int v786 = *(_DWORD *)(v15 + 56);
    if (v20)
    {
      int v854 = v42;
      unint64_t v58 = 0;
      unint64_t v836 = v40;
      v838 = 0;
      uint64_t v24 = -1;
      int v796 = v41;
      int v797 = v40;
LABEL_57:
      unint64_t v843 = v24;
      int v793 = v57;
      shape_enum_clip_alloc(v24, v16, (int *)v20, v57, v27, 1, *(_DWORD *)(v15 + 104), *(_DWORD *)(v15 + 108), v16, v18);
      uint64_t v788 = (uint64_t)v55;
      uint64_t v61 = v60;
      int v62 = v791;
      unsigned __int16 v63 = v11;
      uint64_t v839 = (uint64_t)v11;
      uint64_t v832 = v790;
      if (!v60) {
        return 1;
      }
      while (2)
      {
        if (!shape_enum_clip_next(v61, (int *)&v855 + 1, &v855, v866, v856))
        {
          float v54 = (void *)v61;
LABEL_1120:
          free(v54);
          return 1;
        }
        uint64_t v798 = v61;
        if (v58)
        {
          unint64_t v834 = v58;
          float v69 = (unsigned int *)(v789 + 4 * v27 * (int)v855 + 4 * SHIDWORD(v855));
          int v635 = ((int)v855 + *(_DWORD *)(v15 + 60)) % v796;
          unint64_t v64 = v866[0];
          int v636 = (HIDWORD(v855) + *(_DWORD *)(v15 + 56)) % v797;
          unint64_t v637 = v788 + 4 * v836 * v635;
          int v638 = (int *)(v637 + 4 * v636);
          unint64_t v65 = v637 + 4 * v797;
          uint64_t v59 = v850;
          if (v850) {
            int v62 = &v791[v790 * (int)v855 + SHIDWORD(v855)];
          }
          uint64_t v639 = v832;
          if (v850) {
            uint64_t v639 = v790 - v866[0];
          }
          uint64_t v832 = v639;
          if (v854) {
            int v42 = v854;
          }
          else {
            int v42 = 0;
          }
          if (v854) {
            unsigned __int16 v63 = &v11[v41 * v635 + v636];
          }
          float v640 = (unsigned __int8 *)v839;
          if (v854) {
            float v640 = &v11[v41 * v635 + v636];
          }
          v838 = v638;
          uint64_t v839 = (uint64_t)v640;
          int v803 = v866[0];
          float v55 = v638;
          int v785 = ((int)v855 + *(_DWORD *)(v15 + 60)) % v796;
          int v786 = (HIDWORD(v855) + *(_DWORD *)(v15 + 56)) % v797;
        }
        else
        {
          uint64_t v641 = SHIDWORD(v855) * (uint64_t)v793;
          int v803 = v866[0];
          float v69 = (unsigned int *)(v789 + 4 * v27 * (int)v855 + 4 * v641);
          unint64_t v64 = v866[0] * v793;
          float v55 = (int *)(v788 + 4 * (int)v855 * v797 + 4 * v641);
          unint64_t v836 = v797 - v866[0] * v793;
          uint64_t v59 = v850;
          if (v850) {
            int v62 = &v791[v790 * (int)v855 + SHIDWORD(v855) * (uint64_t)v793];
          }
          uint64_t v642 = v832;
          if (v850) {
            uint64_t v642 = v790 - v866[0] * v793;
          }
          uint64_t v832 = v642;
          if (v854) {
            int v42 = v854;
          }
          else {
            int v42 = 0;
          }
          unint64_t v834 = 0;
          if (v854)
          {
            unsigned __int16 v63 = &v11[(int)v855 * v796 + v641];
            uint64_t v41 = v796 - (int)v64;
          }
          unint64_t v65 = v843;
        }
LABEL_418:
        uint64_t v850 = v59;
        int v854 = v42;
        uint64_t v800 = v41;
        unint64_t v802 = v27 - v64;
        unint64_t v795 = v27;
        switch(v13)
        {
          case 0:
            unint64_t v843 = v65;
            uint64_t v189 = v802 - v803;
            unsigned int v190 = &v69[-v803 + 1];
            if (v793 >= 0)
            {
              unsigned int v190 = v69;
              uint64_t v189 = v802 + v803;
            }
            unsigned int v191 = v856[0];
            uint64_t v192 = v856[0] - 1;
            unint64_t v193 = (char *)&v190[(v189 * v192) & (v189 >> 63)];
            if (v189 < 0) {
              uint64_t v189 = -v189;
            }
            CGBlt_fillBytes(4 * v803, v856[0], 0, v193, 4 * v189);
            if (v850)
            {
              uint64_t v194 = v832 - v803;
              uint64_t v195 = &v62[-v803 + 1];
              if (v793 >= 0)
              {
                uint64_t v195 = v62;
                uint64_t v194 = v832 + v803;
              }
              uint64_t v196 = (v194 * v192) & (v194 >> 63);
              if (v194 >= 0) {
                uint64_t v197 = v194;
              }
              else {
                uint64_t v197 = -v194;
              }
              int v62 = &v195[v196];
              uint64_t v832 = v197;
              CGBlt_fillBytes(v803, v191, 0, &v195[v196], v197);
            }
            goto LABEL_430;
          case 1:
            int v198 = *(unsigned __int8 *)(v15 + 1);
            if (v198 == 2)
            {
              if (v803 < 8
                || (4 * v797) > 0x40
                || (LODWORD(v4) = 4 * v797,
                    uint8x8_t v708 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v4),
                    v708.i16[0] = vaddlv_u8(v708),
                    v708.i32[0] > 1u))
              {
LABEL_1243:
                if (v59)
                {
                  uint64_t v711 = (int)v59;
                  if (v42)
                  {
                    do
                    {
                      int v712 = v866[0];
                      do
                      {
                        *float v69 = *v55;
                        char *v62 = *v63;
                        v62 += v711;
                        int v713 = &v55[v793];
                        if ((unint64_t)v713 >= v65) {
                          uint64_t v714 = -(uint64_t)v797;
                        }
                        else {
                          uint64_t v714 = 0;
                        }
                        float v55 = &v713[v714];
                        v63 += v42 + v714;
                        v69 += v793;
                        --v712;
                      }
                      while (v712);
                      if (v834)
                      {
                        uint64_t v715 = &v838[v836];
                        BOOL v716 = (unint64_t)v715 >= v834;
                        if ((unint64_t)v715 >= v834) {
                          uint64_t v717 = -(uint64_t)(v836 * v796);
                        }
                        else {
                          uint64_t v717 = 0;
                        }
                        uint64_t v718 = &v715[v717];
                        unint64_t v719 = v65 + 4 * v717;
                        if (v716) {
                          uint64_t v720 = -(v41 * v796);
                        }
                        else {
                          uint64_t v720 = 0;
                        }
                        unint64_t v65 = v719 + 4 * v836;
                        float v55 = v718;
                        v838 = v718;
                        v839 += v41 + v720;
                        unsigned __int16 v63 = (unsigned __int8 *)v839;
                      }
                      else
                      {
                        v55 += v836;
                        v63 += v41;
                      }
                      v69 += v802;
                      v62 += v832;
                      --v856[0];
                    }
                    while (v856[0]);
                  }
                  else
                  {
                    do
                    {
                      int v730 = v866[0];
                      do
                      {
                        *float v69 = *v55;
                        char *v62 = -1;
                        v62 += v711;
                        int v731 = &v55[v793];
                        if ((unint64_t)v731 >= v65) {
                          uint64_t v732 = -(uint64_t)v797;
                        }
                        else {
                          uint64_t v732 = 0;
                        }
                        float v55 = &v731[v732];
                        v63 += v732;
                        v69 += v793;
                        --v730;
                      }
                      while (v730);
                      if (v834)
                      {
                        int v733 = &v838[v836];
                        BOOL v734 = (unint64_t)v733 >= v834;
                        if ((unint64_t)v733 >= v834) {
                          uint64_t v735 = -(uint64_t)(v836 * v796);
                        }
                        else {
                          uint64_t v735 = 0;
                        }
                        v736 = &v733[v735];
                        unint64_t v737 = v65 + 4 * v735;
                        if (v734) {
                          uint64_t v738 = -(v41 * v796);
                        }
                        else {
                          uint64_t v738 = 0;
                        }
                        unint64_t v65 = v737 + 4 * v836;
                        float v55 = v736;
                        v838 = v736;
                        v839 += v41 + v738;
                        unsigned __int16 v63 = (unsigned __int8 *)v839;
                      }
                      else
                      {
                        v55 += v836;
                        v63 += v41;
                      }
                      v69 += v802;
                      v62 += v832;
                      --v856[0];
                    }
                    while (v856[0]);
                  }
                }
                else
                {
                  do
                  {
                    int v721 = v866[0];
                    do
                    {
                      *float v69 = *v55;
                      uint64_t v722 = &v55[v793];
                      if ((unint64_t)v722 >= v65) {
                        uint64_t v723 = -(uint64_t)v797;
                      }
                      else {
                        uint64_t v723 = 0;
                      }
                      float v55 = &v722[v723];
                      v63 += v42 + v723;
                      v69 += v793;
                      --v721;
                    }
                    while (v721);
                    if (v834)
                    {
                      uint64_t v724 = &v838[v836];
                      BOOL v725 = (unint64_t)v724 >= v834;
                      if ((unint64_t)v724 >= v834) {
                        uint64_t v726 = -(uint64_t)(v836 * v796);
                      }
                      else {
                        uint64_t v726 = 0;
                      }
                      uint64_t v727 = &v724[v726];
                      unint64_t v728 = v65 + 4 * v726;
                      if (v725) {
                        uint64_t v729 = -(v41 * v796);
                      }
                      else {
                        uint64_t v729 = 0;
                      }
                      unint64_t v65 = v728 + 4 * v836;
                      float v55 = v727;
                      v838 = v727;
                      v839 += v41 + v729;
                      unsigned __int16 v63 = (unsigned __int8 *)v839;
                    }
                    else
                    {
                      v55 += v836;
                      v63 += v41;
                    }
                    v69 += v802;
                    v62 += v832;
                    --v856[0];
                  }
                  while (v856[0]);
                }
LABEL_1292:
                unint64_t v843 = v65;
                goto LABEL_1092;
              }
              unint64_t v843 = v65;
              int v709 = v856[0];
              CGSFillDRAM64((unint64_t)v69, 4 * (v803 + v802), 4 * v803, v856[0], v788, 4 * v836, 4 * v797, v796, 4 * v786, v785);
              if (!v850) {
                goto LABEL_1092;
              }
              unsigned int v710 = v709;
              unint64_t v58 = v834;
              uint64_t v61 = v798;
              if (v42) {
                CGSFillDRAM64((unint64_t)v62, v803 + v832, v803, v710, (uint64_t)v11, v41, v797, v796, v786, v785);
              }
              else {
                CGBlt_fillBytes(v803, v710, -1, v62, v803 + v832);
              }
            }
            else
            {
              if (v198 != 1) {
                goto LABEL_1243;
              }
              unint64_t v843 = v65;
              if (v793 < 0)
              {
                uint64_t v199 = v836 - v803;
                v55 += -v803 + 1;
                uint64_t v200 = v802 - v803;
                v69 += -v803 + 1;
              }
              else
              {
                uint64_t v199 = v836 + v803;
                uint64_t v200 = v802 + v803;
              }
              uint64_t v739 = v856[0] - 1;
              v740 = (char *)&v55[(v199 * v739) & (v199 >> 63)];
              if (v199 >= 0) {
                unint64_t v741 = v199;
              }
              else {
                unint64_t v741 = -v199;
              }
              if (v200 >= 0) {
                LODWORD(v742) = v200;
              }
              else {
                uint64_t v742 = -v200;
              }
              unint64_t v836 = v741;
              int v743 = v856[0];
              CGBlt_copyBytes(4 * v803, v856[0], v740, (char *)&v69[(v200 * v739) & (v200 >> 63)], 4 * v741, 4 * v742);
              if (!v850)
              {
LABEL_430:
                unint64_t v27 = v795;
                uint64_t v41 = v800;
                goto LABEL_1092;
              }
              unint64_t v58 = v834;
              uint64_t v61 = v798;
              if (v42)
              {
                uint64_t v744 = v800 - v803;
                v745 = &v63[-v803 + 1];
                uint64_t v746 = v832 - v803;
                v747 = &v62[-v803 + 1];
                if (v793 >= 0)
                {
                  v747 = v62;
                  v745 = v63;
                  uint64_t v744 = v800 + v803;
                  uint64_t v746 = v832 + v803;
                }
                uint64_t v748 = (v744 * v739) & (v744 >> 63);
                if (v744 >= 0) {
                  uint64_t v749 = v744;
                }
                else {
                  uint64_t v749 = -v744;
                }
                uint64_t v750 = (v746 * v739) & (v746 >> 63);
                if (v746 >= 0) {
                  uint64_t v751 = v746;
                }
                else {
                  uint64_t v751 = -v746;
                }
                unsigned __int16 v63 = &v745[v748];
                int v62 = &v747[v750];
                uint64_t v832 = v751;
                CGBlt_copyBytes(v803, v743, (char *)&v745[v748], &v747[v750], v749, v751);
                unint64_t v27 = v795;
                uint64_t v41 = v749;
              }
              else
              {
                uint64_t v752 = v832 - v803;
                v753 = &v62[-v803 + 1];
                if (v793 >= 0)
                {
                  v753 = v62;
                  uint64_t v752 = v832 + v803;
                }
                uint64_t v754 = (v752 * v739) & (v752 >> 63);
                if (v752 >= 0) {
                  uint64_t v755 = v752;
                }
                else {
                  uint64_t v755 = -v752;
                }
                int v62 = &v753[v754];
                uint64_t v832 = v755;
                CGBlt_fillBytes(v803, v743, -1, &v753[v754], v755);
                unint64_t v27 = v795;
                uint64_t v41 = v800;
              }
            }
            goto LABEL_1093;
          case 2:
            uint64_t v201 = v793;
            uint64_t v202 = 4 * v793;
            if (v59)
            {
              v794 = v11;
              uint64_t v203 = (int)v59;
              uint64_t v783 = -(v41 * v796);
              do
              {
                int v204 = v866[0];
                do
                {
                  int v205 = *v63;
                  if (*v63)
                  {
                    if (v205 == 255)
                    {
                      *float v69 = *v55;
                      char *v62 = *v63;
                    }
                    else
                    {
                      uint64_t v206 = v202;
                      unint64_t v207 = v65;
                      DAplusDAM(v69, v62, *v55, v205, *v69, *v62, v205 ^ 0xFF);
                      uint64_t v202 = v206;
                      uint64_t v201 = v793;
                      unint64_t v65 = v207;
                    }
                  }
                  v62 += v203;
                  uint64_t v208 = &v55[v201];
                  if ((unint64_t)v208 >= v65) {
                    uint64_t v209 = -(uint64_t)v797;
                  }
                  else {
                    uint64_t v209 = 0;
                  }
                  float v55 = &v208[v209];
                  v63 += v42 + v209;
                  float v69 = (unsigned int *)((char *)v69 + v202);
                  --v204;
                }
                while (v204);
                if (v834)
                {
                  unsigned int v210 = &v838[v836];
                  uint64_t v41 = v800;
                  BOOL v211 = (unint64_t)v210 >= v834;
                  uint64_t v212 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v210 < v834) {
                    uint64_t v212 = 0;
                  }
                  unsigned int v213 = &v210[v212];
                  unint64_t v214 = v65 + 4 * v212;
                  uint64_t v215 = v783;
                  if (!v211) {
                    uint64_t v215 = 0;
                  }
                  unint64_t v65 = v214 + 4 * v836;
                  float v55 = v213;
                  v838 = v213;
                  v839 += v800 + v215;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  uint64_t v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_1089;
            }
            do
            {
              int v643 = v866[0];
              do
              {
                int v644 = *v63;
                if (*v63)
                {
                  if (v644 == 255) {
                    unsigned int v645 = *v55;
                  }
                  else {
                    unsigned int v645 = ((((*v69 >> 8) & 0xFF00FF) * (v644 ^ 0xFF)
                  }
                           + 65537
                           + (((((*v69 >> 8) & 0xFF00FF) * (v644 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                         + *v55
                         + ((((*v69 & 0xFF00FF) * (v644 ^ 0xFF)
                            + 65537
                            + ((((*v69 & 0xFF00FF) * (v644 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                  *float v69 = v645;
                }
                uint64_t v646 = &v55[v793];
                if ((unint64_t)v646 >= v65) {
                  uint64_t v647 = -(uint64_t)v797;
                }
                else {
                  uint64_t v647 = 0;
                }
                float v55 = &v646[v647];
                v63 += v42 + v647;
                float v69 = (unsigned int *)((char *)v69 + v202);
                --v643;
              }
              while (v643);
              if (v834)
              {
                uint64_t v648 = &v838[v836];
                BOOL v649 = (unint64_t)v648 >= v834;
                if ((unint64_t)v648 >= v834) {
                  uint64_t v650 = -(uint64_t)(v836 * v796);
                }
                else {
                  uint64_t v650 = 0;
                }
                uint64_t v651 = &v648[v650];
                unint64_t v652 = v65 + 4 * v650;
                if (v649) {
                  uint64_t v653 = -(v41 * v796);
                }
                else {
                  uint64_t v653 = 0;
                }
                unint64_t v65 = v652 + 4 * v836;
                float v55 = v651;
                v838 = v651;
                v839 += v41 + v653;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v63 += v41;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_1202;
          case 3:
            uint64_t v216 = v793;
            uint64_t v217 = (int)v59;
            uint64_t v218 = 4 * v793;
            if (v42)
            {
              v794 = v11;
              uint64_t v784 = -(v41 * v796);
              do
              {
                int v219 = v866[0];
                do
                {
                  int v220 = *v62;
                  if (v220 == 255)
                  {
                    *float v69 = *v55;
                    LOBYTE(v221) = *v63;
                  }
                  else if (*v62)
                  {
                    unint64_t v222 = v65;
                    uint64_t v223 = v218;
                    unint64_t v224 = PDAM_5699(*v55, *v63, v220);
                    uint64_t v218 = v223;
                    uint64_t v216 = v793;
                    unint64_t v65 = v222;
                    *float v69 = v224;
                    unint64_t v221 = HIDWORD(v224);
                  }
                  else
                  {
                    LOBYTE(v221) = 0;
                    *float v69 = 0;
                  }
                  char *v62 = v221;
                  v62 += v217;
                  int v225 = &v55[v216];
                  if ((unint64_t)v225 >= v65) {
                    uint64_t v226 = -(uint64_t)v797;
                  }
                  else {
                    uint64_t v226 = 0;
                  }
                  float v55 = &v225[v226];
                  v63 += v42 + v226;
                  float v69 = (unsigned int *)((char *)v69 + v218);
                  --v219;
                }
                while (v219);
                if (v834)
                {
                  unsigned int v227 = &v838[v836];
                  uint64_t v41 = v800;
                  BOOL v228 = (unint64_t)v227 >= v834;
                  uint64_t v229 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v227 < v834) {
                    uint64_t v229 = 0;
                  }
                  unint64_t v230 = &v227[v229];
                  unint64_t v231 = v65 + 4 * v229;
                  uint64_t v232 = v784;
                  if (!v228) {
                    uint64_t v232 = 0;
                  }
                  unint64_t v65 = v231 + 4 * v836;
                  float v55 = v230;
                  v838 = v230;
                  v839 += v800 + v232;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  uint64_t v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_1089;
            }
            do
            {
              int v654 = v866[0];
              do
              {
                unsigned int v655 = *v62;
                if (*v62)
                {
                  if (v655 == 255) {
                    unsigned int v655 = *v55;
                  }
                  else {
                    unsigned int v655 = (((*v55 & 0xFF00FF) * v655 + 65537 + ((((*v55 & 0xFF00FF) * v655) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v55 >> 8) & 0xFF00FF) * v655 + 65537 + (((((*v55 >> 8) & 0xFF00FF) * v655) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  }
                }
                *float v69 = v655;
                v62 += v217;
                float v656 = &v55[v793];
                if ((unint64_t)v656 >= v65) {
                  uint64_t v657 = -(uint64_t)v797;
                }
                else {
                  uint64_t v657 = 0;
                }
                float v55 = &v656[v657];
                v63 += v657;
                float v69 = (unsigned int *)((char *)v69 + v218);
                --v654;
              }
              while (v654);
              if (v834)
              {
                uint64_t v658 = &v838[v836];
                BOOL v659 = (unint64_t)v658 >= v834;
                if ((unint64_t)v658 >= v834) {
                  uint64_t v660 = -(uint64_t)(v836 * v796);
                }
                else {
                  uint64_t v660 = 0;
                }
                uint64_t v661 = &v658[v660];
                unint64_t v662 = v65 + 4 * v660;
                if (v659) {
                  uint64_t v663 = -(v41 * v796);
                }
                else {
                  uint64_t v663 = 0;
                }
                unint64_t v65 = v662 + 4 * v836;
                float v55 = v661;
                v838 = v661;
                v839 += v41 + v663;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v63 += v41;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            unint64_t v843 = v65;
            int v13 = v792;
            goto LABEL_1091;
          case 4:
            v794 = v11;
            uint64_t v233 = (int)v59;
            uint64_t v234 = v42;
            *(void *)v805 = -(v41 * v796);
            do
            {
              int v235 = v866[0];
              unint64_t v844 = v65;
              do
              {
                if (~*v62 == 255)
                {
                  if (v42) {
                    LOBYTE(v236) = *v63;
                  }
                  else {
                    LOBYTE(v236) = -1;
                  }
                }
                else if (*v62 == -1)
                {
                  LOBYTE(v236) = 0;
                  *float v69 = 0;
                }
                else
                {
                  if (v42) {
                    int v237 = *v63;
                  }
                  else {
                    int v237 = 255;
                  }
                  unint64_t v238 = PDAM_5699(*v55, v237, ~*v62);
                  *float v69 = v238;
                  unint64_t v236 = HIDWORD(v238);
                  int v42 = v854;
                  unint64_t v65 = v844;
                }
                char *v62 = v236;
                v62 += v233;
                double v239 = &v55[v793];
                if ((unint64_t)v239 >= v65) {
                  uint64_t v240 = -(uint64_t)v797;
                }
                else {
                  uint64_t v240 = 0;
                }
                float v55 = &v239[v240];
                v63 += v234 + v240;
                v69 += v793;
                --v235;
              }
              while (v235);
              if (v834)
              {
                double v241 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v242 = (unint64_t)v241 >= v834;
                uint64_t v243 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v241 < v834) {
                  uint64_t v243 = 0;
                }
                unint64_t v244 = &v241[v243];
                unint64_t v245 = v65 + 4 * v243;
                uint64_t v246 = *(void *)v805;
                if (!v242) {
                  uint64_t v246 = 0;
                }
                unint64_t v65 = v245 + 4 * v836;
                float v55 = v244;
                v838 = v244;
                v839 += v800 + v246;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_1089;
          case 5:
            v794 = v11;
            uint64_t v247 = (int)v59;
            uint64_t v757 = -(v41 * v796);
            int v248 = v856[0];
            do
            {
              int v827 = v248;
              int v249 = v803;
              unint64_t v845 = v65;
              do
              {
                DAMplusDAM(v69, v62, *v55, *v63, *v62, *v69, *v62, *v63 ^ 0xFF);
                unint64_t v65 = v845;
                v62 += v247;
                unint64_t v250 = &v55[v793];
                if ((unint64_t)v250 >= v845) {
                  uint64_t v251 = -(uint64_t)v797;
                }
                else {
                  uint64_t v251 = 0;
                }
                float v55 = &v250[v251];
                v63 += v42 + v251;
                v69 += v793;
                --v249;
              }
              while (v249);
              if (v834)
              {
                int8x16_t v252 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v253 = (unint64_t)v252 >= v834;
                uint64_t v254 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v252 < v834) {
                  uint64_t v254 = 0;
                }
                double v255 = &v252[v254];
                unint64_t v256 = v845 + 4 * v254;
                uint64_t v257 = v757;
                if (!v253) {
                  uint64_t v257 = 0;
                }
                unint64_t v65 = v256 + 4 * v836;
                float v55 = v255;
                v838 = v255;
                v839 += v800 + v257;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              int v248 = v827 - 1;
              v856[0] = v827 - 1;
            }
            while (v827 != 1);
            goto LABEL_1089;
          case 6:
            v794 = v11;
            uint64_t v258 = (int)v59;
            uint64_t v259 = v42;
            *(void *)v806 = -(v41 * v796);
            do
            {
              int v260 = v866[0];
              unint64_t v846 = v65;
              do
              {
                if (*v62 != -1)
                {
                  if (~*v62 == 255)
                  {
                    if (v42) {
                      char v261 = *v63;
                    }
                    else {
                      char v261 = -1;
                    }
                    *float v69 = *v55;
                    char *v62 = v261;
                  }
                  else
                  {
                    if (v42) {
                      int v262 = *v63;
                    }
                    else {
                      int v262 = 255;
                    }
                    DAplusDAM(v69, v62, *v69, *v62, *v55, v262, ~*v62);
                    int v42 = v854;
                    unint64_t v65 = v846;
                  }
                }
                v62 += v258;
                unsigned int v263 = &v55[v793];
                if ((unint64_t)v263 >= v65) {
                  uint64_t v264 = -(uint64_t)v797;
                }
                else {
                  uint64_t v264 = 0;
                }
                float v55 = &v263[v264];
                v63 += v259 + v264;
                v69 += v793;
                --v260;
              }
              while (v260);
              if (v834)
              {
                unsigned int v265 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v266 = (unint64_t)v265 >= v834;
                uint64_t v267 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v265 < v834) {
                  uint64_t v267 = 0;
                }
                int v268 = &v265[v267];
                unint64_t v269 = v65 + 4 * v267;
                uint64_t v270 = *(void *)v806;
                if (!v266) {
                  uint64_t v270 = 0;
                }
                unint64_t v65 = v269 + 4 * v836;
                float v55 = v268;
                v838 = v268;
                v839 += v800 + v270;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_1089;
          case 7:
            uint64_t v271 = v793;
            uint64_t v272 = 4 * v793;
            if (v59)
            {
              v794 = v11;
              uint64_t v273 = (int)v59;
              uint64_t v274 = -(uint64_t)v797;
              uint64_t v758 = -(v41 * v796);
              do
              {
                int v275 = v866[0];
                do
                {
                  int v276 = *v63;
                  if (v276 != 255)
                  {
                    if (*v63)
                    {
                      unint64_t v278 = v65;
                      uint64_t v279 = v272;
                      unint64_t v280 = PDAM_5699(*v69, *v62, v276);
                      uint64_t v271 = v793;
                      uint64_t v274 = -(uint64_t)v797;
                      uint64_t v272 = v279;
                      unint64_t v65 = v278;
                      *float v69 = v280;
                      unint64_t v277 = HIDWORD(v280);
                    }
                    else
                    {
                      LOBYTE(v277) = 0;
                      *float v69 = 0;
                    }
                    char *v62 = v277;
                  }
                  v62 += v273;
                  unsigned int v281 = &v55[v271];
                  if ((unint64_t)v281 >= v65) {
                    uint64_t v282 = v274;
                  }
                  else {
                    uint64_t v282 = 0;
                  }
                  float v55 = &v281[v282];
                  v63 += v42 + v282;
                  float v69 = (unsigned int *)((char *)v69 + v272);
                  --v275;
                }
                while (v275);
                if (v834)
                {
                  unint64_t v283 = &v838[v836];
                  uint64_t v41 = v800;
                  BOOL v284 = (unint64_t)v283 >= v834;
                  uint64_t v285 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v283 < v834) {
                    uint64_t v285 = 0;
                  }
                  unsigned int v286 = &v283[v285];
                  unint64_t v287 = v65 + 4 * v285;
                  uint64_t v288 = v758;
                  if (!v284) {
                    uint64_t v288 = 0;
                  }
                  unint64_t v65 = v287 + 4 * v836;
                  float v55 = v286;
                  v838 = v286;
                  v839 += v800 + v288;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  uint64_t v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_1089;
            }
LABEL_1163:
            int v664 = v866[0];
            while (1)
            {
              unsigned int v665 = *v63;
              if (!*v63) {
                goto LABEL_1167;
              }
              if (v665 != 255) {
                break;
              }
LABEL_1168:
              uint64_t v666 = &v55[v793];
              if ((unint64_t)v666 >= v65) {
                uint64_t v667 = -(uint64_t)v797;
              }
              else {
                uint64_t v667 = 0;
              }
              float v55 = &v666[v667];
              v63 += v42 + v667;
              float v69 = (unsigned int *)((char *)v69 + v272);
              if (!--v664)
              {
                if (v834)
                {
                  int v668 = &v838[v836];
                  BOOL v669 = (unint64_t)v668 >= v834;
                  if ((unint64_t)v668 >= v834) {
                    uint64_t v670 = -(uint64_t)(v836 * v796);
                  }
                  else {
                    uint64_t v670 = 0;
                  }
                  int32x2_t v671 = &v668[v670];
                  unint64_t v672 = v65 + 4 * v670;
                  if (v669) {
                    uint64_t v673 = -(v41 * v796);
                  }
                  else {
                    uint64_t v673 = 0;
                  }
                  unint64_t v65 = v672 + 4 * v836;
                  float v55 = v671;
                  v838 = v671;
                  v839 += v41 + v673;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                if (!--v856[0]) {
                  goto LABEL_1202;
                }
                goto LABEL_1163;
              }
            }
            unsigned int v665 = (((*v69 & 0xFF00FF) * v665 + 65537 + ((((*v69 & 0xFF00FF) * v665) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v69 >> 8) & 0xFF00FF) * v665 + 65537 + (((((*v69 >> 8) & 0xFF00FF) * v665) >> 8) & 0xFF00FF)) & 0xFF00FF00;
LABEL_1167:
            *float v69 = v665;
            goto LABEL_1168;
          case 8:
            uint64_t v289 = v793;
            uint64_t v290 = 4 * v793;
            if (!v59)
            {
              while (1)
              {
                int v674 = v866[0];
                do
                {
                  unsigned int v675 = *v63 ^ 0xFF;
                  if (v675)
                  {
                    if (v675 == 255) {
                      goto LABEL_1188;
                    }
                    unsigned int v675 = (((*v69 & 0xFF00FF) * v675 + 65537 + ((((*v69 & 0xFF00FF) * v675) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v69 >> 8) & 0xFF00FF) * v675 + 65537 + (((((*v69 >> 8) & 0xFF00FF) * v675) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  }
                  *float v69 = v675;
LABEL_1188:
                  uint64_t v676 = &v55[v793];
                  if ((unint64_t)v676 >= v65) {
                    uint64_t v677 = -(uint64_t)v797;
                  }
                  else {
                    uint64_t v677 = 0;
                  }
                  float v55 = &v676[v677];
                  v63 += v42 + v677;
                  float v69 = (unsigned int *)((char *)v69 + v290);
                  --v674;
                }
                while (v674);
                if (v834)
                {
                  int v678 = &v838[v836];
                  BOOL v679 = (unint64_t)v678 >= v834;
                  if ((unint64_t)v678 >= v834) {
                    uint64_t v680 = -(uint64_t)(v836 * v796);
                  }
                  else {
                    uint64_t v680 = 0;
                  }
                  long long v681 = &v678[v680];
                  unint64_t v682 = v65 + 4 * v680;
                  if (v679) {
                    uint64_t v683 = -(v41 * v796);
                  }
                  else {
                    uint64_t v683 = 0;
                  }
                  unint64_t v65 = v682 + 4 * v836;
                  float v55 = v681;
                  v838 = v681;
                  v839 += v41 + v683;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                if (!--v856[0])
                {
LABEL_1202:
                  unint64_t v843 = v65;
                  goto LABEL_1091;
                }
              }
            }
            v794 = v11;
            uint64_t v291 = (int)v59;
            uint64_t v759 = -(v41 * v796);
            do
            {
              int v292 = v866[0];
              do
              {
                if (~*v63 != 255)
                {
                  if (*v63 == 0xFF)
                  {
                    LOBYTE(v293) = 0;
                    *float v69 = 0;
                  }
                  else
                  {
                    unint64_t v294 = v65;
                    unint64_t v295 = PDAM_5699(*v69, *v62, ~*v63);
                    uint64_t v290 = 4 * v793;
                    uint64_t v289 = v793;
                    unint64_t v65 = v294;
                    *float v69 = v295;
                    unint64_t v293 = HIDWORD(v295);
                  }
                  char *v62 = v293;
                }
                v62 += v291;
                unint64_t v296 = &v55[v289];
                if ((unint64_t)v296 >= v65) {
                  uint64_t v297 = -(uint64_t)v797;
                }
                else {
                  uint64_t v297 = 0;
                }
                float v55 = &v296[v297];
                v63 += v42 + v297;
                float v69 = (unsigned int *)((char *)v69 + v290);
                --v292;
              }
              while (v292);
              if (v834)
              {
                unint64_t v298 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v299 = (unint64_t)v298 >= v834;
                uint64_t v300 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v298 < v834) {
                  uint64_t v300 = 0;
                }
                int v301 = &v298[v300];
                unint64_t v302 = v65 + 4 * v300;
                uint64_t v303 = v759;
                if (!v299) {
                  uint64_t v303 = 0;
                }
                unint64_t v65 = v302 + 4 * v836;
                float v55 = v301;
                v838 = v301;
                v839 += v800 + v303;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
LABEL_1089:
            unint64_t v843 = v65;
LABEL_1090:
            int v13 = v792;
            unint64_t v15 = v787;
            uint64_t v11 = v794;
LABEL_1091:
            unint64_t v27 = v795;
LABEL_1092:
            unint64_t v58 = v834;
            uint64_t v61 = v798;
LABEL_1093:
            if (!v61) {
              return 1;
            }
            uint64_t v855 = 0;
            continue;
          case 9:
            v794 = v11;
            uint64_t v304 = (int)v59;
            uint64_t v760 = -(v41 * v796);
            int v305 = v856[0];
            do
            {
              int v828 = v305;
              int v306 = v803;
              do
              {
                v847 = v63;
                int v307 = *v63;
                unint64_t v308 = v65;
                DAMplusDAM(v69, v62, *v55, v307, *v62 ^ 0xFF, *v69, *v62, v307);
                unint64_t v65 = v308;
                v62 += v304;
                int v309 = &v55[v793];
                if ((unint64_t)v309 >= v308) {
                  uint64_t v310 = -(uint64_t)v797;
                }
                else {
                  uint64_t v310 = 0;
                }
                float v55 = &v309[v310];
                unsigned __int16 v63 = &v847[v42 + v310];
                v69 += v793;
                --v306;
              }
              while (v306);
              if (v834)
              {
                unsigned int v311 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v312 = (unint64_t)v311 >= v834;
                uint64_t v313 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v311 < v834) {
                  uint64_t v313 = 0;
                }
                unint64_t v314 = &v311[v313];
                unint64_t v315 = v65 + 4 * v313;
                uint64_t v316 = v760;
                if (!v312) {
                  uint64_t v316 = 0;
                }
                unint64_t v65 = v315 + 4 * v836;
                float v55 = v314;
                v838 = v314;
                v839 += v800 + v316;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              int v305 = v828 - 1;
              v856[0] = v828 - 1;
            }
            while (v828 != 1);
            goto LABEL_1089;
          case 10:
            v794 = v11;
            uint64_t v317 = (int)v59;
            uint64_t v761 = -(v41 * v796);
            int v318 = v856[0];
            uint64_t v319 = -(uint64_t)v797;
            do
            {
              int v829 = v318;
              int v320 = v803;
              unint64_t v848 = v65;
              do
              {
                int v321 = *v62;
                unint64_t v322 = v55;
                unsigned int v323 = *v55;
                unsigned int v324 = *v69;
                int v325 = v69;
                unsigned int v326 = v62;
                unsigned int v327 = v62;
                unint64_t v328 = v69;
                unint64_t v329 = v322;
                uint64_t v330 = v319;
                DAMplusDAM(v325, v326, v323, *v63, v321 ^ 0xFF, v324, v321, *v63 ^ 0xFF);
                uint64_t v319 = v330;
                unint64_t v65 = v848;
                int v62 = &v327[v317];
                unint64_t v331 = (unint64_t)&v329[v793];
                if (v331 >= v848) {
                  uint64_t v332 = v319;
                }
                else {
                  uint64_t v332 = 0;
                }
                float v55 = (int *)(v331 + 4 * v332);
                v63 += v42 + v332;
                float v69 = &v328[v793];
                --v320;
              }
              while (v320);
              if (v834)
              {
                unsigned int v333 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v334 = (unint64_t)v333 >= v834;
                uint64_t v335 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v333 < v834) {
                  uint64_t v335 = 0;
                }
                unint64_t v336 = &v333[v335];
                unint64_t v337 = v848 + 4 * v335;
                uint64_t v338 = v761;
                if (!v334) {
                  uint64_t v338 = 0;
                }
                unint64_t v65 = v337 + 4 * v836;
                float v55 = v336;
                v838 = v336;
                v839 += v800 + v338;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              int v318 = v829 - 1;
              v856[0] = v829 - 1;
            }
            while (v829 != 1);
            goto LABEL_1089;
          case 11:
            v794 = v11;
            uint64_t v830 = 4 * v793;
            if (v59)
            {
              uint64_t v339 = (int)v59;
              uint64_t v340 = v42;
              uint64_t v762 = -(v41 * v796);
              int v341 = v856[0];
              do
              {
                int v849 = v341;
                int v342 = v803;
                unint64_t v343 = v65;
                do
                {
                  if (v42) {
                    int v344 = *v63;
                  }
                  else {
                    int v344 = 255;
                  }
                  DAplusdDA(v69, v62, *v69, *v62, *v55, v344);
                  v62 += v339;
                  unint64_t v345 = &v55[v793];
                  if ((unint64_t)v345 >= v343) {
                    uint64_t v346 = -(uint64_t)v797;
                  }
                  else {
                    uint64_t v346 = 0;
                  }
                  float v55 = &v345[v346];
                  v63 += v340 + v346;
                  float v69 = (unsigned int *)((char *)v69 + v830);
                  --v342;
                  int v42 = v854;
                }
                while (v342);
                unint64_t v65 = v343;
                if (v834)
                {
                  int v347 = &v838[v836];
                  uint64_t v41 = v800;
                  BOOL v348 = (unint64_t)v347 >= v834;
                  uint64_t v349 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v347 < v834) {
                    uint64_t v349 = 0;
                  }
                  unint64_t v350 = &v347[v349];
                  unint64_t v351 = v343 + 4 * v349;
                  uint64_t v352 = v762;
                  if (!v348) {
                    uint64_t v352 = 0;
                  }
                  unint64_t v65 = v351 + 4 * v836;
                  float v55 = v350;
                  v838 = v350;
                  v839 += v800 + v352;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  uint64_t v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                int v341 = v849 - 1;
                v856[0] = v849 - 1;
              }
              while (v849 != 1);
              goto LABEL_1089;
            }
            uint64_t v684 = v42;
            uint64_t v782 = -(v41 * v796);
            int v685 = v856[0];
            uint64_t v756 = v832 + v832 * (v856[0] - 1);
            do
            {
              int v686 = v803;
              unint64_t v687 = v65;
              do
              {
                if (v42) {
                  int v688 = *v63;
                }
                else {
                  int v688 = 255;
                }
                DplusdDA(v69, *v69, *v55, v688);
                unsigned int v689 = &v55[v793];
                if ((unint64_t)v689 >= v687) {
                  uint64_t v690 = -(uint64_t)v797;
                }
                else {
                  uint64_t v690 = 0;
                }
                float v55 = &v689[v690];
                v63 += v684 + v690;
                float v69 = (unsigned int *)((char *)v69 + v830);
                --v686;
                int v42 = v854;
              }
              while (v686);
              unint64_t v65 = v687;
              if (v834)
              {
                unsigned int v691 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v692 = (unint64_t)v691 >= v834;
                uint64_t v693 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v691 < v834) {
                  uint64_t v693 = 0;
                }
                uint64_t v694 = &v691[v693];
                unint64_t v695 = v687 + 4 * v693;
                uint64_t v696 = v782;
                if (!v692) {
                  uint64_t v696 = 0;
                }
                unint64_t v65 = v695 + 4 * v836;
                float v55 = v694;
                v838 = v694;
                v839 += v800 + v696;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v856[0] = --v685;
            }
            while (v685);
            unint64_t v843 = v65;
            v62 += v756;
            goto LABEL_1090;
          case 12:
            if (v59)
            {
              do
              {
                int v353 = v866[0];
                do
                {
                  if (v42) {
                    int v354 = *v63;
                  }
                  else {
                    int v354 = 255;
                  }
                  int v355 = ((*v55 >> 8) & 0xFF00FF) + ((*v69 >> 8) & 0xFF00FF);
                  unsigned int v356 = (*v55 & 0xFF00FF) + (*v69 & 0xFF00FF);
                  unsigned int v357 = v354 + *v62;
                  unsigned int v358 = (v355 << 8) & 0xFF00FF00 | v356 & 0xFF00FF | (15 * (v355 & 0x1000100 | (v356 >> 8) & 0x10001)) | (240 * (v355 & 0x1000100 | (v356 >> 8) & 0x10001));
                  if (v357 >= 0xFF) {
                    LOBYTE(v357) = -1;
                  }
                  char *v62 = v357;
                  *float v69 = v358;
                  v62 += (int)v59;
                  unint64_t v359 = &v55[v793];
                  if ((unint64_t)v359 >= v65) {
                    uint64_t v360 = -(uint64_t)v797;
                  }
                  else {
                    uint64_t v360 = 0;
                  }
                  float v55 = &v359[v360];
                  v63 += v42 + v360;
                  v69 += v793;
                  --v353;
                }
                while (v353);
                if (v834)
                {
                  int v361 = &v838[v836];
                  BOOL v362 = (unint64_t)v361 >= v834;
                  uint64_t v363 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v361 < v834) {
                    uint64_t v363 = 0;
                  }
                  unint64_t v364 = &v361[v363];
                  unint64_t v365 = v65 + 4 * v363;
                  if (v362) {
                    uint64_t v366 = -(v41 * v796);
                  }
                  else {
                    uint64_t v366 = 0;
                  }
                  unint64_t v65 = v365 + 4 * v836;
                  float v55 = v364;
                  v838 = v364;
                  v839 += v41 + v366;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
            }
            else
            {
              do
              {
                int v697 = v866[0];
                do
                {
                  int v698 = ((*v55 >> 8) & 0xFF00FF) + ((*v69 >> 8) & 0xFF00FF);
                  unsigned int v699 = (*v55 & 0xFF00FF) + (*v69 & 0xFF00FF);
                  *float v69 = (v698 << 8) & 0xFF00FF00 | v699 & 0xFF00FF | (15 * (v698 & 0x1000100 | (v699 >> 8) & 0x10001)) | (240 * (v698 & 0x1000100 | (v699 >> 8) & 0x10001));
                  uint64_t v700 = &v55[v793];
                  if ((unint64_t)v700 >= v65) {
                    uint64_t v701 = -(uint64_t)v797;
                  }
                  else {
                    uint64_t v701 = 0;
                  }
                  float v55 = &v700[v701];
                  v63 += v42 + v701;
                  v69 += v793;
                  --v697;
                }
                while (v697);
                if (v834)
                {
                  uint64_t v702 = &v838[v836];
                  BOOL v703 = (unint64_t)v702 >= v834;
                  if ((unint64_t)v702 >= v834) {
                    uint64_t v704 = -(uint64_t)(v836 * v796);
                  }
                  else {
                    uint64_t v704 = 0;
                  }
                  uint64_t v705 = &v702[v704];
                  unint64_t v706 = v65 + 4 * v704;
                  if (v703) {
                    uint64_t v707 = -(v41 * v796);
                  }
                  else {
                    uint64_t v707 = 0;
                  }
                  unint64_t v65 = v706 + 4 * v836;
                  float v55 = v705;
                  v838 = v705;
                  v839 += v41 + v707;
                  unsigned __int16 v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
            }
            goto LABEL_1292;
          case 13:
            v794 = v11;
            *(void *)v807 = (int)v59;
            uint64_t v367 = v42;
            uint64_t v763 = -(v41 * v796);
            while (1)
            {
              int v368 = v866[0];
              unint64_t v369 = v65;
              do
              {
                if (v42)
                {
                  int v370 = *v63;
                  if (!*v63) {
                    goto LABEL_663;
                  }
                  if (v59) {
                    goto LABEL_658;
                  }
                }
                else
                {
                  int v370 = 255;
                  if (v59)
                  {
LABEL_658:
                    if (*v62)
                    {
                      unint64_t v371 = PDAmultiplyPDA_5700(*v69, *v62, *v55, v370);
                      unint64_t v65 = v369;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v371;
                      char *v62 = BYTE4(v371);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v370;
                    }
                    goto LABEL_663;
                  }
                }
                unsigned int v372 = PDAmultiplyPDA_5700(*v69, 255, *v55, v370);
                unint64_t v65 = v369;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v372;
LABEL_663:
                v62 += *(void *)v807;
                int v373 = &v55[v793];
                if ((unint64_t)v373 >= v65) {
                  uint64_t v374 = -(uint64_t)v797;
                }
                else {
                  uint64_t v374 = 0;
                }
                float v55 = &v373[v374];
                v63 += v367 + v374;
                v69 += v793;
                --v368;
              }
              while (v368);
              if (v834)
              {
                float v375 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v376 = (unint64_t)v375 >= v834;
                uint64_t v377 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v375 < v834) {
                  uint64_t v377 = 0;
                }
                float v378 = &v375[v377];
                unint64_t v379 = v65 + 4 * v377;
                uint64_t v380 = v763;
                if (!v376) {
                  uint64_t v380 = 0;
                }
                unint64_t v65 = v379 + 4 * v836;
                float v55 = v378;
                v838 = v378;
                v839 += v800 + v380;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 14:
            v794 = v11;
            *(void *)v808 = (int)v59;
            uint64_t v381 = v42;
            uint64_t v764 = -(v41 * v796);
            while (1)
            {
              int v382 = v866[0];
              unint64_t v383 = v65;
              do
              {
                if (v42)
                {
                  unsigned int v384 = *v63;
                  if (!*v63) {
                    goto LABEL_686;
                  }
                  if (v59) {
                    goto LABEL_681;
                  }
                }
                else
                {
                  unsigned int v384 = 255;
                  if (v59)
                  {
LABEL_681:
                    if (*v62)
                    {
                      unint64_t v385 = PDAscreenPDA_5701(*v69, *v62, *v55, v384);
                      unint64_t v65 = v383;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v385;
                      char *v62 = BYTE4(v385);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v384;
                    }
                    goto LABEL_686;
                  }
                }
                unsigned int v386 = PDAscreenPDA_5701(*v69, 0xFFu, *v55, v384);
                unint64_t v65 = v383;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v386;
LABEL_686:
                v62 += *(void *)v808;
                unsigned int v387 = &v55[v793];
                if ((unint64_t)v387 >= v65) {
                  uint64_t v388 = -(uint64_t)v797;
                }
                else {
                  uint64_t v388 = 0;
                }
                float v55 = &v387[v388];
                v63 += v381 + v388;
                v69 += v793;
                --v382;
              }
              while (v382);
              if (v834)
              {
                unint64_t v389 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v390 = (unint64_t)v389 >= v834;
                uint64_t v391 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v389 < v834) {
                  uint64_t v391 = 0;
                }
                int v392 = &v389[v391];
                unint64_t v393 = v65 + 4 * v391;
                uint64_t v394 = v764;
                if (!v390) {
                  uint64_t v394 = 0;
                }
                unint64_t v65 = v393 + 4 * v836;
                float v55 = v392;
                v838 = v392;
                v839 += v800 + v394;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 15:
            v794 = v11;
            *(void *)v809 = (int)v59;
            uint64_t v395 = v42;
            uint64_t v765 = -(v41 * v796);
            while (1)
            {
              int v396 = v866[0];
              unint64_t v397 = v65;
              do
              {
                if (v42)
                {
                  int v398 = *v63;
                  if (!*v63) {
                    goto LABEL_709;
                  }
                  if (v59) {
                    goto LABEL_704;
                  }
                }
                else
                {
                  int v398 = 255;
                  if (v59)
                  {
LABEL_704:
                    if (*v62)
                    {
                      unint64_t v399 = PDAoverlayPDA_5702(*v69, *v62, *v55, v398);
                      unint64_t v65 = v397;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v399;
                      char *v62 = BYTE4(v399);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v398;
                    }
                    goto LABEL_709;
                  }
                }
                unsigned int v400 = PDAoverlayPDA_5702(*v69, 255, *v55, v398);
                unint64_t v65 = v397;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v400;
LABEL_709:
                v62 += *(void *)v809;
                float v401 = &v55[v793];
                if ((unint64_t)v401 >= v65) {
                  uint64_t v402 = -(uint64_t)v797;
                }
                else {
                  uint64_t v402 = 0;
                }
                float v55 = &v401[v402];
                v63 += v395 + v402;
                v69 += v793;
                --v396;
              }
              while (v396);
              if (v834)
              {
                unint64_t v403 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v404 = (unint64_t)v403 >= v834;
                uint64_t v405 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v403 < v834) {
                  uint64_t v405 = 0;
                }
                unsigned __int8 v406 = &v403[v405];
                unint64_t v407 = v65 + 4 * v405;
                uint64_t v408 = v765;
                if (!v404) {
                  uint64_t v408 = 0;
                }
                unint64_t v65 = v407 + 4 * v836;
                float v55 = v406;
                v838 = v406;
                v839 += v800 + v408;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 16:
            v794 = v11;
            *(void *)v810 = (int)v59;
            uint64_t v409 = v42;
            uint64_t v766 = -(v41 * v796);
            while (1)
            {
              int v410 = v866[0];
              unint64_t v411 = v65;
              do
              {
                if (v42)
                {
                  unsigned int v412 = *v63;
                  if (!*v63) {
                    goto LABEL_732;
                  }
                  if (v59) {
                    goto LABEL_727;
                  }
                }
                else
                {
                  unsigned int v412 = 255;
                  if (v59)
                  {
LABEL_727:
                    if (*v62)
                    {
                      unint64_t v413 = PDAdarkenPDA_5704(*v69, *v62, *v55, v412, v4, v5, v6, v7, v8, v9);
                      unint64_t v65 = v411;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v413;
                      char *v62 = BYTE4(v413);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v412;
                    }
                    goto LABEL_732;
                  }
                }
                unsigned int v414 = PDAdarkenPDA_5704(*v69, 0xFFu, *v55, v412, v4, v5, v6, v7, v8, v9);
                unint64_t v65 = v411;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v414;
LABEL_732:
                v62 += *(void *)v810;
                unint64_t v415 = &v55[v793];
                if ((unint64_t)v415 >= v65) {
                  uint64_t v416 = -(uint64_t)v797;
                }
                else {
                  uint64_t v416 = 0;
                }
                float v55 = &v415[v416];
                v63 += v409 + v416;
                v69 += v793;
                --v410;
              }
              while (v410);
              if (v834)
              {
                int v417 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v418 = (unint64_t)v417 >= v834;
                uint64_t v419 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v417 < v834) {
                  uint64_t v419 = 0;
                }
                uint64_t v420 = &v417[v419];
                unint64_t v421 = v65 + 4 * v419;
                uint64_t v422 = v766;
                if (!v418) {
                  uint64_t v422 = 0;
                }
                unint64_t v65 = v421 + 4 * v836;
                float v55 = v420;
                v838 = v420;
                v839 += v800 + v422;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 17:
            v794 = v11;
            *(void *)v811 = (int)v59;
            uint64_t v423 = v42;
            uint64_t v767 = -(v41 * v796);
            while (1)
            {
              int v424 = v866[0];
              unint64_t v425 = v65;
              do
              {
                if (v42)
                {
                  unsigned int v426 = *v63;
                  if (!*v63) {
                    goto LABEL_755;
                  }
                  if (v59) {
                    goto LABEL_750;
                  }
                }
                else
                {
                  unsigned int v426 = 255;
                  if (v59)
                  {
LABEL_750:
                    if (*v62)
                    {
                      unint64_t v427 = PDAlightenPDA_5703(*v69, *v62, *v55, v426, v4, v5, v6, v7, v8, v9);
                      unint64_t v65 = v425;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v427;
                      char *v62 = BYTE4(v427);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v426;
                    }
                    goto LABEL_755;
                  }
                }
                unsigned int v428 = PDAlightenPDA_5703(*v69, 0xFFu, *v55, v426, v4, v5, v6, v7, v8, v9);
                unint64_t v65 = v425;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v428;
LABEL_755:
                v62 += *(void *)v811;
                uint64_t v429 = &v55[v793];
                if ((unint64_t)v429 >= v65) {
                  uint64_t v430 = -(uint64_t)v797;
                }
                else {
                  uint64_t v430 = 0;
                }
                float v55 = &v429[v430];
                v63 += v423 + v430;
                v69 += v793;
                --v424;
              }
              while (v424);
              if (v834)
              {
                uint64_t v431 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v432 = (unint64_t)v431 >= v834;
                uint64_t v433 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v431 < v834) {
                  uint64_t v433 = 0;
                }
                int v434 = &v431[v433];
                unint64_t v435 = v65 + 4 * v433;
                uint64_t v436 = v767;
                if (!v432) {
                  uint64_t v436 = 0;
                }
                unint64_t v65 = v435 + 4 * v836;
                float v55 = v434;
                v838 = v434;
                v839 += v800 + v436;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 18:
            v794 = v11;
            *(void *)v812 = (int)v59;
            uint64_t v437 = v42;
            uint64_t v768 = -(v41 * v796);
            while (1)
            {
              int v438 = v866[0];
              unint64_t v439 = v65;
              do
              {
                if (v42)
                {
                  int v440 = *v63;
                  if (!*v63) {
                    goto LABEL_778;
                  }
                  if (v59) {
                    goto LABEL_773;
                  }
                }
                else
                {
                  int v440 = 255;
                  if (v59)
                  {
LABEL_773:
                    if (*v62)
                    {
                      unint64_t v441 = PDAcolordodgePDA_5705(*v69, *v62, *v55, v440);
                      unint64_t v65 = v439;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v441;
                      char *v62 = BYTE4(v441);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v440;
                    }
                    goto LABEL_778;
                  }
                }
                unsigned int v442 = PDAcolordodgePDA_5705(*v69, 255, *v55, v440);
                unint64_t v65 = v439;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v442;
LABEL_778:
                v62 += *(void *)v812;
                uint64_t v443 = &v55[v793];
                if ((unint64_t)v443 >= v65) {
                  uint64_t v444 = -(uint64_t)v797;
                }
                else {
                  uint64_t v444 = 0;
                }
                float v55 = &v443[v444];
                v63 += v437 + v444;
                v69 += v793;
                --v438;
              }
              while (v438);
              if (v834)
              {
                unint64_t v445 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v446 = (unint64_t)v445 >= v834;
                uint64_t v447 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v445 < v834) {
                  uint64_t v447 = 0;
                }
                uint64_t v448 = &v445[v447];
                unint64_t v449 = v65 + 4 * v447;
                uint64_t v450 = v768;
                if (!v446) {
                  uint64_t v450 = 0;
                }
                unint64_t v65 = v449 + 4 * v836;
                float v55 = v448;
                v838 = v448;
                v839 += v800 + v450;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 19:
            v794 = v11;
            *(void *)v813 = (int)v59;
            uint64_t v451 = v42;
            uint64_t v769 = -(v41 * v796);
            while (1)
            {
              int v452 = v866[0];
              unint64_t v453 = v65;
              do
              {
                if (v42)
                {
                  int v454 = *v63;
                  if (!*v63) {
                    goto LABEL_801;
                  }
                  if (v59) {
                    goto LABEL_796;
                  }
                }
                else
                {
                  int v454 = 255;
                  if (v59)
                  {
LABEL_796:
                    if (*v62)
                    {
                      unint64_t v455 = PDAcolorburnPDA_5706(*v69, *v62, *v55, v454);
                      unint64_t v65 = v453;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v455;
                      char *v62 = BYTE4(v455);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v454;
                    }
                    goto LABEL_801;
                  }
                }
                unsigned int v456 = PDAcolorburnPDA_5706(*v69, 255, *v55, v454);
                unint64_t v65 = v453;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v456;
LABEL_801:
                v62 += *(void *)v813;
                float v457 = &v55[v793];
                if ((unint64_t)v457 >= v65) {
                  uint64_t v458 = -(uint64_t)v797;
                }
                else {
                  uint64_t v458 = 0;
                }
                float v55 = &v457[v458];
                v63 += v451 + v458;
                v69 += v793;
                --v452;
              }
              while (v452);
              if (v834)
              {
                uint64_t v459 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v460 = (unint64_t)v459 >= v834;
                uint64_t v461 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v459 < v834) {
                  uint64_t v461 = 0;
                }
                int v462 = &v459[v461];
                unint64_t v463 = v65 + 4 * v461;
                uint64_t v464 = v769;
                if (!v460) {
                  uint64_t v464 = 0;
                }
                unint64_t v65 = v463 + 4 * v836;
                float v55 = v462;
                v838 = v462;
                v839 += v800 + v464;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 20:
            v794 = v11;
            *(void *)v814 = (int)v59;
            uint64_t v465 = v42;
            uint64_t v770 = -(v41 * v796);
            while (1)
            {
              int v466 = v866[0];
              unint64_t v467 = v65;
              do
              {
                if (v42)
                {
                  int v468 = *v63;
                  if (!*v63) {
                    goto LABEL_824;
                  }
                  if (v59) {
                    goto LABEL_819;
                  }
                }
                else
                {
                  int v468 = 255;
                  if (v59)
                  {
LABEL_819:
                    if (*v62)
                    {
                      unint64_t v469 = PDAsoftlightPDA_5708(*v69, *v62, *v55, v468);
                      unint64_t v65 = v467;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v469;
                      char *v62 = BYTE4(v469);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v468;
                    }
                    goto LABEL_824;
                  }
                }
                unsigned int v470 = PDAsoftlightPDA_5708(*v69, 255, *v55, v468);
                unint64_t v65 = v467;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v470;
LABEL_824:
                v62 += *(void *)v814;
                uint64_t v471 = &v55[v793];
                if ((unint64_t)v471 >= v65) {
                  uint64_t v472 = -(uint64_t)v797;
                }
                else {
                  uint64_t v472 = 0;
                }
                float v55 = &v471[v472];
                v63 += v465 + v472;
                v69 += v793;
                --v466;
              }
              while (v466);
              if (v834)
              {
                unsigned int v473 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v474 = (unint64_t)v473 >= v834;
                uint64_t v475 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v473 < v834) {
                  uint64_t v475 = 0;
                }
                float v476 = &v473[v475];
                unint64_t v477 = v65 + 4 * v475;
                uint64_t v478 = v770;
                if (!v474) {
                  uint64_t v478 = 0;
                }
                unint64_t v65 = v477 + 4 * v836;
                float v55 = v476;
                v838 = v476;
                v839 += v800 + v478;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 21:
            v794 = v11;
            *(void *)v815 = (int)v59;
            uint64_t v479 = v42;
            uint64_t v771 = -(v41 * v796);
            while (1)
            {
              int v480 = v866[0];
              unint64_t v481 = v65;
              do
              {
                if (v42)
                {
                  signed int v482 = *v63;
                  if (!*v63) {
                    goto LABEL_847;
                  }
                  if (v59) {
                    goto LABEL_842;
                  }
                }
                else
                {
                  signed int v482 = 255;
                  if (v59)
                  {
LABEL_842:
                    if (*v62)
                    {
                      unint64_t v483 = PDAhardlightPDA_5707(*v69, *v62, *v55, v482);
                      unint64_t v65 = v481;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v483;
                      char *v62 = BYTE4(v483);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v482;
                    }
                    goto LABEL_847;
                  }
                }
                unsigned int v484 = PDAhardlightPDA_5707(*v69, 255, *v55, v482);
                unint64_t v65 = v481;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v484;
LABEL_847:
                v62 += *(void *)v815;
                unsigned int v485 = &v55[v793];
                if ((unint64_t)v485 >= v65) {
                  uint64_t v486 = -(uint64_t)v797;
                }
                else {
                  uint64_t v486 = 0;
                }
                float v55 = &v485[v486];
                v63 += v479 + v486;
                v69 += v793;
                --v480;
              }
              while (v480);
              if (v834)
              {
                uint64_t v487 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v488 = (unint64_t)v487 >= v834;
                uint64_t v489 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v487 < v834) {
                  uint64_t v489 = 0;
                }
                uint64_t v490 = &v487[v489];
                unint64_t v491 = v65 + 4 * v489;
                uint64_t v492 = v771;
                if (!v488) {
                  uint64_t v492 = 0;
                }
                unint64_t v65 = v491 + 4 * v836;
                float v55 = v490;
                v838 = v490;
                v839 += v800 + v492;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 22:
            v794 = v11;
            *(void *)v816 = (int)v59;
            uint64_t v493 = v42;
            uint64_t v772 = -(v41 * v796);
            while (1)
            {
              int v494 = v866[0];
              unint64_t v495 = v65;
              do
              {
                if (v42)
                {
                  unsigned int v496 = *v63;
                  if (!*v63) {
                    goto LABEL_870;
                  }
                  if (v59) {
                    goto LABEL_865;
                  }
                }
                else
                {
                  unsigned int v496 = 255;
                  if (v59)
                  {
LABEL_865:
                    if (*v62)
                    {
                      unint64_t v497 = PDAdifferencePDA_5709(*v69, *v62, *v55, v496);
                      unint64_t v65 = v495;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v497;
                      char *v62 = BYTE4(v497);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v496;
                    }
                    goto LABEL_870;
                  }
                }
                unsigned int v498 = PDAdifferencePDA_5709(*v69, 0xFFu, *v55, v496);
                unint64_t v65 = v495;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v498;
LABEL_870:
                v62 += *(void *)v816;
                float v499 = &v55[v793];
                if ((unint64_t)v499 >= v65) {
                  uint64_t v500 = -(uint64_t)v797;
                }
                else {
                  uint64_t v500 = 0;
                }
                float v55 = &v499[v500];
                v63 += v493 + v500;
                v69 += v793;
                --v494;
              }
              while (v494);
              if (v834)
              {
                float v501 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v502 = (unint64_t)v501 >= v834;
                uint64_t v503 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v501 < v834) {
                  uint64_t v503 = 0;
                }
                float v504 = &v501[v503];
                unint64_t v505 = v65 + 4 * v503;
                uint64_t v506 = v772;
                if (!v502) {
                  uint64_t v506 = 0;
                }
                unint64_t v65 = v505 + 4 * v836;
                float v55 = v504;
                v838 = v504;
                v839 += v800 + v506;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 23:
            v794 = v11;
            *(void *)v817 = (int)v59;
            uint64_t v507 = v42;
            uint64_t v773 = -(v41 * v796);
            while (1)
            {
              int v508 = v866[0];
              unint64_t v509 = v65;
              do
              {
                if (v42)
                {
                  signed int v510 = *v63;
                  if (!*v63) {
                    goto LABEL_893;
                  }
                  if (v59) {
                    goto LABEL_888;
                  }
                }
                else
                {
                  signed int v510 = 255;
                  if (v59)
                  {
LABEL_888:
                    if (*v62)
                    {
                      unint64_t v511 = PDAexclusionPDA_5710(*v69, *v62, *v55, v510);
                      unint64_t v65 = v509;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v511;
                      char *v62 = BYTE4(v511);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v510;
                    }
                    goto LABEL_893;
                  }
                }
                unsigned int v512 = PDAexclusionPDA_5710(*v69, 255, *v55, v510);
                unint64_t v65 = v509;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v512;
LABEL_893:
                v62 += *(void *)v817;
                uint64_t v513 = &v55[v793];
                if ((unint64_t)v513 >= v65) {
                  uint64_t v514 = -(uint64_t)v797;
                }
                else {
                  uint64_t v514 = 0;
                }
                float v55 = &v513[v514];
                v63 += v507 + v514;
                v69 += v793;
                --v508;
              }
              while (v508);
              if (v834)
              {
                uint64_t v515 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v516 = (unint64_t)v515 >= v834;
                uint64_t v517 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v515 < v834) {
                  uint64_t v517 = 0;
                }
                int v518 = &v515[v517];
                unint64_t v519 = v65 + 4 * v517;
                uint64_t v520 = v773;
                if (!v516) {
                  uint64_t v520 = 0;
                }
                unint64_t v65 = v519 + 4 * v836;
                float v55 = v518;
                v838 = v518;
                v839 += v800 + v520;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 24:
            v794 = v11;
            *(void *)v818 = (int)v59;
            uint64_t v521 = v42;
            uint64_t v774 = -(v41 * v796);
            while (1)
            {
              int v522 = v866[0];
              unint64_t v523 = v65;
              do
              {
                if (v42)
                {
                  signed int v524 = *v63;
                  if (!*v63) {
                    goto LABEL_916;
                  }
                  if (v59) {
                    goto LABEL_911;
                  }
                }
                else
                {
                  signed int v524 = 255;
                  if (v59)
                  {
LABEL_911:
                    if (*v62)
                    {
                      unint64_t v525 = PDAhuePDA_5711(*v69, *v62, *v55, v524);
                      unint64_t v65 = v523;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v525;
                      char *v62 = BYTE4(v525);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v524;
                    }
                    goto LABEL_916;
                  }
                }
                unsigned int v526 = PDAhuePDA_5711(*v69, 255, *v55, v524);
                unint64_t v65 = v523;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v526;
LABEL_916:
                v62 += *(void *)v818;
                float v527 = &v55[v793];
                if ((unint64_t)v527 >= v65) {
                  uint64_t v528 = -(uint64_t)v797;
                }
                else {
                  uint64_t v528 = 0;
                }
                float v55 = &v527[v528];
                v63 += v521 + v528;
                v69 += v793;
                --v522;
              }
              while (v522);
              if (v834)
              {
                unsigned int v529 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v530 = (unint64_t)v529 >= v834;
                uint64_t v531 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v529 < v834) {
                  uint64_t v531 = 0;
                }
                uint64_t v532 = &v529[v531];
                unint64_t v533 = v65 + 4 * v531;
                uint64_t v534 = v774;
                if (!v530) {
                  uint64_t v534 = 0;
                }
                unint64_t v65 = v533 + 4 * v836;
                float v55 = v532;
                v838 = v532;
                v839 += v800 + v534;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 25:
            v794 = v11;
            *(void *)v819 = (int)v59;
            uint64_t v535 = v42;
            uint64_t v775 = -(v41 * v796);
            while (1)
            {
              int v536 = v866[0];
              unint64_t v537 = v65;
              do
              {
                if (v42)
                {
                  signed int v538 = *v63;
                  if (!*v63) {
                    goto LABEL_939;
                  }
                  if (v59) {
                    goto LABEL_934;
                  }
                }
                else
                {
                  signed int v538 = 255;
                  if (v59)
                  {
LABEL_934:
                    if (*v62)
                    {
                      unint64_t v539 = PDAsaturationPDA_5712(*v69, *v62, *v55, v538);
                      unint64_t v65 = v537;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v539;
                      char *v62 = BYTE4(v539);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v538;
                    }
                    goto LABEL_939;
                  }
                }
                unsigned int v540 = PDAsaturationPDA_5712(*v69, 255, *v55, v538);
                unint64_t v65 = v537;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v540;
LABEL_939:
                v62 += *(void *)v819;
                int v541 = &v55[v793];
                if ((unint64_t)v541 >= v65) {
                  uint64_t v542 = -(uint64_t)v797;
                }
                else {
                  uint64_t v542 = 0;
                }
                float v55 = &v541[v542];
                v63 += v535 + v542;
                v69 += v793;
                --v536;
              }
              while (v536);
              if (v834)
              {
                float v543 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v544 = (unint64_t)v543 >= v834;
                uint64_t v545 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v543 < v834) {
                  uint64_t v545 = 0;
                }
                float v546 = &v543[v545];
                unint64_t v547 = v65 + 4 * v545;
                uint64_t v548 = v775;
                if (!v544) {
                  uint64_t v548 = 0;
                }
                unint64_t v65 = v547 + 4 * v836;
                float v55 = v546;
                v838 = v546;
                v839 += v800 + v548;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 26:
            v794 = v11;
            *(void *)v820 = (int)v59;
            uint64_t v549 = v42;
            uint64_t v776 = -(v41 * v796);
            while (1)
            {
              int v550 = v866[0];
              unint64_t v551 = v65;
              do
              {
                if (v42)
                {
                  signed int v552 = *v63;
                  if (!*v63) {
                    goto LABEL_962;
                  }
                  if (v59) {
                    goto LABEL_957;
                  }
                }
                else
                {
                  signed int v552 = 255;
                  if (v59)
                  {
LABEL_957:
                    unsigned int v553 = *v55;
                    if (*v62)
                    {
                      unint64_t v554 = PDAluminosityPDA_5713(v553, v552, *v69, *v62);
                      unint64_t v65 = v551;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v554;
                      char *v62 = BYTE4(v554);
                    }
                    else
                    {
                      *float v69 = v553;
                      char *v62 = v552;
                    }
                    goto LABEL_962;
                  }
                }
                unsigned int v555 = PDAluminosityPDA_5713(*v55, v552, *v69, 255);
                unint64_t v65 = v551;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v555;
LABEL_962:
                v62 += *(void *)v820;
                uint64_t v556 = &v55[v793];
                if ((unint64_t)v556 >= v65) {
                  uint64_t v557 = -(uint64_t)v797;
                }
                else {
                  uint64_t v557 = 0;
                }
                float v55 = &v556[v557];
                v63 += v549 + v557;
                v69 += v793;
                --v550;
              }
              while (v550);
              if (v834)
              {
                uint64_t v558 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v559 = (unint64_t)v558 >= v834;
                uint64_t v560 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v558 < v834) {
                  uint64_t v560 = 0;
                }
                uint64_t v561 = &v558[v560];
                unint64_t v562 = v65 + 4 * v560;
                uint64_t v563 = v776;
                if (!v559) {
                  uint64_t v563 = 0;
                }
                unint64_t v65 = v562 + 4 * v836;
                float v55 = v561;
                v838 = v561;
                v839 += v800 + v563;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 27:
            v794 = v11;
            *(void *)v821 = (int)v59;
            uint64_t v564 = v42;
            uint64_t v777 = -(v41 * v796);
            while (1)
            {
              int v565 = v866[0];
              unint64_t v566 = v65;
              do
              {
                if (v42)
                {
                  signed int v567 = *v63;
                  if (!*v63) {
                    goto LABEL_985;
                  }
                  if (v59) {
                    goto LABEL_980;
                  }
                }
                else
                {
                  signed int v567 = 255;
                  if (v59)
                  {
LABEL_980:
                    if (*v62)
                    {
                      unint64_t v568 = PDAluminosityPDA_5713(*v69, *v62, *v55, v567);
                      unint64_t v65 = v566;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v568;
                      char *v62 = BYTE4(v568);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v567;
                    }
                    goto LABEL_985;
                  }
                }
                unsigned int v569 = PDAluminosityPDA_5713(*v69, 255, *v55, v567);
                unint64_t v65 = v566;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v569;
LABEL_985:
                v62 += *(void *)v821;
                float v570 = &v55[v793];
                if ((unint64_t)v570 >= v65) {
                  uint64_t v571 = -(uint64_t)v797;
                }
                else {
                  uint64_t v571 = 0;
                }
                float v55 = &v570[v571];
                v63 += v564 + v571;
                v69 += v793;
                --v565;
              }
              while (v565);
              if (v834)
              {
                float v572 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v573 = (unint64_t)v572 >= v834;
                uint64_t v574 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v572 < v834) {
                  uint64_t v574 = 0;
                }
                uint64_t v575 = &v572[v574];
                unint64_t v576 = v65 + 4 * v574;
                uint64_t v577 = v777;
                if (!v573) {
                  uint64_t v577 = 0;
                }
                unint64_t v65 = v576 + 4 * v836;
                float v55 = v575;
                v838 = v575;
                v839 += v800 + v577;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 28:
            v794 = v11;
            *(void *)v822 = (int)v59;
            uint64_t v578 = v42;
            uint64_t v778 = -(v41 * v796);
            while (1)
            {
              int v579 = v866[0];
              unint64_t v580 = v65;
              do
              {
                if (v42)
                {
                  signed int v581 = *v63;
                  if (!*v63) {
                    goto LABEL_1008;
                  }
                  if (v59) {
                    goto LABEL_1003;
                  }
                }
                else
                {
                  signed int v581 = 255;
                  if (v59)
                  {
LABEL_1003:
                    if (*v62)
                    {
                      unint64_t v582 = PDAtranspose_huePDA(*v69, *v62, *v55, v581);
                      unint64_t v65 = v580;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v582;
                      char *v62 = BYTE4(v582);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v581;
                    }
                    goto LABEL_1008;
                  }
                }
                unsigned int v583 = PDAtranspose_huePDA(*v69, 255, *v55, v581);
                unint64_t v65 = v580;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v583;
LABEL_1008:
                v62 += *(void *)v822;
                uint64_t v584 = &v55[v793];
                if ((unint64_t)v584 >= v65) {
                  uint64_t v585 = -(uint64_t)v797;
                }
                else {
                  uint64_t v585 = 0;
                }
                float v55 = &v584[v585];
                v63 += v578 + v585;
                v69 += v793;
                --v579;
              }
              while (v579);
              if (v834)
              {
                int v586 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v587 = (unint64_t)v586 >= v834;
                uint64_t v588 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v586 < v834) {
                  uint64_t v588 = 0;
                }
                float v589 = &v586[v588];
                unint64_t v590 = v65 + 4 * v588;
                uint64_t v591 = v778;
                if (!v587) {
                  uint64_t v591 = 0;
                }
                unint64_t v65 = v590 + 4 * v836;
                float v55 = v589;
                v838 = v589;
                v839 += v800 + v591;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 29:
            v794 = v11;
            *(void *)v823 = (int)v59;
            uint64_t v592 = v42;
            uint64_t v779 = -(v41 * v796);
            while (1)
            {
              int v593 = v866[0];
              unint64_t v594 = v65;
              do
              {
                if (v42)
                {
                  signed int v595 = *v63;
                  if (!*v63) {
                    goto LABEL_1031;
                  }
                  if (v59) {
                    goto LABEL_1026;
                  }
                }
                else
                {
                  signed int v595 = 255;
                  if (v59)
                  {
LABEL_1026:
                    if (*v62)
                    {
                      unint64_t v596 = PDAtranspose_saturationPDA(*v69, *v62, *v55, v595);
                      unint64_t v65 = v594;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v596;
                      char *v62 = BYTE4(v596);
                    }
                    else
                    {
                      *float v69 = *v55;
                      char *v62 = v595;
                    }
                    goto LABEL_1031;
                  }
                }
                unsigned int v597 = PDAtranspose_saturationPDA(*v69, 255, *v55, v595);
                unint64_t v65 = v594;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v597;
LABEL_1031:
                v62 += *(void *)v823;
                uint64_t v598 = &v55[v793];
                if ((unint64_t)v598 >= v65) {
                  uint64_t v599 = -(uint64_t)v797;
                }
                else {
                  uint64_t v599 = 0;
                }
                float v55 = &v598[v599];
                v63 += v592 + v599;
                v69 += v793;
                --v593;
              }
              while (v593);
              if (v834)
              {
                uint64_t v600 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v601 = (unint64_t)v600 >= v834;
                uint64_t v602 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v600 < v834) {
                  uint64_t v602 = 0;
                }
                uint64_t v603 = &v600[v602];
                unint64_t v604 = v65 + 4 * v602;
                uint64_t v605 = v779;
                if (!v601) {
                  uint64_t v605 = 0;
                }
                unint64_t v65 = v604 + 4 * v836;
                float v55 = v603;
                v838 = v603;
                v839 += v800 + v605;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 30:
            v794 = v11;
            *(void *)v824 = (int)v59;
            uint64_t v606 = v42;
            uint64_t v780 = -(v41 * v796);
            while (1)
            {
              int v607 = v866[0];
              unint64_t v608 = v65;
              do
              {
                if (v42)
                {
                  signed int v609 = *v63;
                  if (!*v63) {
                    goto LABEL_1054;
                  }
                  if (v59) {
                    goto LABEL_1049;
                  }
                }
                else
                {
                  signed int v609 = 255;
                  if (v59)
                  {
LABEL_1049:
                    unsigned __int32 v610 = *v55;
                    if (*v62)
                    {
                      unint64_t v611 = PDAtranspose_luminosityPDA(v610, v609, *v69, *v62);
                      unint64_t v65 = v608;
                      LODWORD(v59) = v850;
                      int v42 = v854;
                      *float v69 = v611;
                      char *v62 = BYTE4(v611);
                    }
                    else
                    {
                      *float v69 = v610;
                      char *v62 = v609;
                    }
                    goto LABEL_1054;
                  }
                }
                unsigned int v612 = PDAtranspose_luminosityPDA(*v55, v609, *v69, 255);
                unint64_t v65 = v608;
                LODWORD(v59) = v850;
                int v42 = v854;
                *float v69 = v612;
LABEL_1054:
                v62 += *(void *)v824;
                uint64_t v613 = &v55[v793];
                if ((unint64_t)v613 >= v65) {
                  uint64_t v614 = -(uint64_t)v797;
                }
                else {
                  uint64_t v614 = 0;
                }
                float v55 = &v613[v614];
                v63 += v606 + v614;
                v69 += v793;
                --v607;
              }
              while (v607);
              if (v834)
              {
                uint64_t v615 = &v838[v836];
                uint64_t v41 = v800;
                BOOL v616 = (unint64_t)v615 >= v834;
                uint64_t v617 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v615 < v834) {
                  uint64_t v617 = 0;
                }
                uint64_t v618 = &v615[v617];
                unint64_t v619 = v65 + 4 * v617;
                uint64_t v620 = v780;
                if (!v616) {
                  uint64_t v620 = 0;
                }
                unint64_t v65 = v619 + 4 * v836;
                float v55 = v618;
                v838 = v618;
                v839 += v800 + v620;
                unsigned __int16 v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                uint64_t v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0]) {
                goto LABEL_1089;
              }
            }
          case 31:
            v794 = v11;
            *(void *)v825 = (int)v59;
            uint64_t v621 = v42;
            uint64_t v781 = -(v41 * v796);
            break;
          default:
            goto LABEL_1292;
        }
        break;
      }
LABEL_1068:
      int v622 = v866[0];
      unint64_t v623 = v65;
      while (1)
      {
        if (v42)
        {
          signed int v624 = *v63;
          if (!*v63) {
            goto LABEL_1077;
          }
          if (!v59) {
            goto LABEL_1075;
          }
        }
        else
        {
          signed int v624 = 255;
          if (!v59)
          {
LABEL_1075:
            unsigned int v626 = PDAtranspose_luminosityPDA(*v69, 255, *v55, v624);
            unint64_t v65 = v623;
            LODWORD(v59) = v850;
            int v42 = v854;
            *float v69 = v626;
            goto LABEL_1077;
          }
        }
        if (*v62)
        {
          unint64_t v625 = PDAtranspose_luminosityPDA(*v69, *v62, *v55, v624);
          unint64_t v65 = v623;
          LODWORD(v59) = v850;
          int v42 = v854;
          *float v69 = v625;
          char *v62 = BYTE4(v625);
        }
        else
        {
          *float v69 = *v55;
          char *v62 = v624;
        }
LABEL_1077:
        v62 += *(void *)v825;
        uint64_t v627 = &v55[v793];
        if ((unint64_t)v627 >= v65) {
          uint64_t v628 = -(uint64_t)v797;
        }
        else {
          uint64_t v628 = 0;
        }
        float v55 = &v627[v628];
        v63 += v621 + v628;
        v69 += v793;
        if (!--v622)
        {
          if (v834)
          {
            uint64_t v629 = &v838[v836];
            uint64_t v41 = v800;
            BOOL v630 = (unint64_t)v629 >= v834;
            uint64_t v631 = -(uint64_t)(v836 * v796);
            if ((unint64_t)v629 < v834) {
              uint64_t v631 = 0;
            }
            uint64_t v632 = &v629[v631];
            unint64_t v633 = v65 + 4 * v631;
            uint64_t v634 = v781;
            if (!v630) {
              uint64_t v634 = 0;
            }
            unint64_t v65 = v633 + 4 * v836;
            float v55 = v632;
            v838 = v632;
            v839 += v800 + v634;
            unsigned __int16 v63 = (unsigned __int8 *)v839;
          }
          else
          {
            v55 += v836;
            uint64_t v41 = v800;
            v63 += v800;
          }
          v69 += v802;
          v62 += v832;
          if (!--v856[0]) {
            goto LABEL_1089;
          }
          goto LABEL_1068;
        }
      }
    }
    int v793 = v57;
    unint64_t v64 = v57 * (int)v16;
    uint64_t v59 = v850;
    uint64_t v832 = v790 - (int)v850 * (int)v16;
    unint64_t v65 = -1;
    int v796 = v41;
    int v797 = v40;
    goto LABEL_65;
  }
  int v21 = *(_DWORD *)(v15 + 128);
  if ((v21 | 8) == 8)
  {
    if ((v10 & 0xFF00) == 0x400) {
      cmyk32_mark_constmask(v15, v13);
    }
    else {
      cmyk32_mark_pixelmask(v15, v13);
    }
    return 1;
  }
  int v28 = *(_DWORD *)(v15 + 112);
  int v29 = *(_DWORD *)(v15 + 116);
  unsigned int v30 = (v28 + 15) & 0xFFFFFFF0;
  size_t v31 = v30 * v29;
  if ((int)v31 <= 4096)
  {
    long long v33 = v866;
    goto LABEL_41;
  }
  long long v32 = malloc_type_malloc(v31, 0x8303D2FuLL);
  if (v32)
  {
    long long v33 = v32;
    unsigned int v20 = *(uint16x4_t **)(v15 + 136);
    int v21 = *(_DWORD *)(v15 + 128);
LABEL_41:
    CGSConvertBitsToMask(v20, *(_DWORD *)(v15 + 124), v33, v30, v28, v29, v21);
    long long v49 = *(_OWORD *)(v15 + 112);
    long long v862 = *(_OWORD *)(v15 + 96);
    long long v863 = v49;
    long long v50 = *(_OWORD *)(v15 + 144);
    long long v864 = *(_OWORD *)(v15 + 128);
    long long v865 = v50;
    long long v51 = *(_OWORD *)(v15 + 48);
    long long v858 = *(_OWORD *)(v15 + 32);
    long long v859 = v51;
    long long v52 = *(_OWORD *)(v15 + 80);
    long long v860 = *(_OWORD *)(v15 + 64);
    long long v861 = v52;
    long long v53 = *(_OWORD *)(v15 + 16);
    *(_OWORD *)v856 = *(_OWORD *)v15;
    long long v857 = v53;
    HIDWORD(v863) = (v28 + 15) & 0xFFFFFFF0;
    *((void *)&v864 + 1) = v33;
    if (BYTE1(v856[0]) << 8 == 1024) {
      cmyk32_mark_constmask((uint64_t)v856, v13);
    }
    else {
      cmyk32_mark_pixelmask((unint64_t)v856, v13);
    }
    if (v33 == (unsigned char *)v866) {
      return 1;
    }
    float v54 = v33;
    goto LABEL_1120;
  }
  return 1;
}

void cmyk32_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(void, void))
{
  v79[1] = *MEMORY[0x1E4F143B8];
  v8.n128_u64[1] = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v70 = 0u;
  v8.n128_u64[0] = *(unsigned int *)(a2 + 184);
  v8.n128_f32[0] = (float)(v8.n128_f32[0] * 255.0) + 0.5;
  v67[0] = a3;
  v67[1] = a4;
  LOBYTE(v68) = (int)v8.n128_f32[0];
  unint64_t v9 = (unint64_t)*(int *)(a1 + 28) >> 2;
  *(void *)&long long v69 = v9;
  if (*(void *)(a1 + 48)) {
    uint64_t v10 = *(int *)(a1 + 32);
  }
  else {
    uint64_t v10 = 0;
  }
  *(void *)&long long v70 = v10;
  uint64_t v11 = *(void *)(a2 + 120);
  unsigned int v12 = *(_DWORD *)(a2 + 20);
  unsigned int v13 = HIBYTE(v12);
  unsigned int v14 = BYTE2(v12);
  if (v11)
  {
    unint64_t v15 = *(int *)(a2 + 24);
    unint64_t v16 = (uint64_t *)(a2 + 104);
    unsigned int v17 = (uint64_t *)(a2 + 72);
    int v18 = (uint64_t *)(a2 + 88);
    unsigned int v19 = v13;
  }
  else
  {
    unint64_t v15 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    unint64_t v16 = (uint64_t *)(a2 + 96);
    unsigned int v17 = (uint64_t *)(a2 + 64);
    int v18 = (uint64_t *)(a2 + 80);
    uint64_t v11 = *(void *)(a2 + 112);
    unsigned int v19 = v14;
  }
  uint64_t v20 = *v18;
  uint64_t v21 = *v17;
  uint64_t v22 = *v16;
  char v23 = v19;
  *((void *)&v71 + 1) = v19;
  *((void *)&v70 + 1) = v22;
  *((void *)&v75 + 1) = v15;
  *((void *)&v74 + 1) = v20;
  *((void *)&v73 + 1) = v21;
  *((void *)&v72 + 1) = v11;
  uint64_t v24 = *(void *)(a2 + 128);
  if (v24)
  {
    unint64_t v25 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    uint64_t v26 = (uint64_t *)(a2 + 96);
    unint64_t v27 = (uint64_t *)(a2 + 64);
    int v28 = (uint64_t *)(a2 + 80);
    unsigned int v13 = v14;
  }
  else
  {
    unint64_t v25 = *(int *)(a2 + 24);
    uint64_t v26 = (uint64_t *)(a2 + 104);
    unint64_t v27 = (uint64_t *)(a2 + 72);
    int v28 = (uint64_t *)(a2 + 88);
    uint64_t v24 = *(void *)(a2 + 136);
  }
  uint64_t v66 = &v62;
  uint64_t v29 = *v28;
  uint64_t v30 = *v27;
  uint64_t v31 = *v26;
  *(void *)&long long v72 = v13;
  *(void *)&long long v71 = v31;
  *(void *)&long long v76 = v25;
  *(void *)&long long v75 = v29;
  *(void *)&long long v74 = v30;
  *(void *)&long long v73 = v24;
  uint64_t v32 = *(int *)(a1 + 4);
  MEMORY[0x1F4188790](a1, v8);
  unint64_t v65 = (char *)&v62 - v34 - 15;
  if (v35 <= 0xFFFFFFFFFFFFFFELL) {
    unint64_t v37 = (char *)&v62 - v34 - 15;
  }
  else {
    unint64_t v37 = 0;
  }
  if (v35 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000402)
  {
    uint64_t v63 = v33;
    unint64_t v64 = a5;
    uint64_t v38 = v36;
    unint64_t v37 = (char *)malloc_type_malloc(16 * v32, 0x1B1F656EuLL);
    uint64_t v33 = v63;
    uint64_t v36 = v38;
    a5 = v64;
  }
  *((void *)&v76 + 1) = v37;
  if (v37)
  {
    uint64_t v39 = v32;
    if (*(void *)(a2 + 176))
    {
      if ((int)v32 >= 1)
      {
        unint64_t v40 = (uint64_t *)(v37 + 8);
        uint64_t v41 = -v33;
        uint64_t v42 = v36 - v22;
        do
        {
          if (((v41 + v22) | v42) < 0)
          {
            unint64_t v45 = 0;
            uint64_t v46 = 0;
          }
          else
          {
            unint64_t v43 = ((v22 & (unint64_t)~(-1 << v23)) >> (v23 - 4)) & 0xF;
            char v44 = weights_21383[v43];
            if (v43 - 7 >= 9) {
              unint64_t v45 = -(uint64_t)v15;
            }
            else {
              unint64_t v45 = v15;
            }
            uint64_t v46 = v44 & 0xF;
          }
          uint64_t v33 = v15 * (v22 >> v23);
          *(v40 - 1) = v33;
          *unint64_t v40 = v46 | (16 * v45);
          v40 += 2;
          v22 += v11;
          v42 -= v11;
          --v39;
        }
        while (v39);
      }
    }
    else if ((int)v32 >= 1)
    {
      unint64_t v47 = v37 + 8;
      do
      {
        *(v47 - 1) = v15 * (v22 >> v23);
        *unint64_t v47 = 0;
        v47 += 2;
        v22 += v11;
        --v39;
      }
      while (v39);
    }
    unint64_t v48 = v37;
    int v49 = *(_DWORD *)(a1 + 4);
    int v50 = *(_DWORD *)(a1 + 8);
    int v77 = v50;
    int v78 = v49;
    long long v51 = *(int **)(a1 + 136);
    if (v51)
    {
      int v52 = *(_DWORD *)(a1 + 104);
      LODWORD(v79[0]) = *(_DWORD *)(a1 + 108);
      HIDWORD(v79[0]) = v52;
      shape_enum_clip_alloc((uint64_t)v37, v33, v51, 1, 1, 1, v52, v79[0], v49, v50);
      float v54 = v53;
      if (v53) {
        goto LABEL_36;
      }
    }
    int v55 = 0;
    int v56 = 0;
    float v54 = 0;
    v79[0] = 0;
    while (1)
    {
      uint64_t v57 = *(int *)(a1 + 16) + (uint64_t)v56;
      uint64_t v58 = *(void *)(a1 + 48);
      uint64_t v59 = *(int *)(a1 + 12) + (uint64_t)v55;
      uint64_t v60 = *(void *)(a1 + 40) + 4 * v9 * v57 + 4 * v59;
      uint64_t v61 = v58 + v10 * v57 + v59;
      if (!v58) {
        uint64_t v61 = 0;
      }
      *((void *)&v68 + 1) = v60;
      *((void *)&v69 + 1) = v61;
      a5(a2, v67);
      if (!v54) {
        break;
      }
LABEL_36:
      if (!shape_enum_clip_next((uint64_t)v54, (int *)v79 + 1, v79, &v78, &v77))
      {
        free(v54);
        break;
      }
      int v56 = v79[0];
      int v55 = HIDWORD(v79[0]);
      unint64_t v9 = v69;
      uint64_t v10 = v70;
    }
    if (v48 != v65) {
      free(v48);
    }
  }
}

unint64_t cmyk32_image_mark_rgb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  unint64_t v115 = result;
  if (*(void *)(result + 40)) {
    int v7 = 0;
  }
  else {
    int v7 = 255;
  }
  int v119 = v7;
  __n128 v8 = (unsigned int *)*((void *)a2 + 2);
  unint64_t v9 = (unsigned __int8 *)*((void *)a2 + 4);
  if (v9) {
    uint64_t v108 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v108 = 0;
  }
  int v10 = a2[1];
  int v107 = *a2;
  uint64_t v106 = *((void *)a2 + 3) - a5;
  uint64_t v118 = v9 != 0;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v103 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v103 * a4;
  unint64_t v15 = *(unsigned int **)(result + 32);
  unint64_t v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  char v104 = v13;
  uint64_t v105 = v12;
  if (*(void *)(result + 176))
  {
    uint64_t v99 = ~(-1 << v13);
    uint64_t v100 = *((void *)a2 + 15);
    uint64_t v101 = *((void *)a2 + 13);
    char v98 = v13 - 4;
    uint64_t v97 = -v12;
    unsigned int v17 = (unsigned int *)(v16 - 4);
    char v18 = a2[1];
    char v116 = 32 - v10;
    uint64_t v95 = v11 + 16 * a3 + 8;
    uint64_t v96 = a5;
    while (1)
    {
      if (((v100 - v14) | (v14 - v101)) < 0)
      {
        int v23 = 0;
        uint64_t v113 = 0;
      }
      else
      {
        uint64_t v19 = ((v14 & (unint64_t)v99) >> v98) & 0xF;
        char v20 = weights_21383[v19];
        BOOL v21 = (unint64_t)(v19 - 7) >= 9;
        uint64_t v22 = v97;
        if (!v21) {
          uint64_t v22 = v12;
        }
        uint64_t v113 = v22;
        int v23 = v20 & 0xF;
      }
      uint64_t v24 = *(void *)(v115 + 32) + (v14 >> v13) * v12;
      int v111 = a6;
      uint64_t v109 = v14;
      if (v107 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v26 = (uint64_t *)v95;
        uint64_t v25 = v96;
        while (1)
        {
          uint64_t v27 = *(v26 - 1);
          uint64_t v28 = *v26;
          uint64_t v29 = v24 + v27;
          if ((unint64_t)v17 >= v24 + v27) {
            uint64_t v30 = (unsigned int *)(v24 + v27);
          }
          else {
            uint64_t v30 = v17;
          }
          if (v30 < v15) {
            uint64_t v30 = v15;
          }
          unsigned int v31 = *v30;
          char v32 = v28 & 0xF;
          if ((v28 & 0xF) != 0) {
            break;
          }
          if (v23)
          {
            unint64_t v43 = (unsigned int *)(v29 + v113);
            if ((unint64_t)v17 < v29 + v113) {
              unint64_t v43 = v17;
            }
            if (v43 < v15) {
              unint64_t v43 = v15;
            }
            int v44 = BLEND8_21385[v23];
            unsigned int v41 = v31 - ((v44 & v31) >> v23);
            unsigned int v42 = (v44 & *v43) >> v23;
            goto LABEL_45;
          }
LABEL_46:
          unsigned int v45 = (v31 << v18) | (v31 >> v116);
          unsigned int v46 = HIBYTE(v45);
          if (HIBYTE(v45) <= BYTE2(v45)) {
            unsigned int v46 = BYTE2(v45);
          }
          if (v46 <= BYTE1(v45)) {
            unsigned int v46 = BYTE1(v45);
          }
          uint64_t v47 = v45 | v119;
          signed int v48 = (v47 - v46) | ((v46 - BYTE2(v45)) << 16) | ((v46 - HIBYTE(v45)) << 24) | ((v46 - BYTE1(v45)) << 8);
          uint64_t result = v48 | (unint64_t)(v47 << 32);
          if (v6 != 255) {
            uint64_t result = PDAM_5699(v48, BYTE4(result), v6);
          }
          *__n128 v8 = result;
          if (v9) {
            *unint64_t v9 = BYTE4(result);
          }
          v26 += 2;
          ++v8;
          v9 += v118;
          if (!--v25) {
            goto LABEL_103;
          }
        }
        uint64_t v33 = (unsigned int *)(v29 + (v28 >> 4));
        if (v17 < v33) {
          uint64_t v33 = v17;
        }
        if (v33 < v15) {
          uint64_t v33 = v15;
        }
        unsigned int v34 = *v33;
        if (v23)
        {
          unint64_t v35 = (unsigned int *)(v29 + v113);
          if (v17 >= v35) {
            uint64_t v36 = v35;
          }
          else {
            uint64_t v36 = v17;
          }
          if (v36 < v15) {
            uint64_t v36 = v15;
          }
          unsigned int v37 = *v36;
          uint64_t v38 = (unsigned int *)((char *)v35 + (v28 >> 4));
          if (v17 < v38) {
            uint64_t v38 = v17;
          }
          if (v38 < v15) {
            uint64_t v38 = v15;
          }
          int v39 = BLEND8_21385[v23];
          unsigned int v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
        }
        int v40 = BLEND8_21385[*v26 & 0xF];
        unsigned int v41 = v31 - ((v40 & v31) >> v32);
        unsigned int v42 = (v40 & v34) >> v32;
LABEL_45:
        unsigned int v31 = v41 + v42;
        goto LABEL_46;
      }
LABEL_103:
      uint64_t v12 = v105;
      v8 += v106;
      v9 += v108;
      LOBYTE(v13) = v104;
      uint64_t v14 = v109 + v103;
      a6 = v111 - 1;
      if (v111 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_103;
    }
    int v50 = (uint64_t *)v95;
    uint64_t v49 = v96;
    while (1)
    {
      uint64_t v51 = *(v50 - 1);
      uint64_t v52 = *v50;
      uint64_t v53 = v24 + v51;
      if ((unint64_t)v17 >= v24 + v51) {
        float v54 = (unsigned int *)(v24 + v51);
      }
      else {
        float v54 = v17;
      }
      if (v54 < v15) {
        float v54 = v15;
      }
      unsigned int v55 = *v54;
      char v56 = v52 & 0xF;
      if ((v52 & 0xF) != 0) {
        break;
      }
      if (v23)
      {
        unint64_t v67 = (unsigned int *)(v53 + v113);
        if ((unint64_t)v17 < v53 + v113) {
          unint64_t v67 = v17;
        }
        if (v67 < v15) {
          unint64_t v67 = v15;
        }
        int v68 = BLEND8_21385[v23];
        unsigned int v65 = v55 - ((v68 & v55) >> v23);
        unsigned int v66 = (v68 & *v67) >> v23;
        goto LABEL_86;
      }
LABEL_87:
      unsigned int v69 = (v55 << v18) | (v55 >> v116);
      unsigned int v70 = HIBYTE(v69);
      if (HIBYTE(v69) <= BYTE2(v69)) {
        unsigned int v70 = BYTE2(v69);
      }
      if (v70 <= BYTE1(v69)) {
        unsigned int v70 = BYTE1(v69);
      }
      uint64_t v71 = v69 | v119;
      uint64_t result = (v71 - v70) | ((v70 - BYTE2(v69)) << 16) | ((v70 - HIBYTE(v69)) << 24) | ((v70 - BYTE1(v69)) << 8);
      unint64_t v72 = (int)result | (unint64_t)(v71 << 32);
      if (v6 != 255)
      {
        uint64_t result = PDAM_5699(result, BYTE4(v72), v6);
        unint64_t v72 = result;
      }
      if (v9)
      {
        if (BYTE4(v72))
        {
          if (BYTE4(v72) == 255)
          {
            *__n128 v8 = v72;
            *unint64_t v9 = -1;
          }
          else
          {
            uint64_t result = (unint64_t)DAplusDAM(v8, v9, v72, SBYTE4(v72), *v8, *v9, ~BYTE4(v72));
          }
        }
      }
      else if (BYTE4(v72))
      {
        if (BYTE4(v72) == 255)
        {
          *__n128 v8 = v72;
        }
        else
        {
          int v73 = ~BYTE4(v72);
          *__n128 v8 = ((((*v8 >> 8) & 0xFF00FF) * v73 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) & 0xFF00FF00)
              + v72
              + ((((*v8 & 0xFF00FF) * v73 + 65537 + ((((*v8 & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        }
      }
      v50 += 2;
      ++v8;
      v9 += v118;
      if (!--v49) {
        goto LABEL_103;
      }
    }
    uint64_t v57 = (unsigned int *)(v53 + (v52 >> 4));
    if (v17 < v57) {
      uint64_t v57 = v17;
    }
    if (v57 < v15) {
      uint64_t v57 = v15;
    }
    unsigned int v58 = *v57;
    if (v23)
    {
      uint64_t v59 = (unsigned int *)(v53 + v113);
      if (v17 >= v59) {
        uint64_t v60 = v59;
      }
      else {
        uint64_t v60 = v17;
      }
      if (v60 < v15) {
        uint64_t v60 = v15;
      }
      unsigned int v61 = *v60;
      uint64_t v62 = (unsigned int *)((char *)v59 + (v52 >> 4));
      if (v17 < v62) {
        uint64_t v62 = v17;
      }
      if (v62 < v15) {
        uint64_t v62 = v15;
      }
      int v63 = BLEND8_21385[v23];
      unsigned int v55 = v55 - ((v63 & v55) >> v23) + ((v63 & v61) >> v23);
      unsigned int v58 = v58 - ((v63 & v58) >> v23) + ((v63 & *v62) >> v23);
    }
    int v64 = BLEND8_21385[*v50 & 0xF];
    unsigned int v65 = v55 - ((v64 & v55) >> v56);
    unsigned int v66 = (v64 & v58) >> v56;
LABEL_86:
    unsigned int v55 = v65 + v66;
    goto LABEL_87;
  }
  int v117 = (uint64_t *)(v11 + 16 * a3);
  long long v74 = v16 - 4;
  char v75 = a2[1];
  char v76 = 32 - v10;
  uint64_t v114 = a5;
  do
  {
    uint64_t v77 = *(void *)(v115 + 32) + (v14 >> v13) * v12;
    int v112 = a6;
    uint64_t v110 = v14;
    if (v107 == 1)
    {
      if (a5 >= 1)
      {
        int v78 = v117;
        uint64_t v79 = v114;
        do
        {
          uint64_t v80 = *v78;
          v78 += 2;
          int v81 = (char *)(v77 + v80);
          if ((unint64_t)v74 < v77 + v80) {
            int v81 = v74;
          }
          if ((unint64_t)v81 < *(void *)(v115 + 32)) {
            int v81 = *(char **)(v115 + 32);
          }
          unsigned int v82 = (*(_DWORD *)v81 << v75) | (*(_DWORD *)v81 >> v76);
          unsigned int v83 = HIBYTE(v82);
          if (HIBYTE(v82) <= BYTE2(v82)) {
            unsigned int v83 = BYTE2(v82);
          }
          if (v83 <= BYTE1(v82)) {
            unsigned int v83 = BYTE1(v82);
          }
          uint64_t v84 = v82 | v119;
          signed int v85 = (v84 - v83) | ((v83 - BYTE2(v82)) << 16) | ((v83 - HIBYTE(v82)) << 24) | ((v83 - BYTE1(v82)) << 8);
          uint64_t result = v85 | (unint64_t)(v84 << 32);
          if (v6 != 255) {
            uint64_t result = PDAM_5699(v85, BYTE4(result), v6);
          }
          *__n128 v8 = result;
          if (v9) {
            *unint64_t v9 = BYTE4(result);
          }
          ++v8;
          v9 += v118;
          --v79;
        }
        while (v79);
      }
    }
    else
    {
      uint64_t v86 = v117;
      uint64_t v87 = v114;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v88 = *v86;
          v86 += 2;
          unsigned int v89 = (char *)(v77 + v88);
          if ((unint64_t)v74 < v77 + v88) {
            unsigned int v89 = v74;
          }
          if ((unint64_t)v89 < *(void *)(v115 + 32)) {
            unsigned int v89 = *(char **)(v115 + 32);
          }
          unsigned int v90 = (*(_DWORD *)v89 << v75) | (*(_DWORD *)v89 >> v76);
          unsigned int v91 = HIBYTE(v90);
          if (HIBYTE(v90) <= BYTE2(v90)) {
            unsigned int v91 = BYTE2(v90);
          }
          if (v91 <= BYTE1(v90)) {
            unsigned int v91 = BYTE1(v90);
          }
          uint64_t v92 = v90 | v119;
          uint64_t result = (v92 - v91) | ((v91 - BYTE2(v90)) << 16) | ((v91 - HIBYTE(v90)) << 24) | ((v91 - BYTE1(v90)) << 8);
          unint64_t v93 = (int)result | (unint64_t)(v92 << 32);
          if (v6 != 255)
          {
            uint64_t result = PDAM_5699(result, BYTE4(v93), v6);
            unint64_t v93 = result;
          }
          if (v9)
          {
            if (BYTE4(v93))
            {
              if (BYTE4(v93) == 255)
              {
                *__n128 v8 = v93;
                *unint64_t v9 = -1;
              }
              else
              {
                uint64_t result = (unint64_t)DAplusDAM(v8, v9, v93, SBYTE4(v93), *v8, *v9, ~BYTE4(v93));
              }
            }
          }
          else if (BYTE4(v93))
          {
            if (BYTE4(v93) == 255)
            {
              *__n128 v8 = v93;
            }
            else
            {
              int v94 = ~BYTE4(v93);
              *__n128 v8 = ((((*v8 >> 8) & 0xFF00FF) * v94 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v94) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                  + v93
                  + ((((*v8 & 0xFF00FF) * v94 + 65537 + ((((*v8 & 0xFF00FF) * v94) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
          }
          ++v8;
          v9 += v118;
          --v87;
        }
        while (v87);
      }
    }
    uint64_t v12 = v105;
    v8 += v106;
    v9 += v108;
    LOBYTE(v13) = v104;
    uint64_t v14 = v110 + v103;
    a6 = v112 - 1;
  }
  while (v112 != 1);
  return result;
}

unint64_t cmyk32_image_mark_RGB32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  unint64_t v117 = result;
  if (*(void *)(result + 40)) {
    int v7 = 0;
  }
  else {
    int v7 = 255;
  }
  int v121 = v7;
  __n128 v8 = (unsigned int *)*((void *)a2 + 2);
  unint64_t v9 = (unsigned __int8 *)*((void *)a2 + 4);
  if (v9) {
    uint64_t v110 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v110 = 0;
  }
  int v10 = a2[1];
  int v109 = *a2;
  uint64_t v108 = *((void *)a2 + 3) - a5;
  uint64_t v120 = v9 != 0;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v105 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v105 * a4;
  unint64_t v15 = *(unsigned int **)(result + 32);
  unint64_t v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  char v106 = v13;
  uint64_t v107 = v12;
  if (*(void *)(result + 176))
  {
    uint64_t v101 = ~(-1 << v13);
    uint64_t v102 = *((void *)a2 + 15);
    uint64_t v103 = *((void *)a2 + 13);
    char v100 = v13 - 4;
    uint64_t v99 = -v12;
    unsigned int v17 = (unsigned int *)(v16 - 4);
    char v18 = a2[1];
    char v118 = 32 - v10;
    uint64_t v97 = v11 + 16 * a3 + 8;
    uint64_t v98 = a5;
    while (1)
    {
      if (((v102 - v14) | (v14 - v103)) < 0)
      {
        int v23 = 0;
        uint64_t v115 = 0;
      }
      else
      {
        uint64_t v19 = ((v14 & (unint64_t)v101) >> v100) & 0xF;
        char v20 = weights_21383[v19];
        BOOL v21 = (unint64_t)(v19 - 7) >= 9;
        uint64_t v22 = v99;
        if (!v21) {
          uint64_t v22 = v12;
        }
        uint64_t v115 = v22;
        int v23 = v20 & 0xF;
      }
      uint64_t v24 = *(void *)(v117 + 32) + (v14 >> v13) * v12;
      int v113 = a6;
      uint64_t v111 = v14;
      if (v109 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v26 = (uint64_t *)v97;
        uint64_t v25 = v98;
        while (1)
        {
          uint64_t v27 = *(v26 - 1);
          uint64_t v28 = *v26;
          uint64_t v29 = v24 + v27;
          if ((unint64_t)v17 >= v24 + v27) {
            uint64_t v30 = (unsigned int *)(v24 + v27);
          }
          else {
            uint64_t v30 = v17;
          }
          if (v30 < v15) {
            uint64_t v30 = v15;
          }
          unsigned int v31 = bswap32(*v30);
          char v32 = v28 & 0xF;
          if ((v28 & 0xF) != 0) {
            break;
          }
          if (v23)
          {
            unint64_t v43 = (unsigned int *)(v29 + v115);
            if ((unint64_t)v17 < v29 + v115) {
              unint64_t v43 = v17;
            }
            if (v43 < v15) {
              unint64_t v43 = v15;
            }
            int v44 = BLEND8_21385[v23];
            unsigned int v41 = v31 - ((v44 & v31) >> v23);
            unsigned int v42 = (bswap32(*v43) & v44) >> v23;
            goto LABEL_45;
          }
LABEL_46:
          unsigned int v45 = (v31 << v18) | (v31 >> v118);
          unsigned int v46 = HIBYTE(v45);
          if (HIBYTE(v45) <= BYTE2(v45)) {
            unsigned int v46 = BYTE2(v45);
          }
          if (v46 <= BYTE1(v45)) {
            unsigned int v46 = BYTE1(v45);
          }
          uint64_t v47 = v45 | v121;
          signed int v48 = (v47 - v46) | ((v46 - BYTE2(v45)) << 16) | ((v46 - HIBYTE(v45)) << 24) | ((v46 - BYTE1(v45)) << 8);
          uint64_t result = v48 | (unint64_t)(v47 << 32);
          if (v6 != 255) {
            uint64_t result = PDAM_5699(v48, BYTE4(result), v6);
          }
          *__n128 v8 = result;
          if (v9) {
            *unint64_t v9 = BYTE4(result);
          }
          v26 += 2;
          ++v8;
          v9 += v120;
          if (!--v25) {
            goto LABEL_103;
          }
        }
        uint64_t v33 = (unsigned int *)(v29 + (v28 >> 4));
        if (v17 < v33) {
          uint64_t v33 = v17;
        }
        if (v33 < v15) {
          uint64_t v33 = v15;
        }
        unsigned int v34 = bswap32(*v33);
        if (v23)
        {
          unint64_t v35 = (unsigned int *)(v29 + v115);
          if (v17 >= v35) {
            uint64_t v36 = v35;
          }
          else {
            uint64_t v36 = v17;
          }
          if (v36 < v15) {
            uint64_t v36 = v15;
          }
          unsigned int v37 = bswap32(*v36);
          uint64_t v38 = (unsigned int *)((char *)v35 + (v28 >> 4));
          if (v17 < v38) {
            uint64_t v38 = v17;
          }
          if (v38 < v15) {
            uint64_t v38 = v15;
          }
          int v39 = BLEND8_21385[v23];
          unsigned int v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((bswap32(*v38) & v39) >> v23);
        }
        int v40 = BLEND8_21385[*v26 & 0xF];
        unsigned int v41 = v31 - ((v40 & v31) >> v32);
        unsigned int v42 = (v40 & v34) >> v32;
LABEL_45:
        unsigned int v31 = v41 + v42;
        goto LABEL_46;
      }
LABEL_103:
      uint64_t v12 = v107;
      v8 += v108;
      v9 += v110;
      LOBYTE(v13) = v106;
      uint64_t v14 = v111 + v105;
      a6 = v113 - 1;
      if (v113 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_103;
    }
    int v50 = (uint64_t *)v97;
    uint64_t v49 = v98;
    while (1)
    {
      uint64_t v51 = *(v50 - 1);
      uint64_t v52 = *v50;
      uint64_t v53 = v24 + v51;
      if ((unint64_t)v17 >= v24 + v51) {
        float v54 = (unsigned int *)(v24 + v51);
      }
      else {
        float v54 = v17;
      }
      if (v54 < v15) {
        float v54 = v15;
      }
      unsigned int v55 = bswap32(*v54);
      char v56 = v52 & 0xF;
      if ((v52 & 0xF) != 0) {
        break;
      }
      if (v23)
      {
        unint64_t v67 = (unsigned int *)(v53 + v115);
        if ((unint64_t)v17 < v53 + v115) {
          unint64_t v67 = v17;
        }
        if (v67 < v15) {
          unint64_t v67 = v15;
        }
        int v68 = BLEND8_21385[v23];
        unsigned int v65 = v55 - ((v68 & v55) >> v23);
        unsigned int v66 = (bswap32(*v67) & v68) >> v23;
        goto LABEL_86;
      }
LABEL_87:
      unsigned int v69 = (v55 << v18) | (v55 >> v118);
      unsigned int v70 = HIBYTE(v69);
      if (HIBYTE(v69) <= BYTE2(v69)) {
        unsigned int v70 = BYTE2(v69);
      }
      if (v70 <= BYTE1(v69)) {
        unsigned int v70 = BYTE1(v69);
      }
      uint64_t v71 = v69 | v121;
      uint64_t result = (v71 - v70) | ((v70 - BYTE2(v69)) << 16) | ((v70 - HIBYTE(v69)) << 24) | ((v70 - BYTE1(v69)) << 8);
      unint64_t v72 = (int)result | (unint64_t)(v71 << 32);
      if (v6 != 255)
      {
        uint64_t result = PDAM_5699(result, BYTE4(v72), v6);
        unint64_t v72 = result;
      }
      if (v9)
      {
        if (BYTE4(v72))
        {
          if (BYTE4(v72) == 255)
          {
            *__n128 v8 = v72;
            *unint64_t v9 = -1;
          }
          else
          {
            uint64_t result = (unint64_t)DAplusDAM(v8, v9, v72, SBYTE4(v72), *v8, *v9, ~BYTE4(v72));
          }
        }
      }
      else if (BYTE4(v72))
      {
        if (BYTE4(v72) == 255)
        {
          *__n128 v8 = v72;
        }
        else
        {
          int v73 = ~BYTE4(v72);
          *__n128 v8 = ((((*v8 >> 8) & 0xFF00FF) * v73 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) & 0xFF00FF00)
              + v72
              + ((((*v8 & 0xFF00FF) * v73 + 65537 + ((((*v8 & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        }
      }
      v50 += 2;
      ++v8;
      v9 += v120;
      if (!--v49) {
        goto LABEL_103;
      }
    }
    uint64_t v57 = (unsigned int *)(v53 + (v52 >> 4));
    if (v17 < v57) {
      uint64_t v57 = v17;
    }
    if (v57 < v15) {
      uint64_t v57 = v15;
    }
    unsigned int v58 = bswap32(*v57);
    if (v23)
    {
      uint64_t v59 = (unsigned int *)(v53 + v115);
      if (v17 >= v59) {
        uint64_t v60 = v59;
      }
      else {
        uint64_t v60 = v17;
      }
      if (v60 < v15) {
        uint64_t v60 = v15;
      }
      unsigned int v61 = bswap32(*v60);
      uint64_t v62 = (unsigned int *)((char *)v59 + (v52 >> 4));
      if (v17 < v62) {
        uint64_t v62 = v17;
      }
      if (v62 < v15) {
        uint64_t v62 = v15;
      }
      int v63 = BLEND8_21385[v23];
      unsigned int v55 = v55 - ((v63 & v55) >> v23) + ((v63 & v61) >> v23);
      unsigned int v58 = v58 - ((v63 & v58) >> v23) + ((bswap32(*v62) & v63) >> v23);
    }
    int v64 = BLEND8_21385[*v50 & 0xF];
    unsigned int v65 = v55 - ((v64 & v55) >> v56);
    unsigned int v66 = (v64 & v58) >> v56;
LABEL_86:
    unsigned int v55 = v65 + v66;
    goto LABEL_87;
  }
  int v119 = (uint64_t *)(v11 + 16 * a3);
  long long v74 = (unsigned int *)(v16 - 4);
  char v75 = a2[1];
  char v76 = 32 - v10;
  uint64_t v116 = a5;
  do
  {
    uint64_t v77 = *(void *)(v117 + 32) + (v14 >> v13) * v12;
    int v114 = a6;
    uint64_t v112 = v14;
    if (v109 == 1)
    {
      if (a5 >= 1)
      {
        int v78 = v119;
        uint64_t v79 = v116;
        do
        {
          uint64_t v80 = *v78;
          v78 += 2;
          int v81 = (unsigned int *)(v77 + v80);
          if ((unint64_t)v74 < v77 + v80) {
            int v81 = v74;
          }
          if ((unint64_t)v81 < *(void *)(v117 + 32)) {
            int v81 = *(unsigned int **)(v117 + 32);
          }
          unsigned int v82 = bswap32(*v81);
          unsigned int v83 = (v82 << v75) | (v82 >> v76);
          unsigned int v84 = HIBYTE(v83);
          if (HIBYTE(v83) <= BYTE2(v83)) {
            unsigned int v84 = BYTE2(v83);
          }
          if (v84 <= BYTE1(v83)) {
            unsigned int v84 = BYTE1(v83);
          }
          uint64_t v85 = v83 | v121;
          signed int v86 = (v85 - v84) | ((v84 - BYTE2(v83)) << 16) | ((v84 - HIBYTE(v83)) << 24) | ((v84 - BYTE1(v83)) << 8);
          uint64_t result = v86 | (unint64_t)(v85 << 32);
          if (v6 != 255) {
            uint64_t result = PDAM_5699(v86, BYTE4(result), v6);
          }
          *__n128 v8 = result;
          if (v9) {
            *unint64_t v9 = BYTE4(result);
          }
          ++v8;
          v9 += v120;
          --v79;
        }
        while (v79);
      }
    }
    else
    {
      uint64_t v87 = v119;
      uint64_t v88 = v116;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v89 = *v87;
          v87 += 2;
          unsigned int v90 = (unsigned int *)(v77 + v89);
          if ((unint64_t)v74 < v77 + v89) {
            unsigned int v90 = v74;
          }
          if ((unint64_t)v90 < *(void *)(v117 + 32)) {
            unsigned int v90 = *(unsigned int **)(v117 + 32);
          }
          unsigned int v91 = bswap32(*v90);
          unsigned int v92 = (v91 << v75) | (v91 >> v76);
          unsigned int v93 = HIBYTE(v92);
          if (HIBYTE(v92) <= BYTE2(v92)) {
            unsigned int v93 = BYTE2(v92);
          }
          if (v93 <= BYTE1(v92)) {
            unsigned int v93 = BYTE1(v92);
          }
          uint64_t v94 = v92 | v121;
          uint64_t result = (v94 - v93) | ((v93 - BYTE2(v92)) << 16) | ((v93 - HIBYTE(v92)) << 24) | ((v93 - BYTE1(v92)) << 8);
          unint64_t v95 = (int)result | (unint64_t)(v94 << 32);
          if (v6 != 255)
          {
            uint64_t result = PDAM_5699(result, BYTE4(v95), v6);
            unint64_t v95 = result;
          }
          if (v9)
          {
            if (BYTE4(v95))
            {
              if (BYTE4(v95) == 255)
              {
                *__n128 v8 = v95;
                *unint64_t v9 = -1;
              }
              else
              {
                uint64_t result = (unint64_t)DAplusDAM(v8, v9, v95, SBYTE4(v95), *v8, *v9, ~BYTE4(v95));
              }
            }
          }
          else if (BYTE4(v95))
          {
            if (BYTE4(v95) == 255)
            {
              *__n128 v8 = v95;
            }
            else
            {
              int v96 = ~BYTE4(v95);
              *__n128 v8 = ((((*v8 >> 8) & 0xFF00FF) * v96 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v96) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                  + v95
                  + ((((*v8 & 0xFF00FF) * v96 + 65537 + ((((*v8 & 0xFF00FF) * v96) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
          }
          ++v8;
          v9 += v120;
          --v88;
        }
        while (v88);
      }
    }
    uint64_t v12 = v107;
    v8 += v108;
    v9 += v110;
    LOBYTE(v13) = v106;
    uint64_t v14 = v112 + v105;
    a6 = v114 - 1;
  }
  while (v114 != 1);
  return result;
}

unint64_t cmyk32_image_mark_RGB24(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  unint64_t v109 = result;
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = (unsigned int *)*((void *)a2 + 2);
  __n128 v8 = (unsigned __int8 *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v103 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v103 = 0;
  }
  int v102 = *a2;
  uint64_t v101 = *((void *)a2 + 3) - a5;
  uint64_t v9 = v8 != 0;
  uint64_t v11 = *((void *)a2 + 17);
  uint64_t v10 = *((void *)a2 + 18);
  uint64_t v12 = *((void *)a2 + 9);
  uint64_t v98 = *((void *)a2 + 11);
  uint64_t v13 = *((void *)a2 + 7) + v98 * a4;
  uint64_t v14 = *(unsigned __int8 **)(result + 32);
  unint64_t v15 = &v14[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  uint64_t v96 = a5;
  char v99 = v12;
  uint64_t v100 = v11;
  if (*(void *)(result + 176))
  {
    uint64_t v95 = *((void *)a2 + 13);
    uint64_t v93 = ~(-1 << v12);
    uint64_t v94 = *((void *)a2 + 15);
    char v92 = v12 - 4;
    unint64_t v16 = v15 - 3;
    uint64_t v90 = v10 + 16 * a3 + 8;
    uint64_t v91 = -v11;
    while (1)
    {
      if (((v94 - v13) | (v13 - v95)) < 0)
      {
        int v21 = 0;
        uint64_t v107 = 0;
      }
      else
      {
        uint64_t v17 = ((v13 & (unint64_t)v93) >> v92) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v91;
        if (!v19) {
          uint64_t v20 = v11;
        }
        uint64_t v107 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v109 + 32) + (v13 >> v12) * v11;
      int v105 = a6;
      uint64_t v104 = v13;
      if (v102 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        int v23 = (uint64_t *)v90;
        for (uint64_t i = v96; i; --i)
        {
          uint64_t v25 = *(v23 - 1);
          uint64_t v26 = *v23;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25) {
            uint64_t v28 = (unsigned __int8 *)(v22 + v25);
          }
          else {
            uint64_t v28 = v16;
          }
          if (v28 < v14) {
            uint64_t v28 = v14;
          }
          unsigned int v29 = (*v28 << 24) | (v28[1] << 16) | (v28[2] << 8);
          char v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0)
          {
            unsigned int v31 = (unsigned __int8 *)(v27 + (v26 >> 4));
            if (v16 < v31) {
              unsigned int v31 = v16;
            }
            if (v31 < v14) {
              unsigned int v31 = v14;
            }
            int v32 = (*v31 << 24) | (v31[1] << 16) | (v31[2] << 8);
            if (v21)
            {
              uint64_t v33 = (unsigned __int8 *)(v27 + v107);
              if (v16 >= v33) {
                unsigned int v34 = v33;
              }
              else {
                unsigned int v34 = v16;
              }
              if (v34 < v14) {
                unsigned int v34 = v14;
              }
              int v35 = (*v34 << 24) | (v34[1] << 16) | (v34[2] << 8);
              uint64_t v36 = &v33[v26 >> 4];
              if (v16 < v36) {
                uint64_t v36 = v16;
              }
              if (v36 < v14) {
                uint64_t v36 = v14;
              }
              unsigned int v37 = BLEND8_21385[v21];
              unsigned int v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
              int v32 = v32 - ((v37 & v32) >> v21) + ((((*v36 << 24) | (v36[1] << 16) | (v36[2] << 8)) & v37) >> v21);
            }
            int v38 = BLEND8_21385[*v23 & 0xF];
            unsigned int v39 = v29 - ((v38 & v29) >> v30);
            unsigned int v40 = (v38 & v32) >> v30;
          }
          else
          {
            if (!v21) {
              goto LABEL_43;
            }
            unsigned int v41 = (unsigned __int8 *)(v27 + v107);
            if ((unint64_t)v16 < v27 + v107) {
              unsigned int v41 = v16;
            }
            if (v41 < v14) {
              unsigned int v41 = v14;
            }
            unsigned int v42 = BLEND8_21385[v21];
            unsigned int v39 = v29 - ((v42 & v29) >> v21);
            unsigned int v40 = (((*v41 << 24) | (v41[1] << 16) | (v41[2] << 8)) & v42) >> v21;
          }
          unsigned int v29 = v39 + v40;
LABEL_43:
          unsigned int v43 = HIBYTE(v29);
          if (HIBYTE(v29) <= BYTE2(v29)) {
            unsigned int v43 = BYTE2(v29);
          }
          if (v43 <= BYTE1(v29)) {
            unsigned int v43 = BYTE1(v29);
          }
          uint64_t v44 = (((v43 - HIBYTE(v29)) << 24) | ((v43 - BYTE2(v29)) << 16) | ((v43 - BYTE1(v29)) << 8) | v43) ^ 0xFF;
          if (v6 == 255)
          {
            uint64_t result = v44 | 0xFF00000000;
            if (!v8)
            {
LABEL_51:
              *int v7 = result;
              goto LABEL_52;
            }
          }
          else
          {
            uint64_t result = PDAM_5699(v44, 255, v6);
            if (!v8) {
              goto LABEL_51;
            }
          }
          *int v7 = result;
          *__n128 v8 = BYTE4(result);
LABEL_52:
          v23 += 2;
          ++v7;
          v8 += v9;
        }
      }
LABEL_102:
      uint64_t v11 = v100;
      v7 += v101;
      v8 += v103;
      LOBYTE(v12) = v99;
      uint64_t v13 = v104 + v98;
      a6 = v105 - 1;
      if (v105 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_102;
    }
    unsigned int v45 = (uint64_t *)v90;
    uint64_t v46 = v96;
    while (1)
    {
      uint64_t v47 = *(v45 - 1);
      uint64_t v48 = *v45;
      uint64_t v49 = v22 + v47;
      if ((unint64_t)v16 >= v22 + v47) {
        int v50 = (unsigned __int8 *)(v22 + v47);
      }
      else {
        int v50 = v16;
      }
      if (v50 < v14) {
        int v50 = v14;
      }
      unsigned int v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      char v52 = v48 & 0xF;
      if ((v48 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v63 = (unsigned __int8 *)(v49 + v107);
        if ((unint64_t)v16 < v49 + v107) {
          int v63 = v16;
        }
        if (v63 < v14) {
          int v63 = v14;
        }
        unsigned int v64 = BLEND8_21385[v21];
        unsigned int v61 = v51 - ((v64 & v51) >> v21);
        unsigned int v62 = (((*v63 << 24) | (v63[1] << 16) | (v63[2] << 8)) & v64) >> v21;
        goto LABEL_84;
      }
LABEL_85:
      unsigned int v65 = HIBYTE(v51);
      if (HIBYTE(v51) <= BYTE2(v51)) {
        unsigned int v65 = BYTE2(v51);
      }
      if (v65 <= BYTE1(v51)) {
        unsigned int v65 = BYTE1(v51);
      }
      uint64_t result = (((v65 - HIBYTE(v51)) << 24) | ((v65 - BYTE2(v51)) << 16) | ((v65 - BYTE1(v51)) << 8) | v65) ^ 0xFF;
      if (v6 == 255)
      {
        uint64_t v66 = result | 0xFF00000000;
      }
      else
      {
        uint64_t result = PDAM_5699(result, 255, v6);
        uint64_t v66 = result;
      }
      if (v8)
      {
        if (BYTE4(v66))
        {
          if (BYTE4(v66) == 255)
          {
            *int v7 = v66;
            *__n128 v8 = -1;
          }
          else
          {
            uint64_t result = (unint64_t)DAplusDAM(v7, v8, v66, SBYTE4(v66), *v7, *v8, ~BYTE4(v66));
          }
        }
      }
      else if (BYTE4(v66))
      {
        if (BYTE4(v66) == 255)
        {
          *int v7 = v66;
        }
        else
        {
          int v67 = ~BYTE4(v66);
          *int v7 = ((((*v7 >> 8) & 0xFF00FF) * v67 + 65537 + (((((*v7 >> 8) & 0xFF00FF) * v67) >> 8) & 0xFF00FF)) & 0xFF00FF00)
              + v66
              + ((((*v7 & 0xFF00FF) * v67 + 65537 + ((((*v7 & 0xFF00FF) * v67) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        }
      }
      v45 += 2;
      ++v7;
      v8 += v9;
      if (!--v46) {
        goto LABEL_102;
      }
    }
    uint64_t v53 = (unsigned __int8 *)(v49 + (v48 >> 4));
    if (v16 < v53) {
      uint64_t v53 = v16;
    }
    if (v53 < v14) {
      uint64_t v53 = v14;
    }
    int v54 = (*v53 << 24) | (v53[1] << 16) | (v53[2] << 8);
    if (v21)
    {
      unsigned int v55 = (unsigned __int8 *)(v49 + v107);
      if (v16 >= v55) {
        char v56 = v55;
      }
      else {
        char v56 = v16;
      }
      if (v56 < v14) {
        char v56 = v14;
      }
      int v57 = (*v56 << 24) | (v56[1] << 16) | (v56[2] << 8);
      unsigned int v58 = &v55[v48 >> 4];
      if (v16 < v58) {
        unsigned int v58 = v16;
      }
      if (v58 < v14) {
        unsigned int v58 = v14;
      }
      unsigned int v59 = BLEND8_21385[v21];
      unsigned int v51 = v51 - ((v59 & v51) >> v21) + ((v59 & v57) >> v21);
      int v54 = v54 - ((v59 & v54) >> v21) + ((((*v58 << 24) | (v58[1] << 16) | (v58[2] << 8)) & v59) >> v21);
    }
    int v60 = BLEND8_21385[*v45 & 0xF];
    unsigned int v61 = v51 - ((v60 & v51) >> v52);
    unsigned int v62 = (v60 & v54) >> v52;
LABEL_84:
    unsigned int v51 = v61 + v62;
    goto LABEL_85;
  }
  uint64_t v108 = (uint64_t *)(v10 + 16 * a3);
  int v68 = v15 - 3;
  do
  {
    int v106 = a6;
    uint64_t v69 = v13;
    uint64_t v70 = *(void *)(v109 + 32) + (v13 >> v12) * v11;
    if (v102 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v71 = v108;
        for (uint64_t j = v96; j; --j)
        {
          uint64_t v73 = *v71;
          v71 += 2;
          long long v74 = (unsigned __int8 *)(v70 + v73);
          if ((unint64_t)v68 < v70 + v73) {
            long long v74 = v68;
          }
          if ((unint64_t)v74 < *(void *)(v109 + 32)) {
            long long v74 = *(unsigned __int8 **)(v109 + 32);
          }
          unsigned int v75 = *v74;
          unsigned int v76 = v74[1];
          unsigned int v77 = v74[2];
          if (v75 <= v76) {
            unsigned int v78 = v76;
          }
          else {
            unsigned int v78 = v75;
          }
          if (v78 <= v77) {
            unsigned int v78 = v77;
          }
          uint64_t v79 = (((v78 - v75) << 24) | ((v78 - v76) << 16) | ((v78 - v77) << 8) | v78) ^ 0xFF;
          if (v6 == 255)
          {
            uint64_t result = v79 | 0xFF00000000;
            if (!v8)
            {
LABEL_121:
              *int v7 = result;
              goto LABEL_122;
            }
          }
          else
          {
            uint64_t result = PDAM_5699(v79, 255, v6);
            if (!v8) {
              goto LABEL_121;
            }
          }
          *int v7 = result;
          *__n128 v8 = BYTE4(result);
LABEL_122:
          ++v7;
          v8 += v9;
        }
      }
    }
    else
    {
      uint64_t v80 = v108;
      uint64_t v81 = v96;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v82 = *v80;
          v80 += 2;
          unsigned int v83 = (unsigned __int8 *)(v70 + v82);
          if ((unint64_t)v68 < v70 + v82) {
            unsigned int v83 = v68;
          }
          if ((unint64_t)v83 < *(void *)(v109 + 32)) {
            unsigned int v83 = *(unsigned __int8 **)(v109 + 32);
          }
          unsigned int v84 = *v83;
          unsigned int v85 = v83[1];
          unsigned int v86 = v83[2];
          if (v84 <= v85) {
            unsigned int v87 = v85;
          }
          else {
            unsigned int v87 = v84;
          }
          if (v87 <= v86) {
            unsigned int v87 = v86;
          }
          uint64_t result = (((v87 - v84) << 24) | ((v87 - v85) << 16) | ((v87 - v86) << 8) | v87) ^ 0xFF;
          if (v6 == 255)
          {
            uint64_t v88 = result | 0xFF00000000;
          }
          else
          {
            uint64_t result = PDAM_5699(result, 255, v6);
            uint64_t v88 = result;
          }
          if (v8)
          {
            if (BYTE4(v88))
            {
              if (BYTE4(v88) == 255)
              {
                *int v7 = v88;
                *__n128 v8 = -1;
              }
              else
              {
                uint64_t result = (unint64_t)DAplusDAM(v7, v8, v88, SBYTE4(v88), *v7, *v8, ~BYTE4(v88));
              }
            }
          }
          else if (BYTE4(v88))
          {
            if (BYTE4(v88) == 255)
            {
              *int v7 = v88;
            }
            else
            {
              int v89 = ~BYTE4(v88);
              *int v7 = ((((*v7 >> 8) & 0xFF00FF) * v89 + 65537 + (((((*v7 >> 8) & 0xFF00FF) * v89) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                  + v88
                  + ((((*v7 & 0xFF00FF) * v89 + 65537 + ((((*v7 & 0xFF00FF) * v89) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
          }
          ++v7;
          v8 += v9;
          --v81;
        }
        while (v81);
      }
    }
    uint64_t v11 = v100;
    v7 += v101;
    v8 += v103;
    LOBYTE(v12) = v99;
    uint64_t v13 = v69 + v98;
    a6 = v106 - 1;
  }
  while (v106 != 1);
  return result;
}

_DWORD *cmyk32_image_mark_W8(_DWORD *result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v8 = *((unsigned __int8 *)a2 + 8);
  uint64_t v9 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v10 = (unsigned __int8 *)*((void *)a2 + 4);
  if (v10) {
    uint64_t v20 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v20 = 0;
  }
  int v19 = *a2;
  uint64_t v18 = *((void *)a2 + 3) - a5;
  uint64_t v11 = v10 != 0;
  if (v8 == 255) {
    unint64_t v12 = 0xFF000000FELL;
  }
  else {
    unint64_t v12 = ((unsigned __int16)(254 * v8 + ((254 * v8) >> 8) + 1) >> 8) | ((unint64_t)((255 * v8 + ((255 * v8) >> 8) + 1) >> 8) << 32);
  }
  int v13 = ~BYTE4(v12);
  if (*((void *)result + 22))
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          int v14 = a5;
          do
          {
            *uint64_t v9 = v12;
            if (v10) {
              *uint64_t v10 = BYTE4(v12);
            }
            ++v9;
            v10 += v11;
            --v14;
          }
          while (v14);
        }
      }
      else
      {
        int v15 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (BYTE4(v12))
              {
                if (BYTE4(v12) == 255)
                {
                  *uint64_t v9 = v12;
                  *uint64_t v10 = -1;
                }
                else
                {
                  uint64_t result = DAplusDAM(v9, v10, v12, SBYTE4(v12), *v9, *v10, ~BYTE4(v12));
                }
              }
            }
            else if (BYTE4(v12))
            {
              if (BYTE4(v12) == 255) {
                *uint64_t v9 = v12;
              }
              else {
                *uint64_t v9 = ((((*v9 >> 8) & 0xFF00FF) * v13 + 65537 + (((((*v9 >> 8) & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) & 0xFF00FF00 | v12)
              }
                    + ((((*v9 & 0xFF00FF) * v13 + 65537 + ((((*v9 & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            ++v9;
            v10 += v11;
            --v15;
          }
          while (v15);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  else
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          int v16 = a5;
          do
          {
            *uint64_t v9 = v12;
            if (v10) {
              *uint64_t v10 = BYTE4(v12);
            }
            ++v9;
            v10 += v11;
            --v16;
          }
          while (v16);
        }
      }
      else
      {
        int v17 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (BYTE4(v12))
              {
                if (BYTE4(v12) == 255)
                {
                  *uint64_t v9 = v12;
                  *uint64_t v10 = -1;
                }
                else
                {
                  uint64_t result = DAplusDAM(v9, v10, v12, SBYTE4(v12), *v9, *v10, ~BYTE4(v12));
                }
              }
            }
            else if (BYTE4(v12))
            {
              if (BYTE4(v12) == 255) {
                *uint64_t v9 = v12;
              }
              else {
                *uint64_t v9 = ((((*v9 >> 8) & 0xFF00FF) * v13 + 65537 + (((((*v9 >> 8) & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) & 0xFF00FF00 | v12)
              }
                    + ((((*v9 & 0xFF00FF) * v13 + 65537 + ((((*v9 & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            ++v9;
            v10 += v11;
            --v17;
          }
          while (v17);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  return result;
}

unint64_t cmyk32_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  int8x16_t v5 = *(unsigned __int8 **)(a1 + 96);
  if (v5) {
    unint64_t v6 = (unint64_t)*v5 << 32;
  }
  else {
    unint64_t v6 = 0xFF00000000;
  }
  int v258 = *(_DWORD *)(a1 + 4);
  int v261 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 136);
  unint64_t v248 = *(int *)(a1 + 28);
  uint64_t v254 = *(void *)(a1 + 40);
  uint64_t v8 = **(unsigned int **)(a1 + 88);
  unint64_t v9 = v6 | v8;
  pthread_mutex_lock(&cmyk32_cacheColorLock);
  uint64_t v10 = (void *)cmyk32_cacheColor;
  if (!cmyk32_cacheColor || *(void *)(cmyk32_cacheColor + 16) != v9)
  {
    int v19 = 0;
    while (1)
    {
      if (!v10) {
        goto LABEL_12;
      }
      uint64_t v20 = v19;
      int v19 = (char *)v10;
      if (v10[2] == v9) {
        break;
      }
      uint64_t v10 = (void *)*v10;
      if (!*(void *)v19)
      {
        if (cmyk32_cacheColorCount > 6)
        {
          *(void *)uint64_t v20 = 0;
        }
        else
        {
LABEL_12:
          int v21 = (char *)cmyk32_cacheColorBase;
          if (cmyk32_cacheColorBase)
          {
            unsigned int v22 = cmyk32_cacheColorCount;
          }
          else
          {
            int v21 = (char *)malloc_type_calloc(1uLL, 0x38A8uLL, 0x10200402493A768uLL);
            unsigned int v22 = 0;
            cmyk32_cacheColorBase = (uint64_t)v21;
          }
          int v19 = &v21[24 * v22];
          *((void *)v19 + 1) = &v21[2048 * (unint64_t)v22 + 168];
          cmyk32_cacheColorCFIndex Count = v22 + 1;
        }
        uint64_t v23 = 0;
        *(void *)int v19 = cmyk32_cacheColor;
        cmyk32_cacheColor = (uint64_t)v19;
        *((void *)v19 + 2) = v9;
        uint64_t v25 = *((void *)v19 + 1);
        uint64_t v18 = v19 + 8;
        uint64_t v24 = v25;
        unint64_t v26 = HIDWORD(v6);
        do
        {
          *(void *)(v24 + 8 * v23) = PDAM_5699(v8, v26, v23);
          ++v23;
        }
        while (v23 != 256);
        unint64_t result = pthread_mutex_unlock(&cmyk32_cacheColorLock);
        goto LABEL_23;
      }
    }
    if (v20)
    {
      *(void *)uint64_t v20 = *v10;
      *uint64_t v10 = cmyk32_cacheColor;
      cmyk32_cacheColor = (uint64_t)v10;
    }
  }
  unint64_t result = pthread_mutex_unlock(&cmyk32_cacheColorLock);
  uint64_t v18 = v10 + 1;
LABEL_23:
  uint64_t v28 = *(int *)(a1 + 12);
  uint64_t v27 = *(int *)(a1 + 16);
  if (v4)
  {
    uint64_t v29 = *(int *)(a1 + 32);
    char v30 = (unsigned __int8 *)(v4 + v28 + (int)v29 * (uint64_t)(int)v27);
    uint64_t v31 = 1;
    if (!v7) {
      return result;
    }
  }
  else
  {
    char v30 = 0;
    uint64_t v29 = 0;
    uint64_t v31 = 0;
    if (!v7) {
      return result;
    }
  }
  uint64_t v32 = v29 - v258;
  if (v4) {
    v29 -= v258;
  }
  uint64_t v251 = v29;
  uint64_t v33 = *v18;
  uint64_t v34 = *(void *)(*v18 + 2040);
  int v35 = (unsigned int *)(v254 + 4 * (v28 + (v248 >> 2) * v27));
  uint64_t v36 = *(int *)(a1 + 124);
  unint64_t v37 = v7 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v36;
  uint64_t v38 = v36 - v258;
  unint64_t v255 = (v248 >> 2) - v258;
  switch(a2)
  {
    case 0:
      if (v4)
      {
        do
        {
          int v39 = v258;
          do
          {
            int v40 = *(unsigned __int8 *)v37;
            if (*(unsigned char *)v37)
            {
              if (v40 == 255)
              {
                LOBYTE(v41) = 0;
                *int v35 = 0;
              }
              else
              {
                unint64_t result = PDAM_5699(*v35, *v30, v40 ^ 0xFFu);
                *int v35 = result;
                unint64_t v41 = HIDWORD(result);
              }
              *char v30 = v41;
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v39;
          }
          while (v39);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          int v146 = v258;
          do
          {
            int v147 = *(unsigned __int8 *)v37;
            if (*(unsigned char *)v37)
            {
              if (v147 == 255) {
                unsigned int v148 = 0;
              }
              else {
                unsigned int v148 = (((*v35 & 0xFF00FF) * (v147 ^ 0xFF)
              }
                       + 65537
                       + ((((*v35 & 0xFF00FF) * (v147 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v35 >> 8) & 0xFF00FF) * (v147 ^ 0xFF) + 65537 + (((((*v35 >> 8) & 0xFF00FF) * (v147 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
              *int v35 = v148;
            }
            ++v37;
            ++v35;
            --v146;
          }
          while (v146);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 1:
      unsigned int v108 = v37 & 3;
      if (v4)
      {
        int v109 = v108 + v258;
        if ((v37 & 3) != 0) {
          char v110 = v37 & 0xFC;
        }
        else {
          char v110 = v37;
        }
        if ((v37 & 3) != 0) {
          unint64_t result = (-1 << (8 * v108));
        }
        else {
          unint64_t result = 0xFFFFFFFFLL;
        }
        if ((v37 & 3) != 0) {
          uint64_t v111 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          uint64_t v111 = (unsigned int *)v37;
        }
        if ((v37 & 3) != 0)
        {
          v30 -= v37 & 3;
          v35 -= v37 & 3;
        }
        else
        {
          int v109 = v258;
        }
        if ((((_BYTE)v109 + v110) & 3) != 0)
        {
          int v112 = 4 - (((_BYTE)v109 + v110) & 3);
          v108 += v112;
          unsigned int v113 = 0xFFFFFFFF >> (8 * v112);
          if (v109 >= 4) {
            unsigned int v114 = 0xFFFFFFFF >> (8 * v112);
          }
          else {
            unsigned int v114 = 0;
          }
          unsigned int v259 = v114;
          if (v109 >= 4) {
            unsigned int v113 = -1;
          }
          unint64_t result = v113 & result;
          int v252 = result;
        }
        else
        {
          int v252 = result;
          unsigned int v259 = 0;
        }
        uint64_t v250 = v38 - v108;
        unint64_t v256 = v255 - v108;
        int v246 = v109 >> 2;
        uint64_t v244 = v32 - v108;
        do
        {
          unsigned int v176 = *v111 & v252;
          int v177 = v246;
          unsigned int v178 = v259;
          if (!v176) {
            goto LABEL_464;
          }
LABEL_446:
          if (v176 == -1)
          {
            *int v35 = v34;
            *char v30 = BYTE4(v34);
            v35[1] = v34;
            v30[1] = BYTE4(v34);
            v35[2] = v34;
            v30[2] = BYTE4(v34);
            v35[3] = v34;
            v30[3] = BYTE4(v34);
            goto LABEL_464;
          }
          while (1)
          {
            if ((_BYTE)v176)
            {
              if (v176 == 255)
              {
                *int v35 = v34;
                *char v30 = BYTE4(v34);
              }
              else
              {
                DAplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * v176), *(unsigned char *)(v33 + 8 * v176 + 4), *v35, *v30, ~(_BYTE)v176);
              }
            }
            if (BYTE1(v176))
            {
              int v179 = v35 + 1;
              unsigned int v180 = v30 + 1;
              if (BYTE1(v176) == 255)
              {
                *int v179 = v34;
                unsigned __int8 *v180 = BYTE4(v34);
              }
              else
              {
                DAplusDAM(v179, v180, *(_DWORD *)(v33 + 8 * BYTE1(v176)), *(unsigned char *)(v33 + 8 * BYTE1(v176) + 4), *v179, *v180, ~(v176 >> 8));
              }
            }
            if (BYTE2(v176))
            {
              unint64_t v181 = v35 + 2;
              int v182 = v30 + 2;
              if (BYTE2(v176) == 255)
              {
                *unint64_t v181 = v34;
                unsigned __int8 *v182 = BYTE4(v34);
              }
              else
              {
                DAplusDAM(v181, v182, *(_DWORD *)(v33 + 8 * BYTE2(v176)), *(unsigned char *)(v33 + 8 * BYTE2(v176) + 4), *v181, *v182, ~HIWORD(v176));
              }
            }
            unint64_t result = (unint64_t)(v35 + 3);
            int v183 = v30 + 3;
            unsigned int v184 = HIBYTE(v176);
            if (HIBYTE(v176) == 255)
            {
              *(_DWORD *)unint64_t result = v34;
              *int v183 = BYTE4(v34);
            }
            else if (v184)
            {
              unint64_t result = (unint64_t)DAplusDAM((_DWORD *)result, v183, *(_DWORD *)(v33 + 8 * v184), *(unsigned char *)(v33 + 8 * v184 + 4), *(_DWORD *)result, *v183, ~v176 >> 24);
            }
LABEL_464:
            while (1)
            {
              int v185 = v177;
              v35 += 4;
              v30 += 4;
              --v177;
              ++v111;
              if (v185 < 2) {
                break;
              }
              unsigned int v176 = *v111;
              if (*v111) {
                goto LABEL_446;
              }
            }
            if (!v178) {
              break;
            }
            unsigned int v178 = 0;
            unsigned int v176 = *v111 & v259;
          }
          uint64_t v111 = (unsigned int *)((char *)v111 + v250);
          v35 += v256;
          v30 += v244;
          --v261;
        }
        while (v261);
      }
      else
      {
        int v149 = -1 << (8 * v108);
        if ((v37 & 3) != 0) {
          char v150 = v37 & 0xFC;
        }
        else {
          char v150 = v37;
        }
        if ((v37 & 3) != 0)
        {
          unint64_t v151 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v149 = -1;
          unint64_t v151 = (unsigned int *)v37;
        }
        if ((v37 & 3) != 0) {
          int v152 = (int32x4_t *)&v35[-(v37 & 3)];
        }
        else {
          int v152 = (int32x4_t *)v35;
        }
        if ((v37 & 3) != 0) {
          int v153 = v108 + v258;
        }
        else {
          int v153 = v258;
        }
        if ((((_BYTE)v153 + v150) & 3) != 0)
        {
          int v154 = 4 - (((_BYTE)v153 + v150) & 3);
          v108 += v154;
          unsigned int v155 = 0xFFFFFFFF >> (8 * v154);
          if (v153 >= 4) {
            unsigned int v156 = v155;
          }
          else {
            unsigned int v156 = 0;
          }
          if (v153 >= 4) {
            unsigned int v155 = -1;
          }
          v149 &= v155;
        }
        else
        {
          unsigned int v156 = 0;
        }
        int v199 = v153 >> 2;
        int32x4_t v200 = vdupq_n_s32(v34);
        uint64_t v201 = v38 - v108;
        unint64_t v202 = v255 - v108;
        do
        {
          unsigned int v203 = *v151 & v149;
          int v204 = v199;
          unsigned int v205 = v156;
          if (!v203) {
            goto LABEL_513;
          }
LABEL_495:
          if (v203 == -1)
          {
            *int v152 = v200;
            goto LABEL_513;
          }
          while (1)
          {
            if ((_BYTE)v203)
            {
              __int32 v206 = v34;
              if (v203 != 255)
              {
                int v207 = v203 ^ 0xFF;
                __int32 v206 = (((((unsigned __int32)v152->i32[0] >> 8) & 0xFF00FF) * v207
                       + 65537
                       + ((((((unsigned __int32)v152->i32[0] >> 8) & 0xFF00FF) * v207) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                     + *(void *)(v33 + 8 * v203)
                     + ((((v152->i32[0] & 0xFF00FF) * v207
                        + 65537
                        + ((((v152->i32[0] & 0xFF00FFu) * v207) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
              }
              v152->i32[0] = v206;
            }
            if (BYTE1(v203))
            {
              __int32 v208 = v34;
              if (BYTE1(v203) != 255)
              {
                unsigned __int32 v209 = v152->u32[1];
                __int32 v208 = ((((v209 >> 8) & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)
                       + 65537
                       + (((((v209 >> 8) & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                     + *(void *)(v33 + 8 * BYTE1(v203))
                     + ((((v209 & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)
                        + 65537
                        + ((((v209 & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
              }
              v152->i32[1] = v208;
            }
            if (BYTE2(v203))
            {
              __int32 v210 = v34;
              if (BYTE2(v203) != 255)
              {
                unsigned __int32 v211 = v152->u32[2];
                __int32 v210 = ((((v211 >> 8) & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)
                       + 65537
                       + (((((v211 >> 8) & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                     + *(void *)(v33 + 8 * BYTE2(v203))
                     + ((((v211 & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)
                        + 65537
                        + ((((v211 & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
              }
              v152->i32[2] = v210;
            }
            unsigned int v212 = HIBYTE(v203);
            if (v212 == 255)
            {
              v152->i32[3] = v34;
            }
            else if (v212)
            {
              unsigned __int32 v213 = v152->u32[3];
              v152->i32[3] = ((((v213 >> 8) & 0xFF00FF) * (v212 ^ 0xFF)
                             + 65537
                             + (((((v213 >> 8) & 0xFF00FF) * (v212 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                           + *(void *)(v33 + 8 * v212)
                           + ((((v213 & 0xFF00FF) * (v212 ^ 0xFF)
                              + 65537
                              + ((((v213 & 0xFF00FF) * (v212 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
LABEL_513:
            while (1)
            {
              int v214 = v204;
              ++v152;
              --v204;
              ++v151;
              if (v214 < 2) {
                break;
              }
              unsigned int v203 = *v151;
              if (*v151) {
                goto LABEL_495;
              }
            }
            if (!v205) {
              break;
            }
            unsigned int v205 = 0;
            unsigned int v203 = *v151 & v156;
          }
          unint64_t v151 = (unsigned int *)((char *)v151 + v201);
          int v152 = (int32x4_t *)((char *)v152 + 4 * v202);
          unint64_t result = --v261;
        }
        while (v261);
      }
      return result;
    case 2:
      unsigned __int8 v253 = ~BYTE4(v34);
      unsigned int v115 = v37 & 3;
      if (!v4)
      {
        int v157 = -1 << (8 * v115);
        if ((v37 & 3) != 0) {
          char v158 = v37 & 0xFC;
        }
        else {
          char v158 = v37;
        }
        if ((v37 & 3) != 0)
        {
          unint64_t v159 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v157 = -1;
          unint64_t v159 = (unsigned int *)v37;
        }
        if ((v37 & 3) != 0) {
          int v160 = (uint32x2_t *)&v35[-(v37 & 3)];
        }
        else {
          int v160 = (uint32x2_t *)v35;
        }
        if ((v37 & 3) != 0) {
          int v161 = v115 + v258;
        }
        else {
          int v161 = v258;
        }
        if ((((_BYTE)v161 + v158) & 3) != 0)
        {
          int v162 = 4 - (((_BYTE)v161 + v158) & 3);
          v115 += v162;
          unsigned int v163 = 0xFFFFFFFF >> (8 * v162);
          if (v161 >= 4) {
            unsigned int v164 = -1;
          }
          else {
            unsigned int v164 = 0xFFFFFFFF >> (8 * v162);
          }
          v157 &= v164;
          if (v161 < 4) {
            unsigned int v163 = 0;
          }
        }
        else
        {
          unsigned int v163 = 0;
        }
        uint64_t v215 = v38 - v115;
        int32x2_t v216 = vdup_n_s32(v253);
        int v217 = v161 >> 2;
        int32x2_t v218 = vdup_n_s32(v34);
        unint64_t result = 255;
        unint64_t v219 = v255 - v115;
        while (1)
        {
          unsigned int v220 = *v159 & v157;
          unsigned int v221 = v163;
          int v222 = v217;
          if (!v220) {
            goto LABEL_534;
          }
LABEL_523:
          if (v220 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v220)
            {
              uint64_t v232 = v33 + 8 * v220;
              int v233 = *(_DWORD *)v232;
              LODWORD(v232) = ~*(unsigned char *)(v232 + 4);
              v160->i32[0] = ((v232 * (((unsigned __int32)v160->i32[0] >> 8) & 0xFF00FF)
                             + 65537
                             + (((v232 * (((unsigned __int32)v160->i32[0] >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                           + v233
                           + (((v232 * (v160->i32[0] & 0xFF00FF)
                              + 65537
                              + (((v232 * (v160->i32[0] & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            if ((v220 & 0xFF00) != 0)
            {
              uint64_t v234 = v33 + 8 * BYTE1(v220);
              int v235 = *(_DWORD *)v234;
              LODWORD(v234) = ~*(unsigned char *)(v234 + 4);
              v160->i32[1] = ((v234 * (((unsigned __int32)v160->i32[1] >> 8) & 0xFF00FF)
                             + 65537
                             + (((v234 * (((unsigned __int32)v160->i32[1] >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                           + v235
                           + (((v234 * (v160->i32[1] & 0xFF00FF)
                              + 65537
                              + (((v234 * (v160->i32[1] & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            if ((v220 & 0xFF0000) != 0)
            {
              uint64_t v236 = v33 + 8 * BYTE2(v220);
              int v237 = *(_DWORD *)v236;
              LODWORD(v236) = ~*(unsigned char *)(v236 + 4);
              v160[1].i32[0] = ((v236 * (((unsigned __int32)v160[1].i32[0] >> 8) & 0xFF00FF)
                               + 65537
                               + (((v236 * (((unsigned __int32)v160[1].i32[0] >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                             + v237
                             + (((v236 * (v160[1].i32[0] & 0xFF00FF)
                                + 65537
                                + (((v236 * (v160[1].i32[0] & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            unsigned int v238 = HIBYTE(v220);
            if (v238)
            {
              double v239 = (int *)(v33 + 8 * v238);
              int v231 = *v239;
              unsigned __int32 v240 = v160[1].u32[1];
              int v241 = ~*((unsigned char *)v239 + 4);
              unsigned int v229 = v241 * ((v240 >> 8) & 0xFF00FF);
              unsigned int v230 = v241 * (v240 & 0xFF00FF);
              goto LABEL_533;
            }
LABEL_534:
            while (1)
            {
              int v242 = v222;
              v160 += 2;
              --v222;
              ++v159;
              if (v242 < 2) {
                break;
              }
              unsigned int v220 = *v159;
              if (*v159) {
                goto LABEL_523;
              }
            }
            if (!v221) {
              break;
            }
            unsigned int v221 = 0;
            unsigned int v220 = *v159 & v163;
          }
          unint64_t v159 = (unsigned int *)((char *)v159 + v215);
          int v160 = (uint32x2_t *)((char *)v160 + 4 * v219);
          if (!--v261) {
            return result;
          }
        }
        v223.i16[0] = v160->u8[0];
        v223.i16[1] = BYTE2(v160->u32[0]);
        v223.i16[2] = BYTE4(*(unint64_t *)v160);
        v223.i16[3] = BYTE6(*(unint64_t *)v160);
        int32x2_t v224 = vmul_s32((int32x2_t)(*(void *)&vshr_n_u32(*v160, 8uLL) & 0xFFFF00FFFFFF00FFLL), v216);
        int32x2_t v225 = vmul_s32(v223, v216);
        uint32x2_t *v160 = (uint32x2_t)vadd_s32(vadd_s32((int32x2_t)(*(void *)&vadd_s32(vadd_s32(v224, (int32x2_t)0x1000100010001), (int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)v224, 8uLL) & 0xFFFF00FFFFFF00FFLL)) & 0xFF00FF00FF00FF00), v218), (int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(vadd_s32(v225, (int32x2_t)0x1000100010001), (int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)v225, 8uLL) & 0xFFFF00FFFFFF00FFLL)), 8uLL) & 0xFFFF00FFFFFF00FFLL));
        unsigned __int32 v226 = v160[1].u32[0];
        unsigned __int32 v227 = v160[1].u32[1];
        v160[1].i32[0] = ((((v226 >> 8) & 0xFF00FF) * v253
                         + 65537
                         + (((((v226 >> 8) & 0xFF00FF) * v253) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                       + v34
                       + ((((v226 & 0xFF00FF) * v253 + 65537 + ((((v226 & 0xFF00FF) * v253) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        int v228 = v227 & 0xFF00FF;
        unsigned int v229 = ((v227 >> 8) & 0xFF00FF) * v253;
        unsigned int v230 = v228 * v253;
        int v231 = v34;
LABEL_533:
        v160[1].i32[1] = ((v229 + 65537 + ((v229 >> 8) & 0xFF00FF)) & 0xFF00FF00)
                       + v231
                       + (((v230 + 65537 + ((v230 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        goto LABEL_534;
      }
      int v116 = v115 + v258;
      unint64_t v117 = &v35[-(v37 & 3)];
      char v118 = &v30[-(v37 & 3)];
      if ((v37 & 3) != 0) {
        char v119 = v37 & 0xFC;
      }
      else {
        char v119 = v37;
      }
      if ((v37 & 3) != 0) {
        unint64_t result = (-1 << (8 * v115));
      }
      else {
        unint64_t result = 0xFFFFFFFFLL;
      }
      if ((v37 & 3) != 0)
      {
        v37 &= 0xFFFFFFFFFFFFFFFCLL;
        char v30 = v118;
        int v35 = v117;
      }
      else
      {
        int v116 = v258;
      }
      if ((((_BYTE)v116 + v119) & 3) != 0)
      {
        int v120 = 4 - (((_BYTE)v116 + v119) & 3);
        v115 += v120;
        unsigned int v121 = 0xFFFFFFFF >> (8 * v120);
        if (v116 >= 4) {
          unsigned int v122 = 0xFFFFFFFF >> (8 * v120);
        }
        else {
          unsigned int v122 = 0;
        }
        unsigned int v260 = v122;
        if (v116 >= 4) {
          unsigned int v121 = -1;
        }
        unint64_t result = v121 & result;
        int v249 = result;
      }
      else
      {
        int v249 = result;
        unsigned int v260 = 0;
      }
      uint64_t v247 = v38 - v115;
      unint64_t v257 = v255 - v115;
      int v245 = v116 >> 2;
      uint64_t v243 = v32 - v115;
      unsigned int v186 = v260;
      do
      {
        unsigned int v187 = *(_DWORD *)v37 & v249;
        int v188 = v245;
        unsigned int v189 = v186;
        if (!v187) {
          goto LABEL_485;
        }
LABEL_474:
        if (v187 == -1)
        {
          DAplusDAM(v35, v30, v34, SBYTE4(v34), *v35, *v30, ~BYTE4(v34));
          DAplusDAM(v35 + 1, v30 + 1, v34, SBYTE4(v34), v35[1], v30[1], ~BYTE4(v34));
          DAplusDAM(v35 + 2, v30 + 2, v34, SBYTE4(v34), v35[2], v30[2], ~BYTE4(v34));
          unsigned int v190 = v35 + 3;
          unsigned int v191 = v35[3];
          uint64_t v192 = v30 + 3;
          int v193 = v30[3];
          int v194 = v34;
          char v195 = BYTE4(v34);
          int v196 = ~BYTE4(v34);
          unsigned int v186 = v260;
LABEL_484:
          unint64_t result = (unint64_t)DAplusDAM(v190, v192, v194, v195, v191, v193, v196);
          goto LABEL_485;
        }
        while (1)
        {
          if ((_BYTE)v187) {
            unint64_t result = (unint64_t)DAplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * v187), *(_DWORD *)(v33 + 8 * v187 + 4), *v35, *v30, ~*(unsigned char *)(v33 + 8 * v187 + 4));
          }
          if ((v187 & 0xFF00) != 0) {
            unint64_t result = (unint64_t)DAplusDAM(v35 + 1, v30 + 1, *(_DWORD *)(v33 + 8 * BYTE1(v187)), *(_DWORD *)(v33 + 8 * BYTE1(v187) + 4), v35[1], v30[1], ~*(unsigned char *)(v33 + 8 * BYTE1(v187) + 4));
          }
          if ((v187 & 0xFF0000) != 0) {
            unint64_t result = (unint64_t)DAplusDAM(v35 + 2, v30 + 2, *(_DWORD *)(v33 + 8 * BYTE2(v187)), *(_DWORD *)(v33 + 8 * BYTE2(v187) + 4), v35[2], v30[2], ~*(unsigned char *)(v33 + 8 * BYTE2(v187) + 4));
          }
          if (HIBYTE(v187))
          {
            uint64_t v197 = (int *)(v33 + 8 * HIBYTE(v187));
            unsigned int v190 = v35 + 3;
            unsigned int v191 = v35[3];
            int v194 = *v197;
            LODWORD(v197) = v197[1];
            uint64_t v192 = v30 + 3;
            int v193 = v30[3];
            int v196 = ~(_BYTE)v197;
            char v195 = (char)v197;
            goto LABEL_484;
          }
LABEL_485:
          while (1)
          {
            int v198 = v188;
            v35 += 4;
            v30 += 4;
            --v188;
            v37 += 4;
            if (v198 < 2) {
              break;
            }
            unsigned int v187 = *(_DWORD *)v37;
            if (*(_DWORD *)v37) {
              goto LABEL_474;
            }
          }
          if (!v189) {
            break;
          }
          unsigned int v189 = 0;
          unsigned int v187 = *(_DWORD *)v37 & v186;
        }
        v37 += v247;
        v35 += v257;
        v30 += v243;
        --v261;
      }
      while (v261);
      return result;
    case 3:
      do
      {
        int v42 = v258;
        do
        {
          int v43 = *(unsigned __int8 *)v37;
          if (*(unsigned char *)v37)
          {
            if (v43 == 255)
            {
              uint64_t v44 = *(void *)(v33 + 8 * *v30);
              *int v35 = v44;
              *char v30 = BYTE4(v44);
            }
            else
            {
              int v45 = *v30;
              uint64_t v46 = v33 + 8 * ((v45 * v43 + ((v45 * v43) >> 8) + 1) >> 8);
              unint64_t result = (unint64_t)DAplusDAM(v35, v30, *(_DWORD *)v46, *(unsigned char *)(v46 + 4), *v35, v45, v43 ^ 0xFFu);
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v42;
        }
        while (v42);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 4:
      do
      {
        int v47 = v258;
        do
        {
          int v48 = *(unsigned __int8 *)v37;
          if (*(unsigned char *)v37)
          {
            if (v48 == 255)
            {
              uint64_t v49 = *(void *)(v33 + 8 * ~*v30);
              *int v35 = v49;
              *char v30 = BYTE4(v49);
            }
            else
            {
              int v50 = *v30;
              uint64_t v51 = v33 + 8 * (((v50 ^ 0xFF) * v48 + (((v50 ^ 0xFFu) * v48) >> 8) + 1) >> 8);
              unint64_t result = (unint64_t)DAplusDAM(v35, v30, *(_DWORD *)v51, *(unsigned char *)(v51 + 4), *v35, v50, v48 ^ 0xFFu);
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v47;
        }
        while (v47);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 5:
      do
      {
        int v123 = v258;
        do
        {
          if (*(unsigned char *)v37) {
            unint64_t result = (unint64_t)DAMplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4), *v30, *v35, *v30, ~*(unsigned char *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v123;
        }
        while (v123);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 6:
      do
      {
        int v124 = v258;
        do
        {
          uint64_t v125 = *(unsigned __int8 *)v37;
          if (*(unsigned char *)v37 && *v30 != 0xFF)
          {
            if (~*v30 == 255)
            {
              uint64_t v126 = *(void *)(v33 + 8 * v125);
              *int v35 = v126;
              *char v30 = BYTE4(v126);
            }
            else
            {
              unint64_t result = (unint64_t)DAplusDAM(v35, v30, *v35, *v30, *(_DWORD *)(v33 + 8 * v125), *(unsigned __int8 *)(v33 + 8 * v125 + 4), ~*v30);
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v124;
        }
        while (v124);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 7:
      if (v4)
      {
        do
        {
          int v127 = v258;
          do
          {
            int v128 = *(unsigned __int8 *)v37;
            if (*(unsigned char *)v37)
            {
              if (v128 == 255) {
                int v129 = BYTE4(v34);
              }
              else {
                int v129 = (~(_BYTE)v128
              }
                                       + ((unsigned __int16)(BYTE4(v34) * (_WORD)v128
                                                           + ((BYTE4(v34) * v128) >> 8)
                                                           + 1) >> 8));
              unint64_t result = PDAM_5699(*v35, *v30, v129);
              *int v35 = result;
              *char v30 = BYTE4(result);
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v127;
          }
          while (v127);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          int v165 = v258;
          do
          {
            int v166 = *(unsigned __int8 *)v37;
            if (*(unsigned char *)v37)
            {
              if (v166 == 255)
              {
                unsigned int v167 = ((*v35 >> 8) & 0xFF00FF) * BYTE4(v34);
                unsigned int v168 = (*v35 & 0xFF00FF) * BYTE4(v34);
              }
              else
              {
                int v169 = (~(_BYTE)v166
                                       + ((unsigned __int16)(BYTE4(v34) * (_WORD)v166
                                                           + ((BYTE4(v34) * v166) >> 8)
                                                           + 1) >> 8));
                unsigned int v167 = ((*v35 >> 8) & 0xFF00FF) * v169;
                unsigned int v168 = (*v35 & 0xFF00FF) * v169;
              }
              *int v35 = ((v168 + 65537 + ((v168 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v167
                                                                                  + 65537
                                                                                  + ((v167 >> 8) & 0xFF00FF)) & 0xFF00FF00;
            }
            ++v37;
            ++v35;
            --v165;
          }
          while (v165);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 8:
      if (v4)
      {
        do
        {
          int v130 = v258;
          do
          {
            int v131 = *(unsigned __int8 *)v37;
            if (*(unsigned char *)v37)
            {
              if (v131 == 255) {
                int v132 = ~BYTE4(v34);
              }
              else {
                int v132 = ~((BYTE4(v34) * v131 + ((BYTE4(v34) * v131) >> 8) + 1) >> 8);
              }
              unint64_t result = PDAM_5699(*v35, *v30, v132);
              *int v35 = result;
              *char v30 = BYTE4(result);
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v130;
          }
          while (v130);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        int v170 = ~BYTE4(v34);
        do
        {
          int v171 = v258;
          do
          {
            int v172 = *(unsigned __int8 *)v37;
            if (*(unsigned char *)v37)
            {
              if (v172 == 255)
              {
                unsigned int v173 = ((*v35 >> 8) & 0xFF00FF) * v170;
                unsigned int v174 = (*v35 & 0xFF00FF) * v170;
              }
              else
              {
                int v175 = ~((BYTE4(v34) * v172 + ((BYTE4(v34) * v172) >> 8) + 1) >> 8);
                unsigned int v173 = ((*v35 >> 8) & 0xFF00FF) * v175;
                unsigned int v174 = (*v35 & 0xFF00FF) * v175;
              }
              unint64_t result = (v174 >> 8) & 0xFF00FF;
              *int v35 = ((v174 + 65537 + result) >> 8) & 0xFF00FF | (v173 + 65537 + ((v173 >> 8) & 0xFF00FF)) & 0xFF00FF00;
            }
            ++v37;
            ++v35;
            --v171;
          }
          while (v171);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 9:
      do
      {
        int v52 = v258;
        do
        {
          if (*(unsigned char *)v37) {
            unint64_t result = (unint64_t)DAMplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4), *v30 ^ 0xFFu, *v35, *v30, (*(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4)+ ~*(unsigned char *)v37));
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v52;
        }
        while (v52);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 10:
      do
      {
        int v133 = v258;
        do
        {
          if (*(unsigned char *)v37) {
            unint64_t result = (unint64_t)DAMplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4), *v30 ^ 0xFFu, *v35, *v30, ~*(unsigned char *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v133;
        }
        while (v133);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 11:
      if (v4)
      {
        do
        {
          int v134 = v258;
          do
          {
            if (*(unsigned char *)v37) {
              unint64_t result = (unint64_t)DAplusdDA(v35, v30, *v35, *v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(unsigned __int8 *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v134;
          }
          while (v134);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          int v135 = v258;
          do
          {
            if (*(unsigned char *)v37) {
              unint64_t result = (unint64_t)DplusdDA(v35, *v35, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(unsigned __int8 *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
            }
            ++v37;
            ++v35;
            --v135;
          }
          while (v135);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 12:
      if (v4)
      {
        do
        {
          int v136 = v258;
          do
          {
            if (*(unsigned char *)v37)
            {
              uint64_t v137 = v33 + 8 * *(unsigned __int8 *)v37;
              int v138 = *(unsigned __int8 *)(v137 + 4);
              LODWORD(v137) = *(_DWORD *)v137;
              unsigned int v139 = ((v137 >> 8) & 0xFF00FF) + ((*v35 >> 8) & 0xFF00FF);
              LODWORD(v137) = (v137 & 0xFF00FF) + (*v35 & 0xFF00FF);
              unsigned int v140 = v139 & 0x1000100 | (v137 >> 8) & 0x10001;
              unsigned int v141 = v138 + *v30;
              unint64_t result = (v139 << 8) & 0xFF00FF00;
              unsigned int v142 = result | v137 & 0xFF00FF | (15 * v140) | (240 * v140);
              if (v141 >= 0xFF) {
                LOBYTE(v141) = -1;
              }
              *char v30 = v141;
              *int v35 = v142;
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v136;
          }
          while (v136);
          v37 += v38;
          v35 += v255;
          v30 += v29;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          int v143 = v258;
          do
          {
            if (*(unsigned char *)v37)
            {
              uint64_t v144 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
              unsigned int v145 = ((v144 >> 8) & 0xFF00FF) + ((*v35 >> 8) & 0xFF00FF);
              *int v35 = (v145 << 8) & 0xFF00FF00 | ((v144 & 0xFF00FF) + (*v35 & 0xFF00FF)) & 0xFF00FF | (15 * (v145 & 0x1000100 | ((unint64_t)((v144 & 0xFF00FF) + (*v35 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v145 & 0x1000100 | ((unint64_t)((v144 & 0xFF00FF) + (*v35 & 0xFF00FF)) >> 8) & 0x10001));
            }
            ++v37;
            ++v35;
            --v143;
          }
          while (v143);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 13:
      do
      {
        int v53 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v54 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v54))
            {
              unint64_t v55 = HIDWORD(v54);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAmultiplyPDA_5700(*v35, *v30, v54, BYTE4(v54));
                  LODWORD(v54) = result;
                  unint64_t v55 = HIDWORD(result);
                }
                *int v35 = v54;
                *char v30 = v55;
              }
              else
              {
                unint64_t result = PDAmultiplyPDA_5700(*v35, 255, v54, BYTE4(v54));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v53;
        }
        while (v53);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 14:
      do
      {
        int v56 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v57 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v57))
            {
              unint64_t v58 = HIDWORD(v57);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAscreenPDA_5701(*v35, *v30, v57, BYTE4(v57));
                  LODWORD(v57) = result;
                  unint64_t v58 = HIDWORD(result);
                }
                *int v35 = v57;
                *char v30 = v58;
              }
              else
              {
                unint64_t result = PDAscreenPDA_5701(*v35, 0xFFu, v57, BYTE4(v57));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v56;
        }
        while (v56);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 15:
      do
      {
        int v59 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v60 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v60))
            {
              unint64_t v61 = HIDWORD(v60);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAoverlayPDA_5702(*v35, *v30, v60, BYTE4(v60));
                  LODWORD(v60) = result;
                  unint64_t v61 = HIDWORD(result);
                }
                *int v35 = v60;
                *char v30 = v61;
              }
              else
              {
                unint64_t result = PDAoverlayPDA_5702(*v35, 255, v60, BYTE4(v60));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v59;
        }
        while (v59);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 16:
      do
      {
        int v62 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v63 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v63))
            {
              unint64_t v64 = HIDWORD(v63);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAdarkenPDA_5704(*v35, *v30, v63, BYTE4(v63), v12, v13, v14, v15, v16, v17);
                  LODWORD(v63) = result;
                  unint64_t v64 = HIDWORD(result);
                }
                *int v35 = v63;
                *char v30 = v64;
              }
              else
              {
                unint64_t result = PDAdarkenPDA_5704(*v35, 0xFFu, v63, BYTE4(v63), v12, v13, v14, v15, v16, v17);
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v62;
        }
        while (v62);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 17:
      do
      {
        int v65 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v66 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v66))
            {
              unint64_t v67 = HIDWORD(v66);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAlightenPDA_5703(*v35, *v30, v66, BYTE4(v66), v12, v13, v14, v15, v16, v17);
                  LODWORD(v66) = result;
                  unint64_t v67 = HIDWORD(result);
                }
                *int v35 = v66;
                *char v30 = v67;
              }
              else
              {
                unint64_t result = PDAlightenPDA_5703(*v35, 0xFFu, v66, BYTE4(v66), v12, v13, v14, v15, v16, v17);
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v65;
        }
        while (v65);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 18:
      do
      {
        int v68 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v69 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v69))
            {
              unint64_t v70 = HIDWORD(v69);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAcolordodgePDA_5705(*v35, *v30, v69, BYTE4(v69));
                  LODWORD(v69) = result;
                  unint64_t v70 = HIDWORD(result);
                }
                *int v35 = v69;
                *char v30 = v70;
              }
              else
              {
                unint64_t result = PDAcolordodgePDA_5705(*v35, 255, v69, BYTE4(v69));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v68;
        }
        while (v68);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 19:
      do
      {
        int v71 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v72 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v72))
            {
              unint64_t v73 = HIDWORD(v72);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAcolorburnPDA_5706(*v35, *v30, v72, BYTE4(v72));
                  LODWORD(v72) = result;
                  unint64_t v73 = HIDWORD(result);
                }
                *int v35 = v72;
                *char v30 = v73;
              }
              else
              {
                unint64_t result = PDAcolorburnPDA_5706(*v35, 255, v72, BYTE4(v72));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v71;
        }
        while (v71);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 20:
      do
      {
        int v74 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v75 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v75))
            {
              unint64_t v76 = HIDWORD(v75);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAsoftlightPDA_5708(*v35, *v30, v75, BYTE4(v75));
                  LODWORD(v75) = result;
                  unint64_t v76 = HIDWORD(result);
                }
                *int v35 = v75;
                *char v30 = v76;
              }
              else
              {
                unint64_t result = PDAsoftlightPDA_5708(*v35, 255, v75, BYTE4(v75));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v74;
        }
        while (v74);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 21:
      do
      {
        int v77 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v78 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v78))
            {
              unint64_t v79 = HIDWORD(v78);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAhardlightPDA_5707(*v35, *v30, v78, BYTE4(v78));
                  LODWORD(v78) = result;
                  unint64_t v79 = HIDWORD(result);
                }
                *int v35 = v78;
                *char v30 = v79;
              }
              else
              {
                unint64_t result = PDAhardlightPDA_5707(*v35, 255, v78, BYTE4(v78));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v77;
        }
        while (v77);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 22:
      do
      {
        int v80 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v81 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v81))
            {
              unint64_t v82 = HIDWORD(v81);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAdifferencePDA_5709(*v35, *v30, v81, BYTE4(v81));
                  LODWORD(v81) = result;
                  unint64_t v82 = HIDWORD(result);
                }
                *int v35 = v81;
                *char v30 = v82;
              }
              else
              {
                unint64_t result = PDAdifferencePDA_5709(*v35, 0xFFu, v81, BYTE4(v81));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v80;
        }
        while (v80);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 23:
      do
      {
        int v83 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v84 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v84))
            {
              unint64_t v85 = HIDWORD(v84);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAexclusionPDA_5710(*v35, *v30, v84, BYTE4(v84));
                  LODWORD(v84) = result;
                  unint64_t v85 = HIDWORD(result);
                }
                *int v35 = v84;
                *char v30 = v85;
              }
              else
              {
                unint64_t result = PDAexclusionPDA_5710(*v35, 255, v84, BYTE4(v84));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v83;
        }
        while (v83);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 24:
      do
      {
        int v86 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v87 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v87))
            {
              unint64_t v88 = HIDWORD(v87);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAhuePDA_5711(*v35, *v30, v87, BYTE4(v87));
                  LODWORD(v87) = result;
                  unint64_t v88 = HIDWORD(result);
                }
                *int v35 = v87;
                *char v30 = v88;
              }
              else
              {
                unint64_t result = PDAhuePDA_5711(*v35, 255, v87, BYTE4(v87));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v86;
        }
        while (v86);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 25:
      do
      {
        int v89 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v90 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v90))
            {
              unint64_t v91 = HIDWORD(v90);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAsaturationPDA_5712(*v35, *v30, v90, BYTE4(v90));
                  LODWORD(v90) = result;
                  unint64_t v91 = HIDWORD(result);
                }
                *int v35 = v90;
                *char v30 = v91;
              }
              else
              {
                unint64_t result = PDAsaturationPDA_5712(*v35, 255, v90, BYTE4(v90));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v89;
        }
        while (v89);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 26:
      do
      {
        int v92 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t result = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(result))
            {
              unint64_t v93 = HIDWORD(result);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAluminosityPDA_5713(result, BYTE4(result), *v35, *v30);
                  unint64_t v93 = HIDWORD(result);
                }
                *int v35 = result;
                *char v30 = v93;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_5713(result, BYTE4(result), *v35, 255);
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v92;
        }
        while (v92);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 27:
      do
      {
        int v94 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v95 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v95))
            {
              unint64_t v96 = HIDWORD(v95);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAluminosityPDA_5713(*v35, *v30, v95, BYTE4(v95));
                  LODWORD(v95) = result;
                  unint64_t v96 = HIDWORD(result);
                }
                *int v35 = v95;
                *char v30 = v96;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_5713(*v35, 255, v95, BYTE4(v95));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v94;
        }
        while (v94);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 28:
      do
      {
        int v97 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v98 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v98))
            {
              unint64_t v99 = HIDWORD(v98);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAtranspose_huePDA(*v35, *v30, v98, BYTE4(v98));
                  LODWORD(v98) = result;
                  unint64_t v99 = HIDWORD(result);
                }
                *int v35 = v98;
                *char v30 = v99;
              }
              else
              {
                unint64_t result = PDAtranspose_huePDA(*v35, 255, v98, BYTE4(v98));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v97;
        }
        while (v97);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 29:
      do
      {
        int v100 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v101 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v101))
            {
              unint64_t v102 = HIDWORD(v101);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAtranspose_saturationPDA(*v35, *v30, v101, BYTE4(v101));
                  LODWORD(v101) = result;
                  unint64_t v102 = HIDWORD(result);
                }
                *int v35 = v101;
                *char v30 = v102;
              }
              else
              {
                unint64_t result = PDAtranspose_saturationPDA(*v35, 255, v101, BYTE4(v101));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v100;
        }
        while (v100);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 30:
      do
      {
        int v103 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t result = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(result))
            {
              unint64_t v104 = HIDWORD(result);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v35, *v30);
                  unint64_t v104 = HIDWORD(result);
                }
                *int v35 = result;
                *char v30 = v104;
              }
              else
              {
                unint64_t result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v35, 255);
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v103;
        }
        while (v103);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 31:
      do
      {
        int v105 = v258;
        do
        {
          if (*(unsigned char *)v37)
          {
            unint64_t v106 = *(void *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v106))
            {
              unint64_t v107 = HIDWORD(v106);
              if (v4)
              {
                if (*v30)
                {
                  unint64_t result = PDAtranspose_luminosityPDA(*v35, *v30, v106, BYTE4(v106));
                  LODWORD(v106) = result;
                  unint64_t v107 = HIDWORD(result);
                }
                *int v35 = v106;
                *char v30 = v107;
              }
              else
              {
                unint64_t result = PDAtranspose_luminosityPDA(*v35, 255, v106, BYTE4(v106));
                *int v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v105;
        }
        while (v105);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    default:
      return result;
  }
}

unint64_t cmyk32_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 136);
  uint64_t v5 = *(int *)(result + 12);
  uint64_t v4 = *(int *)(result + 16);
  if (v2)
  {
    uint64_t v6 = *(int *)(result + 32);
    uint64_t v7 = (unsigned __int8 *)(v2 + v5 + (int)v6 * (uint64_t)(int)v4);
    int v8 = -1;
    if (!v3) {
      return result;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return result;
    }
  }
  int v9 = *(_DWORD *)(result + 4);
  int v10 = *(_DWORD *)(result + 8);
  uint64_t v11 = *(unsigned int **)(result + 88);
  double v12 = *(unsigned char **)(result + 96);
  unint64_t v13 = (unint64_t)*(int *)(result + 28) >> 2;
  double v14 = (unsigned int *)(*(void *)(result + 40) + 4 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(result + 124);
  double v16 = (char *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(result + 56);
  uint64_t v18 = *(int *)(result + 60);
  unint64_t v716 = (unint64_t)*(int *)(result + 76) >> 2;
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    int v20 = *(_DWORD *)(result + 64);
    int v21 = *(_DWORD *)(result + 68);
    if (v12)
    {
      uint64_t v714 = *(int *)(result + 80);
      int v19 = 1;
    }
    else
    {
      uint64_t v714 = 0;
      int v19 = 0;
    }
    unint64_t result = (unint64_t)&v11[v716 * v21];
    v8 &= 1u;
    int v26 = 1;
    unint64_t v745 = (unint64_t)v11;
    unsigned int v22 = v11;
    goto LABEL_19;
  }
  if (v12)
  {
    uint64_t v714 = *(int *)(result + 80);
    v12 += v17 + (int)v714 * (uint64_t)(int)v18;
    int v19 = -1;
  }
  else
  {
    uint64_t v714 = 0;
    int v19 = 0;
  }
  unsigned int v22 = &v11[v17 + v716 * v18];
  if (v716 == v13 && (char *)v14 - (char *)v22 >= 1)
  {
    if (v9 >= (uint64_t)((unint64_t)((char *)v14 - (char *)v22) >> 2))
    {
      v14 += v9 - 1;
      v22 += v9 - 1;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      int v26 = -1;
      unint64_t v716 = (unint64_t)*(int *)(result + 28) >> 2;
      v12 += v19 & (v9 - 1);
      goto LABEL_16;
    }
    uint64_t v23 = v10 - 1;
    unint64_t v24 = v13 * v23;
    uint64_t v25 = &v22[v13 * v23];
    if (v14 <= &v25[v9 - 1])
    {
      unint64_t v13 = -(uint64_t)v13;
      v16 += v15 * v23;
      uint64_t v15 = -v15;
      v7 += v6 * v23;
      uint64_t v6 = -v6;
      v8 &= 1u;
      v12 += v714 * v23;
      uint64_t v714 = -v714;
      v19 &= 1u;
      int v26 = 1;
      unsigned int v22 = v25;
      unint64_t v716 = v13;
      v14 += v24;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v19 &= 1u;
  int v26 = 1;
LABEL_16:
  uint64_t v11 = 0;
  unint64_t result = 0;
  unint64_t v745 = -1;
  int v21 = v714;
  int v20 = v716;
LABEL_19:
  int v718 = v10;
  int v719 = v8;
  int v27 = v26 * v9;
  int v715 = v9;
  unint64_t v697 = result;
  int v735 = v19;
  if (result)
  {
    uint64_t v28 = (int)v18 % v21;
    uint64_t v29 = &v22[v716 * v28];
    unint64_t result = (int)v17 % v20;
    unsigned int v22 = &v29[result];
    unint64_t v745 = (unint64_t)&v29[v20];
    if (v19) {
      v12 += v714 * v28 + result;
    }
    uint64_t v717 = &v29[result];
  }
  else
  {
    v716 -= v27;
    uint64_t v717 = v11;
    v714 -= v19 * v9;
  }
  uint64_t v713 = v15 - v27;
  unint64_t v712 = v13 - v27;
  uint64_t v696 = v6 - v8 * v9;
  switch(a2)
  {
    case 0:
      uint64_t v30 = v26;
      if (v8)
      {
        do
        {
          int v31 = v715;
          int v32 = v718;
          do
          {
            int v33 = *v16;
            if (*v16)
            {
              if (v33 == 255)
              {
                LOBYTE(v34) = 0;
                *double v14 = 0;
              }
              else
              {
                unint64_t result = PDAM_5699(*v14, *v7, v33 ^ 0xFFu);
                *double v14 = result;
                unint64_t v34 = HIDWORD(result);
              }
              *uint64_t v7 = v34;
            }
            v16 += v30;
            v7 += v719;
            v14 += v30;
            --v31;
          }
          while (v31);
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v32 != 1);
      }
      else
      {
        do
        {
          int v507 = v9;
          int v508 = v718;
          do
          {
            int v509 = *v16;
            if (*v16)
            {
              if (v509 == 255) {
                unsigned int v510 = 0;
              }
              else {
                unsigned int v510 = (((*v14 & 0xFF00FF) * (v509 ^ 0xFF)
              }
                       + 65537
                       + ((((*v14 & 0xFF00FF) * (v509 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v14 >> 8) & 0xFF00FF) * (v509 ^ 0xFF) + 65537 + (((((*v14 >> 8) & 0xFF00FF) * (v509 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
              *double v14 = v510;
            }
            v16 += v26;
            v14 += v26;
            --v507;
          }
          while (v507);
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v508 != 1);
      }
      return result;
    case 1:
      if (v8)
      {
        uint64_t v35 = v26;
        uint64_t v36 = v8;
        int v720 = v8;
        if (v19)
        {
          uint64_t v37 = v19;
          uint64_t v38 = -(uint64_t)v20;
          uint64_t v698 = -(uint64_t)(v716 * v21);
          uint64_t v665 = -(v714 * v21);
          v736 = v12;
          do
          {
            int v39 = v715;
            do
            {
              int v40 = *v16;
              if (*v16)
              {
                if (v40 == 255)
                {
                  *double v14 = *v22;
                  *uint64_t v7 = *v12;
                }
                else
                {
                  unint64_t result = (unint64_t)DAMplusDAM(v14, v7, *v22, *v12, v40, *v14, *v7, v40 ^ 0xFFu);
                  uint64_t v36 = v720;
                }
              }
              v16 += v35;
              v7 += v36;
              unint64_t v41 = &v22[v35];
              if ((unint64_t)v41 >= v745) {
                uint64_t v42 = v38;
              }
              else {
                uint64_t v42 = 0;
              }
              v12 += v37 + v42;
              unsigned int v22 = &v41[v42];
              v14 += v35;
              --v39;
            }
            while (v39);
            if (v697)
            {
              int v43 = &v717[v716];
              uint64_t v44 = &v736[v714];
              BOOL v45 = (unint64_t)v43 >= v697;
              uint64_t v46 = v698;
              if ((unint64_t)v43 < v697) {
                uint64_t v46 = 0;
              }
              unsigned int v22 = &v43[v46];
              unint64_t v47 = v745 + 4 * v46;
              uint64_t v48 = v665;
              if (!v45) {
                uint64_t v48 = 0;
              }
              double v12 = &v44[v48];
              v736 = &v44[v48];
              unint64_t v745 = v47 + 4 * v716;
              uint64_t v717 = v22;
            }
            else
            {
              v22 += v716;
              v12 += v714;
            }
            v16 += v713;
            v14 += v712;
            v7 += v696;
            --v718;
          }
          while (v718);
        }
        else
        {
          uint64_t v605 = -(uint64_t)v20;
          uint64_t v606 = -(uint64_t)(v716 * v21);
          do
          {
            int v607 = v715;
            do
            {
              int v608 = *v16;
              if (*v16)
              {
                if (v608 == 255)
                {
                  *double v14 = *v22;
                  *uint64_t v7 = -1;
                }
                else
                {
                  unint64_t result = (unint64_t)DAMplusDAM(v14, v7, *v22, 255, v608, *v14, *v7, v608 ^ 0xFFu);
                  uint64_t v36 = v720;
                }
              }
              v16 += v35;
              v7 += v36;
              signed int v609 = &v22[v35];
              if ((unint64_t)v609 >= v745) {
                uint64_t v610 = v605;
              }
              else {
                uint64_t v610 = 0;
              }
              unsigned int v22 = &v609[v610];
              v14 += v35;
              --v607;
            }
            while (v607);
            v16 += v713;
            v14 += v712;
            v7 += v696;
            unint64_t v611 = v717;
            unsigned int v612 = &v717[v716];
            if ((unint64_t)v612 >= v697) {
              uint64_t v613 = v606;
            }
            else {
              uint64_t v613 = 0;
            }
            uint64_t v614 = &v612[v613];
            unint64_t v615 = v745;
            uint64_t v616 = v745 + 4 * v613 + 4 * v716;
            if (v697) {
              unint64_t v611 = v614;
            }
            uint64_t v717 = v611;
            if (v697) {
              unint64_t v615 = v616;
            }
            unint64_t v745 = v615;
            if (v697) {
              unsigned int v22 = v614;
            }
            else {
              v22 += v716;
            }
            --v718;
          }
          while (v718);
        }
      }
      else
      {
        uint64_t v511 = v26;
        uint64_t v512 = -(uint64_t)v20;
        uint64_t v513 = -(uint64_t)(v716 * v21);
        uint64_t v514 = 4 * v26;
        do
        {
          int v515 = v715;
          int v516 = v718;
          do
          {
            int v517 = *v16;
            if (*v16)
            {
              if (v517 == 255) {
                *double v14 = *v22;
              }
              else {
                unint64_t result = (unint64_t)DMplusDM(v14, *v22, v517, *v14, v517 ^ 0xFFu);
              }
            }
            v16 += v511;
            int v518 = &v22[v511];
            if ((unint64_t)v518 >= v745) {
              uint64_t v519 = v512;
            }
            else {
              uint64_t v519 = 0;
            }
            unsigned int v22 = &v518[v519];
            double v14 = (unsigned int *)((char *)v14 + v514);
            --v515;
          }
          while (v515);
          v16 += v713;
          v14 += v712;
          uint64_t v520 = v717;
          uint64_t v521 = &v717[v716];
          if ((unint64_t)v521 >= v697) {
            uint64_t v522 = v513;
          }
          else {
            uint64_t v522 = 0;
          }
          unint64_t v523 = &v521[v522];
          unint64_t v524 = v745;
          uint64_t v525 = v745 + 4 * v522 + 4 * v716;
          if (v697) {
            uint64_t v520 = v523;
          }
          uint64_t v717 = v520;
          if (v697) {
            unint64_t v524 = v525;
          }
          unint64_t v745 = v524;
          if (v697) {
            unsigned int v22 = v523;
          }
          else {
            v22 += v716;
          }
          --v718;
        }
        while (v516 != 1);
      }
      return result;
    case 2:
      uint64_t v49 = v26;
      if (v8)
      {
        int v721 = v8;
        uint64_t v50 = v19;
        uint64_t v699 = -(uint64_t)(v716 * v21);
        uint64_t v666 = -(v714 * v21);
        unint64_t v737 = v12;
        uint64_t v51 = -(uint64_t)v20;
        while (1)
        {
          int v52 = v715;
          do
          {
            int v53 = *v16;
            if (!*v16) {
              goto LABEL_70;
            }
            if (v53 == 255)
            {
              int v54 = *v12;
              if (!*v12) {
                goto LABEL_70;
              }
              if (v54 == 255)
              {
                *double v14 = *v22;
                *uint64_t v7 = -1;
                goto LABEL_70;
              }
              int v55 = *v22;
              unsigned int v56 = *v14;
              int v57 = *v7;
              int v58 = v54 ^ 0xFF;
              int v59 = v14;
              unint64_t v60 = v7;
            }
            else
            {
              unint64_t result = PDAM_5699(*v22, *v12, v53);
              if (!BYTE4(result)) {
                goto LABEL_70;
              }
              int v55 = result;
              unsigned int v56 = *v14;
              int v57 = *v7;
              int v58 = ~BYTE4(result);
              LOBYTE(v54) = BYTE4(result);
              int v59 = v14;
              unint64_t v60 = v7;
            }
            unint64_t result = (unint64_t)DAplusDAM(v59, v60, v55, v54, v56, v57, v58);
LABEL_70:
            v16 += v49;
            v7 += v721;
            unint64_t v61 = &v22[v49];
            if ((unint64_t)v61 >= v745) {
              uint64_t v62 = v51;
            }
            else {
              uint64_t v62 = 0;
            }
            v12 += v50 + v62;
            unsigned int v22 = &v61[v62];
            v14 += v49;
            --v52;
          }
          while (v52);
          if (v697)
          {
            unint64_t v63 = &v717[v716];
            unint64_t v64 = &v737[v714];
            BOOL v65 = (unint64_t)v63 >= v697;
            uint64_t v66 = v699;
            if ((unint64_t)v63 < v697) {
              uint64_t v66 = 0;
            }
            unsigned int v22 = &v63[v66];
            unint64_t v67 = v745 + 4 * v66;
            uint64_t v68 = v666;
            if (!v65) {
              uint64_t v68 = 0;
            }
            double v12 = &v64[v68];
            unint64_t v737 = &v64[v68];
            unint64_t v745 = v67 + 4 * v716;
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          if (!--v718) {
            return result;
          }
        }
      }
      uint64_t v526 = v19;
      uint64_t v732 = -(uint64_t)(v716 * v21);
      uint64_t v709 = -(v714 * v21);
      int v743 = v12;
      uint64_t v527 = -(uint64_t)v20;
      break;
    case 3:
      uint64_t v69 = v26;
      int v722 = v8;
      uint64_t v667 = -(uint64_t)(v716 * v21);
      uint64_t v638 = -(v714 * v21);
      uint64_t v70 = 4 * v26;
      uint64_t v700 = v12;
      uint64_t v71 = -(uint64_t)v20;
      do
      {
        int v72 = v715;
        do
        {
          int v73 = *v16;
          if (*v16)
          {
            if (v73 == 255)
            {
              if (v735) {
                int v74 = *v12;
              }
              else {
                int v74 = 255;
              }
              unint64_t result = PDAM_5699(*v22, v74, *v7);
              *double v14 = result;
              *uint64_t v7 = BYTE4(result);
            }
            else
            {
              if (v735) {
                int v75 = *v12;
              }
              else {
                int v75 = 255;
              }
              unint64_t result = (unint64_t)DAMplusDAM(v14, v7, *v22, v75, ((unsigned __int16)(*v7 * (_WORD)v73+ ((*v7 * v73) >> 8)+ 1) >> 8), *v14, *v7, v73 ^ 0xFFu);
            }
          }
          v16 += v69;
          v7 += v722;
          unint64_t v76 = &v22[v69];
          if ((unint64_t)v76 >= v745) {
            uint64_t v77 = v71;
          }
          else {
            uint64_t v77 = 0;
          }
          v12 += v735 + v77;
          unsigned int v22 = &v76[v77];
          double v14 = (unsigned int *)((char *)v14 + v70);
          --v72;
        }
        while (v72);
        if (v697)
        {
          unint64_t v78 = &v717[v716];
          unint64_t v79 = &v700[v714];
          BOOL v80 = (unint64_t)v78 >= v697;
          uint64_t v81 = v667;
          if ((unint64_t)v78 < v697) {
            uint64_t v81 = 0;
          }
          unsigned int v22 = &v78[v81];
          unint64_t v82 = v745 + 4 * v81;
          uint64_t v83 = v638;
          if (!v80) {
            uint64_t v83 = 0;
          }
          double v12 = &v79[v83];
          unint64_t v745 = v82 + 4 * v716;
          uint64_t v700 = &v79[v83];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 4:
      uint64_t v84 = v26;
      int v723 = v8;
      uint64_t v668 = -(uint64_t)(v716 * v21);
      uint64_t v639 = -(v714 * v21);
      uint64_t v85 = 4 * v26;
      uint64_t v701 = v12;
      uint64_t v86 = -(uint64_t)v20;
      do
      {
        int v87 = v715;
        do
        {
          int v88 = *v16;
          if (*v16)
          {
            if (v88 == 255)
            {
              if (v735) {
                int v89 = *v12;
              }
              else {
                int v89 = 255;
              }
              unint64_t result = PDAM_5699(*v22, v89, *v7 ^ 0xFFu);
              *double v14 = result;
              *uint64_t v7 = BYTE4(result);
            }
            else
            {
              if (v735) {
                int v90 = *v12;
              }
              else {
                int v90 = 255;
              }
              unint64_t result = (unint64_t)DAMplusDAM(v14, v7, *v22, v90, ((unsigned __int16)((*v7 ^ 0xFF) * v88+ (((*v7 ^ 0xFFu) * v88) >> 8)+ 1) >> 8), *v14, *v7, v88 ^ 0xFFu);
            }
          }
          v16 += v84;
          v7 += v723;
          unint64_t v91 = &v22[v84];
          if ((unint64_t)v91 >= v745) {
            uint64_t v92 = v86;
          }
          else {
            uint64_t v92 = 0;
          }
          v12 += v735 + v92;
          unsigned int v22 = &v91[v92];
          double v14 = (unsigned int *)((char *)v14 + v85);
          --v87;
        }
        while (v87);
        if (v697)
        {
          unint64_t v93 = &v717[v716];
          int v94 = &v701[v714];
          BOOL v95 = (unint64_t)v93 >= v697;
          uint64_t v96 = v668;
          if ((unint64_t)v93 < v697) {
            uint64_t v96 = 0;
          }
          unsigned int v22 = &v93[v96];
          unint64_t v97 = v745 + 4 * v96;
          uint64_t v98 = v639;
          if (!v95) {
            uint64_t v98 = 0;
          }
          double v12 = &v94[v98];
          unint64_t v745 = v97 + 4 * v716;
          uint64_t v701 = &v94[v98];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 5:
      uint64_t v99 = v26;
      int v724 = v8;
      int v738 = v19;
      uint64_t v100 = -(uint64_t)v20;
      uint64_t v640 = -(v714 * v21);
      uint64_t v669 = -(uint64_t)(v716 * v21);
      uint64_t v101 = 4 * v26;
      uint64_t v702 = v12;
      do
      {
        int v102 = v715;
        do
        {
          if (*v16)
          {
            int v103 = *v7;
            unint64_t v104 = PDAM_5699(*v22, *v12, *v16);
            unint64_t result = (unint64_t)DAMplusDAM(v14, v7, v104, BYTE4(v104), v103, *v14, v103, ~BYTE4(v104));
          }
          v16 += v99;
          v7 += v724;
          int v105 = &v22[v99];
          if ((unint64_t)v105 >= v745) {
            uint64_t v106 = v100;
          }
          else {
            uint64_t v106 = 0;
          }
          v12 += v738 + v106;
          unsigned int v22 = &v105[v106];
          double v14 = (unsigned int *)((char *)v14 + v101);
          --v102;
        }
        while (v102);
        if (v697)
        {
          unint64_t v107 = &v717[v716];
          unsigned int v108 = &v702[v714];
          BOOL v109 = (unint64_t)v107 >= v697;
          uint64_t v110 = v669;
          if ((unint64_t)v107 < v697) {
            uint64_t v110 = 0;
          }
          unsigned int v22 = &v107[v110];
          unint64_t v111 = v745 + 4 * v110;
          uint64_t v112 = v640;
          if (!v109) {
            uint64_t v112 = 0;
          }
          double v12 = &v108[v112];
          unint64_t v745 = v111 + 4 * v716;
          uint64_t v702 = &v108[v112];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 6:
      uint64_t v113 = v26;
      uint64_t v114 = v8;
      uint64_t v115 = -(uint64_t)v20;
      uint64_t v641 = -(v714 * v21);
      uint64_t v670 = -(uint64_t)(v716 * v21);
      uint64_t v116 = 4 * v26;
      BOOL v703 = v12;
      int v725 = v8;
      do
      {
        int v117 = v715;
        do
        {
          int v118 = *v16;
          if (*v16 && *v7 != 0xFF)
          {
            if (~*v7 == 255)
            {
              if (v735) {
                int v119 = *v12;
              }
              else {
                int v119 = 255;
              }
              unint64_t result = PDAM_5699(*v22, v119, v118);
              *double v14 = result;
              *uint64_t v7 = BYTE4(result);
            }
            else
            {
              if (v735) {
                int v120 = *v12;
              }
              else {
                int v120 = 255;
              }
              unint64_t result = (unint64_t)DAplusDAM(v14, v7, *v14, *v7, *v22, v120, ((unsigned __int16)(~*v7 * (_WORD)v118+ ((~*v7* v118) >> 8)+ 1) >> 8));
            }
            uint64_t v114 = v725;
          }
          v16 += v113;
          v7 += v114;
          unsigned int v121 = &v22[v113];
          if ((unint64_t)v121 >= v745) {
            uint64_t v122 = v115;
          }
          else {
            uint64_t v122 = 0;
          }
          v12 += v735 + v122;
          unsigned int v22 = &v121[v122];
          double v14 = (unsigned int *)((char *)v14 + v116);
          --v117;
        }
        while (v117);
        if (v697)
        {
          int v123 = &v717[v716];
          int v124 = &v703[v714];
          BOOL v125 = (unint64_t)v123 >= v697;
          uint64_t v126 = v670;
          if ((unint64_t)v123 < v697) {
            uint64_t v126 = 0;
          }
          unsigned int v22 = &v123[v126];
          unint64_t v127 = v745 + 4 * v126;
          uint64_t v128 = v641;
          if (!v125) {
            uint64_t v128 = 0;
          }
          double v12 = &v124[v128];
          unint64_t v745 = v127 + 4 * v716;
          BOOL v703 = &v124[v128];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 7:
      uint64_t v129 = v26;
      if (v8)
      {
        int v726 = v8;
        uint64_t v130 = v19;
        uint64_t v704 = -(uint64_t)(v716 * v21);
        uint64_t v671 = -(v714 * v21);
        uint64_t v739 = v12;
        uint64_t v131 = -(uint64_t)v20;
        do
        {
          int v132 = v715;
          do
          {
            int v133 = *v16;
            if (*v16)
            {
              if (v133 == 255)
              {
                unint64_t result = PDAM_5699(*v14, *v7, *v12);
                *double v14 = result;
                *uint64_t v7 = BYTE4(result);
              }
              else
              {
                unint64_t result = (unint64_t)DAMplusDAM(v14, v7, *v14, *v7, ((unsigned __int16)(*v12 * (_WORD)v133+ ((*v12* v133) >> 8)+ 1) >> 8), *v14, *v7, v133 ^ 0xFFu);
              }
            }
            v16 += v129;
            v7 += v726;
            int v134 = &v22[v129];
            if ((unint64_t)v134 >= v745) {
              uint64_t v135 = v131;
            }
            else {
              uint64_t v135 = 0;
            }
            v12 += v130 + v135;
            unsigned int v22 = &v134[v135];
            v14 += v129;
            --v132;
          }
          while (v132);
          if (v697)
          {
            int v136 = &v717[v716];
            uint64_t v137 = &v739[v714];
            BOOL v138 = (unint64_t)v136 >= v697;
            uint64_t v139 = v704;
            if ((unint64_t)v136 < v697) {
              uint64_t v139 = 0;
            }
            unsigned int v22 = &v136[v139];
            unint64_t v140 = v745 + 4 * v139;
            uint64_t v141 = v671;
            if (!v138) {
              uint64_t v141 = 0;
            }
            double v12 = &v137[v141];
            uint64_t v739 = &v137[v141];
            unint64_t v745 = v140 + 4 * v716;
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        uint64_t v546 = v19;
        uint64_t v733 = -(uint64_t)(v716 * v21);
        uint64_t v710 = -(v714 * v21);
        uint64_t v744 = v12;
        uint64_t v547 = -(uint64_t)v20;
        do
        {
          int v548 = v715;
          do
          {
            int v549 = *v16;
            if (*v16)
            {
              if (v549 == 255)
              {
                int v550 = *v12;
                *double v14 = (((*v14 & 0xFF00FF) * v550 + 65537 + ((((*v14 & 0xFF00FF) * v550) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v14 >> 8) & 0xFF00FF) * v550 + 65537 + (((((*v14 >> 8) & 0xFF00FF) * v550) >> 8) & 0xFF00FF)) & 0xFF00FF00;
              }
              else
              {
                unint64_t result = (unint64_t)DMplusDM(v14, *v14, ((unsigned __int16)(*v12 * (_WORD)v549+ ((*v12* v549) >> 8)+ 1) >> 8), *v14, v549 ^ 0xFFu);
              }
            }
            v16 += v129;
            unint64_t v551 = &v22[v129];
            if ((unint64_t)v551 >= v745) {
              uint64_t v552 = v547;
            }
            else {
              uint64_t v552 = 0;
            }
            v12 += v546 + v552;
            unsigned int v22 = &v551[v552];
            v14 += v129;
            --v548;
          }
          while (v548);
          if (v697)
          {
            unsigned int v553 = &v717[v716];
            unint64_t v554 = &v744[v714];
            BOOL v555 = (unint64_t)v553 >= v697;
            uint64_t v556 = v733;
            if ((unint64_t)v553 < v697) {
              uint64_t v556 = 0;
            }
            unsigned int v22 = &v553[v556];
            unint64_t v557 = v745 + 4 * v556;
            uint64_t v558 = v710;
            if (!v555) {
              uint64_t v558 = 0;
            }
            double v12 = &v554[v558];
            uint64_t v744 = &v554[v558];
            unint64_t v745 = v557 + 4 * v716;
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v718);
      }
      return result;
    case 8:
      uint64_t v142 = v26;
      if (v8)
      {
        int v727 = v8;
        uint64_t v143 = v19;
        uint64_t v705 = -(uint64_t)(v716 * v21);
        uint64_t v672 = -(v714 * v21);
        v740 = v12;
        uint64_t v144 = -(uint64_t)v20;
        do
        {
          int v145 = v715;
          do
          {
            int v146 = *v16;
            if (*v16)
            {
              if (v146 == 255) {
                int v147 = *v12 ^ 0xFF;
              }
              else {
                int v147 = ~((*v12 * v146
              }
                                         + ((*v12 * v146) >> 8)
                                         + 1) >> 8);
              unint64_t result = PDAM_5699(*v14, *v7, v147);
              *double v14 = result;
              *uint64_t v7 = BYTE4(result);
            }
            v16 += v142;
            v7 += v727;
            unsigned int v148 = &v22[v142];
            if ((unint64_t)v148 >= v745) {
              uint64_t v149 = v144;
            }
            else {
              uint64_t v149 = 0;
            }
            v12 += v143 + v149;
            unsigned int v22 = &v148[v149];
            v14 += v142;
            --v145;
          }
          while (v145);
          if (v697)
          {
            char v150 = &v717[v716];
            unint64_t v151 = &v740[v714];
            BOOL v152 = (unint64_t)v150 >= v697;
            uint64_t v153 = v705;
            if ((unint64_t)v150 < v697) {
              uint64_t v153 = 0;
            }
            unsigned int v22 = &v150[v153];
            unint64_t v154 = v745 + 4 * v153;
            uint64_t v155 = v672;
            if (!v152) {
              uint64_t v155 = 0;
            }
            double v12 = &v151[v155];
            v740 = &v151[v155];
            unint64_t v745 = v154 + 4 * v716;
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        uint64_t v559 = v21;
        uint64_t v560 = -(uint64_t)(v716 * v21);
        unint64_t v561 = -(v714 * v559);
        unint64_t v562 = v12;
        uint64_t v563 = -(uint64_t)v20;
        do
        {
          int v564 = v715;
          int v565 = v718;
          do
          {
            int v566 = *v16;
            if (*v16)
            {
              if (v566 == 255)
              {
                int v567 = *v12 ^ 0xFF;
                unsigned int v568 = *v14 & 0xFF00FF;
                unsigned int v569 = ((*v14 >> 8) & 0xFF00FF) * v567;
              }
              else
              {
                int v567 = *v14 & 0xFF00FF;
                unsigned int v568 = ((*v12 * v566 + ((*v12 * v566) >> 8) + 1) >> 8) ^ 0xFF;
                unsigned int v569 = v568 * ((*v14 >> 8) & 0xFF00FF);
              }
              *double v14 = ((v568 * v567 + 65537 + (((v568 * v567) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v569
                                                                                                  + 65537
                                                                                                  + ((v569 >> 8) & 0xFF00FF)) & 0xFF00FF00;
            }
            v16 += v26;
            float v570 = &v22[v26];
            if ((unint64_t)v570 >= v745) {
              uint64_t v571 = v563;
            }
            else {
              uint64_t v571 = 0;
            }
            v12 += v735 + v571;
            unsigned int v22 = &v570[v571];
            v14 += v26;
            --v564;
          }
          while (v564);
          unint64_t result = v697;
          if (v697)
          {
            float v572 = &v717[v716];
            BOOL v573 = &v562[v714];
            BOOL v574 = (unint64_t)v572 >= v697;
            if ((unint64_t)v572 >= v697) {
              uint64_t v575 = v560;
            }
            else {
              uint64_t v575 = 0;
            }
            unsigned int v22 = &v572[v575];
            unint64_t v576 = v745 + 4 * v575;
            if (v574) {
              unint64_t result = v561;
            }
            else {
              unint64_t result = 0;
            }
            double v12 = &v573[result];
            unint64_t v745 = v576 + 4 * v716;
            unint64_t v562 = &v573[result];
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v565 != 1);
      }
      return result;
    case 9:
      uint64_t v156 = v26;
      int v728 = v8;
      int v741 = v19;
      uint64_t v642 = -(uint64_t)(v716 * v21);
      uint64_t v673 = v12;
      uint64_t v617 = -(v714 * v21);
      uint64_t v706 = 4 * v26;
      uint64_t v157 = -(uint64_t)v20;
      do
      {
        int v158 = v715;
        do
        {
          char v159 = *v16;
          if (*v16)
          {
            int v160 = *v7;
            unint64_t v161 = PDAM_5699(*v22, *v12, *v16);
            unint64_t result = (unint64_t)DAMplusDAM(v14, v7, v161, BYTE4(v161), v160 ^ 0xFFu, *v14, v160, (BYTE4(v161) + ~v159));
          }
          v16 += v156;
          v7 += v728;
          int v162 = &v22[v156];
          if ((unint64_t)v162 >= v745) {
            uint64_t v163 = v157;
          }
          else {
            uint64_t v163 = 0;
          }
          v12 += v741 + v163;
          unsigned int v22 = &v162[v163];
          double v14 = (unsigned int *)((char *)v14 + v706);
          --v158;
        }
        while (v158);
        if (v697)
        {
          unsigned int v164 = &v717[v716];
          int v165 = &v673[v714];
          BOOL v166 = (unint64_t)v164 >= v697;
          uint64_t v167 = v642;
          if ((unint64_t)v164 < v697) {
            uint64_t v167 = 0;
          }
          unsigned int v22 = &v164[v167];
          unint64_t v168 = v745 + 4 * v167;
          uint64_t v169 = v617;
          if (!v166) {
            uint64_t v169 = 0;
          }
          double v12 = &v165[v169];
          unint64_t v745 = v168 + 4 * v716;
          uint64_t v673 = &v165[v169];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 10:
      uint64_t v170 = v26;
      int v729 = v8;
      int v742 = v19;
      uint64_t v171 = -(uint64_t)v20;
      uint64_t v643 = -(v714 * v21);
      uint64_t v674 = -(uint64_t)(v716 * v21);
      uint64_t v172 = 4 * v26;
      uint64_t v707 = v12;
      do
      {
        int v173 = v715;
        do
        {
          if (*v16)
          {
            int v174 = *v7;
            unint64_t v175 = PDAM_5699(*v22, *v12, *v16);
            unint64_t result = (unint64_t)DAMplusDAM(v14, v7, v175, BYTE4(v175), v174 ^ 0xFFu, *v14, v174, ~BYTE4(v175));
          }
          v16 += v170;
          v7 += v729;
          unsigned int v176 = &v22[v170];
          if ((unint64_t)v176 >= v745) {
            uint64_t v177 = v171;
          }
          else {
            uint64_t v177 = 0;
          }
          v12 += v742 + v177;
          unsigned int v22 = &v176[v177];
          double v14 = (unsigned int *)((char *)v14 + v172);
          --v173;
        }
        while (v173);
        if (v697)
        {
          unsigned int v178 = &v717[v716];
          int v179 = &v707[v714];
          BOOL v180 = (unint64_t)v178 >= v697;
          uint64_t v181 = v674;
          if ((unint64_t)v178 < v697) {
            uint64_t v181 = 0;
          }
          unsigned int v22 = &v178[v181];
          unint64_t v182 = v745 + 4 * v181;
          uint64_t v183 = v643;
          if (!v180) {
            uint64_t v183 = 0;
          }
          double v12 = &v179[v183];
          unint64_t v745 = v182 + 4 * v716;
          uint64_t v707 = &v179[v183];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 11:
      uint64_t v184 = v26;
      if (v8)
      {
        int v730 = v8;
        uint64_t v675 = -(uint64_t)(v716 * v21);
        uint64_t v644 = -(v714 * v21);
        uint8x8_t v708 = v12;
        uint64_t v185 = -(uint64_t)v20;
        do
        {
          int v186 = v715;
          do
          {
            if (*v16)
            {
              if (v735) {
                int v187 = *v12;
              }
              else {
                int v187 = 255;
              }
              unint64_t v188 = PDAM_5699(*v22, v187, *v16);
              unint64_t result = (unint64_t)DAplusdDA(v14, v7, *v14, *v7, v188, BYTE4(v188));
            }
            v16 += v184;
            v7 += v730;
            unsigned int v189 = &v22[v184];
            if ((unint64_t)v189 >= v745) {
              uint64_t v190 = v185;
            }
            else {
              uint64_t v190 = 0;
            }
            v12 += v735 + v190;
            unsigned int v22 = &v189[v190];
            v14 += v184;
            --v186;
          }
          while (v186);
          if (v697)
          {
            unsigned int v191 = &v717[v716];
            uint64_t v192 = &v708[v714];
            BOOL v193 = (unint64_t)v191 >= v697;
            uint64_t v194 = v675;
            if ((unint64_t)v191 < v697) {
              uint64_t v194 = 0;
            }
            unsigned int v22 = &v191[v194];
            unint64_t v195 = v745 + 4 * v194;
            uint64_t v196 = v644;
            if (!v193) {
              uint64_t v196 = 0;
            }
            double v12 = &v192[v196];
            unint64_t v745 = v195 + 4 * v716;
            uint8x8_t v708 = &v192[v196];
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        uint64_t v577 = -(uint64_t)v20;
        uint64_t v734 = -(uint64_t)(v716 * v21);
        uint64_t v711 = -(v714 * v21);
        uint64_t v578 = v12;
        do
        {
          int v579 = v715;
          do
          {
            if (*v16)
            {
              if (v735) {
                int v580 = *v12;
              }
              else {
                int v580 = 255;
              }
              unint64_t v581 = PDAM_5699(*v22, v580, *v16);
              unint64_t result = (unint64_t)DplusdDA(v14, *v14, v581, BYTE4(v581));
            }
            v16 += v184;
            unint64_t v582 = &v22[v184];
            if ((unint64_t)v582 >= v745) {
              uint64_t v583 = v577;
            }
            else {
              uint64_t v583 = 0;
            }
            v12 += v735 + v583;
            unsigned int v22 = &v582[v583];
            v14 += v184;
            --v579;
          }
          while (v579);
          if (v697)
          {
            uint64_t v584 = &v717[v716];
            uint64_t v585 = &v578[v714];
            BOOL v586 = (unint64_t)v584 >= v697;
            uint64_t v587 = v734;
            if ((unint64_t)v584 < v697) {
              uint64_t v587 = 0;
            }
            unsigned int v22 = &v584[v587];
            unint64_t v588 = v745 + 4 * v587;
            uint64_t v589 = v711;
            if (!v586) {
              uint64_t v589 = 0;
            }
            double v12 = &v585[v589];
            unint64_t v745 = v588 + 4 * v716;
            uint64_t v578 = &v585[v589];
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v718);
      }
      return result;
    case 12:
      uint64_t v197 = v26;
      if (v8)
      {
        int v731 = v8;
        uint64_t v198 = -(uint64_t)v20;
        uint64_t v618 = -(v714 * v21);
        uint64_t v645 = -(uint64_t)(v716 * v21);
        uint64_t v676 = v12;
        do
        {
          int v199 = v715;
          do
          {
            if (*v16)
            {
              if (v735) {
                int v200 = *v12;
              }
              else {
                int v200 = 255;
              }
              unint64_t result = PDAM_5699(*v22, v200, *v16);
              unsigned int v201 = ((result >> 8) & 0xFF00FF) + ((*v14 >> 8) & 0xFF00FF);
              unsigned int v202 = *v7 + HIDWORD(result);
              unsigned int v203 = (v201 << 8) & 0xFF00FF00 | ((result & 0xFF00FF) + (*v14 & 0xFF00FF)) & 0xFF00FF | (15 * (v201 & 0x1000100 | (((result & 0xFF00FF) + (*v14 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v201 & 0x1000100 | (((result & 0xFF00FF) + (*v14 & 0xFF00FF)) >> 8) & 0x10001));
              if (v202 >= 0xFF) {
                LOBYTE(v202) = -1;
              }
              *uint64_t v7 = v202;
              *double v14 = v203;
            }
            v16 += v197;
            v7 += v731;
            int v204 = &v22[v197];
            if ((unint64_t)v204 >= v745) {
              uint64_t v205 = v198;
            }
            else {
              uint64_t v205 = 0;
            }
            v12 += v735 + v205;
            unsigned int v22 = &v204[v205];
            v14 += v197;
            --v199;
          }
          while (v199);
          if (v697)
          {
            __int32 v206 = &v717[v716];
            int v207 = &v676[v714];
            BOOL v208 = (unint64_t)v206 >= v697;
            uint64_t v209 = v645;
            if ((unint64_t)v206 < v697) {
              uint64_t v209 = 0;
            }
            unsigned int v22 = &v206[v209];
            unint64_t v210 = v745 + 4 * v209;
            uint64_t v211 = v618;
            if (!v208) {
              uint64_t v211 = 0;
            }
            double v12 = &v207[v211];
            unint64_t v745 = v210 + 4 * v716;
            uint64_t v676 = &v207[v211];
            uint64_t v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        uint64_t v590 = -(uint64_t)v20;
        uint64_t v591 = -(uint64_t)(v716 * v21);
        do
        {
          int v592 = v715;
          int v593 = v718;
          do
          {
            int v594 = *v16;
            if (*v16)
            {
              unsigned int v595 = (((((*v22 >> 8) & 0xFF00FF) * v594 + 65537 + (((((*v22 >> 8) & 0xFF00FF) * v594) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                   + ((*v14 >> 8) & 0xFF00FF);
              unsigned int v596 = ((((*v22 & 0xFF00FF) * v594 + 65537 + ((((*v22 & 0xFF00FF) * v594) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                   + (*v14 & 0xFF00FF);
              *double v14 = (v595 << 8) & 0xFF00FF00 | v596 & 0xFF00FF | (15 * (v595 & 0x1000100 | (v596 >> 8) & 0x10001)) | (240 * (v595 & 0x1000100 | (v596 >> 8) & 0x10001));
            }
            v16 += v197;
            unsigned int v597 = &v22[v197];
            if ((unint64_t)v597 >= v745) {
              uint64_t v598 = v590;
            }
            else {
              uint64_t v598 = 0;
            }
            unsigned int v22 = &v597[v598];
            v14 += v197;
            --v592;
          }
          while (v592);
          v16 += v713;
          v14 += v712;
          uint64_t v599 = v717;
          uint64_t v600 = &v717[v716];
          unint64_t result = v697;
          if ((unint64_t)v600 >= v697) {
            uint64_t v601 = v591;
          }
          else {
            uint64_t v601 = 0;
          }
          uint64_t v602 = &v600[v601];
          unint64_t v603 = v745;
          uint64_t v604 = v745 + 4 * v601 + 4 * v716;
          if (v697) {
            uint64_t v599 = v602;
          }
          uint64_t v717 = v599;
          if (v697) {
            unint64_t v603 = v604;
          }
          unint64_t v745 = v603;
          if (v697) {
            unsigned int v22 = v602;
          }
          else {
            v22 += v716;
          }
          --v718;
        }
        while (v593 != 1);
      }
      return result;
    case 13:
      uint64_t v212 = v26;
      uint64_t v646 = -(uint64_t)(v716 * v21);
      uint64_t v677 = v12;
      uint64_t v619 = -(v714 * v21);
      uint64_t v213 = 4 * v26;
      uint64_t v214 = -(uint64_t)v20;
      do
      {
        int v215 = v715;
        do
        {
          if (*v16)
          {
            int v216 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v216, *v16);
            if (BYTE4(result))
            {
              unsigned int v217 = result;
              unint64_t v218 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAmultiplyPDA_5700(*v14, *v7, result, BYTE4(result));
                  unsigned int v217 = result;
                  unint64_t v218 = HIDWORD(result);
                }
                *double v14 = v217;
                *uint64_t v7 = v218;
              }
              else
              {
                unint64_t result = PDAmultiplyPDA_5700(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v212;
          v7 += v719;
          unint64_t v219 = &v22[v212];
          if ((unint64_t)v219 >= v745) {
            uint64_t v220 = v214;
          }
          else {
            uint64_t v220 = 0;
          }
          v12 += v735 + v220;
          unsigned int v22 = &v219[v220];
          double v14 = (unsigned int *)((char *)v14 + v213);
          --v215;
        }
        while (v215);
        if (v697)
        {
          unsigned int v221 = &v717[v716];
          int v222 = &v677[v714];
          BOOL v223 = (unint64_t)v221 >= v697;
          uint64_t v224 = v646;
          if ((unint64_t)v221 < v697) {
            uint64_t v224 = 0;
          }
          unsigned int v22 = &v221[v224];
          unint64_t v225 = v745 + 4 * v224;
          uint64_t v226 = v619;
          if (!v223) {
            uint64_t v226 = 0;
          }
          double v12 = &v222[v226];
          unint64_t v745 = v225 + 4 * v716;
          uint64_t v677 = &v222[v226];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 14:
      uint64_t v227 = v26;
      uint64_t v647 = -(uint64_t)(v716 * v21);
      int v678 = v12;
      uint64_t v620 = -(v714 * v21);
      uint64_t v228 = 4 * v26;
      uint64_t v229 = -(uint64_t)v20;
      do
      {
        int v230 = v715;
        do
        {
          if (*v16)
          {
            int v231 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v231, *v16);
            if (BYTE4(result))
            {
              unsigned int v232 = result;
              unint64_t v233 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAscreenPDA_5701(*v14, *v7, result, BYTE4(result));
                  unsigned int v232 = result;
                  unint64_t v233 = HIDWORD(result);
                }
                *double v14 = v232;
                *uint64_t v7 = v233;
              }
              else
              {
                unint64_t result = PDAscreenPDA_5701(*v14, 0xFFu, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v227;
          v7 += v719;
          uint64_t v234 = &v22[v227];
          if ((unint64_t)v234 >= v745) {
            uint64_t v235 = v229;
          }
          else {
            uint64_t v235 = 0;
          }
          v12 += v735 + v235;
          unsigned int v22 = &v234[v235];
          double v14 = (unsigned int *)((char *)v14 + v228);
          --v230;
        }
        while (v230);
        if (v697)
        {
          uint64_t v236 = &v717[v716];
          int v237 = &v678[v714];
          BOOL v238 = (unint64_t)v236 >= v697;
          uint64_t v239 = v647;
          if ((unint64_t)v236 < v697) {
            uint64_t v239 = 0;
          }
          unsigned int v22 = &v236[v239];
          unint64_t v240 = v745 + 4 * v239;
          uint64_t v241 = v620;
          if (!v238) {
            uint64_t v241 = 0;
          }
          double v12 = &v237[v241];
          unint64_t v745 = v240 + 4 * v716;
          int v678 = &v237[v241];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 15:
      uint64_t v242 = v26;
      uint64_t v648 = -(uint64_t)(v716 * v21);
      BOOL v679 = v12;
      uint64_t v621 = -(v714 * v21);
      uint64_t v243 = 4 * v26;
      uint64_t v244 = -(uint64_t)v20;
      do
      {
        int v245 = v715;
        do
        {
          if (*v16)
          {
            int v246 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v246, *v16);
            if (BYTE4(result))
            {
              unsigned int v247 = result;
              unint64_t v248 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAoverlayPDA_5702(*v14, *v7, result, BYTE4(result));
                  unsigned int v247 = result;
                  unint64_t v248 = HIDWORD(result);
                }
                *double v14 = v247;
                *uint64_t v7 = v248;
              }
              else
              {
                unint64_t result = PDAoverlayPDA_5702(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v242;
          v7 += v719;
          int v249 = &v22[v242];
          if ((unint64_t)v249 >= v745) {
            uint64_t v250 = v244;
          }
          else {
            uint64_t v250 = 0;
          }
          v12 += v735 + v250;
          unsigned int v22 = &v249[v250];
          double v14 = (unsigned int *)((char *)v14 + v243);
          --v245;
        }
        while (v245);
        if (v697)
        {
          uint64_t v251 = &v717[v716];
          int v252 = &v679[v714];
          BOOL v253 = (unint64_t)v251 >= v697;
          uint64_t v254 = v648;
          if ((unint64_t)v251 < v697) {
            uint64_t v254 = 0;
          }
          unsigned int v22 = &v251[v254];
          unint64_t v255 = v745 + 4 * v254;
          uint64_t v256 = v621;
          if (!v253) {
            uint64_t v256 = 0;
          }
          double v12 = &v252[v256];
          unint64_t v745 = v255 + 4 * v716;
          BOOL v679 = &v252[v256];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 16:
      uint64_t v257 = v26;
      uint64_t v649 = -(uint64_t)(v716 * v21);
      uint64_t v680 = v12;
      uint64_t v622 = -(v714 * v21);
      uint64_t v258 = 4 * v26;
      uint64_t v259 = -(uint64_t)v20;
      do
      {
        int v260 = v715;
        do
        {
          if (*v16)
          {
            int v261 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v261, *v16);
            if (BYTE4(result))
            {
              unsigned int v268 = result;
              unint64_t v269 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAdarkenPDA_5704(*v14, *v7, result, BYTE4(result), v262, v263, v264, v265, v266, v267);
                  unsigned int v268 = result;
                  unint64_t v269 = HIDWORD(result);
                }
                *double v14 = v268;
                *uint64_t v7 = v269;
              }
              else
              {
                unint64_t result = PDAdarkenPDA_5704(*v14, 0xFFu, result, BYTE4(result), v262, v263, v264, v265, v266, v267);
                *double v14 = result;
              }
            }
          }
          v16 += v257;
          v7 += v719;
          uint64_t v270 = &v22[v257];
          if ((unint64_t)v270 >= v745) {
            uint64_t v271 = v259;
          }
          else {
            uint64_t v271 = 0;
          }
          v12 += v735 + v271;
          unsigned int v22 = &v270[v271];
          double v14 = (unsigned int *)((char *)v14 + v258);
          --v260;
        }
        while (v260);
        if (v697)
        {
          uint64_t v272 = &v717[v716];
          uint64_t v273 = &v680[v714];
          BOOL v274 = (unint64_t)v272 >= v697;
          uint64_t v275 = v649;
          if ((unint64_t)v272 < v697) {
            uint64_t v275 = 0;
          }
          unsigned int v22 = &v272[v275];
          unint64_t v276 = v745 + 4 * v275;
          uint64_t v277 = v622;
          if (!v274) {
            uint64_t v277 = 0;
          }
          double v12 = &v273[v277];
          unint64_t v745 = v276 + 4 * v716;
          uint64_t v680 = &v273[v277];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 17:
      uint64_t v278 = v26;
      uint64_t v650 = -(uint64_t)(v716 * v21);
      long long v681 = v12;
      uint64_t v623 = -(v714 * v21);
      uint64_t v279 = 4 * v26;
      uint64_t v280 = -(uint64_t)v20;
      do
      {
        int v281 = v715;
        do
        {
          if (*v16)
          {
            int v282 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v282, *v16);
            if (BYTE4(result))
            {
              unsigned int v289 = result;
              unint64_t v290 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAlightenPDA_5703(*v14, *v7, result, BYTE4(result), v283, v284, v285, v286, v287, v288);
                  unsigned int v289 = result;
                  unint64_t v290 = HIDWORD(result);
                }
                *double v14 = v289;
                *uint64_t v7 = v290;
              }
              else
              {
                unint64_t result = PDAlightenPDA_5703(*v14, 0xFFu, result, BYTE4(result), v283, v284, v285, v286, v287, v288);
                *double v14 = result;
              }
            }
          }
          v16 += v278;
          v7 += v719;
          uint64_t v291 = &v22[v278];
          if ((unint64_t)v291 >= v745) {
            uint64_t v292 = v280;
          }
          else {
            uint64_t v292 = 0;
          }
          v12 += v735 + v292;
          unsigned int v22 = &v291[v292];
          double v14 = (unsigned int *)((char *)v14 + v279);
          --v281;
        }
        while (v281);
        if (v697)
        {
          unint64_t v293 = &v717[v716];
          unint64_t v294 = &v681[v714];
          BOOL v295 = (unint64_t)v293 >= v697;
          uint64_t v296 = v650;
          if ((unint64_t)v293 < v697) {
            uint64_t v296 = 0;
          }
          unsigned int v22 = &v293[v296];
          unint64_t v297 = v745 + 4 * v296;
          uint64_t v298 = v623;
          if (!v295) {
            uint64_t v298 = 0;
          }
          double v12 = &v294[v298];
          unint64_t v745 = v297 + 4 * v716;
          long long v681 = &v294[v298];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 18:
      uint64_t v299 = v26;
      uint64_t v651 = -(uint64_t)(v716 * v21);
      unint64_t v682 = v12;
      uint64_t v624 = -(v714 * v21);
      uint64_t v300 = 4 * v26;
      uint64_t v301 = -(uint64_t)v20;
      do
      {
        int v302 = v715;
        do
        {
          if (*v16)
          {
            int v303 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v303, *v16);
            if (BYTE4(result))
            {
              unsigned int v304 = result;
              unint64_t v305 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAcolordodgePDA_5705(*v14, *v7, result, BYTE4(result));
                  unsigned int v304 = result;
                  unint64_t v305 = HIDWORD(result);
                }
                *double v14 = v304;
                *uint64_t v7 = v305;
              }
              else
              {
                unint64_t result = PDAcolordodgePDA_5705(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v299;
          v7 += v719;
          int v306 = &v22[v299];
          if ((unint64_t)v306 >= v745) {
            uint64_t v307 = v301;
          }
          else {
            uint64_t v307 = 0;
          }
          v12 += v735 + v307;
          unsigned int v22 = &v306[v307];
          double v14 = (unsigned int *)((char *)v14 + v300);
          --v302;
        }
        while (v302);
        if (v697)
        {
          unint64_t v308 = &v717[v716];
          int v309 = &v682[v714];
          BOOL v310 = (unint64_t)v308 >= v697;
          uint64_t v311 = v651;
          if ((unint64_t)v308 < v697) {
            uint64_t v311 = 0;
          }
          unsigned int v22 = &v308[v311];
          unint64_t v312 = v745 + 4 * v311;
          uint64_t v313 = v624;
          if (!v310) {
            uint64_t v313 = 0;
          }
          double v12 = &v309[v313];
          unint64_t v745 = v312 + 4 * v716;
          unint64_t v682 = &v309[v313];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 19:
      uint64_t v314 = v26;
      uint64_t v652 = -(uint64_t)(v716 * v21);
      uint64_t v683 = v12;
      uint64_t v625 = -(v714 * v21);
      uint64_t v315 = 4 * v26;
      uint64_t v316 = -(uint64_t)v20;
      do
      {
        int v317 = v715;
        do
        {
          if (*v16)
          {
            int v318 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v318, *v16);
            if (BYTE4(result))
            {
              unsigned int v319 = result;
              unint64_t v320 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAcolorburnPDA_5706(*v14, *v7, result, BYTE4(result));
                  unsigned int v319 = result;
                  unint64_t v320 = HIDWORD(result);
                }
                *double v14 = v319;
                *uint64_t v7 = v320;
              }
              else
              {
                unint64_t result = PDAcolorburnPDA_5706(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v314;
          v7 += v719;
          int v321 = &v22[v314];
          if ((unint64_t)v321 >= v745) {
            uint64_t v322 = v316;
          }
          else {
            uint64_t v322 = 0;
          }
          v12 += v735 + v322;
          unsigned int v22 = &v321[v322];
          double v14 = (unsigned int *)((char *)v14 + v315);
          --v317;
        }
        while (v317);
        if (v697)
        {
          unsigned int v323 = &v717[v716];
          unsigned int v324 = &v683[v714];
          BOOL v325 = (unint64_t)v323 >= v697;
          uint64_t v326 = v652;
          if ((unint64_t)v323 < v697) {
            uint64_t v326 = 0;
          }
          unsigned int v22 = &v323[v326];
          unint64_t v327 = v745 + 4 * v326;
          uint64_t v328 = v625;
          if (!v325) {
            uint64_t v328 = 0;
          }
          double v12 = &v324[v328];
          unint64_t v745 = v327 + 4 * v716;
          uint64_t v683 = &v324[v328];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 20:
      uint64_t v329 = v26;
      uint64_t v653 = -(uint64_t)(v716 * v21);
      uint64_t v684 = v12;
      uint64_t v626 = -(v714 * v21);
      uint64_t v330 = 4 * v26;
      uint64_t v331 = -(uint64_t)v20;
      do
      {
        int v332 = v715;
        do
        {
          if (*v16)
          {
            int v333 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v333, *v16);
            if (BYTE4(result))
            {
              unsigned int v334 = result;
              unint64_t v335 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAsoftlightPDA_5708(*v14, *v7, result, BYTE4(result));
                  unsigned int v334 = result;
                  unint64_t v335 = HIDWORD(result);
                }
                *double v14 = v334;
                *uint64_t v7 = v335;
              }
              else
              {
                unint64_t result = PDAsoftlightPDA_5708(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v329;
          v7 += v719;
          unint64_t v336 = &v22[v329];
          if ((unint64_t)v336 >= v745) {
            uint64_t v337 = v331;
          }
          else {
            uint64_t v337 = 0;
          }
          v12 += v735 + v337;
          unsigned int v22 = &v336[v337];
          double v14 = (unsigned int *)((char *)v14 + v330);
          --v332;
        }
        while (v332);
        if (v697)
        {
          uint64_t v338 = &v717[v716];
          uint64_t v339 = &v684[v714];
          BOOL v340 = (unint64_t)v338 >= v697;
          uint64_t v341 = v653;
          if ((unint64_t)v338 < v697) {
            uint64_t v341 = 0;
          }
          unsigned int v22 = &v338[v341];
          unint64_t v342 = v745 + 4 * v341;
          uint64_t v343 = v626;
          if (!v340) {
            uint64_t v343 = 0;
          }
          double v12 = &v339[v343];
          unint64_t v745 = v342 + 4 * v716;
          uint64_t v684 = &v339[v343];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 21:
      uint64_t v344 = v26;
      uint64_t v654 = -(uint64_t)(v716 * v21);
      int v685 = v12;
      uint64_t v627 = -(v714 * v21);
      uint64_t v345 = 4 * v26;
      uint64_t v346 = -(uint64_t)v20;
      do
      {
        int v347 = v715;
        do
        {
          if (*v16)
          {
            int v348 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v348, *v16);
            if (BYTE4(result))
            {
              unsigned int v349 = result;
              unint64_t v350 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAhardlightPDA_5707(*v14, *v7, result, BYTE4(result));
                  unsigned int v349 = result;
                  unint64_t v350 = HIDWORD(result);
                }
                *double v14 = v349;
                *uint64_t v7 = v350;
              }
              else
              {
                unint64_t result = PDAhardlightPDA_5707(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v344;
          v7 += v719;
          unint64_t v351 = &v22[v344];
          if ((unint64_t)v351 >= v745) {
            uint64_t v352 = v346;
          }
          else {
            uint64_t v352 = 0;
          }
          v12 += v735 + v352;
          unsigned int v22 = &v351[v352];
          double v14 = (unsigned int *)((char *)v14 + v345);
          --v347;
        }
        while (v347);
        if (v697)
        {
          int v353 = &v717[v716];
          int v354 = &v685[v714];
          BOOL v355 = (unint64_t)v353 >= v697;
          uint64_t v356 = v654;
          if ((unint64_t)v353 < v697) {
            uint64_t v356 = 0;
          }
          unsigned int v22 = &v353[v356];
          unint64_t v357 = v745 + 4 * v356;
          uint64_t v358 = v627;
          if (!v355) {
            uint64_t v358 = 0;
          }
          double v12 = &v354[v358];
          unint64_t v745 = v357 + 4 * v716;
          int v685 = &v354[v358];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 22:
      uint64_t v359 = v26;
      uint64_t v655 = -(uint64_t)(v716 * v21);
      int v686 = v12;
      uint64_t v628 = -(v714 * v21);
      uint64_t v360 = 4 * v26;
      uint64_t v361 = -(uint64_t)v20;
      do
      {
        int v362 = v715;
        do
        {
          if (*v16)
          {
            int v363 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v363, *v16);
            if (BYTE4(result))
            {
              unsigned int v364 = result;
              unint64_t v365 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAdifferencePDA_5709(*v14, *v7, result, BYTE4(result));
                  unsigned int v364 = result;
                  unint64_t v365 = HIDWORD(result);
                }
                *double v14 = v364;
                *uint64_t v7 = v365;
              }
              else
              {
                unint64_t result = PDAdifferencePDA_5709(*v14, 0xFFu, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v359;
          v7 += v719;
          uint64_t v366 = &v22[v359];
          if ((unint64_t)v366 >= v745) {
            uint64_t v367 = v361;
          }
          else {
            uint64_t v367 = 0;
          }
          v12 += v735 + v367;
          unsigned int v22 = &v366[v367];
          double v14 = (unsigned int *)((char *)v14 + v360);
          --v362;
        }
        while (v362);
        if (v697)
        {
          int v368 = &v717[v716];
          unint64_t v369 = &v686[v714];
          BOOL v370 = (unint64_t)v368 >= v697;
          uint64_t v371 = v655;
          if ((unint64_t)v368 < v697) {
            uint64_t v371 = 0;
          }
          unsigned int v22 = &v368[v371];
          unint64_t v372 = v745 + 4 * v371;
          uint64_t v373 = v628;
          if (!v370) {
            uint64_t v373 = 0;
          }
          double v12 = &v369[v373];
          unint64_t v745 = v372 + 4 * v716;
          int v686 = &v369[v373];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 23:
      uint64_t v374 = v26;
      uint64_t v656 = -(uint64_t)(v716 * v21);
      unint64_t v687 = v12;
      uint64_t v629 = -(v714 * v21);
      uint64_t v375 = 4 * v26;
      uint64_t v376 = -(uint64_t)v20;
      do
      {
        int v377 = v715;
        do
        {
          if (*v16)
          {
            int v378 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v378, *v16);
            if (BYTE4(result))
            {
              unsigned int v379 = result;
              unint64_t v380 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAexclusionPDA_5710(*v14, *v7, result, BYTE4(result));
                  unsigned int v379 = result;
                  unint64_t v380 = HIDWORD(result);
                }
                *double v14 = v379;
                *uint64_t v7 = v380;
              }
              else
              {
                unint64_t result = PDAexclusionPDA_5710(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v374;
          v7 += v719;
          uint64_t v381 = &v22[v374];
          if ((unint64_t)v381 >= v745) {
            uint64_t v382 = v376;
          }
          else {
            uint64_t v382 = 0;
          }
          v12 += v735 + v382;
          unsigned int v22 = &v381[v382];
          double v14 = (unsigned int *)((char *)v14 + v375);
          --v377;
        }
        while (v377);
        if (v697)
        {
          unint64_t v383 = &v717[v716];
          unsigned int v384 = &v687[v714];
          BOOL v385 = (unint64_t)v383 >= v697;
          uint64_t v386 = v656;
          if ((unint64_t)v383 < v697) {
            uint64_t v386 = 0;
          }
          unsigned int v22 = &v383[v386];
          unint64_t v387 = v745 + 4 * v386;
          uint64_t v388 = v629;
          if (!v385) {
            uint64_t v388 = 0;
          }
          double v12 = &v384[v388];
          unint64_t v745 = v387 + 4 * v716;
          unint64_t v687 = &v384[v388];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 24:
      uint64_t v389 = v26;
      uint64_t v657 = -(uint64_t)(v716 * v21);
      int v688 = v12;
      uint64_t v630 = -(v714 * v21);
      uint64_t v390 = 4 * v26;
      uint64_t v391 = -(uint64_t)v20;
      do
      {
        int v392 = v715;
        do
        {
          if (*v16)
          {
            int v393 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v393, *v16);
            if (BYTE4(result))
            {
              unsigned int v394 = result;
              unint64_t v395 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAhuePDA_5711(*v14, *v7, result, BYTE4(result));
                  unsigned int v394 = result;
                  unint64_t v395 = HIDWORD(result);
                }
                *double v14 = v394;
                *uint64_t v7 = v395;
              }
              else
              {
                unint64_t result = PDAhuePDA_5711(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v389;
          v7 += v719;
          int v396 = &v22[v389];
          if ((unint64_t)v396 >= v745) {
            uint64_t v397 = v391;
          }
          else {
            uint64_t v397 = 0;
          }
          v12 += v735 + v397;
          unsigned int v22 = &v396[v397];
          double v14 = (unsigned int *)((char *)v14 + v390);
          --v392;
        }
        while (v392);
        if (v697)
        {
          int v398 = &v717[v716];
          unint64_t v399 = &v688[v714];
          BOOL v400 = (unint64_t)v398 >= v697;
          uint64_t v401 = v657;
          if ((unint64_t)v398 < v697) {
            uint64_t v401 = 0;
          }
          unsigned int v22 = &v398[v401];
          unint64_t v402 = v745 + 4 * v401;
          uint64_t v403 = v630;
          if (!v400) {
            uint64_t v403 = 0;
          }
          double v12 = &v399[v403];
          unint64_t v745 = v402 + 4 * v716;
          int v688 = &v399[v403];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 25:
      uint64_t v404 = v26;
      uint64_t v658 = -(uint64_t)(v716 * v21);
      unsigned int v689 = v12;
      uint64_t v631 = -(v714 * v21);
      uint64_t v405 = 4 * v26;
      uint64_t v406 = -(uint64_t)v20;
      do
      {
        int v407 = v715;
        do
        {
          if (*v16)
          {
            int v408 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v408, *v16);
            if (BYTE4(result))
            {
              unsigned int v409 = result;
              unint64_t v410 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAsaturationPDA_5712(*v14, *v7, result, BYTE4(result));
                  unsigned int v409 = result;
                  unint64_t v410 = HIDWORD(result);
                }
                *double v14 = v409;
                *uint64_t v7 = v410;
              }
              else
              {
                unint64_t result = PDAsaturationPDA_5712(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v404;
          v7 += v719;
          unint64_t v411 = &v22[v404];
          if ((unint64_t)v411 >= v745) {
            uint64_t v412 = v406;
          }
          else {
            uint64_t v412 = 0;
          }
          v12 += v735 + v412;
          unsigned int v22 = &v411[v412];
          double v14 = (unsigned int *)((char *)v14 + v405);
          --v407;
        }
        while (v407);
        if (v697)
        {
          unint64_t v413 = &v717[v716];
          unsigned int v414 = &v689[v714];
          BOOL v415 = (unint64_t)v413 >= v697;
          uint64_t v416 = v658;
          if ((unint64_t)v413 < v697) {
            uint64_t v416 = 0;
          }
          unsigned int v22 = &v413[v416];
          unint64_t v417 = v745 + 4 * v416;
          uint64_t v418 = v631;
          if (!v415) {
            uint64_t v418 = 0;
          }
          double v12 = &v414[v418];
          unint64_t v745 = v417 + 4 * v716;
          unsigned int v689 = &v414[v418];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 26:
      uint64_t v419 = v26;
      uint64_t v659 = -(uint64_t)(v716 * v21);
      uint64_t v690 = v12;
      uint64_t v632 = -(v714 * v21);
      uint64_t v420 = 4 * v26;
      uint64_t v421 = -(uint64_t)v20;
      do
      {
        int v422 = v715;
        do
        {
          if (*v16)
          {
            int v423 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v423, *v16);
            if (BYTE4(result))
            {
              unint64_t v424 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAluminosityPDA_5713(result, BYTE4(result), *v14, *v7);
                  unint64_t v424 = HIDWORD(result);
                }
                *double v14 = result;
                *uint64_t v7 = v424;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_5713(result, BYTE4(result), *v14, 255);
                *double v14 = result;
              }
            }
          }
          v16 += v419;
          v7 += v719;
          unint64_t v425 = &v22[v419];
          if ((unint64_t)v425 >= v745) {
            uint64_t v426 = v421;
          }
          else {
            uint64_t v426 = 0;
          }
          v12 += v735 + v426;
          unsigned int v22 = &v425[v426];
          double v14 = (unsigned int *)((char *)v14 + v420);
          --v422;
        }
        while (v422);
        if (v697)
        {
          unint64_t v427 = &v717[v716];
          unsigned int v428 = &v690[v714];
          BOOL v429 = (unint64_t)v427 >= v697;
          uint64_t v430 = v659;
          if ((unint64_t)v427 < v697) {
            uint64_t v430 = 0;
          }
          unsigned int v22 = &v427[v430];
          unint64_t v431 = v745 + 4 * v430;
          uint64_t v432 = v632;
          if (!v429) {
            uint64_t v432 = 0;
          }
          double v12 = &v428[v432];
          unint64_t v745 = v431 + 4 * v716;
          uint64_t v690 = &v428[v432];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 27:
      uint64_t v433 = v26;
      uint64_t v660 = -(uint64_t)(v716 * v21);
      unsigned int v691 = v12;
      uint64_t v633 = -(v714 * v21);
      uint64_t v434 = 4 * v26;
      uint64_t v435 = -(uint64_t)v20;
      do
      {
        int v436 = v715;
        do
        {
          if (*v16)
          {
            int v437 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v437, *v16);
            if (BYTE4(result))
            {
              unsigned int v438 = result;
              unint64_t v439 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAluminosityPDA_5713(*v14, *v7, result, BYTE4(result));
                  unsigned int v438 = result;
                  unint64_t v439 = HIDWORD(result);
                }
                *double v14 = v438;
                *uint64_t v7 = v439;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_5713(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v433;
          v7 += v719;
          int v440 = &v22[v433];
          if ((unint64_t)v440 >= v745) {
            uint64_t v441 = v435;
          }
          else {
            uint64_t v441 = 0;
          }
          v12 += v735 + v441;
          unsigned int v22 = &v440[v441];
          double v14 = (unsigned int *)((char *)v14 + v434);
          --v436;
        }
        while (v436);
        if (v697)
        {
          unsigned int v442 = &v717[v716];
          uint64_t v443 = &v691[v714];
          BOOL v444 = (unint64_t)v442 >= v697;
          uint64_t v445 = v660;
          if ((unint64_t)v442 < v697) {
            uint64_t v445 = 0;
          }
          unsigned int v22 = &v442[v445];
          unint64_t v446 = v745 + 4 * v445;
          uint64_t v447 = v633;
          if (!v444) {
            uint64_t v447 = 0;
          }
          double v12 = &v443[v447];
          unint64_t v745 = v446 + 4 * v716;
          unsigned int v691 = &v443[v447];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 28:
      uint64_t v448 = v26;
      uint64_t v661 = -(uint64_t)(v716 * v21);
      BOOL v692 = v12;
      uint64_t v634 = -(v714 * v21);
      uint64_t v449 = 4 * v26;
      uint64_t v450 = -(uint64_t)v20;
      do
      {
        int v451 = v715;
        do
        {
          if (*v16)
          {
            int v452 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v452, *v16);
            if (BYTE4(result))
            {
              unsigned int v453 = result;
              unint64_t v454 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAtranspose_huePDA(*v14, *v7, result, BYTE4(result));
                  unsigned int v453 = result;
                  unint64_t v454 = HIDWORD(result);
                }
                *double v14 = v453;
                *uint64_t v7 = v454;
              }
              else
              {
                unint64_t result = PDAtranspose_huePDA(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v448;
          v7 += v719;
          unint64_t v455 = &v22[v448];
          if ((unint64_t)v455 >= v745) {
            uint64_t v456 = v450;
          }
          else {
            uint64_t v456 = 0;
          }
          v12 += v735 + v456;
          unsigned int v22 = &v455[v456];
          double v14 = (unsigned int *)((char *)v14 + v449);
          --v451;
        }
        while (v451);
        if (v697)
        {
          float v457 = &v717[v716];
          uint64_t v458 = &v692[v714];
          BOOL v459 = (unint64_t)v457 >= v697;
          uint64_t v460 = v661;
          if ((unint64_t)v457 < v697) {
            uint64_t v460 = 0;
          }
          unsigned int v22 = &v457[v460];
          unint64_t v461 = v745 + 4 * v460;
          uint64_t v462 = v634;
          if (!v459) {
            uint64_t v462 = 0;
          }
          double v12 = &v458[v462];
          unint64_t v745 = v461 + 4 * v716;
          BOOL v692 = &v458[v462];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 29:
      uint64_t v463 = v26;
      uint64_t v662 = -(uint64_t)(v716 * v21);
      uint64_t v693 = v12;
      uint64_t v635 = -(v714 * v21);
      uint64_t v464 = 4 * v26;
      uint64_t v465 = -(uint64_t)v20;
      do
      {
        int v466 = v715;
        do
        {
          if (*v16)
          {
            int v467 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v467, *v16);
            if (BYTE4(result))
            {
              unsigned int v468 = result;
              unint64_t v469 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAtranspose_saturationPDA(*v14, *v7, result, BYTE4(result));
                  unsigned int v468 = result;
                  unint64_t v469 = HIDWORD(result);
                }
                *double v14 = v468;
                *uint64_t v7 = v469;
              }
              else
              {
                unint64_t result = PDAtranspose_saturationPDA(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v463;
          v7 += v719;
          unsigned int v470 = &v22[v463];
          if ((unint64_t)v470 >= v745) {
            uint64_t v471 = v465;
          }
          else {
            uint64_t v471 = 0;
          }
          v12 += v735 + v471;
          unsigned int v22 = &v470[v471];
          double v14 = (unsigned int *)((char *)v14 + v464);
          --v466;
        }
        while (v466);
        if (v697)
        {
          uint64_t v472 = &v717[v716];
          unsigned int v473 = &v693[v714];
          BOOL v474 = (unint64_t)v472 >= v697;
          uint64_t v475 = v662;
          if ((unint64_t)v472 < v697) {
            uint64_t v475 = 0;
          }
          unsigned int v22 = &v472[v475];
          unint64_t v476 = v745 + 4 * v475;
          uint64_t v477 = v635;
          if (!v474) {
            uint64_t v477 = 0;
          }
          double v12 = &v473[v477];
          unint64_t v745 = v476 + 4 * v716;
          uint64_t v693 = &v473[v477];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 30:
      uint64_t v478 = v26;
      uint64_t v663 = -(uint64_t)(v716 * v21);
      uint64_t v694 = v12;
      uint64_t v636 = -(v714 * v21);
      uint64_t v479 = 4 * v26;
      uint64_t v480 = -(uint64_t)v20;
      do
      {
        int v481 = v715;
        do
        {
          if (*v16)
          {
            int v482 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v482, *v16);
            if (BYTE4(result))
            {
              unint64_t v483 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v14, *v7);
                  unint64_t v483 = HIDWORD(result);
                }
                *double v14 = result;
                *uint64_t v7 = v483;
              }
              else
              {
                unint64_t result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v14, 255);
                *double v14 = result;
              }
            }
          }
          v16 += v478;
          v7 += v719;
          unsigned int v484 = &v22[v478];
          if ((unint64_t)v484 >= v745) {
            uint64_t v485 = v480;
          }
          else {
            uint64_t v485 = 0;
          }
          v12 += v735 + v485;
          unsigned int v22 = &v484[v485];
          double v14 = (unsigned int *)((char *)v14 + v479);
          --v481;
        }
        while (v481);
        if (v697)
        {
          uint64_t v486 = &v717[v716];
          uint64_t v487 = &v694[v714];
          BOOL v488 = (unint64_t)v486 >= v697;
          uint64_t v489 = v663;
          if ((unint64_t)v486 < v697) {
            uint64_t v489 = 0;
          }
          unsigned int v22 = &v486[v489];
          unint64_t v490 = v745 + 4 * v489;
          uint64_t v491 = v636;
          if (!v488) {
            uint64_t v491 = 0;
          }
          double v12 = &v487[v491];
          unint64_t v745 = v490 + 4 * v716;
          uint64_t v694 = &v487[v491];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 31:
      uint64_t v492 = v26;
      uint64_t v664 = -(uint64_t)(v716 * v21);
      unint64_t v695 = v12;
      uint64_t v637 = -(v714 * v21);
      uint64_t v493 = 4 * v26;
      uint64_t v494 = -(uint64_t)v20;
      do
      {
        int v495 = v715;
        do
        {
          if (*v16)
          {
            int v496 = v735 ? *v12 : 255;
            unint64_t result = PDAM_5699(*v22, v496, *v16);
            if (BYTE4(result))
            {
              unsigned int v497 = result;
              unint64_t v498 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  unint64_t result = PDAtranspose_luminosityPDA(*v14, *v7, result, BYTE4(result));
                  unsigned int v497 = result;
                  unint64_t v498 = HIDWORD(result);
                }
                *double v14 = v497;
                *uint64_t v7 = v498;
              }
              else
              {
                unint64_t result = PDAtranspose_luminosityPDA(*v14, 255, result, BYTE4(result));
                *double v14 = result;
              }
            }
          }
          v16 += v492;
          v7 += v719;
          float v499 = &v22[v492];
          if ((unint64_t)v499 >= v745) {
            uint64_t v500 = v494;
          }
          else {
            uint64_t v500 = 0;
          }
          v12 += v735 + v500;
          unsigned int v22 = &v499[v500];
          double v14 = (unsigned int *)((char *)v14 + v493);
          --v495;
        }
        while (v495);
        if (v697)
        {
          float v501 = &v717[v716];
          BOOL v502 = &v695[v714];
          BOOL v503 = (unint64_t)v501 >= v697;
          uint64_t v504 = v664;
          if ((unint64_t)v501 < v697) {
            uint64_t v504 = 0;
          }
          unsigned int v22 = &v501[v504];
          unint64_t v505 = v745 + 4 * v504;
          uint64_t v506 = v637;
          if (!v503) {
            uint64_t v506 = 0;
          }
          double v12 = &v502[v506];
          unint64_t v745 = v505 + 4 * v716;
          unint64_t v695 = &v502[v506];
          uint64_t v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    default:
      return result;
  }
  do
  {
    int v528 = v715;
    do
    {
      int v529 = *v16;
      if (!*v16) {
        goto LABEL_814;
      }
      if (v529 != 255)
      {
        unint64_t result = PDAM_5699(*v22, *v12, v529);
        if (!BYTE4(result)) {
          goto LABEL_814;
        }
        int v532 = BYTE4(result) ^ 0xFF;
        unsigned int v533 = ((*v14 >> 8) & 0xFF00FF) * v532 + 65537 + (((((*v14 >> 8) & 0xFF00FF) * v532) >> 8) & 0xFF00FF);
        unsigned int v534 = (((*v14 & 0xFF00FF) * v532 + 65537 + ((((*v14 & 0xFF00FF) * v532) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
        unsigned int v535 = (v533 & 0xFF00FF00) + result;
        goto LABEL_812;
      }
      int v530 = *v12;
      if (!*v12) {
        goto LABEL_814;
      }
      if (v530 != 255)
      {
        int v536 = v530 ^ 0xFF;
        unsigned int v537 = ((*v14 >> 8) & 0xFF00FF) * v536 + 65537 + (((((*v14 >> 8) & 0xFF00FF) * v536) >> 8) & 0xFF00FF);
        unsigned int v534 = (((*v14 & 0xFF00FF) * v536 + 65537 + ((((*v14 & 0xFF00FF) * v536) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
        unsigned int v535 = (v537 & 0xFF00FF00) + *v22;
LABEL_812:
        unsigned int v531 = v535 + v534;
        goto LABEL_813;
      }
      unsigned int v531 = *v22;
LABEL_813:
      *double v14 = v531;
LABEL_814:
      v16 += v49;
      signed int v538 = &v22[v49];
      if ((unint64_t)v538 >= v745) {
        uint64_t v539 = v527;
      }
      else {
        uint64_t v539 = 0;
      }
      v12 += v526 + v539;
      unsigned int v22 = &v538[v539];
      v14 += v49;
      --v528;
    }
    while (v528);
    if (v697)
    {
      unsigned int v540 = &v717[v716];
      int v541 = &v743[v714];
      BOOL v542 = (unint64_t)v540 >= v697;
      uint64_t v543 = v732;
      if ((unint64_t)v540 < v697) {
        uint64_t v543 = 0;
      }
      unsigned int v22 = &v540[v543];
      unint64_t v544 = v745 + 4 * v543;
      uint64_t v545 = v709;
      if (!v542) {
        uint64_t v545 = 0;
      }
      double v12 = &v541[v545];
      int v743 = &v541[v545];
      unint64_t v745 = v544 + 4 * v716;
      uint64_t v717 = v22;
    }
    else
    {
      v22 += v716;
      v12 += v714;
    }
    v16 += v713;
    v14 += v712;
    --v718;
  }
  while (v718);
  return result;
}

_DWORD *cmyk32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11 = PIXELCONSTANT(*(float **)(*(void *)a1 + 64), a4, a5, a6, a7, a8, a9);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDBC0;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    a2[12] = v11;
    *((void *)a2 + 4) = a2 + 12;
    if (BYTE4(v11) == 255)
    {
      *((void *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = 16843009 * BYTE4(v11);
      *((void *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

unint64_t PIXELCONSTANT(float *a1, int a2, float32x2_t *a3, float a4, double a5, double a6, double a7)
{
  *(float *)&a7 = *a1;
  *(float *)&a6 = a1[1];
  float v7 = *(float *)&a6;
  if (*(float *)&a6 >= a4)
  {
    float v7 = a4;
    if (*(float *)&a7 > a4) {
      float v7 = *a1;
    }
  }
  float v8 = a1[3];
  float v9 = v7 * a1[2];
  if (a3) {
    int v10 = a2;
  }
  else {
    int v10 = 0;
  }
  if (v10 == 1)
  {
    float v34 = a1[1];
    if (a3->f32[0] <= *(float *)&a6)
    {
      float v34 = a3->f32[0];
      if (a3->f32[0] < *(float *)&a7) {
        float v34 = *a1;
      }
    }
    unsigned int v20 = 0;
    unsigned int v21 = 0;
    unsigned int v22 = 0;
    unsigned int v33 = (float)(v8 + (float)((float)(*(float *)&a6 - v34) * v9));
    uint64_t v19 = (float)(v8 + v9);
  }
  else
  {
    if (v10 == 4)
    {
      float v24 = a3->f32[1];
      float v25 = a3[1].f32[0];
      float v26 = a3[1].f32[1];
      uint64_t v19 = (float)(v8 + v9);
      if (a3->f32[0] < *(float *)&a7) {
        float v27 = *a1;
      }
      else {
        float v27 = a3->f32[0];
      }
      if (a3->f32[0] <= *(float *)&a6) {
        float v28 = v27;
      }
      else {
        float v28 = a1[1];
      }
      if (v24 < *(float *)&a7) {
        float v29 = *a1;
      }
      else {
        float v29 = a3->f32[1];
      }
      if (v24 <= *(float *)&a6) {
        float v30 = v29;
      }
      else {
        float v30 = a1[1];
      }
      if (v25 < *(float *)&a7) {
        float v31 = *a1;
      }
      else {
        float v31 = a3[1].f32[0];
      }
      if (v25 <= *(float *)&a6) {
        float v32 = v31;
      }
      else {
        float v32 = a1[1];
      }
      if (v26 >= *(float *)&a7) {
        LODWORD(a7) = a3[1].i32[1];
      }
      if (v26 <= *(float *)&a6) {
        *(float *)&a6 = *(float *)&a7;
      }
      unsigned int v20 = (float)(v8 + (float)(v28 * v9));
      unsigned int v21 = (float)(v8 + (float)(v30 * v9));
      unsigned int v22 = (float)(v8 + (float)(v32 * v9));
      float v23 = v8 + (float)(*(float *)&a6 * v9);
    }
    else
    {
      if (v10 != 3)
      {
        unsigned int v20 = 0;
        unsigned int v21 = 0;
        unsigned int v22 = 0;
        unsigned int v33 = (float)(v8 + v9);
        uint64_t v19 = v33;
        return (v21 << 16) | (v20 << 24) | (v22 << 8) | v33 | (unint64_t)(v19 << 32);
      }
      float v11 = a3[1].f32[0];
      float32x2_t v12 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
      float32x2_t v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0);
      int8x8_t v14 = vbsl_s8((int8x8_t)vcgt_f32(*a3, v12), (int8x8_t)v13, (int8x8_t)vsub_f32(v12, (float32x2_t)vbic_s8((int8x8_t)*a3, (int8x8_t)vcgt_f32(v13, *a3))));
      float v15 = 0.0;
      if (v11 >= *(float *)&a7) {
        float v15 = a3[1].f32[0];
      }
      float v16 = *(float *)&a6 - v15;
      if (v11 <= *(float *)&a6) {
        float v17 = v16;
      }
      else {
        float v17 = *a1;
      }
      if (*(float *)v14.i32 >= *(float *)&v14.i32[1]) {
        float v18 = *(float *)&v14.i32[1];
      }
      else {
        float v18 = *(float *)v14.i32;
      }
      if (v17 < v18) {
        float v18 = v17;
      }
      uint64_t v19 = (float)(v8 + v9);
      unsigned int v20 = (float)(v8 + (float)((float)(*(float *)v14.i32 - v18) * v9));
      unsigned int v21 = (float)(v8 + (float)((float)(*(float *)&v14.i32[1] - v18) * v9));
      unsigned int v22 = (float)(v8 + (float)((float)(v17 - v18) * v9));
      float v23 = v8 + (float)(v18 * v9);
    }
    unsigned int v33 = v23;
  }
  return (v21 << 16) | (v20 << 24) | (v22 << 8) | v33 | (unint64_t)(v19 << 32);
}

uint64_t CMYK32_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if (v11 >= 24 && *(_DWORD *)v8 == 134759428) {
    v11 += 4;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(void *)(v5 + 16))
    {
      int8x8_t v14 = CMYK32_shade_radial_CMYK;
    }
    else if (*(void *)(v5 + 24))
    {
      int8x8_t v14 = CMYK32_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      int8x8_t v14 = CMYK32_shade_axial_CMYK;
    }
    else
    {
      int8x8_t v14 = CMYK32_shade_custom_CMYK;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 384)
    {
      float v16 = v44;
      v38[1] = v44;
LABEL_30:
      _blt_shade_samples_16((uint64_t)v16, 2, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_32;
    }
    float v16 = malloc_type_malloc(10 * v15 + 32, 0xE83E6668uLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_30;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_32:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  cmyk32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

void CMYK32_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  float v6 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
             + (float)(v5 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  uint64_t v7 = a1 + 368;
  uint64_t v8 = *(void *)(a1 + 368);
  uint64_t v9 = ((unint64_t)a3 >> 4) & 0xF0;
  uint64_t v10 = v8 + v9;
  if (v8) {
    uint64_t v11 = v8 + v9;
  }
  else {
    uint64_t v11 = a1 + 368;
  }
  if (v8) {
    char v12 = 15;
  }
  else {
    char v12 = 0;
  }
  float v14 = *(float *)(a1 + 336);
  float v15 = *(float *)(a1 + 344);
  float v16 = *(float *)(a1 + 304);
  float v17 = *(float *)(a1 + 308);
  int v18 = *(_DWORD *)(a1 + 320);
  int v19 = *(_DWORD *)(a1 + 324);
  uint64_t v22 = a1 + 144;
  long long v20 = *(_DWORD **)(a1 + 144);
  long long v21 = *(int8x16_t **)(v22 + 8);
  long long v23 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v24 = *(void *)(a1 + 360);
  if (v5 != 0.0)
  {
    if (v8) {
      unsigned int v30 = (a2 >> 8) & 0xF;
    }
    else {
      LOBYTE(v30) = 0;
    }
    while (1)
    {
      int v31 = v18;
      if (v6 >= v16)
      {
        int v31 = v19;
        if (v6 <= v17) {
          int v31 = (int)(float)(v15 * (float)(v6 - v14));
        }
      }
      if (v31 < 0)
      {
        if (!v23)
        {
          char v36 = 0;
          goto LABEL_40;
        }
        unsigned int v33 = *(unsigned __int8 *)(v11 + v30);
        __int16 v34 = v33 + *v23;
        long long v32 = v23;
      }
      else
      {
        long long v32 = (unsigned __int16 *)(v24 + 10 * v31);
        unsigned int v33 = *(unsigned __int8 *)(v11 + v30);
        __int16 v34 = v33 + *v32;
      }
      uint32x4_t v35 = vaddw_u16((uint32x4_t)vdupq_n_s32(v33), *(uint16x4_t *)(v32 + 1));
      v21->i64[0] = (v35.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v35.i16[6] & 0xFF00) >> 8) << 32) | (v35.i32[1] << 8) & 0xFF0000 | (unint64_t)(v35.i16[0] & 0xFF00) | HIBYTE(v34);
      char v36 = -1;
LABEL_40:
      LOBYTE(v30) = (v30 + 1) & v12;
      float v6 = v5 + v6;
      long long v21 = (int8x16_t *)((char *)v21 + 8);
      *(unsigned char *)long long v20 = v36;
      long long v20 = (_DWORD *)((char *)v20 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v8) {
    uint64_t v25 = v10;
  }
  else {
    uint64_t v25 = v7;
  }
  if (v8) {
    LODWORD(v26) = ((a2 >> 8) + 1) & 0xF;
  }
  else {
    LODWORD(v26) = 0;
  }
  if (v8) {
    unsigned int v27 = (a2 >> 8) & 0xF;
  }
  else {
    unsigned int v27 = 0;
  }
  if (v8) {
    int v28 = 15;
  }
  else {
    int v28 = 0;
  }
  if (v6 >= v16)
  {
    int v18 = v19;
    if (v6 <= v17) {
      int v18 = (int)(float)(v15 * (float)(v6 - v14));
    }
  }
  if ((v18 & 0x80000000) == 0 || v23)
  {
    long long v37 = (unsigned __int16 *)(v24 + 10 * v18);
    if (v18 < 0) {
      uint64_t v38 = v23;
    }
    else {
      uint64_t v38 = v37;
    }
    unint64_t v39 = *v38;
    unsigned int v40 = v38[1];
    unsigned int v41 = v38[2];
    unsigned int v42 = v38[3];
    unsigned int v43 = v38[4];
    if (v8)
    {
      int32x2_t v44 = vdup_n_s32(v39);
      int32x2_t v45 = vdup_n_s32(v40);
      int v46 = a4 + 4;
      int32x2_t v47 = vdup_n_s32(v41);
      int32x2_t v48 = vdup_n_s32(v42);
      int32x2_t v49 = vdup_n_s32(v43);
      do
      {
        v4.i8[0] = *(unsigned char *)(v25 + v27);
        v4.i8[4] = *(unsigned char *)(v25 + v26);
        int32x2_t v50 = (int32x2_t)vand_s8(*(int8x8_t *)v4.i8, (int8x8_t)0xFF000000FFLL);
        uint32x2_t v51 = (uint32x2_t)vadd_s32(v44, v50);
        int8x8_t v52 = (int8x8_t)vadd_s32(v45, v50);
        int32x2_t v53 = vadd_s32(v47, v50);
        int32x2_t v54 = vshl_n_s32(vadd_s32(v48, v50), 0x10uLL);
        v55.i64[0] = v54.i32[0] & 0xFF00FFFF;
        v55.i64[1] = v54.i32[1] & 0xFF00FFFF;
        int8x16_t v56 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v49, v50), (int8x8_t)0xFF000000FF00), 0x18uLL), v55);
        int8x8_t v57 = vand_s8((int8x8_t)vshl_n_s32(v53, 8uLL), (int8x8_t)0xFF000000FF0000);
        v55.i64[0] = v57.u32[0];
        v55.i64[1] = v57.u32[1];
        int8x16_t v58 = v55;
        int8x8_t v59 = vand_s8(v52, (int8x8_t)0xFF000000FF00);
        v55.i64[0] = v59.u32[0];
        v55.i64[1] = v59.u32[1];
        int8x16_t v60 = vorrq_s8(v56, vorrq_s8(v58, v55));
        uint32x2_t v61 = vshr_n_u32(v51, 8uLL);
        v55.i64[0] = v61.i32[0] & 0xFFFFFEFF;
        v55.i64[1] = v61.i32[1] & 0xFFFFFEFF;
        int8x16_t v62 = vorrq_s8(v60, v55);
        *long long v21 = v62;
        uint64_t v26 = (v26 + 1) & v28;
        v62.i8[0] = *(unsigned char *)(v25 + ((v27 + 1) & v28));
        v62.i8[4] = *(unsigned char *)(v25 + v26);
        *(int8x8_t *)v62.i8 = vand_s8(*(int8x8_t *)v62.i8, (int8x8_t)0xFF000000FFLL);
        uint32x2_t v63 = (uint32x2_t)vadd_s32(v44, *(int32x2_t *)v62.i8);
        int8x8_t v64 = (int8x8_t)vadd_s32(v45, *(int32x2_t *)v62.i8);
        *(int32x2_t *)v58.i8 = vadd_s32(v47, *(int32x2_t *)v62.i8);
        int32x2_t v65 = vshl_n_s32(vadd_s32(v48, *(int32x2_t *)v62.i8), 0x10uLL);
        v55.i64[0] = v65.i32[0] & 0xFF00FFFF;
        v55.i64[1] = v65.i32[1] & 0xFF00FFFF;
        int8x16_t v66 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v49, *(int32x2_t *)v62.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v55);
        *(int8x8_t *)v58.i8 = vand_s8((int8x8_t)vshl_n_s32(*(int32x2_t *)v58.i8, 8uLL), (int8x8_t)0xFF000000FF0000);
        v55.i64[0] = v58.u32[0];
        v55.i64[1] = v58.u32[1];
        int8x16_t v67 = v55;
        int8x8_t v68 = vand_s8(v64, (int8x8_t)0xFF000000FF00);
        v55.i64[0] = v68.u32[0];
        v55.i64[1] = v68.u32[1];
        int8x16_t v69 = vorrq_s8(v66, vorrq_s8(v67, v55));
        uint32x2_t v70 = vshr_n_u32(v63, 8uLL);
        v55.i64[0] = v70.i32[0] & 0xFFFFFEFF;
        v55.i64[1] = v70.i32[1] & 0xFFFFFEFF;
        *v20++ = -1;
        v46 -= 4;
        int8x16_t v4 = vorrq_s8(v69, v55);
        v21[1] = v4;
        v21 += 2;
        unsigned int v27 = (v27 + 1) & v28;
      }
      while (v46 > 4);
    }
    else
    {
      unint64_t v71 = (v42 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v43 & 0xFF00) >> 8) << 32) | ((unint64_t)BYTE1(v41) << 16) | (unsigned __int16)v40 & 0xFF00 | (v39 >> 8);
      int v72 = a4 + 4;
      do
      {
        v21->i64[0] = v71;
        v21->i64[1] = v71;
        v21[1].i64[0] = v71;
        v21[1].i64[1] = v71;
        v72 -= 4;
        v21 += 2;
        *v20++ = -1;
      }
      while (v72 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v29 = 4;
    }
    else {
      int v29 = a4;
    }
    bzero(v20, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

unint64_t CMYK32_shade_custom_CMYK(unint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(result + 280);
  float v5 = *(float *)(*(void *)(result + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  unint64_t v9 = result + 368;
  uint64_t v10 = *(void *)(result + 368);
  int v11 = 15;
  if (v10) {
    unint64_t v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(result + 284);
  float v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  float v14 = *(float *)(result + 304);
  float v15 = *(float *)(result + 308);
  float v16 = *(float *)(result + 312);
  float v17 = *(float *)(result + 316);
  float v18 = *(float *)(result + 336);
  float v19 = *(float *)(result + 348);
  float v20 = *(float *)(result + 344);
  float v21 = *(float *)(result + 356);
  uint64_t v22 = *(_WORD **)(result + 376);
  uint64_t v23 = *(void *)(result + 360);
  int v24 = 5 * *(_DWORD *)(result + 48);
  if (v10) {
    uint64_t v25 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v25 = 0;
  }
  unsigned int v27 = *(char **)(result + 144);
  uint64_t v26 = *(unint64_t **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      uint64_t v33 = v23 + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19)) + 10 * (int)(float)(v20 * (float)(v8 - v18));
      unsigned int v31 = *(unsigned __int8 *)(v9 + v25);
      __int16 v32 = v31 + *(_WORD *)v33;
      goto LABEL_21;
    }
    if (v22)
    {
      unsigned int v31 = *(unsigned __int8 *)(v9 + v25);
      __int16 v32 = v31 + *v22;
      uint64_t v33 = (uint64_t)v22;
LABEL_21:
      uint32x4_t v34 = vaddw_u16((uint32x4_t)vdupq_n_s32(v31), *(uint16x4_t *)(v33 + 2));
      unint64_t result = (v34.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v34.i16[6] & 0xFF00) >> 8) << 32);
      *uint64_t v26 = result | (v34.i32[1] << 8) & 0xFF0000 | (unint64_t)(v34.i16[0] & 0xFF00) | HIBYTE(v32);
      char v35 = -1;
      goto LABEL_22;
    }
    char v35 = 0;
LABEL_22:
    uint64_t v25 = (v25 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    ++v26;
    *v27++ = v35;
    --a4;
  }
  while (a4);
  return result;
}

uint64_t CMYK32_shade_conic_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = *(void *)(a1 + 368);
  if (v9) {
    uint64_t v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v10 = a1 + 368;
  }
  if (v9) {
    int v11 = 15;
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(a1 + 284);
  float v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  float v41 = *(float *)(a1 + 336);
  float v42 = *(float *)(a1 + 304);
  float v15 = *(float *)(a1 + 344);
  uint64_t v16 = *(void *)(a1 + 360);
  float v18 = *(unsigned char **)(a1 + 144);
  float v17 = *(unint64_t **)(a1 + 152);
  if (v9) {
    uint64_t v19 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v19 = 0;
  }
  float v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    float v21 = v15 * (float)((float)(v42 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v41);
    unsigned int v22 = vcvtms_s32_f32(v21);
    float v23 = ceilf(v21);
    float v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    unsigned int v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0) {
      unsigned int v22 = v25;
    }
    float v26 = ceilf(v21 - v15);
    if (v21 <= v15) {
      float v27 = v23;
    }
    else {
      float v27 = v26;
    }
    int v28 = (unsigned __int16 *)(v16 + 2 * (int)(5 * v22));
    int v29 = *v28;
    int v30 = v28[1];
    int v31 = v28[2];
    int v32 = v28[3];
    uint64_t v33 = (unsigned __int16 *)(v16 + 10 * (int)v27);
    int v34 = 255 - (int)v24;
    int v35 = v33[1];
    uint64_t result = v33[2];
    int v37 = v33[3];
    LODWORD(v28) = v33[4] * (int)v24 + v34 * v28[4];
    LODWORD(v33) = (int)v24 * *v33 + v34 * v29;
    unsigned int v38 = (int)v24 * v35 + v34 * v30;
    int v39 = (int)v24 * result + v34 * v31;
    int v40 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = ((v40 + ((v37 * (int)v24 + v34 * v32) >> 8)) << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v40 + (v28 >> 8)) & 0xFF00) >> 8) << 32) | (v39 + (v40 << 8)) & 0xFF0000 | (unint64_t)((unsigned __int16)(v40 + (v38 >> 8)) & 0xFF00) | ((unsigned __int16)(v40 + (v33 >> 8)) >> 8);
    uint64_t v19 = (v19 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
  return result;
}

void CMYK32_shade_radial_CMYK(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  float v6 = *(float *)(a1 + 280);
  float v7 = *(float *)(a1 + 284);
  float v8 = *(float *)(*(void *)(a1 + 272) + 4);
  float v9 = v8 * (float)a2;
  float v10 = v8 * (float)(uint64_t)a3;
  float v11 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v10) + (float)(v6 * v9));
  float v12 = *(float *)(a1 + 300) + (float)((float)(v10 * *(float *)(a1 + 292)) + (float)(v7 * v9));
  uint64_t v14 = *(void *)(a1 + 400);
  float v15 = *(float *)(a1 + 336);
  float v16 = *(float *)(a1 + 344);
  float v17 = *(float *)(a1 + 304);
  float v18 = *(float *)(a1 + 308);
  int v19 = *(_DWORD *)(a1 + 324);
  float v20 = *(float *)(v14 + 8);
  float v21 = *(float *)(v14 + 16);
  v5.i32[0] = *(_DWORD *)(v14 + 20);
  float v22 = *(float *)(v14 + 28);
  uint64_t v25 = a1 + 144;
  float v23 = *(char **)(a1 + 144);
  float v24 = *(int8x16_t **)(v25 + 8);
  float v26 = *(_WORD **)(a1 + 376);
  uint64_t v27 = *(void *)(a1 + 360);
  uint64_t v28 = ((unint64_t)a2 >> 8) & 0xF;
  if (v20 != 0.0 || v22 != 0.0 || v7 != 0.0)
  {
    int v38 = *(_DWORD *)(a1 + 320);
    float v39 = *(float *)(v14 + 12);
    float v40 = *(float *)(v14 + 24);
    float v41 = *(float *)(v14 + 32);
    uint64_t v42 = a1 + 368;
    uint64_t v43 = *(void *)(a1 + 368);
    uint64_t v44 = v43 + ((a3 >> 4) & 0xF0);
    BOOL v31 = v43 == 0;
    int v45 = 15;
    if (v31)
    {
      int v45 = 0;
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v42 = v44;
    }
    float v46 = -v40;
    float v47 = v18 - v17;
    while (1)
    {
      float v48 = v46 + (float)((float)(v11 + v11) * v20);
      float v49 = (float)((float)(v12 * v12) + (float)(v11 * v11)) - v22;
      if (*(float *)v5.i32 == 0.0)
      {
        float v56 = v49 / v48;
      }
      else
      {
        float v50 = (float)((float)(*(float *)v5.i32 * -4.0) * v49) + (float)(v48 * v48);
        if (v50 < 0.0) {
          goto LABEL_56;
        }
        float v51 = sqrtf(v50);
        float v52 = v41 * (float)(v48 - v51);
        float v53 = v48 + v51;
        float v54 = v41 * v53;
        BOOL v55 = (float)(v41 * v53) <= v52;
        if ((float)(v41 * v53) <= v52) {
          float v56 = v41 * v53;
        }
        else {
          float v56 = v52;
        }
        if (v55) {
          float v54 = v52;
        }
        if (v54 < 0.0)
        {
          BOOL v57 = v54 < v39;
LABEL_42:
          int v58 = v38;
          if (v57) {
            goto LABEL_56;
          }
LABEL_43:
          if ((v58 & 0x80000000) == 0) {
            goto LABEL_55;
          }
          goto LABEL_56;
        }
        if (v54 <= 1.0)
        {
          float v59 = v17 + (float)(v54 * v47);
          goto LABEL_54;
        }
        if ((v19 & 0x80000000) == 0)
        {
          int v58 = v19;
          if (v54 <= v21)
          {
LABEL_55:
            int8x16_t v60 = (_WORD *)(v27 + 10 * v58);
            unsigned int v61 = *(unsigned __int8 *)(v42 + v28);
            __int16 v62 = v61 + *v60;
            goto LABEL_58;
          }
        }
      }
      if (v56 < 0.0)
      {
        BOOL v57 = v56 < v39;
        goto LABEL_42;
      }
      if (v56 > 1.0)
      {
        int v58 = v19;
        if (v56 > v21) {
          goto LABEL_56;
        }
        goto LABEL_43;
      }
      float v59 = v17 + (float)(v56 * v47);
LABEL_54:
      int v58 = (int)(float)(v16 * (float)(v59 - v15));
      if ((v58 & 0x80000000) == 0) {
        goto LABEL_55;
      }
LABEL_56:
      if (!v26)
      {
        char v64 = 0;
        goto LABEL_60;
      }
      unsigned int v61 = *(unsigned __int8 *)(v42 + v28);
      __int16 v62 = v61 + *v26;
      int8x16_t v60 = v26;
LABEL_58:
      uint32x4_t v63 = vaddw_u16((uint32x4_t)vdupq_n_s32(v61), *(uint16x4_t *)(v60 + 1));
      v24->i64[0] = (v63.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v63.i16[6] & 0xFF00) >> 8) << 32) | (v63.i32[1] << 8) & 0xFF0000 | (unint64_t)(v63.i16[0] & 0xFF00) | HIBYTE(v62);
      char v64 = -1;
LABEL_60:
      uint64_t v28 = (v28 + 1) & v45;
      float v11 = v6 + v11;
      float v12 = v7 + v12;
      float v24 = (int8x16_t *)((char *)v24 + 8);
      *v23++ = v64;
      if (!--a4) {
        return;
      }
    }
  }
  uint64_t v29 = a1 + 368;
  uint64_t v30 = *(void *)(a1 + 368);
  BOOL v31 = v30 == 0;
  if (v30) {
    uint64_t v32 = v30 + ((a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v32 = v29;
  }
  if (v31) {
    LODWORD(a2) = 0;
  }
  else {
    LODWORD(a2) = (BYTE1(a2) + 1) & 0xF;
  }
  if (v31) {
    int v33 = 0;
  }
  else {
    int v33 = v28;
  }
  if (v31) {
    int v34 = 0;
  }
  else {
    int v34 = 15;
  }
  float v35 = v12 * v12;
  float v36 = -*(float *)v5.i32;
  if (v35 <= (float)-*(float *)v5.i32)
  {
    float v65 = fabsf(*(float *)(v14 + 32));
    float v66 = *(float *)v5.i32 * -4.0;
    float v67 = v18 - v17;
    int8x8_t v68 = (unsigned __int16 *)(v27 + 10 * v19);
    int v69 = a4 + 2;
    while (1)
    {
      float v70 = v35 + (float)(v11 * v11);
      float v71 = v6 + v11;
      float v72 = v35 + (float)(v71 * v71);
      if (v70 > v36 && v72 > v36)
      {
        if (v19 < 0)
        {
          if (!v26)
          {
            char v113 = 0;
            char v112 = 0;
            goto LABEL_84;
          }
          unsigned __int16 v81 = *v26;
          unsigned __int16 v82 = v26[1];
          int v83 = (unsigned __int16)v26[2];
          int v84 = (unsigned __int16)v26[3];
          unsigned __int16 v85 = v26[4];
        }
        else
        {
          unsigned __int16 v81 = *v68;
          unsigned __int16 v82 = v68[1];
          int v83 = v68[2];
          int v84 = v68[3];
          unsigned __int16 v85 = v68[4];
        }
        int v105 = *(unsigned __int8 *)(v32 + v33);
        __int16 v106 = v105 + v81;
        unsigned __int16 v107 = v105 + v82;
        int v108 = v105 + v83;
        int v109 = v105 + v84;
        __int16 v110 = v105 + v85;
        int v111 = *(unsigned __int8 *)(v32 + a2);
        __int16 v98 = v111 + v81;
        unsigned __int16 v99 = v111 + v82;
        int v100 = v111 + v83;
        int v101 = v111 + v84;
        __int16 v102 = v111 + v85;
        unint64_t v103 = (v109 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v110 & 0xFF00) >> 8) << 32) | (v108 << 8) & 0xFF0000 | (unint64_t)(v107 & 0xFF00);
        uint64_t v104 = HIBYTE(v106);
        goto LABEL_82;
      }
      float v74 = sqrtf(v66 * v72);
      float v75 = v65 * sqrtf(v66 * v70);
      float v76 = v65 * v74;
      int v77 = (int)(float)(v16 * (float)((float)(v17 + (float)(v75 * v67)) - v15));
      int v78 = (int)(float)(v16 * (float)((float)(v17 + (float)((float)(v65 * v74) * v67)) - v15));
      if (v75 <= 1.0 && v76 <= 1.0)
      {
        uint64_t v86 = (_WORD *)(v27 + 10 * v77);
        int v87 = (__int16 *)(v27 + 10 * v78);
        __int16 v88 = *v87;
        __int16 v89 = v87[1];
        int v90 = (unsigned __int16)v87[2];
        int v91 = (unsigned __int16)v87[3];
        __int16 v92 = v87[4];
        LODWORD(v87) = *(unsigned __int8 *)(v32 + v33);
        __int16 v93 = (_WORD)v87 + *v86;
        unsigned __int16 v94 = (_WORD)v87 + v86[1];
        int v95 = v87 + (unsigned __int16)v86[2];
        int v96 = v87 + (unsigned __int16)v86[3];
        LOWORD(v86) = (_WORD)v87 + v86[4];
        int v97 = *(unsigned __int8 *)(v32 + a2);
        __int16 v98 = v97 + v88;
        unsigned __int16 v99 = v97 + v89;
        int v100 = v97 + v90;
        int v101 = v97 + v91;
        __int16 v102 = v97 + v92;
        unint64_t v103 = (v96 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((unsigned __int16)v86 & 0xFF00) >> 8) << 32) | (v95 << 8) & 0xFF0000 | (unint64_t)(v94 & 0xFF00);
        uint64_t v104 = HIBYTE(v93);
LABEL_82:
        v24->i64[0] = v103 | v104;
        char v112 = -1;
        goto LABEL_83;
      }
      if (v75 <= 1.0)
      {
        if ((v77 & 0x80000000) == 0)
        {
          uint64_t v80 = 5 * v77;
LABEL_88:
          uint64_t v114 = (_WORD *)(v27 + 2 * v80);
          __int16 v116 = *v114;
          uint64_t v115 = (uint16x4_t *)(v114 + 1);
          unsigned int v117 = *(unsigned __int8 *)(v32 + v33);
          __int16 v118 = v117 + v116;
          goto LABEL_91;
        }
      }
      else if (v75 <= v21)
      {
        uint64_t v80 = 5 * v19;
        if ((v19 & 0x80000000) == 0) {
          goto LABEL_88;
        }
      }
      if (!v26)
      {
        char v112 = 0;
        goto LABEL_92;
      }
      unsigned int v117 = *(unsigned __int8 *)(v32 + v33);
      __int16 v118 = v117 + *v26;
      uint64_t v115 = (uint16x4_t *)(v26 + 1);
LABEL_91:
      uint32x4_t v119 = vaddw_u16((uint32x4_t)vdupq_n_s32(v117), *v115);
      v24->i64[0] = (v119.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v119.i16[6] & 0xFF00) >> 8) << 32) | (v119.i32[1] << 8) & 0xFF0000 | (unint64_t)(v119.i16[0] & 0xFF00) | HIBYTE(v118);
      char v112 = -1;
LABEL_92:
      if (v76 <= 1.0)
      {
        if (v78 < 0) {
          goto LABEL_99;
        }
        uint64_t v120 = 5 * v78;
      }
      else if (v76 > v21 || (uint64_t v120 = 5 * v19, v19 < 0))
      {
LABEL_99:
        if (!v26)
        {
          char v113 = 0;
          goto LABEL_84;
        }
        int v126 = *(unsigned __int8 *)(v32 + a2);
        __int16 v98 = v126 + *v26;
        unsigned __int16 v99 = v126 + v26[1];
        int v100 = v126 + (unsigned __int16)v26[2];
        int v101 = v126 + (unsigned __int16)v26[3];
        __int16 v102 = v126 + v26[4];
        goto LABEL_83;
      }
      unsigned int v121 = (_WORD *)(v27 + 2 * v120);
      int v122 = (unsigned __int16)v121[2];
      int v123 = (unsigned __int16)v121[3];
      int v124 = *(unsigned __int8 *)(v32 + a2);
      __int16 v98 = v124 + *v121;
      __int16 v125 = v121[4];
      unsigned __int16 v99 = v124 + v121[1];
      int v100 = v124 + v122;
      int v101 = v124 + v123;
      __int16 v102 = v124 + v125;
LABEL_83:
      v24->i64[1] = (v101 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v102 & 0xFF00) >> 8) << 32) | (v100 << 8) & 0xFF0000 | (unint64_t)(v99 & 0xFF00) | HIBYTE(v98);
      char v113 = -1;
LABEL_84:
      float v11 = v6 + v71;
      LOBYTE(v33) = (v33 + 1) & v34;
      LOBYTE(a2) = (a2 + 1) & v34;
      ++v24;
      *float v23 = v112;
      v23[1] = v113;
      v23 += 2;
      v69 -= 2;
      if (v69 <= 2) {
        return;
      }
    }
  }
  if (v26 || (v19 & 0x80000000) == 0)
  {
    unint64_t v127 = (unsigned __int16 *)(v27 + 10 * v19);
    if (v19 >= 0) {
      uint64_t v128 = v127;
    }
    else {
      uint64_t v128 = v26;
    }
    int32x2_t v129 = vdup_n_s32(v128[4]);
    int32x2_t v130 = vdup_n_s32(v128[3]);
    int32x2_t v131 = vdup_n_s32(v128[2]);
    int32x2_t v132 = vdup_n_s32(v128[1]);
    int32x2_t v133 = vdup_n_s32(*v128);
    int v134 = a4 + 4;
    do
    {
      v5.i8[0] = *(unsigned char *)(v32 + v33);
      v5.i8[4] = *(unsigned char *)(v32 + a2);
      int32x2_t v135 = (int32x2_t)vand_s8(*(int8x8_t *)v5.i8, (int8x8_t)0xFF000000FFLL);
      uint32x2_t v136 = (uint32x2_t)vadd_s32(v133, v135);
      int8x8_t v137 = (int8x8_t)vadd_s32(v132, v135);
      int32x2_t v138 = vadd_s32(v131, v135);
      int32x2_t v139 = vshl_n_s32(vadd_s32(v130, v135), 0x10uLL);
      v140.i64[0] = v139.i32[0] & 0xFF00FFFF;
      v140.i64[1] = v139.i32[1] & 0xFF00FFFF;
      int8x16_t v141 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v129, v135), (int8x8_t)0xFF000000FF00), 0x18uLL), v140);
      int8x8_t v142 = vand_s8((int8x8_t)vshl_n_s32(v138, 8uLL), (int8x8_t)0xFF000000FF0000);
      v140.i64[0] = v142.u32[0];
      v140.i64[1] = v142.u32[1];
      int8x16_t v143 = v140;
      int8x8_t v144 = vand_s8(v137, (int8x8_t)0xFF000000FF00);
      v140.i64[0] = v144.u32[0];
      v140.i64[1] = v144.u32[1];
      int8x16_t v145 = vorrq_s8(v141, vorrq_s8(v143, v140));
      uint32x2_t v146 = vshr_n_u32(v136, 8uLL);
      v140.i64[0] = v146.i32[0] & 0xFFFFFEFF;
      v140.i64[1] = v146.i32[1] & 0xFFFFFEFF;
      int8x16_t v147 = vorrq_s8(v145, v140);
      *float v24 = v147;
      a2 = (a2 + 1) & v34;
      v147.i8[0] = *(unsigned char *)(v32 + ((v33 + 1) & v34));
      v147.i8[4] = *(unsigned char *)(v32 + a2);
      *(int8x8_t *)v147.i8 = vand_s8(*(int8x8_t *)v147.i8, (int8x8_t)0xFF000000FFLL);
      uint32x2_t v148 = (uint32x2_t)vadd_s32(v133, *(int32x2_t *)v147.i8);
      int8x8_t v149 = (int8x8_t)vadd_s32(v132, *(int32x2_t *)v147.i8);
      *(int32x2_t *)v143.i8 = vadd_s32(v131, *(int32x2_t *)v147.i8);
      int32x2_t v150 = vshl_n_s32(vadd_s32(v130, *(int32x2_t *)v147.i8), 0x10uLL);
      v140.i64[0] = v150.i32[0] & 0xFF00FFFF;
      v140.i64[1] = v150.i32[1] & 0xFF00FFFF;
      int8x16_t v151 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v129, *(int32x2_t *)v147.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v140);
      *(int8x8_t *)v143.i8 = vand_s8((int8x8_t)vshl_n_s32(*(int32x2_t *)v143.i8, 8uLL), (int8x8_t)0xFF000000FF0000);
      v140.i64[0] = v143.u32[0];
      v140.i64[1] = v143.u32[1];
      int8x16_t v152 = v140;
      int8x8_t v153 = vand_s8(v149, (int8x8_t)0xFF000000FF00);
      v140.i64[0] = v153.u32[0];
      v140.i64[1] = v153.u32[1];
      int8x16_t v154 = vorrq_s8(v151, vorrq_s8(v152, v140));
      uint32x2_t v155 = vshr_n_u32(v148, 8uLL);
      v140.i64[0] = v155.i32[0] & 0xFFFFFEFF;
      v140.i64[1] = v155.i32[1] & 0xFFFFFEFF;
      *(_DWORD *)float v23 = -1;
      v23 += 4;
      v134 -= 4;
      int8x16_t v5 = vorrq_s8(v154, v140);
      v24[1] = v5;
      v24 += 2;
      int v33 = (v33 + 1) & v34;
    }
    while (v134 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v37 = 4;
    }
    else {
      int v37 = a4;
    }
    bzero(v23, ((a4 - v37 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t CMYK32_image(int **a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  float v6 = *a1;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  memset(v42, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v25, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  BOOL v19 = *v6 != 134759428 || v8 <= 23;
  unsigned int v20 = *(_DWORD *)a3;
  if (v19) {
    int v21 = v8;
  }
  else {
    int v21 = v8 + 4;
  }
  DWORD2(v25) = *(_DWORD *)a3;
  HIDWORD(v25) = v18;
  if (v20 != 134759428)
  {
    int v22 = SAMPLEINDEX(v20, v10, v11, v12, v13, v14, v15, v16);
    if (v22)
    {
      *(void *)&long long v25 = *(void *)&CMYK8_image_sample[2 * v22 + 2];
      if ((void)v25)
      {
        DWORD2(v25) = 134759444;
        goto LABEL_31;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 0x10)
      {
        *(void *)&long long v25 = *(void *)&CMYK16_image_sample[2 * v22 + 2];
        if ((void)v25)
        {
          int v23 = 16;
          int v24 = 269501476;
LABEL_30:
          LODWORD(v26) = v23;
          DWORD2(v25) = v24;
          goto LABEL_31;
        }
      }
      *(void *)&long long v25 = *(void *)&CMYKF_image_sample[2 * v22 + 2];
      if ((void)v25)
      {
        int v23 = 20;
        int v24 = 538985509;
        goto LABEL_30;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(void)v36 && (~DWORD1(v26) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((BYTE4(v26) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      cmyk32_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(void *)&long long v25 = cmyk32_sample_cmyk32;
LABEL_31:
  cmyk32_image_mark((uint64_t)a2, (uint64_t)&v25, v21, v17);
  return 1;
}

_DWORD *CMYK32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11 = PIXELCONSTANT(*(float **)(*(void *)a1 + 64), a4, a5, a6, a7, a8, a9);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDBC0;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    a2[12] = bswap32(v11);
    *((void *)a2 + 4) = a2 + 12;
    if (BYTE4(v11) == 255)
    {
      *((void *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = 16843009 * BYTE4(v11);
      *((void *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

void __MapContextToPage_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (CGPDFAnnotationGetType(a3) == 25 || CGPDFAnnotationGetType(a3) == 4)
  {
    int8x16_t v5 = [[CPAnnotation alloc] initWithCGPDFAnnotation:a3];
    if (v5)
    {
      float v6 = v5;
      [*(id *)(a1 + 32) addAnnotation:v5];
    }
  }
}

uint64_t ReconstructZone(void *a1)
{
  int v2 = [a1 count];
  if (v2 >= 1)
  {
    int v3 = v2;
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = [a1 childAtIndex:v4];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        ReconstructZone(v5);
      }
      uint64_t v4 = (v4 + 1);
    }
    while (v3 != v4);
  }
  float v6 = (void *)[a1 textLinesInZone];
  unsigned int v7 = [v6 count];
  if (v7)
  {
    +[CPTextLineSplitter splitLinesIn:a1];
    if ([v6 count] > v7) {
      [a1 sortUsingSelector:sel_compareTopDescending_];
    }
    int v8 = objc_alloc_init(CPParagraphMaker);
    [(CPParagraphMaker *)v8 makeParagraphsIn:a1];
    float v9 = objc_alloc_init(CPColumnMaker);
    objc_msgSend((id)objc_msgSend(a1, "page"), "pageCropBox");
    -[CPColumnMaker setPageBounds:](v9, "setPageBounds:");
    [(CPColumnMaker *)v9 makeColumnsFrom:[(CPParagraphMaker *)v8 paragraphs] zone:a1];
    uint64_t v10 = objc_alloc_init(CPLayoutMaker);
    [(CPLayoutMaker *)v10 makeLayouts:a1 from:[(CPColumnMaker *)v9 columns]];
  }

  return [a1 sortUsingSelector:sel_compareTopDescending_];
}

__n128 CGPDFTextObjectMoveToNextLine(uint64_t a1, double a2, double a3)
{
  double v3 = *(double *)(a1 + 72);
  double v4 = *(double *)(a1 + 80);
  double v5 = *(double *)(a1 + 88);
  double v6 = *(double *)(a1 + 96);
  double v7 = *(double *)(a1 + 112);
  double v8 = v3 + v5 * 0.0;
  double v9 = v5 + v3 * 0.0;
  double v10 = *(double *)(a1 + 104) + v5 * a3 + a2 * v3;
  *(double *)(a1 + 72) = v8;
  *(double *)(a1 + 80) = v4 + v6 * 0.0;
  *(double *)(a1 + 88) = v9;
  *(double *)(a1 + 96) = v6 + v4 * 0.0;
  *(double *)(a1 + 104) = v10;
  *(double *)(a1 + 112) = v6 * a3 + a2 * v4 + v7;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a1 + 88);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a1 + 72);
  __n128 result = *(__n128 *)(a1 + 104);
  *(__n128 *)(a1 + 152) = result;
  return result;
}

void CGPDFTextObjectSetFont(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 48);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 48) = cf;
  }
}

uint64_t CGPDFTextObjectSetTextDrawingMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 40) = a2;
  if ((a2 & 0xFFFFFFFC) == 4)
  {
    uint64_t v2 = result;
    if (!*(void *)(result + 176))
    {
      CFTypeRef v3 = malloc_type_malloc(8uLL, 0x566C45D1uLL);
      __n128 result = __CFSetLastAllocationEventName();
      *CFTypeRef v3 = 0;
      *(void *)(v2 + 176) = v3;
    }
  }
  return result;
}

double CGPDFTextObjectAppendString(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      if (*(void *)(a1 + 48))
      {
        double result = *(double *)(a1 + 56);
        if (result != 0.0)
        {
          double v5 = *(uint64_t **)(a1 + 168);
          if (!v5)
          {
            double v5 = (uint64_t *)malloc_type_malloc(8uLL, 0x566C45D1uLL);
            __CFSetLastAllocationEventName();
            *double v5 = 0;
            *(void *)(a1 + 168) = v5;
          }
          long long v7 = 0uLL;
          CGPDFTextLayoutAppendString(v5, a1, a2, (double *)&v7);
          double v6 = *(uint64_t **)(a1 + 176);
          if (v6) {
            CGPDFTextLayoutAppendString(v6, a1, a2, 0);
          }
          double result = *(double *)&v7;
          *(float64x2_t *)(a1 + 152) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 152), *(float64x2_t *)(a1 + 120), *(double *)&v7), *(float64x2_t *)(a1 + 136), *((double *)&v7 + 1));
        }
      }
    }
  }
  return result;
}

double CGPDFTextObjectAppendStrings(uint64_t a1, CGPDFArray *a2)
{
  if (a1)
  {
    if (a2)
    {
      if (*(void *)(a1 + 48))
      {
        double result = *(double *)(a1 + 56);
        if (result != 0.0)
        {
          double v5 = *(uint64_t **)(a1 + 168);
          if (!v5)
          {
            double v5 = (uint64_t *)malloc_type_malloc(8uLL, 0x566C45D1uLL);
            __CFSetLastAllocationEventName();
            *double v5 = 0;
            *(void *)(a1 + 168) = v5;
          }
          long long v7 = 0uLL;
          CGPDFTextLayoutAppendStrings(v5, a1, a2, (double *)&v7);
          double v6 = *(uint64_t **)(a1 + 176);
          if (v6) {
            CGPDFTextLayoutAppendStrings(v6, a1, a2, 0);
          }
          double result = *(double *)&v7;
          *(float64x2_t *)(a1 + 152) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 152), *(float64x2_t *)(a1 + 120), *(double *)&v7), *(float64x2_t *)(a1 + 136), *((double *)&v7 + 1));
        }
      }
    }
  }
  return result;
}

void PDFDocumentRelease(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return;
  }
  if ((*(_DWORD *)a1)-- != 1) {
    return;
  }
  PDFDocumentFinalize(a1, a2, a3, a4, a5, a6, a7, a8);
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 432));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 440));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 448));
  uint64_t v10 = *(void *)(a1 + 328);
  if (v10)
  {
    CFRelease(*(CFTypeRef *)(v10 + 8));
    CGOrderedSetRelease(*(const void ***)(v10 + 16));
    free((void *)v10);
  }
  unint64_t v11 = *(void **)(a1 + 416);
  if (v11)
  {
    uint64_t v12 = (const void *)v11[1];
    if (v12) {
      CFRelease(v12);
    }
    free(v11);
  }
  uint64_t v13 = *(void *)(a1 + 400);
  if (v13)
  {
    uint64_t v14 = *(const void **)(v13 + 8);
    if (v14) {
      CFRelease(v14);
    }
    CGOrderedSetRelease(*(const void ***)(v13 + 16));
    free((void *)v13);
  }
  uint64_t v15 = *(void *)(a1 + 336);
  if (v15)
  {
    std::__tree<unsigned long>::destroy(*(void **)(v15 + 64));
    std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(*(void **)(v15 + 40));
    std::__tree<std::__value_type<std::string,CGDisplayListEntryType>,std::__map_value_compare<std::string,std::__value_type<std::string,CGDisplayListEntryType>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CGDisplayListEntryType>>>::destroy(*(char **)(v15 + 16));
    MEMORY[0x18532A2A0](v15, 0x1020C40E45BEF79);
  }
  uint64_t v16 = *(void *)(a1 + 368);
  if (v16)
  {
    CGOrderedSetRelease(*(const void ***)(v16 + 16));
    __n128 v17 = *(const void **)(v16 + 8);
    if (v17) {
      CFRelease(v17);
    }
    free((void *)v16);
  }
  PDFImageSetRelease(*(void *)(a1 + 344));
  PDFImageSetRelease(*(void *)(a1 + 352));
  uint64_t v18 = *(void *)(a1 + 376);
  if (v18)
  {
    BOOL v19 = *(const void **)(v18 + 8);
    if (v19) {
      CFRelease(v19);
    }
    CGOrderedSetRelease(*(const void ***)(v18 + 16));
    free((void *)v18);
  }
  uint64_t v20 = *(void *)(a1 + 408);
  if (v20)
  {
    int v21 = *(const void **)(v20 + 8);
    if (v21) {
      CFRelease(v21);
    }
    CGOrderedSetRelease(*(const void ***)(v20 + 16));
    free((void *)v20);
  }
  uint64_t v22 = *(void *)(a1 + 384);
  if (v22)
  {
    int v23 = *(const void **)(v22 + 8);
    if (v23) {
      CFRelease(v23);
    }
    CGOrderedSetRelease(*(const void ***)(v22 + 16));
    free((void *)v22);
  }
  uint64_t v24 = *(void *)(a1 + 392);
  if (v24)
  {
    CGOrderedSetRelease(*(const void ***)(v24 + 16));
    long long v25 = *(const void **)(v24 + 8);
    if (v25) {
      CFRelease(v25);
    }
    free((void *)v24);
  }
  uint64_t v26 = *(void *)(a1 + 360);
  if (v26)
  {
    CGOrderedSetRelease(*(const void ***)(v26 + 16));
    long long v27 = *(const void **)(v26 + 8);
    if (v27) {
      CFRelease(v27);
    }
    free((void *)v26);
  }
  long long v28 = *(const void **)(a1 + 312);
  if (v28) {
    CFRelease(v28);
  }
  PDFMetaSetRelease(*(void **)(a1 + 40));
  uint64_t v29 = *(void *)(a1 + 456);
  if (v29)
  {
    long long v30 = *(const void **)(v29 + 16);
    if (v30) {
      CFRelease(v30);
    }
    uint64_t v31 = *(void *)(v29 + 24);
    if (v31)
    {
      uint32x4_t v63 = *(void ***)(v29 + 24);
      std::vector<std::shared_ptr<PDFPageNode>>::__destroy_vector::operator()[abi:fe180100](&v63);
      MEMORY[0x18532A2A0](v31, 0x20C40960023A9);
    }
    uint32x4_t v63 = (void **)(v29 + 48);
    std::vector<std::pair<std::shared_ptr<PDFPageNode>,unsigned long>>::__destroy_vector::operator()[abi:fe180100](&v63);
    long long v32 = *(std::__shared_weak_count **)(v29 + 40);
    if (v32) {
      std::__shared_weak_count::__release_shared[abi:fe180100](v32);
    }
    MEMORY[0x18532A2A0](v29, 0x1020C40932E6E95);
  }
  PDFXRefTableRelease(*(void *)(a1 + 464));
  PDFOutputIntentRelease(*(void **)(a1 + 48));
  long long v33 = *(void **)(a1 + 56);
  if (v33)
  {
    long long v34 = (const void *)v33[2];
    if (v34) {
      CFRelease(v34);
    }
    free(v33);
  }
  long long v35 = *(void **)(a1 + 64);
  if (v35)
  {
    long long v36 = (const void *)v35[1];
    if (v36) {
      CFRelease(v36);
    }
    long long v37 = (const void *)v35[3];
    if (v37) {
      CFRelease(v37);
    }
    free(v35);
  }
  long long v38 = *(const void **)(a1 + 472);
  if (v38) {
    CFRelease(v38);
  }
  long long v39 = *(const void **)(a1 + 536);
  if (v39) {
    CFRelease(v39);
  }
  long long v40 = *(const void **)(a1 + 488);
  if (v40) {
    CFRelease(v40);
  }
  long long v41 = *(const void **)(a1 + 496);
  if (v41) {
    CFRelease(v41);
  }
  uint64_t v42 = *(const void **)(a1 + 504);
  if (v42) {
    CFRelease(v42);
  }
  uint64_t v43 = *(void *)(a1 + 288);
  if (v43)
  {
    uint64_t v44 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v43);
    MEMORY[0x18532A2A0](v44, 0x10A0C408EF24B1CLL);
  }
  uint64_t v45 = *(void *)(a1 + 296);
  if (v45)
  {
    uint64_t v46 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v45);
    MEMORY[0x18532A2A0](v46, 0x10A0C408EF24B1CLL);
  }
  uint64_t v47 = *(void *)(a1 + 304);
  if (v47)
  {
    uint64_t v48 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v47);
    MEMORY[0x18532A2A0](v48, 0x10A0C408EF24B1CLL);
  }
  CGPDFAssociationRelease(*(const void ***)(a1 + 32));
  float v49 = *(const void **)(a1 + 24);
  if (v49) {
    CFRelease(v49);
  }
  float v50 = *(const void **)(a1 + 528);
  if (v50) {
    CFRelease(v50);
  }
  uint64_t v51 = *(void *)(a1 + 520);
  if (v51)
  {
    PDFXRefTableRelease(*(void *)(v51 + 88));
    PDFXRefTableRelease(*(void *)(v51 + 104));
    float v52 = *(const void **)(v51 + 16);
    if (v52) {
      CFRelease(v52);
    }
    float v53 = *(const void **)(v51 + 320);
    if (v53) {
      CFRelease(v53);
    }
    float v54 = *(const void **)(v51 + 328);
    if (v54) {
      CFRelease(v54);
    }
    BOOL v55 = (void **)(v51 + 24);
    if (*(char *)(v51 + 47) < 0)
    {
      if (!*(void *)(v51 + 32))
      {
LABEL_93:
        std::__tree<unsigned long>::destroy(*(void **)(v51 + 240));
        std::__tree<unsigned long>::destroy(*(void **)(v51 + 216));
        BOOL v57 = *(void **)(v51 + 184);
        if (v57)
        {
          *(void *)(v51 + 192) = v57;
          operator delete(v57);
        }
        int v58 = *(void **)(v51 + 160);
        if (v58)
        {
          *(void *)(v51 + 168) = v58;
          operator delete(v58);
        }
        float v59 = *(void **)(v51 + 136);
        if (v59)
        {
          *(void *)(v51 + 144) = v59;
          operator delete(v59);
        }
        uint32x4_t v63 = (void **)(v51 + 112);
        std::vector<PDFIndirectObject>::__destroy_vector::operator()[abi:fe180100](&v63);
        uint32x4_t v63 = (void **)(v51 + 48);
        std::vector<PDFLinearizerPageInfo>::__destroy_vector::operator()[abi:fe180100](&v63);
        if (*(char *)(v51 + 47) < 0) {
          operator delete(*v55);
        }
        MEMORY[0x18532A2A0](v51, 0x1072C405A727712);
        goto LABEL_102;
      }
      float v56 = (const char *)*v55;
    }
    else
    {
      float v56 = (const char *)(v51 + 24);
      if (!*(unsigned char *)(v51 + 47)) {
        goto LABEL_93;
      }
    }
    unlink(v56);
    goto LABEL_93;
  }
LABEL_102:
  int8x16_t v60 = *(const void **)(a1 + 560);
  if (v60) {
    CFRelease(v60);
  }
  unsigned int v61 = *(const void **)(a1 + 568);
  if (v61) {
    CFRelease(v61);
  }
  __int16 v62 = *(const void **)(a1 + 512);
  if (v62) {
    CFRelease(v62);
  }

  free((void *)a1);
}

PDFDocumentPrivate *get_default_rgb_color_space(PDFDocument *a1)
{
  double result = a1[27]._private;
  if (!result)
  {
    double result = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
    a1[27]._private = result;
    if (!result)
    {
      double result = CGColorSpaceCreateDeviceRGB();
      a1[27]._private = result;
    }
  }
  return result;
}

uint64_t PDFDocumentFinalize(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(result + 72)) {
    return result;
  }
  uint64_t v8 = result;
  v988 = (PDFDocument *)result;
  if (!*(void *)(result + 568)) {
    goto LABEL_55;
  }
  double v9 = (CGPDFArray *)PDFXRefTableAddObject(*(void **)(result + 464));
  uint64_t v10 = PDFXRefTableAddObject(*(void **)(v8 + 464));
  unint64_t v11 = PDFXRefTableAddObject(*(void **)(v8 + 464));
  unint64_t v12 = PDFXRefTableAddObject(*(void **)(v8 + 464));
  PDFDocumentBeginObject(v8, v10, v13, v14, v15, v16, v17, v18);
  PDFWriterPrintf(*(unsigned char ***)(v8 + 32), (uint64_t)"<< /Type /StructTreeRoot /K %R /ParentTree %R /IDTree %R>>", v19, v20, v21, v22, v23, v24, (uint64_t)v9);
  PDFDocumentEndObject(v8, v25, v26, v27, v28, v29, v30, v31);
  *(void *)(v8 + 576) = v10;
  unint64_t v989 = -1;
  CGCFDictionaryGetNumber(*(const __CFDictionary **)(v8 + 568), @"TagNodeObjectRefID", kCFNumberSInt64Type, &v989);
  long long v32 = *(float **)(v8 + 288);
  value[0] = (CGPDFArrayRef)v989;
  value[1] = v9;
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(v32, v989, value);
  PDFDocumentEmitTaggedNodeStructure((PDFDocument *)v8, (unint64_t)v9, *(__CFDictionary **)(v8 + 568), v10);
  value[0] = 0;
  if (CGPDFDictionaryGetArray(*(CGPDFDictionaryRef *)(v8 + 496), "Nums", value))
  {
    PDFDocumentBeginObject(v8, v11, v33, v34, v35, v36, v37, v38);
    PDFWriterPrintf(*(unsigned char ***)(v8 + 32), (uint64_t)"<</Nums[", v39, v40, v41, v42, v43, v44, v943);
    v991[0] = 0;
    array[0] = 0;
    v999[0] = -1;
    if (value[0])
    {
      uint64_t v51 = *((void *)value[0] + 2);
      if (v51)
      {
        for (size_t i = 0; i != v51; ++i)
        {
          if (CGPDFArrayGetArray(value[0], i, array))
          {
            if (array[0])
            {
              uint64_t v53 = *((void *)array[0] + 2);
              if (v53)
              {
                PDFWriterPrintf((unsigned char **)v988[2].super.isa, (uint64_t)"[", v45, v46, v47, v48, v49, v50, v944);
                size_t v54 = 0;
                while (1)
                {
                  CGPDFObjectRef v998 = 0;
                  CGPDFArrayGetObject(array[0], v54, &v998);
                  CGPDFObjectRef v61 = v998;
                  if (v998 && *((_DWORD *)v998 + 2) != 1)
                  {
                    char v64 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>((void *)v988[19].super.isa, v999[0]);
                    if (v64) {
                      uint64_t v65 = v64[3];
                    }
                    else {
                      LODWORD(v65) = -1;
                    }
                    float v66 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>((void *)v988[18]._private, v54 | ((unint64_t)v65 << 32));
                    if (!v66 || (uint64_t v67 = v66[3], v67 == -1))
                    {
                      int8x8_t v68 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>((void *)v988[18].super.isa, *((void *)v61 + 2));
                      if (!v68) {
                        goto LABEL_23;
                      }
                      uint64_t v67 = v68[3];
                      if (v67 == -1) {
                        goto LABEL_23;
                      }
                    }
                    isa = (unsigned char **)v988[2].super.isa;
                    uint64_t v945 = v67;
                    uint32x4_t v63 = "%R";
                  }
                  else
                  {
                    isa = (unsigned char **)v988[2].super.isa;
                    uint32x4_t v63 = "null";
                  }
                  PDFWriterPrintf(isa, (uint64_t)v63, v55, v56, v57, v58, v59, v60, v945);
LABEL_23:
                  if (v53 == ++v54)
                  {
                    int v69 = (unsigned char **)v988[2].super.isa;
                    float v70 = "]";
                    goto LABEL_27;
                  }
                }
              }
            }
          }
          else if (CGPDFArrayGetInteger(value[0], i, v999))
          {
            int v69 = (unsigned char **)v988[2].super.isa;
            uint64_t v945 = v999[0];
            float v70 = "%d";
LABEL_27:
            PDFWriterPrintf(v69, (uint64_t)v70, v55, v56, v57, v58, v59, v60, v945);
          }
          else if (CGPDFArrayGetObject(value[0], i, v991))
          {
            float v71 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>((void *)v988[18].super.isa, *((void *)v991[0] + 2));
            if (v71)
            {
              uint64_t v72 = v71[3];
              if (v72 != -1) {
                PDFWriterPrintf((unsigned char **)v988[2].super.isa, (uint64_t)"%R", v45, v46, v47, v48, v49, v50, v72);
              }
            }
          }
        }
      }
    }
    uint64_t v8 = (uint64_t)v988;
    PDFWriterPrintf((unsigned char **)v988[2].super.isa, (uint64_t)"]>>", v45, v46, v47, v48, v49, v50, v944);
    PDFDocumentEndObject((uint64_t)v988, v73, v74, v75, v76, v77, v78, v79);
  }
  value[0] = 0;
  if (CGPDFDictionaryGetArray(*(CGPDFDictionaryRef *)(v8 + 504), "Names", value))
  {
    PDFDocumentBeginObject(v8, v12, a3, a4, a5, a6, a7, a8);
    PDFWriterPrintf(*(unsigned char ***)(v8 + 32), (uint64_t)"<</Names[", v81, v82, v83, v84, v85, v86, v943);
    v991[0] = 0;
    if (value[0])
    {
      uint64_t v93 = *((void *)value[0] + 2);
      if (v93)
      {
        for (size_t j = 0; j != v93; ++j)
        {
          if (CGPDFArrayGetObject(value[0], j, v991) && v991[0])
          {
            int v95 = *((_DWORD *)v991[0] + 2);
            if (v95 == 8)
            {
              uint64_t v104 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(*(void **)(v8 + 288), *((void *)v991[0] + 2));
              if (v104)
              {
                uint64_t v105 = v104[3];
                if (v105 != -1) {
                  PDFWriterPrintf(*(unsigned char ***)(v8 + 32), (uint64_t)"%R", v87, v88, v89, v90, v91, v92, v105);
                }
              }
            }
            else if (v95 == 6)
            {
              array[0] = 0;
              CGPDFArrayGetString(value[0], j, array);
              CGPDFArrayRef v102 = array[0];
              if (array[0])
              {
                if (*((void *)array[0] + 3)) {
                  decrypt_string((uint64_t)array[0]);
                }
                uint64_t v103 = (uint64_t)v102 + 80;
              }
              else
              {
                uint64_t v103 = 0;
              }
              PDFWriterPrintf(*(unsigned char ***)(v8 + 32), (uint64_t)"(%s)", v96, v97, v98, v99, v100, v101, v103);
            }
          }
        }
      }
    }
    PDFWriterPrintf(*(unsigned char ***)(v8 + 32), (uint64_t)"]>>", v87, v88, v89, v90, v91, v92, v946);
    PDFDocumentEndObject(v8, v106, v107, v108, v109, v110, v111, v112);
  }
  if (*(void *)(v8 + 568))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", v80, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEmitStructureTree");
  }
  else
  {
LABEL_55:
    if (*(void *)(v8 + 600) != *(void *)(v8 + 608))
    {
      uint64_t v119 = PDFXRefTableAddObject(*(void **)(v8 + 464));
      *(void *)(v8 + 576) = v119;
      if (*(uint64_t *)(v8 + 592) < 1) {
        uint64_t v120 = 0;
      }
      else {
        uint64_t v120 = PDFXRefTableAddObject(*(void **)(v8 + 464));
      }
      unsigned int v121 = *(uint64_t **)(v8 + 600);
      int v122 = *(uint64_t **)(v8 + 608);
      while (v121 != v122)
      {
        unint64_t v123 = PDFXRefTableAddObject(*(void **)(v8 + 464));
        uint64_t v124 = *v121++;
        PDFStructureElement::Emit((PDFStructureElement *)(v124 + 16), (PDFDocument *)v8, v119, v123, v125, v126, v127, v128);
      }
      PDFDocumentBeginObject(v8, v119, v113, v114, v115, v116, v117, v118);
      PDFDocumentPrintf(v8, (uint64_t)"<<", v129, v130, v131, v132, v133, v134, v943);
      PDFDocumentPrintf(v8, (uint64_t)"/Type /StructTreeRoot", v135, v136, v137, v138, v139, v140, v947);
      PDFDocumentPrintf(v8, (uint64_t)"/K", v141, v142, v143, v144, v145, v146, v948);
      uint64_t v151 = *(void *)(v8 + 608);
      uint64_t v152 = *(void *)(v8 + 600);
      if (v151 - v152 == 8)
      {
        if (v152 == v151) {
          goto LABEL_412;
        }
        PDFDocumentPrintf(v8, (uint64_t)"%R", v148, v149, v150, a6, a7, a8, *(void *)(*(void *)v152 + 64));
      }
      else
      {
        PDFDocumentPrintf(v8, (uint64_t)"[", v148, v149, v150, a6, a7, a8, v949);
        int v165 = *(uint64_t **)(v8 + 600);
        BOOL v166 = *(uint64_t **)(v8 + 608);
        while (v165 != v166)
        {
          uint64_t v167 = *v165++;
          PDFDocumentPrintf(v8, (uint64_t)"%R", v159, v160, v161, v162, v163, v164, *(void *)(v167 + 64));
        }
        PDFDocumentPrintf(v8, (uint64_t)"]", v159, v160, v161, v162, v163, v164, v951);
      }
      if (v120)
      {
        PDFDocumentPrintf(v8, (uint64_t)"/ParentTree %R", v153, v154, v155, v156, v157, v158, v120);
        PDFDocumentPrintf(v8, (uint64_t)"/ParentTreeNextKey %d", v168, v169, v170, v171, v172, v173, *(void *)(v8 + 592));
      }
      PDFDocumentPrintf(v8, (uint64_t)">>", v153, v154, v155, v156, v157, v158, v950);
      PDFDocumentEndObject(v8, v174, v175, v176, v177, v178, v179, v180);
      value[0] = 0;
      value[1] = (CGPDFArrayRef)value;
      *(void *)&long long v993 = 0x4812000000;
      *((void *)&v993 + 1) = __Block_byref_object_copy__5806;
      v994 = __Block_byref_object_dispose__5807;
      v995 = "";
      v997[0] = 0;
      v997[1] = 0;
      v996 = v997;
      int v187 = *(uint64_t **)(v8 + 600);
      unint64_t v188 = *(uint64_t **)(v8 + 608);
      if (v187 != v188)
      {
        unsigned int v189 = (CGPDFObject *)MEMORY[0x1E4F143A8];
        do
        {
          uint64_t v190 = *v187;
          v991[0] = v189;
          v991[1] = (CGPDFObjectRef)3221225472;
          v991[2] = (CGPDFObjectRef)___ZL28PDFDocumentEmitStructureTreeP11PDFDocument_block_invoke;
          v991[3] = (CGPDFObjectRef)&unk_1E52B37B0;
          v991[4] = (CGPDFObjectRef)value;
          PDFStructureElement::EnumerateMarkedContentItemsRecursively(v190 + 16, v991);
          ++v187;
        }
        while (v187 != v188);
      }
      uint64_t v8 = (uint64_t)v988;
      if (v120)
      {
        PDFDocumentBeginObject((uint64_t)v988, v120, v181, v182, v183, v184, v185, v186);
        PDFDocumentPrintf((uint64_t)v988, (uint64_t)"<<", v191, v192, v193, v194, v195, v196, v943);
        PDFDocumentPrintf((uint64_t)v988, (uint64_t)"/Nums", v197, v198, v199, v200, v201, v202, v952);
        PDFDocumentPrintf((uint64_t)v988, (uint64_t)"[", v203, v204, v205, v206, v207, v208, v953);
        int v216 = (char *)*((void *)value[1] + 6);
        unsigned int v217 = (char *)value[1] + 56;
        if (v216 != (char *)value[1] + 56)
        {
          uint64_t v218 = 0;
          do
          {
            for (uint64_t k = *((void *)v216 + 4); v218 < k; uint64_t k = *((void *)v216 + 4))
            {
              CGPostError((uint64_t)"%s: Object reference with struct parent of %ld not added to a structure element", v209, v210, v211, v212, v213, v214, v215, (char)"PDFDocumentEmitStructureTree");
              PDFDocumentPrintf((uint64_t)v988, (uint64_t)"%d null", v220, v221, v222, v223, v224, v225, v218++);
            }
            PDFDocumentPrintf((uint64_t)v988, (uint64_t)"%d", v210, v211, v212, v213, v214, v215, k);
            array[0] = (CGPDFArrayRef)v988;
            array[1] = (CGPDFArrayRef)v988;
            uint64_t v226 = *((unsigned int *)v216 + 16);
            if (v226 == -1) {
              std::__throw_bad_variant_access[abi:fe180100]();
            }
            v999[0] = (CGPDFInteger)array;
            ((void (*)(CGPDFInteger *, char *))off_1ED09B530[v226])(v999, v216 + 40);
            uint64_t v227 = (char *)*((void *)v216 + 1);
            if (v227)
            {
              do
              {
                uint64_t v228 = v227;
                uint64_t v227 = *(char **)v227;
              }
              while (v227);
            }
            else
            {
              do
              {
                uint64_t v228 = (char *)*((void *)v216 + 2);
                BOOL v310 = *(void *)v228 == (void)v216;
                int v216 = v228;
              }
              while (!v310);
            }
            uint64_t v218 = k + 1;
            int v216 = v228;
          }
          while (v228 != v217);
        }
        uint64_t v8 = (uint64_t)v988;
        PDFDocumentPrintf((uint64_t)v988, (uint64_t)"]", v210, v211, v212, v213, v214, v215, v954);
        PDFDocumentPrintf((uint64_t)v988, (uint64_t)">>", v229, v230, v231, v232, v233, v234, v955);
        PDFDocumentEndObject((uint64_t)v988, v235, v236, v237, v238, v239, v240, v241);
      }
      _Block_object_dispose(value, 8);
      std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(v997[0]);
    }
  }
  if (*(void *)(v8 + 64))
  {
    v991[0] = 0;
    if (*(unsigned char *)(v8 + 91))
    {
      if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
        dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_5812);
      }
      uint64_t v242 = create_pdfa_xmp_metadata(PDFDocument *)::f();
      if (v242)
      {
        uint64_t v243 = (const void *)v242;
        for (uint64_t m = 0; m != 10; m += 2)
        {
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_162_5813);
          }
          if ((create_pdfa_xmp_metadata(PDFDocument *)::f(v243, off_1E52B37D0[m], off_1E52B37D0[m + 1], 0) & 1) == 0)
          {
            uint64_t v8 = (uint64_t)v988;
LABEL_150:
            CFRelease(v243);
            goto LABEL_151;
          }
        }
        uint64_t v8 = (uint64_t)v988;
        CFDictionaryRef String = PDFInfoGetString(v988[4].super.isa, @"kCGPDFContextTitle", @"Title");
        if (String)
        {
          CFDictionaryRef v246 = String;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_168);
          }
          create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"dc:title[\"x-default\"]", v246);
        }
        CFDictionaryRef v247 = PDFInfoGetString(v988[4].super.isa, @"kCGPDFContextAuthor", @"Author");
        if (v247)
        {
          CFDictionaryRef v248 = v247;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_177);
          }
          create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"dc:creator[0]", v248);
        }
        CFDictionaryRef v249 = PDFInfoGetString(v988[4].super.isa, @"kCGPDFContextSubject", @"Subject");
        if (v249)
        {
          CFDictionaryRef v250 = v249;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_185);
          }
          create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"dc:description[\"x-default\"]", v250);
        }
        CFStringRef v251 = PDFInfoCopyKeywordsString((uint64_t)v988[4].super.isa);
        if (v251)
        {
          CFStringRef v252 = v251;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_190);
          }
          create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"pdf:Keywords", v252);
          CFRelease(v252);
        }
        CFDictionaryRef v253 = PDFInfoGetString(v988[4].super.isa, @"kCGPDFContextCreator", @"Creator");
        if (v253)
        {
          CFDictionaryRef v254 = v253;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_198);
          }
          create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"xmp:CreatorTool", v254);
        }
        CFDictionaryRef v255 = PDFInfoCopyProducer((const __CFDictionary **)v988[4].super.isa);
        if (v255)
        {
          CFDictionaryRef v256 = v255;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_203);
          }
          create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"pdf:Producer", v256);
          CFRelease(v256);
        }
        CFAllocatorRef v257 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDateFormatterRef ISO8601Formatter = CFDateFormatterCreateISO8601Formatter((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0x773uLL);
        if (ISO8601Formatter)
        {
          uint64_t v259 = ISO8601Formatter;
          CFDateRef NowDate = (const __CFDate *)PDFInfoGetNowDate((void *)v988[4].super.isa);
          CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v257, v259, NowDate);
          if (StringWithDate)
          {
            CFStringRef v262 = StringWithDate;
            if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
              dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_208);
            }
            create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"xmp:CreateDate", v262);
            if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
              dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_213);
            }
            create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"xmp:ModifyDate", v262);
            CFRelease(v262);
          }
          CFRelease(v259);
        }
        if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1) {
          dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_218_5824);
        }
        create_pdfa_xmp_metadata(PDFDocument *)::f(v243, 0, @"pdfaid:part", @"2");
        if (_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__10_ != -1) {
          dispatch_once(&_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__10_, &__block_literal_global_226);
        }
        _ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__10_(v243, 0, @"pdfaid:conformance", @"B");
        value[0] = 0;
        uint64_t ID = PDFDocumentGetID((uint64_t)v988, value);
        double v264 = (const UInt8 *)malloc_type_malloc((2 * (uint64_t)value[0]) | 1, 0x20E20AFDuLL);
        if (v264)
        {
          double v265 = (UInt8 *)v264;
          if (value[0])
          {
            double v266 = 0;
            int8x16_t v267 = v264 + 1;
            do
            {
              *(v267 - 1) = a0123456789abcd[(unint64_t)*((unsigned __int8 *)v266 + ID) >> 4];
              *int8x16_t v267 = a0123456789abcd[*((unsigned char *)v266 + ID) & 0xF];
              v267 += 2;
              double v266 = (CGPDFArray *)((char *)v266 + 1);
            }
            while (v266 < value[0]);
            CFIndex v268 = 2 * (uint64_t)value[0];
          }
          else
          {
            CFIndex v268 = 0;
          }
          CFStringRef v269 = CFStringCreateWithBytes(v257, v264, v268, 0x600u, 0);
          if (v269)
          {
            CFStringRef v270 = v269;
            if (_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__11_ != -1) {
              dispatch_once(&_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__11_, &__block_literal_global_234);
            }
            _ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__11_(v243, 0, @"xmpMM:DocumentID", v270);
            CFRelease(v270);
          }
          free(v265);
        }
        if (_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__12_ != -1) {
          dispatch_once(&_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__12_, &__block_literal_global_239);
        }
        uint64_t v271 = (const void *)_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__12_(v243, 0);
        CFRelease(v243);
        if (v271)
        {
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(Mutable, @"/Type", @"/Metadata");
          CFDictionarySetValue(Mutable, @"/Subtype", @"/XML");
          CFDictionarySetValue(Mutable, @"/%Stream", v271);
          PDFDocumentAddCatalogEntry((uint64_t)v988, @"/Metadata", Mutable);
          CFRelease(Mutable);
          uint64_t v243 = v271;
          goto LABEL_150;
        }
      }
    }
LABEL_151:
    uint64_t v273 = *(void *)(v8 + 456);
    if (!v273)
    {
      uint64_t v285 = 0;
      goto LABEL_211;
    }
    BOOL v274 = *(void **)(v273 + 24);
    if (!v274 || v274[1] == *v274)
    {
      PDFDocumentBeginPage(*(void **)v273, 0);
      PDFDocumentEndPage(*(void *)v273);
    }
    uint64_t v275 = *(void *)(v273 + 48);
    uint64_t v276 = *(void *)(v273 + 56);
    if (v276 != v275)
    {
LABEL_188:
      while (v275 != v276)
      {
        int8x16_t v288 = *(unint64_t **)v275;
        unsigned int v289 = *(std::__shared_weak_count **)(v275 + 8);
        if (v289) {
          atomic_fetch_add_explicit(&v289->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unint64_t v290 = *(void *)(v275 + 16);
        PDFDocumentBeginObject(*(void *)v273, *v288, a3, a4, a5, a6, a7, a8);
        PDFDocumentPrintf(*(void *)v273, (uint64_t)"<<", v291, v292, v293, v294, v295, v296, v943);
        PDFDocumentPrintf(*(void *)v273, (uint64_t)"/Type /Pages", v297, v298, v299, v300, v301, v302, v956);
        uint64_t v309 = *(void *)v273;
        if (v290)
        {
          PDFDocumentPrintPageParentReference(v309, (uint64_t)"/Parent %R", v290, v304, v305, v306, v307, v308);
        }
        else if (!*(unsigned char *)(v309 + 90))
        {
          BOOL v310 = *(double *)(v309 + 96) == INFINITY || *(double *)(v309 + 104) == INFINITY;
          if (!v310)
          {
            long long v311 = *(_OWORD *)(v309 + 112);
            *(_OWORD *)CGPDFReal value = *(_OWORD *)(v309 + 96);
            long long v993 = v311;
            PDFDocumentPrintf(*(void *)v273, (uint64_t)"/MediaBox %r", v303, v304, v305, v306, v307, v308, (uint64_t)value);
            uint64_t v309 = *(void *)v273;
          }
          double v313 = *(double *)(v309 + 128);
          double v314 = *(double *)(v309 + 136);
          unint64_t v312 = (_OWORD *)(v309 + 128);
          if (v313 != INFINITY && v314 != INFINITY)
          {
            long long v316 = v312[1];
            *(_OWORD *)CGPDFReal value = *v312;
            long long v993 = v316;
            PDFDocumentPrintf(*(void *)v273, (uint64_t)"/CropBox %r", v303, v304, v305, v306, v307, v308, (uint64_t)value);
          }
        }
        PDFDocumentPrintf(*(void *)v273, (uint64_t)"/Count %d", v303, v304, v305, v306, v307, v308, v288[1]);
        PDFDocumentPrintf(*(void *)v273, (uint64_t)"/Kids [", v317, v318, v319, v320, v321, v322, v957);
        if (v288[2])
        {
          unint64_t v329 = 0;
          do
            PDFDocumentPrintReference(*(void *)v273, (uint64_t)"%R", v288[v329++ + 3], v324, v325, v326, v327, v328);
          while (v329 < v288[2]);
        }
        PDFDocumentPrintf(*(void *)v273, (uint64_t)"]", v323, v324, v325, v326, v327, v328, v958);
        PDFDocumentPrintf(*(void *)v273, (uint64_t)">>", v330, v331, v332, v333, v334, v335, v959);
        PDFDocumentEndObject(*(void *)v273, v336, v337, v338, v339, v340, v341, v342);
        if (v289) {
          std::__shared_weak_count::__release_shared[abi:fe180100](v289);
        }
        v275 += 24;
      }
      uint64_t v285 = *(void *)(v273 + 72);
      uint64_t v8 = (uint64_t)v988;
LABEL_211:
      uint64_t v343 = *(void *)(v8 + 48);
      if (v343 && (uint64_t v344 = PDFXRefTableAddObject(*(void **)(*(void *)v343 + 464))) != 0)
      {
        unint64_t v345 = v344;
        CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v343 + 16));
        int v353 = (CGColorSpaceRef **)malloc_type_calloc(1uLL, 8 * Count, 0x2004093837F09uLL);
        if (v353)
        {
          PDFDocumentBeginObject(*(void *)v343, v345, v347, v348, v349, v350, v351, v352);
          PDFDocumentPrintf(*(void *)v343, (uint64_t)"[", v354, v355, v356, v357, v358, v359, v943);
          v986 = (CGColorSpaceRef **)v345;
          if (Count)
          {
            for (CFIndex n = 0; n != Count; ++n)
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v343 + 16), n);
              uint64_t v368 = *(void *)v343;
              PDFDocumentPrintf(*(void *)v343, (uint64_t)"<<", v369, v370, v371, v372, v373, v374, v960);
              PDFDocumentPrintf(v368, (uint64_t)"/Type /OutputIntent", v375, v376, v377, v378, v379, v380, v961);
              CFStringRef v381 = (const __CFString *)get_string(ValueAtIndex, @"S");
              CFIndex Length = CFStringGetLength(v381);
              CFIndex v383 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
              unsigned int v384 = (char *)malloc_type_malloc(v383, 0xA7E497E8uLL);
              if (v384)
              {
                BOOL v385 = v384;
                if (CFStringGetCString(v381, v384, v383, 0x8000100u)) {
                  PDFDocumentPrintf(v368, (uint64_t)"/S /%N", v386, v387, v388, v389, v390, v391, (uint64_t)v385);
                }
                free(v385);
              }
              int v392 = get_string(ValueAtIndex, @"OutputConditionIdentifier");
              PDFDocumentPrintf(v368, (uint64_t)"/OutputConditionIdentifier %S", v393, v394, v395, v396, v397, v398, (uint64_t)v392);
              unint64_t v399 = get_string(ValueAtIndex, @"OutputCondition");
              if (v399) {
                PDFDocumentPrintf(v368, (uint64_t)"/OutputCondition %T", v400, v401, v402, v403, v404, v405, (uint64_t)v399);
              }
              uint64_t v406 = get_string(ValueAtIndex, @"RegistryName");
              if (v406) {
                PDFDocumentPrintf(v368, (uint64_t)"/RegistryName %S", v407, v408, v409, v410, v411, v412, (uint64_t)v406);
              }
              unint64_t v413 = get_string(ValueAtIndex, @"Info");
              if (v413) {
                PDFDocumentPrintf(v368, (uint64_t)"/Info %T", v414, v415, v416, v417, v418, v419, (uint64_t)v413);
              }
              else {
                PDFDocumentPrintf(v368, (uint64_t)"/Info (none)", v414, v415, v416, v417, v418, v419, v962);
              }
              uint64_t v420 = CFDictionaryGetValue(ValueAtIndex, @"DestOutputProfile");
              unint64_t v427 = v420;
              if (v420)
              {
                CFTypeID v428 = CFGetTypeID(v420);
                if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
                  dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
                }
                if (v428 == CGColorSpaceGetTypeID_type_id
                  && (CGColorSpaceGetType(v427) == 6 || CGColorSpaceGetType(v427) == 11))
                {
                  unint64_t v427 = PDFColorSpaceCreate(v368, v427, 0);
                  PDFDocumentPrintf(v368, (uint64_t)"/DestOutputProfile", v429, v430, v431, v432, v433, v434, v963);
                  PDFColorSpaceEmitReference(v427, v435, v436, v437, v438, v439, v440, v441);
                }
                else
                {
                  unint64_t v427 = 0;
                }
              }
              PDFDocumentPrintf(v368, (uint64_t)">>", v421, v422, v423, v424, v425, v426, v963);
              v353[n] = (CGColorSpaceRef *)v427;
            }
            PDFDocumentPrintf(*(void *)v343, (uint64_t)"]", v442, v443, v444, v445, v446, v447, v960);
            PDFDocumentEndObject(*(void *)v343, v448, v449, v450, v451, v452, v453, v454);
            unint64_t v455 = v353;
            while (1)
            {
              uint64_t v456 = *v455;
              if (*v455)
              {
                LODWORD(v147) = CGColorSpaceGetType(v456[3]);
                if ((v147 - 10) >= 2 && v147 != 6) {
                  goto LABEL_413;
                }
                uint64_t v458 = (uint64_t)v456[2];
                if (!v458) {
                  _CGHandleAssert("PDFColorSpaceEmitICCDataStream", 408, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/ColorSpaces/PDFColorSpace.c", "cs->object_number != PDFObjectNumberInvalid", "invalid PDF object number", a6, a7, a8, v943);
                }
                BOOL v459 = PDFStreamCreateWithObjectNumber((uint64_t)v456[1], v458);
                PDFDocumentBeginObject(*v459, v459[1], v460, v461, v462, v463, v464, v465);
                PDFDocumentPrintf(*v459, (uint64_t)"<<", v466, v467, v468, v469, v470, v471, v943);
                uint64_t v478 = (uint64_t)v456[3];
                if (v478) {
                  uint64_t v478 = *(void *)(*(void *)(v478 + 24) + 48);
                }
                PDFDocumentPrintf((uint64_t)v456[1], (uint64_t)"/N %z", v472, v473, v474, v475, v476, v477, v478);
                PDFStreamBeginData((CGDataConsumerRef)v459);
                CFDataRef v479 = CGColorSpaceCopyICCData(v456[3]);
                BytePtr = CFDataGetBytePtr(v479);
                CFIndex v481 = CFDataGetLength(v479);
                CGDataConsumerPutBytes(v459[3], (uint64_t)BytePtr, v481);
                CFRelease(v479);
                PDFStreamEndData(v459);
                PDFStreamEnd((CFDataRef *)v459);
                PDFStreamRelease((uint64_t)v459);
                PDFColorSpaceRelease(*v455);
              }
              ++v455;
              if (!--Count) {
                goto LABEL_251;
              }
            }
          }
          PDFDocumentPrintf(*(void *)v343, (uint64_t)"]", v360, v361, v362, v363, v364, v365, v960);
          PDFDocumentEndObject(*(void *)v343, v482, v483, v484, v485, v486, v487, v488);
LABEL_251:
          free(v353);
          int v353 = v986;
          uint64_t v8 = (uint64_t)v988;
        }
      }
      else
      {
        int v353 = 0;
      }
      uint64_t v987 = PDFXRefTableAddObject(*(void **)(v8 + 464));
      if (v987)
      {
        PDFDocumentBeginObject(v8, v987, v489, v490, v491, v492, v493, v494);
        PDFDocumentPrintf(v8, (uint64_t)"<<", v495, v496, v497, v498, v499, v500, v943);
        PDFDocumentPrintf(v8, (uint64_t)"/Type /Catalog", v501, v502, v503, v504, v505, v506, v964);
        CFDictionaryRef v512 = *(const __CFDictionary **)(v8 + 312);
        if (v512) {
          CFDictionaryApplyFunction(v512, (CFDictionaryApplierFunction)emit_catalog_entries, (void *)v8);
        }
        PDFDocumentPrintReference(v8, (uint64_t)"/Pages %R", v285, v507, v508, v509, v510, v511);
        int v519 = *(_DWORD *)(v8 + 4);
        if (v519 < 2)
        {
          if (v519 == 1 && *(int *)(v8 + 8) >= 4) {
            PDFDocumentPrintf(v8, (uint64_t)"/Version /%d.%d", v513, v514, v515, v516, v517, v518, 1);
          }
        }
        else
        {
          PDFDocumentPrintf(v8, (uint64_t)"/Version /%d.%d", v513, v514, v515, v516, v517, v518, *(unsigned int *)(v8 + 4));
        }
        if (v353) {
          PDFDocumentPrintReference(v8, (uint64_t)"/OutputIntents %R ", (uint64_t)v353, v514, v515, v516, v517, v518);
        }
        if (*(void *)(v8 + 576))
        {
          PDFDocumentPrintf(v8, (uint64_t)"/MarkInfo << /Marked true >>", v513, v514, v515, v516, v517, v518, v965);
          PDFDocumentPrintReference(v8, (uint64_t)"/StructTreeRoot %R", *(void *)(v8 + 576), v520, v521, v522, v523, v524);
        }
        if (*(void *)(v8 + 520))
        {
          CFMutableDictionaryRef v525 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionaryRef v526 = *(const __CFDictionary **)(v8 + 312);
          if (v526) {
            CFDictionaryApplyFunction(v526, (CFDictionaryApplierFunction)copy_catalog_entries, v525);
          }
          CGCFDictionarySetInteger(v525, @"/Pages", v285);
          if (v353) {
            CGCFDictionarySetInteger(v525, @"/OutputIntents", (int)v353);
          }
          uint64_t v527 = *(void *)(v8 + 576);
          if (v527) {
            CGCFDictionarySetInteger(v525, @"/StructTreeRoot", v527);
          }
          uint64_t v528 = *(void *)(v8 + 520);
          if (v528)
          {
            *(void *)(v528 + 256) = v987;
            CFMutableDictionaryRef v529 = *(CFMutableDictionaryRef *)(v528 + 328);
            if (v529 != v525)
            {
              if (v529) {
                CFRelease(v529);
              }
              if (v525) {
                CFRetain(v525);
              }
              *(void *)(v528 + 328) = v525;
            }
          }
          CFRelease(v525);
        }
        PDFDocumentPrintf(v8, (uint64_t)">>", v513, v514, v515, v516, v517, v518, v965);
        PDFDocumentEndObject(v8, v530, v531, v532, v533, v534, v535, v536);
      }
      uint64_t v537 = *(void *)(v8 + 416);
      if (v537) {
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(v537 + 8), (CFDictionaryApplierFunction)emitDestination, 0);
      }
      uint64_t v538 = *(void *)(v8 + 40);
      if (v538)
      {
        while (1)
        {
          CFIndex v539 = CFArrayGetCount(*(CFArrayRef *)(v538 + 16));
          if (!v539) {
            break;
          }
          CFIndex v540 = v539 - 1;
          CFStringRef v541 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v538 + 16), v539 - 1);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v538 + 16), v540);
          uint64_t v545 = CFDictionaryGetValue(*(CFDictionaryRef *)(v538 + 24), v541);
          if (!v545) {
            _CGHandleAssert("write_top_level_object", 388, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/Annotations/PDFMetaSet.c", "n != PDFObjectNumberInvalid", "invalid PDF object %lu", v542, v543, v544, 0);
          }
          CFTypeID v546 = CFGetTypeID(v541);
          if (v546 == CFDictionaryGetTypeID()
            && (CFDataRef v547 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v541, @"/%Stream")) != 0)
          {
            CFDataRef v548 = v547;
            CFStringRef v549 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v541, @"/Type");
            if (v549) {
              BOOL v550 = CFEqual(v549, @"/Metadata");
            }
            else {
              BOOL v550 = 0;
            }
            uint64_t v571 = PDFStreamCreateWithObjectNumber(*(void *)(v538 + 8), (uint64_t)v545);
            uint64_t v578 = v571;
            if (v571) {
              *((unsigned char *)v571 + 65) = v550;
            }
            PDFDocumentBeginObject(*v571, v571[1], v572, v573, v574, v575, v576, v577);
            PDFDocumentPrintf(*v578, (uint64_t)"<<", v579, v580, v581, v582, v583, v584, v943);
            CFDictionaryApplyFunction((CFDictionaryRef)v541, (CFDictionaryApplierFunction)write_dictionary_entry, (void *)v538);
            PDFStreamBeginData((CGDataConsumerRef)v578);
            uint64_t v585 = CFDataGetBytePtr(v548);
            CFIndex v586 = CFDataGetLength(v548);
            CGDataConsumerPutBytes(v578[3], (uint64_t)v585, v586);
            PDFStreamEndData(v578);
            PDFStreamEnd((CFDataRef *)v578);
            PDFStreamRelease((uint64_t)v578);
          }
          else
          {
            CFTypeID v551 = CFGetTypeID(v541);
            if (v551 == CFDataGetTypeID())
            {
              write_object((uint64_t *)v538, v541, v552, v553, v554, v555, v556, v557, v943);
            }
            else
            {
              PDFDocumentBeginObject(*(void *)(v538 + 8), (unint64_t)v545, v552, v553, v554, v555, v556, v557);
              write_object((uint64_t *)v538, v541, v558, v559, v560, v561, v562, v563, v943);
              PDFDocumentEndObject(*(void *)(v538 + 8), v564, v565, v566, v567, v568, v569, v570);
            }
          }
        }
      }
      uint64_t v587 = (uint64_t)v988;
      emit_page_resources(v988);
      LOBYTE(v588) = 0;
      do
      {
        Class v589 = v988[21].super.isa;
        if (v589)
        {
          uint64_t v588 = *((void *)v589 + 9);
          if (v588)
          {
            do
            {
              CGPDFArrayRef v590 = (CGPDFArrayRef)*((void *)v589 + 8);
              value[0] = *((CGPDFArrayRef *)v589 + 7);
              CGPDFArrayRef v591 = value[0];
              value[1] = v590;
              *((void *)v589 + 8) = 0;
              *((void *)v589 + 9) = 0;
              *(void *)&long long v993 = v588;
              *((void *)v590 + 2) = &value[1];
              *((void *)v589 + 7) = (char *)v589 + 64;
              if (v591 != (CGPDFArrayRef)&value[1])
              {
                do
                {
                  (*(void (**)(void))(**((void **)v591 + 4) + 40))(*((void *)v591 + 4));
                  int v592 = (void *)*((void *)v591 + 1);
                  if (v592)
                  {
                    do
                    {
                      int v593 = (CGPDFArrayRef *)v592;
                      int v592 = (void *)*v592;
                    }
                    while (v592);
                  }
                  else
                  {
                    do
                    {
                      int v593 = (CGPDFArrayRef *)*((void *)v591 + 2);
                      BOOL v310 = *v593 == v591;
                      CGPDFArrayRef v591 = (CGPDFArrayRef)v593;
                    }
                    while (!v310);
                  }
                  CGPDFArrayRef v591 = (CGPDFArrayRef)v593;
                }
                while (v593 != &value[1]);
                CGPDFArrayRef v590 = value[1];
              }
              std::__tree<unsigned long>::destroy(v590);
              uint64_t v588 = *((void *)v589 + 9);
            }
            while (v588);
            LOBYTE(v588) = 1;
          }
        }
        char v594 = v588;
        char v595 = PDFColorSpaceSetEmitDefinitions((uint64_t)v988[20]._private);
        BOOL v596 = PDFFunctionSetEmitDefinitions((BOOL)v988[23].super.isa);
        LOBYTE(v588) = 1;
      }
      while ((v594 & 1) != 0 || (v595 & 1) != 0 || v596);
      uint64_t v602 = (uint64_t *)v988[4].super.isa;
      if (!v602)
      {
LABEL_353:
        uint64_t v713 = *(void *)(v587 + 56);
        if (v713
          && ((v714 = *(void *)(v587 + 32)) == 0 || (*(void *)(v714 + 8) = 0, (uint64_t v713 = *(void *)(v587 + 56)) != 0)))
        {
          uint64_t v716 = PDFXRefTableAddObject(*(void **)(*(void *)v713 + 464));
          if (v716)
          {
            PDFDocumentBeginObject(*(void *)v713, v716, v715, v597, v598, v599, v600, v601);
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"<<", v717, v718, v719, v720, v721, v722, v943);
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"/Filter /Standard", v723, v724, v725, v726, v727, v728, v968);
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"/V %d", v729, v730, v731, v732, v733, v734, *(unsigned int *)(v713 + 8));
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"/R %d", v735, v736, v737, v738, v739, v740, *(unsigned int *)(v713 + 12));
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"/Length %d", v741, v742, v743, v744, v745, v746, *(void *)(v713 + 128));
            int v753 = *(_DWORD *)(v713 + 8);
            if ((v753 - 4) >= 2)
            {
              if (v753 != 2) {
                _CGHandleAssert("PDFSecurityHandlerEmitEncrypt", 1189, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/Encryption/PDFSecurityHandler.c", "0", "unhandled file version %d  (File too new?)", v750, v751, v752, *(_DWORD *)(v713 + 8));
              }
            }
            else
            {
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/CF", v747, v748, v749, v750, v751, v752, v969);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"<<", v754, v755, v756, v757, v758, v759, v970);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/StdCF", v760, v761, v762, v763, v764, v765, v971);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"<<", v766, v767, v768, v769, v770, v771, v972);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/AuthEvent /DocOpen", v772, v773, v774, v775, v776, v777, v973);
              if (*(_DWORD *)(v713 + 8) == 4) {
                uint64_t v784 = "/AESV2";
              }
              else {
                uint64_t v784 = "/AESV3";
              }
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/CFM %s", v778, v779, v780, v781, v782, v783, (uint64_t)v784);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/Length %d", v785, v786, v787, v788, v789, v790, *(void *)(v713 + 128) >> 3);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)">>", v791, v792, v793, v794, v795, v796, v974);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)">>", v797, v798, v799, v800, v801, v802, v975);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/StmF /StdCF", v803, v804, v805, v806, v807, v808, v976);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/StrF /StdCF", v809, v810, v811, v812, v813, v814, v977);
              PDFDocumentPrintf(*(void *)v713, (uint64_t)"/EncryptMetadata %b", v815, v816, v817, v818, v819, v820, *(unsigned __int8 *)(v713 + 136));
            }
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"/O %X", v747, v748, v749, v750, v751, v752, 32);
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"/U %X", v821, v822, v823, v824, v825, v826, 32);
            PDFDocumentPrintf(*(void *)v713, (uint64_t)"/P %d", v827, v828, v829, v830, v831, v832, *(unsigned int *)(v713 + 24));
            PDFDocumentPrintf(*(void *)v713, (uint64_t)">>", v833, v834, v835, v836, v837, v838, v978);
            PDFDocumentEndObject(*(void *)v713, v839, v840, v841, v842, v843, v844, v845);
          }
        }
        else
        {
          uint64_t v716 = 0;
        }
        uint64_t v846 = *(void *)(v587 + 24);
        if (v846) {
          uint64_t v847 = *(void *)(v846 + 40);
        }
        else {
          uint64_t v847 = 0;
        }
        PDFXRefTableEmit(*(unsigned char **)(v587 + 464), v846, 0, v597, v598, v599, v600, v601);
        uint64_t v854 = *(void *)(v587 + 464);
        if (v854) {
          uint64_t v855 = (uint64_t)(*(void *)(v854 + 24) - *(void *)(v854 + 16)) >> 4;
        }
        else {
          uint64_t v855 = 0;
        }
        PDFDocumentPrintf(v587, (uint64_t)"trailer\n", v848, v849, v850, v851, v852, v853, v943);
        PDFDocumentPrintf(v587, (uint64_t)"<<", v856, v857, v858, v859, v860, v861, v979);
        PDFDocumentPrintf(v587, (uint64_t)"/Size %d", v862, v863, v864, v865, v866, v867, v855);
        PDFDocumentPrintReference(v587, (uint64_t)"/Root %R", v987, v868, v869, v870, v871, v872);
        if (v716) {
          PDFDocumentPrintReference(v587, (uint64_t)"/Encrypt %R", v716, v873, v874, v875, v876, v877);
        }
        uint64_t v878 = *(void *)(v587 + 64);
        if (v878)
        {
          uint64_t v879 = *(void *)(v878 + 16);
          BOOL v880 = v879 == 0;
          if (!v879
            || (PDFDocumentPrintReference(v587, (uint64_t)"/Info %R", *(void *)(v878 + 16), v873, v874, v875, v876, v877), (uint64_t v878 = *(void *)(v587 + 64)) != 0))
          {
            CFDictionaryRef v881 = *(const __CFDictionary **)(v878 + 8);
            if (v881)
            {
              CFArrayRef v882 = (const __CFArray *)CFDictionaryGetValue(v881, @"CGPDFContextDocumentID");
              if (v882)
              {
                CFArrayRef v883 = v882;
                CFTypeID v884 = CFGetTypeID(v882);
                if (v884 == CFArrayGetTypeID()
                  && CFArrayGetCount(v883) == 2
                  && (CFDataRef v891 = (const __CFData *)CFArrayGetValueAtIndex(v883, 0),
                      CFDataRef v892 = (const __CFData *)CFArrayGetValueAtIndex(v883, 1),
                      CFTypeID v893 = CFGetTypeID(v891),
                      v893 == CFDataGetTypeID())
                  && (CFTypeID v894 = CFGetTypeID(v892), v894 == CFDataGetTypeID())
                  && CFDataGetLength(v891) == 16
                  && CFDataGetLength(v892) == 16)
                {
                  v895 = CFDataGetBytePtr(v891);
                  CFDataGetBytePtr(v892);
                  v991[0] = (CGPDFObjectRef)16;
                }
                else
                {
                  if (v883 != (const __CFArray *)*MEMORY[0x1E4F1D260]) {
                    pdf_error("Invalid value for kCGPDFContextDocumentID.");
                  }
                  v991[0] = (CGPDFObjectRef)16;
                  v895 = (const UInt8 *)&emit_trailer(PDFDocument *)::md5;
                }
                uint64_t v896 = (uint64_t)v988;
                goto LABEL_387;
              }
            }
          }
        }
        else
        {
          LODWORD(v879) = 0;
          BOOL v880 = 1;
        }
        v895 = (const UInt8 *)PDFDocumentGetID(v587, v991);
        uint64_t v896 = v587;
LABEL_387:
        PDFDocumentPrintf(v896, (uint64_t)"/ID [", v885, v886, v887, v888, v889, v890, v980);
        PDFDocumentPrintf(v896, (uint64_t)"%X", v897, v898, v899, v900, v901, v902, (uint64_t)v991[0]);
        PDFDocumentPrintf(v896, (uint64_t)"%X", v903, v904, v905, v906, v907, v908, (uint64_t)v991[0]);
        PDFDocumentPrintf(v896, (uint64_t)"]", v909, v910, v911, v912, v913, v914, v981);
        PDFDocumentPrintf(v896, (uint64_t)">>\n", v915, v916, v917, v918, v919, v920, v982);
        uint64_t v8 = v896;
        if (*(void *)(v896 + 520))
        {
          v927 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CGCFDictionarySetInteger(v927, @"/Size", v855);
          CGCFDictionarySetInteger(v927, @"/Root", v987);
          if (v716) {
            CGCFDictionarySetInteger(v927, @"/Encrypt", v716);
          }
          if (!v880) {
            CGCFDictionarySetInteger(v927, @"/Info", v879);
          }
          CFDataRef v928 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v895, (CFIndex)v991[0]);
          CFDictionaryAddValue(v927, @"/ID", v928);
          CFRelease(v928);
          v929 = v988[32]._private;
          if (v929)
          {
            v930 = (__CFDictionary *)*((void *)v929 + 40);
            if (v930 != v927)
            {
              if (v930) {
                CFRelease(v930);
              }
              if (v927) {
                CFRetain(v927);
              }
              *((void *)v929 + 40) = v927;
            }
          }
          CFRelease(v927);
          uint64_t v8 = (uint64_t)v988;
        }
        PDFDocumentPrintf(v8, (uint64_t)"startxref\n", v921, v922, v923, v924, v925, v926, v983);
        PDFDocumentPrintf(v8, (uint64_t)"%O\n", v931, v932, v933, v934, v935, v936, v847);
        PDFDocumentPrintf(v8, (uint64_t)"%%%%EOF\n", v937, v938, v939, v940, v941, v942, v984);
        goto LABEL_401;
      }
      if (v602[1])
      {
        CFStringRef v603 = PDFInfoCopyKeywordsString((uint64_t)v988[4].super.isa);
        if (v603)
        {
          CFStringRef v604 = v603;
          uint64_t v605 = PDFXRefTableAddObject(*(void **)(*v602 + 464));
          PDFDocumentBeginObject(*v602, v605, v606, v607, v608, v609, v610, v611);
          PDFDocumentPrintf(*v602, (uint64_t)"%T", v612, v613, v614, v615, v616, v617, (uint64_t)v604);
          PDFDocumentEndObject(*v602, v618, v619, v620, v621, v622, v623, v624);
          CFRelease(v604);
        }
        else
        {
          uint64_t v605 = 0;
        }
        CFDictionaryRef v625 = (const __CFDictionary *)v602[1];
        if (v625)
        {
          CFArrayRef v626 = (const __CFArray *)CFDictionaryGetValue(v625, @"kCGPDFContextKeywords");
          CFArrayRef v627 = v626;
          if (!v626)
          {
LABEL_333:
            unint64_t v668 = PDFXRefTableAddObject(*(void **)(*v602 + 464));
            v602[2] = v668;
            PDFDocumentBeginObject(*v602, v668, v669, v670, v671, v672, v673, v674);
            PDFDocumentPrintf(*v602, (uint64_t)"<<", v675, v676, v677, v678, v679, v680, v943);
            CFStringRef v681 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v602, @"kCGPDFContextTitle", @"Title");
            uint64_t v682 = *(void *)(*v602 + 48);
            if (!v681)
            {
              if (PDFOutputIntentGetIsX3(*(unsigned char **)(*v602 + 48))) {
                CFStringRef v681 = @"Untitled";
              }
              else {
                CFStringRef v681 = 0;
              }
            }
            emit_key_string(v602, @"/Title", v681);
            CFStringRef v683 = (const __CFString *)PDFInfoCopyProducer((const __CFDictionary **)v602);
            if (v683)
            {
              CFStringRef v684 = v683;
              emit_key_string(v602, @"/Producer", v683);
              CFRelease(v684);
            }
            CFStringRef v685 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v602, @"kCGPDFContextAuthor", @"Author");
            emit_key_string(v602, @"/Author", v685);
            CFStringRef v686 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v602, @"kCGPDFContextSubject", @"Subject");
            emit_key_string(v602, @"/Subject", v686);
            CFStringRef v687 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v602, @"kCGPDFContextCreator", @"Creator");
            emit_key_string(v602, @"/Creator", v687);
            int v688 = PDFInfoGetNowDate(v602);
            if (v688)
            {
              CFStringRef v695 = (const __CFString *)PDFCreateDateString((uint64_t)v688);
              if (v695)
              {
                CFStringRef v696 = v695;
                emit_key_string(v602, @"/CreationDate", v695);
                emit_key_string(v602, @"/ModDate", v696);
                CFRelease(v696);
              }
            }
            if (v605) {
              PDFDocumentPrintReference(*v602, (uint64_t)"/Keywords %R", v605, v690, v691, v692, v693, v694);
            }
            uint64_t v587 = (uint64_t)v988;
            if (v627) {
              PDFDocumentPrintReference(*v602, (uint64_t)"/AAPL:Keywords %R", (uint64_t)v627, v690, v691, v692, v693, v694);
            }
            if (v682 && PDFOutputIntentGetIsX3((unsigned char *)v682))
            {
              uint64_t v697 = *(void *)v682;
              PDFDocumentPrintf(*(void *)v682, (uint64_t)"/GTS_PDFXVersion (PDF/X-3:2002)", v689, v690, v691, v692, v693, v694, v967);
              uint64_t v698 = CFDictionaryGetValue(*(CFDictionaryRef *)(v682 + 8), @"Trapped");
              uint64_t v705 = "False";
              if (v698 && CFEqual(v698, @"True")) {
                uint64_t v705 = "True";
              }
              PDFDocumentPrintf(v697, (uint64_t)"/Trapped /%N", v699, v700, v701, v702, v703, v704, (uint64_t)v705);
            }
            PDFDocumentPrintf(*v602, (uint64_t)">>", v689, v690, v691, v692, v693, v694, v967);
            PDFDocumentEndObject(*v602, v706, v707, v708, v709, v710, v711, v712);
            goto LABEL_353;
          }
          CFTypeID v628 = CFGetTypeID(v626);
          if (v628 == CFArrayGetTypeID())
          {
            CFIndex v629 = CFArrayGetCount(v627);
            if (v629 >= 1)
            {
              uint64_t v630 = v629;
              MutableCopdouble y = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v627);
              for (isize_t i = 0; ii < v630; ++ii)
              {
                CFStringRef v633 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, ii);
                CFTypeID v634 = CFGetTypeID(v633);
                if (v634 != CFStringGetTypeID() || CFStringGetLength(v633) <= 0)
                {
                  CFArrayRemoveValueAtIndex(MutableCopy, ii);
                  --v630;
                  --ii;
                }
              }
              if (v630 >= 1)
              {
                CFArrayRef v627 = (const __CFArray *)PDFXRefTableAddObject(*(void **)(*v602 + 464));
                PDFDocumentBeginObject(*v602, (unint64_t)v627, v635, v636, v637, v638, v639, v640);
                PDFDocumentPrintf(*v602, (uint64_t)"[", v641, v642, v643, v644, v645, v646, v943);
                for (jsize_t j = 0; jj != v630; ++jj)
                {
                  uint64_t v648 = CFArrayGetValueAtIndex(MutableCopy, jj);
                  PDFDocumentPrintf(*v602, (uint64_t)"%T", v649, v650, v651, v652, v653, v654, (uint64_t)v648);
                }
                CFRelease(MutableCopy);
                PDFDocumentPrintf(*v602, (uint64_t)"]", v655, v656, v657, v658, v659, v660, v966);
                PDFDocumentEndObject(*v602, v661, v662, v663, v664, v665, v666, v667);
                goto LABEL_333;
              }
              CFRelease(MutableCopy);
            }
          }
        }
      }
      else
      {
        uint64_t v605 = 0;
      }
      CFArrayRef v627 = 0;
      goto LABEL_333;
    }
    for (kuint64_t k = 0; ; kuint64_t k = (std::__shared_weak_count *)v284)
    {
      uint64_t v278 = *(CGPDFArray **)(v273 + 24);
      *(void *)(v273 + 24) = 0;
      *(void *)(v273 + 32) = 0;
      int8x16_t v147 = *(std::__shared_weak_count **)(v273 + 40);
      *(void *)(v273 + 40) = 0;
      if (v147) {
        std::__shared_weak_count::__release_shared[abi:fe180100](v147);
      }
      uint64_t v279 = *(void *)v278;
      uint64_t v280 = *((void *)v278 + 1);
      if (v280 - *(void *)v278 == 16) {
        break;
      }
      v985 = v278;
      if (v279 == v280)
      {
        CGPDFArrayRef v284 = (CGPDFArrayRef)kk;
      }
      else
      {
        do
        {
          CGPDFArrayRef v281 = *(CGPDFArrayRef *)v279;
          int v282 = *(atomic_ullong **)(v279 + 8);
          if (v282) {
            atomic_fetch_add_explicit(v282 + 1, 1uLL, memory_order_relaxed);
          }
          PDFPageTree::addNode((PDFPageTree *)value, (void *)v273, *(void *)v281, *((void *)v281 + 1));
          CGPDFArrayRef v283 = value[0];
          CGPDFArrayRef v284 = value[1];
          value[0] = 0;
          value[1] = 0;
          if (kk)
          {
            std::__shared_weak_count::__release_shared[abi:fe180100](kk);
            if (value[1]) {
              std::__shared_weak_count::__release_shared[abi:fe180100]((std::__shared_weak_count *)value[1]);
            }
          }
          value[0] = v281;
          value[1] = (CGPDFArrayRef)v282;
          if (v282) {
            atomic_fetch_add_explicit(v282 + 1, 1uLL, memory_order_relaxed);
          }
          *(void *)&long long v993 = *(void *)v283;
          std::vector<std::pair<std::shared_ptr<PDFPageNode>,unsigned long>>::push_back[abi:fe180100]((char **)(v273 + 48), (uint64_t)value);
          if (value[1]) {
            std::__shared_weak_count::__release_shared[abi:fe180100]((std::__shared_weak_count *)value[1]);
          }
          if (v282) {
            std::__shared_weak_count::__release_shared[abi:fe180100]((std::__shared_weak_count *)v282);
          }
          v279 += 16;
          kuint64_t k = (std::__shared_weak_count *)v284;
        }
        while (v279 != v280);
      }
      value[0] = v985;
      std::vector<std::shared_ptr<PDFPageNode>>::__destroy_vector::operator()[abi:fe180100]((void ***)value);
      MEMORY[0x18532A2A0](v985, 0x20C40960023A9);
    }
    if (v279 != v280)
    {
      double v286 = *(CGPDFArray **)v279;
      double v287 = *(atomic_ullong **)(v279 + 8);
      if (v287)
      {
        atomic_fetch_add_explicit(v287 + 1, 1uLL, memory_order_relaxed);
        value[0] = v286;
        value[1] = (CGPDFArrayRef)v287;
        atomic_fetch_add_explicit(v287 + 1, 1uLL, memory_order_relaxed);
      }
      else
      {
        value[0] = *(CGPDFArrayRef *)v279;
        value[1] = 0;
      }
      *(void *)&long long v993 = 0;
      std::vector<std::pair<std::shared_ptr<PDFPageNode>,unsigned long>>::push_back[abi:fe180100]((char **)(v273 + 48), (uint64_t)value);
      if (value[1]) {
        std::__shared_weak_count::__release_shared[abi:fe180100]((std::__shared_weak_count *)value[1]);
      }
      *(void *)(v273 + 72) = *(void *)v286;
      value[0] = v278;
      std::vector<std::shared_ptr<PDFPageNode>>::__destroy_vector::operator()[abi:fe180100]((void ***)value);
      MEMORY[0x18532A2A0](v278, 0x20C40960023A9);
      if (kk) {
        std::__shared_weak_count::__release_shared[abi:fe180100](kk);
      }
      if (v287) {
        std::__shared_weak_count::__release_shared[abi:fe180100]((std::__shared_weak_count *)v287);
      }
      uint64_t v275 = *(void *)(v273 + 48);
      uint64_t v276 = *(void *)(v273 + 56);
      goto LABEL_188;
    }
LABEL_412:
    __break(1u);
LABEL_413:
    _CGHandleAssert("PDFColorSpaceEmitICCDataStream", 407, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/ColorSpaces/PDFColorSpace.c", "type == kCGColorSpaceICCBased || type == kCGColorSpaceProfileSets || type == kCGColorSpaceFlexGTCProxy", "invalid colorspace type %d", a6, a7, a8, (char)v147);
  }
LABEL_401:
  CGDataConsumerClose(*(void *)(v8 + 24));
  double result = *(void *)(v8 + 520);
  if (result) {
    PDFLinearizer::endDocument((PDFLinearizer *)result, *(CGDataConsumer **)(v8 + 528));
  }
  *(unsigned char *)(v8 + 72) = 1;
  return result;
}

void sub_184E45880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:fe180100](a24);
  }
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v30);
  }
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v31);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(*a1);
    std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(a1[1]);
    uint64_t v2 = a1[5];
    a1[5] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    operator delete(a1);
  }
}

uint64_t *PDFDocumentBeginObject(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = 0;
  double result = PDFWriterBeginObject(*(uint64_t **)(a1 + 32), a2, &v17, a4, a5, a6, a7, a8);
  uint64_t v11 = *(void *)(a1 + 464);
  if (v11)
  {
    unint64_t v12 = *(void *)(v11 + 8);
    BOOL v13 = a2 >= v12;
    unint64_t v14 = a2 - v12;
    if (v13)
    {
      uint64_t v16 = v11 + 16;
      uint64_t v15 = *(void *)(v11 + 16);
      if (v14 < (*(void *)(v16 + 8) - v15) >> 4) {
        *(void *)(v15 + 16 * v14) = v17;
      }
    }
  }
  *(void *)(a1 + 280) = a2;
  return result;
}

unsigned char *PDFDocumentEndObject(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = 0;
  double result = PDFWriterEndObject(*(unsigned char **)(a1 + 32), &v17, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(void *)(a1 + 464);
  if (v10)
  {
    unint64_t v11 = *(void *)(a1 + 280);
    unint64_t v12 = *(void *)(v10 + 8);
    BOOL v13 = v11 >= v12;
    unint64_t v14 = v11 - v12;
    if (v13)
    {
      uint64_t v16 = v10 + 16;
      uint64_t v15 = *(void *)(v10 + 16);
      if (v14 < (*(void *)(v16 + 8) - v15) >> 4) {
        *(void *)(v15 + 16 * v14 + 8) = v17 - *(void *)(v15 + 16 * v14);
      }
    }
  }
  *(void *)(a1 + 280) = 0;
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(float *a1, unint64_t a2, _OWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    double v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (size_t i = (void *)*v9; i; size_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  unint64_t v12 = operator new(0x20uLL);
  *unint64_t v12 = 0;
  v12[1] = v5;
  *((_OWORD *)v12 + 1) = *a3;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      uint64_t v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  uint64_t v19 = operator new(8 * *(void *)&prime);
  uint64_t v20 = *(void **)a1;
  *(void *)a1 = v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v21++) = 0;
  while (*(void *)&prime != v21);
  uint64_t v22 = (void *)*((void *)a1 + 2);
  if (v22)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }
    else
    {
      v23 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
    uint64_t v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }
        else
        {
          v29 &= *(void *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(void *)(*(void *)a1 + 8 * v29))
          {
            *(void *)(*(void *)a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *uint64_t v22 = *v28;
          *uint64_t v28 = **(void **)(*(void *)a1 + 8 * v29);
          **(void **)(*(void *)a1 + 8 * v29) = v28;
          uint64_t v28 = v22;
        }
        unint64_t v29 = v23;
LABEL_56:
        uint64_t v22 = v28;
        uint64_t v28 = (void *)*v28;
        unint64_t v23 = v29;
      }
      while (v28);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  uint64_t v30 = *(void **)a1;
  uint64_t v31 = *(void **)(*(void *)a1 + 8 * v5);
  if (v31)
  {
    *unint64_t v12 = *v31;
LABEL_72:
    *uint64_t v31 = v12;
    goto LABEL_73;
  }
  *unint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v30[v5] = a1 + 4;
  if (*v12)
  {
    unint64_t v32 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
}

void sub_184E45ED4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void PDFDocumentEmitTaggedNodeStructure(PDFDocument *a1, unint64_t a2, __CFDictionary *a3, uint64_t a4)
{
  uint64_t v185 = -1;
  CGCFDictionaryGetNumber(a3, @"TagNodeMCID", kCFNumberSInt64Type, &v185);
  tagunsigned int Type = 0;
  if (CGCFDictionaryGetInteger(a3, @"TagNodeType", &tagType))
  {
    CGPDFTagType v8 = tagType;
    Name = CGPDFTagTypeGetName(tagType);
    if (Name)
    {
      uint64_t v10 = (uint64_t)Name;
      unsigned int v183 = 0;
      int Integer = CGCFDictionaryGetInteger(a3, @"PageObjectNumber", &v183);
      if (v185 != -1)
      {
        uint64_t v18 = (float *)a1[18]._private;
        *(void *)&long long value = v185 | ((unint64_t)v183 << 32);
        *((void *)&value + 1) = a2;
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(v18, value, &value);
      }
      if (v8 == 800)
      {
        PDFDocumentBeginObject((uint64_t)a1, a2, v11, v12, v13, v14, v15, v16);
        LODWORD(value) = 0;
        CGCFDictionaryGetInteger(a3, @"TagNodeObjectRefID", &value);
        uint64_t v19 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>((void *)a1[18].super.isa, (int)value);
        if (v19) {
          uint64_t v26 = v19[3];
        }
        else {
          uint64_t v26 = -1;
        }
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"<<", v20, v21, v22, v23, v24, v25, v175);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Type /OBJR", v37, v38, v39, v40, v41, v42, v176);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Obj %R", v43, v44, v45, v46, v47, v48, v26);
        PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/P %R", a4, v49, v50, v51, v52, v53);
        if (Integer) {
          PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/Pg %R", (int)v183, v55, v56, v57, v58, v59);
        }
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)">>", v54, v55, v56, v57, v58, v59, v177);
        PDFDocumentEndObject((uint64_t)a1, v60, v61, v62, v63, v64, v65, v66);
      }
      else
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        CFArrayRef v28 = (const __CFArray *)CFDictionaryGetValue(a3, @"TagNodeChildren");
        CFArrayRef v35 = v28;
        if (v28) {
          CFIndex Count = CFArrayGetCount(v28);
        }
        else {
          CFIndex Count = 0;
        }
        PDFDocumentBeginObject((uint64_t)a1, a2, v29, v30, v31, v32, v33, v34);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"<< /Type /StructElem", v67, v68, v69, v70, v71, v72, v175);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/S %s", v73, v74, v75, v76, v77, v78, v10);
        PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/P %R", a4, v79, v80, v81, v82, v83);
        if (Integer && (Count < 1 || v185 != -1)) {
          PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/Pg %R", (int)v183, v84, v85, v86, v87, v88);
        }
        CFDictionaryRef v89 = (const __CFDictionary *)CFDictionaryGetValue(a3, @"TagNodeProperties");
        if (v89)
        {
          CFDictionaryRef v90 = v89;
          CFTypeID TypeID = CFStringGetTypeID();
          ValueWithunsigned int Type = CGCFDictionaryGetValueWithType(v90, @"CGPDFTagPropertyLanguageText", TypeID);
          if (ValueWithType
            || (CFTypeID v99 = CFStringGetTypeID(),
                (ValueWithunsigned int Type = CGCFDictionaryGetValueWithType(v90, @"Lang", v99)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Lang %T", v93, v94, v95, v96, v97, v98, (uint64_t)ValueWithType);
          }
          CFTypeID v100 = CFStringGetTypeID();
          uint64_t v101 = CGCFDictionaryGetValueWithType(v90, @"CGPDFTagPropertyAlternativeText", v100);
          if (v101
            || (v108 = CFStringGetTypeID(), (uint64_t v101 = CGCFDictionaryGetValueWithType(v90, @"Alt", v108)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Alt %T", v102, v103, v104, v105, v106, v107, (uint64_t)v101);
          }
          CFTypeID v109 = CFStringGetTypeID();
          uint64_t v110 = CGCFDictionaryGetValueWithType(v90, @"CGPDFTagPropertyActualText", v109);
          if (v110
            || (CFTypeID v117 = CFStringGetTypeID(),
                (uint64_t v110 = CGCFDictionaryGetValueWithType(v90, @"ActualText", v117)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/ActualText %T", v111, v112, v113, v114, v115, v116, (uint64_t)v110);
          }
          CFTypeID v118 = CFStringGetTypeID();
          uint64_t v119 = CGCFDictionaryGetValueWithType(v90, @"CGPDFTagPropertyTitleText", v118);
          if (v119
            || (v126 = CFStringGetTypeID(), (uint64_t v119 = CGCFDictionaryGetValueWithType(v90, @"T", v126)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/T %T", v120, v121, v122, v123, v124, v125, (uint64_t)v119);
          }
        }
        *(void *)&long long value = 0;
        if (CFDictionaryGetValueIfPresent(a3, @"ID", (const void **)&value))
        {
          char CStringPtr = CFStringGetCStringPtr((CFStringRef)value, 0x8000100u);
          PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/ID (%s)", v134, v135, v136, v137, v138, v139, (uint64_t)CStringPtr);
        }
        if (Count <= 0)
        {
          uint64_t v179 = v185;
          uint64_t v153 = "/K %d ";
        }
        else
        {
          PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/K [", v127, v128, v129, v130, v131, v132, v178);
          CFIndex v146 = Count;
          if ((v185 & 0x8000000000000000) == 0)
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"%d", v140, v141, v142, v143, v144, v145, v185);
            CFIndex v146 = Count;
          }
          do
          {
            uint64_t v147 = PDFXRefTableAddObject((void *)a1[29].super.isa);
            CGCFArrayAppendInteger(Mutable, v147);
            PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"%R", v147, v148, v149, v150, v151, v152);
            --v146;
          }
          while (v146);
          uint64_t v153 = "]";
        }
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)v153, v127, v128, v129, v130, v131, v132, v179);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)" >>", v154, v155, v156, v157, v158, v159, v180);
        PDFDocumentEndObject((uint64_t)a1, v160, v161, v162, v163, v164, v165, v166);
        CFNumberRef number = 0;
        if (CFDictionaryGetValueIfPresent(a3, @"TagNodeObjectRefID", (const void **)&number))
        {
          unint64_t valuePtr = 0;
          CFNumberGetValue(number, kCFNumberLongType, &valuePtr);
          isa = (float *)a1[18].super.isa;
          *(void *)&long long value = valuePtr;
          *((void *)&value + 1) = a2;
          std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(isa, valuePtr, &value);
        }
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            CFDictionaryRef ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(v35, i);
            if (Mutable
              && (CFNumberRef v170 = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, i)) != 0
              && (v171 = v170, CFTypeID v172 = CFGetTypeID(v170), v172 == CFNumberGetTypeID()))
            {
              LODWORD(value) = 0;
              int v173 = CFNumberGetValue(v171, kCFNumberIntType, &value);
              int v174 = value;
              if (!v173) {
                int v174 = 0;
              }
            }
            else
            {
              int v174 = 0;
            }
            PDFDocumentEmitTaggedNodeStructure(a1, v174, ValueAtIndex, a2);
          }
        }
        CFRelease(Mutable);
      }
    }
  }
}

void PDFDocumentPrintf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *__Block_byref_object_copy__5806(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  double v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *uint64_t v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__5807(uint64_t a1)
{
}

void ___ZL28PDFDocumentEmitStructureTreeP11PDFDocument_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 40);
  uint64_t v4 = *(void *)(*(void *)(a2 + 48) + 64);
  uint64_t v5 = (uint64_t **)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
  if (*(_DWORD *)(a2 + 16))
  {
    uint64_t v24 = v3;
    v25[0] = v4;
    int v26 = 0;
    std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::__emplace_unique_key_args<long,std::pair<long const,std::variant<unsigned long,std::vector<unsigned long>>>>(v5, v3, (uint64_t)&v24);
    std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v25);
    return;
  }
  uint64_t v24 = v3;
  memset(v25, 0, sizeof(v25));
  int v26 = 1;
  double v6 = std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::__emplace_unique_key_args<long,std::pair<long const,std::variant<unsigned long,std::vector<unsigned long>>>>(v5, v3, (uint64_t)&v24);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v25);
  if (*((_DWORD *)v6 + 16) != 1) {
LABEL_23:
  }
    std::__throw_bad_variant_access[abi:fe180100]();
  unint64_t v7 = *(void *)(a2 + 32);
  CGPDFTagType v8 = v6[5];
  double v9 = v6[6];
  unint64_t v10 = v9 - v8;
  unint64_t v11 = v7 + 1;
  if (v7 + 1 > v10)
  {
    unint64_t v12 = v11 - v10;
    uint64_t v13 = v6[7];
    if (v11 - v10 <= v13 - v9)
    {
      bzero(v6[6], 8 * v12);
      uint64_t v22 = &v9[v12];
      v6[6] = v22;
    }
    else
    {
      if (v11 >> 61) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v14 = (char *)v13 - (char *)v8;
      if (v14 >> 2 > v11) {
        unint64_t v11 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v11;
      }
      uint64_t v16 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v15);
      unint64_t v17 = v6[5];
      uint64_t v18 = v6[6];
      uint64_t v19 = &v16[8 * v10];
      uint64_t v21 = (uint64_t *)&v16[8 * v20];
      bzero(v19, 8 * v12);
      uint64_t v22 = (uint64_t *)&v19[8 * v12];
      while (v18 != v17)
      {
        uint64_t v23 = *--v18;
        *((void *)v19 - 1) = v23;
        v19 -= 8;
      }
      v6[5] = (uint64_t *)v19;
      v6[6] = v22;
      v6[7] = v21;
      if (v17)
      {
        operator delete(v17);
        uint64_t v22 = v6[6];
      }
    }
    CGPDFTagType v8 = v6[5];
    unint64_t v10 = v22 - v8;
  }
  if (v10 <= v7)
  {
    __break(1u);
    goto LABEL_23;
  }
  v8[v7] = v4;
}

void sub_184E46670(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(*a1);
    std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(a1[1]);
    std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

uint64_t PDFDocumentGetID(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 256))
  {
    uint64_t v4 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
    CC_MD5_Init(v4);
    time_t data = time(0);
    if (v4)
    {
      CC_MD5_Update(v4, &data, 8u);
      CC_MD5_Update(v4, &PDFDocumentGetID::stamp, 4u);
    }
    ++PDFDocumentGetID::stamp;
    uint64_t v5 = *(void *)(a1 + 24);
    if (v5) {
      unint64_t v6 = *(void *)(v5 + 40);
    }
    else {
      unint64_t v6 = 0;
    }
    CFIndex v15 = v6;
    if (v4)
    {
      CC_MD5_Update(v4, &v15, 8u);
      uint64_t v5 = *(void *)(a1 + 24);
    }
    if (v5)
    {
      if (*(unint64_t (**)(uint64_t, const UInt8 *, unint64_t))(v5 + 72) == url_put_bytes)
      {
        CGPDFTagType v8 = *(CFURLRef **)(v5 + 16);
        if (v8)
        {
          if (*v8)
          {
            CFURLRef v9 = CFURLCopyAbsoluteURL(*v8);
            if (v9)
            {
              CFURLRef v10 = v9;
              CFStringRef v11 = CFURLCopyPath(v9);
              if (v11)
              {
                CFStringRef v12 = v11;
                CFIndex Length = CFStringGetLength(v11);
                CFIndex v15 = 2 * Length;
                uint64_t v14 = (UniChar *)malloc_type_malloc(2 * Length, 0xE9B63996uLL);
                v19.locatioCFIndex n = 0;
                v19.length = Length;
                CFStringGetCharacters(v12, v19, v14);
                if (v4) {
                  md5_update(v4, (char *)v14, v15);
                }
                free(v14);
                CFRelease(v12);
              }
              CFRelease(v10);
            }
          }
        }
      }
    }
    time_t data = time(0);
    if (v4)
    {
      CC_MD5_Update(v4, &data, 8u);
      CC_MD5_Final(md, v4);
    }
    free(v4);
    *(_OWORD *)(a1 + 257) = *(_OWORD *)md;
    *(unsigned char *)(a1 + 256) = 1;
  }
  if (a2) {
    *a2 = 16;
  }
  return a1 + 257;
}

void PDFDocumentAddCatalogEntry(uint64_t a1, const void *a2, void *key)
{
  if (a1)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 24), key);
    if (Value
      || (Value = (const void *)PDFXRefTableAddObject(*(void **)(*(void *)(v6 + 8) + 464)),
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 24), key, Value),
          CFArrayAppendValue(*(CFMutableArrayRef *)(v6 + 16), key),
          Value))
    {
      Mutable = *(__CFDictionary **)(a1 + 312);
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
        *(void *)(a1 + 312) = Mutable;
      }
      CFDictionarySetValue(Mutable, a2, Value);
    }
  }
}

void PDFDocumentPrintReference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFDocumentPrintf(a1, a2, a3, a4, a5, a6, a7, a8, a3);
  CFURLRef v10 = *(void **)(a1 + 520);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 280);
    PDFLinearizerRecordReference(v10, a3, v11);
  }
}

BOOL emit_page_resources(PDFDocument *a1)
{
  do
  {
    uint64_t v2 = a1[22]._private;
    char context = 0;
    if (v2 && (uint64_t v3 = *((void *)v2 + 2)) != 0)
    {
      do
      {
        *((void *)v2 + 2) = 0;
        CFArrayRef v4 = *(const __CFArray **)(v3 + 8);
        v41.length = CFArrayGetCount(v4);
        v41.locatioCFIndex n = 0;
        CFArrayApplyFunction(v4, v41, (CFArrayApplierFunction)emitFormDefinition, &context);
        CGOrderedSetRelease((const void **)v3);
        uint64_t v3 = *((void *)v2 + 2);
      }
      while (v3);
      BOOL v5 = context != 0;
    }
    else
    {
      BOOL v5 = 0;
    }
    uint64_t v6 = a1[24]._private;
    char v36 = 0;
    if (v6 && (uint64_t v7 = *((void *)v6 + 2)) != 0)
    {
      do
      {
        *((void *)v6 + 2) = 0;
        CFArrayRef v8 = *(const __CFArray **)(v7 + 8);
        v42.length = CFArrayGetCount(v8);
        v42.locatioCFIndex n = 0;
        CFArrayApplyFunction(v8, v42, (CFArrayApplierFunction)emitClipMaskDefinition, &v36);
        CGOrderedSetRelease((const void **)v7);
        uint64_t v7 = *((void *)v6 + 2);
      }
      while (v7);
      BOOL v9 = v36 != 0;
    }
    else
    {
      BOOL v9 = 0;
    }
    CFURLRef v10 = a1[23]._private;
    char v37 = 0;
    if (v10 && (uint64_t v11 = *((void *)v10 + 2)) != 0)
    {
      do
      {
        *((void *)v10 + 2) = 0;
        CFArrayRef v12 = *(const __CFArray **)(v11 + 8);
        v43.length = CFArrayGetCount(v12);
        v43.locatioCFIndex n = 0;
        CFArrayApplyFunction(v12, v43, (CFArrayApplierFunction)emitPatternDefinition, &v37);
        CGOrderedSetRelease((const void **)v11);
        uint64_t v11 = *((void *)v10 + 2);
      }
      while (v11);
      BOOL v13 = v37 != 0;
    }
    else
    {
      BOOL v13 = 0;
    }
    Class isa = a1[24].super.isa;
    char v38 = 0;
    if (isa && (uint64_t v15 = *((void *)isa + 2)) != 0)
    {
      do
      {
        *((void *)isa + 2) = 0;
        CFArrayRef v16 = *(const __CFArray **)(v15 + 8);
        v44.length = CFArrayGetCount(v16);
        v44.locatioCFIndex n = 0;
        CFArrayApplyFunction(v16, v44, (CFArrayApplierFunction)emitShadingDefinition, &v38);
        CGOrderedSetRelease((const void **)v15);
        uint64_t v15 = *((void *)isa + 2);
      }
      while (v15);
      BOOL v17 = v38 != 0;
    }
    else
    {
      BOOL v17 = 0;
    }
    char v18 = PDFImageSetEmitDefinitions((uint64_t)a1[21]._private);
    char v19 = PDFImageSetEmitDefinitions((uint64_t)a1[22].super.isa);
    Class v20 = a1[25].super.isa;
    char v39 = 0;
    if (v20)
    {
      uint64_t v21 = *((void *)v20 + 2);
      if (v21)
      {
        BOOL v22 = v5;
        do
        {
          *((void *)v20 + 2) = 0;
          CFArrayRef v23 = *(const __CFArray **)(v21 + 8);
          v45.length = CFArrayGetCount(v23);
          v45.locatioCFIndex n = 0;
          CFArrayApplyFunction(v23, v45, (CFArrayApplierFunction)emitEStateDefinition, &v39);
          CGOrderedSetRelease((const void **)v21);
          uint64_t v21 = *((void *)v20 + 2);
        }
        while (v21);
        LOBYTE(v20) = v39 != 0;
        BOOL v5 = v22;
      }
      else
      {
        LOBYTE(v20) = 0;
      }
    }
    uint64_t v24 = a1[25]._private;
    char v40 = 0;
    if (v24 && (uint64_t v25 = *((void *)v24 + 2)) != 0)
    {
      BOOL v34 = v17;
      BOOL v26 = v13;
      BOOL v27 = v9;
      BOOL v28 = v5;
      do
      {
        *((void *)v24 + 2) = 0;
        CFArrayRef v29 = *(const __CFArray **)(v25 + 8);
        v46.length = CFArrayGetCount(v29);
        v46.locatioCFIndex n = 0;
        CFArrayApplyFunction(v29, v46, (CFArrayApplierFunction)emitPropertyListDefinition, &v40);
        CGOrderedSetRelease((const void **)v25);
        uint64_t v25 = *((void *)v24 + 2);
      }
      while (v25);
      BOOL v30 = v40 != 0;
      BOOL v5 = v28;
      BOOL v9 = v27;
      BOOL v13 = v26;
      BOOL v17 = v34;
    }
    else
    {
      BOOL v30 = 0;
    }
    char v31 = (v5 || v9 || v13 || v17) | v18 | v19 | v20 | v30;
    char v32 = PDFColorSpaceSetEmitDefinitions((uint64_t)a1[20]._private);
    BOOL result = PDFFunctionSetEmitDefinitions((BOOL)a1[23].super.isa);
  }
  while ((v31 & 1) != 0 || (v32 & 1) != 0 || result);
  return result;
}

void copy_catalog_entries(const void *a1, uint64_t a2, __CFDictionary *a3)
{
}

void emit_catalog_entries(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void PDFDocumentPrintNameReferencePair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFDocumentPrintf(a1, a2, a3, a4, a5, a6, a7, a8, a3);
  CFURLRef v10 = *(void **)(a1 + 520);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 280);
    PDFLinearizerRecordReference(v10, a4, v11);
  }
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataCreateXMPData");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataCreateXMPData");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataCreateXMPData");
  }
  _ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__12_ = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_13(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  _ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__11_ = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_12(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  _ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__10_ = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_11(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_9(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataSetValueWithPath");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataSetValueWithPath");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataSetValueWithPath");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataRegisterNamespaceForPrefix");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataRegisterNamespaceForPrefix");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataRegisterNamespaceForPrefix");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

void *___ZL24create_pdfa_xmp_metadataP11PDFDocument_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageMetadataCreateMutable");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageMetadataCreateMutable");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageMetadataCreateMutable");
  }
  create_pdfa_xmp_metadata(PDFDocument *)::f = result;
  return result;
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1ED09B510[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8fe180100IOZNS0_6__dtorINS0_8__traitsIJmNS_6vectorImNS_9allocatorImEEEEEEELNS0_6_TraitE1EE9__destroyB8fe180100EvEUlRT_E_JRNS0_6__baseILSD_1EJmSB_EEEEEEDcSF_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:fe180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<PDFDocumentEmitStructureTree(PDFDocument *)::$_0,PDFDocumentEmitStructureTree(PDFDocument *)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,std::vector<unsigned long>> const&>(uint64_t *a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *a1;
  PDFDocumentPrintf(*(void *)(*a1 + 8), (uint64_t)"[", a3, a4, a5, a6, a7, a8, v21);
  BOOL v17 = *a2;
  char v18 = a2[1];
  if (*a2 != v18)
  {
    do
    {
      uint64_t v19 = *(void *)(v10 + 8);
      if (*v17) {
        PDFDocumentPrintf(v19, (uint64_t)"%R", v11, v12, v13, v14, v15, v16, *v17);
      }
      else {
        PDFDocumentPrintf(v19, (uint64_t)"null", v11, v12, v13, v14, v15, v16, v22);
      }
      ++v17;
    }
    while (v17 != v18);
  }
  uint64_t v20 = *(void *)(v10 + 8);

  PDFDocumentPrintf(v20, (uint64_t)"]", v11, v12, v13, v14, v15, v16, a9);
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:fe180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<PDFDocumentEmitStructureTree(PDFDocument *)::$_0,PDFDocumentEmitStructureTree(PDFDocument *)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,std::vector<unsigned long>> const&>(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t **std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::__emplace_unique_key_args<long,std::pair<long const,std::variant<unsigned long,std::vector<unsigned long>>>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= a2) {
        return v7;
      }
      BOOL v5 = v7[1];
    }
    while (v5);
    uint64_t v6 = v7 + 1;
  }
  else
  {
    uint64_t v7 = a1 + 1;
  }
LABEL_10:
  uint64_t v12 = operator new(0x48uLL);
  v12[4] = *(void *)a3;
  *((unsigned char *)v12 + 40) = 0;
  *((_DWORD *)v12 + 16) = -1;
  uint64_t v9 = *(unsigned int *)(a3 + 32);
  if (v9 != -1)
  {
    ((void (*)(char *, void *, uint64_t))off_1ED09B520[v9])(&v14, v12 + 5, a3 + 8);
    *((_DWORD *)v12 + 16) = v9;
  }
  *uint64_t v12 = 0;
  v12[1] = 0;
  v12[2] = v7;
  *uint64_t v6 = v12;
  uint64_t v10 = (uint64_t *)**a1;
  uint64_t v11 = v12;
  if (v10)
  {
    *a1 = v10;
    uint64_t v11 = *v6;
  }
  std::__tree_balance_after_insert[abi:fe180100]<std::__tree_node_base<void *> *>(a1[1], v11);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v12;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8fe180100IOZNS0_6__ctorINS0_8__traitsIJmNS_6vectorImNS_9allocatorImEEEEEEEE19__generic_constructB8fe180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJmSB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  __n128 result = *a3;
  *a2 = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8fe180100IOZNS0_6__ctorINS0_8__traitsIJmNS_6vectorImNS_9allocatorImEEEEEEEE19__generic_constructB8fe180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJmSB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  BOOL v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  __n128 result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }
        else
        {
          v7 &= *(void *)&v2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void PDFDocumentPushContentStream(uint64_t a1, void *value)
{
  Mutable = *(__CFArray **)(a1 + 472);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *(void *)(a1 + 472) = Mutable;
  }

  CFArrayAppendValue(Mutable, value);
}

void PDFDocumentPopContentStream(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 472);
  if (v2)
  {
    CFIndex Count = CFArrayGetCount(v2);
    CFIndex v4 = Count - 1;
    if (Count >= 1)
    {
      BOOL v5 = *(__CFArray **)(a1 + 472);
      CFArrayRemoveValueAtIndex(v5, v4);
    }
  }
}

const void *PDFDocumentGetContentStream(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 472);
  if (!v2) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(v2);
  if (!Count) {
    return 0;
  }
  CFIndex v4 = Count - 1;
  CFArrayRef v5 = *(const __CFArray **)(a1 + 472);

  return CFArrayGetValueAtIndex(v5, v4);
}

uint64_t PDFDocumentSetOutputIntent(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  uint64_t result = CFDictionaryGetTypeID();
  if (v4 == result)
  {
    PDFOutputIntentRelease(*(void **)(a1 + 48));
    uint64_t result = (uint64_t)PDFOutputIntentCreate(a1, cf);
    *(void *)(a1 + 48) = result;
  }
  return result;
}

void PDFDocumentAddPDFXInfo(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFDictionaryGetTypeID())
  {
    PDFDocumentSetOutputIntent(a1, cf);
    Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"kCGPDFContextAuthor");
    if (Value) {
      PDFInfoSetValue(*(void *)(a1 + 64), @"kCGPDFContextAuthor", Value);
    }
    uint64_t v6 = CFDictionaryGetValue((CFDictionaryRef)cf, @"kCGPDFContextCreator");
    if (v6)
    {
      unint64_t v7 = v6;
      uint64_t v8 = *(void *)(a1 + 64);
      PDFInfoSetValue(v8, @"kCGPDFContextCreator", v7);
    }
  }
}

PDFDocumentPrivate *PDFDocumentPushTag(PDFDocument *a1, int a2, const __CFDictionary *a3)
{
  CFTypeID v4 = a1[34]._private;
  a1[34]._private = (PDFDocumentPrivate *)((char *)v4 + 1);
  TagNode = PDFDocumentCreateTagNode(a1, (uint64_t)v4, a2, a3, 1);
  uint64_t v6 = TagNode;
  if (a1[35]._private)
  {
    CFArrayRef isa = a1[35].super.isa;
    if (isa && CFArrayGetCount(isa))
    {
      CFIndex Count = CFArrayGetCount(a1[35].super.isa);
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1[35].super.isa, Count - 1);
      Value = (void *)CFDictionaryGetValue(ValueAtIndex, @"TagNodeChildren");
      if (!Value)
      {
        Value = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        CFDictionarySetValue(ValueAtIndex, @"TagNodeChildren", Value);
        CFRelease(Value);
      }
      CFDictionaryRemoveValue(ValueAtIndex, @"TagNodeMCID");
      CFArrayAppendValue((CFMutableArrayRef)Value, v6);
      CFRelease(v6);
    }
  }
  else
  {
    a1[35]._private = TagNode;
  }
  CFArrayAppendValue(a1[35].super.isa, v6);
  return v4;
}

__CFDictionary *PDFDocumentCreateTagNode(PDFDocument *a1, uint64_t a2, int a3, const __CFDictionary *a4, int a5)
{
  uint64_t valuePtr = a2;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CGCFDictionarySetNumber(Mutable, @"TagNodeMCID", kCFNumberSInt64Type, &valuePtr);
  CGCFDictionarySetInteger(Mutable, @"TagNodeType", a3);
  if (a4) {
    CFDictionarySetValue(Mutable, @"TagNodeProperties", a4);
  }
  Class isa = a1[30].super.isa;
  if (isa && a5) {
    CGCFDictionarySetInteger(Mutable, @"PageObjectNumber", *((_DWORD *)isa + 4));
  }
  return Mutable;
}

uint64_t StructureElementPathForMCID(const __CFDictionary *a1, uint64_t a2, __CFArray **a3)
{
  uint64_t v14 = -1;
  if (CGCFDictionaryGetNumber(a1, @"TagNodeMCID", kCFNumberSInt64Type, &v14) && v14 == a2)
  {
    CFMutableArrayRef Mutable = *a3;
    if (!*a3)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      *a3 = Mutable;
    }
    CFArrayAppendValue(Mutable, a1);
  }
  else
  {
    uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"TagNodeChildren");
    if (!result) {
      return result;
    }
    CFArrayRef v8 = (const __CFArray *)result;
    CFIndex Count = CFArrayGetCount((CFArrayRef)result);
    if (Count < 1) {
      return 0;
    }
    CFIndex v10 = Count;
    CFIndex v11 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v11);
      if (StructureElementPathForMCID(ValueAtIndex, a2, a3)) {
        break;
      }
      if (v10 == ++v11) {
        return 0;
      }
    }
    CFArrayInsertValueAtIndex(*a3, 0, a1);
  }
  return 1;
}

void PDFDocumentInsertStructureElementPath(PDFDocument *a1, CFArrayRef theArray)
{
  CFArrayRef v2 = theArray;
  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex v25 = Count - 1;
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFDictionaryRef TagNode = a1[35]._private;
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, 0);
    if (StructureElementsAreEqual(TagNode, ValueAtIndex, 0) && v5 != 1)
    {
      CFIndex v9 = 1;
      CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFIndex v24 = v5;
      do
      {
        CFDictionaryRef v10 = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v9);
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(TagNode, @"TagNodeChildren");
        if (Value)
        {
          CFArrayRef Mutable = Value;
          CFIndex v13 = CFArrayGetCount(Value);
          if (v13 >= 1)
          {
            CFIndex v14 = v13;
            CFArrayRef v15 = v2;
            uint64_t v16 = a1;
            CFIndex v17 = 0;
            while (1)
            {
              CFDictionaryRef TagNode = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v17);
              if (StructureElementsAreEqual(v10, TagNode, 1)) {
                break;
              }
              if (v14 == ++v17)
              {
                a1 = v16;
                CFArrayRef v2 = v15;
                CFIndex v5 = v24;
                goto LABEL_15;
              }
            }
            a1 = v16;
            CFArrayRef v2 = v15;
            CFIndex v5 = v24;
            if (TagNode) {
              goto LABEL_24;
            }
          }
        }
        else
        {
          CFArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
          CFDictionarySetValue(TagNode, @"TagNodeChildren", Mutable);
          CFRelease(Mutable);
        }
LABEL_15:
        uint64_t v29 = -1;
        CGCFDictionaryGetNumber(v10, @"TagNodeMCID", kCFNumberSInt64Type, &v29);
        uint64_t valuePtr = -1;
        CGCFDictionaryGetNumber(v10, @"TagNodeStructureID", kCFNumberSInt64Type, &valuePtr);
        uint64_t v27 = -1;
        CGCFDictionaryGetNumber(v10, @"TagNodeObjectRefID", kCFNumberSInt64Type, &v27);
        CGPDFTagType v26 = CGPDFTagTypeDiv;
        CGCFDictionaryGetInteger(v10, @"TagNodeType", &v26);
        CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue(v10, @"TagNodeProperties");
        CFDictionaryRef TagNode = PDFDocumentCreateTagNode(a1, v29, v26, v18, v9 == v25);
        CGCFDictionarySetNumber(TagNode, @"TagNodeStructureID", kCFNumberSInt64Type, &valuePtr);
        CGCFDictionarySetNumber(TagNode, @"TagNodeObjectRefID", kCFNumberSInt64Type, &v27);
        uint64_t v19 = CFDictionaryGetValue(v10, @"ID");
        if (v19) {
          CFDictionarySetValue(TagNode, @"ID", v19);
        }
        CFIndex v20 = CFArrayGetCount(Mutable);
        uint64_t v31 = -1;
        CGCFDictionaryGetNumber(TagNode, @"TagNodeStructureID", kCFNumberSInt64Type, &v31);
        if (v20 < 1)
        {
          CFIndex v21 = 0;
        }
        else
        {
          CFIndex v21 = 0;
          while (1)
          {
            uint64_t v30 = -1;
            CFDictionaryRef v22 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v21);
            CGCFDictionaryGetNumber(v22, @"TagNodeStructureID", kCFNumberSInt64Type, &v30);
            if (v30 >= v31) {
              break;
            }
            if (v20 == ++v21)
            {
              CFIndex v21 = v20;
              break;
            }
          }
        }
        CFArrayInsertValueAtIndex(Mutable, v21, TagNode);
        CFRelease(TagNode);
LABEL_24:
        ++v9;
      }
      while (v9 != v5);
    }
  }
}

uint64_t StructureElementsAreEqual(const __CFDictionary *a1, const __CFDictionary *a2, int a3)
{
  uint64_t v12 = -1;
  uint64_t result = CGCFDictionaryGetNumber(a1, @"TagNodeMCID", kCFNumberSInt64Type, &v12);
  if (result)
  {
    uint64_t v11 = -1;
    uint64_t result = CGCFDictionaryGetNumber(a2, @"TagNodeMCID", kCFNumberSInt64Type, &v11);
    if (result)
    {
      if (v12 != v11) {
        return 0;
      }
      int v10 = 104;
      uint64_t result = CGCFDictionaryGetInteger(a1, @"TagNodeType", &v10);
      if (result)
      {
        int v9 = 104;
        uint64_t result = CGCFDictionaryGetInteger(a2, @"TagNodeType", &v9);
        if (result)
        {
          if (v10 == v9)
          {
            if (!a3
              || (uint64_t v8 = -1, CGCFDictionaryGetNumber(a1, @"TagNodeStructureID", kCFNumberSInt64Type, &v8))
              && (uint64_t v7 = -1, CGCFDictionaryGetNumber(a2, @"TagNodeStructureID", kCFNumberSInt64Type, &v7))
              && v8 == v7)
            {
              LODWORD(v8) = -1;
              LODWORD(v7) = -1;
              if (!CGCFDictionaryGetInteger(a1, @"PageObjectNumber", &v8)
                || !CGCFDictionaryGetInteger(a2, @"PageObjectNumber", &v7)
                || v8 == v7)
              {
                return 1;
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void PDFDocumentBeginMarkedContentSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginMarkedContentSequence");
  }
  else if (*(void *)(a1 + 480))
  {
    CGPDFTagType v8 = (int)a2;
    ContentStreauint64_t m = (unsigned char ***)PDFDocumentGetContentStream(a1);
    Name = CGPDFTagTypeGetName(v8);
    PDFWriterPrintf(ContentStream[8], (uint64_t)"%s BMC", v11, v12, v13, v14, v15, v16, (uint64_t)Name);
    ContentStream[24] = (unsigned char **)((char *)ContentStream[24] + 1);
  }
  else
  {
    CGPostError((uint64_t)"%s: Cannot start a marked content sequence without first starting a page", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginMarkedContentSequence");
  }
}

uint64_t PDFDocumentBeginStructuralMarkedContentSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginStructuralMarkedContentSequence");
    return 0;
  }
  if (!*(void *)(a1 + 480))
  {
    CGPostError((uint64_t)"%s: Cannot start a structural marked content sequence without first starting a page", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginStructuralMarkedContentSequence");
    return 0;
  }
  CGPDFTagType v11 = (int)a2;
  ContentStreauint64_t m = PDFDocumentGetContentStream(a1);
  if ((ContentStream[23] & 0x8000000000000000) == 0)
  {
    CGPostError((uint64_t)"%s: Cannot start a structural marked content sequence once one has already started", v13, v14, v15, v16, v17, v18, v19, (char)"PDFContentStreamBeginStructuralMarkedContentSequence");
    return 0;
  }
  CFIndex v20 = ContentStream;
  CFIndex v21 = *(void **)(a1 + 480);
  Name = CGPDFTagTypeGetName(v11);
  uint64_t v23 = CGPDFMarkedContentItemCreate();
  uint64_t v8 = v23;
  if (v23) {
    PDFMarkedContentItem::PDFMarkedContentItem(v23 + 16, 0, v21);
  }
  PDFWriterPrintf((unsigned char **)v20[8], (uint64_t)"%s << /MCID %d >> BDC", v24, v25, v26, v27, v28, v29, (uint64_t)Name);
  uint64_t v30 = v20[24];
  v20[23] = v30;
  v20[24] = v30 + 1;
  return v8;
}

void PDFDocumentEndMarkedContentSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEndMarkedContentSequence");
  }
  else
  {
    ContentStreauint64_t m = (unsigned char ***)PDFDocumentGetContentStream(a1);
    if ((uint64_t)ContentStream[24] <= 0)
    {
      CGPostError((uint64_t)"%s: End marked content sequence does not have a matching begin", v9, v10, v11, v12, v13, v14, v15, (char)"PDFContentStreamEndMarkedContentSequence");
    }
    else
    {
      uint64_t v16 = ContentStream;
      PDFWriterPrintf(ContentStream[8], (uint64_t)"EMC", v10, v11, v12, v13, v14, v15, v19);
      uint64_t v17 = v16[23];
      uint64_t v18 = (uint64_t)v16[24] - 1;
      v16[24] = (unsigned char **)v18;
      if (v17 == (unsigned char **)v18) {
        v16[23] = (unsigned char **)-1;
      }
    }
  }
}

uint64_t PDFDocumentBeginObjectReference(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[70])
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginObjectReference");
    return 0;
  }
  uint64_t v10 = a1[60];
  if (!v10)
  {
    CGPostError((uint64_t)"%s: Cannot start an object reference without first starting a page", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginObjectReference");
    return 0;
  }
  if (a1[73])
  {
    CGPostError((uint64_t)"%s: Cannot start another object reference without ending the first one", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginObjectReference");
    return 0;
  }
  uint64_t result = CGPDFMarkedContentItemCreate();
  if (result)
  {
    *(_DWORD *)(result + 16) = 1;
    *(void *)(result + 24) = *(void *)(v10 + 16);
    *(void *)(result + 48) = 0;
    *(_OWORD *)(result + 32) = xmmword_1850CDBD0;
  }
  a1[73] = result;
  return result;
}

void PDFDocumentEndObjectReference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEndObjectReference");
  }
  else
  {
    if (!*(void *)(a1 + 584)) {
      CGPostError((uint64_t)"%s: Cannot end an object reference without first starting one", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEndObjectReference");
    }
    *(void *)(a1 + 584) = 0;
  }
}

uint64_t PDFDocumentAddStructureTreeRootChild(void *a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[70])
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", (uint64_t)cf, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentAddStructureTreeRootChild");
    return 1000;
  }
  else
  {
    if (cf) {
      CFTypeRef v10 = CFRetain(cf);
    }
    else {
      CFTypeRef v10 = 0;
    }
    uint64_t v11 = (void *)a1[76];
    unint64_t v12 = a1[77];
    if ((unint64_t)v11 >= v12)
    {
      uint64_t v13 = (void *)a1[75];
      uint64_t v14 = v11 - v13;
      unint64_t v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 61) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v16 = v12 - (void)v13;
      if (v16 >> 2 > v15) {
        unint64_t v15 = v16 >> 2;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17)
      {
        if (v17 >> 61) {
          std::__throw_bad_array_new_length[abi:fe180100]();
        }
        uint64_t v18 = (char *)operator new(8 * v17);
      }
      else
      {
        uint64_t v18 = 0;
      }
      uint64_t v19 = &v18[8 * v14];
      *(void *)uint64_t v19 = v10;
      for (i = v19 + 8; v11 != v13; *uint64_t v11 = 0)
      {
        uint64_t v21 = *--v11;
        *((void *)v19 - 1) = v21;
        v19 -= 8;
      }
      long long v22 = *(_OWORD *)(a1 + 75);
      a1[75] = v19;
      a1[76] = i;
      a1[77] = &v18[8 * v17];
      uint64_t v23 = (char *)*((void *)&v22 + 1);
      uint64_t v24 = (char *)v22;
      while (v23 != v24)
      {
        uint64_t v26 = (const void *)*((void *)v23 - 1);
        v23 -= 8;
        uint64_t v25 = v26;
        if (v26) {
          CFRelease(v25);
        }
      }
      if (v24) {
        operator delete(v24);
      }
      a1[76] = i;
    }
    else
    {
      *uint64_t v11 = v10;
      a1[76] = v11 + 1;
    }
    return 0;
  }
}

void sub_184E48BCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFStructureElement *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void PDFDocumentBeginPage(void *a1, const __CFDictionary *a2)
{
  uint8x8_t v3 = (CFDictionaryRef *)a1[57];
  if (v3)
  {
    CFIndex v5 = (char *)v3[1];
    v3[1] = (CFDictionaryRef)(v5 + 1);
    ObjectNumberForPageNumber = PDFPageTree::getObjectNumberForPageNumber(v3, v5);
    if (ObjectNumberForPageNumber)
    {
      CGFloat v7 = *(double *)&ObjectNumberForPageNumber;
      PDFPageTree::addNode((PDFPageTree *)&v57, v3, (uint64_t)ObjectNumberForPageNumber, 1);
      if (v57)
      {
        CFDictionaryRef v8 = *v3;
        CFDictionaryRef v9 = *v57;
        uint8x8_t v3 = (CFDictionaryRef *)malloc_type_calloc(1uLL, 0x68uLL, 0x33BCE901uLL);
        __CFSetLastAllocationEventName();
        if (v3)
        {
          *(_DWORD *)uint8x8_t v3 = 1;
          v3[1] = v8;
          *((CGFloat *)v3 + 2) = v7;
          v3[3] = v9;
          v3[5] = 0;
          long long value = 0;
          if (a2)
          {
            if (CFDictionaryGetValueIfPresent(a2, @"StructParents", (const void **)&value))
            {
              valuePtr[0] = 0;
              CFNumberGetValue((CFNumberRef)value, kCFNumberLongType, valuePtr);
              CGFloat v10 = *(double *)valuePtr;
              v3[12] = (CFDictionaryRef)valuePtr[0];
              if (v8)
              {
                uint64_t v11 = (float *)*((void *)v8 + 38);
                context.origin.x = v10;
                context.origin.double y = v7;
                std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(v11, *(unint64_t *)&v10, &context);
              }
            }
            else
            {
              v3[12] = (CFDictionaryRef)-1;
            }
            a2 = (const __CFDictionary *)CFRetain(a2);
          }
          else
          {
            v3[12] = (CFDictionaryRef)-1;
          }
          v3[6] = a2;
          v3[9] = 0;
          v3[11] = 0;
          CFTypeRef v65 = 0;
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (CGCFDictionaryGetCFTypeRef(a2, @"CGPDFContextPageApplicationData", TypeID, (uint64_t *)&v65))
          {
            CFDictionaryRef v13 = (const __CFDictionary *)CFRetain(v65);
            v3[7] = v13;
            size_t Count = CFDictionaryGetCount(v13);
            CFDictionaryRef v15 = (const __CFDictionary *)malloc_type_calloc(Count, 8uLL, 0x33BCE901uLL);
            __CFSetLastAllocationEventName();
            v3[8] = v15;
            valuePtr[0] = 0;
            valuePtr[1] = valuePtr;
            valuePtr[2] = 0x2000000000;
            int v64 = 0;
            CFDictionaryRef v16 = v3[7];
            *(void *)&context.origin.x = MEMORY[0x1E4F143A8];
            *(void *)&context.origin.double y = 0x40000000;
            *(void *)&context.size.double width = __init_appl_data_block_invoke;
            *(void *)&context.size.double height = &unk_1E52CE850;
            uint64_t v61 = valuePtr;
            uint64_t v62 = v3;
            CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)call_dict_block, &context);
            _Block_object_dispose(valuePtr, 8);
          }
        }
      }
      else
      {
        uint8x8_t v3 = 0;
      }
      if (v58) {
        std::__shared_weak_count::__release_shared[abi:fe180100](v58);
      }
    }
    else
    {
      uint8x8_t v3 = 0;
    }
  }
  a1[60] = v3;
  unint64_t v17 = (void *)a1[65];
  if (v17)
  {
    v17[1] = v3;
    if (v3) {
      CFDictionaryRef v18 = v3[2];
    }
    else {
      CFDictionaryRef v18 = 0;
    }
    CFIndex v20 = (CFDictionaryRef *)v17[7];
    unint64_t v19 = v17[8];
    if ((unint64_t)v20 >= v19)
    {
      long long v22 = (void *)v17[6];
      unint64_t v23 = 0x8E38E38E38E38E39 * (v20 - (CFDictionaryRef *)v22) + 1;
      if (v23 > 0x38E38E38E38E38ELL) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      unint64_t v24 = 0x8E38E38E38E38E39 * ((uint64_t)(v19 - (void)v22) >> 3);
      if (2 * v24 > v23) {
        unint64_t v23 = 2 * v24;
      }
      if (v24 >= 0x1C71C71C71C71C7) {
        unint64_t v25 = 0x38E38E38E38E38ELL;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        if (v25 > 0x38E38E38E38E38ELL) {
          std::__throw_bad_array_new_length[abi:fe180100]();
        }
        uint64_t v26 = (char *)operator new(72 * v25);
      }
      else
      {
        uint64_t v26 = 0;
      }
      uint64_t v27 = &v26[8 * (v20 - (CFDictionaryRef *)v22)];
      *(void *)uint64_t v27 = v18;
      *(_OWORD *)(v27 + 8) = 0u;
      *(_OWORD *)(v27 + 24) = 0u;
      uint64_t v28 = &v26[72 * v25];
      *(_OWORD *)(v27 + 40) = 0u;
      *(_OWORD *)(v27 + 56) = 0u;
      uint64_t v21 = v27 + 72;
      if (v20 == v22)
      {
        v17[6] = v27;
        v17[7] = v21;
        v17[8] = v28;
        if (!v20) {
          goto LABEL_43;
        }
      }
      else
      {
        do
        {
          uint64_t v29 = (uint64_t)*(v20 - 7);
          *(_OWORD *)(v27 - 72) = *(_OWORD *)(v20 - 9);
          *((void *)v27 - 7) = v29;
          *((void *)v27 - 6) = 0;
          *((void *)v27 - 5) = 0;
          *((void *)v27 - 4) = 0;
          *((_OWORD *)v27 - 3) = *((_OWORD *)v20 - 3);
          *((void *)v27 - 4) = *(v20 - 4);
          *(v20 - 6) = 0;
          *(v20 - 5) = 0;
          *(v20 - 4) = 0;
          long long v30 = *(_OWORD *)(v20 - 3);
          *((void *)v27 - 1) = *(v20 - 1);
          *(_OWORD *)(v27 - 24) = v30;
          v27 -= 72;
          v20 -= 9;
        }
        while (v20 != v22);
        uint64_t v31 = (CFDictionaryRef *)v17[6];
        CFIndex v20 = (CFDictionaryRef *)v17[7];
        v17[6] = v27;
        v17[7] = v21;
        v17[8] = v28;
        if (v20 != v31)
        {
          do
          {
            CFDictionaryRef v32 = *(v20 - 6);
            if (v32)
            {
              *(v20 - 5) = v32;
              operator delete(v32);
            }
            v20 -= 9;
          }
          while (v20 != v31);
          CFIndex v20 = v31;
        }
        if (!v20) {
          goto LABEL_43;
        }
      }
      operator delete(v20);
    }
    else
    {
      *CFIndex v20 = v18;
      *(_OWORD *)(v20 + 1) = 0u;
      *(_OWORD *)(v20 + 3) = 0u;
      *(_OWORD *)(v20 + 5) = 0u;
      *(_OWORD *)(v20 + 7) = 0u;
      uint64_t v21 = v20 + 9;
    }
LABEL_43:
    v17[7] = v21;
    uint8x8_t v3 = (CFDictionaryRef *)a1[60];
  }
  memset(&context, 0, sizeof(context));
  if (!CGCFDictionaryGetRect(v3[6], @"MediaBox", (UInt8 *)&context))
  {
    CFDictionaryRef v33 = v3[1];
    double v35 = *((double *)v33 + 12);
    double v36 = *((double *)v33 + 13);
    uint64_t v34 = (uint64_t)v33 + 96;
    if (v35 != INFINITY && v36 != INFINITY)
    {
      CGSize v38 = *(CGSize *)(v34 + 16);
      context.origiCFIndex n = *(CGPoint *)v34;
      context.size = v38;
    }
  }
  char v39 = PDFContentStreamCreate((uint64_t)v3[1], &context);
  v3[5] = (CFDictionaryRef)v39;
  if (v39)
  {
    PDFContentStreamBegin((uint64_t)v39, v40, v41, v42, v43, v44, v45, v46, v55);
    PDFContentStreamBeginData((uint64_t *)v3[5], v47, v48, v49, v50, v51, v52, v53, v56);
    CFDictionaryRef v54 = v3[5];
  }
  else
  {
    CFDictionaryRef v54 = 0;
  }

  PDFDocumentPushContentStream((uint64_t)a1, v54);
}

void sub_184E49070(void *a1, int a2)
{
  uint8x8_t v3 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    (*(void (**)(void *))(*(void *)v3 + 16))(v3);
    pdf_error("%s caught exception: %s");
  }
  else
  {
    pdf_error("%s caught an unknown exception");
  }
  __cxa_end_catch();
  JUMPOUT(0x184E48FA8);
}

void PDFDocumentEndPage(uint64_t a1)
{
  CFArrayRef v2 = *(void **)(a1 + 480);
  *(void *)(a1 + 480) = 0;
  if (!v2) {
    goto LABEL_107;
  }
  PDFDocumentPopContentStream(a1);
  PDFContentStreamEndData(*((void *)v2 + 5), v3, v4, v5, v6, v7, v8, v9);
  PDFContentStreamEnd(*((CFDataRef **)v2 + 5));
  PDFDocumentBeginObject(*((void *)v2 + 1), *((void *)v2 + 2), v10, v11, v12, v13, v14, v15);
  PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"<<", v16, v17, v18, v19, v20, v21, v202);
  PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/Type /Page", v22, v23, v24, v25, v26, v27, v203);
  PDFDocumentPrintPageParentReference(*((void *)v2 + 1), (uint64_t)"/Parent %R", *((void *)v2 + 3), v28, v29, v30, v31, v32);
  if (*((void *)v2 + 12) != -1) {
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/StructParents %d", v33, v34, v35, v36, v37, v38, *((void *)v2 + 12));
  }
  uint64_t v39 = *((void *)v2 + 5);
  if (v39)
  {
    uint64_t v40 = *(void *)(v39 + 112);
    BOOL v41 = v40 == 0;
    if (v40)
    {
      PDFDocumentPrintReference(*((void *)v2 + 1), (uint64_t)"/Resources %R", *(void *)(v40 + 16), v34, v35, v36, v37, v38);
      uint64_t v39 = *((void *)v2 + 5);
      unsigned int v207 = 0;
      if (!v39)
      {
        uint64_t v42 = 0;
        goto LABEL_11;
      }
    }
    else
    {
      unsigned int v207 = 0;
    }
    uint64_t v42 = *(void *)(v39 + 8);
  }
  else
  {
    uint64_t v40 = 0;
    uint64_t v42 = 0;
    unsigned int v207 = 0;
    BOOL v41 = 1;
  }
LABEL_11:
  PDFDocumentPrintReference(*((void *)v2 + 1), (uint64_t)"/Contents %R", v42, v34, v35, v36, v37, v38);
  uint64_t v43 = *((void *)v2 + 1);
  if (PDFOutputIntentGetIsX3(*(unsigned char **)(v43 + 48)))
  {
    long long v212 = 0uLL;
    long long v213 = 0uLL;
    int v44 = *(unsigned __int8 *)(v43 + 90);
    if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"MediaBox", (UInt8 *)&v212))
    {
      uint64_t v51 = *((void *)v2 + 1);
    }
    else
    {
      if (!v44)
      {
        if (!CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"CropBox", (UInt8 *)&v212)) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
      uint64_t v51 = *((void *)v2 + 1);
      BOOL v82 = *(double *)(v51 + 96) == INFINITY || *(double *)(v51 + 104) == INFINITY;
      if (v82)
      {
        if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"CropBox", (UInt8 *)&v212)) {
          goto LABEL_41;
        }
LABEL_36:
        uint64_t v90 = *((void *)v2 + 1);
        double v92 = *(double *)(v90 + 128);
        double v93 = *(double *)(v90 + 136);
        uint64_t v91 = (long long *)(v90 + 128);
        if (v92 != INFINITY && v93 != INFINITY)
        {
          long long v95 = v91[1];
          long long v212 = *v91;
          long long v213 = v95;
          goto LABEL_41;
        }
LABEL_42:
        if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"BleedBox", (UInt8 *)&v212)) {
          PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/BleedBox %r", v96, v97, v98, v99, v100, v101, (uint64_t)&v212);
        }
        if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"TrimBox", (UInt8 *)&v212))
        {
          PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/TrimBox %r", v102, v103, v104, v105, v106, v107, (uint64_t)&v212);
          goto LABEL_64;
        }
        BOOL Rect = CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"ArtBox", (UInt8 *)&v212);
        uint64_t v115 = *((void *)v2 + 1);
        if (Rect) {
          goto LABEL_47;
        }
        if (*(double *)(v115 + 192) == INFINITY || *(double *)(v115 + 200) == INFINITY)
        {
          if (*(double *)(v115 + 224) != INFINITY && *(double *)(v115 + 232) != INFINITY)
          {
            long long v119 = *(_OWORD *)(v115 + 240);
            long long v212 = *(_OWORD *)(v115 + 224);
            long long v213 = v119;
LABEL_47:
            uint64_t v116 = "/ArtBox %r";
LABEL_63:
            PDFDocumentPrintf(v115, (uint64_t)v116, v109, v110, v111, v112, v113, v114, (uint64_t)&v212);
            goto LABEL_64;
          }
          long long context = 0u;
          long long v209 = 0u;
          if (!CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"CropBox", (UInt8 *)&context)
            && !CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"MediaBox", (UInt8 *)&context))
          {
            if ((uint64_t v120 = (double *)*((void *)v2 + 1), v121 = v120 + 16, v120[16] != INFINITY) && v120[17] != INFINITY
              || (v123 = v120[12], v122 = v120 + 12, v123 != INFINITY) && (uint64_t v121 = v122, v122[1] != INFINITY))
            {
              long long v124 = *((_OWORD *)v121 + 1);
              long long context = *(_OWORD *)v121;
              long long v209 = v124;
            }
          }
          long long v117 = context;
          long long v118 = v209;
        }
        else
        {
          long long v117 = *(_OWORD *)(v115 + 192);
          long long v118 = *(_OWORD *)(v115 + 208);
        }
        long long v212 = v117;
        long long v213 = v118;
        uint64_t v116 = "/TrimBox %r";
        goto LABEL_63;
      }
      long long v89 = *(_OWORD *)(v51 + 112);
      long long v212 = *(_OWORD *)(v51 + 96);
      long long v213 = v89;
    }
    PDFDocumentPrintf(v51, (uint64_t)"/MediaBox %r", v45, v46, v47, v48, v49, v50, (uint64_t)&v212);
    if (!CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"CropBox", (UInt8 *)&v212))
    {
      if (!v44) {
        goto LABEL_42;
      }
      goto LABEL_36;
    }
LABEL_41:
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/CropBox %r", v83, v84, v85, v86, v87, v88, (uint64_t)&v212);
    goto LABEL_42;
  }
  long long context = 0uLL;
  long long v209 = 0uLL;
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"MediaBox", (UInt8 *)&context)) {
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/MediaBox %r", v52, v53, v54, v55, v56, v57, (uint64_t)&context);
  }
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"CropBox", (UInt8 *)&context)) {
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/CropBox %r", v58, v59, v60, v61, v62, v63, (uint64_t)&context);
  }
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"BleedBox", (UInt8 *)&context)) {
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/BleedBox %r", v64, v65, v66, v67, v68, v69, (uint64_t)&context);
  }
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"TrimBox", (UInt8 *)&context)) {
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/TrimBox %r", v70, v71, v72, v73, v74, v75, (uint64_t)&context);
  }
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), @"ArtBox", (UInt8 *)&context)) {
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/ArtBox %r", v76, v77, v78, v79, v80, v81, (uint64_t)&context);
  }
LABEL_64:
  if (CGCFDictionaryGetInteger(*((CFDictionaryRef *)v2 + 6), @"Rotate", &v207)) {
    PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)"/Rotate %d", v125, v126, v127, v128, v129, v130, v207);
  }
  uint64_t v131 = *((void *)v2 + 4);
  if (v131) {
    PDFDocumentPrintReference(*((void *)v2 + 1), (uint64_t)"/Annots %R", *(void *)(v131 + 8), v126, v127, v128, v129, v130);
  }
  uint64_t v132 = (CGContext *)*((void *)v2 + 9);
  if (!v132) {
    goto LABEL_83;
  }
  CGImageRef Image = CGBitmapContextCreateImage(v132);
  uint64_t v134 = (const void *)*((void *)v2 + 9);
  if (v134) {
    CFRelease(v134);
  }
  *((void *)v2 + 9) = 0;
  CFDataRef Mutable = CFDataCreateMutable(0, 0);
  if (emit_thumbnail_predicate != -1) {
    dispatch_once(&emit_thumbnail_predicate, &__block_literal_global_22210);
  }
  uint64_t v136 = (const void *)emit_thumbnail_f(Mutable, @"public.jpeg", 1, 0);
  if (emit_thumbnail_predicate_26 != -1) {
    dispatch_once(&emit_thumbnail_predicate_26, &__block_literal_global_29_22212);
  }
  emit_thumbnail_f_25(v136, Image, 0);
  if (Image) {
    CFRelease(Image);
  }
  if (emit_thumbnail_predicate_32 != -1) {
    dispatch_once(&emit_thumbnail_predicate_32, &__block_literal_global_35_22213);
  }
  emit_thumbnail_f_31(v136);
  CFRelease(v136);
  uint64_t v137 = CGDataProviderCreateWithCFData(Mutable);
  CFRelease(Mutable);
  CGImageRef v138 = CGImageCreateWithJPEGDataProvider2((uint64_t)v137, 0, 0, 0, 0);
  CGDataProviderRelease(v137);
  uint64_t v144 = *((void *)PDFDocumentAddImage(*((void *)v2 + 1), (uint64_t)v138, 1u) + 2);
  if (!v144)
  {
    uint64_t v145 = 0;
    if (!v138) {
      goto LABEL_82;
    }
    goto LABEL_81;
  }
  uint64_t v145 = *(void *)(v144 + 8);
  if (v138) {
LABEL_81:
  }
    CFRelease(v138);
LABEL_82:
  PDFDocumentPrintReference(*((void *)v2 + 1), (uint64_t)"/Thumb %R", v145, v139, v140, v141, v142, v143);
LABEL_83:
  CFDictionaryRef v146 = (const __CFDictionary *)*((void *)v2 + 7);
  if (v146 && *((void *)v2 + 8))
  {
    *(void *)&long long v212 = 0;
    *((void *)&v212 + 1) = &v212;
    *(void *)&long long v213 = 0x2000000000;
    DWORD2(v213) = 0;
    *(void *)&long long context = MEMORY[0x1E4F143A8];
    *((void *)&context + 1) = 0x40000000;
    *(void *)&long long v209 = __emit_application_data_block_invoke;
    *((void *)&v209 + 1) = &unk_1E52CE8F8;
    uint64_t v210 = &v212;
    uint64_t v211 = v2;
    CFDictionaryApplyFunction(v146, (CFDictionaryApplierFunction)call_dict_block, &context);
    _Block_object_dispose(&v212, 8);
  }
  PDFDocumentPrintf(*((void *)v2 + 1), (uint64_t)">>", v125, v126, v127, v128, v129, v130, v204);
  PDFDocumentEndObject(*((void *)v2 + 1), v147, v148, v149, v150, v151, v152, v153);
  if (!v41) {
    PDFResourceSetEmit(v40, v154, v155, v156, v157, v158, v159, v160);
  }
  if (v131)
  {
    PDFDocumentBeginObject(*(void *)(v131 + 16), *(void *)(v131 + 8), v155, v156, v157, v158, v159, v160);
    PDFDocumentPrintf(*(void *)(v131 + 16), (uint64_t)"[", v161, v162, v163, v164, v165, v166, v205);
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v131 + 32));
    if (Count)
    {
      CFIndex v174 = Count;
      for (CFIndex i = 0; i != v174; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v131 + 32), i);
        PDFDocumentPrintReference(*(void *)(v131 + 16), (uint64_t)"%R", (uint64_t)ValueAtIndex, v177, v178, v179, v180, v181);
      }
    }
    PDFDocumentPrintf(*(void *)(v131 + 16), (uint64_t)"]", v168, v169, v170, v171, v172, v173, v206);
    PDFDocumentEndObject(*(void *)(v131 + 16), v182, v183, v184, v185, v186, v187, v188);
  }
  CFDictionaryRef v189 = (const __CFDictionary *)*((void *)v2 + 7);
  if (v189 && *((void *)v2 + 8))
  {
    *(void *)&long long v212 = 0;
    *((void *)&v212 + 1) = &v212;
    *(void *)&long long v213 = 0x2000000000;
    DWORD2(v213) = 0;
    *(void *)&long long context = MEMORY[0x1E4F143A8];
    *((void *)&context + 1) = 0x40000000;
    *(void *)&long long v209 = __emit_application_data_streams_block_invoke;
    *((void *)&v209 + 1) = &unk_1E52CE920;
    uint64_t v210 = &v212;
    uint64_t v211 = v2;
    CFDictionaryApplyFunction(v189, (CFDictionaryApplierFunction)call_dict_block, &context);
    _Block_object_dispose(&v212, 8);
  }
  emit_page_resources((PDFDocument *)a1);
  uint64_t v197 = *(void *)(a1 + 520);
  if (v197) {
    *(void *)(v197 + 8) = 0;
  }
  BOOL v82 = (*(_DWORD *)v2)-- == 1;
  if (v82)
  {
    PDFContentStreamRelease(*((void *)v2 + 5), v190, v191, v192, v193, v194, v195, v196);
    PDFAnnotationSetRelease(*((void **)v2 + 4));
    uint64_t v198 = (const void *)*((void *)v2 + 6);
    if (v198) {
      CFRelease(v198);
    }
    uint64_t v199 = (const void *)*((void *)v2 + 7);
    if (v199) {
      CFRelease(v199);
    }
    uint64_t v200 = (const void *)*((void *)v2 + 9);
    if (v200) {
      CFRelease(v200);
    }
    free(*((void **)v2 + 8));
    free(v2);
  }
LABEL_107:
  uint64_t v201 = *(const void **)(a1 + 536);
  if (v201)
  {
    CFRelease(v201);
    *(void *)(a1 + 536) = 0;
  }
  *(_DWORD *)(a1 + 544) = 0;
}

void PDFDocumentSetPageRedactionPath(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    CFTypeRef v4 = *(CFTypeRef *)(a1 + 488);
    if (v4 != cf)
    {
      if (v4) {
        CFRelease(v4);
      }
      if (cf) {
        CFRetain(cf);
      }
      *(void *)(a1 + 488) = cf;
    }
  }
}

void *PDFDocumentSetParentTree(void *result, void *cf)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (void *)result[62];
    if (result != cf)
    {
      if (result) {
        CFRelease(result);
      }
      uint64_t result = CFRetain(cf);
      v3[62] = result;
    }
  }
  return result;
}

void *PDFDocumentSetIDTree(void *result, void *cf)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (void *)result[63];
    if (result != cf)
    {
      if (result) {
        CFRelease(result);
      }
      uint64_t result = CFRetain(cf);
      v3[63] = result;
    }
  }
  return result;
}

void *PDFDocumentSetPageTagStructureTree(void *result, void *cf)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (void *)result[64];
    if (result != cf)
    {
      if (result) {
        CFRelease(result);
      }
      uint64_t result = CFRetain(cf);
      v3[64] = result;
    }
  }
  return result;
}

void *PDFDocumentAddColorSpace(uint64_t a1, void *key)
{
  uint64_t v3 = *(void **)(a1 + 328);
  if (!v3)
  {
    uint64_t v3 = malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    *(void *)uint64_t v3 = a1;
    *((void *)v3 + 1) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, &color_space_callbacks);
    *((void *)v3 + 2) = 0;
    *((_DWORD *)v3 + 6) = 0;
    *(void *)(a1 + 328) = v3;
  }
  if (v3) {
    BOOL v5 = key == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0;
  }
  CFArrayRef Value = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)v3 + 1), key);
  uint64_t v6 = Value;
  if (!Value)
  {
    uint64_t v8 = *(void *)v3;
    int v9 = *((_DWORD *)v3 + 6) + 1;
    *((_DWORD *)v3 + 6) = v9;
    uint64_t v6 = PDFColorSpaceCreate(v8, key, v9);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)v3 + 1), key, v6);
    uint64_t v10 = (const void **)*((void *)v3 + 2);
    if (!v10)
    {
      uint64_t v10 = CGOrderedSetCreate();
      *((void *)v3 + 2) = v10;
    }
    CGOrderedSetAddValue((CFSetRef *)v10, v6);
    PDFColorSpaceRelease((CGColorSpaceRef *)v6);
  }
  return v6;
}

PDFDocumentPrivate *PDFDocumentResolveColorSpace(uint64_t a1, CGColorSpace *a2)
{
  CGColorSpaceRef DeviceCMYK = a2;
  if (a2 && *(unsigned char *)(*((void *)a2 + 3) + 9)) {
    return DeviceCMYK;
  }
  int Type = CGColorSpaceGetType(a2);
  if (Type == 2)
  {
    if (*(unsigned char *)(a1 + 91))
    {
      CGColorSpaceRef DeviceCMYK = *(CGColorSpaceRef *)(a1 + 448);
      if (!DeviceCMYK)
      {
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
        *(void *)(a1 + 448) = DeviceCMYK;
        if (!DeviceCMYK)
        {
          CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
          *(void *)(a1 + 448) = DeviceCMYK;
        }
      }
    }
    return DeviceCMYK;
  }
  if (Type != 1)
  {
    if (!Type)
    {
      CGColorSpaceRef DeviceCMYK = *(CGColorSpaceRef *)(a1 + 432);
      if (!DeviceCMYK)
      {
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
        *(void *)(a1 + 432) = DeviceCMYK;
        if (!DeviceCMYK)
        {
          CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceGray();
          *(void *)(a1 + 432) = DeviceCMYK;
        }
      }
    }
    return DeviceCMYK;
  }

  return get_default_rgb_color_space((PDFDocument *)a1);
}

void PDFDocumentAddAnnotationToPage(PDFDocument *a1, uint64_t a2, const __CFDictionary *a3)
{
  MutableCopdouble y = CFDictionaryCreateMutableCopy(0, 0, a3);
  v21[1] = (uint64_t)MutableCopy;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"ObjectNumber");
  CFDictionaryRemoveValue(MutableCopy, @"ObjectNumber");
  uint64_t v8 = *(void **)(a2 + 32);
  if (!v8)
  {
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v8 = malloc_type_calloc(1uLL, 0x28uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v8)
    {
      *(_DWORD *)uint64_t v8 = 1;
      v8[2] = v9;
      v8[1] = PDFXRefTableAddObject(*(void **)(v9 + 464));
      v8[3] = *(void *)(v9 + 40);
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
      v8[4] = Mutable;
      if (!Mutable)
      {
        PDFAnnotationSetRelease(v8);
        uint64_t v8 = 0;
      }
    }
    *(void *)(a2 + 32) = v8;
  }
  uint64_t v11 = -1;
  if (v8 && MutableCopy)
  {
    uint64_t v12 = *(void *)(v8[2] + 584);
    if (v12
      && (CFIndex Count = CFDictionaryGetCount(MutableCopy),
          (CFMutableDictionaryRef v14 = CFDictionaryCreateMutableCopy(0, Count + 1, MutableCopy)) != 0))
    {
      uint64_t v15 = v14;
      uint64_t v16 = PDFMetaSetAddDictionary(v8[3], v14);
      uint64_t v11 = (uint64_t)v16;
      if (*(_DWORD *)(v12 + 16) == 1 && !*(void *)(v12 + 32))
      {
        uint64_t v17 = v8[2];
        *(void *)(v12 + 32) = v16;
        uint64_t v18 = *(void *)(v17 + 592);
        *(void *)(v17 + 592) = v18 + 1;
        *(void *)(v12 + 40) = v18;
        if (v18 != -1) {
          CGCFDictionarySetLongInteger(v15, @"/StructParent", v18);
        }
      }
      CFRelease(v15);
    }
    else
    {
      uint64_t v11 = (uint64_t)PDFMetaSetAddDictionary(v8[3], MutableCopy);
    }
    CFArrayAppendValue((CFMutableArrayRef)v8[4], (const void *)v11);
  }
  if (a1[32].super.isa)
  {
    if (Value)
    {
      v21[0] = 0;
      CFNumberGetValue(Value, kCFNumberLongType, v21);
      Class isa = (float *)a1[18].super.isa;
      *(void *)&theArradouble y = v21[0];
      *((void *)&theArray + 1) = v11;
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(isa, v21[0], &theArray);
      *(void *)&theArradouble y = 0;
      StructureElementPathForObjectRefID(a1[32].super.isa, v21[0], (__CFArray **)&theArray);
      CFArrayRef v20 = (const __CFArray *)theArray;
      if ((void)theArray)
      {
        if (CFArrayGetCount((CFArrayRef)theArray) >= 1) {
          PDFDocumentInsertStructureElementPath(a1, v20);
        }
      }
    }
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

void sub_184E49F10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t StructureElementPathForObjectRefID(const __CFDictionary *a1, uint64_t a2, __CFArray **a3)
{
  uint64_t v14 = -1;
  if (CGCFDictionaryGetNumber(a1, @"TagNodeObjectRefID", kCFNumberSInt64Type, &v14) && v14 == a2)
  {
    CFMutableArrayRef Mutable = *a3;
    if (!*a3)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      *a3 = Mutable;
    }
    CFArrayAppendValue(Mutable, a1);
  }
  else
  {
    uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"TagNodeChildren");
    if (!result) {
      return result;
    }
    CFArrayRef v8 = (const __CFArray *)result;
    CFIndex Count = CFArrayGetCount((CFArrayRef)result);
    if (Count < 1) {
      return 0;
    }
    CFIndex v10 = Count;
    CFIndex v11 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v11);
      if (StructureElementPathForObjectRefID(ValueAtIndex, a2, a3)) {
        break;
      }
      if (v10 == ++v11) {
        return 0;
      }
    }
    CFArrayInsertValueAtIndex(*a3, 0, a1);
  }
  return 1;
}

const void **applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef(const void **a1)
{
  CFArrayRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t PDFDocumentAddFont(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 336);
  if (!v3) {
    operator new();
  }
  if (!a2) {
    return 0;
  }
  CFTypeRef v4 = *(void **)(v3 + 40);
  if (!v4) {
    goto LABEL_14;
  }
  BOOL v5 = (void *)(v3 + 40);
  do
  {
    unint64_t v6 = v4[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      CFArrayRef v8 = v4;
    }
    else {
      CFArrayRef v8 = v4 + 1;
    }
    if (v7) {
      BOOL v5 = v4;
    }
    CFTypeRef v4 = (void *)*v8;
  }
  while (*v8);
  if (v5 == (void *)(v3 + 40) || v5[4] > a2)
  {
LABEL_14:
    ++*(_DWORD *)(v3 + 80);
    LODWORD(v11) = 0;
    if (CGFontGetIntProperty(a2, @"com.apple.CoreGraphics.CGPDFFontFormat", &v11)) {
      int v9 = v11;
    }
    else {
      int v9 = (*(uint64_t (**)(void))(*(void *)(a2 + 16) + 336))(*(void *)(a2 + 112));
    }
    switch(v9)
    {
      case 0:
      case 5:
        break;
      case 1:
        operator new();
      case 2:
        operator new();
      case 3:
        operator new();
      case 4:
        operator new();
      default:
        pdf_error("unsupported streaming format: %d", v9);
        break;
    }
  }
  return v5[5];
}

void sub_184E4A520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::__tree<unsigned long>::destroy(*v21);
  if (v18[111] < 0) {
    operator delete(*v19);
  }
  if (v18[87] < 0) {
    operator delete(*v20);
  }
  PDFFont::~PDFFont((PDFFont *)v18);
  MEMORY[0x18532A2A0]();
  _Unwind_Resume(a1);
}

void *PDFDocumentAddFormWithDisplayList(uint64_t a1, void *value)
{
  if (!*(void *)(a1 + 360)) {
    *(void *)(a1 + 360) = PDFFormSetCreate(a1);
  }
  CFMutableArrayRef Mutable = *(__CFSet **)(a1 + 536);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
    *(void *)(a1 + 536) = Mutable;
  }
  CFSetAddValue(Mutable, value);
  uint64_t result = 0;
  uint64_t v6 = *(void *)(a1 + 360);
  if (v6 && value)
  {
    if (!*(void *)(v6 + 8)) {
      *(void *)(v6 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_12489);
    }
    CGPDFObjectRef valuea = 0;
    uint64_t v7 = *(void *)v6;
    CFArrayRef v8 = malloc_type_calloc(1uLL, 0x58uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v8)
    {
      *(_DWORD *)CFArrayRef v8 = 1;
      v8[1] = v7;
      v8[2] = PDFContentStreamCreate(v7, 0);
      *((_DWORD *)v8 + 6) = 0;
      v8[4] = CFRetain(value);
      v8[8] = 0;
      v8[9] = 0;
      v8[10] = -1;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v6 + 8), v8, (const void **)&valuea))
    {
      uint64_t v16 = (*(_DWORD *)(v6 + 24) + 1);
      *(_DWORD *)(v6 + 24) = v16;
      if (*((_DWORD *)v8 + 6) == 1) {
        uint64_t v17 = "Sm";
      }
      else {
        uint64_t v17 = "Fm";
      }
      snprintf_l((char *)v8 + 40, 0x10uLL, 0, "%s%zu", v17, v16);
      CFSetAddValue(*(CFMutableSetRef *)(v6 + 8), v8);
      CGPDFObjectRef valuea = v8;
    }
    PDFFormRelease(v8, v9, v10, v11, v12, v13, v14, v15);
    uint64_t v18 = *(const void ***)(v6 + 16);
    if (!v18)
    {
      uint64_t v18 = CGOrderedSetCreate();
      *(void *)(v6 + 16) = v18;
    }
    CGOrderedSetAddValue((CFSetRef *)v18, valuea);
    return valuea;
  }
  return result;
}

void *PDFDocumentAddFunction(uint64_t a1, uint64_t a2)
{
  CFTypeRef v4 = *(uint64_t **)(a1 + 368);
  if (v4)
  {
    if (a2)
    {
LABEL_3:
      unint64_t v5 = *(void *)(a2 + 48) - 1;
      goto LABEL_6;
    }
  }
  else
  {
    CFTypeRef v4 = PDFFunctionSetCreate(a1);
    *(void *)(a1 + 368) = v4;
    if (a2) {
      goto LABEL_3;
    }
  }
  unint64_t v5 = -1;
LABEL_6:

  return PDFFunctionSetAddFunctionWithRange(v4, a2, v5, 0);
}

void PDFDocumentAddImageTag(uint64_t a1, uint64_t a2, void *value)
{
  unint64_t v5 = *(void **)(a1 + 344);
  if (!v5)
  {
    unint64_t v5 = PDFImageSetCreate(a1);
    *(void *)(a1 + 344) = v5;
  }
  CFMutableArrayRef Mutable = (__CFDictionary *)v5[3];
  if (Mutable)
  {
    if (a2)
    {
LABEL_5:
      CFArrayRef v8 = (const void *)*(unsigned int *)(a2 + 24);
      goto LABEL_8;
    }
  }
  else
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
    v5[3] = Mutable;
    if (a2) {
      goto LABEL_5;
    }
  }
  CFArrayRef v8 = 0;
LABEL_8:

  CFDictionarySetValue(Mutable, v8, value);
}

const void *PDFDocumentAddImage(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = *(void **)(a1 + 344);
  if (!v6)
  {
    uint64_t v6 = PDFImageSetCreate(a1);
    *(void *)(a1 + 344) = v6;
  }

  return add_image((uint64_t)v6, a2, 0, 0, a3);
}

const void *PDFDocumentAddSMask(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4)
{
  CFArrayRef v8 = *(void **)(a1 + 352);
  if (!v8)
  {
    CFArrayRef v8 = PDFImageSetCreate(a1);
    *(void *)(a1 + 352) = v8;
  }

  return add_image((uint64_t)v8, a2, a3, 1, a4);
}

void *PDFDocumentAddShading(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 384);
  if (!v3)
  {
    uint64_t v3 = (uint64_t *)malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v3) {
      *uint64_t v3 = a1;
    }
    *(void *)(a1 + 384) = v3;
  }
  if (v3) {
    BOOL v5 = a2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0;
  }
  CFDictionaryRef Mutable = (const __CFDictionary *)v3[1];
  if (!Mutable)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, &shadingCallbacks);
    v3[1] = (uint64_t)Mutable;
  }
  CFArrayRef v8 = (const void *)a2[4];
  CFNumberRef Value = CFDictionaryGetValue(Mutable, v8);
  if (!Value)
  {
    uint64_t v9 = *v3;
    uint64_t v10 = (*((_DWORD *)v3 + 6) + 1);
    *((_DWORD *)v3 + 6) = v10;
    CFNumberRef Value = malloc_type_calloc(1uLL, 0x38uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (Value)
    {
      *(_DWORD *)CFNumberRef Value = 1;
      Value[1] = v9;
      CFRetain(a2);
      Value[2] = a2;
      Value[3] = PDFXRefTableAddObject(*(void **)(v9 + 464));
      *((unsigned char *)Value + 48) = 0;
      snprintf_l((char *)Value + 32, 0x10uLL, 0, "Sh%lu", v10);
    }
    CFDictionarySetValue((CFMutableDictionaryRef)v3[1], v8, Value);
    PDFShadingRelease(Value);
  }
  uint64_t v11 = (const void **)v3[2];
  if (!v11)
  {
    uint64_t v11 = CGOrderedSetCreate();
    v3[2] = (uint64_t)v11;
  }
  CGOrderedSetAddValue((CFSetRef *)v11, Value);
  return Value;
}

void *PDFDocumentGetDestinationSet(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 416);
  if (!v1)
  {
    uint64_t v1 = malloc_type_calloc(1uLL, 0x10uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v1) {
      void *v1 = a1;
    }
    *(void *)(a1 + 416) = v1;
  }
  return v1;
}

void PDFDocumentPrintPageParentReference(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFDocumentPrintf(a1, a2, a3, a4, a5, a6, a7, a8, a3);
  uint64_t v10 = *(void *)(a1 + 520);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 280);
    if (a3 && v11)
    {
      uint64_t v12 = (uint64_t *)operator new(0x30uLL);
      uint64_t v15 = *(uint64_t **)(v10 + 216);
      uint64_t v14 = (uint64_t **)(v10 + 216);
      uint64_t v13 = v15;
      uint64_t v16 = v14 - 1;
      *(void *)&long long v17 = a3;
      *((void *)&v17 + 1) = v11;
      *((_OWORD *)v12 + 2) = v17;
      if (v15)
      {
        do
        {
          while (1)
          {
            uint64_t v14 = (uint64_t **)v13;
            if (v13[4] <= a3) {
              break;
            }
            uint64_t v13 = (uint64_t *)*v13;
            uint64_t v18 = v14;
            if (!*v14) {
              goto LABEL_13;
            }
          }
          uint64_t v13 = (uint64_t *)v13[1];
        }
        while (v13);
        uint64_t v18 = v14 + 1;
      }
      else
      {
        uint64_t v18 = v14;
      }
LABEL_13:
      std::__tree<unsigned long>::__insert_node_at(v16, (uint64_t)v14, v18, v12);
    }
    else
    {
      pdf_log("%s: Invalid param. object = %lu, referrer = %lu", "void PDFLinearizer::recordPageParentReference(PDFObjectNumber, PDFObjectNumber)", a3, v11);
    }
  }
}

void CGGStateSetAlpha(uint64_t a1, double a2)
{
  if (*(double *)(*(void *)(a1 + 120) + 8) != a2)
  {
    maybeCopyRenderingState(a1);
    *(double *)(*(void *)(a1 + 120) + 8) = a2;
  }
}

uint64_t CGGStateGetRenderingIntent(uint64_t a1)
{
  return ((int)(*(_DWORD *)(*(void *)(a1 + 120) + 4) << 12) >> 28);
}

float CGGStateGetEDRTargetHeadroom(uint64_t a1)
{
  return *(float *)(*(void *)(a1 + 120) + 48);
}

void CGGStateSetEDRTargetHeadroom(uint64_t a1, float a2)
{
  if (*(float *)(*(void *)(a1 + 120) + 48) != a2)
  {
    maybeCopyRenderingState(a1);
    *(float *)(*(void *)(a1 + 120) + 48) = a2;
  }
}

double CGGStateGetPatternPhase(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 120) + 24);
}

void CGGStateSetPatternPhase(uint64_t a1, double a2, double a3)
{
  uint64_t v5 = *(void *)(a1 + 120);
  if (*(double *)(v5 + 24) != a2 || *(double *)(v5 + 32) != a3)
  {
    maybeCopyRenderingState(a1);
    uint64_t v8 = *(void *)(a1 + 120);
    *(double *)(v8 + 24) = a2;
    *(double *)(v8 + 32) = a3;
  }
}

uint64_t CGGStateGetAlphaIsShape(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)(a1 + 120) + 7) >> 1) & 1;
}

uint64_t CGGStateGetImageRenderingIntent(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(*(void *)(a1 + 120) + 4);
  if (((v1 >> 20) & 0xF) != 0) {
    int v2 = v1 << 8;
  }
  else {
    int v2 = v1 << 12;
  }
  return (v2 >> 28);
}

uint64_t CGGStateGetInterpolationQuality(uint64_t a1)
{
  return *(char *)(*(void *)(a1 + 120) + 4);
}

CFTypeID CGFunctionGetTypeID(void)
{
  if (_block_invoke_once_6090 != -1) {
    dispatch_once(&_block_invoke_once_6090, &__block_literal_global_8_6091);
  }
  return CGFunctionGetTypeID_function_type_id;
}

CGFunctionRef CGFunctionRetain(CGFunctionRef function)
{
  if (function) {
    CFRetain(function);
  }
  return function;
}

void CGFunctionRelease(CGFunctionRef function)
{
  if (function) {
    CFRelease(function);
  }
}

uint64_t CGFunctionCreateIdentity()
{
  if (CGFunctionCreateIdentity_predicate != -1) {
    dispatch_once(&CGFunctionCreateIdentity_predicate, &__block_literal_global_6100);
  }
  uint64_t v0 = CGFunctionCreateIdentity_identity;
  if (CGFunctionCreateIdentity_identity) {
    CFRetain((CFTypeRef)CGFunctionCreateIdentity_identity);
  }
  return v0;
}

CGFunctionRef __CGFunctionCreateIdentity_block_invoke()
{
  CGFunctionRef result = CGFunctionCreate(0, 1uLL, 0, 1uLL, 0, &create_identity_callbacks);
  CGFunctionCreateIdentity_identitdouble y = (uint64_t)result;
  return result;
}

double evaluate_identity(uint64_t a1, double *a2, void *a3)
{
  double result = *a2;
  *a3 = *(void *)a2;
  return result;
}

uint64_t CGFunctionGetDomainDimension(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t CGFunctionGetDomain(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t CGFunctionGetRangeDimension(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

uint64_t CGFunctionGetRange(uint64_t result)
{
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

uint64_t CGFunctionGetIdentifier(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t CGFunctionGetInfo(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

CGFunctionRef CGFunctionCreateEvaluatedCopy(uint64_t a1)
{
  v21[1] = *(double *)MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  size_t v2 = *(void *)(a1 + 32);
  if (v2 > 1) {
    return 0;
  }
  CGFunctionRef v3 = CGFunctionCreate(0, v2, 0, *(void *)(a1 + 48), 0, (const CGFunctionCallbacks *)(a1 + 64));
  if (v3)
  {
    if (*(void *)(a1 + 40))
    {
      size_t v5 = 16 * *(void *)(a1 + 32);
      uint64_t v6 = malloc_type_malloc(v5, 0x2062DE7BuLL);
      *((void *)v3 + 5) = v6;
      memcpy(v6, *(const void **)(a1 + 40), v5);
    }
    if (*(void *)(a1 + 56))
    {
      size_t v7 = 16 * *(void *)(a1 + 48);
      uint64_t v8 = malloc_type_malloc(v7, 0x2062DE7BuLL);
      *((void *)v3 + 7) = v8;
      memcpy(v8, *(const void **)(a1 + 56), v7);
    }
    size_t v9 = MEMORY[0x1F4188790](8 * *((void *)v3 + 4), v4);
    uint64_t v11 = (double *)((char *)v21 - v10);
    if (v9 >= 0x101) {
      uint64_t v11 = (double *)malloc_type_malloc(v9, 0xC4C2B412uLL);
    }
    uint64_t v13 = *((void *)v3 + 4);
    uint64_t v12 = (const void *)*((void *)v3 + 5);
    if (v12)
    {
      memcpy(v11, v12, 8 * v13);
    }
    else if (v13)
    {
      uint64_t v14 = v11;
      do
      {
        *(_OWORD *)v14++ = xmmword_1850CD8C0;
        --v13;
      }
      while (v13);
    }
    *((_OWORD *)v3 + 4) = xmmword_1ED09B5C0;
    *((void *)v3 + 10) = off_1ED09B5D0;
    uint64_t v15 = malloc_type_malloc(0x18uLL, 0x108004098BBCF0FuLL);
    uint64_t v16 = (double *)malloc_type_malloc(*((void *)v3 + 6) << 14, 0x100004000313F17uLL);
    v15[2] = v16;
    uint64_t v17 = *((void *)v3 + 6);
    uint64_t v18 = 2048;
    *uint64_t v15 = 2048;
    v15[1] = v17;
    *((void *)v3 + 3) = v15;
    double v19 = (v11[1] - *v11) * 0.00048828125;
    v21[0] = *v11;
    do
    {
      CGFunctionEvaluate(a1, (char *)v21, v16);
      v21[0] = v19 + v21[0];
      v16 += *((void *)v3 + 6);
      --v18;
    }
    while (v18);
  }
  return v3;
}

void evaluated_function_release_info(void **a1)
{
  if (a1)
  {
    free(a1[2]);
    free(a1);
  }
}

double evaluated_function_evaluate(void *a1, double *a2, double *a3)
{
  double v3 = *a2;
  double v4 = 1.0;
  BOOL v5 = *a2 > 1.0 || *a2 < 0.0;
  if (*a2 < 0.0 && *a2 <= 1.0) {
    double v4 = 0.0;
  }
  if (v5) {
    double v3 = v4;
  }
  uint64_t v6 = a1[1];
  uint64_t v7 = a1[2];
  double result = v3 * (double)(unint64_t)(*a1 - 1);
  uint64_t v9 = vcvtmd_s64_f64(result);
  uint64_t v10 = (double *)(v7 + 8 * v6 * v9);
  if ((unint64_t)(v9 + 1) >= *a1)
  {
    for (; v6; --v6)
    {
      double v15 = *v10++;
      double result = v15;
      *a3++ = v15;
    }
  }
  else if (v6)
  {
    uint64_t v11 = (double *)(v7 + 8 * (v9 + 1) * v6);
    double result = result - (double)v9;
    do
    {
      double v12 = *v10++;
      double v13 = v12;
      double v14 = *v11++;
      *a3++ = v13 + result * (v14 - v13);
      --v6;
    }
    while (v6);
  }
  return result;
}

BOOL CGFunctionIsIdentity(BOOL result)
{
  if (result) {
    return *(void *)(result + 72) == (void)evaluate_identity;
  }
  return result;
}

void CGFunctionEvaluateFloat(uint64_t a1, float *a2, float *a3, __n128 a4)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1, a4);
  uint64_t v11 = (char *)v19 - v10;
  if (v9 <= 0x1FFFFFFFFFFFFFFELL) {
    double v12 = (char *)v19 - v10;
  }
  else {
    double v12 = 0;
  }
  if (v9 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000012)
  {
    double v12 = (char *)malloc_type_malloc(8 * v8, 0x66B37E0BuLL);
    uint64_t v7 = *(void *)(a1 + 32);
  }
  double v13 = (double *)&v12[8 * v7];
  if (v7)
  {
    double v14 = (double *)v12;
    do
    {
      float v15 = *a2++;
      *v14++ = v15;
      --v7;
    }
    while (v7);
  }
  CGFunctionEvaluate(a1, v12, v13);
  for (uint64_t i = *(void *)(a1 + 48); i; --i)
  {
    double v17 = *v13++;
    float v18 = v17;
    *a3++ = v18;
  }
  if (v12 != v11) {
    free(v12);
  }
}

uint64_t CGFunctionCopyPDFDescription(uint64_t a1)
{
  if (a1 && (unsigned int v1 = *(uint64_t (**)(void))(a1 + 88)) != 0) {
    return v1(*(void *)(a1 + 24));
  }
  else {
    return 0;
  }
}

uint64_t CGFunctionSetAssociate(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v2 = 0;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(result + 96), (unint64_t *)&v2, a2, memory_order_relaxed, memory_order_relaxed);
    return *(void *)(result + 96);
  }
  return result;
}

uint64_t CGFunctionGetAssociate(uint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

void CGFunctionSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  if (!*(void *)(a1 + 104))
  {
    uint64_t v6 = (CFTypeRef *)CGPropertiesCreate();
    uint64_t v7 = 0;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 104), (unint64_t *)&v7, (unint64_t)v6, memory_order_relaxed, memory_order_relaxed);
    if (v7) {
      CGPropertiesRelease(v6);
    }
  }
  uint64_t v8 = *(void *)(a1 + 104);

  CGPropertiesSetProperty(v8, a2, a3);
}

const void *CGImageCopyProperty(uint64_t a1, const void *a2)
{
  return CGPropertiesCopyProperty(*(void *)(a1 + 104), a2);
}

__CFHTTPMessage *http_message_send_request(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = CFGetAllocator(a1);
  double v3 = CFReadStreamCreateForHTTPRequest(v2, (CFHTTPMessageRef)a1);
  CFWriteStreamRef v4 = CFWriteStreamCreateWithAllocatedBuffers(v2, v2);
  BOOL v5 = v4;
  if (v3 && v4)
  {
    CFReadStreamSetProperty(v3, @"kCFStreamPropertyHTTPShouldAutoredirect", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
    if (CFReadStreamOpen(v3) && CFWriteStreamOpen(v5))
    {
LABEL_5:
      CFStreamStatus Status = CFReadStreamGetStatus(v3);
      while ((Status | 2) != 7)
      {
        uint64_t v7 = CFReadStreamRead(v3, buffer, 512);
        if (v7 < 1) {
          goto LABEL_5;
        }
        uint64_t v8 = v7;
        CFIndex v9 = CFWriteStreamWrite(v5, buffer, v7);
        CFStreamStatus Status = CFReadStreamGetStatus(v3);
        if (v9 != v8)
        {
          CFReadStreamClose(v3);
          CFWriteStreamClose(v5);
          goto LABEL_16;
        }
      }
      CFStreamStatus v11 = CFReadStreamGetStatus(v3);
      CFReadStreamClose(v3);
      CFWriteStreamClose(v5);
      if (v11 != kCFStreamStatusError)
      {
        CFDataRef v13 = (const __CFData *)CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
        double v14 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v3, @"kCFStreamPropertyHTTPResponseHeader");
        uint64_t v10 = v14;
        if (v14) {
          CFHTTPMessageSetBody(v14, v13);
        }
        if (v13) {
          CFRelease(v13);
        }
        goto LABEL_17;
      }
    }
LABEL_16:
    uint64_t v10 = 0;
LABEL_17:
    CFRelease(v3);
    CFRelease(v5);
    return v10;
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v5) {
    CFRelease(v5);
  }
  return 0;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:fe180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  BOOL v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_184E4B8C0(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x18532A250](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x18532A250](a1 + 128);
  return a1;
}

void type1_release_info(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[2];
    if (v2)
    {
      CGPDFGStateReleaseProperties((void *)a1[2]);
      free(v2);
    }
    uint64_t v3 = (const void *)a1[1];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

void type1_draw_uncolored_pattern(uint64_t *a1, uint64_t a2)
{
  Copdouble y = (long long *)CGPDFGStateCreateCopy((long long *)a1[2]);
  FillColorAsColor = (const void *)CGContextGetFillColorAsColor(a2, v5, v6, v7, v8, v9, v10, v11);
  CGPDFGStateSetFillColor((uint64_t)Copy, FillColorAsColor);
  StrokeColorAsColor = (const void *)CGContextGetStrokeColorAsColor(a2, v13, v14, v15, v16, v17, v18, v19);
  CGPDFGStateSetStrokeColor((uint64_t)Copy, StrokeColorAsColor);
  uint64_t v21 = *a1;
  if (*a1 && *(_DWORD *)(v21 + 16) == 1)
  {
    uint64_t v22 = *(CGPDFStream **)(v21 + 24);
    uint64_t v23 = *(CGPDFDictionary **)(v21 + 88);
  }
  else
  {
    uint64_t v22 = 0;
    uint64_t v23 = 0;
  }
  CGPDFDrawingContextDrawStream(0, v22, v23, Copy, a2);
  if (Copy)
  {
    CGPDFGStateReleaseProperties(Copy);
    free(Copy);
  }
}

void type1_draw_colored_pattern(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  if (*a1 && *(_DWORD *)(v3 + 16) == 1)
  {
    uint64_t v4 = *(CGPDFStream **)(v3 + 24);
    uint64_t v5 = *(CGPDFDictionary **)(v3 + 88);
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
  }
  CGPDFDrawingContextDrawStream(0, v4, v5, (long long *)a1[2], a2);
}

void color_space_state_create_uncalibrated_gray()
{
  color_space_state_create_device_gray();
  *(unsigned char *)(v0 + 9) = 1;
  *(void *)(v0 + 80) = @"kCGColorSpaceUncalibratedGray";
}

void color_space_state_create_uncalibrated_rgb()
{
  color_space_state_create_device_rgb();
  *(unsigned char *)(v0 + 9) = 1;
  *(void *)(v0 + 80) = @"kCGColorSpaceUncalibratedRGB";
}

void color_space_state_create_uncalibrated_cmyk()
{
  color_space_state_create_device_cmyk();
  *(unsigned char *)(v0 + 9) = 1;
  *(void *)(v0 + 80) = @"kCGColorSpaceUncalibratedCMYK";
}

void PageLayoutFactory::appendCurLine(PageLayoutFactory *this, BOOL *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *((void *)this + 2);
  uint64_t v5 = *((void *)this + 3);
  while (v5 != v4)
  {
    unsigned int v6 = *(unsigned __int16 *)(v5 - 2);
    v5 -= 2;
    uint64_t v7 = [MEMORY[0x1E4F28B88] whitespaceAndNewlineCharacterSet];
    char v8 = [v7 characterIsMember:v6];

    if ((v8 & 1) == 0)
    {
      uint64_t v4 = v5 + 2;
      break;
    }
  }
  PageLayoutFactory::eraseLastUniChars(v3, (*((void *)v3 + 3) - v4) >> 1);
  if (*((void *)v3 + 5) == *((void *)v3 + 6)) {
    return;
  }
  CFStringRef v251 = 0;
  CFStringRef v252 = 0;
  CFDictionaryRef v253 = 0;
  BOOL v9 = *a2;
  *a2 = 0;
  int v245 = v3;
  if (*(unsigned char *)(*((void *)v3 + 1) + 8))
  {
    uint64_t v10 = ubidi_open();
    uint64_t v250 = v10;
    int v249 = 0;
    ubidi_setReorderingMode();
    ubidi_setContext();
    ubidi_setPara();
    int Length = ubidi_getLength();
    int v12 = ubidi_countRuns();
    std::vector<unsigned short>::resize((char **)&v251, Length + 2 * v12);
    uint64_t v13 = (int)ubidi_writeReordered();
    Processedint Length = ubidi_getProcessedLength();
    if (ProcessedLength != ((uint64_t)(*((void *)v3 + 3) - *((void *)v3 + 2)) >> 1)) {
      _CGHandleAssert("appendCurLine", 480, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/PageLayout/PageLayoutFactory.mm", "mapLen == static_cast<int32_t>(_curLineUniChars.size())", "%d != %lu", v15, v16, v17, ProcessedLength);
    }
    if (ProcessedLength)
    {
      if (ProcessedLength < 0) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      size_t v18 = 4 * ProcessedLength;
      uint64_t v19 = (char *)operator new(v18);
      bzero(v19, v18);
      CFArrayRef v20 = (int *)&v19[v18];
      uint64_t v21 = (int *)v19;
    }
    else
    {
      uint64_t v21 = 0;
      CFArrayRef v20 = 0;
    }
    ubidi_getVisualMap();
    uint64_t v26 = *(void *)(*((void *)v245 + 1) + 296);
    uint64_t v25 = *(void *)(*((void *)v245 + 1) + 304);
    __p = (void *)(*((void *)v245 + 1) + 296);
    if (v21 != v20)
    {
      uint64_t v27 = (v25 - v26) >> 3;
      uint64_t v28 = v21;
      do
      {
        uint64_t v254 = v27 + *v28;
        std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&__p, &v254);
        ++v28;
      }
      while (v28 != v20);
    }
    uint64_t v250 = 0;
    if (v10) {
      ubidi_close();
    }
    uint64_t v3 = v245;
    if (v21) {
      operator delete(v21);
    }
    if (v13) {
      goto LABEL_27;
    }
    goto LABEL_41;
  }
  uint64_t v22 = (char *)*((void *)v3 + 2);
  if (v9)
  {
    uint64_t v23 = (char *)*((void *)v3 + 3);
    uint64_t v24 = (char *)*((void *)v3 + 2);
    if (v22 != v23)
    {
      while (*(_WORD *)v24 != 32)
      {
        v24 += 2;
        if (v24 == v23)
        {
          uint64_t v24 = (char *)*((void *)v3 + 3);
          break;
        }
      }
    }
    if (v24 != v23) {
      *(_WORD *)uint64_t v24 = 10;
    }
  }
  else
  {
    uint64_t v23 = (char *)*((void *)v3 + 3);
  }
  if (v22 == v23)
  {
    uint64_t v38 = 0;
LABEL_39:
    uint64_t v39 = 0;
    goto LABEL_40;
  }
  if (*((_WORD *)v23 - 1) == 173)
  {
    PageLayoutFactory::eraseLastUniChars(v3, 1uLL);
    *a2 = 1;
    uint64_t v22 = (char *)*((void *)v3 + 2);
    uint64_t v23 = (char *)*((void *)v3 + 3);
  }
  size_t v37 = v23 - v22;
  uint64_t v38 = (v23 - v22) >> 1;
  if (v23 == v22) {
    goto LABEL_39;
  }
  if ((v37 & 0x8000000000000000) != 0) {
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
  }
  uint64_t v39 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<unsigned short>>((v23 - v22) >> 1);
  CFStringRef v251 = v39;
  CFStringRef v252 = v39;
  CFDictionaryRef v253 = &v39[2 * v40];
  memmove(v39, v22, v37);
LABEL_40:
  CFStringRef v252 = &v39[2 * v38];
  uint64_t v13 = (uint64_t)(*((void *)v3 + 3) - *((void *)v3 + 2)) >> 1;
  if (v13)
  {
LABEL_27:
    id v29 = [NSString alloc];
    uint64_t v30 = (void *)[v29 initWithCharacters:v251 length:v13];
    uint64_t v31 = [v30 length];
    [*((id *)v3 + 21) appendString:v30];
    if (!*a2)
    {
      [*((id *)v3 + 21) appendString:@"\n"];
      uint64_t v32 = (void *)*((void *)v3 + 1);
      uint64_t v33 = (char *)v32[25];
      uint64_t v34 = (char *)v32[26];
      if (v33 == v34) {
        goto LABEL_297;
      }
      unint64_t v35 = v32[27];
      if ((unint64_t)v34 >= v35)
      {
        uint64_t v41 = (v34 - v33) >> 3;
        unint64_t v42 = v41 + 1;
        if ((unint64_t)(v41 + 1) >> 61) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        uint64_t v43 = v35 - (void)v33;
        if (v43 >> 2 > v42) {
          unint64_t v42 = v43 >> 2;
        }
        BOOL v44 = (unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8;
        unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
        if (!v44) {
          unint64_t v45 = v42;
        }
        if (v45)
        {
          unint64_t v45 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v45);
          uint64_t v33 = (char *)v32[25];
          uint64_t v47 = (char *)v32[26];
        }
        else
        {
          uint64_t v46 = 0;
          uint64_t v47 = (char *)v32[26];
        }
        uint64_t v48 = (void *)(v45 + 8 * v41);
        unint64_t v49 = v45 + 8 * v46;
        *uint64_t v48 = *((void *)v34 - 1);
        uint64_t v36 = v48 + 1;
        while (v47 != v33)
        {
          uint64_t v50 = *((void *)v47 - 1);
          v47 -= 8;
          *--uint64_t v48 = v50;
        }
        v32[25] = v48;
        v32[26] = v36;
        v32[27] = v49;
        if (v33) {
          operator delete(v33);
        }
      }
      else
      {
        *(void *)uint64_t v34 = *((void *)v34 - 1);
        uint64_t v36 = v34 + 8;
      }
      v32[26] = v36;
      uint64_t v51 = (void *)*((void *)v3 + 1);
      uint64_t v52 = (char *)v51[28];
      uint64_t v53 = (char *)v51[29];
      if (v52 == v53) {
        goto LABEL_297;
      }
      unint64_t v54 = v51[30];
      if ((unint64_t)v53 >= v54)
      {
        uint64_t v56 = (v53 - v52) >> 3;
        unint64_t v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 61) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        uint64_t v58 = v54 - (void)v52;
        if (v58 >> 2 > v57) {
          unint64_t v57 = v58 >> 2;
        }
        BOOL v44 = (unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8;
        unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
        if (!v44) {
          unint64_t v59 = v57;
        }
        if (v59)
        {
          unint64_t v59 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v59);
          uint64_t v52 = (char *)v51[28];
          uint64_t v61 = (char *)v51[29];
        }
        else
        {
          uint64_t v60 = 0;
          uint64_t v61 = (char *)v51[29];
        }
        uint64_t v62 = (void *)(v59 + 8 * v56);
        unint64_t v63 = v59 + 8 * v60;
        void *v62 = *((void *)v53 - 1);
        uint64_t v55 = v62 + 1;
        while (v61 != v52)
        {
          uint64_t v64 = *((void *)v61 - 1);
          v61 -= 8;
          *--uint64_t v62 = v64;
        }
        v51[28] = v62;
        v51[29] = v55;
        v51[30] = v63;
        if (v52) {
          operator delete(v52);
        }
      }
      else
      {
        *(void *)uint64_t v53 = *((void *)v53 - 1);
        uint64_t v55 = v53 + 8;
      }
      v51[29] = v55;
      uint64_t v65 = *((void *)v3 + 1);
      if (*(unsigned char *)(v65 + 8))
      {
        uint64_t v66 = *(uint64_t **)(v65 + 296);
        uint64_t v67 = *(uint64_t **)(v65 + 304);
        uint64_t v68 = v67 - v66;
        unint64_t v69 = *(void *)(v65 + 312);
        if ((unint64_t)v67 >= v69)
        {
          unint64_t v71 = v68 + 1;
          if ((unint64_t)(v68 + 1) >> 61) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v72 = v69 - (void)v66;
          if (v72 >> 2 > v71) {
            unint64_t v71 = v72 >> 2;
          }
          BOOL v44 = (unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8;
          unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v44) {
            unint64_t v73 = v71;
          }
          if (v73)
          {
            unint64_t v73 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v73);
            uint64_t v66 = *(uint64_t **)(v65 + 296);
            uint64_t v67 = *(uint64_t **)(v65 + 304);
          }
          else
          {
            uint64_t v74 = 0;
          }
          uint64_t v75 = (uint64_t *)(v73 + 8 * v68);
          unint64_t v76 = v73 + 8 * v74;
          uint64_t *v75 = v68;
          uint64_t v70 = v75 + 1;
          while (v67 != v66)
          {
            uint64_t v77 = *--v67;
            *--uint64_t v75 = v77;
          }
          *(void *)(v65 + 296) = v75;
          *(void *)(v65 + 304) = v70;
          *(void *)(v65 + 312) = v76;
          if (v66) {
            operator delete(v66);
          }
        }
        else
        {
          *uint64_t v67 = v68;
          uint64_t v70 = v67 + 1;
        }
        *(void *)(v65 + 304) = v70;
      }
      ++v31;
    }
    unint64_t v242 = v31;
    goto LABEL_90;
  }
LABEL_41:
  unint64_t v242 = 0;
  uint64_t v30 = 0;
LABEL_90:
  uint64_t v78 = (void *)*((void *)v3 + 1);
  uint64_t v79 = (uint64_t)(*((void *)v3 + 6) - *((void *)v3 + 5)) >> 3;
  uint64_t v80 = ((uint64_t)(v78[14] - v78[13]) >> 5) - v79;
  uint64_t v81 = (uint64_t)(v78[8] - v78[7]) >> 1;
  uint64_t v82 = v78[2];
  v78[2] = v82 + 1;
  unint64_t v83 = v78[5];
  unint64_t v84 = v78[6];
  uint64_t v243 = v30;
  if (v83 >= v84)
  {
    uint64_t v86 = v78[4];
    unint64_t v87 = 0x8E38E38E38E38E39 * ((uint64_t)(v83 - v86) >> 3);
    unint64_t v88 = v87 + 1;
    if (v87 + 1 > 0x38E38E38E38E38ELL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v89 = 0x8E38E38E38E38E39 * ((uint64_t)(v84 - v86) >> 3);
    if (2 * v89 > v88) {
      unint64_t v88 = 2 * v89;
    }
    if (v89 >= 0x1C71C71C71C71C7) {
      unint64_t v90 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v90 = v88;
    }
    uint64_t v91 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(v90);
    double v92 = &v91[72 * v87];
    uint64_t v94 = &v91[72 * v93];
    *(void *)double v92 = v80;
    *((void *)v92 + 1) = v79;
    *((void *)v92 + 2) = v81;
    *(int64x2_t *)(v92 + 24) = vdupq_n_s64(0x7FF0000000000000uLL);
    *((void *)v92 + 5) = 0;
    *((void *)v92 + 6) = 0;
    *((void *)v92 + 7) = 0;
    *((void *)v92 + 8) = v82;
    uint64_t v85 = v92 + 72;
    uint64_t v96 = (char *)v78[4];
    long long v95 = (char *)v78[5];
    if (v95 != v96)
    {
      do
      {
        *(_OWORD *)(v92 - 72) = *(_OWORD *)(v95 - 72);
        long long v97 = *(_OWORD *)(v95 - 56);
        long long v98 = *(_OWORD *)(v95 - 40);
        long long v99 = *(_OWORD *)(v95 - 24);
        *((void *)v92 - 1) = *((void *)v95 - 1);
        *(_OWORD *)(v92 - 24) = v99;
        *(_OWORD *)(v92 - 40) = v98;
        *(_OWORD *)(v92 - 56) = v97;
        v92 -= 72;
        v95 -= 72;
      }
      while (v95 != v96);
      long long v95 = (char *)v78[4];
    }
    v78[4] = v92;
    v78[5] = v85;
    v78[6] = v94;
    if (v95) {
      operator delete(v95);
    }
  }
  else
  {
    *(void *)unint64_t v83 = v80;
    *(void *)(v83 + 8) = v79;
    *(void *)(v83 + 16) = v81;
    *(int64x2_t *)(v83 + 24) = vdupq_n_s64(0x7FF0000000000000uLL);
    *(void *)(v83 + 40) = 0;
    *(void *)(v83 + 48) = 0;
    *(void *)(v83 + 56) = 0;
    *(void *)(v83 + 64) = v82;
    uint64_t v85 = (char *)(v83 + 72);
  }
  v78[5] = v85;
  unint64_t v100 = *((void *)v85 - 9);
  uint64_t v101 = *((void *)v85 - 8);
  uint64_t v102 = (double *)*((void *)v3 + 5);
  uint64_t v103 = (double *)*((void *)v3 + 6);
  if (v102 == v103)
  {
    double v109 = 0.0;
  }
  else
  {
    char v104 = 0;
    double v105 = 0.0;
    uint64_t v106 = (double *)*((void *)v3 + 5);
    double v107 = 0.0;
    do
    {
      while (*v106 != 0.0)
      {
        __double2 v108 = __sincos_stret(*v106);
        double v105 = v105 + v108.__cosval;
        double v107 = v107 + v108.__sinval;
        ++v106;
        char v104 = 1;
        if (v106 == v103) {
          goto LABEL_111;
        }
      }
      double v105 = v105 + 1.0;
      double v107 = v107 + 0.0;
      ++v106;
    }
    while (v106 != v103);
    double v109 = 0.0;
    if ((v104 & 1) == 0) {
      goto LABEL_113;
    }
LABEL_111:
    double v109 = atan2(v107 / (double)(unint64_t)(v103 - v102), v105 / (double)(unint64_t)(v103 - v102));
  }
LABEL_113:
  *((double *)v85 - 2) = v109;
  uint64_t v110 = *((void *)v3 + 1);
  uint64_t v111 = *(void *)(v110 + 104);
  unint64_t v244 = (*(void *)(v110 + 112) - v111) >> 5;
  unint64_t v112 = v244 - v100;
  if (v244 < v100) {
    goto LABEL_297;
  }
  if (v101 != -1)
  {
    BOOL v44 = v112 >= v101;
    unint64_t v112 = v101;
    if (!v44) {
      goto LABEL_297;
    }
  }
  if (!v112
    || (uint64_t v113 = (double *)(v111 + 32 * v100), v114 = (CGRect *)&v113[4 * v112], v115 = 32 * v112, v113 == (double *)v114))
  {
LABEL_286:

    if (v251) {
      operator delete(v251);
    }
    *((void *)v3 + 3) = *((void *)v3 + 2);
    *((void *)v3 + 6) = *((void *)v3 + 5);
    return;
  }
  uint64_t v241 = (void *)*((void *)v3 + 1);
  uint64_t v116 = (CGRect *)(v111 + 32 * v100);
  double y = v116->origin.y;
  if (v116 == v114) {
    goto LABEL_297;
  }
  double width = v116->size.width;
  double height = v116->size.height;
  if (width < 0.0 || height < 0.0)
  {
    CGFloat x = v116->origin.x;
    CGFloat v121 = v116->origin.y;
    CGRect v255 = CGRectStandardize(*(CGRect *)(&width - 2));
    double y = v255.origin.y;
  }
  for (uint64_t i = v116 + 1; i != v114; ++i)
  {
    double v123 = i->origin.y;
    double v124 = i->size.width;
    double v125 = i->size.height;
    BOOL v126 = v125 >= 0.0 && v124 >= 0.0;
    if (v126)
    {
      if (v123 < y) {
        double y = i->origin.y;
      }
    }
    else
    {
      CGRect v256 = CGRectStandardize(*i);
      char v127 = v256.origin.y >= y || v126;
      if (v256.origin.y < y) {
        double y = v123;
      }
      if ((v127 & 1) == 0)
      {
        v257.origin.CGFloat x = i->origin.x;
        v257.origin.double y = v123;
        v257.size.double width = v124;
        v257.size.double height = v125;
        CGRect v258 = CGRectStandardize(v257);
        double y = v258.origin.y;
      }
    }
  }
  uint64_t v128 = (CGRect *)(v111 + 32 * v100);
  double v129 = v128->origin.y;
  if (v128 == v114) {
    goto LABEL_297;
  }
  double v130 = v128->size.width;
  double v131 = v128->size.height;
  if (v130 < 0.0 || v131 < 0.0)
  {
    CGFloat v132 = v128->origin.x;
    *(CGRect *)(&v129 - 1) = CGRectStandardize(*(CGRect *)(&v129 - 1));
  }
  double v133 = v129 + v131;
  for (size_t j = v128 + 1; j != v114; ++j)
  {
    double v135 = j->origin.y;
    double v137 = j->size.width;
    double v136 = j->size.height;
    if (v137 < 0.0 || v136 < 0.0)
    {
      CGRect v259 = CGRectStandardize(*j);
      if (v133 >= v259.origin.y + v259.size.height) {
        continue;
      }
      v260.origin.CGFloat x = j->origin.x;
      v260.origin.double y = v135;
      v260.size.double width = v137;
      v260.size.double height = v136;
      CGRect v261 = CGRectStandardize(v260);
      double v135 = v261.origin.y;
      double v136 = v261.size.height;
    }
    else if (v133 >= v135 + v136)
    {
      continue;
    }
    double v133 = v135 + v136;
  }
  CGImageRef v138 = (double *)(v111 + 32 * v100 + 24);
  do
  {
    *(v138 - 2) = y;
    *CGImageRef v138 = v133 - y;
    v138 += 4;
    v115 -= 32;
  }
  while (v115);
  if (v101 >= 1)
  {
    uint64_t v139 = 0;
    uint64_t v140 = *((void *)v245 + 5);
    uint64_t v141 = (*((void *)v245 + 6) - v140) >> 3;
    if (v244 >= v100) {
      unint64_t v142 = v244 - v100;
    }
    else {
      unint64_t v142 = 0;
    }
    while (v141 != v139 && v142 != v139)
    {
      double v143 = *((double *)v85 - 2);
      double v144 = *(double *)(v140 + 8 * v139);
      if (vabdd_f64(v143, v144) > 2.22044605e-16)
      {
        __double2 v146 = __sincos_stret(v143 - v144);
        v145.f64[0] = v146.__cosval;
        v147.f64[0] = -v146.__sinval;
        v147.f64[1] = v146.__cosval;
        v145.f64[1] = v146.__sinval;
        *(float64x2_t *)uint64_t v113 = vaddq_f64(vmlaq_n_f64(vmulq_n_f64(v147, v113[1]), v145, *v113), (float64x2_t)0);
      }
      ++v139;
      v113 += 4;
      if (v139 >= v101) {
        goto LABEL_167;
      }
    }
    goto LABEL_297;
  }
LABEL_167:
  uint64_t v148 = v100 + v101 - 1;
  if ((uint64_t)v100 < v148)
  {
    if (v244 >= v100) {
      unint64_t v149 = v244 - v100;
    }
    else {
      unint64_t v149 = 0;
    }
    uint64_t v150 = 32 * v100;
    while (v149)
    {
      unint64_t v151 = v100 + 1;
      if (v244 <= v100 + 1) {
        break;
      }
      uint64_t v152 = v111 + v150;
      double v153 = *(double *)(v111 + v150 + 32);
      double v155 = *(double *)(v111 + v150 + 48);
      double v154 = *(double *)(v111 + v150 + 56);
      if (v155 < 0.0 || (double v156 = *(double *)(v111 + v150 + 32), v154 < 0.0))
      {
        uint64_t v157 = *(void *)(v152 + 40);
        uint64_t v158 = *(void *)(v111 + v150 + 32);
        uint64_t v159 = *(void *)(v111 + v150 + 48);
        *(void *)&double v156 = (unint64_t)CGRectStandardize(*(CGRect *)(&v154 - 3));
      }
      double v160 = *(double *)(v111 + v150);
      double v162 = *(double *)(v111 + v150 + 16);
      double v161 = *(double *)(v111 + v150 + 24);
      if (v162 < 0.0 || v161 < 0.0)
      {
        uint64_t v164 = *(void *)(v111 + v150 + 8);
        uint64_t v165 = *(void *)(v111 + v150 + 16);
        *(CGRect *)&double v160 = CGRectStandardize(*(CGRect *)&v160);
      }
      else
      {
        double v163 = *(double *)(v111 + v150 + 16);
      }
      double v166 = (v156 - (v160 + v163)) * 0.5;
      uint64_t v167 = v111 + v150;
      *(double *)(v167 + 16) = v166 + v162;
      *(double *)(v152 + 32) = v153 - v166;
      *(double *)(v167 + 48) = v166 + v155;
      uint64_t v168 = v241[16];
      uint64_t v169 = v241[17];
      unint64_t v170 = (v169 - v168) >> 5;
      if (v170 <= v100 || v170 <= v151) {
        break;
      }
      uint64_t v171 = v168 + v150;
      double v172 = *(double *)(v168 + v150 + 32);
      double v174 = *(double *)(v168 + v150 + 48);
      double v173 = *(double *)(v168 + v150 + 56);
      if (v174 < 0.0 || (double v175 = *(double *)(v168 + v150 + 32), v173 < 0.0))
      {
        uint64_t v176 = *(void *)(v171 + 40);
        uint64_t v177 = *(void *)(v168 + v150 + 32);
        uint64_t v178 = *(void *)(v168 + v150 + 48);
        *(void *)&double v175 = (unint64_t)CGRectStandardize(*(CGRect *)(&v173 - 3));
      }
      CGFloat v179 = *(double *)(v168 + v150);
      double v181 = *(double *)(v168 + v150 + 16);
      double v180 = *(double *)(v168 + v150 + 24);
      if (v181 < 0.0 || (v182 = *(double *)(v168 + v150), double v183 = *(double *)(v168 + v150 + 16), v180 < 0.0)) {
        *(CGRect *)&double v182 = CGRectStandardize(*(CGRect *)(v168 + v150));
      }
      double v184 = (v175 - (v182 + v183)) * 0.5;
      uint64_t v185 = v168 + v150;
      v262.size.double width = v184 + v181;
      *(double *)(v185 + 16) = v184 + v181;
      *(double *)(v171 + 32) = v172 - v184;
      *(double *)(v185 + 48) = v184 + v174;
      v262.origin.double y = *(CGFloat *)(v168 + v150 + 8);
      v262.origin.CGFloat x = v179;
      v262.size.double height = v180;
      *(CGRect *)(v85 - 48) = CGRectUnion(*(CGRect *)(v85 - 48), v262);
      --v149;
      v150 += 32;
      unint64_t v100 = v151;
      if (v151 == v148) {
        goto LABEL_192;
      }
    }
    goto LABEL_297;
  }
  uint64_t v168 = v241[16];
  uint64_t v169 = v241[17];
LABEL_192:
  if (v168 != v169)
  {
    *(CGRect *)(v85 - 48) = CGRectUnion(*(CGRect *)(v85 - 48), *(CGRect *)(v169 - 32));
    if (v242)
    {
      uint64_t v186 = (void *)v241[29];
      __p = 0;
      CFDictionaryRef v247 = 0;
      uint64_t v248 = 0;
      uint64_t v3 = v245;
      std::__unwrap_and_dispatch[abi:fe180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<double *>,std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<double>>,0>(&v186[-v242], v186, (uint64_t)&__p);
      uint64_t v187 = (double *)__p;
      uint64_t v188 = v247;
      CFDictionaryRef v189 = (double *)((char *)__p + 8 * (v242 >> 1));
      if (v189 != v247)
      {
        do
        {
          unint64_t v190 = v188 - v187;
          if (v190 < 2) {
            break;
          }
          if (v190 == 3)
          {
            std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<double *>>(v187, v187 + 1, v188 - 1);
            break;
          }
          if (v190 == 2)
          {
            double v218 = *(v188 - 1);
            double v219 = *v187;
            if (v218 < *v187)
            {
              *uint64_t v187 = v218;
              *(v188 - 1) = v219;
            }
            break;
          }
          if ((char *)v188 - (char *)v187 <= 63)
          {
            while (v187 != v188 - 1)
            {
              uint64_t v220 = v187++;
              if (v220 != v188 && v187 != v188)
              {
                double v221 = *v220;
                double v222 = *v220;
                uint64_t v223 = v187;
                uint64_t v224 = v220;
                uint64_t v225 = v187;
                do
                {
                  double v226 = *v225++;
                  double v227 = v226;
                  if (v226 < v222)
                  {
                    double v222 = v227;
                    uint64_t v224 = v223;
                  }
                  uint64_t v223 = v225;
                }
                while (v225 != v188);
                if (v224 != v220)
                {
                  *uint64_t v220 = *v224;
                  double *v224 = v221;
                }
              }
            }
            break;
          }
          uint64_t v191 = &v187[v190 >> 1];
          uint64_t v192 = v188 - 1;
          int v193 = std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<double *>>(v187, v191, v188 - 1);
          double v194 = *v187;
          if (*v187 >= *v191)
          {
            uint64_t v195 = v188 - 2;
            while (v195 != v187)
            {
              uint64_t v196 = v195;
              double v197 = *v195--;
              double v198 = v197;
              if (v197 < *v191)
              {
                *uint64_t v187 = v198;
                *uint64_t v196 = v194;
                ++v193;
                uint64_t v192 = v196;
                goto LABEL_204;
              }
            }
            uint64_t v206 = v187 + 1;
            if (v194 >= *v192)
            {
              uint64_t v3 = v245;
              if (v206 == v192) {
                break;
              }
              while (1)
              {
                double v209 = *v206;
                if (v194 < *v206) {
                  break;
                }
                if (++v206 == v192) {
                  goto LABEL_265;
                }
              }
              *v206++ = *v192;
              *uint64_t v192 = v209;
            }
            else
            {
              uint64_t v3 = v245;
            }
            if (v206 != v192)
            {
LABEL_241:
              double v213 = *v187;
              while (1)
              {
                double v214 = *v206;
                if (v213 < *v206) {
                  break;
                }
                if (++v206 == v188) {
                  goto LABEL_297;
                }
              }
              while (v192 != v187)
              {
                double v215 = *--v192;
                double v216 = v215;
                if (v213 >= v215)
                {
                  if (v206 < v192)
                  {
                    *v206++ = v216;
                    *uint64_t v192 = v214;
                    goto LABEL_241;
                  }
                  if (v206 <= v189) {
                    goto LABEL_223;
                  }
                  goto LABEL_265;
                }
              }
              goto LABEL_297;
            }
            break;
          }
LABEL_204:
          uint64_t v199 = v187 + 1;
          uint64_t v200 = v187 + 1;
          if (v187 + 1 < v192)
          {
LABEL_205:
            double v201 = *v191;
            while (1)
            {
              double v202 = *v200;
              if (*v200 >= v201) {
                break;
              }
              if (++v200 == v188) {
                goto LABEL_297;
              }
            }
            while (v192 != v187)
            {
              double v203 = *--v192;
              double v204 = v203;
              if (v203 < v201)
              {
                if (v200 >= v192) {
                  goto LABEL_215;
                }
                BOOL v231 = v191 == v200;
                *v200++ = v204;
                *uint64_t v192 = v202;
                ++v193;
                if (v231) {
                  uint64_t v191 = v192;
                }
                goto LABEL_205;
              }
            }
            goto LABEL_297;
          }
LABEL_215:
          if (v200 != v191)
          {
            double v205 = *v200;
            if (*v191 < *v200)
            {
              *uint64_t v200 = *v191;
              double *v191 = v205;
              ++v193;
            }
          }
          uint64_t v3 = v245;
          if (v200 == v189) {
            break;
          }
          if (!v193)
          {
            if (v200 <= v189)
            {
              uint64_t v210 = v200 + 1;
              while (v210 != v188)
              {
                double v212 = *(v210 - 1);
                double v211 = *v210++;
                if (v211 < v212) {
                  goto LABEL_220;
                }
              }
            }
            else
            {
              while (v199 != v200)
              {
                double v208 = *(v199 - 1);
                double v207 = *v199++;
                if (v207 < v208) {
                  goto LABEL_220;
                }
              }
            }
            break;
          }
LABEL_220:
          if (v200 <= v189)
          {
            uint64_t v206 = v200 + 1;
          }
          else
          {
            uint64_t v188 = v200;
            uint64_t v206 = v187;
          }
LABEL_223:
          uint64_t v187 = v206;
        }
        while (v188 != v189);
      }
LABEL_265:
      double v228 = *v189;
      if ((v242 & 1) == 0)
      {
        uint64_t v229 = (double *)__p;
        uint64_t v230 = (double *)((char *)__p + 8);
        BOOL v231 = __p == v189 || v230 == v189;
        if (!v231)
        {
          double v232 = *(double *)__p;
          uint64_t v233 = (double *)((char *)__p + 8);
          do
          {
            double v234 = *v233++;
            double v235 = v234;
            if (v232 < v234)
            {
              double v232 = v235;
              uint64_t v229 = v230;
            }
            uint64_t v230 = v233;
          }
          while (v233 != v189);
        }
        double v228 = (v228 + *v229) * 0.5;
      }
      uint64_t v236 = 0x1FFFFFFFFFFFFFFFLL * v242;
      do
      {
        double v237 = *(double *)&v186[v236];
        if (vabdd_f64(v237, v228) >= 0.00001) {
          double v238 = v237 - v228;
        }
        else {
          double v238 = 0.0;
        }
        *(double *)&v186[v236++] = v238;
      }
      while (v236 * 8);
      if (__p)
      {
        CFDictionaryRef v247 = (double *)__p;
        operator delete(__p);
      }
      unsigned int v217 = (void *)*((void *)v3 + 1);
    }
    else
    {
      uint64_t v3 = v245;
      unsigned int v217 = v241;
    }
    uint64_t v240 = (_WORD *)*((void *)v3 + 2);
    uint64_t v239 = (_WORD *)*((void *)v3 + 3);
    __p = v217 + 7;
    while (v240 != v239)
      std::back_insert_iterator<std::vector<unsigned short>>::operator=[abi:fe180100]((uint64_t *)&__p, v240++);
    goto LABEL_286;
  }
LABEL_297:
  __break(1u);
}

void sub_184E4CFB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  if (__p) {
    operator delete(__p);
  }

  if (a22) {
    operator delete(a22);
  }
  a16[3] = a16[2];
  a16[6] = a16[5];
  _Unwind_Resume(a1);
}

void PageLayoutFactory::addUniChars(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10, CGFloat a11, CGFloat a12, CGFloat a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  uint64_t v26 = a4;
  uint64_t v27 = a3;
  if (a4 != 1 || *a3 != 32) {
    goto LABEL_10;
  }
  uint64_t v30 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 16) != v30 && *(_WORD *)(v30 - 2) != 32)
  {
    uint64_t v31 = *(void *)(a1 + 8);
    uint64_t v33 = *(void *)(v31 + 104);
    uint64_t v32 = *(void *)(v31 + 112);
    if (v33 == v32) {
      goto LABEL_128;
    }
    double v34 = *(double *)(v32 - 32);
    double v35 = *(double *)(v32 - 16);
    double v36 = *(double *)(v32 - 8);
    if (v35 < 0.0 || v36 < 0.0)
    {
      uint64_t v37 = *(void *)(v32 - 24);
      *(CGRect *)&double v34 = CGRectStandardize(*(CGRect *)&v34);
    }
    a6 = v34 + v35;
    a9 = 0.0;
    a7 = NAN;
LABEL_10:
    uint64_t v38 = *(void *)(a1 + 24);
    if (*(void *)(a1 + 16) == v38 || *(_WORD *)(v38 - 2) != 32) {
      goto LABEL_27;
    }
    uint64_t v39 = *(void **)(a1 + 8);
    uint64_t v40 = v39[14];
    if (v39[13] != v40)
    {
      uint64_t v41 = v39[17];
      if (v39[16] != v41)
      {
        if (a8 < 0.0 || (double v42 = a6, a9 < 0.0))
        {
          v136.origin.CGFloat x = a6;
          v136.origin.double y = a7;
          v136.size.double width = a8;
          v136.size.double height = a9;
          *(void *)&double v42 = (unint64_t)CGRectStandardize(v136);
        }
        double v43 = *(double *)(v40 - 32);
        double v44 = *(double *)(v40 - 16);
        double v45 = *(double *)(v40 - 8);
        if (v44 < 0.0 || v45 < 0.0)
        {
          uint64_t v46 = *(void *)(v40 - 24);
          *(void *)&double v43 = (unint64_t)CGRectStandardize(*(CGRect *)&v43);
        }
        *(double *)(v40 - 16) = v42 - v43;
        if (a12 < 0.0 || (double v47 = a10, a13 < 0.0))
        {
          v137.origin.CGFloat x = a10;
          v137.origin.double y = a11;
          v137.size.double width = a12;
          v137.size.double height = a13;
          *(void *)&double v47 = (unint64_t)CGRectStandardize(v137);
        }
        double v48 = *(double *)(v41 - 32);
        double v49 = *(double *)(v41 - 16);
        double v50 = *(double *)(v41 - 8);
        if (v49 < 0.0 || v50 < 0.0)
        {
          uint64_t v51 = *(void *)(v41 - 24);
          *(void *)&double v48 = (unint64_t)CGRectStandardize(*(CGRect *)&v48);
        }
        *(double *)(v41 - 16) = v47 - v48;
LABEL_27:
        uint64_t v52 = *(void **)(a1 + 8);
        uint64_t v53 = [*(id *)(a1 + 168) length] + ((uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 1);
        uint64_t v55 = (uint64_t *)v52[20];
        unint64_t v54 = v52[21];
        if ((unint64_t)v55 >= v54)
        {
          unint64_t v57 = (uint64_t *)v52[19];
          uint64_t v58 = v55 - v57;
          unint64_t v59 = v58 + 1;
          if ((unint64_t)(v58 + 1) >> 61) {
            goto LABEL_129;
          }
          uint64_t v60 = v54 - (void)v57;
          if (v60 >> 2 > v59) {
            unint64_t v59 = v60 >> 2;
          }
          BOOL v61 = (unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8;
          unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v61) {
            unint64_t v62 = v59;
          }
          if (v62)
          {
            unint64_t v62 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v62);
            unint64_t v57 = (uint64_t *)v52[19];
            uint64_t v55 = (uint64_t *)v52[20];
          }
          else
          {
            uint64_t v63 = 0;
          }
          uint64_t v64 = (uint64_t *)(v62 + 8 * v58);
          unint64_t v65 = v62 + 8 * v63;
          *uint64_t v64 = v53;
          uint64_t v56 = v64 + 1;
          while (v55 != v57)
          {
            uint64_t v66 = *--v55;
            *--uint64_t v64 = v66;
          }
          v52[19] = v64;
          v52[20] = v56;
          v52[21] = v65;
          if (v57) {
            operator delete(v57);
          }
        }
        else
        {
          *uint64_t v55 = v53;
          uint64_t v56 = v55 + 1;
        }
        v52[20] = v56;
        double v135 = (void *)(a1 + 16);
        if (v26)
        {
          uint64_t v67 = 2 * v26;
          do
          {
            std::back_insert_iterator<std::vector<unsigned short>>::operator=[abi:fe180100]((uint64_t *)&v135, v27++);
            v67 -= 2;
          }
          while (v67);
        }
        unint64_t v69 = *(char **)(a1 + 48);
        unint64_t v68 = *(void *)(a1 + 56);
        if ((unint64_t)v69 >= v68)
        {
          unint64_t v71 = *(char **)(a1 + 40);
          uint64_t v72 = (v69 - v71) >> 3;
          unint64_t v73 = v72 + 1;
          if ((unint64_t)(v72 + 1) >> 61) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v74 = v68 - (void)v71;
          if (v74 >> 2 > v73) {
            unint64_t v73 = v74 >> 2;
          }
          BOOL v61 = (unint64_t)v74 >= 0x7FFFFFFFFFFFFFF8;
          unint64_t v75 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v61) {
            unint64_t v75 = v73;
          }
          if (v75)
          {
            unint64_t v75 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v75);
            unint64_t v71 = *(char **)(a1 + 40);
            unint64_t v69 = *(char **)(a1 + 48);
          }
          else
          {
            uint64_t v76 = 0;
          }
          uint64_t v77 = (void *)(v75 + 8 * v72);
          unint64_t v78 = v75 + 8 * v76;
          void *v77 = a17;
          uint64_t v70 = v77 + 1;
          while (v69 != v71)
          {
            uint64_t v79 = *((void *)v69 - 1);
            v69 -= 8;
            *--uint64_t v77 = v79;
          }
          *(void *)(a1 + 40) = v77;
          *(void *)(a1 + 48) = v70;
          *(void *)(a1 + 56) = v78;
          if (v71) {
            operator delete(v71);
          }
        }
        else
        {
          *(void *)unint64_t v69 = a17;
          uint64_t v70 = v69 + 8;
        }
        *(void *)(a1 + 48) = v70;
        uint64_t v80 = *(void **)(a1 + 8);
        uint64_t v82 = (double *)v80[14];
        unint64_t v81 = v80[15];
        if ((unint64_t)v82 >= v81)
        {
          unint64_t v84 = (double *)v80[13];
          uint64_t v85 = ((char *)v82 - (char *)v84) >> 5;
          unint64_t v86 = v85 + 1;
          if ((unint64_t)(v85 + 1) >> 59) {
            goto LABEL_130;
          }
          uint64_t v87 = v81 - (void)v84;
          if (v87 >> 4 > v86) {
            unint64_t v86 = v87 >> 4;
          }
          BOOL v61 = (unint64_t)v87 >= 0x7FFFFFFFFFFFFFE0;
          unint64_t v88 = 0x7FFFFFFFFFFFFFFLL;
          if (!v61) {
            unint64_t v88 = v86;
          }
          if (v88)
          {
            unint64_t v88 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v88);
            unint64_t v84 = (double *)v80[13];
            uint64_t v82 = (double *)v80[14];
          }
          else
          {
            uint64_t v89 = 0;
          }
          unint64_t v90 = (double *)(v88 + 32 * v85);
          *unint64_t v90 = a6;
          v90[1] = a7;
          unint64_t v91 = v88 + 32 * v89;
          v90[2] = a8;
          v90[3] = a9;
          unint64_t v83 = v90 + 4;
          if (v82 != v84)
          {
            do
            {
              long long v92 = *((_OWORD *)v82 - 1);
              *((_OWORD *)v90 - 2) = *((_OWORD *)v82 - 2);
              *((_OWORD *)v90 - 1) = v92;
              v90 -= 4;
              v82 -= 4;
            }
            while (v82 != v84);
            unint64_t v84 = (double *)v80[13];
          }
          v80[13] = v90;
          v80[14] = v83;
          v80[15] = v91;
          if (v84) {
            operator delete(v84);
          }
        }
        else
        {
          *uint64_t v82 = a6;
          v82[1] = a7;
          unint64_t v83 = v82 + 4;
          v82[2] = a8;
          v82[3] = a9;
        }
        v80[14] = v83;
        uint64_t v93 = *(void **)(a1 + 8);
        long long v95 = (double *)v93[17];
        unint64_t v94 = v93[18];
        if ((unint64_t)v95 < v94)
        {
          *long long v95 = a10;
          v95[1] = a11;
          uint64_t v96 = v95 + 4;
          v95[2] = a12;
          v95[3] = a13;
LABEL_90:
          v93[17] = v96;
          uint64_t v106 = *(void **)(a1 + 8);
          __double2 v108 = (char *)v106[11];
          unint64_t v107 = v106[12];
          if ((unint64_t)v108 >= v107)
          {
            uint64_t v110 = (char *)v106[10];
            uint64_t v111 = (v108 - v110) >> 3;
            unint64_t v112 = v111 + 1;
            if ((unint64_t)(v111 + 1) >> 61) {
              goto LABEL_129;
            }
            uint64_t v113 = v107 - (void)v110;
            if (v113 >> 2 > v112) {
              unint64_t v112 = v113 >> 2;
            }
            BOOL v61 = (unint64_t)v113 >= 0x7FFFFFFFFFFFFFF8;
            unint64_t v114 = 0x1FFFFFFFFFFFFFFFLL;
            if (!v61) {
              unint64_t v114 = v112;
            }
            if (v114)
            {
              unint64_t v114 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v114);
              uint64_t v110 = (char *)v106[10];
              __double2 v108 = (char *)v106[11];
            }
            else
            {
              uint64_t v115 = 0;
            }
            uint64_t v116 = (void *)(v114 + 8 * v111);
            unint64_t v117 = v114 + 8 * v115;
            void *v116 = v26;
            double v109 = v116 + 1;
            while (v108 != v110)
            {
              uint64_t v118 = *((void *)v108 - 1);
              v108 -= 8;
              *--uint64_t v116 = v118;
            }
            v106[10] = v116;
            v106[11] = v109;
            v106[12] = v117;
            if (v110) {
              operator delete(v110);
            }
          }
          else
          {
            *(void *)__double2 v108 = v26;
            double v109 = v108 + 8;
          }
          v106[11] = v109;
          long long v119 = *(void **)(a1 + 8);
          double v135 = v119 + 25;
          if (v26)
          {
            uint64_t v120 = v26;
            do
            {
              uint64_t v134 = a2;
              std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&v135, &v134);
              --v120;
            }
            while (v120);
            double v135 = (void *)(*(void *)(a1 + 8) + 224);
            do
            {
              uint64_t v134 = a18;
              std::back_insert_iterator<std::vector<double>>::operator=[abi:fe180100]((uint64_t *)&v135, &v134);
              --v26;
            }
            while (v26);
            long long v119 = *(void **)(a1 + 8);
          }
          uint64_t v122 = (char *)v119[35];
          unint64_t v121 = v119[36];
          if ((unint64_t)v122 < v121)
          {
            *(void *)uint64_t v122 = a5;
            double v123 = v122 + 8;
LABEL_126:
            v119[35] = v123;
            return;
          }
          double v124 = (char *)v119[34];
          uint64_t v125 = (v122 - v124) >> 3;
          unint64_t v126 = v125 + 1;
          if (!((unint64_t)(v125 + 1) >> 61))
          {
            uint64_t v127 = v121 - (void)v124;
            if (v127 >> 2 > v126) {
              unint64_t v126 = v127 >> 2;
            }
            BOOL v61 = (unint64_t)v127 >= 0x7FFFFFFFFFFFFFF8;
            unint64_t v128 = 0x1FFFFFFFFFFFFFFFLL;
            if (!v61) {
              unint64_t v128 = v126;
            }
            if (v128)
            {
              unint64_t v128 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v128);
              double v124 = (char *)v119[34];
              uint64_t v122 = (char *)v119[35];
            }
            else
            {
              uint64_t v129 = 0;
            }
            double v130 = (void *)(v128 + 8 * v125);
            unint64_t v131 = v128 + 8 * v129;
            void *v130 = a5;
            double v123 = v130 + 1;
            while (v122 != v124)
            {
              uint64_t v132 = *((void *)v122 - 1);
              v122 -= 8;
              *--double v130 = v132;
            }
            v119[34] = v130;
            v119[35] = v123;
            v119[36] = v131;
            if (v124) {
              operator delete(v124);
            }
            goto LABEL_126;
          }
LABEL_129:
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        long long v97 = (double *)v93[16];
        uint64_t v98 = ((char *)v95 - (char *)v97) >> 5;
        unint64_t v99 = v98 + 1;
        if (!((unint64_t)(v98 + 1) >> 59))
        {
          uint64_t v100 = v94 - (void)v97;
          if (v100 >> 4 > v99) {
            unint64_t v99 = v100 >> 4;
          }
          BOOL v61 = (unint64_t)v100 >= 0x7FFFFFFFFFFFFFE0;
          unint64_t v101 = 0x7FFFFFFFFFFFFFFLL;
          if (!v61) {
            unint64_t v101 = v99;
          }
          if (v101)
          {
            unint64_t v101 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v101);
            long long v97 = (double *)v93[16];
            long long v95 = (double *)v93[17];
          }
          else
          {
            uint64_t v102 = 0;
          }
          uint64_t v103 = (double *)(v101 + 32 * v98);
          *uint64_t v103 = a10;
          v103[1] = a11;
          unint64_t v104 = v101 + 32 * v102;
          v103[2] = a12;
          v103[3] = a13;
          uint64_t v96 = v103 + 4;
          if (v95 != v97)
          {
            do
            {
              long long v105 = *((_OWORD *)v95 - 1);
              *((_OWORD *)v103 - 2) = *((_OWORD *)v95 - 2);
              *((_OWORD *)v103 - 1) = v105;
              v103 -= 4;
              v95 -= 4;
            }
            while (v95 != v97);
            long long v97 = (double *)v93[16];
          }
          v93[16] = v103;
          v93[17] = v96;
          v93[18] = v104;
          if (v97) {
            operator delete(v97);
          }
          goto LABEL_90;
        }
LABEL_130:
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
    }
LABEL_128:
    __break(1u);
    goto LABEL_129;
  }
}

void PageLayoutFactory::getSpaceWidth(int8x8_t *this, const TextChunk *a2)
{
  uint64_t v3 = *(atomic_ullong **)((char *)&a2[13].ckSize + 2);
  if (v3) {
    CFRetain(*(CFTypeRef *)((char *)&a2[13].ckSize + 2));
  }
  int8x8_t v4 = this[9];
  if (!*(void *)&v4) {
    goto LABEL_21;
  }
  unint64_t v5 = 0x9DDFEA08EB382D69 * (((8 * v3) + 8) ^ ((unint64_t)v3 >> 32));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((unint64_t)v3 >> 32) ^ (v5 >> 47) ^ v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v4);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v9 = v7;
    if (v7 >= *(void *)&v4) {
      unint64_t v9 = v7 % *(void *)&v4;
    }
  }
  else
  {
    unint64_t v9 = v7 & (*(void *)&v4 - 1);
  }
  uint64_t v10 = *(double ***)(*(void *)&this[8] + 8 * v9);
  if (!v10)
  {
LABEL_21:
    uint64_t i = 0;
    if (!v3) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  for (uint64_t i = *v10; i; uint64_t i = *(double **)i)
  {
    unint64_t v12 = *((void *)i + 1);
    if (v12 == v7)
    {
      if (*((atomic_ullong **)i + 2) == v3) {
        break;
      }
    }
    else
    {
      if (v8.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v4) {
          v12 %= *(void *)&v4;
        }
      }
      else
      {
        v12 &= *(void *)&v4 - 1;
      }
      if (v12 != v9) {
        goto LABEL_21;
      }
    }
  }
  if (v3) {
LABEL_22:
  }
    CFRelease(v3);
LABEL_23:
  if (i)
  {
    if (i[3] > 0.0) {
      return;
    }
    if (v3) {
      goto LABEL_26;
    }
  }
  else if (v3)
  {
LABEL_26:
    uint64_t explicit = atomic_load_explicit(v3 + 11, memory_order_acquire);
    if (explicit) {
      CGPropertiesGetProperty(explicit, @"com.apple.CoreGraphics.CGPDFFontToUnicodeCMap");
    }
    CGGlyph glyphs = 0;
    __int16 v15 = 32;
    (*(void (**)(atomic_ullong, __int16 *, CGGlyph *, uint64_t))(v3[2] + 376))(v3[14], &v15, &glyphs, 1);
    if (glyphs)
    {
      int advances = 0;
      CGFontGetGlyphAdvances((CGFontRef)v3, &glyphs, 1uLL, &advances);
    }
    goto LABEL_32;
  }
  CGGlyph glyphs = 0;
LABEL_32:
  get_font_info(v3);
}

void PageLayoutFactory::addChunkUnicodes(PageLayoutFactory::TextChunk const&)::$_0::operator()(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 72);
  if (a2 >= (*(void *)(*(void *)(a1 + 8) + 80) - v8) >> 3) {
    goto LABEL_25;
  }
  uint64_t v11 = *(void *)a1;
  unint64_t v12 = *(void *)(v8 + 8 * a2);
  uint64_t v13 = *(uint64_t **)(a1 + 16);
  if (v12 != 1)
  {
    uint64_t v21 = *v13;
    unint64_t v22 = (v13[1] - *v13) >> 1;
    unint64_t v23 = **(void **)(a1 + 24);
    unint64_t v24 = v22 - v23;
    if (v22 < v23) {
      goto LABEL_25;
    }
    if (v12 != -1)
    {
      BOOL v25 = v24 >= v12;
      unint64_t v24 = v12;
      if (!v25) {
        goto LABEL_25;
      }
    }
    uint64_t v26 = (int *)(v21 + 2 * v23);
    goto LABEL_22;
  }
  unint64_t v14 = **(void **)(a1 + 24);
  uint64_t v15 = *v13;
  if (v14 >= (*(void *)(*(void *)(a1 + 16) + 8) - v15) >> 1) {
    goto LABEL_25;
  }
  uint64_t v16 = *(unsigned __int16 *)(v15 + 2 * v14);
  uint64_t v17 = [MEMORY[0x1E4F28B88] whitespaceCharacterSet];
  int v18 = [v17 characterIsMember:v16];

  if (v18) {
    int v19 = 32;
  }
  else {
    int v19 = v16;
  }
  if (v19 > 64256)
  {
    if (v19 != 64257)
    {
      int v20 = 64258;
      goto LABEL_17;
    }
LABEL_19:
    int v27 = 6881382;
    goto LABEL_20;
  }
  if (v19 == 61441) {
    goto LABEL_19;
  }
  int v20 = 61442;
LABEL_17:
  if (v19 != v20)
  {
    LOWORD(v31) = v19;
    uint64_t v26 = &v31;
    unint64_t v24 = 1;
    goto LABEL_22;
  }
  int v27 = 7077990;
LABEL_20:
  int v31 = v27;
  uint64_t v26 = &v31;
  unint64_t v24 = 2;
LABEL_22:
  uint64_t v28 = *(void *)(a1 + 8);
  uint64_t v29 = *(void *)(v28 + 24);
  if (a2 < (*(void *)(v28 + 32) - v29) >> 5)
  {
    uint64_t v30 = *(void *)(v28 + 48);
    if (a2 < (*(void *)(v28 + 56) - v30) >> 5)
    {
      PageLayoutFactory::addUniChars(v11, *(void *)(v28 + 224), v26, v24, *(void *)(v28 + 176), *(CGFloat *)(v29 + 32 * a2), *(CGFloat *)(v28 + 120), *(CGFloat *)(v29 + 32 * a2 + 16), *(CGFloat *)(v28 + 128), *(CGFloat *)(v30 + 32 * a2), *(CGFloat *)(v30 + 32 * a2 + 8), *(CGFloat *)(v30 + 32 * a2 + 16), *(CGFloat *)(v30 + 32 * a2 + 24), a6, a7, a8, *(void *)(v28 + 144), *(void *)(v28 + 152));
      **(void **)(a1 + 24) += v12;
      return;
    }
  }
LABEL_25:
  __break(1u);
}

void sub_184E4DB54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100](uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  unint64_t v6 = *(void **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(void **)v4;
    uint64_t v9 = ((uint64_t)v6 - *(void *)v4) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v13);
      uint64_t v8 = *(void **)v4;
      unint64_t v6 = *(void **)(v4 + 8);
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = (void *)(v13 + 8 * v9);
    unint64_t v16 = v13 + 8 * v14;
    *uint64_t v15 = *a2;
    unint64_t v7 = v15 + 1;
    while (v6 != v8)
    {
      uint64_t v17 = *--v6;
      *--uint64_t v15 = v17;
    }
    *(void *)uint64_t v4 = v15;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *unint64_t v6 = *a2;
    unint64_t v7 = v6 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

uint64_t *std::back_insert_iterator<std::vector<double>>::operator=[abi:fe180100](uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  unint64_t v6 = *(void **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(void **)v4;
    uint64_t v9 = ((uint64_t)v6 - *(void *)v4) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v13);
      uint64_t v8 = *(void **)v4;
      unint64_t v6 = *(void **)(v4 + 8);
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = (void *)(v13 + 8 * v9);
    unint64_t v16 = v13 + 8 * v14;
    *uint64_t v15 = *a2;
    unint64_t v7 = v15 + 1;
    while (v6 != v8)
    {
      uint64_t v17 = *--v6;
      *--uint64_t v15 = v17;
    }
    *(void *)uint64_t v4 = v15;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *unint64_t v6 = *a2;
    unint64_t v7 = v6 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

uint64_t std::unique_ptr<UBiDi,applesauce::raii::v1::detail::opaque_deletion_functor<UBiDi*,&(ubidi_close)>>::reset[abi:fe180100](uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result) {
    return ubidi_close();
  }
  return result;
}

void *PageLayoutFactory::eraseLastUniChars(void *this, unint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = this;
    uint64_t v3 = this[3];
    if (this[2] != v3)
    {
      unint64_t v4 = a2;
      if ((a2 & 0x8000000000000000) == 0)
      {
        this[3] = v3 - 2 * a2;
        unint64_t v5 = (void *)this[1];
        uint64_t v6 = v5[26];
        unint64_t v7 = v5;
        v5[26] = v6 - 8 * a2;
        uint64_t v8 = (unsigned char *)v5[29];
        uint64_t v9 = &v8[-8 * a2];
        unint64_t v10 = &v9[8 * ((uint64_t)(8 * a2) >> 3)];
        int64_t v11 = v8 - v10;
        if (v8 != v10)
        {
          this = memmove(&v8[-8 * v4], v10, v8 - v10);
          unint64_t v5 = (void *)v2[1];
        }
        uint64_t v12 = 0;
        v7[29] = &v9[v11];
        uint64_t v13 = v5[10];
        unint64_t v14 = (v5[11] - v13) >> 3;
        unint64_t v15 = v14 - 1;
        while (v14 > v15)
        {
          unint64_t v16 = *(void *)(v13 + 8 * v15);
          unint64_t v17 = v4 - v16;
          if (v4 < v16)
          {
            *(void *)(v13 + 8 * v15) = v16 - v4;
LABEL_12:
            if (v12 < 0) {
              break;
            }
            if (v12)
            {
              uint64_t v18 = v2[6];
              uint64_t v19 = -v12;
              v2[6] = v18 - 8 * v12;
              uint64_t v20 = v5[14];
              uint64_t v21 = v20 - 32 * v12;
              uint64_t v22 = (32 * v12) >> 5;
              unint64_t v23 = v5;
              uint64_t v24 = (8 * v12) >> 3;
              v5[14] = v21;
              BOOL v25 = (unsigned char *)v5[17];
              uint64_t v26 = &v25[32 * v19];
              int v27 = &v26[32 * v22];
              int64_t v28 = v25 - v27;
              if (v25 != v27)
              {
                this = memmove(&v25[32 * v19], v27, v25 - v27);
                unint64_t v5 = (void *)v2[1];
              }
              v23[17] = &v26[v28];
              uint64_t v29 = (unsigned char *)v5[11];
              uint64_t v30 = &v29[8 * v19];
              int v31 = &v30[8 * v24];
              uint64_t v32 = v5;
              int64_t v33 = v29 - v31;
              if (v29 != v31)
              {
                this = memmove(&v29[8 * v19], v31, v29 - v31);
                uint64_t v32 = (void *)v2[1];
              }
              v5[11] = &v30[v33];
              double v34 = (unsigned char *)v32[20];
              double v35 = &v34[8 * v19];
              double v36 = &v35[8 * v24];
              uint64_t v37 = v32;
              int64_t v38 = v34 - v36;
              if (v34 != v36)
              {
                this = memmove(&v34[8 * v19], v36, v34 - v36);
                uint64_t v37 = (void *)v2[1];
              }
              v32[20] = &v35[v38];
              uint64_t v39 = (unsigned char *)v37[35];
              uint64_t v40 = &v39[8 * v19];
              uint64_t v41 = &v40[8 * v24];
              int64_t v42 = v39 - v41;
              if (v39 != v41) {
                this = memmove(&v39[8 * v19], v41, v39 - v41);
              }
              v37[35] = &v40[v42];
            }
            return this;
          }
          ++v12;
          --v15;
          v4 -= v16;
          if (!v17) {
            goto LABEL_12;
          }
        }
      }
      __break(1u);
    }
  }
  return this;
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(unint64_t a1)
{
  if (a1 >= 0x38E38E38E38E38FLL) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(72 * a1);
}

void std::__unwrap_and_dispatch[abi:fe180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<double *>,std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<double>>,0>(void *a1, void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    unint64_t v5 = a1;
    uint64_t v6 = *(void **)(a3 + 8);
    do
    {
      unint64_t v7 = *(void *)(a3 + 16);
      if ((unint64_t)v6 >= v7)
      {
        uint64_t v9 = *(void **)a3;
        uint64_t v10 = ((uint64_t)v6 - *(void *)a3) >> 3;
        unint64_t v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) >> 61) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        uint64_t v12 = v7 - (void)v9;
        if (v12 >> 2 > v11) {
          unint64_t v11 = v12 >> 2;
        }
        if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v11;
        }
        if (v13)
        {
          unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v13);
          uint64_t v9 = *(void **)a3;
          uint64_t v6 = *(void **)(a3 + 8);
        }
        else
        {
          uint64_t v14 = 0;
        }
        unint64_t v15 = (void *)(v13 + 8 * v10);
        *unint64_t v15 = *v5;
        uint64_t v8 = v15 + 1;
        while (v6 != v9)
        {
          uint64_t v16 = *--v6;
          *--unint64_t v15 = v16;
        }
        *(void *)a3 = v15;
        *(void *)(a3 + 8) = v8;
        *(void *)(a3 + 16) = v13 + 8 * v14;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *uint64_t v6 = *v5;
        uint64_t v8 = v6 + 1;
      }
      *(void *)(a3 + 8) = v8;
      ++v5;
      uint64_t v6 = v8;
    }
    while (v5 != a2);
  }
}

uint64_t std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<double *>>(double *a1, double *a2, double *a3)
{
  double v3 = *a2;
  double v4 = *a1;
  double v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    double v6 = *a1;
    if (*a2 >= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

uint64_t std::construct_at[abi:fe180100]<PageLayout::CharacterStyle,PageLayout::CharacterStyle const&,PageLayout::CharacterStyle*>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3) {
    CFRetain(*(CFTypeRef *)(a2 + 16));
  }
  *(void *)(a1 + 16) = v3;
  return a1;
}

uint64_t std::__split_buffer<PageLayout::CharacterStyle>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    std::__destroy_at[abi:fe180100]<PageLayout::CharacterStyle,0>(*(const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__destroy_at[abi:fe180100]<PageLayout::CharacterStyle,0>(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
}

void PageLayout::addVertEdge(PageLayout *this, const CGPoint *a2, const CGPoint *a3, double a4, double a5, double a6)
{
  uint64_t v9 = (double *)*((void *)this + 57);
  uint64_t v8 = (double *)*((void *)this + 58);
  uint64_t v10 = (char *)v8 - (char *)v9;
  if (v8 == v9)
  {
    uint64_t v12 = (double *)*((void *)this + 58);
  }
  else
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3);
    uint64_t v12 = (double *)*((void *)this + 57);
    do
    {
      unint64_t v13 = v11 >> 1;
      uint64_t v14 = &v12[3 * (v11 >> 1)];
      double v16 = *v14;
      unint64_t v15 = v14 + 3;
      v11 += ~(v11 >> 1);
      if (v16 < a4) {
        uint64_t v12 = v15;
      }
      else {
        unint64_t v11 = v13;
      }
    }
    while (v11);
  }
  if (a5 >= a6) {
    double v17 = a6;
  }
  else {
    double v17 = a5;
  }
  if (a5 >= a6) {
    double v18 = a5;
  }
  else {
    double v18 = a6;
  }
  if (v8 == v12 || *v12 != a4) {
    goto LABEL_26;
  }
  double v19 = v12[1];
  double v20 = v12[2];
  if (v17 == v19 && v18 == v20) {
    return;
  }
  if (v17 > v20 || v18 < v19)
  {
LABEL_26:
    unint64_t v23 = *((void *)this + 59);
    if ((unint64_t)v8 >= v23)
    {
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3) + 1;
      if (v28 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (void)v9) >> 3);
      if (2 * v29 > v28) {
        unint64_t v28 = 2 * v29;
      }
      if (v29 >= 0x555555555555555) {
        unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v30 = v28;
      }
      if (v30)
      {
        uint64_t v32 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v30);
      }
      else
      {
        uint64_t v32 = 0;
        uint64_t v31 = 0;
      }
      int64_t v33 = (double *)&v32[8 * (v12 - v9)];
      double v34 = &v32[24 * v31];
      if (0xAAAAAAAAAAAAAAABLL * (v12 - v9) == v31)
      {
        if ((char *)v12 - (char *)v9 < 1)
        {
          if (v12 == v9) {
            unint64_t v37 = 1;
          }
          else {
            unint64_t v37 = 0x5555555555555556 * (v12 - v9);
          }
          int64_t v38 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v37);
          int64_t v33 = (double *)&v38[24 * (v37 >> 2)];
          double v34 = &v38[24 * v39];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          int64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((8 * (v12 - v9)) >> 3);
          if (v35 >= -1) {
            uint64_t v36 = v35 + 1;
          }
          else {
            uint64_t v36 = v35 + 2;
          }
          v33 -= 3 * (v36 >> 1);
        }
      }
      *int64_t v33 = a4;
      v33[1] = v17;
      v33[2] = v18;
      uint64_t v40 = (double *)*((void *)this + 57);
      uint64_t v41 = v33;
      if (v40 != v12)
      {
        int64_t v42 = v12;
        double v43 = v33;
        do
        {
          long long v44 = *(_OWORD *)(v42 - 3);
          uint64_t v41 = v43 - 3;
          *(v43 - 1) = *(v42 - 1);
          *(_OWORD *)(v43 - 3) = v44;
          v42 -= 3;
          v43 -= 3;
        }
        while (v42 != v40);
      }
      double v45 = (double *)*((void *)this + 58);
      int64_t v46 = (char *)v45 - (char *)v12;
      if (v45 != v12) {
        memmove(v33 + 3, v12, (char *)v45 - (char *)v12);
      }
      double v47 = (void *)*((void *)this + 57);
      *((void *)this + 57) = v41;
      *((void *)this + 58) = (char *)v33 + v46 + 24;
      *((void *)this + 59) = v34;
      if (v47)
      {
        operator delete(v47);
      }
    }
    else if (v12 == v8)
    {
      *uint64_t v8 = a4;
      v8[1] = v17;
      v8[2] = v18;
      *((void *)this + 58) = v8 + 3;
    }
    else
    {
      uint64_t v24 = v12 + 3;
      BOOL v25 = v8 - 3;
      uint64_t v26 = *((void *)this + 58);
      while (v25 < v8)
      {
        long long v27 = *(_OWORD *)v25;
        *(double *)(v26 + 16) = v25[2];
        *(_OWORD *)uint64_t v26 = v27;
        v26 += 24;
        v25 += 3;
      }
      *((void *)this + 58) = v26;
      if (v8 != v24) {
        memmove(v12 + 3, v12, (char *)v8 - (char *)v24);
      }
      *uint64_t v12 = a4;
      v12[1] = v17;
      v12[2] = v18;
    }
  }
  else
  {
    if (v17 < v19) {
      double v19 = v17;
    }
    if (v20 < v18) {
      double v20 = v18;
    }
    v12[1] = v19;
    v12[2] = v20;
  }
}

void sub_184E4E530(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void PageLayout::addHorzEdge(PageLayout *this, const CGPoint *a2, const CGPoint *a3, double a4, double a5, double a6)
{
  uint64_t v9 = (double *)*((void *)this + 54);
  uint64_t v8 = (double *)*((void *)this + 55);
  uint64_t v10 = (char *)v8 - (char *)v9;
  if (v8 == v9)
  {
    uint64_t v12 = (double *)*((void *)this + 55);
  }
  else
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3);
    uint64_t v12 = (double *)*((void *)this + 54);
    do
    {
      unint64_t v13 = v11 >> 1;
      uint64_t v14 = &v12[3 * (v11 >> 1)];
      double v16 = *v14;
      unint64_t v15 = v14 + 3;
      v11 += ~(v11 >> 1);
      if (v16 < a5) {
        uint64_t v12 = v15;
      }
      else {
        unint64_t v11 = v13;
      }
    }
    while (v11);
  }
  if (a4 >= a6) {
    double v17 = a6;
  }
  else {
    double v17 = a4;
  }
  if (a4 >= a6) {
    double v18 = a4;
  }
  else {
    double v18 = a6;
  }
  if (v8 == v12 || *v12 != a5) {
    goto LABEL_26;
  }
  double v19 = v12[1];
  double v20 = v12[2];
  if (v17 == v19 && v18 == v20) {
    return;
  }
  if (v17 > v20 || v18 < v19)
  {
LABEL_26:
    unint64_t v23 = *((void *)this + 56);
    if ((unint64_t)v8 >= v23)
    {
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3) + 1;
      if (v28 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (void)v9) >> 3);
      if (2 * v29 > v28) {
        unint64_t v28 = 2 * v29;
      }
      if (v29 >= 0x555555555555555) {
        unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v30 = v28;
      }
      if (v30)
      {
        uint64_t v32 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v30);
      }
      else
      {
        uint64_t v32 = 0;
        uint64_t v31 = 0;
      }
      int64_t v33 = (double *)&v32[8 * (v12 - v9)];
      double v34 = &v32[24 * v31];
      if (0xAAAAAAAAAAAAAAABLL * (v12 - v9) == v31)
      {
        if ((char *)v12 - (char *)v9 < 1)
        {
          if (v12 == v9) {
            unint64_t v37 = 1;
          }
          else {
            unint64_t v37 = 0x5555555555555556 * (v12 - v9);
          }
          int64_t v38 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v37);
          int64_t v33 = (double *)&v38[24 * (v37 >> 2)];
          double v34 = &v38[24 * v39];
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          int64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((8 * (v12 - v9)) >> 3);
          if (v35 >= -1) {
            uint64_t v36 = v35 + 1;
          }
          else {
            uint64_t v36 = v35 + 2;
          }
          v33 -= 3 * (v36 >> 1);
        }
      }
      *int64_t v33 = a5;
      v33[1] = v17;
      v33[2] = v18;
      uint64_t v40 = (double *)*((void *)this + 54);
      uint64_t v41 = v33;
      if (v40 != v12)
      {
        int64_t v42 = v12;
        double v43 = v33;
        do
        {
          long long v44 = *(_OWORD *)(v42 - 3);
          uint64_t v41 = v43 - 3;
          *(v43 - 1) = *(v42 - 1);
          *(_OWORD *)(v43 - 3) = v44;
          v42 -= 3;
          v43 -= 3;
        }
        while (v42 != v40);
      }
      double v45 = (double *)*((void *)this + 55);
      int64_t v46 = (char *)v45 - (char *)v12;
      if (v45 != v12) {
        memmove(v33 + 3, v12, (char *)v45 - (char *)v12);
      }
      double v47 = (void *)*((void *)this + 54);
      *((void *)this + 54) = v41;
      *((void *)this + 55) = (char *)v33 + v46 + 24;
      *((void *)this + 56) = v34;
      if (v47)
      {
        operator delete(v47);
      }
    }
    else if (v12 == v8)
    {
      *uint64_t v8 = a5;
      v8[1] = v17;
      v8[2] = v18;
      *((void *)this + 55) = v8 + 3;
    }
    else
    {
      uint64_t v24 = v12 + 3;
      BOOL v25 = v8 - 3;
      uint64_t v26 = *((void *)this + 55);
      while (v25 < v8)
      {
        long long v27 = *(_OWORD *)v25;
        *(double *)(v26 + 16) = v25[2];
        *(_OWORD *)uint64_t v26 = v27;
        v26 += 24;
        v25 += 3;
      }
      *((void *)this + 55) = v26;
      if (v8 != v24) {
        memmove(v12 + 3, v12, (char *)v8 - (char *)v24);
      }
      *uint64_t v12 = a5;
      v12[1] = v17;
      v12[2] = v18;
    }
  }
  else
  {
    if (v17 < v19) {
      double v19 = v17;
    }
    if (v20 < v18) {
      double v20 = v18;
    }
    v12[1] = v19;
    v12[2] = v20;
  }
}

void sub_184E4E858(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

CGColorSpaceRef CGColorSpaceCreateColoredPattern()
{
  return CGColorSpaceCreatePattern(0);
}

uint64_t CGColorSpacePerceptualStandardRGB()
{
  if (CGColorSpacePerceptualStandardRGB_predicate != -1) {
    dispatch_once(&CGColorSpacePerceptualStandardRGB_predicate, &__block_literal_global_304_6455);
  }
  uint64_t v0 = CGColorSpacePerceptualStandardRGB_space;
  if (CGColorSpacePerceptualStandardRGB_space) {
    CFRetain((CFTypeRef)CGColorSpacePerceptualStandardRGB_space);
  }
  return v0;
}

uint64_t __CGColorSpacePerceptualStandardRGB_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_perceptual_rgb);
  CGColorSpacePerceptualStandardRGB_space = result;
  return result;
}

uint64_t CGColorSpaceExtendedLinearGray()
{
  if (CGColorSpaceExtendedLinearGray_predicate != -1) {
    dispatch_once(&CGColorSpaceExtendedLinearGray_predicate, &__block_literal_global_301_6458);
  }
  uint64_t v0 = CGColorSpaceExtendedLinearGray_space;
  if (CGColorSpaceExtendedLinearGray_space) {
    CFRetain((CFTypeRef)CGColorSpaceExtendedLinearGray_space);
  }
  return v0;
}

uint64_t __CGColorSpaceExtendedLinearGray_block_invoke()
{
  CGColorSpaceExtendedLinearGray_space = create_singleton((uint64_t (*)(void))color_space_state_create_extended_linear_gray);
  CGColorSpaceSetProperty(CGColorSpaceExtendedLinearGray_space, @"kCGColorSpaceStandardRangeOriginal", @"kCGColorSpaceLinearGray");
  CGColorSpaceSetProperty(CGColorSpaceExtendedLinearGray_space, @"kCGColorSpaceLinearDerivative", (const void *)CGColorSpaceExtendedLinearGray_space);
  CGColorSpaceSetProperty(CGColorSpaceExtendedLinearGray_space, @"kCGColorSpaceExtendedDerivative", (const void *)CGColorSpaceExtendedLinearGray_space);
  uint64_t v0 = CGColorSpaceExtendedLinearGray_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearGray");
}

uint64_t CGColorSpaceCreateDCIP3()
{
  if (CGColorSpaceCreateDCIP3_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDCIP3_predicate, &__block_literal_global_283_6464);
  }
  uint64_t v0 = CGColorSpaceCreateDCIP3_space;
  if (CGColorSpaceCreateDCIP3_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDCIP3_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateDCIP3_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_dci_p3);
  CGColorSpaceCreateDCIP3_space = result;
  return result;
}

uint64_t CGColorSpaceCreateExtendedLinearITUR_2020()
{
  if (CGColorSpaceCreateExtendedLinearITUR_2020_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateExtendedLinearITUR_2020_predicate, &__block_literal_global_271);
  }
  uint64_t v0 = CGColorSpaceCreateExtendedLinearITUR_2020_space;
  if (CGColorSpaceCreateExtendedLinearITUR_2020_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedLinearITUR_2020_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateExtendedITUR_2020()
{
  if (CGColorSpaceCreateExtendedITUR_2020_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateExtendedITUR_2020_predicate, &__block_literal_global_268_6467);
  }
  uint64_t v0 = CGColorSpaceCreateExtendedITUR_2020_space;
  if (CGColorSpaceCreateExtendedITUR_2020_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedITUR_2020_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateLinearITUR_2020()
{
  if (CGColorSpaceCreateLinearITUR_2020_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateLinearITUR_2020_predicate, &__block_literal_global_265_6470);
  }
  uint64_t v0 = CGColorSpaceCreateLinearITUR_2020_space;
  if (CGColorSpaceCreateLinearITUR_2020_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateLinearITUR_2020_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateITUR_709_HLG()
{
  if (CGColorSpaceCreateITUR_709_HLG_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateITUR_709_HLG_predicate, &__block_literal_global_256_6479);
  }
  uint64_t v0 = CGColorSpaceCreateITUR_709_HLG_space;
  if (CGColorSpaceCreateITUR_709_HLG_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_709_HLG_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateITUR_709_PQ()
{
  if (CGColorSpaceCreateITUR_709_PQ_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateITUR_709_PQ_predicate, &__block_literal_global_253);
  }
  uint64_t v0 = CGColorSpaceCreateITUR_709_PQ_space;
  if (CGColorSpaceCreateITUR_709_PQ_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_709_PQ_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateACESCGLinear()
{
  if (CGColorSpaceCreateACESCGLinear_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateACESCGLinear_predicate, &__block_literal_global_247);
  }
  uint64_t v0 = CGColorSpaceCreateACESCGLinear_space;
  if (CGColorSpaceCreateACESCGLinear_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateACESCGLinear_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateACESCGLinear_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_acescg_linear);
  CGColorSpaceCreateACESCGLinear_space = result;
  return result;
}

uint64_t CGColorSpaceCreateGenericLab()
{
  if (CGColorSpaceCreateGenericLab_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateGenericLab_predicate, &__block_literal_global_235);
  }
  uint64_t v0 = CGColorSpaceCreateGenericLab_space;
  if (CGColorSpaceCreateGenericLab_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericLab_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateGenericLab_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_generic_lab);
  CGColorSpaceCreateGenericLab_space = result;
  return result;
}

uint64_t CGColorSpaceCreateDisplayP3_709OETF()
{
  if (CGColorSpaceCreateDisplayP3_709OETF_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDisplayP3_709OETF_predicate, &__block_literal_global_223);
  }
  uint64_t v0 = CGColorSpaceCreateDisplayP3_709OETF_space;
  if (CGColorSpaceCreateDisplayP3_709OETF_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDisplayP3_709OETF_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateExtendedLinearDisplayP3()
{
  if (CGColorSpaceCreateExtendedLinearDisplayP3_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateExtendedLinearDisplayP3_predicate, &__block_literal_global_214);
  }
  uint64_t v0 = CGColorSpaceCreateExtendedLinearDisplayP3_space;
  if (CGColorSpaceCreateExtendedLinearDisplayP3_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedLinearDisplayP3_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateExtendedLinearDisplayP3_block_invoke()
{
  CGColorSpaceCreateExtendedLinearDisplayP3_space = create_singleton((uint64_t (*)(void))color_space_state_create_extended_linear_display_p3);
  CGColorSpaceSetProperty(CGColorSpaceCreateExtendedLinearDisplayP3_space, @"kCGColorSpaceStandardRangeOriginal", @"kCGColorSpaceLinearDisplayP3");
  CGColorSpaceSetProperty(CGColorSpaceCreateExtendedLinearDisplayP3_space, @"kCGColorSpaceLinearDerivative", (const void *)CGColorSpaceCreateExtendedLinearDisplayP3_space);
  CGColorSpaceSetProperty(CGColorSpaceCreateExtendedLinearDisplayP3_space, @"kCGColorSpaceExtendedDerivative", (const void *)CGColorSpaceCreateExtendedLinearDisplayP3_space);
  uint64_t v0 = CGColorSpaceCreateExtendedLinearDisplayP3_space;
  uint64_t v1 = (const void *)CGColorSpaceCreateExtendedLinearDisplayP3_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", v1);
}

uint64_t CGColorSpaceCreateExtendedDisplayP3()
{
  if (CGColorSpaceCreateExtendedDisplayP3_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateExtendedDisplayP3_predicate, &__block_literal_global_208_6497);
  }
  uint64_t v0 = CGColorSpaceCreateExtendedDisplayP3_space;
  if (CGColorSpaceCreateExtendedDisplayP3_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedDisplayP3_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateExtendedDisplayP3_block_invoke()
{
  CGColorSpaceCreateExtendedDisplayP3_space = create_singleton((uint64_t (*)(void))color_space_state_create_extended_display_p3);
  CGColorSpaceSetProperty(CGColorSpaceCreateExtendedDisplayP3_space, @"kCGColorSpaceStandardRangeOriginal", @"kCGColorSpaceDisplayP3");
  CGColorSpaceSetProperty(CGColorSpaceCreateExtendedDisplayP3_space, @"kCGColorSpaceLinearDerivative", @"kCGColorSpaceExtendedLinearDisplayP3");
  CGColorSpaceSetProperty(CGColorSpaceCreateExtendedDisplayP3_space, @"kCGColorSpaceExtendedDerivative", (const void *)CGColorSpaceCreateExtendedDisplayP3_space);
  uint64_t v0 = CGColorSpaceCreateExtendedDisplayP3_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearDisplayP3");
}

uint64_t CGColorSpaceCreateGenericGray()
{
  if (CGColorSpaceCreateGenericGray_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateGenericGray_predicate, &__block_literal_global_196);
  }
  uint64_t v0 = CGColorSpaceCreateGenericGray_space;
  if (CGColorSpaceCreateGenericGray_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericGray_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateGenericGray_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_generic_gray);
  CGColorSpaceCreateGenericGray_space = result;
  return result;
}

uint64_t CGColorSpaceCreateUncalibratedCMYK()
{
  if (CGColorSpaceCreateUncalibratedCMYK_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateUncalibratedCMYK_predicate, &__block_literal_global_193_6502);
  }
  uint64_t v0 = CGColorSpaceCreateUncalibratedCMYK_space;
  if (CGColorSpaceCreateUncalibratedCMYK_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateUncalibratedCMYK_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateUncalibratedCMYK_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_uncalibrated_cmyk);
  CGColorSpaceCreateUncalibratedCMYK_space = result;
  return result;
}

uint64_t CGColorSpaceCreateUncalibratedRGB()
{
  if (CGColorSpaceCreateUncalibratedRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateUncalibratedRGB_predicate, &__block_literal_global_190_6505);
  }
  uint64_t v0 = CGColorSpaceCreateUncalibratedRGB_space;
  if (CGColorSpaceCreateUncalibratedRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateUncalibratedRGB_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateUncalibratedRGB_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_uncalibrated_rgb);
  CGColorSpaceCreateUncalibratedRGB_space = result;
  return result;
}

uint64_t CGColorSpaceCreateUncalibratedGray()
{
  if (CGColorSpaceCreateUncalibratedGray_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateUncalibratedGray_predicate, &__block_literal_global_187);
  }
  uint64_t v0 = CGColorSpaceCreateUncalibratedGray_space;
  if (CGColorSpaceCreateUncalibratedGray_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateUncalibratedGray_space);
  }
  return v0;
}

uint64_t __CGColorSpaceCreateUncalibratedGray_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_uncalibrated_gray);
  CGColorSpaceCreateUncalibratedGray_space = result;
  return result;
}

CGColorSpaceRef CGColorSpaceIDFromName(const __CFString *a1)
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName(a1);
  if (result) {
    return (CGColorSpaceRef)*(unsigned int *)(*((void *)result + 3) + 20);
  }
  return result;
}

uint64_t CGColorSpaceNameFromID(int a1)
{
  uint64_t result = CGColorSpaceCreateWithID(a1);
  if (result) {
    return *(void *)(*(void *)(result + 24) + 80);
  }
  return result;
}

CGColorSpaceRef __CGColorSpaceFindMatchingSingleton_block_invoke_3()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
  CGColorSpaceFindMatchingSingleton_spaces_176_0 = (uint64_t)result;
  return result;
}

CGColorSpaceRef __CGColorSpaceFindMatchingSingleton_block_invoke()
{
  for (uint64_t i = 0; i != 3; ++i)
  {
    CGColorSpaceRef result = CGColorSpaceCreateWithName(off_1E52B39B8[i]);
    CGColorSpaceFindMatchingSingleton_spaces[i] = (uint64_t)result;
  }
  return result;
}

uint64_t CGColorSpaceAttachToIOSurface(CGColorSpace *space, __IOSurface *a2)
{
  uint64_t result = 0;
  if (space && a2)
  {
    if (*(_DWORD *)(*((void *)space + 3) + 20))
    {
      int valuePtr = *(_DWORD *)(*((void *)space + 3) + 20);
      uint64_t result = (uint64_t)CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      if (!result) {
        return result;
      }
      double v5 = (const void *)result;
      IOSurfaceSetValue(a2, @"IOSurfaceColorSpaceID", (CFTypeRef)result);
      CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F2F068];
    }
    else
    {
      uint64_t result = (uint64_t)CGColorSpaceCopyPropertyList(space);
      if (!result) {
        return result;
      }
      double v5 = (const void *)result;
      IOSurfaceSetValue(a2, (CFStringRef)*MEMORY[0x1E4F2F068], (CFTypeRef)result);
      CFStringRef v6 = @"IOSurfaceColorSpaceID";
    }
    IOSurfaceRemoveValue(a2, v6);
    CFRelease(v5);
    return 1;
  }
  return result;
}

uint64_t CGColorSpaceCopyFromIOSurface(__IOSurface *a1)
{
  if (!a1) {
    return 0;
  }
  CFNumberRef v2 = (const __CFNumber *)IOSurfaceCopyValue(a1, @"IOSurfaceColorSpaceID");
  if (!v2
    || ((v3 = v2, CFTypeID v4 = CFGetTypeID(v2), v4 != CFNumberGetTypeID())
      ? (int v5 = 0)
      : (valuePtr = 0, CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr), int v5 = valuePtr),
        uint64_t v6 = CGColorSpaceCreateWithID(v5),
        CFRelease(v3),
        !v6))
  {
    CFTypeRef v7 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E4F2F068]);
    uint64_t v6 = (uint64_t)CGColorSpaceCreateWithPropertyList(v7);
    if (v7) {
      CFRelease(v7);
    }
  }
  return v6;
}

void __setup_block_invoke()
{
  if (CGFontCacheGetLocalCache_predicate != -1) {
    dispatch_once(&CGFontCacheGetLocalCache_predicate, &__block_literal_global_6537);
  }
  uint64_t v0 = CGFontCacheGetLocalCache_local_font_cache;

  CGFontCacheReset(v0);
}

void CGFontCacheReset(uint64_t a1)
{
  if (a1)
  {
    CFNumberRef v2 = (os_unfair_lock_s *)(a1 + 4);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
    *(_DWORD *)(a1 + 24) = 0;
    *(void *)(a1 + 16) = 0;
    CFNumberRef v3 = *(const void **)(a1 + 32);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 32) = 0;
    }
    uint64_t v4 = *(void *)(a1 + 40);
    if (v4)
    {
      do
      {
        CGFontStrikeRelease(*(void **)v4);
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v4);
      int v5 = *(void **)(a1 + 40);
      if (v5)
      {
        do
        {
          uint64_t v6 = (void *)v5[1];
          free(v5);
          int v5 = v6;
        }
        while (v6);
      }
    }
    *(void *)(a1 + 40) = 0;
    os_unfair_lock_unlock(v2);
  }
}

void print_cache_size()
{
  while (1)
  {
    sleep(reporting_frequency);
    pthread_mutex_lock(&font_caches_mutex);
    CFTypeRef v7 = (uint64_t *)font_caches;
    if (font_caches)
    {
      do
      {
        uint64_t v8 = *v7;
        if (*v7)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(v8 + 4));
          uint64_t v9 = *(void *)(v8 + 40);
          if (v9)
          {
            uint64_t v10 = 0;
            do
            {
              v10 += (uint64_t)CGFontStrikeGetSize(*(os_unfair_lock_s **)v9);
              uint64_t v9 = *(void *)(v9 + 8);
            }
            while (v9);
            uint64_t v11 = *(void *)(v8 + 40);
            if (v11)
            {
              uint64_t v12 = 0;
              do
              {
                ++v12;
                uint64_t v11 = *(void *)(v11 + 8);
              }
              while (v11);
            }
          }
          os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 4));
        }
        CGPostError((uint64_t)"Cache %p: %zu bytes count = %zu", v0, v1, v2, v3, v4, v5, v6, v8);
        CFTypeRef v7 = (uint64_t *)v7[1];
      }
      while (v7);
    }
    pthread_mutex_unlock(&font_caches_mutex);
  }
}

atomic_uint *CGFontCacheRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

void CGFontCacheRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    pthread_mutex_lock(&font_caches_mutex);
    font_caches = (uint64_t)x_list_remove((void *)font_caches, (uint64_t)a1);
    pthread_mutex_unlock(&font_caches_mutex);
    CGFontCacheReset((uint64_t)a1);
    free(a1);
  }
}

uint64_t CGFontCacheResetAllCaches()
{
  pthread_mutex_lock(&font_caches_mutex);
  uint64_t v0 = (uint64_t *)font_caches;
  if (font_caches)
  {
    do
    {
      CGFontCacheReset(*v0);
      uint64_t v0 = (uint64_t *)v0[1];
    }
    while (v0);
  }

  return pthread_mutex_unlock(&font_caches_mutex);
}

uint64_t CGFontCacheSetMaxSize(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

uint64_t CGFontCacheGetMaxSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void CGFontCachePrint(uint64_t a1, FILE *a2)
{
  if (a1 && a2)
  {
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 4);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
    uint64_t v5 = *(void *)(a1 + 40);
    locuint64_t k = v4;
    for (i = 0; v5; uint64_t v5 = *(void *)(v5 + 8))
      i += (uint64_t)CGFontStrikeGetSize(*(os_unfair_lock_s **)v5);
    fprintf(a2, "cache %p: size = %zu (max %zu)\n", (const void *)a1, i, *(void *)(a1 + 8));
    CFTypeRef v7 = *(uint64_t **)(a1 + 40);
    if (v7)
    {
      do
      {
        uint64_t v8 = *v7;
        fwrite("  ", 2uLL, 1uLL, a2);
        if (v8) {
          uint64_t v9 = v8 + 8;
        }
        else {
          uint64_t v9 = 0;
        }
        fprintf(a2, "strike %p <font %d; style 0x%04x >; ", (const void *)v8, *(_DWORD *)v9, *(_DWORD *)(v9 + 4));
        fprintf(a2, "[ %g %g %g %g ; %g %g ]; ",
          *(double *)(v9 + 8),
          *(double *)(v9 + 16),
          *(double *)(v9 + 24),
          *(double *)(v9 + 32),
          *(double *)(v9 + 40),
          *(double *)(v9 + 48));
        fprintf(a2, "[ %g %g ]; ", *(double *)(v9 + 56), *(double *)(v9 + 64));
        fprintf(a2, "%zu bytes; %d", *(void *)(v8 + 88), *(_DWORD *)(v8 + 4));
        fwrite(":\n", 2uLL, 1uLL, a2);
        if (*(void *)(v8 + 88))
        {
          fwrite("    entries:\n", 0xDuLL, 1uLL, a2);
          for (uint64_t j = 0; j != 256; ++j)
          {
            uint64_t v11 = *(void *)(v8 + 8 * j + 112);
            if (v11)
            {
              for (uint64_t k = 0; k != 256; ++k)
              {
                for (uint64_t m = *(void **)(v11 + 8 * k); m; uint64_t m = (void *)m[1])
                  fprintf(a2, "    glyph %hu (%hhu/%hhu)\n", *(unsigned __int16 *)(*m + 4), *(unsigned __int8 *)(*m + 6), *(unsigned __int8 *)(*m + 7));
              }
            }
          }
        }
        else
        {
          fwrite("    no entries.\n", 0x10uLL, 1uLL, a2);
        }
        CFTypeRef v7 = (uint64_t *)v7[1];
      }
      while (v7);
    }
    else
    {
      fwrite("  no strikes.\n", 0xEuLL, 1uLL, a2);
    }
    os_unfair_lock_unlock(lock);
  }
}

uint64_t CGFontCacheGetLocalCache()
{
  if (CGFontCacheGetLocalCache_predicate != -1) {
    dispatch_once(&CGFontCacheGetLocalCache_predicate, &__block_literal_global_6537);
  }
  return CGFontCacheGetLocalCache_local_font_cache;
}

void CGSBlend8888toARGB8888(char *a1, int a2, char *a3, int a4, int a5, int a6, unsigned int a7, char a8)
{
  int v11 = a4;
  uint64_t v12 = a3;
  int v13 = a2;
  uint64_t v14 = a1;
  vImagePixelCount v15 = a5;
  if (a3 > a1 && a2 == a4)
  {
    double v16 = &a1[4 * a5];
    if (v16 <= a3)
    {
      unint64_t v19 = (unint64_t)&v16[(a6 - 1) * a2];
      double v20 = (void *)(v19 - 4 * a5);
      BOOL v21 = v19 > (unint64_t)a3;
      if (v19 <= (unint64_t)a3) {
        int v11 = a2;
      }
      else {
        int v11 = -a2;
      }
      if (v19 > (unint64_t)a3) {
        double v17 = &a3[(a6 - 1) * a2];
      }
      else {
        double v17 = a3;
      }
      if (v19 <= (unint64_t)a3) {
        int v18 = a2;
      }
      else {
        int v18 = -a2;
      }
      if (v19 <= (unint64_t)a3) {
        int v22 = a2;
      }
      else {
        int v22 = -a2;
      }
      if (v21) {
        uint64_t v14 = v20;
      }
      if (v21) {
        uint64_t v12 = &a3[(a6 - 1) * a2];
      }
      int v13 = v22;
    }
    else
    {
      int v11 = 4 * a5;
      double v17 = (char *)malloc_type_malloc(4 * a5 * a6, 0xE8732C4AuLL);
      int v18 = v13;
    }
  }
  else
  {
    double v17 = a3;
    int v18 = a4;
  }
  srcTop.time_t data = v14;
  srcTop.double height = a6;
  srcTop.double width = v15;
  srcTop.rowBytes = v13;
  srcBottom.time_t data = v12;
  srcBottom.double height = a6;
  srcBottom.double width = v15;
  srcBottom.rowBytes = v18;
  dest.time_t data = v17;
  dest.double height = a6;
  dest.double width = v15;
  dest.rowBytes = v11;
  permuteMap[0] = a7 >> 6;
  permuteMap[1] = (a7 >> 4) & 3;
  permuteMap[2] = (a7 >> 2) & 3;
  permuteMap[3] = a7 & 3;
  vImagePremultipliedAlphaBlendWithPermute_ARGB8888(&srcTop, &srcBottom, &dest, permuteMap, a8 != 1, 0x10u);
  if (v12 != v17)
  {
    CGBlt_copyBytes(v11, a6, v17, v12, v11, v18);
    free(v17);
  }
}

_DWORD *resample_float_h_Ncpp(_DWORD *result, unsigned int a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a3;
    uint64_t v10 = *a6;
    uint64_t v11 = *a7;
    uint64_t v12 = 4 * a2 + 8;
    uint64_t v13 = a8;
    do
    {
      if (a4)
      {
        uint64_t v14 = *(float **)(a5 + 8 * v8);
        int v15 = a4;
        double v16 = result;
        do
        {
          if (v9)
          {
            uint64_t v17 = 0;
            int v18 = v16[1];
            uint64_t v19 = v10 + v8 * v11 + 4 * *v16 * (int)v9;
            do
            {
              float v20 = 0.0;
              if (v18)
              {
                BOOL v21 = (float *)v19;
                int v22 = (float *)(v16 + 2);
                int v23 = v18;
                do
                {
                  float v24 = *v22++;
                  float v20 = v20 + (float)(*v21 * v24);
                  v21 += v9;
                  --v23;
                }
                while (v23);
              }
              *v14++ = v20;
              ++v17;
              v19 += 4;
            }
            while (v17 != v9);
          }
          double v16 = (_DWORD *)((char *)v16 + v12);
          --v15;
        }
        while (v15);
      }
      ++v8;
    }
    while (v8 != v13);
  }
  return result;
}

_DWORD *resample_float_h_3cpp_ap(_DWORD *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    do
    {
      if (a4)
      {
        int v15 = *(float32x4_t **)(a5 + 8 * v8);
        int v16 = a4;
        uint64_t v17 = result;
        do
        {
          int v18 = v17[1];
          if (v18)
          {
            uint64_t v19 = (float *)(v17 + 2);
            uint64_t v20 = v9 + v8 * v11 + 12 * *v17;
            BOOL v21 = (__int32 *)(v10 + v8 * v12 + 4 + 4 * (*v17 - 1));
            float32x4_t v22 = 0uLL;
            do
            {
              float v23 = *v19++;
              float v24 = v23;
              v25.i64[0] = *(void *)v20;
              __int32 v26 = *v21++;
              v25.i32[2] = *(_DWORD *)(v20 + 8);
              v25.i32[3] = v26;
              float32x4_t v22 = vmlaq_n_f32(v22, v25, v24);
              v20 += 12;
              --v18;
            }
            while (v18);
          }
          else
          {
            float32x4_t v22 = 0uLL;
          }
          *v15++ = v22;
          uint64_t v17 = (_DWORD *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

int *resample_float_h_4cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = *a7;
    uint64_t v11 = 4 * a2 + 8;
    do
    {
      if (a4)
      {
        uint64_t v12 = *(float32x4_t **)(a5 + 8 * v8);
        int v13 = a4;
        uint64_t v14 = result;
        do
        {
          int v15 = v14[1];
          if (v15)
          {
            int v16 = (float *)(v14 + 2);
            uint64_t v17 = (float32x4_t *)(v9 + v8 * v10 + 16 * *v14);
            float32x4_t v18 = 0uLL;
            do
            {
              float v19 = *v16++;
              float v20 = v19;
              float32x4_t v21 = *v17++;
              float32x4_t v18 = vmlaq_n_f32(v18, v21, v20);
              --v15;
            }
            while (v15);
          }
          else
          {
            float32x4_t v18 = 0uLL;
          }
          *v12++ = v18;
          uint64_t v14 = (int *)((char *)v14 + v11);
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

int *resample_float_h_3cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = *a7;
    uint64_t v11 = 4 * a2 + 8;
    do
    {
      if (a4)
      {
        uint64_t v12 = *(float32x2_t **)(a5 + 8 * v8);
        int v13 = a4;
        uint64_t v14 = result;
        do
        {
          int v15 = v14[1];
          if (v15)
          {
            int v16 = (float *)(v14 + 2);
            uint64_t v17 = (float32x2_t *)(v9 + v8 * v10 + 12 * *v14);
            float32x2_t v18 = 0;
            float v19 = 0.0;
            do
            {
              float v20 = *v16++;
              float32x2_t v18 = vmla_n_f32(v18, *v17, v20);
              float v19 = v19 + (float)(v17[1].f32[0] * v20);
              uint64_t v17 = (float32x2_t *)((char *)v17 + 12);
              --v15;
            }
            while (v15);
          }
          else
          {
            float32x2_t v18 = 0;
            float v19 = 0.0;
          }
          *uint64_t v12 = v18;
          v12[1].f32[0] = v19;
          uint64_t v12 = (float32x2_t *)((char *)v12 + 12);
          uint64_t v14 = (int *)((char *)v14 + v11);
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

int *resample_float_h_1cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = *a7;
    uint64_t v11 = 4 * a2 + 8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == a8) {
        return result;
      }
    }
    uint64_t v12 = *(float **)(a5 + 8 * v8);
    int v13 = a4;
    uint64_t v14 = result;
    while (1)
    {
      int v15 = v14[1];
      int v16 = v14 + 2;
      float v17 = *((float *)v14 + 2);
      uint64_t v18 = v9 + v8 * v10 + 4 * *v14 - 4;
      if (v15 >= 4) {
        break;
      }
      float v20 = 0.0;
      if (v15) {
        goto LABEL_11;
      }
LABEL_13:
      *v12++ = v20;
      uint64_t v14 = (int *)((char *)v14 + v11);
      if (!--v13) {
        goto LABEL_14;
      }
    }
    float v19 = (float *)(v14 + 6);
    float v20 = 0.0;
    do
    {
      unsigned int v21 = v15;
      float v22 = *(float *)(v18 + 16);
      v18 += 16;
      v15 -= 4;
      float v20 = (float)((float)((float)(v20 + (float)(*(float *)(v18 - 12) * v17))
                          + (float)(*(float *)(v18 - 8) * *(v19 - 3)))
                  + (float)(*(float *)(v18 - 4) * *(v19 - 2)))
          + (float)(v22 * *(v19 - 1));
      float v23 = *v19;
      v19 += 4;
      float v17 = v23;
    }
    while (v21 > 7);
    int v16 = (int *)(v19 - 4);
    if (!v15) {
      goto LABEL_13;
    }
LABEL_11:
    float v24 = (float *)(v18 + 4);
    float32x4_t v25 = (float *)(v16 + 1);
    do
    {
      float v26 = *v24++;
      float v20 = v20 + (float)(v26 * v17);
      float v27 = *v25++;
      float v17 = v27;
      --v15;
    }
    while (v15);
    goto LABEL_13;
  }
  return result;
}

uint64_t resample_float_v_Ncpp_al(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v6 = (float *)(*a5 - 4);
  int v7 = *(_DWORD *)(result + 4);
  uint64_t v8 = (float *)(result + 8);
  int v9 = a3;
  uint64_t v10 = a3 * a4;
  unint64_t v11 = v10 & 0xFFFFFFFC;
  if ((int)v11 < 1)
  {
    LODWORD(v12) = 0;
    float v13 = 0.0;
    unsigned int v14 = a3;
  }
  else
  {
    unint64_t v12 = 0;
    float v13 = 0.0;
    unsigned int v14 = a3;
    do
    {
      uint64_t v15 = v12 | 1;
      float v16 = 0.0;
      float v17 = 0.0;
      float v18 = 0.0;
      float v19 = 0.0;
      if (v7)
      {
        float v20 = a6;
        unsigned int v21 = v8;
        int v22 = v7;
        do
        {
          float v23 = *v21++;
          float v24 = v23;
          uint64_t v25 = *v20++;
          float v16 = v16 + (float)(*(float *)(v25 + 4 * v12) * v24);
          float v17 = v17 + (float)(*(float *)(v25 + 4 * v15) * v24);
          float v18 = v18 + (float)(*(float *)(v25 + 4 * (v12 | 2)) * v24);
          float v19 = v19 + (float)(*(float *)(v25 + 4 * (v12 | 3)) * v24);
          --v22;
        }
        while (v22);
      }
      if (v13 < v16) {
        float v13 = v16;
      }
      if (v13 >= 0.0) {
        float v26 = v13;
      }
      else {
        float v26 = 0.0;
      }
      if (v13 > 1.0) {
        float v26 = 1.0;
      }
      BOOL v27 = v15 == v14;
      if (v15 == v14) {
        uint64_t v28 = v14 + v9;
      }
      else {
        uint64_t v28 = v14;
      }
      if (v27) {
        v14 += v9;
      }
      if (v27) {
        float v13 = 0.0;
      }
      if (v27) {
        float v16 = v26;
      }
      if (v13 < v17) {
        float v13 = v17;
      }
      if (v13 >= 0.0) {
        float v29 = v13;
      }
      else {
        float v29 = 0.0;
      }
      if (v13 > 1.0) {
        float v29 = 1.0;
      }
      if ((v12 | 2) == v28)
      {
        uint64_t v28 = v14 + v9;
        v14 += v9;
        float v13 = 0.0;
        float v17 = v29;
      }
      v6[1] = v16;
      v6[2] = v17;
      if (v13 < v18) {
        float v13 = v18;
      }
      if (v13 >= 0.0) {
        float v30 = v13;
      }
      else {
        float v30 = 0.0;
      }
      if (v13 > 1.0) {
        float v30 = 1.0;
      }
      uint64_t result = v14 + v9;
      if ((v12 | 3) == v28)
      {
        uint64_t v28 = v14 + v9;
        v14 += v9;
        float v13 = 0.0;
        float v18 = v30;
      }
      v6[3] = v18;
      if (v13 < v19) {
        float v13 = v19;
      }
      v12 += 4;
      if (v12 == v28)
      {
        float v19 = 0.0;
        if (v13 >= 0.0) {
          float v19 = v13;
        }
        if (v13 > 1.0) {
          float v19 = 1.0;
        }
        v14 += v9;
        float v13 = 0.0;
      }
      v6[4] = v19;
      v6 += 4;
    }
    while (v12 < v11);
  }
  if ((int)v12 < (int)v10)
  {
    unint64_t v12 = v12;
    do
    {
      float v31 = 0.0;
      if (v7)
      {
        uint64_t v32 = a6;
        int64_t v33 = v8;
        int v34 = v7;
        do
        {
          float v35 = *v33++;
          float v36 = v35;
          uint64_t v37 = *v32++;
          uint64_t result = v37;
          float v31 = v31 + (float)(*(float *)(v37 + 4 * v12) * v36);
          --v34;
        }
        while (v34);
      }
      if (v13 < v31) {
        float v13 = v31;
      }
      if (++v12 == v14)
      {
        float v31 = 0.0;
        if (v13 >= 0.0) {
          float v31 = v13;
        }
        if (v13 > 1.0) {
          float v31 = 1.0;
        }
        v14 += v9;
        float v13 = 0.0;
      }
      v6[1] = v31;
      ++v6;
    }
    while (v12 != v10);
  }
  return result;
}

uint64_t resample_float_v_3cpp_al(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float **a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *(_DWORD *)(result + 4);
    int v9 = (float *)(result + 8);
    uint64_t v10 = *a5;
    do
    {
      float v11 = 0.0;
      float v12 = 0.0;
      float v13 = 0.0;
      float v14 = 0.0;
      if (v8)
      {
        uint64_t v15 = a6;
        float v16 = v9;
        LODWORD(result) = v8;
        do
        {
          float v17 = *v16++;
          float v18 = v17;
          uint64_t v19 = *v15++;
          float v11 = v11 + (float)(*(float *)(v19 + 4 * v7) * v18);
          float v12 = v12 + (float)(*(float *)(v19 + 4 * (v7 | 1)) * v18);
          float v13 = v13 + (float)(*(float *)(v19 + 4 * (v7 | 2)) * v18);
          float v14 = v14 + (float)(*(float *)(v19 + 4 * (v7 | 3)) * v18);
          uint64_t result = (result - 1);
        }
        while (result);
      }
      if (v11 > v14) {
        float v14 = v11;
      }
      if (v12 > v14) {
        float v14 = v12;
      }
      if (v13 > v14) {
        float v14 = v13;
      }
      *uint64_t v10 = v11;
      v10[1] = v12;
      if (v14 >= 0.0) {
        float v20 = v14;
      }
      else {
        float v20 = 0.0;
      }
      if (v14 > 1.0) {
        float v20 = 1.0;
      }
      v10[2] = v13;
      v10[3] = v20;
      v10 += 4;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t resample_float_v_Ncpp_af(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  unint64_t v6 = (float *)(*a5 - 4);
  int v7 = *(_DWORD *)(result + 4);
  int v8 = (float *)(result + 8);
  uint64_t v9 = 2 - a3;
  uint64_t v10 = a3 * a4;
  unint64_t v11 = v10 & 0xFFFFFFFC;
  if ((int)v11 < 1)
  {
    LODWORD(v12) = 0;
    float v13 = 0.0;
    unsigned int v14 = a3;
  }
  else
  {
    unint64_t v12 = 0;
    float v13 = 0.0;
    unsigned int v14 = a3;
    do
    {
      uint64_t v15 = v12 | 1;
      float v16 = 0.0;
      float v17 = 0.0;
      float v18 = 0.0;
      float v19 = 0.0;
      if (v7)
      {
        float v20 = a6;
        unsigned int v21 = v8;
        int v22 = v7;
        do
        {
          float v23 = *v21++;
          float v24 = v23;
          uint64_t v25 = *v20++;
          float v16 = v16 + (float)(*(float *)(v25 + 4 * v12) * v24);
          float v17 = v17 + (float)(*(float *)(v25 + 4 * v15) * v24);
          float v18 = v18 + (float)(*(float *)(v25 + 4 * (v12 | 2)) * v24);
          float v19 = v19 + (float)(*(float *)(v25 + 4 * (v12 | 3)) * v24);
          --v22;
        }
        while (v22);
      }
      if (v13 < v16) {
        float v13 = v16;
      }
      if (v15 == v14)
      {
        float v26 = 0.0;
        if (v13 >= 0.0) {
          float v26 = v13;
        }
        if (v13 <= 1.0) {
          float v27 = v26;
        }
        else {
          float v27 = 1.0;
        }
        v6[(int)v9] = v27;
        uint64_t result = v14 + a3;
        v14 += a3;
        float v13 = 0.0;
      }
      else
      {
        uint64_t result = v14;
      }
      v6[1] = v16;
      if (v13 < v17) {
        float v13 = v17;
      }
      if ((v12 | 2) == result)
      {
        float v28 = 0.0;
        if (v13 >= 0.0) {
          float v28 = v13;
        }
        if (v13 <= 1.0) {
          float v29 = v28;
        }
        else {
          float v29 = 1.0;
        }
        v6[(int)v9 + 1] = v29;
        uint64_t result = v14 + a3;
        v14 += a3;
        float v13 = 0.0;
      }
      v6[2] = v17;
      if (v13 < v18) {
        float v13 = v18;
      }
      if ((v12 | 3) == result)
      {
        float v30 = 0.0;
        if (v13 >= 0.0) {
          float v30 = v13;
        }
        if (v13 <= 1.0) {
          float v31 = v30;
        }
        else {
          float v31 = 1.0;
        }
        v6[(int)v9 + 2] = v31;
        uint64_t result = v14 + a3;
        v14 += a3;
        float v13 = 0.0;
      }
      v6[3] = v18;
      if (v13 < v19) {
        float v13 = v19;
      }
      v12 += 4;
      if (v12 == result)
      {
        float v32 = 0.0;
        if (v13 >= 0.0) {
          float v32 = v13;
        }
        if (v13 <= 1.0) {
          float v33 = v32;
        }
        else {
          float v33 = 1.0;
        }
        v6[(int)v9 + 3] = v33;
        v14 += a3;
        float v13 = 0.0;
      }
      v6[4] = v19;
      v6 += 4;
    }
    while (v12 < v11);
  }
  if ((int)v12 < (int)v10)
  {
    unint64_t v12 = v12;
    do
    {
      float v34 = 0.0;
      if (v7)
      {
        float v35 = a6;
        float v36 = v8;
        LODWORD(result) = v7;
        do
        {
          float v37 = *v36++;
          float v38 = v37;
          uint64_t v39 = *v35++;
          float v34 = v34 + (float)(*(float *)(v39 + 4 * v12) * v38);
          uint64_t result = (result - 1);
        }
        while (result);
      }
      if (v13 < v34) {
        float v13 = v34;
      }
      if (++v12 == v14)
      {
        float v40 = 0.0;
        if (v13 >= 0.0) {
          float v40 = v13;
        }
        if (v13 <= 1.0) {
          float v41 = v40;
        }
        else {
          float v41 = 1.0;
        }
        v6[v9] = v41;
        v14 += a3;
        float v13 = 0.0;
      }
      v6[1] = v34;
      ++v6;
    }
    while (v12 != v10);
  }
  return result;
}

uint64_t resample_float_v_3cpp_af(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float **a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *(_DWORD *)(result + 4);
    uint64_t v9 = (float *)(result + 8);
    uint64_t v10 = *a5;
    do
    {
      float v11 = 0.0;
      float v12 = 0.0;
      float v13 = 0.0;
      float v14 = 0.0;
      if (v8)
      {
        uint64_t v15 = a6;
        float v16 = v9;
        LODWORD(result) = v8;
        do
        {
          float v17 = *v16++;
          float v18 = v17;
          uint64_t v19 = *v15++;
          float v11 = v11 + (float)(*(float *)(v19 + 4 * v7) * v18);
          float v12 = v12 + (float)(*(float *)(v19 + 4 * (v7 | 1)) * v18);
          float v13 = v13 + (float)(*(float *)(v19 + 4 * (v7 | 2)) * v18);
          float v14 = v14 + (float)(*(float *)(v19 + 4 * (v7 | 3)) * v18);
          uint64_t result = (result - 1);
        }
        while (result);
      }
      if (v12 > v11) {
        float v11 = v12;
      }
      if (v13 > v11) {
        float v11 = v13;
      }
      if (v14 > v11) {
        float v11 = v14;
      }
      if (v11 >= 0.0) {
        float v20 = v11;
      }
      else {
        float v20 = 0.0;
      }
      if (v11 <= 1.0) {
        float v21 = v20;
      }
      else {
        float v21 = 1.0;
      }
      *uint64_t v10 = v21;
      v10[1] = v12;
      v10[2] = v13;
      v10[3] = v14;
      v10 += 4;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t resample_float_v_Ncpp(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float32x4_t **a5, uint64_t *a6)
{
  unint64_t v6 = *a5;
  int v7 = *(_DWORD *)(result + 4);
  int v8 = (float *)(result + 8);
  uint64_t v9 = a3 * a4;
  unint64_t v10 = v9 & 0xFFFFFFFC;
  if ((int)v10 < 1)
  {
    LODWORD(i) = 0;
  }
  else
  {
    for (unint64_t i = 0; i < v10; i += 4)
    {
      float32x4_t v12 = 0uLL;
      if (v7)
      {
        float v13 = a6;
        float v14 = v8;
        int v15 = v7;
        do
        {
          float v16 = *v14++;
          float v17 = v16;
          uint64_t v18 = *v13++;
          uint64_t result = 4 * i;
          float32x4_t v12 = vmlaq_n_f32(v12, *(float32x4_t *)(v18 + 4 * i), v17);
          --v15;
        }
        while (v15);
      }
      *v6++ = v12;
    }
  }
  if ((int)i < (int)v9)
  {
    unint64_t i = i;
    do
    {
      float v19 = 0.0;
      if (v7)
      {
        float v20 = a6;
        float v21 = v8;
        int v22 = v7;
        do
        {
          float v23 = *v21++;
          float v24 = v23;
          uint64_t v25 = *v20++;
          float v19 = v19 + (float)(*(float *)(v25 + 4 * i) * v24);
          --v22;
        }
        while (v22);
      }
      v6->f32[0] = v19;
      unint64_t v6 = (float32x4_t *)((char *)v6 + 4);
      ++i;
    }
    while (i != v9);
  }
  return result;
}

float *resample_float_h_1cpp_ap(float *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == v14) {
        return result;
      }
    }
    int v15 = *(float **)(a5 + 8 * v8);
    int v16 = a4;
    float v17 = result;
    while (1)
    {
      uint64_t v18 = (uint64_t)(v17 + 2);
      float v19 = v17[2];
      int v20 = *((_DWORD *)v17 + 1);
      uint64_t v21 = 4 * *(int *)v17 - 4;
      uint64_t v22 = v9 + v8 * v11 + v21;
      uint64_t v23 = v10 + v8 * v12 + v21;
      if (v20 >= 2) {
        break;
      }
      float v26 = 0.0;
      float v25 = 0.0;
      if (v20) {
        goto LABEL_11;
      }
LABEL_13:
      *int v15 = v26;
      v15[1] = v25;
      v15 += 2;
      float v17 = (float *)((char *)v17 + v13);
      if (!--v16) {
        goto LABEL_14;
      }
    }
    unint64_t v24 = 0;
    float v25 = 0.0;
    float v26 = 0.0;
    do
    {
      float v27 = v26 + (float)(*(float *)(v22 + v24 + 4) * v19);
      float v28 = v25 + (float)(*(float *)(v23 + v24 + 4) * v19);
      float v29 = v17[v24 / 4 + 3];
      float v19 = v17[v24 / 4 + 4];
      float v26 = v27 + (float)(*(float *)(v22 + v24 + 8) * v29);
      unsigned int v30 = v20;
      v20 -= 2;
      float v25 = v28 + (float)(*(float *)(v23 + v24 + 8) * v29);
      v24 += 8;
    }
    while (v30 > 3);
    v23 += v24;
    v22 += v24;
    uint64_t v18 = (uint64_t)&v17[v24 / 4 + 2];
    if (!v20) {
      goto LABEL_13;
    }
LABEL_11:
    float v31 = (float *)(v23 + 4);
    float v32 = (float *)(v22 + 4);
    float v33 = (float *)(v18 + 4);
    do
    {
      float v34 = *v32++;
      float v35 = v34;
      float v36 = *v31++;
      float v26 = v26 + (float)(v35 * v19);
      float v25 = v25 + (float)(v36 * v19);
      float v37 = *v33++;
      float v19 = v37;
      --v20;
    }
    while (v20);
    goto LABEL_13;
  }
  return result;
}

_DWORD *resample_float_h_Ncpp_ap(_DWORD *result, unsigned int a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    unsigned int v9 = a3;
    int v10 = a3 - 1;
    uint64_t v11 = *a6;
    uint64_t v12 = a6[1];
    uint64_t v13 = *a7;
    uint64_t v14 = a7[1];
    uint64_t v15 = a8;
    uint64_t v16 = 4 * a3 - 4;
    do
    {
      if (a4)
      {
        float v17 = *(float **)(a5 + 8 * v8);
        int v18 = a4;
        float v19 = result;
        do
        {
          int v21 = *v19;
          int v20 = v19[1];
          uint64_t v22 = (float *)(v19 + 2);
          if (v9 >= 2)
          {
            int v23 = 0;
            do
            {
              float v24 = 0.0;
              if (v20)
              {
                float v25 = (float *)(v11 + v8 * v13 + 4 * v21 * v10);
                float v26 = (float *)(v19 + 2);
                int v27 = v20;
                do
                {
                  float v28 = *v26++;
                  float v24 = v24 + (float)(*v25 * v28);
                  float v25 = (float *)((char *)v25 + v16);
                  --v27;
                }
                while (v27);
              }
              *v17++ = v24;
              ++v23;
            }
            while (v23 != v10);
          }
          if (v20)
          {
            float v29 = (float *)(v12 + v8 * v14 + 4 + 4 * (v21 - 1));
            float v30 = 0.0;
            do
            {
              float v31 = *v22++;
              float v32 = v31;
              float v33 = *v29++;
              float v30 = v30 + (float)(v33 * v32);
              --v20;
            }
            while (v20);
          }
          else
          {
            float v30 = 0.0;
          }
          *v17++ = v30;
          v19 += a2 + 2;
          --v18;
        }
        while (v18);
      }
      ++v8;
    }
    while (v8 != v15);
  }
  return result;
}

int *resample_float_h_4cpp_ap(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    do
    {
      if (a4)
      {
        uint64_t v15 = *(float32x4_t **)(a5 + 8 * v8);
        int v16 = a4;
        float v17 = result;
        do
        {
          int v18 = v17[1];
          if (v18)
          {
            float v19 = (float *)(v17 + 2);
            uint64_t v20 = *v17;
            int v21 = (float32x4_t *)(v9 + v8 * v11 + 16 * v20);
            uint64_t v22 = (__int32 *)(v10 + v8 * v12 + 4 * v20);
            float32x4_t v23 = 0uLL;
            float v24 = 0.0;
            do
            {
              float v25 = *v19++;
              float v26 = v25;
              float32x4_t v27 = *v21++;
              float32x4_t v28 = v27;
              v27.i32[0] = *v22++;
              float32x4_t v23 = vmlaq_n_f32(v23, v28, v26);
              float v24 = v24 + (float)(v27.f32[0] * v26);
              --v18;
            }
            while (v18);
          }
          else
          {
            float32x4_t v23 = 0uLL;
            float v24 = 0.0;
          }
          *uint64_t v15 = v23;
          v15[1].f32[0] = v24;
          uint64_t v15 = (float32x4_t *)((char *)v15 + 20);
          float v17 = (int *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

uint64_t resample_float_v_Ncpp_ap(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v6 = *a5 - 4;
  uint64_t v7 = a5[1] - 4;
  int v8 = *(_DWORD *)(result + 4);
  uint64_t v9 = (float *)(result + 8);
  int v10 = a3;
  uint64_t v11 = a3 * a4;
  unint64_t v12 = v11 & 0xFFFFFFFC;
  if ((int)v12 < 1)
  {
    LODWORD(v13) = 0;
    float v14 = 0.0;
    unsigned int v15 = a3;
  }
  else
  {
    unint64_t v13 = 0;
    float v14 = 0.0;
    unsigned int v15 = a3;
    do
    {
      uint64_t v16 = v13 | 1;
      float v17 = 0.0;
      float v18 = 0.0;
      float v19 = 0.0;
      float v20 = 0.0;
      if (v8)
      {
        int v21 = a6;
        uint64_t v22 = v9;
        int v23 = v8;
        do
        {
          float v24 = *v22++;
          float v25 = v24;
          uint64_t v26 = *v21++;
          float v17 = v17 + (float)(*(float *)(v26 + 4 * v13) * v25);
          float v18 = v18 + (float)(*(float *)(v26 + 4 * v16) * v25);
          float v19 = v19 + (float)(*(float *)(v26 + 4 * (v13 | 2)) * v25);
          float v20 = v20 + (float)(*(float *)(v26 + 4 * (v13 | 3)) * v25);
          --v23;
        }
        while (v23);
      }
      if (v14 < v17) {
        float v14 = v17;
      }
      if (v16 == v15)
      {
        float v27 = 0.0;
        if (v14 >= 0.0) {
          float v27 = v14;
        }
        if (v14 <= 1.0) {
          float v28 = v27;
        }
        else {
          float v28 = 1.0;
        }
        *(float *)(v7 + 4) = v28;
        v7 += 4;
        uint64_t v29 = v15 + v10;
        v15 += v10;
        float v14 = 0.0;
      }
      else
      {
        uint64_t v29 = v15;
        *(float *)(v6 + 4) = v17;
        v6 += 4;
      }
      if (v14 < v18) {
        float v14 = v18;
      }
      if ((v13 | 2) == v29)
      {
        float v30 = 0.0;
        if (v14 >= 0.0) {
          float v30 = v14;
        }
        if (v14 <= 1.0) {
          float v31 = v30;
        }
        else {
          float v31 = 1.0;
        }
        *(float *)(v7 + 4) = v31;
        v7 += 4;
        uint64_t v29 = v15 + v10;
        v15 += v10;
        float v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v18;
        v6 += 4;
      }
      if (v14 < v19) {
        float v14 = v19;
      }
      uint64_t result = v13 | 3;
      if ((v13 | 3) == v29)
      {
        float v32 = 0.0;
        if (v14 >= 0.0) {
          float v32 = v14;
        }
        if (v14 <= 1.0) {
          float v33 = v32;
        }
        else {
          float v33 = 1.0;
        }
        *(float *)(v7 + 4) = v33;
        v7 += 4;
        uint64_t v29 = v15 + v10;
        v15 += v10;
        float v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v19;
        v6 += 4;
      }
      if (v14 < v20) {
        float v14 = v20;
      }
      v13 += 4;
      if (v13 == v29)
      {
        float v34 = 0.0;
        if (v14 >= 0.0) {
          float v34 = v14;
        }
        if (v14 <= 1.0) {
          float v35 = v34;
        }
        else {
          float v35 = 1.0;
        }
        *(float *)(v7 + 4) = v35;
        v7 += 4;
        v15 += v10;
        float v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v20;
        v6 += 4;
      }
    }
    while (v13 < v12);
  }
  if ((int)v13 < (int)v11)
  {
    unint64_t v13 = v13;
    do
    {
      float v36 = 0.0;
      if (v8)
      {
        float v37 = a6;
        float v38 = v9;
        LODWORD(result) = v8;
        do
        {
          float v39 = *v38++;
          float v40 = v39;
          uint64_t v41 = *v37++;
          float v36 = v36 + (float)(*(float *)(v41 + 4 * v13) * v40);
          uint64_t result = (result - 1);
        }
        while (result);
      }
      if (v14 < v36) {
        float v14 = v36;
      }
      if (++v13 == v15)
      {
        float v42 = 0.0;
        if (v14 >= 0.0) {
          float v42 = v14;
        }
        if (v14 <= 1.0) {
          float v43 = v42;
        }
        else {
          float v43 = 1.0;
        }
        *(float *)(v7 + 4) = v43;
        v7 += 4;
        v15 += v10;
        float v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v36;
        v6 += 4;
      }
    }
    while (v13 != v11);
  }
  return result;
}

float *resample_float_v_3cpp_ap(float *result, uint64_t a2, unsigned __int8 a3, int a4, float **a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *((_DWORD *)result + 1);
    uint64_t v9 = result + 2;
    uint64_t v11 = *a5;
    int v10 = a5[1];
    do
    {
      float v12 = 0.0;
      float v13 = 0.0;
      float v14 = 0.0;
      float v15 = 0.0;
      if (v8)
      {
        uint64_t v16 = a6;
        uint64_t result = v9;
        int v17 = v8;
        do
        {
          float v18 = *result++;
          float v19 = v18;
          uint64_t v20 = *v16++;
          float v12 = v12 + (float)(*(float *)(v20 + 4 * v7) * v19);
          float v13 = v13 + (float)(*(float *)(v20 + 4 * (v7 | 1)) * v19);
          float v14 = v14 + (float)(*(float *)(v20 + 4 * (v7 | 2)) * v19);
          float v15 = v15 + (float)(*(float *)(v20 + 4 * (v7 | 3)) * v19);
          --v17;
        }
        while (v17);
      }
      if (v12 > v15) {
        float v15 = v12;
      }
      if (v13 > v15) {
        float v15 = v13;
      }
      if (v14 > v15) {
        float v15 = v14;
      }
      *uint64_t v11 = v12;
      v11[1] = v13;
      v11[2] = v14;
      v11 += 3;
      if (v15 >= 0.0) {
        float v21 = v15;
      }
      else {
        float v21 = 0.0;
      }
      if (v15 > 1.0) {
        float v21 = 1.0;
      }
      *v10++ = v21;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

void CGSConvertABGR8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertABGR8888toARGB8888", 111, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertABGR8888toARGB8888", 111, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    int v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    int v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    float v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    float v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      uint64_t v14 = 0;
      float v15 = v10 + 3;
      do
      {
        if (a5 >= 1)
        {
          int v16 = a5;
          int v17 = v15;
          do
          {
            char v18 = *(v17 - 2);
            *(v17 - 2) = *v17;
            *int v17 = v18;
            v17 += 4;
            --v16;
          }
          while (v16);
        }
        ++v14;
        v15 += v11;
      }
      while (v14 != v9);
    }
  }
  else
  {
    src.time_t data = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowBytes = v12;
    dest.time_t data = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 16909056;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

void CGSConvertBGRA8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertBGRA8888toARGB8888", 177, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertBGRA8888toARGB8888", 177, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    int v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    int v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    float v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    float v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          int v16 = (__int32 *)&v10[i * v11];
          int v17 = a5;
          do
          {
            v14.i32[0] = *v16;
            int16x8_t v18 = (int16x8_t)vmovl_u8(v14);
            *(int16x4_t *)v18.i8 = vrev64_s16(*(int16x4_t *)v18.i8);
            uint8x8_t v14 = (uint8x8_t)vmovn_s16(v18);
            *v16++ = v14.i32[0];
            --v17;
          }
          while (v17);
        }
      }
    }
  }
  else
  {
    src.time_t data = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowBytes = v12;
    dest.time_t data = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 66051;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

void CGSConvertBGRX8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertBGRX8888toARGB8888", 208, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertBGRX8888toARGB8888", 208, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    int v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    int v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    float v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    float v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          float v15 = &v10[i * v11];
          int v16 = a5;
          do
          {
            char v17 = *v15;
            char v18 = v15[1];
            char v19 = v15[2];
            *float v15 = -1;
            v15[1] = v19;
            v15[2] = v18;
            v15[3] = v17;
            v15 += 4;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  else
  {
    src.time_t data = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowBytes = v12;
    dest.time_t data = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 66051;
    *(_DWORD *)backgroundColor = -1;
    vImagePermuteChannelsWithMaskedInsert_ARGB8888(&src, &dest, permuteMap, 8u, backgroundColor, 0);
  }
}

void CGSConvertRGBA8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertRGBA8888toARGB8888", 274, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertRGBA8888toARGB8888", 274, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    int v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    int v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    float v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    float v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          int v16 = (__int32 *)&v10[i * v11];
          int v17 = a5;
          do
          {
            v14.i32[0] = *v16;
            int16x8_t v18 = (int16x8_t)vmovl_u8(v14);
            *(int8x8_t *)v18.i8 = vext_s8(*(int8x8_t *)v18.i8, *(int8x8_t *)v18.i8, 6uLL);
            uint8x8_t v14 = (uint8x8_t)vmovn_s16(v18);
            *v16++ = v14.i32[0];
            --v17;
          }
          while (v17);
        }
      }
    }
  }
  else
  {
    src.time_t data = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowBytes = v12;
    dest.time_t data = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 33619971;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

void CGSConvertRGBX8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertRGBX8888toARGB8888", 305, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertRGBX8888toARGB8888", 305, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    int v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    int v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    float v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    float v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          float v15 = &v10[i * v11];
          int v16 = a5;
          do
          {
            __int16 v17 = *(_WORD *)v15;
            char v18 = v15[2];
            *float v15 = -1;
            *(_WORD *)(v15 + 1) = v17;
            v15[3] = v18;
            v15 += 4;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  else
  {
    src.time_t data = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowBytes = v12;
    dest.time_t data = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 33619971;
    *(_DWORD *)backgroundColor = -1;
    vImagePermuteChannelsWithMaskedInsert_ARGB8888(&src, &dest, permuteMap, 8u, backgroundColor, 0);
  }
}

void CGSConvertXBGR8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertXBGR8888toARGB8888", 338, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertXBGR8888toARGB8888", 338, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    int v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    int v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    float v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    float v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      uint64_t v14 = 0;
      float v15 = v10 + 3;
      do
      {
        if (a5 >= 1)
        {
          int v16 = a5;
          __int16 v17 = v15;
          do
          {
            char v18 = *(v17 - 2);
            char v19 = *v17;
            *(v17 - 3) = -1;
            *(v17 - 2) = v19;
            *__int16 v17 = v18;
            v17 += 4;
            --v16;
          }
          while (v16);
        }
        ++v14;
        v15 += v11;
      }
      while (v14 != v9);
    }
  }
  else
  {
    src.time_t data = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowBytes = v12;
    dest.time_t data = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 16909056;
    *(_DWORD *)backgroundColor = -1;
    vImagePermuteChannelsWithMaskedInsert_ARGB8888(&src, &dest, permuteMap, 8u, backgroundColor, 0);
  }
}

vImage_Error CGSConvertXRGB8888toARGB8888(char *a1, int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertXRGB8888toARGB8888", 371, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertXRGB8888toARGB8888", 371, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  int v8 = &a1[((int)a6 - 1) * (uint64_t)a2];
  if (a4 >= 0) {
    int v9 = a2;
  }
  else {
    int v9 = -a2;
  }
  if (a4 >= 0) {
    int v8 = a1;
  }
  src.time_t data = v8;
  src.double height = (int)a6;
  src.double width = a5;
  src.rowBytes = v9;
  int v10 = &a3[((int)a6 - 1) * a4];
  if (a4 >= 0) {
    int v10 = a3;
  }
  dest.time_t data = v10;
  dest.double height = (int)a6;
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  dest.double width = a5;
  dest.rowBytes = v11;
  return vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, &src, &dest, 8u, 0);
}

void CGSConvertW8toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertW8toARGB8888", 387, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertW8toARGB8888", 387, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    int v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    int v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    float v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    float v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    uint64_t v14 = (char *)malloc_type_malloc((int)v11 * (int)a6, 0x4604072DuLL);
    float v15 = v14;
    if (v9 >= 1)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          __int16 v17 = &v14[i * v11];
          int v18 = a5;
          char v19 = &v13[i * (int)v12];
          do
          {
            char v20 = *v19++;
            *__int16 v17 = -1;
            v17[1] = v20;
            _OWORD v17[2] = v20;
            v17[3] = v20;
            v17 += 4;
            --v18;
          }
          while (v18);
        }
      }
    }
    CGBlt_copyBytes(4 * a5, v9, v14, v10, v11, v11);
    free(v15);
  }
  else
  {
    blue.time_t data = v13;
    blue.double height = (int)a6;
    blue.double width = a5;
    blue.rowBytes = v12;
    dest.time_t data = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowBytes = v11;
    vImageConvert_Planar8ToXRGB8888(0xFFu, &blue, &blue, &blue, &dest, 0);
  }
}

void CGSConvertW16toARGB8888(uint64_t a1, int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertW16toARGB8888", 552, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertW16toARGB8888", 552, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  uint64_t v10 = (int)a6 - 1;
  if (a4 < 0) {
    size_t v11 = &a3[v10 * a4];
  }
  else {
    size_t v11 = a3;
  }
  if (a4 >= 0) {
    uint64_t v12 = a4;
  }
  else {
    uint64_t v12 = -a4;
  }
  if (a4 >= 0) {
    int v13 = a2;
  }
  else {
    int v13 = -a2;
  }
  if (a4 < 0) {
    uint64_t v14 = a1 + (int)v10 * (uint64_t)a2;
  }
  else {
    uint64_t v14 = a1;
  }
  unint64_t v15 = v14 + (int)((v13 * v10) & (v13 >> 31));
  int v16 = v11;
  if (v15 <= (unint64_t)&v11[(int)a6 * (uint64_t)(int)v12])
  {
    int v17 = v13 >= 0 ? v13 : -v13;
    int v16 = v11;
    if (v15 + (int)a6 * (uint64_t)v17 >= (unint64_t)v11) {
      int v16 = (char *)malloc_type_malloc((int)a6 * (uint64_t)(int)v12, 0x46DC5C89uLL);
    }
  }
  if (v9 >= 1)
  {
    for (uint64_t i = 0; i != v9; ++i)
    {
      if (a5 >= 1)
      {
        char v19 = &v16[i * v12];
        int v20 = a5;
        float v21 = (char *)(v14 + i * v13);
        do
        {
          char v22 = *v21;
          v21 += 2;
          *char v19 = -1;
          v19[1] = v22;
          void v19[2] = v22;
          v19[3] = v22;
          v19 += 4;
          --v20;
        }
        while (v20);
      }
    }
  }
  if (v16 != v11)
  {
    CGBlt_copyBytes(4 * a5, v9, v16, v11, v12, v12);
    free(v16);
  }
}

void CGSConvertw16toARGB8888(uint64_t a1, int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertw16toARGB8888", 714, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertw16toARGB8888", 714, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  }
  uint64_t v10 = (int)a6 - 1;
  if (a4 < 0) {
    size_t v11 = &a3[v10 * a4];
  }
  else {
    size_t v11 = a3;
  }
  if (a4 >= 0) {
    uint64_t v12 = a4;
  }
  else {
    uint64_t v12 = -a4;
  }
  if (a4 >= 0) {
    int v13 = a2;
  }
  else {
    int v13 = -a2;
  }
  if (a4 < 0) {
    uint64_t v14 = a1 + (int)v10 * (uint64_t)a2;
  }
  else {
    uint64_t v14 = a1;
  }
  unint64_t v15 = v14 + (int)((v13 * v10) & (v13 >> 31));
  int v16 = v11;
  if (v15 <= (unint64_t)&v11[(int)a6 * (uint64_t)(int)v12])
  {
    int v17 = v13 >= 0 ? v13 : -v13;
    int v16 = v11;
    if (v15 + (int)a6 * (uint64_t)v17 >= (unint64_t)v11) {
      int v16 = (char *)malloc_type_malloc((int)a6 * (uint64_t)(int)v12, 0x262C1751uLL);
    }
  }
  if (v9 >= 1)
  {
    uint64_t v18 = 0;
    char v19 = (char *)(v14 + 1);
    do
    {
      if (a5 >= 1)
      {
        int v20 = &v16[v18 * v12];
        int v21 = a5;
        char v22 = v19;
        do
        {
          char v23 = *v22;
          v22 += 2;
          *int v20 = -1;
          v20[1] = v23;
          v20[2] = v23;
          v20[3] = v23;
          v20 += 4;
          --v21;
        }
        while (v21);
      }
      ++v18;
      v19 += v13;
    }
    while (v18 != v9);
  }
  if (v16 != v11)
  {
    CGBlt_copyBytes(4 * a5, v9, v16, v11, v12, v12);
    free(v16);
  }
}

char *fill_runs(char *result, _WORD *a2, _WORD *a3, unsigned int a4, int a5)
{
  unint64_t v6 = a3;
  unint64_t v7 = a2;
  int v8 = result;
  if (((a3 - a2) & 2) != 0)
  {
    *a3 = 0;
    unint64_t v6 = a3 + 1;
  }
  if (v6 > a2)
  {
    unsigned int v9 = 0;
    if (a5) {
      int v10 = -1;
    }
    else {
      int v10 = 0;
    }
    do
    {
      unsigned int v11 = (unsigned __int16)*v7;
      if (v9 + v11 > a4)
      {
        unsigned int v11 = a4 - v9;
        *unint64_t v7 = a4 - v9;
      }
      if (!v11) {
        goto LABEL_28;
      }
      uint64_t v12 = &v8[v9 >> 3];
      unsigned int v13 = 8 - (v9 & 7);
      if (v11 <= v13)
      {
        int v16 = (-1 << (8 - v11)) >> (v9 & 7);
        LOBYTE(v15) = v16;
      }
      else
      {
        if ((v9 & 7) != 0)
        {
          *uint64_t v12 = (-1 << v13) & *v12 | v10 & ~(-1 << v13);
          ++v12;
          v11 -= v13;
        }
        if (v11 >= 8)
        {
          uint64_t v14 = v11 >> 3;
          switch((int)v14)
          {
            case 1:
              goto LABEL_21;
            case 2:
              goto LABEL_20;
            case 3:
              goto LABEL_19;
            case 4:
              goto LABEL_18;
            case 5:
              goto LABEL_17;
            case 6:
              goto LABEL_16;
            case 7:
              v12[6] = v10;
LABEL_16:
              v12[5] = v10;
LABEL_17:
              v12[4] = v10;
LABEL_18:
              v12[3] = v10;
LABEL_19:
              v12[2] = v10;
LABEL_20:
              v12[1] = v10;
LABEL_21:
              *uint64_t v12 = v10;
              break;
            default:
              uint64_t result = (char *)memset(v12, v10, v11 >> 3);
              break;
          }
          v12 += v14;
          v11 &= 7u;
        }
        if (!v11) {
          goto LABEL_27;
        }
        int v15 = -1 << (8 - v11);
        LOBYTE(v16) = v15 & 0xFE;
      }
      *uint64_t v12 = *v12 & ~(_BYTE)v16 | v15 & v10;
LABEL_27:
      v9 += (unsigned __int16)*v7;
LABEL_28:
      int v10 = ~v10;
      ++v7;
    }
    while (v7 < v6);
  }
  return result;
}

void pdf_error(char *a1, ...)
{
  va_start(va, a1);
  if (pdf_is_verbose_onceToken != -1) {
    dispatch_once(&pdf_is_verbose_onceToken, &__block_literal_global_5_6606);
  }
  if (pdf_is_verbose_isVerbose)
  {
    uint64_t v2 = (FILE **)MEMORY[0x1E4F143C8];
    vfprintf_l((FILE *)*MEMORY[0x1E4F143C8], 0, a1, va);
    fprintf_l(*v2, 0, "\n");
  }
  else if (pdf_error_onceToken != -1)
  {
    dispatch_once(&pdf_error_onceToken, &__block_literal_global_6607);
  }
}

uint64_t __pdf_error_block_invoke()
{
  return fprintf((FILE *)*MEMORY[0x1E4F143C8], "CoreGraphics PDF has logged an error. Set environment variable \"%s\" to learn more.\n", "CG_PDF_VERBOSE");
}

char *__pdf_is_verbose_block_invoke()
{
  uint64_t result = getenv("CG_PDF_VERBOSE");
  pdf_is_verbose_isVerbose = result != 0;
  return result;
}

void pdf_log(char *a1, ...)
{
  va_start(va, a1);
  if (pdf_is_verbose_onceToken != -1) {
    dispatch_once(&pdf_is_verbose_onceToken, &__block_literal_global_5_6606);
  }
  if (pdf_is_verbose_isVerbose)
  {
    uint64_t v2 = (FILE **)MEMORY[0x1E4F143C8];
    vfprintf_l((FILE *)*MEMORY[0x1E4F143C8], 0, a1, va);
    fprintf_l(*v2, 0, "\n");
  }
}

long long *std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(long long *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  if (*(void *)result >= *a2)
  {
    if (v3 < v4)
    {
      uint64_t v8 = a2[2];
      long long v9 = *(_OWORD *)a2;
      uint64_t v10 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v10;
      *(_OWORD *)a3 = v9;
      a3[2] = v8;
      if (*(void *)result < *a2)
      {
        uint64_t v11 = *((void *)result + 2);
        long long v12 = *result;
        uint64_t v13 = a2[2];
        *uint64_t result = *(_OWORD *)a2;
        *((void *)result + 2) = v13;
        *(_OWORD *)a2 = v12;
        a2[2] = v11;
      }
    }
  }
  else
  {
    if (v3 >= v4)
    {
      uint64_t v14 = *((void *)result + 2);
      long long v15 = *result;
      uint64_t v16 = a2[2];
      *uint64_t result = *(_OWORD *)a2;
      *((void *)result + 2) = v16;
      *(_OWORD *)a2 = v15;
      a2[2] = v14;
      if (*a2 >= *a3) {
        return result;
      }
      uint64_t v5 = a2[2];
      long long v6 = *(_OWORD *)a2;
      uint64_t v17 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v17;
    }
    else
    {
      uint64_t v5 = *((void *)result + 2);
      long long v6 = *result;
      uint64_t v7 = a3[2];
      *uint64_t result = *(_OWORD *)a3;
      *((void *)result + 2) = v7;
    }
    *(_OWORD *)a3 = v6;
    a3[2] = v5;
  }
  return result;
}

__n128 std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((long long *)a1, a2, a3);
  if (*a3 < *(void *)a4)
  {
    uint64_t v9 = a3[2];
    __n128 result = *(__n128 *)a3;
    uint64_t v10 = *(void *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v10;
    *(__n128 *)a4 = result;
    *(void *)(a4 + 16) = v9;
    if (*a2 < *a3)
    {
      uint64_t v11 = a2[2];
      __n128 result = *(__n128 *)a2;
      uint64_t v12 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v12;
      *(__n128 *)a3 = result;
      a3[2] = v11;
      if (*(void *)a1 < *a2)
      {
        uint64_t v13 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v14 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v14;
        *(__n128 *)a2 = result;
        a2[2] = v13;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(__n128 *a1, uint64_t *a2, uint64_t *a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((uint64_t)a1, a2, a3, (uint64_t)a4).n128_u64[0];
  if ((int64_t)a4->n128_u64[0] < (int64_t)a5->n128_u64[0])
  {
    unint64_t v11 = a4[1].n128_u64[0];
    __n128 result = *a4;
    unint64_t v12 = a5[1].n128_u64[0];
    *a4 = *a5;
    a4[1].n128_u64[0] = v12;
    *a5 = result;
    a5[1].n128_u64[0] = v11;
    if (*a3 < (int64_t)a4->n128_u64[0])
    {
      uint64_t v13 = a3[2];
      __n128 result = *(__n128 *)a3;
      uint64_t v14 = a4[1].n128_i64[0];
      *(__n128 *)a3 = *a4;
      a3[2] = v14;
      *a4 = result;
      a4[1].n128_u64[0] = v13;
      if (*a2 < *a3)
      {
        uint64_t v15 = a2[2];
        __n128 result = *(__n128 *)a2;
        uint64_t v16 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v16;
        *(__n128 *)a3 = result;
        a3[2] = v15;
        if ((int64_t)a1->n128_u64[0] < *a2)
        {
          uint64_t v17 = a1[1].n128_i64[0];
          __n128 result = *a1;
          uint64_t v18 = a2[2];
          *a1 = *(__n128 *)a2;
          a1[1].n128_u64[0] = v18;
          *(__n128 *)a2 = result;
          a2[2] = v17;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      long long v6 = (long long *)(a2 - 24);
      if (*(void *)a1 < *(void *)(a2 - 24))
      {
        uint64_t v7 = *(void *)(a1 + 16);
        long long v8 = *(_OWORD *)a1;
        uint64_t v9 = *(void *)(a2 - 8);
        *(_OWORD *)a1 = *v6;
        *(void *)(a1 + 16) = v9;
        *long long v6 = v8;
        *(void *)(a2 - 8) = v7;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((long long *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a2 - 24));
      return 1;
    case 4uLL:
      std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(a1, (uint64_t *)(a1 + 24), (uint64_t *)(a1 + 48), a2 - 24);
      return 1;
    case 5uLL:
      std::__sort5[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__n128 *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a1 + 48), (__n128 *)(a1 + 72), (__n128 *)(a2 - 24));
      return 1;
    default:
      uint64_t v10 = (void *)(a1 + 48);
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((long long *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a1 + 48));
      uint64_t v11 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    uint64_t v14 = *(void *)v11;
    if (*v10 < *(void *)v11)
    {
      long long v18 = *(_OWORD *)(v11 + 8);
      uint64_t v15 = v12;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_OWORD *)(v16 + 72) = *(_OWORD *)(a1 + v15 + 48);
        *(void *)(v16 + 88) = *(void *)(a1 + v15 + 64);
        if (v15 == -48) {
          break;
        }
        v15 -= 24;
        if (*(void *)(v16 + 24) >= v14)
        {
          uint64_t v17 = a1 + v15 + 72;
          goto LABEL_12;
        }
      }
      uint64_t v17 = a1;
LABEL_12:
      *(void *)uint64_t v17 = v14;
      *(_OWORD *)(v17 + 8) = v18;
      if (++v13 == 8) {
        return v11 + 24 == a2;
      }
    }
    uint64_t v10 = (void *)v11;
    v12 += 24;
    v11 += 24;
    if (v11 == a2) {
      return 1;
    }
  }
}

unint64_t *ClipperLib::Int128Mul(unint64_t *this, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = -a2;
  }
  if (a3 >= 0) {
    uint64_t v4 = a3;
  }
  else {
    uint64_t v4 = -a3;
  }
  unint64_t v5 = v4 * (unint64_t)v3;
  unint64_t v6 = ((HIDWORD(v4) * (unint64_t)v3 + v4 * (unint64_t)HIDWORD(v3)) >> 32)
     + HIDWORD(v4) * (unint64_t)HIDWORD(v3);
  unint64_t v7 = v4 * v3;
  *this = v7;
  this[1] = v6;
  if (v7 < v5) {
    this[1] = ++v6;
  }
  if ((unint64_t)a2 >> 63 != (unint64_t)a3 >> 63)
  {
    unint64_t v8 = -(uint64_t)v6;
    if (v7) {
      unint64_t v8 = ~v6;
    }
    *this = -(uint64_t)v7;
    this[1] = v8;
  }
  return this;
}

void ClipperLib::clipperException::~clipperException(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&unk_1ED094538;
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }

  std::exception::~exception(this);
}

{
  uint64_t vars8;

  ClipperLib::clipperException::~clipperException(this);

  JUMPOUT(0x18532A2A0);
}

uint64_t ClipperLib::clipperException::what(ClipperLib::clipperException *this)
{
  uint64_t result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

ClipperLib::clipperException *ClipperLib::clipperException::clipperException(ClipperLib::clipperException *this, char *a2)
{
  *(void *)this = &unk_1ED094538;
  std::string::basic_string[abi:fe180100]<0>((void *)this + 1, a2);
  return this;
}

void sub_184E52688(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void virtual thunk to'ClipperLib::Clipper::~Clipper(ClipperLib::Clipper *this)
{
  uint64_t v1 = (void *)((char *)this + *(void *)(*(void *)this - 24));
  void *v1 = &unk_1ED094568;
  v1[18] = &unk_1ED0945B0;
  std::__list_imp<long long>::clear(v1 + 11);
  uint64_t v2 = (void *)v1[7];
  if (v2)
  {
    v1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)v1[4];
  if (v3)
  {
    v1[5] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)v1[1];
  if (v4)
  {
    v1[2] = v4;
    operator delete(v4);
  }
  ClipperLib::ClipperBase::~ClipperBase((ClipperLib::ClipperBase *)(v1 + 18));

  JUMPOUT(0x18532A2A0);
}

{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  uint64_t v1 = (void *)((char *)this + *(void *)(*(void *)this - 24));
  void *v1 = &unk_1ED094568;
  v1[18] = &unk_1ED0945B0;
  std::__list_imp<long long>::clear(v1 + 11);
  uint64_t v2 = (void *)v1[7];
  if (v2)
  {
    v1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)v1[4];
  if (v3)
  {
    v1[5] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)v1[1];
  if (v4)
  {
    v1[2] = v4;
    operator delete(v4);
  }

  ClipperLib::ClipperBase::~ClipperBase((ClipperLib::ClipperBase *)(v1 + 18));
}

uint64_t ClipperLib::PointInPolygon(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = 0;
  unint64_t v5 = a3;
  while (1)
  {
    unint64_t v6 = v5;
    unint64_t v5 = (void *)v5[7];
    uint64_t v7 = v5[2];
    if (v7 == a2)
    {
      uint64_t v8 = v5[1];
      if (v8 == a1) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v9 = v6[2];
      if (v9 == a2)
      {
        if (v8 <= a1 != v6[1] < a1) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v9 = v6[2];
    }
    if (v7 < a2 != v9 >= a2) {
      goto LABEL_20;
    }
    uint64_t v10 = v6[1];
    uint64_t v11 = v5[1];
    BOOL v13 = __OFSUB__(v10, a1);
    BOOL v12 = v10 - a1 < 0;
    uint64_t v14 = v10 - a1;
    if (v12 == v13) {
      break;
    }
    BOOL v13 = __OFSUB__(v11, a1);
    BOOL v15 = v11 == a1;
    BOOL v12 = v11 - a1 < 0;
    uint64_t v16 = v11 - a1;
    if (!(v12 ^ v13 | v15)) {
      goto LABEL_16;
    }
LABEL_20:
    if (v5 == a3) {
      return result;
    }
  }
  BOOL v13 = __OFSUB__(v11, a1);
  BOOL v15 = v11 == a1;
  BOOL v12 = v11 - a1 < 0;
  uint64_t v16 = v11 - a1;
  if (!(v12 ^ v13 | v15))
  {
    uint64_t result = (1 - result);
    goto LABEL_20;
  }
LABEL_16:
  double v17 = (double)v14 * (double)(v7 - a2) - (double)v16 * (double)(v9 - a2);
  if (v17 != 0.0)
  {
    if (v7 > v9 != v17 <= 0.0) {
      uint64_t result = (1 - result);
    }
    else {
      uint64_t result = result;
    }
    goto LABEL_20;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ClipperLib::Clipper::FixupFirstLefts2(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *(void *)result;
  uint64_t v21 = *(void *)(a3 + 8);
  uint64_t v3 = *(void *)(*(void *)result - 24);
  uint64_t v4 = *(void *)(result + v3 + 80);
  if (*(void *)(result + v3 + 88) != v4)
  {
    uint64_t v7 = result;
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(v4 + 8 * v8);
      uint64_t v10 = *(uint64_t **)(v9 + 24);
      if (v9 != a2 && v9 != a3 && v10 != 0)
      {
        uint64_t v13 = *(void *)(v9 + 8);
        if (v13)
        {
          uint64_t v14 = *(void *)(v9 + 8);
          do
          {
            if (*(void *)(v14 + 24)) {
              break;
            }
            uint64_t v14 = *(void *)(v14 + 8);
          }
          while (v14);
        }
        else
        {
          uint64_t v14 = 0;
        }
        if (v14 == a3 || v14 == v21 || v14 == a2)
        {
          BOOL v15 = *(void **)(a2 + 24);
          uint64_t v16 = *(uint64_t **)(v9 + 24);
          while (1)
          {
            uint64_t result = ClipperLib::PointInPolygon(v16[1], v16[2], v15);
            if ((result & 0x80000000) == 0) {
              break;
            }
            uint64_t v16 = (uint64_t *)v16[7];
            if (v16 == v10)
            {
              uint64_t v17 = a2;
LABEL_29:
              *(void *)(v9 + 8) = v17;
              uint64_t v3 = *(void *)(v20 - 24);
              goto LABEL_30;
            }
          }
          uint64_t v17 = a2;
          if (result) {
            goto LABEL_29;
          }
          long long v18 = *(void **)(a3 + 24);
          char v19 = v10;
          while (1)
          {
            uint64_t result = ClipperLib::PointInPolygon(v19[1], v19[2], v18);
            if ((result & 0x80000000) == 0) {
              break;
            }
            char v19 = (uint64_t *)v19[7];
            if (v19 == v10)
            {
              uint64_t v17 = a3;
              goto LABEL_29;
            }
          }
          uint64_t v17 = a3;
          if (result) {
            goto LABEL_29;
          }
          uint64_t v17 = v21;
          if (v13 == a2) {
            goto LABEL_29;
          }
          uint64_t v17 = v21;
          if (v13 == a3) {
            goto LABEL_29;
          }
        }
      }
LABEL_30:
      ++v8;
      uint64_t v4 = *(void *)(v7 + v3 + 80);
    }
    while (v8 < (*(void *)(v7 + v3 + 88) - v4) >> 3);
  }
  return result;
}

uint64_t ClipperLib::Clipper::FixupFirstLefts1(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)result;
  uint64_t v4 = *(void *)(*(void *)result - 24);
  uint64_t v5 = *(void *)(result + v4 + 80);
  if (*(void *)(result + v4 + 88) != v5)
  {
    uint64_t v8 = result;
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(v5 + 8 * v9);
      for (uint64_t i = *(void *)(v10 + 8); i; uint64_t i = *(void *)(i + 8))
      {
        if (*(void *)(i + 24)) {
          break;
        }
      }
      if (i == a2)
      {
        BOOL v12 = *(uint64_t **)(v10 + 24);
        if (v12)
        {
          uint64_t v13 = *(void **)(a3 + 24);
          uint64_t v14 = *(uint64_t **)(v10 + 24);
          while (1)
          {
            uint64_t result = ClipperLib::PointInPolygon(v14[1], v14[2], v13);
            if ((result & 0x80000000) == 0) {
              break;
            }
            uint64_t v14 = (uint64_t *)v14[7];
            if (v14 == v12) {
              goto LABEL_13;
            }
          }
          if (!result) {
            goto LABEL_14;
          }
LABEL_13:
          *(void *)(v10 + 8) = a3;
          uint64_t v4 = *(void *)(v3 - 24);
        }
      }
LABEL_14:
      ++v9;
      uint64_t v5 = *(void *)(v8 + v4 + 80);
    }
    while (v9 < (*(void *)(v8 + v4 + 88) - v5) >> 3);
  }
  return result;
}

int *ClipperLib::Clipper::GetOutRec(int *this, int a2)
{
  uint64_t v2 = *(void *)((char *)this + *(void *)(*(void *)this - 24) + 80);
  unint64_t v3 = (*(void *)((char *)this + *(void *)(*(void *)this - 24) + 88) - v2) >> 3;
  if (v3 > a2)
  {
    uint64_t v4 = *(int **)(v2 + 8 * a2);
    while (1)
    {
      this = v4;
      unint64_t v5 = *v4;
      if (v3 <= v5) {
        break;
      }
      uint64_t v4 = *(int **)(v2 + 8 * v5);
      if (this == v4) {
        return this;
      }
    }
  }
  __break(1u);
  return this;
}

uint64_t ClipperLib::GetLowermostRec(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  BottomPt = *(void **)(a1 + 32);
  if (!BottomPt)
  {
    BottomPt = (void *)ClipperLib::GetBottomPt(*(void **)(v3 + 24));
    *(void *)(v3 + 32) = BottomPt;
  }
  unint64_t v5 = *(void **)(a2 + 32);
  if (!v5)
  {
    unint64_t v5 = (void *)ClipperLib::GetBottomPt(*(void **)(a2 + 24));
    *(void *)(a2 + 32) = v5;
    BottomPt = *(void **)(v3 + 32);
  }
  uint64_t v6 = BottomPt[2];
  uint64_t v7 = v5[2];
  if (v6 <= v7)
  {
    if (v6 < v7) {
      return a2;
    }
    uint64_t v8 = BottomPt[1];
    uint64_t v9 = v5[1];
    if (v8 < v9) {
      return v3;
    }
    if (v8 > v9 || (void *)BottomPt[7] == BottomPt)
    {
      return a2;
    }
    else if ((void *)v5[7] != v5 && !ClipperLib::FirstIsBottomPt((uint64_t)BottomPt, v5))
    {
      return a2;
    }
  }
  return v3;
}

uint64_t ClipperLib::Clipper::JoinPoints(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (void *)*a2;
  uint64_t v7 = (void *)a2[1];
  uint64_t v8 = *(void *)(*a2 + 8);
  uint64_t v9 = *(void *)(*a2 + 16);
  uint64_t v10 = a2[3];
  if (v9 != v10)
  {
    uint64_t v44 = (uint64_t)(v6 + 7);
    do
    {
      double v45 = *(void **)v44;
      uint64_t v46 = *(void *)(*(void *)v44 + 8);
      uint64_t v47 = *(void *)(*(void *)v44 + 16);
      uint64_t v44 = *(void *)v44 + 56;
    }
    while (v45 != v6 && v46 == v8 && v47 == v9);
    if (v47 <= v9
      && (uint64_t v84 = *a1,
          uint64_t v85 = a2[2],
          ClipperLib::SlopesEqual(v8, v9, v46, v47, v85, v10, *((unsigned __int8 *)a1 + *(void *)(*a1 - 24) + 40))))
    {
      uint64_t v82 = a4;
      int v81 = 0;
    }
    else
    {
      double v45 = v6;
      do
      {
        double v45 = (void *)v45[8];
        uint64_t v50 = v45[1];
        uint64_t v51 = v45[2];
      }
      while (v45 != v6 && v50 == v8 && v51 == v9);
      if (v51 > v9) {
        return 0;
      }
      uint64_t v84 = *a1;
      uint64_t v85 = a2[2];
      if (!ClipperLib::SlopesEqual(v8, v9, v50, v51, v85, v10, *((unsigned __int8 *)a1 + *(void *)(*a1 - 24) + 40))) {
        return 0;
      }
      uint64_t v82 = a4;
      int v81 = 1;
    }
    uint64_t v54 = v7[1];
    uint64_t v55 = (uint64_t)(v7 + 7);
    uint64_t v56 = v7[2];
    do
    {
      unint64_t v57 = *(void **)v55;
      uint64_t v58 = *(void *)(*(void *)v55 + 8);
      uint64_t v59 = *(void *)(*(void *)v55 + 16);
      uint64_t v55 = *(void *)v55 + 56;
    }
    while (v58 == v54 && v59 == v56 && v57 != v7);
    if (v59 <= v56
      && ClipperLib::SlopesEqual(v54, v7[2], v58, v59, v85, v10, *((unsigned __int8 *)a1 + *(void *)(v84 - 24) + 40)))
    {
      int v62 = 0;
    }
    else
    {
      unint64_t v57 = v7;
      do
      {
        unint64_t v57 = (void *)v57[8];
        uint64_t v63 = v57[1];
        uint64_t v64 = v57[2];
      }
      while (v63 == v54 && v64 == v56 && v57 != v7);
      if (v64 > v56
        || !ClipperLib::SlopesEqual(v54, v56, v63, v64, v85, v10, *((unsigned __int8 *)a1 + *(void *)(v84 - 24) + 40)))
      {
        return 0;
      }
      int v62 = 1;
    }
    uint64_t v67 = 0;
    if (v45 == v57 || v45 == v6 || v57 == v7) {
      return v67;
    }
    if (a3 != v82 || v81 != v62) {
      operator new();
    }
    return 0;
  }
  uint64_t v11 = (void *)*a2;
  if (a2[2] == v8)
  {
    BOOL v12 = v8 == v7[1] && v9 == v7[2];
    uint64_t v11 = (void *)*a2;
    if (v12)
    {
      if (a3 == a4)
      {
        unint64_t v69 = (void *)*a2;
        while (1)
        {
          unint64_t v69 = (void *)v69[7];
          if (v69 == v6) {
            break;
          }
          uint64_t v70 = v69[2];
          if (v69[1] != v8 || v70 != v9) {
            goto LABEL_146;
          }
        }
        uint64_t v70 = *(void *)(*a2 + 16);
LABEL_146:
        uint64_t v72 = (void *)a2[1];
        do
        {
          uint64_t v72 = (void *)v72[7];
          if (v72 == v7)
          {
            if (v70 > v9) {
              goto LABEL_155;
            }
            return 0;
          }
          uint64_t v73 = v72[2];
        }
        while (v72[1] == v8 && v73 == v9);
        if (v70 > v9 == v73 <= v9) {
LABEL_155:
        }
          operator new();
      }
      return 0;
    }
  }
  do
  {
    uint64_t v13 = v11;
    uint64_t v11 = (void *)v11[8];
  }
  while (v11 != v6 && v11[2] == v9 && v11 != v7);
  do
  {
    uint64_t v16 = v6;
    uint64_t v6 = (void *)v6[7];
  }
  while (v6 != v13 && v6[2] == v9 && v6 != v7);
  if (v6 == v13 || v6 == v7) {
    return 0;
  }
  uint64_t v20 = v7[2];
  uint64_t v21 = (void *)a2[1];
  do
  {
    char v22 = v21;
    uint64_t v21 = (void *)v21[8];
  }
  while (v21 != v16 && v21[2] == v20 && v21 != v7);
  do
  {
    float v25 = v7;
    uint64_t v7 = (void *)v7[7];
  }
  while (v7 != v13 && v7 != v22 && v7[2] == v20);
  if (v7 == v22 || v7 == v13) {
    return 0;
  }
  uint64_t v29 = v13[1];
  uint64_t v30 = v16[1];
  uint64_t v31 = v22[1];
  uint64_t v32 = v25[1];
  if (v30 <= v32) {
    uint64_t v33 = v25[1];
  }
  else {
    uint64_t v33 = v16[1];
  }
  if (v31 >= v29) {
    uint64_t v34 = v13[1];
  }
  else {
    uint64_t v34 = v22[1];
  }
  if (v30 <= v31) {
    uint64_t v35 = v22[1];
  }
  else {
    uint64_t v35 = v16[1];
  }
  if (v32 >= v29) {
    uint64_t v36 = v13[1];
  }
  else {
    uint64_t v36 = v25[1];
  }
  if (v31 < v32) {
    uint64_t v34 = v36;
  }
  else {
    uint64_t v35 = v33;
  }
  if (v29 <= v32) {
    uint64_t v37 = v25[1];
  }
  else {
    uint64_t v37 = v13[1];
  }
  if (v31 >= v30) {
    uint64_t v38 = v16[1];
  }
  else {
    uint64_t v38 = v22[1];
  }
  if (v29 <= v31) {
    uint64_t v39 = v22[1];
  }
  else {
    uint64_t v39 = v13[1];
  }
  if (v32 >= v30) {
    uint64_t v40 = v16[1];
  }
  else {
    uint64_t v40 = v25[1];
  }
  if (v31 < v32) {
    uint64_t v38 = v40;
  }
  else {
    uint64_t v39 = v37;
  }
  if (v29 < v30)
  {
    uint64_t v35 = v39;
    uint64_t v34 = v38;
  }
  if (v35 >= v34) {
    return 0;
  }
  if (v29 < v35 || v29 > v34)
  {
    if (v31 < v35 || v31 > v34)
    {
      if (v30 < v35 || v30 > v34)
      {
        uint64_t v41 = v25[2];
        uint64_t v42 = v25[1];
      }
      else
      {
        uint64_t v41 = v16[2];
        uint64_t v42 = v16[1];
      }
    }
    else
    {
      uint64_t v41 = v22[2];
      uint64_t v42 = v22[1];
    }
  }
  else
  {
    uint64_t v41 = v13[2];
    uint64_t v42 = v13[1];
  }
  *a2 = v13;
  a2[1] = v22;
  int v75 = v29 <= v30;
  unsigned int v76 = v31 <= v32;
  uint64_t v67 = v75 ^ v76;
  if (v75 != v76)
  {
    if (v29 <= v30)
    {
      do
      {
        uint64_t v77 = v13;
        uint64_t v13 = (void *)v13[7];
        uint64_t v78 = v13[1];
      }
      while (v78 <= v42 && v78 >= v77[1] && v13[2] == v41);
      ClipperLib::DupOutPt();
    }
    do
    {
      uint64_t v79 = v13;
      uint64_t v13 = (void *)v13[7];
      uint64_t v80 = v13[1];
    }
    while (v80 >= v42 && v80 <= v79[1] && v13[2] == v41);
    ClipperLib::DupOutPt();
  }
  return v67;
}

void ClipperLib::DupOutPt()
{
}

uint64_t ClipperLib::GetBottomPt(void *a1)
{
  uint64_t v1 = (uint64_t)a1;
  uint64_t v2 = (void *)a1[7];
  if (v2 == a1) {
    return v1;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v4 = v2[2];
    uint64_t v5 = *(void *)(v1 + 16);
    if (v4 > v5)
    {
LABEL_4:
      uint64_t v3 = 0;
      uint64_t v1 = (uint64_t)v2;
      goto LABEL_11;
    }
    if (v4 == v5)
    {
      uint64_t v6 = v2[1];
      uint64_t v7 = *(void *)(v1 + 8);
      if (v6 <= v7)
      {
        if (v6 < v7) {
          goto LABEL_4;
        }
        if (v2[7] != v1 && v2[8] != v1) {
          uint64_t v3 = v2;
        }
      }
    }
LABEL_11:
    uint64_t v2 = (void *)v2[7];
  }
  while (v2 != (void *)v1);
  if (!v3 || v3 == (void *)v1) {
    return v1;
  }
  uint64_t v8 = (void *)v1;
  do
  {
    if (!ClipperLib::FirstIsBottomPt(v1, v3)) {
      uint64_t v8 = v3;
    }
    do
      uint64_t v3 = (void *)v3[7];
    while (v3[1] != v8[1] || v3[2] != v8[2]);
  }
  while (v3 != (void *)v1);
  return (uint64_t)v8;
}

uint64_t ClipperLib::FirstIsBottomPt(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = *(void *)(result + 16);
  uint64_t v4 = (void *)result;
  do
  {
    uint64_t v4 = (void *)v4[8];
    uint64_t v5 = v4[1];
    uint64_t v6 = v4[2];
  }
  while (v4 != (void *)result && v5 == v2 && v6 == v3);
  uint64_t v9 = v6 - v3;
  if (v9) {
    double v10 = (double)(v5 - v2) / (double)v9;
  }
  else {
    double v10 = -1.0e40;
  }
  uint64_t v11 = (void *)result;
  do
  {
    uint64_t v11 = (void *)v11[7];
    uint64_t v12 = v11[1];
    uint64_t v13 = v11[2];
  }
  while (v11 != (void *)result && v12 == v2 && v13 == v3);
  uint64_t v16 = v13 - v3;
  if (v16) {
    double v17 = (double)(v12 - v2) / (double)v16;
  }
  else {
    double v17 = -1.0e40;
  }
  double v18 = fabs(v10);
  uint64_t v19 = a2[1];
  uint64_t v20 = a2[2];
  uint64_t v21 = a2;
  do
  {
    uint64_t v21 = (void *)v21[8];
    uint64_t v22 = v21[1];
    uint64_t v23 = v21[2];
  }
  while (v21 != a2 && v22 == v19 && v23 == v20);
  if (v23 == v20) {
    double v26 = -1.0e40;
  }
  else {
    double v26 = (double)(v22 - v19) / (double)(v23 - v20);
  }
  double v27 = fabs(v17);
  float v28 = a2;
  do
  {
    float v28 = (void *)v28[7];
    uint64_t v29 = v28[1];
    uint64_t v30 = v28[2];
  }
  while (v28 != a2 && v29 == v19 && v30 == v20);
  double v33 = fabs(v26);
  uint64_t v34 = v30 - v20;
  if (v34) {
    double v35 = (double)(v29 - v19) / (double)v34;
  }
  else {
    double v35 = -1.0e40;
  }
  double v36 = fabs(v35);
  if (v18 >= v27) {
    double v37 = v18;
  }
  else {
    double v37 = v27;
  }
  if (v33 >= v36) {
    double v38 = v33;
  }
  else {
    double v38 = v36;
  }
  if (v37 == v38 && (v27 >= v18 ? (double v39 = v18) : (double v39 = v27), v36 >= v33 ? (v40 = v33) : (v40 = v36), v39 == v40))
  {
    if (result)
    {
      double v41 = 0.0;
      uint64_t v42 = (void *)result;
      do
      {
        double v41 = v41
            + (double)(uint64_t)(v42[1] + *(void *)(v42[8] + 8))
            * (double)(uint64_t)(*(void *)(v42[8] + 16) - v42[2]);
        uint64_t v42 = (void *)v42[7];
      }
      while (v42 != (void *)result);
      return v41 * 0.5 > 0.0;
    }
  }
  else
  {
    BOOL v43 = v27 >= v33;
    if (v27 < v36) {
      BOOL v43 = 0;
    }
    return v18 >= v33 && v18 >= v36 || v43;
  }
  return result;
}

void ClipperLib::Clipper::AddJoin()
{
}

BOOL ClipperLib::SlopesEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a9)
  {
    ClipperLib::Int128Mul(v16, a2 - a4, a5 - a7);
    ClipperLib::Int128Mul(v15, a1 - a3, a6 - a8);
    return v16[1] == v15[1] && v16[0] == v15[0];
  }
  else
  {
    return (a5 - a7) * (a2 - a4) == (a6 - a8) * (a1 - a3);
  }
}

void *ClipperLib::Clipper::AppendPolygon(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(int *)(a2 + 172);
  uint64_t v4 = *(void *)((char *)result + *(void *)(*result - 24) + 80);
  unint64_t v5 = (*(void *)((char *)result + *(void *)(*result - 24) + 88) - v4) >> 3;
  if (v5 <= v3 || (unint64_t v7 = *(int *)(a3 + 172), v5 <= v7))
  {
    __break(1u);
  }
  else
  {
    uint64_t v9 = result;
    uint64_t v10 = *(void *)(v4 + 8 * v3);
    uint64_t v11 = *(void *)(v4 + 8 * v7);
    uint64_t v12 = v10;
    do
      uint64_t v12 = *(void *)(v12 + 8);
    while (v12 != v11 && v12 != 0);
    uint64_t result = (void *)v11;
    if (v12 != v11)
    {
      uint64_t v14 = v11;
      do
        uint64_t v14 = *(void *)(v14 + 8);
      while (v14 != v10 && v14 != 0);
      uint64_t result = (void *)v10;
      if (v14 != v10) {
        uint64_t result = (void *)ClipperLib::GetLowermostRec(v10, v11);
      }
    }
    uint64_t v16 = *(void *)(v10 + 24);
    uint64_t v17 = *(void *)(v16 + 64);
    uint64_t v18 = *(void *)(v11 + 24);
    uint64_t v19 = *(void *)(v18 + 64);
    int v20 = *(_DWORD *)(a2 + 156);
    int v21 = *(_DWORD *)(a3 + 156);
    if (v20 == 1)
    {
      if (v21 == 1)
      {
        uint64_t v22 = *(void *)(v11 + 24);
        do
        {
          int8x16_t v23 = *(int8x16_t *)(v22 + 56);
          *(int8x16_t *)(v22 + 56) = vextq_s8(v23, v23, 8uLL);
          uint64_t v22 = v23.i64[0];
        }
        while (v23.i64[0] != v18);
        *(void *)(v18 + 56) = v16;
        *(void *)(v16 + 64) = v18;
        *(void *)(v17 + 56) = v19;
        *(void *)(v19 + 64) = v17;
        *(void *)(v10 + 24) = v19;
      }
      else
      {
        *(void *)(v19 + 56) = v16;
        *(void *)(v16 + 64) = v19;
        *(void *)(v18 + 64) = v17;
        *(void *)(v17 + 56) = v18;
        *(void *)(v10 + 24) = v18;
      }
    }
    else if (v21 == 2)
    {
      uint64_t v24 = *(void *)(v11 + 24);
      do
      {
        int8x16_t v25 = *(int8x16_t *)(v24 + 56);
        *(int8x16_t *)(v24 + 56) = vextq_s8(v25, v25, 8uLL);
        uint64_t v24 = v25.i64[0];
      }
      while (v25.i64[0] != v18);
      *(void *)(v17 + 56) = v19;
      *(void *)(v19 + 64) = v17;
      *(void *)(v18 + 56) = v16;
      *(void *)(v16 + 64) = v18;
    }
    else
    {
      *(void *)(v17 + 56) = v18;
      *(void *)(v18 + 64) = v17;
      *(void *)(v16 + 64) = v19;
      *(void *)(v19 + 56) = v16;
    }
    *(void *)(v10 + 32) = 0;
    if (result == (void *)v11)
    {
      uint64_t v26 = *(void *)(v11 + 8);
      if (v26 != v10) {
        *(void *)(v10 + 8) = v26;
      }
      *(unsigned char *)(v10 + 4) = *(unsigned char *)(v11 + 4);
    }
    *(void *)(v11 + 24) = 0;
    *(void *)(v11 + 32) = 0;
    *(void *)(v11 + 8) = v10;
    int v27 = *(_DWORD *)(a2 + 172);
    int v28 = *(_DWORD *)(a3 + 172);
    *(_DWORD *)(a2 + 172) = -1;
    *(_DWORD *)(a3 + 172) = -1;
    uint64_t v29 = *(void *)((char *)v9 + *(void *)(*v9 - 24) + 104);
    if (v29)
    {
      while (*(_DWORD *)(v29 + 172) != v28)
      {
        uint64_t v29 = *(void *)(v29 + 200);
        if (!v29) {
          goto LABEL_38;
        }
      }
      *(_DWORD *)(v29 + 172) = v27;
      *(_DWORD *)(v29 + 156) = v20;
    }
LABEL_38:
    *(_DWORD *)uint64_t v11 = *(_DWORD *)v10;
  }
  return result;
}

uint64_t ClipperLib::Clipper::DisposeIntersectNodes(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v3 = *(void *)(this + 56);
  uint64_t v2 = *(void *)(this + 64);
  if (v2 == v3)
  {
    uint64_t v3 = *(void *)(this + 64);
  }
  else
  {
    unint64_t v4 = 0;
    do
    {
      this = *(void *)(v3 + 8 * v4);
      if (this)
      {
        this = MEMORY[0x18532A2A0](this, 0x1020C40038FC326);
        uint64_t v3 = *(void *)(v1 + 56);
        uint64_t v2 = *(void *)(v1 + 64);
      }
      ++v4;
    }
    while (v4 < (v2 - v3) >> 3);
  }
  *(void *)(v1 + 64) = v3;
  return this;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(uint64_t result, char *a2, uint64_t (**a3)(void), uint64_t a4, char a5)
{
  uint64_t v10 = (char *)result;
  while (2)
  {
    uint64_t v11 = a2 - 8;
    uint64_t v12 = v10;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v10 = v12;
          uint64_t v13 = a2 - v12;
          uint64_t v14 = (a2 - v12) >> 3;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t result = ((uint64_t (*)(void, void))*a3)(*(void *)v11, *(void *)v12);
                if (result)
                {
                  uint64_t v44 = *(void *)v12;
                  *(void *)uint64_t v12 = *(void *)v11;
                  *(void *)uint64_t v11 = v44;
                }
                break;
              case 3:
                uint64_t result = std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v12, (void *)v12 + 1, v11, a3);
                break;
              case 4:
                uint64_t result = std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v12, (void *)v12 + 1, (void *)v12 + 2, v11, a3);
                break;
              case 5:
                uint64_t result = std::__sort5[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v12, (void *)v12 + 1, (void *)v12 + 2, (void *)v12 + 3, v11, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            double v45 = v12 + 8;
            BOOL v47 = v12 == a2 || v45 == a2;
            if (a5)
            {
              if (!v47)
              {
                uint64_t v48 = 0;
                double v49 = v12;
                do
                {
                  uint64_t v50 = *(void *)v49;
                  double v49 = v45;
                  uint64_t result = ((uint64_t (*)(void, uint64_t))*a3)(*(void *)v45, v50);
                  if (result)
                  {
                    uint64_t v51 = *(void *)v45;
                    uint64_t v52 = v48;
                    while (1)
                    {
                      *(void *)&v12[v52 + 8] = *(void *)&v12[v52];
                      if (!v52) {
                        break;
                      }
                      uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v51, *(void *)&v12[v52 - 8]);
                      v52 -= 8;
                      if ((result & 1) == 0)
                      {
                        uint64_t v53 = &v12[v52 + 8];
                        goto LABEL_86;
                      }
                    }
                    uint64_t v53 = v12;
LABEL_86:
                    *(void *)uint64_t v53 = v51;
                  }
                  double v45 = v49 + 8;
                  v48 += 8;
                }
                while (v49 + 8 != a2);
              }
            }
            else if (!v47)
            {
              uint64_t v76 = 0;
              uint64_t v77 = -1;
              uint64_t v78 = 1;
              do
              {
                uint64_t v79 = *(void *)&v12[8 * v76];
                uint64_t v76 = v78;
                uint64_t result = ((uint64_t (*)(void, uint64_t))*a3)(*(void *)v45, v79);
                if (result)
                {
                  uint64_t v80 = *(void *)v45;
                  uint64_t v81 = v77;
                  uint64_t v82 = v45;
                  do
                  {
                    *(void *)uint64_t v82 = *((void *)v82 - 1);
                    if (!v81) {
                      goto LABEL_132;
                    }
                    uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v80, *((void *)v82 - 2));
                    v82 -= 8;
                    ++v81;
                  }
                  while ((result & 1) != 0);
                  *(void *)uint64_t v82 = v80;
                }
                uint64_t v78 = v76 + 1;
                v45 += 8;
                --v77;
              }
              while (v45 != a2);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != a2)
            {
              int64_t v54 = (unint64_t)(v14 - 2) >> 1;
              int64_t v88 = v54;
              do
              {
                int64_t v55 = v54;
                if (v88 >= v54)
                {
                  uint64_t v56 = (2 * v54) | 1;
                  unint64_t v57 = &v10[8 * v56];
                  if (2 * v54 + 2 < v14
                    && ((unsigned int (*)(void, void))*a3)(*(void *)v57, *((void *)v57 + 1)))
                  {
                    v57 += 8;
                    uint64_t v56 = 2 * v55 + 2;
                  }
                  uint64_t v58 = &v10[8 * v55];
                  uint64_t result = ((uint64_t (*)(void, void))*a3)(*(void *)v57, *(void *)v58);
                  if ((result & 1) == 0)
                  {
                    int64_t v83 = v55;
                    uint64_t v85 = *(void *)v58;
                    do
                    {
                      uint64_t v59 = v57;
                      *(void *)uint64_t v58 = *(void *)v57;
                      if (v88 < v56) {
                        break;
                      }
                      uint64_t v60 = (2 * v56) | 1;
                      unint64_t v57 = &v10[8 * v60];
                      uint64_t v61 = 2 * v56 + 2;
                      if (v61 < v14
                        && ((unsigned int (*)(void, void))*a3)(*(void *)v57, *((void *)v57 + 1)))
                      {
                        v57 += 8;
                        uint64_t v60 = v61;
                      }
                      uint64_t result = ((uint64_t (*)(void, uint64_t))*a3)(*(void *)v57, v85);
                      uint64_t v58 = v59;
                      uint64_t v56 = v60;
                    }
                    while (!result);
                    int64_t v55 = v83;
                    *(void *)uint64_t v59 = v85;
                  }
                }
                int64_t v54 = v55 - 1;
              }
              while (v55);
              uint64_t v62 = (unint64_t)v13 >> 3;
              do
              {
                uint64_t v63 = 0;
                uint64_t v64 = v62 - 2;
                uint64_t v86 = *(void *)v10;
                if (v62 < 2) {
                  uint64_t v64 = v62 - 1;
                }
                uint64_t v65 = v64 >> 1;
                uint64_t v66 = v10;
                do
                {
                  uint64_t v67 = &v66[8 * v63 + 8];
                  uint64_t v68 = (2 * v63) | 1;
                  uint64_t v69 = 2 * v63 + 2;
                  if (v69 < v62)
                  {
                    uint64_t result = ((uint64_t (*)(void, void))*a3)(*(void *)&v66[8 * v63 + 8], *(void *)&v66[8 * v63 + 16]);
                    if (result)
                    {
                      v67 += 8;
                      uint64_t v68 = v69;
                    }
                  }
                  *(void *)uint64_t v66 = *(void *)v67;
                  uint64_t v66 = v67;
                  uint64_t v63 = v68;
                }
                while (v68 <= v65);
                a2 -= 8;
                if (v67 == a2)
                {
                  *(void *)uint64_t v67 = v86;
                }
                else
                {
                  *(void *)uint64_t v67 = *(void *)a2;
                  *(void *)a2 = v86;
                  uint64_t v70 = v67 - v10 + 8;
                  if (v70 >= 9)
                  {
                    unint64_t v71 = (unint64_t)((v70 >> 3) - 2) >> 1;
                    uint64_t v72 = &v10[8 * v71];
                    uint64_t result = ((uint64_t (*)(void, void))*a3)(*(void *)v72, *(void *)v67);
                    if (result)
                    {
                      uint64_t v73 = *(void *)v67;
                      do
                      {
                        uint64_t v74 = v72;
                        *(void *)uint64_t v67 = *(void *)v72;
                        if (!v71) {
                          break;
                        }
                        unint64_t v71 = (v71 - 1) >> 1;
                        uint64_t v72 = &v10[8 * v71];
                        uint64_t result = ((uint64_t (*)(void, uint64_t))*a3)(*(void *)v72, v73);
                        uint64_t v67 = v74;
                      }
                      while ((result & 1) != 0);
                      *(void *)uint64_t v74 = v73;
                    }
                  }
                }
              }
              while (v62-- > 2);
            }
            return result;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          uint64_t v16 = &v12[8 * ((unint64_t)v14 >> 1)];
          if ((unint64_t)v13 < 0x401)
          {
            std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v16, v12, v11, a3);
          }
          else
          {
            std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v12, v16, v11, a3);
            std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((void *)v12 + 1, (void *)v16 - 1, (void *)a2 - 2, a3);
            std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((void *)v12 + 2, &v12[8 * v15 + 8], (void *)a2 - 3, a3);
            std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((void *)v16 - 1, v16, &v12[8 * v15 + 8], a3);
            uint64_t v17 = *(void *)v12;
            *(void *)uint64_t v12 = *(void *)v16;
            *(void *)uint64_t v16 = v17;
          }
          --a4;
          if ((a5 & 1) != 0
            || (((uint64_t (*)(void, void))*a3)(*((void *)v12 - 1), *(void *)v12) & 1) != 0)
          {
            break;
          }
          uint64_t v34 = *(void *)v12;
          uint64_t result = ((uint64_t (*)(void, void))*a3)(*(void *)v12, *(void *)v11);
          double v35 = v12 + 8;
          if (result)
          {
            do
            {
              if (v35 == a2) {
                goto LABEL_132;
              }
              uint64_t v36 = *(void *)v35;
              v35 += 8;
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v34, v36);
            }
            while ((result & 1) == 0);
            uint64_t v12 = v35 - 8;
          }
          else
          {
            do
            {
              uint64_t v12 = v35;
              if (v35 >= a2) {
                break;
              }
              v35 += 8;
              uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v34, *(void *)v12);
            }
            while ((result & 1) == 0);
          }
          double v37 = a2;
          if (v12 < a2)
          {
            double v37 = a2;
            while (v37 != v10)
            {
              uint64_t v38 = *((void *)v37 - 1);
              v37 -= 8;
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v34, v38);
              if ((result & 1) == 0) {
                goto LABEL_53;
              }
            }
LABEL_132:
            __break(1u);
            JUMPOUT(0x184E546D8);
          }
LABEL_53:
          if (v12 < v37)
          {
            uint64_t v39 = *(void *)v12;
            *(void *)uint64_t v12 = *(void *)v37;
            *(void *)double v37 = v39;
            double v40 = v12 + 8;
            do
            {
              if (v40 == a2) {
                goto LABEL_132;
              }
              uint64_t v12 = v40;
              uint64_t v41 = *(void *)v40;
              v40 += 8;
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v34, v41));
            while (v37 != v10)
            {
              uint64_t v42 = *((void *)v37 - 1);
              v37 -= 8;
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v34, v42);
              if ((result & 1) == 0) {
                goto LABEL_53;
              }
            }
            goto LABEL_132;
          }
          BOOL v43 = v12 - 8;
          BOOL v5 = v12 - 8 >= v10;
          BOOL v6 = v12 - 8 == v10;
          if (v12 - 8 != v10) {
            *(void *)uint64_t v10 = *(void *)v43;
          }
          a5 = 0;
          *(void *)BOOL v43 = v34;
        }
        uint64_t v18 = v12 + 8;
        uint64_t v19 = *(void *)v12;
        do
        {
          if (v18 == a2) {
            goto LABEL_132;
          }
          int v20 = v18;
          int v21 = v18 - 8;
          char v22 = ((uint64_t (*)(void, uint64_t))*a3)(*(void *)v18, v19);
          uint64_t v18 = v20 + 8;
        }
        while ((v22 & 1) != 0);
        uint64_t v87 = a4;
        int8x16_t v23 = v11;
        uint64_t v24 = a2;
        if (v21 != v10)
        {
          while (v24 != v10)
          {
            uint64_t v25 = *((void *)v24 - 1);
            v24 -= 8;
            if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v25, v19)) {
              goto LABEL_22;
            }
          }
          goto LABEL_132;
        }
        uint64_t v24 = a2;
        do
        {
          if (v20 >= v24) {
            break;
          }
          uint64_t v26 = *((void *)v24 - 1);
          v24 -= 8;
        }
        while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v26, v19) & 1) == 0);
LABEL_22:
        if (v20 < v24)
        {
          int v27 = v20;
          int v28 = v24;
          do
          {
            uint64_t v29 = *(void *)v27;
            *(void *)int v27 = *(void *)v28;
            *(void *)int v28 = v29;
            uint64_t v30 = v27 + 8;
            do
            {
              if (v30 == a2) {
                goto LABEL_132;
              }
              int v27 = v30;
              int v21 = v30 - 8;
              char v31 = ((uint64_t (*)(void, uint64_t))*a3)(*(void *)v30, v19);
              uint64_t v30 = v27 + 8;
            }
            while ((v31 & 1) != 0);
            do
            {
              if (v28 == v10) {
                goto LABEL_132;
              }
              uint64_t v32 = *((void *)v28 - 1);
              v28 -= 8;
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v32, v19));
          }
          while (v27 < v28);
        }
        if (v21 != v10) {
          *(void *)uint64_t v10 = *(void *)v21;
        }
        *(void *)int v21 = v19;
        BOOL v5 = v20 >= v24;
        uint64_t v11 = v23;
        a4 = v87;
        if (v5) {
          break;
        }
LABEL_36:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(v10, v21, a3, v87, a5 & 1);
        a5 = 0;
        uint64_t v12 = v21 + 8;
      }
      BOOL v33 = std::__insertion_sort_incomplete[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v10, v21, a3);
      uint64_t v12 = v21 + 8;
      uint64_t result = std::__insertion_sort_incomplete[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((void *)v21 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v33) {
        goto LABEL_36;
      }
    }
    a2 = v21;
    if (!v33) {
      continue;
    }
    return result;
  }
}

uint64_t std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(void *a1, void *a2, void *a3, uint64_t (**a4)(void))
{
  char v8 = ((uint64_t (*)(void, void))*a4)(*a2, *a1);
  uint64_t result = ((uint64_t (*)(void, void))*a4)(*a3, *a2);
  if (v8)
  {
    uint64_t v10 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v10;
    }
    else
    {
      *a1 = *a2;
      *a2 = v10;
      uint64_t result = (*a4)(*a3);
      if (result)
      {
        uint64_t v13 = *a2;
        *a2 = *a3;
        *a3 = v13;
      }
    }
  }
  else if (result)
  {
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    uint64_t result = ((uint64_t (*)(void, void))*a4)(*a2, *a1);
    if (result)
    {
      uint64_t v12 = *a1;
      *a1 = *a2;
      *a2 = v12;
    }
  }
  return result;
}

uint64_t std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(void *a1, void *a2, void *a3, void *a4, uint64_t (**a5)(void))
{
  std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a2, a3, a5);
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if (result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if (result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(void *a1, void *a2, void *a3, void *a4, void *a5, uint64_t (**a6)(void))
{
  std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a2, a3, a4, a6);
  uint64_t result = ((uint64_t (*)(void, void))*a6)(*a5, *a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = ((uint64_t (*)(void, void))*a6)(*a4, *a3);
    if (result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = ((uint64_t (*)(void, void))*a6)(*a3, *a2);
      if (result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = ((uint64_t (*)(void, void))*a6)(*a2, *a1);
        if (result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(void *a1, void *a2, uint64_t (**a3)(void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v9 = a1 + 2;
      std::__sort3[abi:fe180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a1 + 2, a3);
      uint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v10, *v9))
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = (char *)a1 + v14;
        *(void *)((char *)a1 + v14 + 24) = *(void *)((char *)a1 + v14 + 16);
        if (v14 == -16) {
          break;
        }
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, void))*a3)(v13, *((void *)v15 + 1)) & 1) == 0)
        {
          uint64_t v16 = (void *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      *uint64_t v16 = v13;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 8;
    if (++v10 == a2) {
      return 1;
    }
  }
}

BOOL ClipperLib::IntersectListSort(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24) < *(void *)(a1 + 24);
}

void *ClipperLib::Clipper::GetLastOutPt(void *result, uint64_t a2)
{
  unint64_t v2 = *(int *)(a2 + 172);
  uint64_t v3 = *(void *)((char *)result + *(void *)(*result - 24) + 80);
  if (v2 >= (*(void *)((char *)result + *(void *)(*result - 24) + 88) - v3) >> 3)
  {
    __break(1u);
  }
  else
  {
    uint64_t v4 = *(void *)(v3 + 8 * v2) + 24;
    if (*(_DWORD *)(a2 + 156) != 1) {
      uint64_t v4 = *(void *)v4 + 64;
    }
    return *(void **)v4;
  }
  return result;
}

void ClipperLib::Clipper::AddGhostJoin()
{
}

BOOL ClipperLib::SlopesEqual(void *a1, void *a2, int a3)
{
  if (a3)
  {
    ClipperLib::Int128Mul(v8, a1[13] - a1[1], a2[12] - *a2);
    ClipperLib::Int128Mul(v7, a1[12] - *a1, a2[13] - a2[1]);
    return v8[1] == v7[1] && v8[0] == v7[0];
  }
  else
  {
    return (a2[12] - *a2) * (a1[13] - a1[1]) == (a2[13] - a2[1]) * (a1[12] - *a1);
  }
}

void *ClipperLib::PolyTree::Clear(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[10];
  uint64_t v3 = this[11];
  if (v3 != v2)
  {
    unint64_t v4 = 0;
    do
    {
      this = *(void **)(v2 + 8 * v4);
      if (this)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v2 = v1[10];
        uint64_t v3 = v1[11];
      }
      ++v4;
    }
    while (v4 < (v3 - v2) >> 3);
    if (v3 != v2) {
      v1[11] = v2;
    }
  }
  uint64_t v5 = v1[4];
  if (v1[5] != v5) {
    v1[5] = v5;
  }
  return this;
}

void *std::vector<ClipperLib::IntPoint>::__init_with_size[abi:fe180100]<ClipperLib::IntPoint*,ClipperLib::IntPoint*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = result;
    if (a4 >= 0x555555555555556) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    BOOL result = std::__allocate_at_least[abi:fe180100]<std::allocator<ClipperLib::IntPoint>>(a4);
    unint64_t v7 = result;
    *unint64_t v4 = result;
    v4[1] = result;
    v4[2] = &result[6 * v8];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      BOOL result = memmove(result, a2, v9);
    }
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_184E54E74(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<ClipperLib::PolyNode *>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v4 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(a2);
    uint64_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v7 = &v4[8 * v6];
    size_t v9 = (char *)*a1;
    uint64_t v8 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v8 != v9);
      uint64_t v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_6())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  BOOL result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    BOOL result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyASCIIDescriptionString");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_6672;
  }
  color_space_state_create_flexGTC_proxy_f_30 = v1;
  return result;
}

uint64_t colorsync_smart_null_6672()
{
  return 0;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_5())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  BOOL result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    BOOL result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyDescriptionString");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_6672;
  }
  color_space_state_create_flexGTC_proxy_f_23 = v1;
  return result;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_4())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  BOOL result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    BOOL result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileGetMD5");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_6672;
  }
  color_space_state_create_flexGTC_proxy_f_17 = v1;
  return result;
}

CFTypeRef flexGTC_create_icc_profile_ascii_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  int v9 = *(_DWORD *)(v8 + 24);
  if (v9 != 6 && v9 != 11) {
    _CGHandleAssert("flexGTC_create_icc_profile_ascii_description", 148, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "space->state->type == kCGColorSpaceICCBased || space->state->type == kCGColorSpaceFlexGTCProxy", "Colorspace must be ICC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
  }
  CFTypeRef result = *(CFTypeRef *)(*(void *)(v8 + 96) + 40);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

BOOL flexGTC_md5_equal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 != 11 || (int v8 = *(_DWORD *)(a2 + 24), v8 != 11)) {
    _CGHandleAssert("flexGTC_get_icc_md5", 48, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not FlexGTC based. type = %d", a6, a7, a8, v8);
  }
  uint64_t v9 = *(void *)(a1 + 96);
  uint64_t v10 = *(void *)(a2 + 96);
  if (v9 == v10) {
    return 1;
  }
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v11 = *(void *)(v9 + 16);
  uint64_t v14 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 16);
  return v12 == v14 && v11 == v13;
}

CFTypeRef flexGTC_create_icc_profile_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v8 + 24) != 11) {
    _CGHandleAssert("flexGTC_create_icc_profile_description", 138, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "space->state->type == kCGColorSpaceFlexGTCProxy", "Colorspace must be FlexGTC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
  }
  CFTypeRef result = *(CFTypeRef *)(*(void *)(v8 + 96) + 24);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

uint64_t flexGTC_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

void flexGTC_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 != 11) {
    _CGHandleAssert("flexGTC_finalize", 68, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not FlexGTC based. type = %d", a6, a7, a8, v8);
  }
  uint64_t v9 = *(void *)(a1 + 96);
  if (v9)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(v9 + 32));
    if (*(void *)v9) {
      CFRelease(*(CFTypeRef *)v9);
    }
    uint64_t v10 = *(const void **)(v9 + 24);
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v11 = *(const void **)(v9 + 40);
    if (v11) {
      CFRelease(v11);
    }
    uint64_t v12 = *(const void **)(v9 + 48);
    if (v12) {
      CFRelease(v12);
    }
    _Block_release(*(const void **)(v9 + 56));
    if (!*(void *)(v9 + 80))
    {
      uint64_t v13 = *(void *)(v9 + 64);
      if (v13) {
        (*(void (**)(uint64_t, void, void))(v13 + 16))(v13, *(void *)(v9 + 72), 0);
      }
    }
    uint64_t v14 = *(const void **)(v9 + 64);
    if (v14) {
      _Block_release(v14);
    }
    uint64_t v15 = *(const void **)(v9 + 80);
    if (v15) {
      CFRelease(v15);
    }
    uint64_t v16 = *(void **)(v9 + 88);
    free(v16);
  }
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_3())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFTypeRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CFTypeRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileIsHLGBased");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_6672;
  }
  color_space_state_create_flexGTC_proxy_f_11 = v1;
  return result;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFTypeRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CFTypeRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileIsPQBased");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_6672;
  }
  color_space_state_create_flexGTC_proxy_f_5 = v1;
  return result;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFTypeRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CFTypeRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileIsWideGamut");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_6672;
  }
  color_space_state_create_flexGTC_proxy_f = v1;
  return result;
}

uint64_t CGColorSpaceFlexGTCProxyGetFlexGTCProfile(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v3 + 24) != 11) {
    goto LABEL_9;
  }
  uint64_t v4 = *(void *)(v3 + 96);
  uint64_t FlexGTCProfile_f = *(void *)(v4 + 80);
  if (FlexGTCProfile_f) {
    goto LABEL_10;
  }
  CFDictionaryRef v6 = (const __CFDictionary *)(*(uint64_t (**)(void))(*(void *)(v4 + 56) + 16))();
  if (!v6)
  {
LABEL_9:
    uint64_t FlexGTCProfile_f = 0;
    goto LABEL_10;
  }
  CFDictionaryRef v7 = v6;
  MutableCopdouble y = CFDictionaryCreateMutableCopy(0, 0, v6);
  if (MutableCopy)
  {
    uint64_t v9 = MutableCopy;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, @"com.apple.ColorSync.MonoGainMapParams");
    uint64_t v11 = CFDictionaryCreateMutableCopy(0, 0, Value);
    if (v11)
    {
      uint64_t v12 = v11;
      CFDictionarySetValue(v11, @"com.apple.ColorSync.GUID", *(const void **)(v4 + 48));
      CFDictionarySetValue(v9, @"com.apple.ColorSync.MonoGainMapParams", v12);
      if (CGColorSpaceFlexGTCProxyGetFlexGTCProfile_cglibrarypredicate != -1) {
        dispatch_once(&CGColorSpaceFlexGTCProxyGetFlexGTCProfile_cglibrarypredicate, &__block_literal_global_44);
      }
      uint64_t FlexGTCProfile_f = CGColorSpaceFlexGTCProxyGetFlexGTCProfile_f(*(void *)v4, v7);
      *(void *)(v4 + 80) = FlexGTCProfile_f;
      CFRelease(v12);
    }
    else
    {
      uint64_t FlexGTCProfile_f = 0;
    }
    CFRelease(v9);
  }
  else
  {
    uint64_t FlexGTCProfile_f = 0;
  }
  CFRelease(v7);
LABEL_10:
  pthread_mutex_unlock(v2);
  return FlexGTCProfile_f;
}

uint64_t CGColorSpaceCreateFlexGTCProxy(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (!*(unsigned char *)(v5 + 16) || !*(void *)(v5 + 80)) {
    return 0;
  }
  CFUUIDRef v9 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  CFUUIDRef v10 = v9;
  uint64_t v11 = *(void *)(a1 + 24);
  int v12 = *(_DWORD *)(v11 + 24);
  if (v12 == 11)
  {
    uint64_t v13 = *(uint64_t **)(v11 + 96);
  }
  else
  {
    if (v12 != 6)
    {
      uint64_t v16 = 0;
      goto LABEL_12;
    }
    uint64_t v13 = (uint64_t *)(*(void *)(v11 + 96) + 16);
  }
  uint64_t v16 = *v13;
LABEL_12:
  *(_OWORD *)keys = xmmword_1E52B4168;
  long long v65 = *(_OWORD *)&off_1E52B4178;
  long long v66 = xmmword_1E52B4188;
  long long v67 = *(_OWORD *)off_1E52B4198;
  values = v9;
  int valuePtr = 1069547520;
  CFTypeRef cf = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  int valuePtr = 1075838976;
  CFNumberRef v58 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  int valuePtr = 1080033280;
  CFNumberRef v59 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  int valuePtr = 1083179008;
  CFNumberRef v60 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  int valuePtr = 1085276160;
  CFNumberRef v61 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  int valuePtr = 1087373312;
  CFNumberRef v62 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  int valuePtr = 1089470464;
  CFNumberRef v63 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  uint64_t v17 = 8;
  CFDictionaryRef v18 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  do
  {
    CFRelease(*(void **)((char *)&values + v17));
    v17 += 8;
  }
  while (v17 != 64);
  if (create_node_table_predicate != -1) {
    dispatch_once(&create_node_table_predicate, &__block_literal_global_91);
  }
  CFTypeRef v19 = (CFTypeRef)create_node_table_node_table;
  if (create_node_table_node_table) {
    CFTypeRef v19 = CFRetain((CFTypeRef)create_node_table_node_table);
  }
  *(_OWORD *)keys = xmmword_1E52B4158;
  values = v18;
  CFTypeRef cf = v19;
  CFDictionaryRef v20 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(values);
  CFRelease(cf);
  if (create_flexGTX_profile_stub_cglibrarypredicate != -1) {
    dispatch_once(&create_flexGTX_profile_stub_cglibrarypredicate, &__block_literal_global_64_6713);
  }
  uint64_t flexGTX_profile_stub_f = create_flexGTX_profile_stub_f(v16, v20);
  if (v20) {
    CFRelease(v20);
  }
  uint64_t v22 = *(void *)(a1 + 24);
  int v23 = *(_DWORD *)(v22 + 24);
  switch(v23)
  {
    case 6:
      uint64_t v24 = (const void **)(*(void *)(v22 + 96) + 56);
      goto LABEL_28;
    case 10:
      uint64_t v24 = (const void **)(*(void *)(v22 + 96) + 48);
LABEL_28:
      uint64_t v25 = *v24;
      if (!flexGTX_profile_stub_f) {
        goto LABEL_69;
      }
      goto LABEL_31;
    case 8:
      uint64_t v24 = (const void **)(*(void *)(v22 + 96) + 8);
      goto LABEL_28;
  }
  uint64_t v25 = 0;
  if (!flexGTX_profile_stub_f)
  {
LABEL_69:
    uint64_t v27 = 0;
    goto LABEL_70;
  }
LABEL_31:
  uint64_t v26 = malloc_type_calloc(0x78uLL, 1uLL, 0x7405B4D7uLL);
  uint64_t v27 = (uint64_t)v26;
  if (v26)
  {
    *(_DWORD *)uint64_t v26 = 1;
    v26[12] = 1;
    *((_DWORD *)v26 + 2) = 0x10000;
    if (color_space_state_create_flexGTC_proxy_cglibrarypredicate != -1) {
      dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate, &__block_literal_global_6659);
    }
    *(unsigned char *)(v27 + 14) = color_space_state_create_flexGTC_proxy_f(flexGTX_profile_stub_f);
    *(unsigned char *)(v27 + 15) = 1;
    if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_6 != -1) {
      dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_6, &__block_literal_global_9_6660);
    }
    *(unsigned char *)(v27 + 16) = color_space_state_create_flexGTC_proxy_f_5(flexGTX_profile_stub_f);
    if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_12 != -1) {
      dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_12, &__block_literal_global_15_6661);
    }
    char flexGTC_proxy_f_11 = color_space_state_create_flexGTC_proxy_f_11(flexGTX_profile_stub_f);
    *(void *)(v27 + 24) = 0x10000000BLL;
    *(unsigned char *)(v27 + 17) = flexGTC_proxy_f_11;
    *(unsigned char *)(v27 + 13) = 0;
    *(void *)(v27 + 112) = flexGTC_vtable;
    *(_DWORD *)(v27 + 32) = 1;
    *(void *)(v27 + 80) = 0;
    *(void *)(v27 + 88) = 0;
    *(void *)(v27 + 40) = &icc_get_default_color_components_components03;
    *(void *)(v27 + 48) = 3;
    uint64_t v29 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F20409491EBA0uLL);
    *(void *)(v27 + 96) = v29;
    if (v29)
    {
      uint64_t v30 = v29;
      *uint64_t v29 = flexGTX_profile_stub_f;
      if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_18 != -1) {
        dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_18, &__block_literal_global_21_6662);
      }
      v30[1] = color_space_state_create_flexGTC_proxy_f_17(flexGTX_profile_stub_f);
      v30[2] = v31;
      if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_24 != -1) {
        dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_24, &__block_literal_global_27);
      }
      uint64_t flexGTC_proxy_f_23 = color_space_state_create_flexGTC_proxy_f_23(flexGTX_profile_stub_f);
      if (flexGTC_proxy_f_23) {
        BOOL v33 = (__CFString *)flexGTC_proxy_f_23;
      }
      else {
        BOOL v33 = @"<no description>";
      }
      v30[3] = v33;
      if (v25) {
        CFRetain(v25);
      }
      v30[4] = v25;
      if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_31 != -1) {
        dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_31, &__block_literal_global_34_6664);
      }
      uint64_t flexGTC_proxy_f_30 = color_space_state_create_flexGTC_proxy_f_30(flexGTX_profile_stub_f);
      if (flexGTC_proxy_f_30) {
        double v35 = (__CFString *)flexGTC_proxy_f_30;
      }
      else {
        double v35 = @"<no description>";
      }
      v30[5] = v35;
      if (v10) {
        CFTypeRef v36 = CFRetain(v10);
      }
      else {
        CFTypeRef v36 = 0;
      }
      v30[6] = v36;
      double v37 = malloc_type_malloc(0x30uLL, 0x100004000313F17uLL);
      v30[11] = v37;
      if (v37)
      {
        *double v37 = xmmword_1850CD8C0;
        v37[1] = xmmword_1850CD8C0;
        v37[2] = xmmword_1850CD8C0;
        keys[0] = 0;
        keys[1] = 0;
        if (*(_DWORD *)(v27 + 24) != 11) {
          _CGHandleAssert("flexGTC_get_md5", 26, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not FlexGTC based. type = %d", v38, v39, v40, *(_DWORD *)(v27 + 24));
        }
        uint64_t v41 = *(void *)(v27 + 96);
        uint64_t v42 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
        CC_MD5_Init(v42);
        if (v42)
        {
          CC_MD5_Update(v42, (const void *)(v27 + 24), 4u);
          CC_MD5_Update(v42, (const void *)(v41 + 8), 0x10u);
        }
        uint64_t v43 = 2 * *(void *)(v27 + 48);
        if (v43)
        {
          for (uint64_t i = 0; i != v43; ++i)
          {
            float v45 = *(double *)(*(void *)(v41 + 88) + 8 * i);
            *(float *)&values = v45;
            if (v42) {
              CC_MD5_Update(v42, &values, 4u);
            }
          }
        }
        if (v42)
        {
          CC_MD5_Final((unsigned __int8 *)keys, v42);
          long long v46 = *(_OWORD *)keys;
        }
        else
        {
          long long v46 = 0uLL;
        }
        long long v54 = v46;
        free(v42);
        *(_OWORD *)(v27 + 64) = v54;
        goto LABEL_70;
      }
      free(*(void **)(v27 + 96));
    }
    free((void *)v27);
    goto LABEL_69;
  }
LABEL_70:
  *(void *)(*(void *)(v27 + 96) + 56) = _Block_copy(a3);
  *(void *)(*(void *)(v27 + 96) + 64) = _Block_copy(a4);
  *(void *)(*(void *)(v27 + 96) + 72) = a2;
  uint64_t v14 = CGColorSpaceCreateWithState((atomic_uint *)v27, v47, v48, v49, v50, v51, v52, v53);
  if (atomic_fetch_add_explicit((atomic_uint *volatile)v27, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    color_space_state_dealloc(v27);
  }
  if (v10) {
    CFRelease(v10);
  }
  return v14;
}