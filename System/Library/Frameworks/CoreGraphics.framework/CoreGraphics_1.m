uint64_t resample_vertical<int,unsigned char,4,(AlphaStyle)2>(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint8x8_t **a5, uint64_t a6)
{
  uint8x8_t *v6;
  uint64_t v7;
  const __int16 *v8;
  signed int v9;
  int v10;
  unint64_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  const __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  int32x4_t *v19;
  int32x4_t *v20;
  unsigned int v21;
  int16x4_t v22;
  int16x4_t v23;
  int32x4_t *v24;
  int16x4_t v25;
  int8x8_t v26;
  int8x8_t v27;
  int8x16_t v28;
  int32x4_t v29;
  int32x4_t v30;
  const __int16 *v31;
  uint64_t v32;
  uint64_t *v33;
  unsigned int v34;
  uint64_t v35;
  int16x4_t v36;
  int16x8_t v37;
  __int16 v38;
  __int16 v39;
  __int16 v40;
  __int16 v41;

  v6 = *a5;
  v7 = *(int *)(result + 4);
  v8 = (const __int16 *)(result + 8);
  if (a4 >= 2)
  {
    v10 = 0;
    v11 = 2;
    v12.i64[0] = 0x200000002000;
    v12.i64[1] = 0x200000002000;
    do
    {
      v13 = 0uLL;
      v14 = 0uLL;
      v15 = v8;
      if ((int)v7 >= 2)
      {
        v16 = 0;
        v17 = (4 * v10) & 0xFFFFFFF8;
        v15 = v8;
        do
        {
          v18 = (void *)(a6 + 8 * v16);
          v19 = (int32x4_t *)(*v18 + 4 * v17);
          v20 = (int32x4_t *)(v18[1] + 4 * v17);
          v21 = *(_DWORD *)v15;
          v15 += 2;
          v22 = vdup_n_s16(v21);
          v23 = vdup_n_s16(HIWORD(v21));
          v14 = vmlal_s16(vmlal_s16(v14, vmovn_s32(v19[1]), v22), vmovn_s32(v20[1]), v23);
          v13 = vmlal_s16(vmlal_s16(v13, vmovn_s32(*v19), v22), vmovn_s32(*v20), v23);
          result = v16 + 4;
          v16 += 2;
        }
        while (result <= v7);
      }
      if (v7)
      {
        v24 = (int32x4_t *)(*(void *)(a6 + 8 * ((int)v7 - 1)) + 4 * ((4 * v10) & 0xFFFFFFF8));
        v25 = vld1_dup_s16(v15);
        v14 = vmlal_s16(v14, vmovn_s32(v24[1]), v25);
        v13 = vmlal_s16(v13, vmovn_s32(*v24), v25);
      }
      v10 += 2;
      v26 = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vshrq_n_s32(vaddq_s32(v13, v12), 0xEuLL)), vshrq_n_s32(vaddq_s32(v14, v12), 0xEuLL)));
      v27 = (int8x8_t)vmax_u8((uint8x8_t)vuzp1_s8(v26, *(int8x8_t *)v12.i8), (uint8x8_t)vuzp2_s8(v26, *(int8x8_t *)v12.i8));
      *(uint8x8_t *)v28.i8 = vmax_u8((uint8x8_t)vuzp1_s8(v27, *(int8x8_t *)v12.i8), (uint8x8_t)vuzp2_s8(v27, *(int8x8_t *)v12.i8));
      v28.i64[1] = v28.i64[0];
      *v6++ = vmax_u8((uint8x8_t)v26, (uint8x8_t)vqtbl1_s8(v28, (int8x8_t)0x1FFFFFF00FFFFFFLL));
      v11 += 2;
    }
    while (v11 <= a4);
    v9 = a4 & 0xFFFFFFFE;
  }
  else
  {
    v9 = 0;
  }
  if (v9 < a4)
  {
    v29.i64[0] = 0x200000002000;
    v29.i64[1] = 0x200000002000;
    do
    {
      v30 = 0uLL;
      v31 = v8;
      if ((int)v7 >= 2)
      {
        v32 = 0;
        v31 = v8;
        do
        {
          v33 = (uint64_t *)(a6 + 8 * v32);
          result = *v33;
          v34 = *(_DWORD *)v31;
          v31 += 2;
          v30 = vmlal_s16(vmlal_s16(v30, vmovn_s32(*(int32x4_t *)(*v33 + 4 * (4 * v9))), vdup_n_s16(v34)), vmovn_s32(*(int32x4_t *)(v33[1] + 4 * (4 * v9))), vdup_n_s16(HIWORD(v34)));
          v35 = v32 + 4;
          v32 += 2;
        }
        while (v35 <= v7);
      }
      if (v7)
      {
        v36 = vld1_dup_s16(v31);
        v30 = vmlal_s16(v30, vmovn_s32(*(int32x4_t *)(*(void *)(a6 + 8 * ((int)v7 - 1)) + 4 * (4 * v9))), v36);
      }
      v37 = (int16x8_t)vshrq_n_s32(vaddq_s32(v30, v29), 0xEuLL);
      *(int16x4_t *)v37.i8 = vqmovn_s32((int32x4_t)v37);
      *(int8x8_t *)v37.i8 = vqmovun_s16(v37);
      v38 = v37.u8[2];
      v39 = v37.u8[1];
      v40 = v37.u8[0];
      v37.i8[0] = vmaxv_u8(*(uint8x8_t *)v37.i8);
      v41 = v37.i16[0];
      v37.i16[0] = v40;
      v37.i16[1] = v39;
      v37.i16[2] = v38;
      v37.i16[3] = v41;
      v6->i32[0] = vmovn_s16(v37).u32[0];
      v6 = (uint8x8_t *)((char *)v6 + 4);
      ++v9;
    }
    while (v9 < a4);
  }
  return result;
}

uint64_t resample_range(uint64_t a1, int a2, unsigned int a3, int a4, int *a5)
{
  if (a1)
  {
    uint64_t v5 = 92;
    if (a2 == 1) {
      uint64_t v5 = 88;
    }
    uint64_t v6 = 76;
    if (a2 == 1) {
      uint64_t v6 = 72;
    }
    uint64_t v7 = *(void *)(a1 + 8 * (a2 == 1));
    unsigned int v8 = *(_DWORD *)(a1 + v6);
    int v9 = *(_DWORD *)(a1 + v5);
    unsigned int v10 = a4 + a3;
    if (a4 + a3 >= v8) {
      unsigned int v10 = v8;
    }
    if (v10 >= a3) {
      uint64_t v11 = a3;
    }
    else {
      uint64_t v11 = v10;
    }
    uint64_t v12 = *(int *)(a1 + 80) * (uint64_t)v9 + 8;
    int v13 = *(_DWORD *)(v12 * v11 + v7);
    int v14 = *(_DWORD *)(v7 + v12 * ((__PAIR64__(v10, a3) - v10) >> 32) + 4)
        + *(_DWORD *)(v7 + v12 * ((__PAIR64__(v10, a3) - v10) >> 32));
    if (a2 == 3 && *(void *)(a1 + 56))
    {
      unsigned int v15 = *(_DWORD *)(a1 + 48);
      unsigned int v16 = *(_DWORD *)(a1 + 44) + v15;
      BOOL v17 = v13 >= 0 && v13 >= v15;
      BOOL v18 = v17;
      int v19 = (int)v16 <= v14 ? v14 : v16;
      if (v18 && v13 < v16)
      {
        int v13 = v16;
        int v14 = v19;
      }
    }
    if (a5) {
      *a5 = v13;
    }
    return (v14 - v13);
  }
  else
  {
    if (a5) {
      *a5 = 0;
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t img_decode_read(uint64_t a1, unsigned int a2, uint64_t a3, uint16x4_t **a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  uint64_t result = 0;
  uint64_t v152 = *MEMORY[0x1E4F143B8];
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v11 = a3;
    uint64_t v12 = (a3 - 1);
    if ((int)a3 >= 1)
    {
      uint64_t v16 = *(void *)(a1 + 96);
      BOOL v18 = *(uint64_t **)(a1 + 144);
      BOOL v17 = *(int **)(a1 + 152);
      v144 = *(int **)(a1 + 160);
      if (v16 == -1)
      {
        int v28 = *(_DWORD *)(a1 + 128);
        int v29 = *(_DWORD *)(a1 + 40);
        if (v29 >= 0) {
          int v30 = *(_DWORD *)(a1 + 40);
        }
        else {
          int v30 = v29 + 7;
        }
        v31 = *(void **)(a1 + 184);
        if (!v31)
        {
          v32 = img_blocks_create((uint64_t)v18, 0, v17, 0);
          if (!v32) {
            return 0xFFFFFFFFLL;
          }
          v31 = v32;
          *(void *)(a1 + 184) = v32;
          *(void *)(a1 + 88) = 0;
        }
        int v33 = v11 + a2;
        int v34 = *((_DWORD *)v31 + 15);
        int v35 = *((_DWORD *)v31 + 17) + v34;
        if (v34 >= (int)(v11 + a2) || v35 <= (int)a2) {
          return 0;
        }
        BOOL v37 = __OFSUB__(v35, v33);
        int v38 = v35 - v33;
        if (v38 < 0 != v37)
        {
          uint64_t v11 = (v38 + v11);
          if ((int)v11 < 1) {
            return 0;
          }
        }
        *(void *)(a1 + 88) = a2;
        int v148 = 0;
        unsigned int v149 = a2;
        int v150 = *(void *)(a1 + 120);
        int v151 = v11;
        uint64_t v39 = v31[5];
        if ((int)v39 >= 1)
        {
          int v40 = v28;
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          int v43 = *((_DWORD *)v31 + 8);
          int v141 = v30 >> 3;
          int v142 = v43;
          unsigned int v143 = (v30 >> 3) * v40;
          int v140 = (v30 >> 3) + v143;
          uint64_t v44 = 16 * v39;
          do
          {
            uint64_t v146 = 0;
            uint64_t v147 = 0;
            long long v145 = 0uLL;
            long long v145 = *(_OWORD *)(v31[9] + v42);
            if (CGSBoundsIntersection(&v148, (int *)&v145, &v146))
            {
              uint64_t v47 = SHIDWORD(v146) - (uint64_t)(int)v149;
              v48 = a4[1];
              v49 = (char *)*a4 + (int)v47 * *a5;
              if (v48)
              {
                int v50 = v146;
                int v51 = v146 - v148;
                if (v48 == *a4)
                {
                  v52 = (uint16x4_t *)&v49[v140 * v51];
                  v53 = v52;
                }
                else
                {
                  v52 = (uint16x4_t *)&v49[v143 * v51];
                  v53 = (uint16x4_t *)((char *)v48 + a5[1] * v47 + v51 * v141);
                }
              }
              else
              {
                v53 = 0;
                int v50 = v146;
                v52 = (uint16x4_t *)&v49[(int)(v143 * (v146 - v148))];
              }
              uint64_t v54 = *(void *)(v31[10] + v41);
              if (v54)
              {
                decode_data(v144, v147, SHIDWORD(v147), (char *)(v54+ *(void *)(v31[11] + v41) * (SHIDWORD(v146) - (uint64_t)SDWORD1(v145))+ (v50 - (int)v145) * v142), *(void *)(v31[11] + v41), v52, *a5, v53, v45, v46, a5[1]);
              }
              else
              {
                CGBlt_fillBytes(*a5, HIDWORD(v147), 0, (char *)v52, *a5);
                if (v53 && v53 != v52) {
                  CGBlt_fillBytes(a5[1], HIDWORD(v147), 0, (char *)v53, a5[1]);
                }
              }
            }
            v42 += 16;
            v41 += 8;
          }
          while (v44 != v42);
        }
      }
      else
      {
        if (!v16)
        {
          if (v16) {
            _CGHandleAssert("img_decode_read_with_data_provider", 1202, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "stage->param[IMG_DECODE_NDATA] == 0", "param = %ld", a6, a7, a8, 0);
          }
          uint64_t image_pointer = get_image_pointer((void *)a1);
          if (image_pointer)
          {
            uint64_t v22 = image_pointer;
            uint64_t v23 = *(void *)(a1 + 120);
            uint64_t v24 = *(void *)(a1 + 136);
            v25 = *(int **)(a1 + 160);
            *(void *)(a1 + 88) = a2;
            unint64_t v26 = (int)v24 * (unint64_t)a2;
            if (v26 == (int)v26)
            {
              decode_data(v25, v23, v11, (char *)(v22 + v26), v24, *a4, *a5, a4[1], v20, v21, a5[1]);
LABEL_9:
              uint64_t v27 = *(void *)(a1 + 88) + (int)v11;
LABEL_132:
              *(void *)(a1 + 88) = v27;
              return v11;
            }
          }
          else
          {
            signed int v79 = *(_DWORD *)(a1 + 136);
            int v80 = *(_DWORD *)(a1 + 104);
            int v81 = *(_DWORD *)(a1 + 88);
            v82 = *(int **)(a1 + 160);
            access_session = get_access_session(a1);
            signed int v85 = (v80 + 15) & 0xFFFFFFF0;
            if (v79 - v85 < 64 || v79 <= v85) {
              signed int v85 = v79;
            }
            if (v80 < 1) {
              signed int v85 = v79;
            }
            uint64_t v87 = *a5;
            uint64_t v88 = v87 * v11;
            if (v88 != (int)v88) {
              return 0;
            }
            uint64_t v89 = v87 * v12;
            if (v89 != (int)v89) {
              return 0;
            }
            v113 = (char *)*a4 + v88;
            int v114 = (int)v89 / v85;
            if (v114 < (int)v11)
            {
              int v115 = *(_DWORD *)(a1 + 64);
              LODWORD(v12) = v114;
              if (v114 < v115)
              {
                if (v115 >= (int)v11) {
                  LODWORD(v12) = v11;
                }
                else {
                  LODWORD(v12) = *(_DWORD *)(a1 + 64);
                }
                signed int v85 = *(_DWORD *)(a1 + 56);
                uint64_t v116 = v85 * (uint64_t)(int)v12;
                if (v116 != (int)v116) {
                  return 0;
                }
                v113 = (char *)(*(void *)(a1 + 72) + v116);
              }
            }
            v144 = v82;
            uint64_t v117 = (int)v12 * (uint64_t)v85;
            if (v117 == (int)v117)
            {
              int v118 = v81;
              unint64_t v119 = v85;
              v120 = &v113[-v117];
              int v121 = v118;
              if (v118 > (int)a2)
              {
                int v121 = 0;
                *(void *)(a1 + 88) = 0;
              }
              if (v121 < (int)a2) {
                *(void *)(a1 + 88) = a2;
              }
              int ChunksAtPosition = CGAccessSessionGetChunksAtPosition(access_session, (int)(v79 * a2), v119, v79 - (int)v119, (int)v12, &v113[-v117], 0, v84);
              unsigned int v125 = ChunksAtPosition / v79;
              if (ChunksAtPosition % v79 < v80) {
                unsigned int v126 = ChunksAtPosition / v79;
              }
              else {
                unsigned int v126 = v125 + 1;
              }
              if (v80 >= 1) {
                uint64_t v11 = v126;
              }
              else {
                uint64_t v11 = v125;
              }
              if (v144)
              {
                decode_data(v144, *(unsigned int *)(a1 + 120), v11, v120, v119, *a4, *a5, a4[1], v123, v124, a5[1]);
              }
              else
              {
                unint64_t v131 = *a5;
                if (v131 >= v119) {
                  size_t v132 = v119;
                }
                else {
                  size_t v132 = *a5;
                }
                if (v11)
                {
                  uint64_t v133 = (int)v11;
                  v134 = *a4;
                  do
                  {
                    memmove(v134, v120, v132);
                    v134 = (uint16x4_t *)((char *)v134 + v131);
                    v120 += v119;
                    --v133;
                  }
                  while (v133);
                }
              }
              goto LABEL_9;
            }
          }
          return 0;
        }
        int v55 = *(_DWORD *)(a1 + 120);
        v56 = *(_DWORD **)(a1 + 136);
        if (v17)
        {
          unsigned int v57 = *(_DWORD *)(a1 + 128);
          int v58 = *(_DWORD *)(a1 + 40);
          int v59 = v58 + 7;
          int v140 = v58;
          if (v58 >= 0) {
            int v59 = v58;
          }
          int v142 = v59;
          unsigned int v143 = v57;
          int v60 = a3 + a2;
          int v61 = v17[1];
          int v62 = v17[3] + v61;
          *(void *)(a1 + 88) = a2;
          if (v62 <= (int)a2 || v60 <= v61)
          {
            int v61 = 0;
            int v60 = 0;
            unsigned int v64 = 0;
            int v141 = 0;
          }
          else
          {
            if (v62 < v60) {
              int v60 = v62;
            }
            unsigned int v90 = a2 - v61;
            int v92 = v61 - a2;
            BOOL v91 = v61 <= (int)a2;
            if (v61 > (int)a2)
            {
              unsigned int v64 = 0;
            }
            else
            {
              int v61 = a2;
              unsigned int v64 = v90;
            }
            if (v91) {
              int v93 = 0;
            }
            else {
              int v93 = v92;
            }
            int v141 = v93;
          }
          int v94 = v60 - v61;
          if (v60 - v61 != a3 || v17[2] != v55)
          {
            CGBlt_fillBytes(*a5, a3, 0, (char *)*a4, *a5);
            v95 = (char *)a4[1];
            if (v95) {
              CGBlt_fillBytes(a5[1], v11, 0, v95, a5[1]);
            }
          }
          if (v94 >= 1)
          {
            unsigned int v139 = v94;
            uint64_t v138 = v16 << 32;
            MEMORY[0x1F4188790](result, a9);
            v97 = (int *)((char *)&v137 - v96);
            bzero((char *)&v137 - v96, v98);
            v101 = (void **)((char *)v97 + (v138 >> 30));
            if ((int)v16 >= 1)
            {
              uint64_t v102 = v16;
              v103 = (void *)((char *)v97 + (v138 >> 30));
              v104 = v97;
              do
              {
                uint64_t v106 = *v18++;
                uint64_t v105 = v106;
                LODWORD(v106) = *v56++;
                *v103++ = v105 + (int)(v106 * v64);
                *v104++ = v106;
                --v102;
              }
              while (v102);
            }
            int v107 = v142 >> 3;
            v108 = a4[1];
            uint64_t v109 = (uint64_t)*a4 + *a5 * (uint64_t)v141;
            int v110 = v139;
            if (v108)
            {
              if (v108 == *a4)
              {
                v111 = (uint16x4_t *)(v109 + (int)((v107 + v107 * v143) * *v17));
                v112 = v111;
              }
              else
              {
                v111 = (uint16x4_t *)(v109 + (int)(v107 * v143 * *v17));
                v112 = (uint16x4_t *)((char *)v108 + a5[1] * (uint64_t)v141 + *v17 * v107);
              }
            }
            else
            {
              v112 = 0;
              v111 = (uint16x4_t *)(v109 + (int)(v107 * v143 * *v17));
            }
            if (v16 == 2 && v112 && (*(_DWORD *)(a1 + 44) & 0xFFFFFFFE) == 8)
            {
              if (v140 >= 16 && (int v127 = *(_DWORD *)(a1 + 112)) != 0)
              {
                v128 = v101;
                CGBlt_swapBytes(v17[2] * v107, v139, v101[1], v112, v97[1], a5[1], v127);
              }
              else
              {
                int v129 = v97[1];
                int v130 = a5[1];
                v128 = v101;
                if (v129 == v130) {
                  memcpy(v112, v101[1], (int)(v129 * v139));
                }
                else {
                  CGBlt_copyBytes(v17[2] * v107, v139, (char *)v101[1], (char *)v112, v129, v130);
                }
              }
              v101 = v128;
            }
            decode_data(v144, v17[2], v110, (char *)*v101, *v97, v111, *a5, v112, v99, v100, a5[1]);
          }
        }
        else
        {
          unsigned int v143 = *(_DWORD *)(a1 + 120);
          MEMORY[0x1F4188790](0, a9);
          v66 = (int *)((char *)&v137 - v65);
          bzero((char *)&v137 - v65, v67);
          v70 = &v66[(int)v16];
          *(void *)(a1 + 88) = a2;
          if ((int)v16 >= 1)
          {
            uint64_t v71 = v16;
            v72 = &v66[(int)v16];
            v73 = v66;
            do
            {
              uint64_t v75 = *v18++;
              uint64_t v74 = v75;
              LODWORD(v75) = *v56++;
              *(void *)v72 = v74 + (int)(v75 * a2);
              v72 += 2;
              *v73++ = v75;
              --v71;
            }
            while (v71);
            if (v16 == 2)
            {
              v76 = a4[1];
              if (v76)
              {
                if ((*(_DWORD *)(a1 + 44) & 0xFFFFFFFE) == 8)
                {
                  int v77 = *(_DWORD *)(a1 + 40);
                  if (v77 >= 9 && (uint64_t v78 = *(void *)(a1 + 112)) != 0)
                  {
                    CGBlt_swapBytes((v77 >> 3) * v143, v11, *((void **)v70 + 1), v76, v66[1], a5[1], v78);
                  }
                  else
                  {
                    int v135 = v66[1];
                    int v136 = a5[1];
                    if (v135 == v136) {
                      memcpy(a4[1], *((const void **)v70 + 1), v135 * (int)v11);
                    }
                    else {
                      CGBlt_copyBytes(v77 / 8 * v143, v11, *(char **)&v66[(int)v16 + 2], (char *)v76, v135, v136);
                    }
                  }
                }
              }
            }
          }
          decode_data(v144, v143, v11, *(char **)v70, *v66, *a4, *a5, a4[1], v68, v69, a5[1]);
        }
      }
      uint64_t v27 = *(void *)(a1 + 88) + v11;
      goto LABEL_132;
    }
  }
  return result;
}

uint64_t get_image_pointer(void *a1)
{
  if (a1[12] || a1[23]) {
    return 0;
  }
  uint64_t v2 = a1[24];
  if (!v2)
  {
    uint64_t v4 = a1[18];
    uint64_t v5 = CGDataProviderRetainBytePtr(v4);
    uint64_t v2 = v5;
    if (v5) {
      a1[24] = v5;
    }
    else {
      CGDataProviderReleaseBytePtr(v4);
    }
    a1[11] = 0;
  }
  return v2;
}

void decode_data(int *a1, uint64_t a2, int a3, char *__src, int a5, uint16x4_t *__dst, int a7, uint16x4_t *a8, double a9, uint8x8_t a10, int a11)
{
  v758 = a8;
  if (!__src) {
    return;
  }
  uint64_t v12 = a1;
  if (!a1) {
    return;
  }
  uint64_t v14 = a2;
  if ((int)a2 < 1) {
    return;
  }
  int v15 = a3;
  if (a3 < 1 || !__dst) {
    return;
  }
  BOOL v17 = (int8x8_t *)__src;
  int v18 = a1[1];
  if (v18 > 127)
  {
    if (v18 != 128)
    {
      if (v18 != 129)
      {
        if (v18 != 130) {
          return;
        }
        int v20 = a8 == __dst ? -1 : a1[2];
        int v744 = v20;
        int v66 = a1[4];
        int v67 = a1[5];
        if (((v67 | v66) & 0x1F) != 0) {
          return;
        }
        int v68 = a1[3];
        int v69 = v67 - v66 * v68;
        if (v67 < v66 * v68) {
          return;
        }
        int v729 = a5;
        uint64_t v70 = a1[7];
        if (!a1[6]) {
          int v69 = 0;
        }
        int v71 = v69 + v66 * (v68 - 1);
        int v72 = v69 + v66;
        if (v744) {
          int v72 = v69;
        }
        else {
          int v71 = v69;
        }
        if (v744 >= 0) {
          int v73 = v68 - 1;
        }
        else {
          int v73 = a1[3];
        }
        BOOL v74 = v744 >= 0 && v744 == 0;
        if (v744 >= 0) {
          int v75 = v72;
        }
        else {
          int v75 = v69;
        }
        if (v744 >= 0) {
          int v76 = v71;
        }
        else {
          int v76 = v69;
        }
        BOOL v722 = v74;
        if (v70 == 2)
        {
          int v78 = v67 * a2 + 7;
          int v713 = v78 >> 3;
          signed int v79 = (int8x8_t *)malloc_type_malloc((uint64_t)v78 >> 3, 0x705560E0uLL);
          BOOL v74 = v722;
          uint64_t v12 = a1;
          LODWORD(v14) = a2;
          int v80 = v79;
        }
        else
        {
          int v713 = 0;
          int v80 = 0;
        }
        int v207 = v67 >> 5;
        uint64_t v208 = (uint64_t)v75 >> 5;
        int v209 = v73 * v14;
        uint64_t v741 = (uint64_t)v76 >> 5;
        uint64_t v210 = v729;
        uint64_t v211 = a7;
        uint64_t v212 = 4 * (v67 >> 5);
        v213 = v758;
        v750 = v80;
        uint64_t v720 = v208;
        while (1)
        {
          if (v70 == 4)
          {
            int v214 = 0;
            v215 = (char *)v17 + 4 * v208;
            uint64_t v216 = *((void *)v12 + 4);
            v217 = __dst;
            int v218 = v209;
            v219 = (float **)(v216 + 8 * v74);
            do
            {
              v220 = *v219;
              int v221 = v214 + 1;
              float v222 = *v220 + (float)(*(float *)&v215[4 * v214] * v220[1]);
              if (v214 + 1 < v73) {
                int v223 = v214 + 1;
              }
              else {
                int v223 = 0;
              }
              float v224 = 0.0;
              if (v222 >= 0.0)
              {
                float v224 = 65535.0;
                if (v222 <= 0.99998) {
                  float v224 = v222 * 65535.0;
                }
              }
              v217->i16[v214] = (int)v224;
              BOOL v225 = v221 < v73;
              if (v221 >= v73) {
                int v226 = v207;
              }
              else {
                int v226 = 0;
              }
              v215 += 4 * v226;
              v219 = (float **)(v216 + 8 * v74 + 8 * v223);
              if (v225) {
                int v227 = 0;
              }
              else {
                int v227 = v73;
              }
              v217 = (uint16x4_t *)((char *)v217 + 2 * v227);
              int v214 = v223;
              --v218;
            }
            while (v218);
            if (v744 < 0 || !v213) {
              goto LABEL_331;
            }
            v228 = (float *)v17 + v741;
            v229 = *(float **)(v216 + 8 * v744);
            float v230 = *v229;
            float v231 = v229[1];
            v232 = v213;
            int v233 = v14;
            do
            {
              float v234 = v230 + (float)(*v228 * v231);
              float v235 = 0.0;
              if (v234 >= 0.0)
              {
                float v235 = 65535.0;
                if (v234 <= 0.99998) {
                  float v235 = v234 * 65535.0;
                }
              }
              v232->i16[0] = (int)v235;
              v232 = (uint16x4_t *)((char *)v232 + 2);
              v228 = (float *)((char *)v228 + v212);
              --v233;
            }
            while (v233);
          }
          else
          {
            v236 = v17;
            if (v80)
            {
              uint64_t v237 = v70;
              uint64_t v238 = v70;
              uint64_t v239 = v210;
              v236 = decode_swap(v237, v750, v17, v713);
              uint64_t v210 = v239;
              uint64_t v70 = v238;
              uint64_t v208 = v720;
              BOOL v74 = v722;
              int v80 = v750;
              uint64_t v12 = a1;
              LODWORD(v14) = a2;
            }
            int v240 = 0;
            v241 = (char *)v236 + 4 * v208;
            uint64_t v242 = *((void *)v12 + 4);
            v243 = __dst;
            v244 = (float **)(v242 + 8 * v74);
            int v245 = v209;
            do
            {
              v246 = *v244;
              int v247 = v240 + 1;
              float v248 = *v246 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)&v241[4 * v240])) * v246[1]);
              if (v240 + 1 < v73) {
                int v249 = v240 + 1;
              }
              else {
                int v249 = 0;
              }
              float v250 = 0.0;
              if (v248 >= 0.0)
              {
                float v250 = 65535.0;
                if (v248 <= 0.99998) {
                  float v250 = v248 * 65535.0;
                }
              }
              v243->i16[v240] = (int)v250;
              BOOL v251 = v247 < v73;
              if (v247 >= v73) {
                int v252 = v207;
              }
              else {
                int v252 = 0;
              }
              v241 += 4 * v252;
              v244 = (float **)(v242 + 8 * v74 + 8 * v249);
              if (v251) {
                int v253 = 0;
              }
              else {
                int v253 = v73;
              }
              v243 = (uint16x4_t *)((char *)v243 + 2 * v253);
              int v240 = v249;
              --v245;
            }
            while (v245);
            if (v744 < 0 || !v213) {
              goto LABEL_331;
            }
            v254 = (unsigned int *)v236 + v741;
            v255 = *(float **)(v242 + 8 * v744);
            float v256 = *v255;
            float v257 = v255[1];
            v258 = v213;
            int v259 = v14;
            do
            {
              float v260 = v256 + (float)(COERCE_FLOAT(bswap32(*v254)) * v257);
              float v261 = 0.0;
              if (v260 >= 0.0)
              {
                float v261 = 65535.0;
                if (v260 <= 0.99998) {
                  float v261 = v260 * 65535.0;
                }
              }
              v258->i16[0] = (int)v261;
              v258 = (uint16x4_t *)((char *)v258 + 2);
              v254 = (unsigned int *)((char *)v254 + v212);
              --v259;
            }
            while (v259);
          }
          v213 = (uint16x4_t *)((char *)v213 + a11);
LABEL_331:
          BOOL v17 = (int8x8_t *)((char *)v17 + v210);
          __dst = (uint16x4_t *)((char *)__dst + v211);
          if (!--v15)
          {
            if (!v80) {
              return;
            }
            goto LABEL_429;
          }
        }
      }
      if (a8 == __dst) {
        int v26 = -1;
      }
      else {
        int v26 = a1[2];
      }
      int v746 = v26;
      int v121 = a1[4];
      int v122 = a1[5];
      if (((v122 | v121) & 0x1F) != 0) {
        return;
      }
      int v123 = a1[3];
      int v124 = v122 - v121 * v123;
      if (v122 < v121 * v123) {
        return;
      }
      int v731 = a5;
      uint64_t v125 = a1[7];
      if (!a1[6]) {
        int v124 = 0;
      }
      int v126 = v124 + v121 * (v123 - 1);
      int v127 = v124 + v121;
      if (v746) {
        int v127 = v124;
      }
      else {
        int v126 = v124;
      }
      if (v746 >= 0) {
        int v128 = v123 - 1;
      }
      else {
        int v128 = a1[3];
      }
      BOOL v129 = v746 >= 0 && v746 == 0;
      if (v746 >= 0) {
        int v130 = v127;
      }
      else {
        int v130 = v124;
      }
      if (v746 >= 0) {
        int v131 = v126;
      }
      else {
        int v131 = v124;
      }
      BOOL v726 = v129;
      if (v125 == 2)
      {
        int v133 = v122 * a2 + 7;
        int v716 = v133 >> 3;
        v134 = (int8x8_t *)malloc_type_malloc((uint64_t)v133 >> 3, 0x705560E0uLL);
        BOOL v129 = v726;
        uint64_t v12 = a1;
        LODWORD(v14) = a2;
        int v135 = v134;
      }
      else
      {
        int v716 = 0;
        int v135 = 0;
      }
      int v303 = v122 >> 5;
      uint64_t v304 = (uint64_t)v130 >> 5;
      uint64_t v305 = (v128 * v14);
      uint64_t v743 = (uint64_t)v131 >> 5;
      uint64_t v306 = a7;
      uint64_t v307 = 4 * (v122 >> 5);
      v308 = v758;
      v750 = v135;
      while (1)
      {
        if (v125 == 4)
        {
          int v309 = 0;
          v310 = (char *)v17 + 4 * v304;
          uint64_t v311 = *((void *)v12 + 4) + 8 * v129;
          v312 = __dst;
          int v313 = v305;
          v314 = (float **)v311;
          do
          {
            v315 = *v314;
            int v316 = v309 + 1;
            float v317 = *v315 + (float)(*(float *)&v310[4 * v309] * v315[1]);
            if (v309 + 1 < v128) {
              int v318 = v309 + 1;
            }
            else {
              int v318 = 0;
            }
            float v319 = 0.0;
            if (v317 >= 0.0)
            {
              if (v317 <= 0.99608) {
                float v319 = v317 * 255.0;
              }
              else {
                float v319 = 255.0;
              }
            }
            v312->i8[v309] = (int)v319;
            BOOL v320 = v316 < v128;
            if (v316 >= v128) {
              int v321 = v303;
            }
            else {
              int v321 = 0;
            }
            v310 += 4 * v321;
            v314 = (float **)(v311 + 8 * v318);
            if (v320) {
              int v322 = 0;
            }
            else {
              int v322 = v128;
            }
            v312 = (uint16x4_t *)((char *)v312 + v322);
            int v309 = v318;
            --v313;
          }
          while (v313);
          if (v746 < 0 || !v308) {
            goto LABEL_427;
          }
          v323 = (float *)v17 + v743;
          v324 = *(float **)(*((void *)v12 + 4) + 8 * v746);
          float v325 = *v324;
          float v326 = v324[1];
          v327 = v308;
          int v328 = v14;
          do
          {
            float v329 = v325 + (float)(*v323 * v326);
            float v330 = 0.0;
            if (v329 >= 0.0)
            {
              if (v329 <= 0.99608) {
                float v330 = v329 * 255.0;
              }
              else {
                float v330 = 255.0;
              }
            }
            v327->i8[0] = (int)v330;
            v327 = (uint16x4_t *)((char *)v327 + 1);
            v323 = (float *)((char *)v323 + v307);
            --v328;
          }
          while (v328);
        }
        else
        {
          v331 = v17;
          if (v135)
          {
            uint64_t v332 = v125;
            uint64_t v333 = v125;
            uint64_t v334 = v305;
            v331 = decode_swap(v332, v750, v17, v716);
            uint64_t v305 = v334;
            uint64_t v125 = v333;
            uint64_t v304 = (uint64_t)v130 >> 5;
            BOOL v129 = v726;
            int v135 = v750;
            uint64_t v12 = a1;
            LODWORD(v14) = a2;
          }
          int v335 = 0;
          v336 = (char *)v331 + 4 * v304;
          uint64_t v337 = *((void *)v12 + 4) + 8 * v129;
          v338 = __dst;
          v339 = (float **)v337;
          int v340 = v305;
          do
          {
            v341 = *v339;
            int v342 = v335 + 1;
            float v343 = *v341 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)&v336[4 * v335])) * v341[1]);
            if (v335 + 1 < v128) {
              int v344 = v335 + 1;
            }
            else {
              int v344 = 0;
            }
            float v345 = 0.0;
            if (v343 >= 0.0)
            {
              if (v343 <= 0.99608) {
                float v345 = v343 * 255.0;
              }
              else {
                float v345 = 255.0;
              }
            }
            v338->i8[v335] = (int)v345;
            BOOL v346 = v342 < v128;
            if (v342 >= v128) {
              int v347 = v303;
            }
            else {
              int v347 = 0;
            }
            v336 += 4 * v347;
            v339 = (float **)(v337 + 8 * v344);
            if (v346) {
              int v348 = 0;
            }
            else {
              int v348 = v128;
            }
            v338 = (uint16x4_t *)((char *)v338 + v348);
            int v335 = v344;
            --v340;
          }
          while (v340);
          if (v746 < 0 || !v308) {
            goto LABEL_427;
          }
          v349 = (unsigned int *)v331 + v743;
          v350 = *(float **)(*((void *)v12 + 4) + 8 * v746);
          float v351 = *v350;
          float v352 = v350[1];
          v353 = v308;
          int v354 = v14;
          do
          {
            float v355 = v351 + (float)(COERCE_FLOAT(bswap32(*v349)) * v352);
            float v356 = 0.0;
            if (v355 >= 0.0)
            {
              if (v355 <= 0.99608) {
                float v356 = v355 * 255.0;
              }
              else {
                float v356 = 255.0;
              }
            }
            v353->i8[0] = (int)v356;
            v353 = (uint16x4_t *)((char *)v353 + 1);
            v349 = (unsigned int *)((char *)v349 + v307);
            --v354;
          }
          while (v354);
        }
        v308 = (uint16x4_t *)((char *)v308 + a11);
LABEL_427:
        BOOL v17 = (int8x8_t *)((char *)v17 + v731);
        __dst = (uint16x4_t *)((char *)__dst + v306);
        if (!--v15)
        {
          if (!v135) {
            return;
          }
LABEL_429:
          uint64_t v102 = v750;
LABEL_430:
          free(v102);
          return;
        }
      }
    }
    if (a8 == __dst) {
      int v25 = -1;
    }
    else {
      int v25 = a1[2];
    }
    int v107 = a1[4];
    int v108 = a1[5];
    if (((v108 | v107) & 0x1F) != 0) {
      return;
    }
    int v109 = a1[3];
    int v110 = v108 - v107 * v109;
    if (v108 < v107 * v109) {
      return;
    }
    uint64_t v111 = a1[7];
    if (!a1[6]) {
      int v110 = 0;
    }
    int v112 = v110 + v107 * (v109 - 1);
    int v113 = v110 + v107;
    if (v25) {
      int v113 = v110;
    }
    else {
      int v112 = v110;
    }
    if (v25 >= 0) {
      int v114 = v109 - 1;
    }
    else {
      int v114 = a1[3];
    }
    BOOL v115 = v25 >= 0 && v25 == 0;
    if (v25 >= 0) {
      int v116 = v113;
    }
    else {
      int v116 = v110;
    }
    if (v25 >= 0) {
      int v117 = v112;
    }
    else {
      int v117 = v110;
    }
    int v735 = v25;
    BOOL v725 = v115;
    if (v111 == 2)
    {
      int v118 = v108 * a2 + 7;
      int v715 = v118 >> 3;
      unint64_t v119 = (int8x8_t *)malloc_type_malloc((uint64_t)v118 >> 3, 0x705560E0uLL);
      BOOL v115 = v725;
      int v25 = v735;
      uint64_t v12 = a1;
      LODWORD(v14) = a2;
      v120 = v119;
    }
    else
    {
      int v715 = 0;
      v120 = 0;
    }
    int v262 = v108 >> 5;
    uint64_t v263 = (uint64_t)v116 >> 5;
    uint64_t v264 = (v114 * v14);
    uint64_t v747 = (uint64_t)v117 >> 5;
    uint64_t v265 = a5;
    uint64_t v266 = a7;
    uint64_t v267 = 4 * v262;
    uint64_t v742 = v25;
    v268 = (float *)v758;
    v738 = v120;
    uint64_t v721 = v111;
    uint64_t v733 = a7;
    while (1)
    {
      if (v111 == 4)
      {
        int v269 = 0;
        v270 = (char *)v17 + 4 * v263;
        uint64_t v271 = *((void *)v12 + 4);
        v272 = __dst;
        int v273 = v264;
        uint64_t v274 = v271 + 8 * v115;
        do
        {
          int v275 = v269 + 1;
          *(float *)&v272->i32[v269] = **(float **)v274
                                     + (float)(*(float *)&v270[4 * v269] * *(float *)(*(void *)v274 + 4));
          if (v269 + 1 < v114) {
            ++v269;
          }
          else {
            int v269 = 0;
          }
          if (v275 >= v114) {
            int v276 = v262;
          }
          else {
            int v276 = 0;
          }
          v270 += 4 * v276;
          uint64_t v274 = v271 + 8 * v115 + 8 * v269;
          if (v275 >= v114) {
            int v277 = v114;
          }
          else {
            int v277 = 0;
          }
          v272 = (uint16x4_t *)((char *)v272 + 4 * v277);
          --v273;
        }
        while (v273);
        if (v25 < 0 || !v268) {
          goto LABEL_371;
        }
        v278 = (float *)v17 + v747;
        v279 = *(float **)(v271 + 8 * v742);
        float v280 = *v279;
        float v281 = v279[1];
        v282 = v268;
        int v283 = v14;
        do
        {
          *v282++ = v280 + (float)(*v278 * v281);
          v278 = (float *)((char *)v278 + v267);
          --v283;
        }
        while (v283);
      }
      else
      {
        v284 = v17;
        if (v120)
        {
          v285 = v268;
          uint64_t v286 = v263;
          uint64_t v287 = v264;
          v284 = decode_swap(v111, v120, v17, v715);
          uint64_t v264 = v287;
          uint64_t v263 = v286;
          v120 = v738;
          int v25 = v735;
          uint64_t v12 = a1;
          LODWORD(v14) = a2;
          uint64_t v111 = v721;
          BOOL v115 = v725;
          v268 = v285;
          uint64_t v266 = v733;
        }
        int v288 = 0;
        v289 = (char *)v284 + 4 * v263;
        uint64_t v290 = *((void *)v12 + 4);
        v291 = __dst;
        uint64_t v292 = v290 + 8 * v115;
        int v293 = v264;
        do
        {
          int v294 = v288 + 1;
          *(float *)&v291->i32[v288] = **(float **)v292
                                     + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)&v289[4 * v288]))
                                             * *(float *)(*(void *)v292 + 4));
          if (v288 + 1 < v114) {
            ++v288;
          }
          else {
            int v288 = 0;
          }
          if (v294 >= v114) {
            int v295 = v262;
          }
          else {
            int v295 = 0;
          }
          v289 += 4 * v295;
          uint64_t v292 = v290 + 8 * v115 + 8 * v288;
          if (v294 >= v114) {
            int v296 = v114;
          }
          else {
            int v296 = 0;
          }
          v291 = (uint16x4_t *)((char *)v291 + 4 * v296);
          --v293;
        }
        while (v293);
        if (v25 < 0 || !v268) {
          goto LABEL_371;
        }
        v297 = (unsigned int *)v284 + v747;
        v298 = *(float **)(v290 + 8 * v742);
        float v299 = *v298;
        float v300 = v298[1];
        v301 = v268;
        int v302 = v14;
        do
        {
          *v301++ = v299 + (float)(COERCE_FLOAT(bswap32(*v297)) * v300);
          v297 = (unsigned int *)((char *)v297 + v267);
          --v302;
        }
        while (v302);
      }
      v268 = (float *)((char *)v268 + a11);
LABEL_371:
      BOOL v17 = (int8x8_t *)((char *)v17 + v265);
      __dst = (uint16x4_t *)((char *)__dst + v266);
      if (!--v15)
      {
        if (!v120) {
          return;
        }
        uint64_t v102 = v738;
        goto LABEL_430;
      }
    }
  }
  if (v18 != 1)
  {
    if (v18 != 2)
    {
      if (v18 == 4)
      {
        int v19 = a8 == __dst ? -1 : a1[2];
        int v27 = a1[4];
        int v28 = a1[5];
        if (((v28 | v27) & 0xF) == 0 && !a1[7])
        {
          int v29 = a1[3];
          int v30 = v28 - v27 * v29;
          if (v28 >= v27 * v29)
          {
            if (!a1[6]) {
              int v30 = 0;
            }
            int v31 = v30 + v27 * (v29 - 1);
            int v32 = v30 + v27;
            BOOL v33 = v19 == 0;
            if (v19) {
              int v34 = v30;
            }
            else {
              int v34 = v32;
            }
            if (!v19) {
              int v31 = v30;
            }
            if (v19 >= 0) {
              int v35 = v29 - 1;
            }
            else {
              int v35 = a1[3];
            }
            if (v19 >= 0)
            {
              int v36 = v34;
            }
            else
            {
              BOOL v33 = 0;
              int v36 = v30;
            }
            if (v19 >= 0) {
              int v37 = v31;
            }
            else {
              int v37 = v30;
            }
            int v38 = v28 >> 4;
            int v39 = a7 >> 1;
            if (a7 >> 1 >= (int)a2) {
              int v39 = a2;
            }
            uint64_t v40 = (uint64_t)v36 >> 4;
            uint64_t v41 = *((void *)a1 + 4);
            uint64_t v42 = (uint64_t)v37 >> 4;
            do
            {
              int v43 = 0;
              uint64_t v44 = __dst;
              int v45 = v35 * v39;
              uint64_t v46 = v41 + 8 * v33;
              uint64_t v47 = (char *)v17 + 2 * v40;
              do
              {
                _H0 = *(_WORD *)&v47[2 * v43];
                int v49 = v43 + 1;
                __asm { FCVT            S0, H0 }
                _S0 = **(float **)v46 + (float)(_S0 * *(float *)(*(void *)v46 + 4));
                __asm { FCVT            H0, S0 }
                v44->i16[v43] = LOWORD(_S0);
                if (v43 + 1 < v35) {
                  ++v43;
                }
                else {
                  int v43 = 0;
                }
                if (v49 >= v35) {
                  int v55 = v38;
                }
                else {
                  int v55 = 0;
                }
                v47 += 2 * v55;
                uint64_t v46 = v41 + 8 * v33 + 8 * v43;
                if (v49 >= v35) {
                  int v56 = v35;
                }
                else {
                  int v56 = 0;
                }
                uint64_t v44 = (uint16x4_t *)((char *)v44 + 2 * v56);
                --v45;
              }
              while (v45);
              if ((v19 & 0x80000000) == 0 && v758)
              {
                unsigned int v57 = (__int16 *)v17 + v42;
                int v58 = *(float **)(v41 + 8 * v19);
                float v59 = *v58;
                float v60 = v58[1];
                int v61 = v758;
                int v62 = v39;
                do
                {
                  _H2 = *v57;
                  __asm { FCVT            S2, H2 }
                  _S2 = v59 + (float)(_S2 * v60);
                  __asm { FCVT            H2, S2 }
                  v61->i16[0] = LOWORD(_S2);
                  int v61 = (uint16x4_t *)((char *)v61 + 2);
                  v57 += v38;
                  --v62;
                }
                while (v62);
                v758 = (uint16x4_t *)((char *)v758 + a11);
              }
              BOOL v17 = (int8x8_t *)((char *)v17 + a5);
              __dst = (uint16x4_t *)((char *)__dst + a7);
              --v15;
            }
            while (v15);
          }
        }
      }
      return;
    }
    int v23 = a1[3];
    if (a8 == __dst) {
      unsigned int v24 = -1;
    }
    else {
      unsigned int v24 = a1[2];
    }
    int v104 = a1[4];
    int v103 = a1[5];
    unsigned int v724 = v24;
    if (v103 == v104 * v23)
    {
      int v105 = 0;
      if ((v24 & 0x80000000) == 0)
      {
LABEL_139:
        --v23;
        if (v24)
        {
          uint64_t v745 = 0;
          int v106 = v105 + v104 * v23;
        }
        else
        {
          int v106 = v105;
          uint64_t v745 = 1;
          v105 += v104;
        }
        goto LABEL_205;
      }
    }
    else
    {
      if (v103 <= v104 * v23) {
        return;
      }
      if (a1[6]) {
        int v105 = v103 - v104 * v23;
      }
      else {
        int v105 = 0;
      }
      if ((v24 & 0x80000000) == 0) {
        goto LABEL_139;
      }
    }
    uint64_t v745 = 0;
    int v106 = 0;
LABEL_205:
    uint64_t v719 = a1[7];
    if (v719)
    {
      int v144 = a3;
      if ((v103 & 7) == 0 && v104 == 16 && v719 == 2)
      {
        switch(v23)
        {
          case 4:
            int v366 = v103 >> 3;
            uint64_t v367 = *a1;
            int v368 = v105 >> 3;
            if ((v24 & 0x80000000) != 0)
            {
              uint64_t v425 = a5 - (uint64_t)(v366 * (int)a2);
              uint64_t v426 = a7 - 8 * (int)a2;
              int v427 = a3;
              if (*a1)
              {
                if (v367 == 2)
                {
                  v652 = (void *)*((void *)a1 + 4);
                  v653 = (_DWORD *)*v652;
                  v654 = (_DWORD *)v652[1];
                  int v655 = a2;
                  v656 = (_DWORD *)v652[2];
                  v657 = (_DWORD *)v652[3];
                  uint64_t v658 = v368;
                  int v660 = v653[2];
                  int v659 = v653[3];
                  int v662 = v654[2];
                  int v661 = v654[3];
                  int v664 = v656[2];
                  int v663 = v656[3];
                  int v666 = v657[2];
                  int v665 = v657[3];
                  int v667 = v653[4];
                  int v668 = v654[4];
                  int v669 = v656[4];
                  int v670 = v657[4];
                  int v671 = v655 + 1;
                  do
                  {
                    int v672 = v671;
                    do
                    {
                      int v673 = *(unsigned __int16 *)((char *)v17->u16 + v658);
                      int v674 = *(unsigned __int16 *)((char *)&v17->u16[1] + v658);
                      int v675 = *(unsigned __int16 *)((char *)&v17->u16[2] + v658);
                      int v676 = *(unsigned __int16 *)((char *)&v17->u16[3] + v658);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v366);
                      unsigned int v677 = ((v660 + v659 * v673) >> v667) & ~((v660 + v659 * v673) >> v667 >> 31);
                      unsigned int v678 = ((v662 + v661 * v674) >> v668) & ~((v662 + v661 * v674) >> v668 >> 31);
                      unsigned int v679 = ((v664 + v663 * v675) >> v669) & ~((v664 + v663 * v675) >> v669 >> 31);
                      unsigned int v680 = ((v666 + v665 * v676) >> v670) & ~((v666 + v665 * v676) >> v670 >> 31);
                      if (v677 >= 0xFFFF) {
                        LOWORD(v677) = -1;
                      }
                      if (v678 >= 0xFFFF) {
                        LOWORD(v678) = -1;
                      }
                      if (v679 >= 0xFFFF) {
                        LOWORD(v679) = -1;
                      }
                      if (v680 >= 0xFFFF) {
                        LOWORD(v680) = -1;
                      }
                      __dst->i16[0] = v677;
                      __dst->i16[1] = v678;
                      __dst->i16[2] = v679;
                      __dst->i16[3] = v680;
                      ++__dst;
                      --v672;
                    }
                    while (v672 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + (int)v425);
                    __dst = (uint16x4_t *)((char *)__dst + (int)v426);
                    _VF = __OFSUB__(v427--, 1);
                  }
                  while (!((v427 < 0) ^ _VF | (v427 == 0)));
                }
                else if (v367 == 1)
                {
                  do
                  {
                    int v428 = a2 + 1;
                    do
                    {
                      v429 = (int8x8_t *)((char *)v17 + v366);
                      *__dst++ = (uint16x4_t)vmvn_s8(*(int8x8_t *)((char *)v17 + v368));
                      --v428;
                      BOOL v17 = v429;
                    }
                    while (v428 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v429 + v425);
                    __dst = (uint16x4_t *)((char *)__dst + v426);
                    _VF = __OFSUB__(v427--, 1);
                  }
                  while (!((v427 < 0) ^ _VF | (v427 == 0)));
                }
              }
              else
              {
                do
                {
                  int v650 = a2 + 1;
                  do
                  {
                    v651 = (int8x8_t *)((char *)v17 + v366);
                    *__dst++ = *(uint16x4_t *)((char *)v17 + v368);
                    --v650;
                    BOOL v17 = v651;
                  }
                  while (v650 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v651 + (int)v425);
                  __dst = (uint16x4_t *)((char *)__dst + (int)v426);
                  _VF = __OFSUB__(v427--, 1);
                }
                while (!((v427 < 0) ^ _VF | (v427 == 0)));
              }
            }
            else
            {
              int v369 = v106 >> 3;
              uint64_t v370 = a5 - (uint64_t)(v366 * (int)a2);
              uint64_t v371 = a7 - 8 * (int)a2;
              uint64_t v372 = a11 - 2 * (int)a2;
              int v373 = a3;
              if (*a1)
              {
                if (v367 == 2)
                {
                  uint64_t v461 = *((void *)a1 + 4);
                  v462 = *(_DWORD **)(v461 + 8 * (v368 > v369));
                  uint64_t v463 = 8;
                  uint64_t v464 = 16;
                  if (v368 > v369) {
                    uint64_t v463 = 16;
                  }
                  v465 = *(_DWORD **)(v461 + v463);
                  uint64_t v466 = 24;
                  if (v368 > v369) {
                    uint64_t v464 = 24;
                  }
                  v467 = *(_DWORD **)(v461 + v464);
                  if (v368 > v369) {
                    uint64_t v466 = 32;
                  }
                  v468 = *(_DWORD **)(v461 + v466);
                  v469 = *(_DWORD **)(v461 + 32 * (v369 > v368));
                  int v471 = v469[2];
                  int v470 = v469[3];
                  uint64_t v757 = (int)v370;
                  int v473 = v462[2];
                  int v472 = v462[3];
                  int v475 = v465[2];
                  int v474 = v465[3];
                  int v477 = v467[2];
                  int v476 = v467[3];
                  int v478 = v14;
                  int v480 = v468[2];
                  int v479 = v468[3];
                  int v481 = v469[4];
                  int v482 = v462[4];
                  int v483 = v372;
                  int v484 = v465[4];
                  uint64_t v754 = v483;
                  int v485 = v371;
                  int v486 = v467[4];
                  uint64_t v751 = v485;
                  int v748 = v478 + 1;
                  int v487 = v468[4];
                  do
                  {
                    int v488 = v373;
                    int v489 = v748;
                    v490 = v758;
                    do
                    {
                      int v491 = *(unsigned __int16 *)((char *)v17->u16 + v369);
                      int v492 = *(unsigned __int16 *)((char *)v17->u16 + v368);
                      int v493 = *(unsigned __int16 *)((char *)&v17->u16[1] + v368);
                      int v494 = *(unsigned __int16 *)((char *)&v17->u16[2] + v368);
                      int v495 = *(unsigned __int16 *)((char *)&v17->u16[3] + v368);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v366);
                      unsigned int v496 = ((v471 + v470 * v491) >> v481) & ~((v471 + v470 * v491) >> v481 >> 31);
                      unsigned int v497 = ((v473 + v472 * v492) >> v482) & ~((v473 + v472 * v492) >> v482 >> 31);
                      unsigned int v498 = ((v475 + v474 * v493) >> v484) & ~((v475 + v474 * v493) >> v484 >> 31);
                      unsigned int v499 = ((v477 + v476 * v494) >> v486) & ~((v477 + v476 * v494) >> v486 >> 31);
                      unsigned int v500 = ((v480 + v479 * v495) >> v487) & ~((v480 + v479 * v495) >> v487 >> 31);
                      if (v496 >= 0xFFFF) {
                        LOWORD(v496) = -1;
                      }
                      if (v497 >= 0xFFFF) {
                        LOWORD(v497) = -1;
                      }
                      if (v498 >= 0xFFFF) {
                        LOWORD(v498) = -1;
                      }
                      if (v499 >= 0xFFFF) {
                        LOWORD(v499) = -1;
                      }
                      v490->i16[0] = v496;
                      v490 = (uint16x4_t *)((char *)v490 + 2);
                      if (v500 >= 0xFFFF) {
                        __int16 v501 = -1;
                      }
                      else {
                        __int16 v501 = v500;
                      }
                      __dst->i16[0] = v497;
                      __dst->i16[1] = v498;
                      __dst->i16[2] = v499;
                      __dst->i16[3] = v501;
                      ++__dst;
                      --v489;
                    }
                    while (v489 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v757);
                    v758 = (uint16x4_t *)((char *)v490 + v754);
                    __dst = (uint16x4_t *)((char *)__dst + v751);
                    int v373 = v488 - 1;
                  }
                  while (v488 > 1);
                }
                else if (v367 == 1)
                {
                  uint64_t v374 = v369;
                  do
                  {
                    int v375 = a2 + 1;
                    v376 = v758;
                    do
                    {
                      int8x8_t v377 = *(int8x8_t *)((char *)v17 + v368);
                      v376->i16[0] = ~*(__int16 *)((char *)v17->i16 + v374);
                      v376 = (uint16x4_t *)((char *)v376 + 2);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v366);
                      *__dst++ = (uint16x4_t)vmvn_s8(v377);
                      --v375;
                    }
                    while (v375 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v370);
                    v758 = (uint16x4_t *)((char *)v376 + v372);
                    __dst = (uint16x4_t *)((char *)__dst + v371);
                    _VF = __OFSUB__(v373--, 1);
                  }
                  while (!((v373 < 0) ^ _VF | (v373 == 0)));
                }
              }
              else
              {
                uint64_t v457 = v369;
                do
                {
                  int v458 = a2 + 1;
                  v459 = v758;
                  do
                  {
                    uint16x4_t v460 = *(uint16x4_t *)((char *)v17 + v368);
                    v459->i16[0] = *(__int16 *)((char *)v17->i16 + v457);
                    v459 = (uint16x4_t *)((char *)v459 + 2);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v366);
                    *__dst++ = v460;
                    --v458;
                  }
                  while (v458 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v370);
                  v758 = (uint16x4_t *)((char *)v459 + (int)v372);
                  __dst = (uint16x4_t *)((char *)__dst + (int)v371);
                  _VF = __OFSUB__(v373--, 1);
                }
                while (!((v373 < 0) ^ _VF | (v373 == 0)));
              }
            }
            return;
          case 3:
            int v378 = v103 >> 3;
            uint64_t v379 = *a1;
            int v380 = v105 >> 3;
            if ((v24 & 0x80000000) != 0)
            {
              uint64_t v430 = a5 - (uint64_t)(v378 * (int)a2);
              int v431 = a7 - 6 * a2;
              int v432 = v15;
              if (*a1)
              {
                if (v379 == 2)
                {
                  v683 = (void *)*((void *)a1 + 4);
                  v685 = (_DWORD *)*v683;
                  v684 = (_DWORD *)v683[1];
                  v686 = (_DWORD *)v683[2];
                  uint64_t v687 = v380;
                  int v689 = v685[2];
                  int v688 = v685[3];
                  int v691 = v684[2];
                  int v690 = v684[3];
                  int v693 = v686[2];
                  int v692 = v686[3];
                  int v694 = v685[4];
                  int v695 = v684[4];
                  int v696 = v686[4];
                  do
                  {
                    int v697 = v14 + 1;
                    do
                    {
                      int v698 = *(unsigned __int16 *)((char *)v17->u16 + v687);
                      int v699 = *(unsigned __int16 *)((char *)&v17->u16[1] + v687);
                      int v700 = *(unsigned __int16 *)((char *)&v17->u16[2] + v687);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v378);
                      unsigned int v701 = ((v689 + v688 * v698) >> v694) & ~((v689 + v688 * v698) >> v694 >> 31);
                      unsigned int v702 = ((v691 + v690 * v699) >> v695) & ~((v691 + v690 * v699) >> v695 >> 31);
                      unsigned int v703 = ((v693 + v692 * v700) >> v696) & ~((v693 + v692 * v700) >> v696 >> 31);
                      if (v701 >= 0xFFFF) {
                        LOWORD(v701) = -1;
                      }
                      if (v702 >= 0xFFFF) {
                        LOWORD(v702) = -1;
                      }
                      if (v703 >= 0xFFFF) {
                        LOWORD(v703) = -1;
                      }
                      __dst->i16[0] = v701;
                      __dst->i16[1] = v702;
                      __dst->i16[2] = v703;
                      __dst = (uint16x4_t *)((char *)__dst + 6);
                      --v697;
                    }
                    while (v697 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + (int)v430);
                    __dst = (uint16x4_t *)((char *)__dst + v431);
                    _VF = __OFSUB__(v432--, 1);
                  }
                  while (!((v432 < 0) ^ _VF | (v432 == 0)));
                }
                else if (v379 == 1)
                {
                  do
                  {
                    int v433 = a2 + 1;
                    do
                    {
                      __int16 v434 = *(__int16 *)((char *)&v17->i16[1] + v380);
                      __int16 v435 = *(__int16 *)((char *)&v17->i16[2] + v380);
                      __dst->i16[0] = ~*(__int16 *)((char *)v17->i16 + v380);
                      __dst->i16[1] = ~v434;
                      __dst->i16[2] = ~v435;
                      BOOL v17 = (int8x8_t *)((char *)v17 + v378);
                      __dst = (uint16x4_t *)((char *)__dst + 6);
                      --v433;
                    }
                    while (v433 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v430);
                    __dst = (uint16x4_t *)((char *)__dst + v431);
                    _VF = __OFSUB__(v432--, 1);
                  }
                  while (!((v432 < 0) ^ _VF | (v432 == 0)));
                }
              }
              else
              {
                do
                {
                  int v681 = a2 + 1;
                  do
                  {
                    __int16 v682 = *(__int16 *)((char *)&v17->i16[2] + v380);
                    __dst->i32[0] = *(__int32 *)((char *)v17->i32 + v380);
                    __dst->i16[2] = v682;
                    BOOL v17 = (int8x8_t *)((char *)v17 + v378);
                    __dst = (uint16x4_t *)((char *)__dst + 6);
                    --v681;
                  }
                  while (v681 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v430);
                  __dst = (uint16x4_t *)((char *)__dst + v431);
                  _VF = __OFSUB__(v432--, 1);
                }
                while (!((v432 < 0) ^ _VF | (v432 == 0)));
              }
            }
            else
            {
              int v381 = v106 >> 3;
              uint64_t v382 = a5 - (uint64_t)(v378 * (int)a2);
              int v383 = a7 - 6 * a2;
              uint64_t v384 = a11 - 2 * (int)a2;
              if (*a1)
              {
                if (v379 == 2)
                {
                  uint64_t v506 = *((void *)a1 + 4);
                  int v507 = a2;
                  v508 = *(_DWORD **)(v506 + 8 * (v380 > v381));
                  uint64_t v509 = 8;
                  uint64_t v510 = 16;
                  if (v380 > v381) {
                    uint64_t v509 = 16;
                  }
                  v511 = *(_DWORD **)(v506 + v509);
                  uint64_t v512 = 24;
                  if (v380 > v381) {
                    uint64_t v510 = 24;
                  }
                  v513 = *(_DWORD **)(v506 + v510);
                  if (v381 <= v380) {
                    uint64_t v512 = 0;
                  }
                  v514 = *(_DWORD **)(v506 + v512);
                  int v516 = v514[2];
                  int v515 = v514[3];
                  int v518 = v508[2];
                  int v517 = v508[3];
                  int v519 = v511[2];
                  int v520 = v511[3];
                  int v522 = v513[2];
                  int v521 = v513[3];
                  int v523 = v514[4];
                  int v524 = v508[4];
                  int v525 = v511[4];
                  int v526 = v384;
                  int v527 = v513[4];
                  do
                  {
                    int v528 = v507 + 1;
                    v529 = v758;
                    do
                    {
                      int v530 = *(unsigned __int16 *)((char *)v17->u16 + v381);
                      int v531 = *(unsigned __int16 *)((char *)v17->u16 + v380);
                      int v532 = *(unsigned __int16 *)((char *)&v17->u16[1] + v380);
                      int v533 = *(unsigned __int16 *)((char *)&v17->u16[2] + v380);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v378);
                      unsigned int v534 = ((v516 + v515 * v530) >> v523) & ~((v516 + v515 * v530) >> v523 >> 31);
                      unsigned int v535 = ((v518 + v517 * v531) >> v524) & ~((v518 + v517 * v531) >> v524 >> 31);
                      unsigned int v536 = ((v519 + v520 * v532) >> v525) & ~((v519 + v520 * v532) >> v525 >> 31);
                      unsigned int v537 = ((v522 + v521 * v533) >> v527) & ~((v522 + v521 * v533) >> v527 >> 31);
                      if (v534 >= 0xFFFF) {
                        LOWORD(v534) = -1;
                      }
                      if (v535 >= 0xFFFF) {
                        LOWORD(v535) = -1;
                      }
                      if (v536 >= 0xFFFF) {
                        LOWORD(v536) = -1;
                      }
                      if (v537 >= 0xFFFF) {
                        LOWORD(v537) = -1;
                      }
                      v529->i16[0] = v534;
                      v529 = (uint16x4_t *)((char *)v529 + 2);
                      __dst->i16[0] = v535;
                      __dst->i16[1] = v536;
                      __dst->i16[2] = v537;
                      __dst = (uint16x4_t *)((char *)__dst + 6);
                      --v528;
                    }
                    while (v528 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + (int)v382);
                    v758 = (uint16x4_t *)((char *)v529 + v526);
                    __dst = (uint16x4_t *)((char *)__dst + v383);
                    _VF = __OFSUB__(v144--, 1);
                  }
                  while (!((v144 < 0) ^ _VF | (v144 == 0)));
                }
                else if (v379 == 1)
                {
                  do
                  {
                    int v385 = v14 + 1;
                    v386 = v758;
                    do
                    {
                      __int16 v387 = *(__int16 *)((char *)v17->i16 + v380);
                      __int16 v388 = *(__int16 *)((char *)&v17->i16[1] + v380);
                      __int16 v389 = *(__int16 *)((char *)&v17->i16[2] + v380);
                      v386->i16[0] = ~*(__int16 *)((char *)v17->i16 + v381);
                      v386 = (uint16x4_t *)((char *)v386 + 2);
                      __dst->i16[0] = ~v387;
                      __dst->i16[1] = ~v388;
                      __dst->i16[2] = ~v389;
                      BOOL v17 = (int8x8_t *)((char *)v17 + v378);
                      __dst = (uint16x4_t *)((char *)__dst + 6);
                      --v385;
                    }
                    while (v385 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v382);
                    v758 = (uint16x4_t *)((char *)v386 + v384);
                    __dst = (uint16x4_t *)((char *)__dst + v383);
                    _VF = __OFSUB__(v144--, 1);
                  }
                  while (!((v144 < 0) ^ _VF | (v144 == 0)));
                }
              }
              else
              {
                do
                {
                  int v502 = v14 + 1;
                  v503 = v758;
                  do
                  {
                    __int32 v504 = *(__int32 *)((char *)v17->i32 + v380);
                    __int16 v505 = *(__int16 *)((char *)&v17->i16[2] + v380);
                    v503->i16[0] = *(__int16 *)((char *)v17->i16 + v381);
                    v503 = (uint16x4_t *)((char *)v503 + 2);
                    __dst->i32[0] = v504;
                    __dst->i16[2] = v505;
                    BOOL v17 = (int8x8_t *)((char *)v17 + v378);
                    __dst = (uint16x4_t *)((char *)__dst + 6);
                    --v502;
                  }
                  while (v502 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v382);
                  v758 = (uint16x4_t *)((char *)v503 + (int)v384);
                  __dst = (uint16x4_t *)((char *)__dst + v383);
                  _VF = __OFSUB__(v144--, 1);
                }
                while (!((v144 < 0) ^ _VF | (v144 == 0)));
              }
            }
            return;
          case 1:
            int v145 = v103 >> 3;
            uint64_t v146 = *a1;
            int v147 = v105 >> 3;
            if ((v24 & 0x80000000) != 0)
            {
              uint64_t v421 = a5 - (uint64_t)(v145 * (int)a2);
              uint64_t v422 = a7 - 2 * (int)a2;
              int v423 = a3;
              if (*a1)
              {
                if (v146 == 2)
                {
                  v642 = (_DWORD *)**((void **)a1 + 4);
                  uint64_t v643 = v147;
                  int v645 = v642[2];
                  int v644 = v642[3];
                  int v646 = v642[4];
                  do
                  {
                    int v647 = v14 + 1;
                    do
                    {
                      int v648 = *(unsigned __int16 *)((char *)v17->u16 + v643);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v145);
                      unsigned int v649 = ((v645 + v644 * v648) >> v646) & ~((v645 + v644 * v648) >> v646 >> 31);
                      if (v649 >= 0xFFFF) {
                        LOWORD(v649) = -1;
                      }
                      __dst->i16[0] = v649;
                      __dst = (uint16x4_t *)((char *)__dst + 2);
                      --v647;
                    }
                    while (v647 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + (int)v421);
                    __dst = (uint16x4_t *)((char *)__dst + (int)v422);
                    _VF = __OFSUB__(v423--, 1);
                  }
                  while (!((v423 < 0) ^ _VF | (v423 == 0)));
                }
                else if (v146 == 1)
                {
                  do
                  {
                    int v424 = v14 + 1;
                    do
                    {
                      __dst->i16[0] = ~*(__int16 *)((char *)v17->i16 + v147);
                      __dst = (uint16x4_t *)((char *)__dst + 2);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v145);
                      --v424;
                    }
                    while (v424 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v421);
                    __dst = (uint16x4_t *)((char *)__dst + v422);
                    _VF = __OFSUB__(v423--, 1);
                  }
                  while (!((v423 < 0) ^ _VF | (v423 == 0)));
                }
              }
              else
              {
                do
                {
                  int v641 = v14 + 1;
                  do
                  {
                    __dst->i16[0] = *(__int16 *)((char *)v17->i16 + v147);
                    __dst = (uint16x4_t *)((char *)__dst + 2);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v145);
                    --v641;
                  }
                  while (v641 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v421);
                  __dst = (uint16x4_t *)((char *)__dst + (int)v422);
                  _VF = __OFSUB__(v423--, 1);
                }
                while (!((v423 < 0) ^ _VF | (v423 == 0)));
              }
            }
            else
            {
              int v148 = v106 >> 3;
              uint64_t v149 = a5 - (uint64_t)(v145 * (int)a2);
              uint64_t v150 = a7 - (uint64_t)(2 * (int)a2);
              uint64_t v151 = a11 - 2 * (int)a2;
              int v152 = a3;
              if (*a1)
              {
                if (v146 == 2)
                {
                  uint64_t v440 = *((void *)a1 + 4);
                  v441 = *(_DWORD **)(v440 + 8 * (v147 > v148));
                  v442 = *(_DWORD **)(v440 + 8 * (v148 > v147));
                  uint64_t v443 = v148;
                  int v445 = v442[2];
                  int v444 = v442[3];
                  int v447 = v441[2];
                  int v446 = v441[3];
                  int v448 = v442[4];
                  int v449 = v441[4];
                  int v450 = v14 + 1;
                  do
                  {
                    int v451 = v450;
                    v452 = v758;
                    do
                    {
                      int v453 = *(unsigned __int16 *)((char *)v17->u16 + v443);
                      int v454 = *(unsigned __int16 *)((char *)v17->u16 + v147);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v145);
                      unsigned int v455 = ((v445 + v444 * v453) >> v448) & ~((v445 + v444 * v453) >> v448 >> 31);
                      unsigned int v456 = ((v447 + v446 * v454) >> v449) & ~((v447 + v446 * v454) >> v449 >> 31);
                      if (v455 >= 0xFFFF) {
                        LOWORD(v455) = -1;
                      }
                      if (v456 >= 0xFFFF) {
                        LOWORD(v456) = -1;
                      }
                      v452->i16[0] = v455;
                      v452 = (uint16x4_t *)((char *)v452 + 2);
                      __dst->i16[0] = v456;
                      __dst = (uint16x4_t *)((char *)__dst + 2);
                      --v451;
                    }
                    while (v451 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + (int)v149);
                    v758 = (uint16x4_t *)((char *)v452 + (int)v151);
                    __dst = (uint16x4_t *)((char *)__dst + (int)v150);
                    _VF = __OFSUB__(v152--, 1);
                  }
                  while (!((v152 < 0) ^ _VF | (v152 == 0)));
                }
                else if (v146 == 1)
                {
                  do
                  {
                    int v153 = a2 + 1;
                    v154 = v758;
                    do
                    {
                      __int16 v155 = *(__int16 *)((char *)v17->i16 + v147);
                      v154->i16[0] = ~*(__int16 *)((char *)v17->i16 + v148);
                      v154 = (uint16x4_t *)((char *)v154 + 2);
                      __dst->i16[0] = ~v155;
                      __dst = (uint16x4_t *)((char *)__dst + 2);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v145);
                      --v153;
                    }
                    while (v153 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v149);
                    v758 = (uint16x4_t *)((char *)v154 + v151);
                    __dst = (uint16x4_t *)((char *)__dst + v150);
                    _VF = __OFSUB__(v152--, 1);
                  }
                  while (!((v152 < 0) ^ _VF | (v152 == 0)));
                }
              }
              else
              {
                do
                {
                  int v437 = a2 + 1;
                  v438 = v758;
                  do
                  {
                    __int16 v439 = *(__int16 *)((char *)v17->i16 + v147);
                    v438->i16[0] = *(__int16 *)((char *)v17->i16 + v148);
                    v438 = (uint16x4_t *)((char *)v438 + 2);
                    __dst->i16[0] = v439;
                    __dst = (uint16x4_t *)((char *)__dst + 2);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v145);
                    --v437;
                  }
                  while (v437 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v149);
                  v758 = (uint16x4_t *)((char *)v438 + (int)v151);
                  __dst = (uint16x4_t *)((char *)__dst + (int)v150);
                  _VF = __OFSUB__(v152--, 1);
                }
                while (!((v152 < 0) ^ _VF | (v152 == 0)));
              }
            }
            return;
        }
      }
      int v156 = v103 * a2 + 7;
      int v712 = v156 >> 3;
      v157 = (int8x8_t *)malloc_type_malloc((uint64_t)v156 >> 3, 0x705560E0uLL);
      unsigned int v24 = v724;
      uint64_t v12 = a1;
      LODWORD(v14) = a2;
      v158 = v157;
    }
    else
    {
      v158 = 0;
      int v712 = 0;
      if (v104 == 16 && (v103 & 7) == 0)
      {
        switch(v23)
        {
          case 4:
            int v390 = v103 >> 3;
            unsigned int v391 = v24;
            uint64_t v392 = *a1;
            if ((v391 & 0x80000000) != 0)
            {
              decode_word_16bpc_4(v14, v15, v390, (uint64_t)__src, a5, __dst, a7, v392, *((void **)a1 + 4), v105 >> 3);
            }
            else
            {
              int v393 = v105 >> 3;
              int v394 = v106 >> 3;
              uint64_t v395 = a5 - (uint64_t)(v390 * (int)v14);
              uint64_t v396 = a7 - 8 * (int)v14;
              uint64_t v397 = a11 - 2 * (int)v14;
              if (*a1)
              {
                if (v392 == 2)
                {
                  uint64_t v577 = *((void *)a1 + 4);
                  v578 = *(_DWORD **)(v577 + 8 * (v393 > v394));
                  uint64_t v579 = 8;
                  uint64_t v580 = 16;
                  if (v393 > v394) {
                    uint64_t v579 = 16;
                  }
                  v581 = *(_DWORD **)(v577 + v579);
                  uint64_t v582 = 24;
                  if (v393 > v394) {
                    uint64_t v580 = 24;
                  }
                  v583 = *(_DWORD **)(v577 + v580);
                  if (v393 > v394) {
                    uint64_t v582 = 32;
                  }
                  v584 = *(_DWORD **)(v577 + v582);
                  v585 = *(_DWORD **)(v577 + 32 * (v394 > v393));
                  int v586 = v14;
                  uint64_t v587 = v390;
                  int v589 = v585[2];
                  int v588 = v585[3];
                  int v590 = v585[4];
                  v592.i32[0] = v578[2];
                  v591.i32[0] = v578[3];
                  v591.i32[1] = v581[3];
                  v591.i32[2] = v583[3];
                  v591.i32[3] = v584[3];
                  v592.i32[1] = v581[2];
                  v592.i32[2] = v583[2];
                  v592.i32[3] = v584[2];
                  v593.i32[0] = v578[4];
                  v593.i32[1] = v581[4];
                  v593.i32[2] = v583[4];
                  v593.i32[3] = v584[4];
                  int32x4_t v594 = vnegq_s32(v593);
                  do
                  {
                    int v595 = v586 + 1;
                    v596 = v758;
                    do
                    {
                      unsigned int v597 = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v394)) >> 16;
                      v598 = (char *)v17 + v587;
                      unsigned int v599 = ((int)(v589 + v588 * v597) >> v590) & ~((int)(v589 + v588 * v597) >> v590 >> 31);
                      if (v599 >= 0xFFFF) {
                        LOWORD(v599) = -1;
                      }
                      int8x8_t v600 = *(int8x8_t *)((char *)v17 + v393);
                      v596->i16[0] = v599;
                      v596 = (uint16x4_t *)((char *)v596 + 2);
                      *__dst++ = vqmovn_u32((uint32x4_t)vmaxq_s32(vshlq_s32(vmlaq_s32(v592, v591, (int32x4_t)vmovl_u16((uint16x4_t)vrev16_s8(v600))), v594), (int32x4_t)0));
                      --v595;
                      BOOL v17 = (int8x8_t *)((char *)v17 + v587);
                    }
                    while (v595 > 1);
                    BOOL v17 = (int8x8_t *)&v598[(int)v395];
                    v758 = (uint16x4_t *)((char *)v596 + (int)v397);
                    __dst = (uint16x4_t *)((char *)__dst + (int)v396);
                    _VF = __OFSUB__(v15--, 1);
                  }
                  while (!((v15 < 0) ^ _VF | (v15 == 0)));
                }
                else if (v392 == 1)
                {
                  do
                  {
                    int v398 = v14 + 1;
                    v399 = v758;
                    do
                    {
                      int8x8_t v400 = *(int8x8_t *)((char *)v17 + v393);
                      v399->i16[0] = bswap32(~*(unsigned __int16 *)((char *)v17->u16 + v394)) >> 16;
                      v399 = (uint16x4_t *)((char *)v399 + 2);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v390);
                      *__dst++ = (uint16x4_t)vrev16_s8(vmvn_s8(v400));
                      --v398;
                    }
                    while (v398 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v395);
                    v758 = (uint16x4_t *)((char *)v399 + v397);
                    __dst = (uint16x4_t *)((char *)__dst + v396);
                    _VF = __OFSUB__(v15--, 1);
                  }
                  while (!((v15 < 0) ^ _VF | (v15 == 0)));
                }
              }
              else
              {
                do
                {
                  int v574 = v14 + 1;
                  v575 = v758;
                  do
                  {
                    int8x8_t v576 = *(int8x8_t *)((char *)v17 + v393);
                    v575->i16[0] = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v394)) >> 16;
                    v575 = (uint16x4_t *)((char *)v575 + 2);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v390);
                    *__dst++ = (uint16x4_t)vrev16_s8(v576);
                    --v574;
                  }
                  while (v574 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v395);
                  v758 = (uint16x4_t *)((char *)v575 + (int)v397);
                  __dst = (uint16x4_t *)((char *)__dst + (int)v396);
                  _VF = __OFSUB__(v15--, 1);
                }
                while (!((v15 < 0) ^ _VF | (v15 == 0)));
              }
            }
            return;
          case 3:
            int v401 = v103 >> 3;
            unsigned int v402 = v24;
            uint64_t v403 = *a1;
            if ((v402 & 0x80000000) != 0)
            {
              decode_word_16bpc_3(v14, v15, v401, (uint64_t)__src, a5, __dst, a7, v403, *((void **)a1 + 4), v105 >> 3);
            }
            else
            {
              int v404 = v105 >> 3;
              int v405 = v106 >> 3;
              uint64_t v406 = a5 - (uint64_t)(v401 * (int)v14);
              int v407 = a7 - 6 * v14;
              uint64_t v408 = a11 - 2 * (int)v14;
              if (*a1)
              {
                if (v403 == 2)
                {
                  uint64_t v608 = *((void *)a1 + 4);
                  int v609 = v14;
                  v610 = *(_DWORD **)(v608 + 8 * (v404 > v405));
                  uint64_t v611 = 8;
                  uint64_t v612 = 16;
                  if (v404 > v405) {
                    uint64_t v611 = 16;
                  }
                  v613 = *(_DWORD **)(v608 + v611);
                  uint64_t v614 = 24;
                  if (v404 > v405) {
                    uint64_t v612 = 24;
                  }
                  v615 = *(_DWORD **)(v608 + v612);
                  if (v405 <= v404) {
                    uint64_t v614 = 0;
                  }
                  v616 = *(_DWORD **)(v608 + v614);
                  int v618 = v616[2];
                  int v617 = v616[3];
                  int v620 = v610[2];
                  int v619 = v610[3];
                  uint64_t v621 = v401;
                  int v622 = v613[2];
                  int v623 = v613[3];
                  int v625 = v615[2];
                  int v624 = v615[3];
                  int v626 = v616[4];
                  int v627 = v610[4];
                  int v628 = v613[4];
                  int v629 = v408;
                  int v630 = v615[4];
                  do
                  {
                    int v631 = v609 + 1;
                    v632 = v758;
                    do
                    {
                      unsigned int v633 = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v405));
                      unsigned int v634 = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v404));
                      unsigned int v635 = bswap32(*(unsigned __int16 *)((char *)&v17->u16[1] + v404));
                      unsigned int v636 = bswap32(*(unsigned __int16 *)((char *)&v17->u16[2] + v404));
                      BOOL v17 = (int8x8_t *)((char *)v17 + v621);
                      unsigned int v637 = ((int)(v618 + v617 * HIWORD(v633)) >> v626) & ~((int)(v618 + v617 * HIWORD(v633)) >> v626 >> 31);
                      unsigned int v638 = ((int)(v620 + v619 * HIWORD(v634)) >> v627) & ~((int)(v620 + v619 * HIWORD(v634)) >> v627 >> 31);
                      unsigned int v639 = ((int)(v622 + v623 * HIWORD(v635)) >> v628) & ~((int)(v622 + v623 * HIWORD(v635)) >> v628 >> 31);
                      unsigned int v640 = ((int)(v625 + v624 * HIWORD(v636)) >> v630) & ~((int)(v625 + v624 * HIWORD(v636)) >> v630 >> 31);
                      if (v637 >= 0xFFFF) {
                        LOWORD(v637) = -1;
                      }
                      if (v638 >= 0xFFFF) {
                        LOWORD(v638) = -1;
                      }
                      if (v639 >= 0xFFFF) {
                        LOWORD(v639) = -1;
                      }
                      if (v640 >= 0xFFFF) {
                        LOWORD(v640) = -1;
                      }
                      v632->i16[0] = v637;
                      v632 = (uint16x4_t *)((char *)v632 + 2);
                      __dst->i16[0] = v638;
                      __dst->i16[1] = v639;
                      __dst->i16[2] = v640;
                      __dst = (uint16x4_t *)((char *)__dst + 6);
                      --v631;
                    }
                    while (v631 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + (int)v406);
                    v758 = (uint16x4_t *)((char *)v632 + v629);
                    __dst = (uint16x4_t *)((char *)__dst + v407);
                    _VF = __OFSUB__(v15--, 1);
                  }
                  while (!((v15 < 0) ^ _VF | (v15 == 0)));
                }
                else if (v403 == 1)
                {
                  uint64_t v409 = v405;
                  uint64_t v410 = v401;
                  do
                  {
                    int v411 = v14 + 1;
                    v412 = v758;
                    do
                    {
                      int v413 = *(unsigned __int16 *)((char *)v17->u16 + v404);
                      int v414 = *(unsigned __int16 *)((char *)&v17->u16[1] + v404);
                      int v415 = *(unsigned __int16 *)((char *)&v17->u16[2] + v404);
                      v412->i16[0] = bswap32(~*(unsigned __int16 *)((char *)v17->u16 + v409)) >> 16;
                      v412 = (uint16x4_t *)((char *)v412 + 2);
                      __dst->i16[0] = bswap32(~v413) >> 16;
                      __dst->i16[1] = bswap32(~v414) >> 16;
                      __dst->i16[2] = bswap32(~v415) >> 16;
                      BOOL v17 = (int8x8_t *)((char *)v17 + v410);
                      __dst = (uint16x4_t *)((char *)__dst + 6);
                      --v411;
                    }
                    while (v411 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v406);
                    v758 = (uint16x4_t *)((char *)v412 + v408);
                    __dst = (uint16x4_t *)((char *)__dst + v407);
                    _VF = __OFSUB__(v15--, 1);
                  }
                  while (!((v15 < 0) ^ _VF | (v15 == 0)));
                }
              }
              else
              {
                uint64_t v601 = v405;
                uint64_t v602 = v401;
                do
                {
                  int v603 = v14 + 1;
                  v604 = v758;
                  do
                  {
                    unsigned int v605 = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v404)) >> 16;
                    unsigned int v606 = bswap32(*(unsigned __int16 *)((char *)&v17->u16[1] + v404));
                    unsigned int v607 = bswap32(*(unsigned __int16 *)((char *)&v17->u16[2] + v404));
                    v604->i16[0] = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v601)) >> 16;
                    v604 = (uint16x4_t *)((char *)v604 + 2);
                    __dst->i16[0] = v605;
                    __dst->i16[1] = HIWORD(v606);
                    __dst->i16[2] = HIWORD(v607);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v602);
                    __dst = (uint16x4_t *)((char *)__dst + 6);
                    --v603;
                  }
                  while (v603 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v406);
                  v758 = (uint16x4_t *)((char *)v604 + (int)v408);
                  __dst = (uint16x4_t *)((char *)__dst + v407);
                  _VF = __OFSUB__(v15--, 1);
                }
                while (!((v15 < 0) ^ _VF | (v15 == 0)));
              }
            }
            return;
          case 1:
            int v196 = v103 >> 3;
            unsigned int v197 = v24;
            uint64_t v198 = *a1;
            if ((v197 & 0x80000000) != 0)
            {
              decode_word_16bpc_1(v14, v15, v196, (uint64_t)__src, a5, __dst, a7, v198, *((void *)a1 + 4), v105 >> 3);
            }
            else
            {
              int v199 = v105 >> 3;
              int v200 = v106 >> 3;
              uint64_t v201 = a5 - (uint64_t)(v196 * (int)v14);
              uint64_t v202 = a7 - (uint64_t)(2 * (int)v14);
              uint64_t v203 = a11 - 2 * (int)v14;
              if (*a1)
              {
                if (v198 == 2)
                {
                  uint64_t v557 = *((void *)a1 + 4);
                  v558 = *(_DWORD **)(v557 + 8 * (v199 > v200));
                  v559 = *(_DWORD **)(v557 + 8 * (v200 > v199));
                  uint64_t v560 = v196;
                  int v562 = v559[2];
                  int v561 = v559[3];
                  int v564 = v558[2];
                  int v563 = v558[3];
                  int v565 = v559[4];
                  int v566 = v558[4];
                  int v567 = v14 + 1;
                  do
                  {
                    int v568 = v567;
                    v569 = v758;
                    do
                    {
                      unsigned int v570 = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v200));
                      unsigned int v571 = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v199));
                      BOOL v17 = (int8x8_t *)((char *)v17 + v560);
                      unsigned int v572 = ((int)(v562 + v561 * HIWORD(v570)) >> v565) & ~((int)(v562 + v561 * HIWORD(v570)) >> v565 >> 31);
                      unsigned int v573 = ((int)(v564 + v563 * HIWORD(v571)) >> v566) & ~((int)(v564 + v563 * HIWORD(v571)) >> v566 >> 31);
                      if (v572 >= 0xFFFF) {
                        LOWORD(v572) = -1;
                      }
                      if (v573 >= 0xFFFF) {
                        LOWORD(v573) = -1;
                      }
                      v569->i16[0] = v572;
                      v569 = (uint16x4_t *)((char *)v569 + 2);
                      __dst->i16[0] = v573;
                      __dst = (uint16x4_t *)((char *)__dst + 2);
                      --v568;
                    }
                    while (v568 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + (int)v201);
                    v758 = (uint16x4_t *)((char *)v569 + (int)v203);
                    __dst = (uint16x4_t *)((char *)__dst + (int)v202);
                    _VF = __OFSUB__(v15--, 1);
                  }
                  while (!((v15 < 0) ^ _VF | (v15 == 0)));
                }
                else if (v198 == 1)
                {
                  do
                  {
                    int v204 = v14 + 1;
                    v205 = v758;
                    do
                    {
                      int v206 = *(unsigned __int16 *)((char *)v17->u16 + v199);
                      v205->i16[0] = bswap32(~*(unsigned __int16 *)((char *)v17->u16 + v200)) >> 16;
                      v205 = (uint16x4_t *)((char *)v205 + 2);
                      __dst->i16[0] = bswap32(~v206) >> 16;
                      __dst = (uint16x4_t *)((char *)__dst + 2);
                      BOOL v17 = (int8x8_t *)((char *)v17 + v196);
                      --v204;
                    }
                    while (v204 > 1);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v201);
                    v758 = (uint16x4_t *)((char *)v205 + v203);
                    __dst = (uint16x4_t *)((char *)__dst + v202);
                    _VF = __OFSUB__(v15--, 1);
                  }
                  while (!((v15 < 0) ^ _VF | (v15 == 0)));
                }
              }
              else
              {
                do
                {
                  int v554 = v14 + 1;
                  v555 = v758;
                  do
                  {
                    unsigned int v556 = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v199));
                    v555->i16[0] = bswap32(*(unsigned __int16 *)((char *)v17->u16 + v200)) >> 16;
                    v555 = (uint16x4_t *)((char *)v555 + 2);
                    __dst->i16[0] = HIWORD(v556);
                    __dst = (uint16x4_t *)((char *)__dst + 2);
                    BOOL v17 = (int8x8_t *)((char *)v17 + v196);
                    --v554;
                  }
                  while (v554 > 1);
                  BOOL v17 = (int8x8_t *)((char *)v17 + (int)v201);
                  v758 = (uint16x4_t *)((char *)v555 + (int)v203);
                  __dst = (uint16x4_t *)((char *)__dst + (int)v202);
                  _VF = __OFSUB__(v15--, 1);
                }
                while (!((v15 < 0) ^ _VF | (v15 == 0)));
              }
            }
            return;
        }
        int v712 = 0;
        v158 = 0;
      }
    }
    int v159 = a5;
    if (v104 >= 16) {
      int v160 = 16;
    }
    else {
      int v160 = v104;
    }
    int v161 = ~(-1 << v160);
    int v740 = v23 * v14;
    uint64_t v737 = (uint64_t)v105 >> 3;
    uint64_t v710 = (uint64_t)v106 >> 3;
    uint64_t v732 = v159;
    uint64_t v706 = v24;
    v717 = v158;
    do
    {
      int v749 = v15;
      v162 = v17;
      if (v158)
      {
        v162 = decode_swap(v719, v158, v17, v712);
        v158 = v717;
        unsigned int v24 = v724;
        uint64_t v12 = a1;
      }
      int v163 = 0;
      uint64_t v164 = *((void *)v12 + 4);
      v165 = (char *)v162 + v737;
      int v166 = v162->u8[v737];
      v167 = __dst;
      int v168 = v740;
      v169 = (void *)(v164 + 8 * v745);
      int v170 = 8 - (v105 & 7);
      do
      {
        v171 = (_DWORD *)*v169;
        char v172 = v170 - v160;
        if (v170 - v160 < 0)
        {
          LODWORD(v173) = -v170 >> 3;
          unsigned int v174 = -v170 & 0xFFFFFFF8;
          if (v170 >= -7) {
            uint64_t v173 = 0;
          }
          else {
            uint64_t v173 = v173;
          }
          v165 += v173;
          if (v170 >= -7) {
            unsigned int v174 = 0;
          }
          v170 += v174;
          do
          {
            int v175 = *++v165;
            v170 += 8;
            int v166 = v175 | (v166 << 8);
          }
          while (v170 - v160 < 0);
          char v172 = v170 - v160;
        }
        int v176 = v163 + 1;
        int v177 = (v166 >> v172) & v161;
        if (v163 + 1 >= v23) {
          int v176 = 0;
        }
        int v178 = ((v171[2] + v177 * v171[3]) >> v171[4]) & ~((v171[2] + v177 * v171[3]) >> v171[4] >> 31);
        if (v163 + 1 >= v23) {
          int v179 = v23 * v104 - v103;
        }
        else {
          int v179 = 0;
        }
        if (v163 + 1 >= v23) {
          int v180 = v23;
        }
        else {
          int v180 = 0;
        }
        if (v178 >= 0xFFFF) {
          LOWORD(v178) = -1;
        }
        v167->i16[v163] = v178;
        v170 += v179 - v104;
        v167 = (uint16x4_t *)((char *)v167 + 2 * v180);
        v169 = (void *)(v164 + 8 * v745 + 8 * v176);
        int v163 = v176;
        --v168;
      }
      while (v168);
      int v181 = a2;
      if ((v24 & 0x80000000) == 0 && v758)
      {
        v182 = *(_DWORD **)(v164 + 8 * v706);
        int v183 = v182[2];
        int v184 = v182[3];
        int v185 = v182[4];
        v186 = (char *)&v758[-1] + 6;
        v187 = (char *)v162 + v710;
        int v188 = v162->u8[v710];
        int v189 = 8 - (v106 & 7);
        do
        {
          char v190 = v189 - v160;
          if (v189 - v160 < 0)
          {
            LODWORD(v191) = -v189 >> 3;
            unsigned int v192 = -v189 & 0xFFFFFFF8;
            if (v189 >= -7) {
              uint64_t v191 = 0;
            }
            else {
              uint64_t v191 = v191;
            }
            v187 += v191;
            if (v189 >= -7) {
              unsigned int v192 = 0;
            }
            v189 += v192;
            do
            {
              int v193 = *++v187;
              v189 += 8;
              int v188 = v193 | (v188 << 8);
            }
            while (v189 - v160 < 0);
            char v190 = v189 - v160;
          }
          v189 -= v103;
          int v194 = (v183 + ((v188 >> v190) & v161) * v184) >> v185;
          int v195 = v194 & ~(v194 >> 31);
          if (v195 >= 0xFFFF) {
            LOWORD(v195) = -1;
          }
          *((_WORD *)v186 + 1) = v195;
          v186 += 2;
          --v181;
        }
        while (v181);
        v758 = (uint16x4_t *)((char *)v758 + a11);
      }
      BOOL v17 = (int8x8_t *)((char *)v17 + v732);
      __dst = (uint16x4_t *)((char *)__dst + a7);
      --v15;
    }
    while (v749 != 1);
    if (!v158) {
      return;
    }
    uint64_t v102 = v717;
    goto LABEL_430;
  }
  int v21 = a1[3];
  if (v758 == __dst) {
    LODWORD(v22) = -1;
  }
  else {
    LODWORD(v22) = a1[2];
  }
  uint64_t v82 = a1[4];
  uint64_t v81 = a1[5];
  int v83 = v81 - v82 * v21;
  if (v83 < 0) {
    return;
  }
  if (!a1[6]) {
    int v83 = 0;
  }
  int v84 = v21 - 1;
  int v85 = v83 + v82 * (v21 - 1);
  int v86 = v83 + v82;
  if (v22) {
    int v86 = v83;
  }
  else {
    int v85 = v83;
  }
  if ((int)v22 >= 0) {
    int v83 = v86;
  }
  int v734 = v83;
  BOOL v87 = (int)v22 >= 0 && v22 == 0;
  BOOL v718 = v87;
  if ((int)v22 >= 0)
  {
    int v88 = v85;
  }
  else
  {
    int v84 = a1[3];
    int v88 = 0;
  }
  int v707 = v88;
  int v714 = v84;
  uint64_t v711 = a1[7];
  if (a1[7])
  {
    int v723 = ((int)v81 * (int)a2 + 7) >> 3;
    int v730 = a5;
    int v705 = a1[5];
    if ((int)v82 < 8 || ((v81 | v82) & 7) != 0)
    {
      int v89 = a3;
      int v90 = 0;
    }
    else
    {
      int v89 = a3;
      if ((v84 & 0xFFFFFFFD) == 1 || v84 == 4) {
        int v90 = v84;
      }
      else {
        int v90 = 0;
      }
    }
    BOOL v91 = (int8x8_t *)malloc_type_malloc(v723, 0x705560E0uLL);
    int v739 = v705 >> 3;
    int v704 = v82;
    int v709 = (int)v82 >> 3;
    int v736 = v734 >> 3;
    if ((int)v22 >= 0 && v758 == 0) {
      uint64_t v22 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v22 = v22;
    }
    int v708 = v707 >> 3;
    int v727 = a7;
    uint64_t v93 = a7;
    while (1)
    {
      int v94 = v17;
      if (v91) {
        int v94 = decode_swap(v711, v91, v17, v723);
      }
      switch(v90)
      {
        case 4:
          uint64_t v98 = *a1;
          double v99 = (void *)*((void *)a1 + 4);
          if ((v22 & 0x80000000) != 0)
          {
            decode_byte_8bpc_4(a2, 1, v739, v709, (uint64_t)v94, v730, __dst, v727, v98, v99, v736);
            goto LABEL_130;
          }
          v97 = v758;
          decode_byte_8bpc_4a(a2, 1, v739, v709, (uint64_t)v94, v730, __dst, v727, v758, a11, v98, (uint64_t)v99, v736, v708);
          break;
        case 3:
          uint64_t v100 = *a1;
          v101 = (void *)*((void *)a1 + 4);
          if ((v22 & 0x80000000) != 0)
          {
            decode_byte_8bpc_3(a2, 1, v739, v709, (uint64_t)v94, v730, __dst, v727, v100, v101, v736);
            goto LABEL_130;
          }
          v97 = v758;
          decode_byte_8bpc_3a(a2, 1, v739, v709, (uint64_t)v94, v730, __dst, v727, v758, a11, v100, (uint64_t)v101, v736, v708);
          break;
        case 1:
          uint64_t v95 = *a1;
          uint64_t v96 = (void *)*((void *)a1 + 4);
          if ((v22 & 0x80000000) != 0)
          {
            decode_byte_8bpc_1(a2, 1, v739, (uint64_t)v94, v730, __dst, v727, v95, v96, v736);
LABEL_130:
            v97 = v758;
            break;
          }
          v97 = v758;
          decode_byte_8bpc_1a(a2, 1, v739, (uint64_t)v94, v730, __dst, v727, v758, a11, v95, (uint64_t)v96, v736, v708);
          break;
        default:
          decode_byte_nbpc_N(a2, v704, v705, (uint64_t)v94, v734, (uint64_t)__dst, v714, (void *)(*((void *)a1 + 4) + 8 * v718), v714);
          v97 = v758;
          if ((v22 & 0x80000000) == 0) {
            decode_byte_nbpc_1(a2, v704, v705, (uint64_t)v94, v707, (uint64_t)v758, *(void *)(*((void *)a1 + 4) + 8 * v22));
          }
          break;
      }
      BOOL v17 = (int8x8_t *)((char *)v17 + v730);
      __dst = (uint16x4_t *)((char *)__dst + v93);
      if ((int)v22 >= 0) {
        v97 = (uint16x4_t *)((char *)v97 + a11);
      }
      v758 = v97;
      if (!--v89)
      {
        if (v91)
        {
          uint64_t v102 = v91;
          goto LABEL_430;
        }
        return;
      }
    }
  }
  if ((v22 & 0x80000000) != 0 && v81 == v82 * v21)
  {
    int v136 = *a1;
    if (*a1 >= 2)
    {
      if (v136 == 2 && (v82 & 7) == 0)
      {
        int v420 = (int)v82 >> 3;
        goto LABEL_532;
      }
    }
    else
    {
      if ((int)v82 <= 15)
      {
        switch((int)v82)
        {
          case 1:
            uint64_t v137 = &decode_byte_1bpc__LUT;
            if (v136 == 1) {
              uint64_t v137 = &unk_185155F0C;
            }
            uint64_t v138 = (char *)__dst + 4;
            do
            {
              unsigned int v139 = v138;
              int v140 = v17;
              int v141 = v21 * a2;
              do
              {
                unsigned int v142 = v140->u8[0];
                int v140 = (int8x8_t *)((char *)v140 + 1);
                int v143 = v137[v142 & 0xF];
                *(v139 - 1) = *(_DWORD *)((char *)v137 + (((unint64_t)v142 >> 2) & 0x3C));
                if (v141 < 5) {
                  break;
                }
                *unsigned int v139 = v143;
                v139 += 2;
                _CF = v141 >= 8;
                v141 -= 8;
              }
              while (v141 != 0 && _CF);
              BOOL v17 = (int8x8_t *)((char *)v17 + a5);
              v138 += a7;
              --v15;
            }
            while (v15);
            break;
          case 2:
            v548 = (unsigned __int16 *)&decode_byte_2bpc__LUT;
            if (v136 == 1) {
              v548 = (unsigned __int16 *)&unk_185155F6C;
            }
            do
            {
              uint64_t v549 = 0;
              int v550 = v21 * a2 + 4;
              do
              {
                __dst->i32[v549] = v548[v17->u8[v549] >> 4] | (v548[v17->i8[v549] & 0xF] << 16);
                ++v549;
                v550 -= 4;
              }
              while (v550 > 4);
              BOOL v17 = (int8x8_t *)((char *)v17 + a5);
              __dst = (uint16x4_t *)((char *)__dst + a7);
              --v15;
            }
            while (v15);
            break;
          case 4:
            v551 = (unsigned __int8 *)&decode_byte_4bpc__LUT;
            if (v136 == 1) {
              v551 = (unsigned __int8 *)&unk_185155F9C;
            }
            do
            {
              uint64_t v552 = 0;
              int v553 = v21 * a2 + 2;
              do
              {
                __dst->i16[v552] = v551[(unint64_t)v17->u8[v552] >> 4] | (v551[v17->i8[v552] & 0xF] << 8);
                ++v552;
                v553 -= 2;
              }
              while (v553 > 2);
              BOOL v17 = (int8x8_t *)((char *)v17 + a5);
              __dst = (uint16x4_t *)((char *)__dst + a7);
              --v15;
            }
            while (v15);
            break;
          case 8:
            decode_byte_8bpc(a2, a3, __src, a5, (char *)__dst, a7, v136, v21, a9, a10);
            break;
          default:
            goto LABEL_441;
        }
        return;
      }
      if (v82 == 16)
      {
        decode_byte_16bpc(a2, a3, (uint64_t)__src, a5, (uint64_t)__dst, a7, v136, v21);
        return;
      }
      if (v82 == 24 || v82 == 32)
      {
        int v420 = v82 >> 3;
LABEL_532:
        v436 = (uint64_t *)*((void *)a1 + 4);
        decode_byte_8bpc_N(a2, v15, v420, (uint64_t)__src, a5, (uint64_t)__dst, a7, v436, v21);
        return;
      }
    }
  }
LABEL_441:
  if ((int)v22 >= 0 && v758 == 0) {
    uint64_t v359 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v359 = v22;
  }
  if ((int)v82 >= 8 && ((v81 | v82) & 7) == 0)
  {
    switch(v84)
    {
      case 4:
        int v538 = (int)v81 >> 3;
        unsigned int v539 = v82 >> 3;
        uint64_t v540 = *a1;
        v541 = (void *)*((void *)a1 + 4);
        int v542 = v734 >> 3;
        if ((v359 & 0x80000000) != 0) {
          decode_byte_8bpc_4(a2, v15, v538, v539, (uint64_t)v17, a5, __dst, a7, v540, v541, v542);
        }
        else {
          decode_byte_8bpc_4a(a2, v15, v538, v539, (uint64_t)v17, a5, __dst, a7, v758, a11, v540, (uint64_t)v541, v542, v707 >> 3);
        }
        return;
      case 3:
        int v543 = (int)v81 >> 3;
        unsigned int v544 = v82 >> 3;
        uint64_t v545 = *a1;
        v546 = (void *)*((void *)a1 + 4);
        int v547 = v734 >> 3;
        if ((v359 & 0x80000000) != 0) {
          decode_byte_8bpc_3(a2, v15, v543, v544, (uint64_t)v17, a5, __dst, a7, v545, v546, v547);
        }
        else {
          decode_byte_8bpc_3a(a2, v15, v543, v544, (uint64_t)v17, a5, __dst, a7, v758, a11, v545, (uint64_t)v546, v547, v707 >> 3);
        }
        return;
      case 1:
        int v416 = (int)v81 >> 3;
        uint64_t v417 = *a1;
        v418 = (void *)*((void *)a1 + 4);
        int v419 = v734 >> 3;
        if ((v359 & 0x80000000) != 0) {
          decode_byte_8bpc_1(a2, v15, v416, (uint64_t)__src, a5, __dst, a7, v417, v418, v419);
        }
        else {
          decode_byte_8bpc_1a(a2, v15, v416, (uint64_t)__src, a5, __dst, a7, v758, a11, v417, (uint64_t)v418, v419, v707 >> 3);
        }
        return;
    }
  }
  uint64_t v753 = a7;
  uint64_t v756 = a5;
  do
  {
    int v360 = v15;
    uint64_t v361 = v14;
    v362 = v12;
    decode_byte_nbpc_N(v14, v82, v81, (uint64_t)v17, v734, (uint64_t)__dst, v84, (void *)(*((void *)v12 + 4) + 8 * v718), v84);
    uint64_t v363 = v81;
    uint64_t v364 = v82;
    v365 = v758;
    if ((v359 & 0x80000000) == 0) {
      decode_byte_nbpc_1(v361, v364, v363, (uint64_t)v17, v707, (uint64_t)v758, *(void *)(*((void *)v362 + 4) + 8 * v359));
    }
    BOOL v17 = (int8x8_t *)((char *)v17 + v756);
    __dst = (uint16x4_t *)((char *)__dst + v753);
    if ((int)v359 >= 0) {
      v365 = (uint16x4_t *)((char *)v758 + a11);
    }
    v758 = v365;
    --v15;
    uint64_t v14 = v361;
    uint64_t v12 = v362;
    uint64_t v82 = v364;
    uint64_t v81 = v363;
    int v84 = v714;
  }
  while (v360 != 1);
}

int16x4_t *resample_horizontal<unsigned char,int,4,false>(int16x4_t *result, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, int16x4_t a10, uint64_t a11, unsigned int a12, uint64_t a13, uint64_t *a14, int *a15, int a16)
{
  if ((int)a12 >= 1 && a16 >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = *a14;
    unint64_t v19 = *a15;
    uint64_t v20 = v19 >> 2;
    uint64_t v21 = 2 * a2 + 8;
    uint64_t v22 = (char *)result + v21 * a12;
    if (v19 >> 2 >= *(int *)&v22[-v21 + 4] + (uint64_t)*(int *)&v22[-v21]) {
      uint64_t v20 = *(int *)&v22[-v21 + 4] + (uint64_t)*(int *)&v22[-v21];
    }
    BOOL v23 = a2 > 3;
    LODWORD(v24) = (4 * (a2 & 3)) | 0x10;
    if ((a2 & 3) != 0) {
      uint64_t v24 = v24;
    }
    else {
      uint64_t v24 = 32;
    }
    if ((a2 & 3) != 0) {
      BOOL v23 = 0;
    }
    unint64_t v25 = ((v24 - 1) & 0xFFFFFFFFFFFFFFF0) + 16 * ((a2 >> 2) - v23);
    uint64_t v26 = a16;
    BOOL v29 = a2 != (__int16)a2 || a12 < 2 || a12 == 1;
    v30.i64[0] = 0x200000002000;
    v30.i64[1] = 0x200000002000;
    v31.i64[0] = 0xFF000000FFLL;
    v31.i64[1] = 0xFF000000FFLL;
    do
    {
      int v32 = *(int32x4_t **)(a13 + 8 * v17);
      unint64_t v33 = 0;
      if (v29)
      {
        int v34 = result;
      }
      else
      {
        int v34 = result;
        do
        {
          int v62 = (uint8x16_t *)(v18 + 4 * v34->i32[0]);
          v63 = (uint8x16_t *)((char *)v62 + v25);
          if ((unint64_t)v62->u64 + v25 > 4 * v20 + v18) {
            break;
          }
          if (v62 >= v63)
          {
            int32x4_t v67 = 0uLL;
            int32x4_t v68 = 0uLL;
            int32x4_t v69 = 0uLL;
            int32x4_t v70 = 0uLL;
          }
          else
          {
            unsigned int v64 = v34 + 1;
            int v65 = v34->i32[1];
            unint64_t v66 = (unint64_t)&v63[-1];
            int32x4_t v67 = 0uLL;
            int32x4_t v68 = 0uLL;
            int32x4_t v69 = 0uLL;
            int32x4_t v70 = 0uLL;
            while ((unint64_t)v62 < v66)
            {
              double v71 = *(double *)v64++;
              *(double *)&a10 = v71;
              uint8x16_t v72 = *v62++;
              int16x8_t v73 = (int16x8_t)vmovl_high_u8(v72);
              int16x8_t v16 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v72.i8);
              int32x4_t v67 = vmlal_lane_s16(v67, *(int16x4_t *)v16.i8, a10, 0);
              int32x4_t v68 = vmlal_high_lane_s16(v68, v16, a10, 1);
              int32x4_t v69 = vmlal_lane_s16(v69, *(int16x4_t *)v73.i8, a10, 2);
              int32x4_t v70 = vmlal_high_lane_s16(v70, v73, a10, 3);
              v65 -= 4;
            }
            if (v65 >= 1)
            {
              a10 = *v64;
              int16x8_t v74 = (int16x8_t)vmovl_high_u8(*v62);
              int16x8_t v16 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v62->i8);
              int32x4_t v67 = vmlal_lane_s16(v67, *(int16x4_t *)v16.i8, *v64, 0);
              int32x4_t v68 = vmlal_high_lane_s16(v68, v16, *v64, 1);
              int32x4_t v69 = vmlal_lane_s16(v69, *(int16x4_t *)v74.i8, *v64, 2);
              int32x4_t v70 = vmlal_high_lane_s16(v70, v74, *v64, 3);
            }
          }
          *v32++ = vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(vaddq_s32(vaddq_s32(v68, v70), vaddq_s32(v67, v69)), v30), 0xEuLL), v31), (int32x4_t)0);
          ++v33;
          int v34 = (int16x4_t *)((char *)v34 + v21);
          if (a12 < 2) {
            break;
          }
        }
        while ((unint64_t)a12 - 1 > v33);
      }
      if (v33 < a12)
      {
        do
        {
          int v35 = v34->i32[1];
          uint64_t v36 = v34->i32[0];
          if ((int)v36 >= (int)v20) {
            __int32 v37 = v20;
          }
          else {
            __int32 v37 = v34->i32[0];
          }
          int v38 = v20 - v37;
          if (v35 >= v38) {
            int v35 = v38;
          }
          if (v35 < 1)
          {
            int32x4_t v43 = 0uLL;
            int32x4_t v44 = 0uLL;
            int32x4_t v45 = 0uLL;
            int32x4_t v46 = 0uLL;
          }
          else
          {
            int v39 = (uint8x16_t *)(v18 + 4 * v36);
            unint64_t v40 = (unint64_t)&v39[-1] + 4 * v35;
            uint64_t v41 = (__int16 *)&v34[1];
            if ((unint64_t)v39 >= v40)
            {
              int32x4_t v43 = 0uLL;
              int32x4_t v44 = 0uLL;
              int32x4_t v45 = 0uLL;
              int32x4_t v46 = 0uLL;
              goto LABEL_51;
            }
            uint64_t v42 = v35;
            int32x4_t v43 = 0uLL;
            int32x4_t v44 = 0uLL;
            int32x4_t v45 = 0uLL;
            int32x4_t v46 = 0uLL;
            do
            {
              unint64_t v47 = v22 - (char *)v41;
              if ((unint64_t)(v22 - (char *)v41) >= 8) {
                unint64_t v47 = 8;
              }
              if (v47 < 8)
              {
                if (v42)
                {
                  if (v42 == 1)
                  {
                    a10.i16[0] = *v41;
                  }
                  else
                  {
                    if (v42 == 2)
                    {
                      int16x4_t v50 = 0;
                    }
                    else
                    {
                      if (v35) {
                        __int32 v51 = 0;
                      }
                      else {
                        __int32 v51 = (unsigned __int16)v41[3];
                      }
                      v50.i32[0] = (unsigned __int16)v41[2];
                      v50.i32[1] = v51;
                    }
                    v16.i16[0] = *v41;
                    v16.i16[2] = v41[1];
                    a10 = vuzp1_s16(*(int16x4_t *)v16.i8, v50);
                  }
                }
                else
                {
                  *(double *)&a10 = 0.0;
                }
              }
              else
              {
                a10 = *(int16x4_t *)v41;
              }
              v41 += 4;
              uint8x16_t v48 = *v39++;
              int16x8_t v49 = (int16x8_t)vmovl_high_u8(v48);
              int16x8_t v16 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v48.i8);
              int32x4_t v43 = vmlal_lane_s16(v43, *(int16x4_t *)v16.i8, a10, 0);
              int32x4_t v44 = vmlal_high_lane_s16(v44, v16, a10, 1);
              int32x4_t v45 = vmlal_lane_s16(v45, *(int16x4_t *)v49.i8, a10, 2);
              int32x4_t v46 = vmlal_high_lane_s16(v46, v49, a10, 3);
              v42 -= 4;
            }
            while ((unint64_t)v39 < v40);
            if ((int)v42 >= 1)
            {
              int v35 = v42;
LABEL_51:
              int v52 = v35;
              while (2)
              {
                unint64_t v53 = v22 - (char *)v41;
                if ((unint64_t)(v22 - (char *)v41) >= 8) {
                  unint64_t v53 = 8;
                }
                if (v53 >= 8)
                {
                  a10 = *(int16x4_t *)v41;
                  goto LABEL_56;
                }
                if (v52 == 1)
                {
                  unsigned __int16 v56 = *v41;
                  v41 += 4;
                  uint64_t v57 = 0;
                  a10 = (int16x4_t)v56;
                  v16.i32[0] = v39->i32[0];
                  v16.i64[0] = vmovl_u8(*(uint8x8_t *)v16.i8).u64[0];
                  goto LABEL_63;
                }
                if (v52 == 2)
                {
                  int16x4_t v58 = 0;
                }
                else
                {
                  if (v35) {
                    __int32 v60 = 0;
                  }
                  else {
                    __int32 v60 = (unsigned __int16)v41[3];
                  }
                  v58.i32[0] = (unsigned __int16)v41[2];
                  v58.i32[1] = v60;
                }
                v16.i16[0] = *v41;
                v16.i16[2] = v41[1];
                a10 = vuzp1_s16(*(int16x4_t *)v16.i8, v58);
LABEL_56:
                v41 += 4;
                if (v52 < 4)
                {
                  if ((v52 & 0x3FFFFFFE) != 0)
                  {
                    if (v52 == 2)
                    {
                      uint64_t v59 = 0;
                    }
                    else
                    {
                      v16.i32[0] = v39->i32[2];
                      uint16x8_t v61 = vmovl_u8(*(uint8x8_t *)v16.i8);
                      HIDWORD(v59) = 0;
                      LOBYTE(v59) = v61.i8[0];
                      BYTE1(v59) = v61.i8[2];
                      BYTE2(v59) = v61.i8[4];
                      BYTE3(v59) = v61.i8[6];
                    }
                    v16.i64[0] = v39->i64[0];
                    v16.i64[1] = v59;
                  }
                  else
                  {
                    v16.i32[0] = v39->i32[0];
                    v16.i64[0] = vmovl_u8(*(uint8x8_t *)v16.i8).u64[0];
                    if (v52 == 1)
                    {
                      uint64_t v57 = 0;
                    }
                    else
                    {
                      LOBYTE(v57) = v39->i8[4];
                      BYTE2(v57) = v39->i8[5];
                      BYTE4(v57) = v39->i8[6];
                      BYTE6(v57) = v39->i8[7];
                    }
LABEL_63:
                    v16.i64[1] = 0;
                    v16.i8[1] = v16.i8[2];
                    v16.i8[2] = v16.i8[4];
                    v16.i8[3] = v16.i8[6];
                    v16.i8[4] = v57;
                    v16.i8[5] = BYTE2(v57);
                    v16.i8[6] = BYTE4(v57);
                    v16.i8[7] = BYTE6(v57);
                  }
                }
                else
                {
                  int16x8_t v16 = *(int16x8_t *)v39;
                }
                ++v39;
                int16x8_t v54 = (int16x8_t)vmovl_high_u8((uint8x16_t)v16);
                int16x8_t v16 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v16.i8);
                int32x4_t v43 = vmlal_lane_s16(v43, *(int16x4_t *)v16.i8, a10, 0);
                int32x4_t v44 = vmlal_high_lane_s16(v44, v16, a10, 1);
                int32x4_t v45 = vmlal_lane_s16(v45, *(int16x4_t *)v54.i8, a10, 2);
                int32x4_t v46 = vmlal_high_lane_s16(v46, v54, a10, 3);
                BOOL v55 = __OFSUB__(v52, 4);
                v52 -= 4;
                if ((v52 < 0) ^ v55 | (v52 == 0)) {
                  break;
                }
                continue;
              }
            }
          }
          *v32++ = vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(vaddq_s32(vaddq_s32(v44, v46), vaddq_s32(v43, v45)), v30), 0xEuLL), v31), (int32x4_t)0);
          ++v33;
          int v34 = (int16x4_t *)((char *)v34 + v21);
        }
        while (v33 != a12);
      }
      v18 += v19;
      ++v17;
    }
    while (v17 != v26);
  }
  return result;
}

uint64_t resample_vertical<int,unsigned char,3,(AlphaStyle)0>(uint64_t result, double a2, double a3, double a4, int32x4_t a5, int32x4_t a6, uint64_t a7, uint64_t a8, int a9, int8x8_t **a10, uint64_t a11)
{
  uint64_t v11 = *a10;
  uint64_t v12 = *(int *)(result + 4);
  int v13 = (const __int16 *)(result + 8);
  if (a9 >= 4)
  {
    int v15 = 0;
    unint64_t v16 = 4;
    v17.i64[0] = 0x200000002000;
    v17.i64[1] = 0x200000002000;
    do
    {
      if ((int)v12 >= 2)
      {
        uint64_t v30 = 0;
        unsigned __int32 v18 = 0;
        LODWORD(result) = 0;
        unsigned __int32 v19 = 0;
        unsigned __int32 v20 = 0;
        unsigned __int32 v21 = 0;
        unsigned __int32 v22 = 0;
        unsigned __int32 v23 = 0;
        unsigned __int32 v24 = 0;
        __int32 v25 = 0;
        __int32 v26 = 0;
        __int32 v27 = 0;
        __int32 v28 = 0;
        uint64_t v31 = (3 * v15) & 0xFFFFFFFC;
        BOOL v29 = v13;
        do
        {
          int v32 = (void *)(a11 + 8 * v30);
          unint64_t v33 = (int32x4_t *)(*v32 + 4 * v31);
          int v34 = (int32x4_t *)(v32[1] + 4 * v31);
          unsigned int v35 = *(_DWORD *)v29;
          v29 += 2;
          int16x4_t v36 = vdup_n_s16(v35);
          v37.i64[0] = __PAIR64__(v26, v25);
          v37.i64[1] = __PAIR64__(v28, v27);
          v38.i64[0] = __PAIR64__(result, v18);
          v38.i64[1] = __PAIR64__(v20, v19);
          int16x4_t v39 = vdup_n_s16(HIWORD(v35));
          a5 = vmlal_s16(vmlal_s16(v38, vmovn_s32(*v33), v36), vmovn_s32(*v34), v39);
          v40.i64[0] = __PAIR64__(v22, v21);
          v40.i64[1] = __PAIR64__(v24, v23);
          unsigned __int32 v20 = a5.u32[3];
          unsigned __int32 v19 = a5.u32[2];
          uint64_t result = a5.u32[1];
          a6 = vmlal_s16(vmlal_s16(v40, vmovn_s32(v33[1]), v36), vmovn_s32(v34[1]), v39);
          unsigned __int32 v24 = a6.u32[3];
          unsigned __int32 v18 = a5.i32[0];
          unsigned __int32 v23 = a6.u32[2];
          unsigned __int32 v22 = a6.u32[1];
          int32x4_t v41 = vmlal_s16(vmlal_s16(v37, vmovn_s32(v33[2]), v36), vmovn_s32(v34[2]), v39);
          __int32 v28 = v41.i32[3];
          __int32 v27 = v41.i32[2];
          __int32 v26 = v41.i32[1];
          unsigned __int32 v21 = a6.i32[0];
          __int32 v25 = v41.i32[0];
          uint64_t v42 = v30 + 4;
          v30 += 2;
        }
        while (v42 <= v12);
      }
      else
      {
        unsigned __int32 v18 = 0;
        uint64_t result = 0;
        unsigned __int32 v19 = 0;
        unsigned __int32 v20 = 0;
        unsigned __int32 v21 = 0;
        unsigned __int32 v22 = 0;
        unsigned __int32 v23 = 0;
        unsigned __int32 v24 = 0;
        __int32 v25 = 0;
        __int32 v26 = 0;
        __int32 v27 = 0;
        __int32 v28 = 0;
        BOOL v29 = v13;
      }
      if (v12)
      {
        int32x4_t v43 = (int32x4_t *)(*(void *)(a11 + 8 * ((int)v12 - 1)) + 4 * ((3 * v15) & 0xFFFFFFFC));
        *(int16x4_t *)a5.i8 = vld1_dup_s16(v29);
        v44.i64[0] = __PAIR64__(result, v18);
        v44.i64[1] = __PAIR64__(v20, v19);
        a6 = vmlal_s16(v44, vmovn_s32(*v43), *(int16x4_t *)a5.i8);
        unsigned __int32 v20 = a6.u32[3];
        unsigned __int32 v19 = a6.u32[2];
        uint64_t result = a6.u32[1];
        v45.i64[0] = __PAIR64__(v22, v21);
        v45.i64[1] = __PAIR64__(v24, v23);
        int32x4_t v46 = vmlal_s16(v45, vmovn_s32(v43[1]), *(int16x4_t *)a5.i8);
        unsigned __int32 v24 = v46.u32[3];
        unsigned __int32 v23 = v46.u32[2];
        unsigned __int32 v22 = v46.u32[1];
        v47.i64[0] = __PAIR64__(v26, v25);
        v47.i64[1] = __PAIR64__(v28, v27);
        unsigned __int32 v18 = a6.i32[0];
        int32x4_t v48 = vmlal_s16(v47, vmovn_s32(v43[2]), *(int16x4_t *)a5.i8);
        __int32 v28 = v48.i32[3];
        unsigned __int32 v21 = v46.i32[0];
        __int32 v27 = v48.i32[2];
        __int32 v26 = v48.i32[1];
        __int32 v25 = v48.i32[0];
      }
      v49.i64[0] = __PAIR64__(v22, v21);
      v49.i64[1] = __PAIR64__(v24, v23);
      v50.i64[0] = __PAIR64__(result, v18);
      v15 += 4;
      v50.i64[1] = __PAIR64__(v20, v19);
      int16x8_t v51 = vqmovn_high_s32(vqmovn_s32(vshrq_n_s32(vaddq_s32(v50, v17), 0xEuLL)), vshrq_n_s32(vaddq_s32(v49, v17), 0xEuLL));
      v49.i64[0] = __PAIR64__(v26, v25);
      v49.i64[1] = __PAIR64__(v28, v27);
      int16x8_t v52 = (int16x8_t)vshrq_n_s32(vaddq_s32(v49, v17), 0xEuLL);
      *(int16x4_t *)v52.i8 = vqmovn_s32((int32x4_t)v52);
      *uint64_t v11 = vqmovun_s16(v51);
      v11[1].i32[0] = vqmovun_high_s16(*(int8x8_t *)&v52, v52).i32[2];
      uint64_t v11 = (int8x8_t *)((char *)v11 + 12);
      v16 += 4;
    }
    while (v16 <= a9);
    int v14 = a9 & 0x7FFFFFFC;
  }
  else
  {
    int v14 = 0;
  }
  if (v14 < a9)
  {
    v53.i64[0] = 0x200000002000;
    v53.i64[1] = 0x200000002000;
    do
    {
      int32x4_t v54 = 0uLL;
      BOOL v55 = v13;
      if ((int)v12 >= 2)
      {
        uint64_t v56 = 0;
        uint64_t v57 = (3 * v14);
        BOOL v55 = v13;
        do
        {
          int16x4_t v58 = (void *)(a11 + 8 * v56);
          uint64_t v59 = *v58 + 4 * v57;
          v60.i64[0] = *(void *)v59;
          a5.i32[0] = *(_DWORD *)(v59 + 8);
          v60.i64[1] = a5.i64[0];
          uint64_t v61 = v58[1] + 4 * v57;
          uint64_t v62 = *(void *)v61;
          a6.i32[0] = *(_DWORD *)(v61 + 8);
          a5.i64[1] = a6.i64[0];
          unsigned int v63 = *(_DWORD *)v55;
          v55 += 2;
          *(int16x4_t *)a6.i8 = vdup_n_s16(v63);
          *(int16x4_t *)a5.i8 = vmovn_s32(a5);
          int32x4_t v54 = vmlal_s16(vmlal_s16(v54, vmovn_s32(v60), *(int16x4_t *)a6.i8), *(int16x4_t *)a5.i8, vdup_n_s16(HIWORD(v63)));
          uint64_t v64 = v56 + 4;
          v56 += 2;
        }
        while (v64 <= v12);
      }
      if (v12)
      {
        uint64_t v65 = *(void *)(a11 + 8 * ((int)v12 - 1)) + 4 * (3 * v14);
        v66.i64[0] = *(void *)v65;
        a5.i32[0] = *(_DWORD *)(v65 + 8);
        v66.i64[1] = a5.i64[0];
        *(int16x4_t *)a5.i8 = vld1_dup_s16(v55);
        int32x4_t v54 = vmlal_s16(v54, vmovn_s32(v66), *(int16x4_t *)a5.i8);
      }
      int16x8_t v67 = (int16x8_t)vshrq_n_s32(vaddq_s32(v54, v53), 0xEuLL);
      *(int16x4_t *)v67.i8 = vqmovn_s32((int32x4_t)v67);
      *(int8x8_t *)v67.i8 = vqmovun_s16(v67);
      v11->i16[0] = v67.i16[0];
      v11->i8[2] = v67.i8[2];
      uint64_t v11 = (int8x8_t *)((char *)v11 + 3);
      ++v14;
    }
    while (v14 < a9);
  }
  return result;
}

uint64_t decode_byte_8bpc_1a(uint64_t result, int a2, int a3, uint64_t a4, int a5, unsigned char *a6, int a7, unsigned char *a8, int a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  uint64_t v13 = a5 - (uint64_t)(a3 * (int)result);
  uint64_t v14 = a7 - (uint64_t)(int)result;
  uint64_t v15 = a9 - (uint64_t)(int)result;
  if (a10)
  {
    if (a10 == 2)
    {
      uint64_t v21 = *(void *)(a11 + 8 * (a12 > a13)) + 20;
      uint64_t v22 = *(void *)(a11 + 8 * (a13 > a12)) + 20;
      uint64_t v23 = a3;
      int v24 = result + 1;
      do
      {
        int v25 = v24;
        do
        {
          uint64_t result = *(unsigned __int8 *)(v22 + *(unsigned __int8 *)(a4 + a13));
          char v26 = *(unsigned char *)(v21 + *(unsigned __int8 *)(a4 + a12));
          *a8++ = result;
          *a6++ = v26;
          a4 += v23;
          --v25;
        }
        while (v25 > 1);
        a4 += (int)v13;
        a6 += (int)v14;
        a8 += (int)v15;
        BOOL v18 = __OFSUB__(a2--, 1);
      }
      while (!((a2 < 0) ^ v18 | (a2 == 0)));
    }
    else if (a10 == 1)
    {
      do
      {
        int v16 = result + 1;
        do
        {
          char v17 = *(unsigned char *)(a4 + a12);
          *a8++ = ~*(unsigned char *)(a4 + a13);
          *a6++ = ~v17;
          a4 += a3;
          --v16;
        }
        while (v16 > 1);
        a4 += (int)v13;
        a6 += v14;
        a8 += v15;
        BOOL v18 = __OFSUB__(a2--, 1);
      }
      while (!((a2 < 0) ^ v18 | (a2 == 0)));
    }
  }
  else
  {
    do
    {
      int v19 = result + 1;
      do
      {
        char v20 = *(unsigned char *)(a4 + a12);
        *a8++ = *(unsigned char *)(a4 + a13);
        *a6++ = v20;
        a4 += a3;
        --v19;
      }
      while (v19 > 1);
      a4 += v13;
      a6 += (int)v14;
      a8 += (int)v15;
      BOOL v18 = __OFSUB__(a2--, 1);
    }
    while (!((a2 < 0) ^ v18 | (a2 == 0)));
  }
  return result;
}

int *resample_horizontal<unsigned char,int,1,true>(int *result, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if ((int)a4 >= 1 && a8 >= 1)
  {
    uint64_t v12 = 0;
    uint64_t v13 = *a6;
    uint64_t v14 = a6[1];
    unint64_t v15 = *a7;
    unint64_t v16 = a7[1];
    if (v15 >= v16) {
      unint64_t v17 = a7[1];
    }
    else {
      unint64_t v17 = *a7;
    }
    unint64_t v18 = a4;
    uint64_t v19 = 2 * a2;
    uint64_t v20 = v19 + 8;
    uint64_t v21 = (char *)result + (v19 + 8) * a4;
    if (v17 >= *(int *)&v21[-v19 - 4] + (uint64_t)*(int *)&v21[-v19 - 8]) {
      unint64_t v17 = *(int *)&v21[-v19 - 4] + (uint64_t)*(int *)&v21[-v19 - 8];
    }
    if (a2 <= 3) {
      unint64_t v22 = (2 * a2 + 23) / (2 * a2 + 8);
    }
    else {
      unint64_t v22 = 1;
    }
    unint64_t v23 = a4 - v22;
    int v24 = a2 > 7;
    unsigned int v25 = a2 & 7;
    if ((a2 & 7) != 0) {
      int v24 = 0;
    }
    else {
      unsigned int v25 = 8;
    }
    uint16x8_t v26 = (uint16x8_t)vdupq_n_s16(v25);
    unint64_t v27 = ((a2 + 8 * (v24 << 31 >> 31)) & 0xFFFFFFF8) + (unint64_t)(((_BYTE)v25 + 7) & 0x18);
    if (a2 >= 8) {
      unsigned int v28 = 8;
    }
    else {
      unsigned int v28 = a2;
    }
    int8x16_t v29 = (int8x16_t)vcgtq_u16((uint16x8_t)vdupq_n_s16(v28), (uint16x8_t)xmmword_1850CD7D0);
    uint64_t v30 = a8;
    BOOL v32 = a2 == (__int16)a2 && v18 > v22;
    if (v23 <= 1) {
      uint64_t v33 = 1;
    }
    else {
      uint64_t v33 = v18 - v22;
    }
    int8x16_t v34 = (int8x16_t)vcgtq_u16(v26, (uint16x8_t)xmmword_1850CD7D0);
    do
    {
      unsigned int v35 = *(int32x2_t **)(a5 + 8 * v12);
      unint64_t v36 = 0;
      if (v32)
      {
        int32x4_t v37 = result;
        while (1)
        {
          uint64_t v38 = *v37;
          int16x4_t v39 = (uint8x8_t *)(v13 + v38);
          unint64_t v40 = v27 + v13 + v38;
          if (v40 > v17 + v13) {
            break;
          }
          if ((unint64_t)v39 >= v40)
          {
            int32x4_t v45 = 0uLL;
            int32x4_t v46 = 0uLL;
            int32x4_t v47 = 0uLL;
            int32x4_t v48 = 0uLL;
          }
          else
          {
            int32x4_t v41 = (int8x16_t *)(v37 + 2);
            int v42 = v37[1];
            int32x4_t v43 = (uint8x8_t *)(v14 + v38);
            unint64_t v44 = v40 - 8;
            int32x4_t v45 = 0uLL;
            if ((unint64_t)v39 < v44)
            {
              int32x4_t v47 = 0uLL;
              int32x4_t v48 = 0uLL;
              int32x4_t v46 = 0uLL;
              do
              {
                int8x16_t v52 = *v41++;
                int16x8_t v8 = (int16x8_t)vandq_s8(v52, v29);
                *(uint8x8_t *)v52.i8 = *v39++;
                int16x8_t v53 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v52.i8);
                int32x4_t v48 = vmlal_high_s16(v48, v53, v8);
                *(uint8x8_t *)v52.i8 = *v43++;
                int16x4_t v10 = *(int16x4_t *)v52.i8;
                int32x4_t v47 = vmlal_s16(v47, *(int16x4_t *)v53.i8, *(int16x4_t *)v8.i8);
                int16x8_t v9 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v52.i8);
                int32x4_t v46 = vmlal_high_s16(v46, v9, v8);
                int32x4_t v45 = vmlal_s16(v45, *(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8);
                v42 -= 8;
              }
              while ((unint64_t)v39 < v44);
            }
            else
            {
              int32x4_t v46 = 0uLL;
              int32x4_t v47 = 0uLL;
              int32x4_t v48 = 0uLL;
            }
            if (v42 >= 1)
            {
              int16x8_t v8 = (int16x8_t)vandq_s8(*v41, v34);
              int16x8_t v49 = (int16x8_t)vmovl_u8(*v39);
              int32x4_t v48 = vmlal_high_s16(v48, v49, v8);
              int32x4_t v47 = vmlal_s16(v47, *(int16x4_t *)v49.i8, *(int16x4_t *)v8.i8);
              int16x8_t v9 = (int16x8_t)vmovl_u8(*v43);
              int32x4_t v46 = vmlal_high_s16(v46, v9, v8);
              int32x4_t v45 = vmlal_s16(v45, *(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8);
            }
          }
          int32x2_t v50 = (int32x2_t)vaddvq_s32(vaddq_s32(v47, v48));
          v50.i32[0] = (v50.i32[0] + 0x2000) >> 14;
          int32x2_t v51 = (int32x2_t)vaddvq_s32(vaddq_s32(v45, v46));
          v51.i32[0] = (v51.i32[0] + 0x2000) >> 14;
          *v35++ = vzip1_s32(vmax_s32(vmin_s32(v50, (int32x2_t)0xFF000000FFLL), 0), vmax_s32(vmin_s32(v51, (int32x2_t)0xFF000000FFLL), 0));
          ++v36;
          int32x4_t v37 = (int *)((char *)v37 + v20);
          if (v36 == v33)
          {
            unint64_t v36 = v33;
            break;
          }
        }
      }
      else
      {
        int32x4_t v37 = result;
      }
      if (v36 < v18)
      {
        do
        {
          uint64_t v54 = *v37;
          if ((int)v54 >= (int)v17) {
            int v55 = v17;
          }
          else {
            int v55 = *v37;
          }
          int v56 = v17 - v55;
          if (v37[1] >= v56) {
            int v57 = v56;
          }
          else {
            int v57 = v37[1];
          }
          if (v57 < 1)
          {
            int32x4_t v62 = 0uLL;
            int32x4_t v66 = 0uLL;
            int32x4_t v64 = 0uLL;
            int32x4_t v65 = 0uLL;
          }
          else
          {
            int16x4_t v58 = (uint8x8_t *)(v13 + v54);
            unint64_t v59 = v13 + v54 + v57 - 16;
            int32x4_t v60 = (int16x4_t *)(v14 + v54);
            uint64_t v61 = (int8x16_t *)(v37 + 2);
            int32x4_t v62 = 0uLL;
            if ((unint64_t)v58 >= v59)
            {
              int32x4_t v66 = 0uLL;
              int32x4_t v64 = 0uLL;
              int32x4_t v65 = 0uLL;
              LODWORD(v63) = v57;
LABEL_82:
              int v74 = v63 << 16;
              while (2)
              {
                unint64_t v75 = v21 - (char *)v61;
                if ((unint64_t)(v21 - (char *)v61) >= 0x10) {
                  unint64_t v75 = 16;
                }
                if (v75 < 0x10)
                {
                  if (v63 >= 4)
                  {
                    if (v63 == 4)
                    {
                      v9.i64[0] = 0;
                    }
                    else if (v63 == 5)
                    {
                      v9.i16[0] = v61->i16[4];
                    }
                    else
                    {
                      if (v63 == 6)
                      {
                        int16x4_t v85 = 0;
                      }
                      else
                      {
                        if (v63) {
                          __int32 v90 = 0;
                        }
                        else {
                          __int32 v90 = v61->u16[7];
                        }
                        v85.i32[0] = v61->u16[6];
                        v85.i32[1] = v90;
                      }
                      v9.i16[0] = v61->i16[4];
                      v9.i16[2] = v61->i16[5];
                      *(int16x4_t *)v9.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v85);
                    }
                    v8.i64[0] = v61->i64[0];
                    v8.i64[1] = v9.i64[0];
                    goto LABEL_89;
                  }
                  if (v63 == 1)
                  {
                    v8.i16[0] = v61->i16[0];
                  }
                  else
                  {
                    if (v63 == 2) {
                      int16x4_t v83 = 0;
                    }
                    else {
                      int16x4_t v83 = (int16x4_t)v61->u16[2];
                    }
                    v9.i16[0] = v61->i16[0];
                    v9.i16[2] = v61->i16[1];
                    *(int16x4_t *)v8.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v83);
                  }
                  v8.i64[1] = 0;
                  ++v61;
                }
                else
                {
                  unsigned int v76 = v74 >> 16;
                  if (v74 >> 16 >= 8) {
                    unsigned int v76 = 8;
                  }
                  int16x8_t v8 = (int16x8_t)vandq_s8(*v61, (int8x16_t)vcgtq_s16(vdupq_n_s16(v76), (int16x8_t)xmmword_1850CD7D0));
LABEL_89:
                  ++v61;
                  if (v63 >= 8)
                  {
                    uint8x8_t v77 = *v58;
                    int v78 = 1;
                    goto LABEL_91;
                  }
                  if (v63 >= 4)
                  {
                    if (v63 == 4)
                    {
                      int8x8_t v82 = 0;
                    }
                    else if (v63 == 5)
                    {
                      int8x8_t v82 = (int8x8_t)v58->u8[4];
                    }
                    else
                    {
                      if (v63 == 6) {
                        int16x4_t v89 = 0;
                      }
                      else {
                        int16x4_t v89 = (int16x4_t)v58->u8[6];
                      }
                      v10.i8[0] = v58->i8[4];
                      v10.i8[4] = v58->i8[5];
                      int8x8_t v82 = (int8x8_t)vuzp1_s16(v10, v89);
                    }
                    int v78 = 0;
                    v10.i32[0] = v58->i32[0];
                    uint8x8_t v77 = (uint8x8_t)vuzp1_s8((int8x8_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v10), v82);
                    goto LABEL_91;
                  }
                }
                if (v63 == 1)
                {
                  int16x4_t v87 = (int16x4_t)v58->u8[0];
                }
                else
                {
                  if (v63 == 2) {
                    int16x4_t v88 = 0;
                  }
                  else {
                    int16x4_t v88 = (int16x4_t)v58->u8[2];
                  }
                  v10.i8[0] = v58->i8[0];
                  v10.i8[4] = v58->i8[1];
                  int16x4_t v87 = vuzp1_s16(v10, v88);
                }
                int v78 = 0;
                v77.i32[1] = 0;
                v77.i8[0] = v87.i8[0];
                v77.i8[1] = v87.i8[2];
                v77.i8[2] = v87.i8[4];
                v77.i8[3] = v87.i8[6];
LABEL_91:
                if (v78)
                {
                  int16x4_t v10 = *v60;
                }
                else if (v63 < 4)
                {
                  if (v63 == 1)
                  {
                    int16x4_t v11 = (int16x4_t)v60->u8[0];
                  }
                  else
                  {
                    if (v63 == 2) {
                      int16x4_t v84 = 0;
                    }
                    else {
                      int16x4_t v84 = (int16x4_t)v60->u8[2];
                    }
                    v11.i8[0] = v60->i8[0];
                    v11.i8[4] = v60->i8[1];
                    int16x4_t v11 = vuzp1_s16(v11, v84);
                  }
                  v10.i32[1] = 0;
                  v10.i8[0] = v11.i8[0];
                  v10.i8[1] = v11.i8[2];
                  v10.i8[2] = v11.i8[4];
                  v10.i8[3] = v11.i8[6];
                }
                else
                {
                  if (v63 == 4)
                  {
                    int8x8_t v81 = 0;
                  }
                  else if (v63 == 5)
                  {
                    int8x8_t v81 = (int8x8_t)v60->u8[4];
                  }
                  else
                  {
                    if (v63 == 6)
                    {
                      int16x4_t v86 = 0;
                    }
                    else
                    {
                      if (v63) {
                        __int32 v91 = 0;
                      }
                      else {
                        __int32 v91 = v60->u8[7];
                      }
                      v86.i32[0] = v60->u8[6];
                      v86.i32[1] = v91;
                    }
                    v11.i8[0] = v60->i8[4];
                    v11.i8[4] = v60->i8[5];
                    int8x8_t v81 = (int8x8_t)vuzp1_s16(v11, v86);
                  }
                  v11.i32[0] = v60->i32[0];
                  int16x4_t v11 = (int16x4_t)vmovl_u8((uint8x8_t)v11).u64[0];
                  int16x4_t v10 = (int16x4_t)vuzp1_s8((int8x8_t)v11, v81);
                }
                ++v58;
                int16x8_t v79 = (int16x8_t)vmovl_u8(v77);
                int32x4_t v65 = vmlal_high_s16(v65, v79, v8);
                int32x4_t v64 = vmlal_s16(v64, *(int16x4_t *)v79.i8, *(int16x4_t *)v8.i8);
                ++v60;
                int16x8_t v9 = (int16x8_t)vmovl_u8((uint8x8_t)v10);
                int32x4_t v66 = vmlal_high_s16(v66, v9, v8);
                int32x4_t v62 = vmlal_s16(v62, *(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8);
                v74 -= 0x80000;
                BOOL v80 = __OFSUB__(v63, 8);
                LODWORD(v63) = v63 - 8;
                if (((int)v63 < 0) ^ v80 | (v63 == 0)) {
                  goto LABEL_153;
                }
                continue;
              }
            }
            uint64_t v63 = v57;
            int32x4_t v64 = 0uLL;
            int32x4_t v65 = 0uLL;
            int32x4_t v66 = 0uLL;
            do
            {
              unint64_t v67 = v21 - (char *)v61;
              if ((unint64_t)(v21 - (char *)v61) >= 0x10) {
                unint64_t v67 = 16;
              }
              if (v67 < 0x10)
              {
                if (v63)
                {
                  if (v63 < 4)
                  {
                    if (v63 == 1)
                    {
                      v8.i16[0] = v61->i16[0];
                    }
                    else
                    {
                      if (v63 == 2) {
                        int16x4_t v71 = 0;
                      }
                      else {
                        int16x4_t v71 = (int16x4_t)v61->u16[2];
                      }
                      v9.i16[0] = v61->i16[0];
                      v9.i16[2] = v61->i16[1];
                      *(int16x4_t *)v8.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v71);
                    }
                    v8.i64[1] = 0;
                  }
                  else
                  {
                    if (v63 == 4)
                    {
                      v9.i64[0] = 0;
                    }
                    else if (v63 == 5)
                    {
                      v9.i16[0] = v61->i16[4];
                    }
                    else
                    {
                      if (v63 == 6)
                      {
                        int16x4_t v72 = 0;
                      }
                      else
                      {
                        if (v57) {
                          __int32 v73 = 0;
                        }
                        else {
                          __int32 v73 = v61->u16[7];
                        }
                        v72.i32[0] = v61->u16[6];
                        v72.i32[1] = v73;
                      }
                      v9.i16[0] = v61->i16[4];
                      v9.i16[2] = v61->i16[5];
                      *(int16x4_t *)v9.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v72);
                    }
                    v8.i64[0] = v61->i64[0];
                    v8.i64[1] = v9.i64[0];
                  }
                }
                else
                {
                  int16x8_t v8 = 0uLL;
                }
              }
              else
              {
                int16x8_t v8 = (int16x8_t)vandq_s8(*v61, v29);
              }
              ++v61;
              uint8x8_t v68 = *v58++;
              int16x8_t v69 = (int16x8_t)vmovl_u8(v68);
              int32x4_t v65 = vmlal_high_s16(v65, v69, v8);
              uint8x8_t v70 = (uint8x8_t)*v60++;
              int16x4_t v10 = (int16x4_t)v70;
              int32x4_t v64 = vmlal_s16(v64, *(int16x4_t *)v69.i8, *(int16x4_t *)v8.i8);
              int16x8_t v9 = (int16x8_t)vmovl_u8(v70);
              int32x4_t v66 = vmlal_high_s16(v66, v9, v8);
              int32x4_t v62 = vmlal_s16(v62, *(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8);
              v63 -= 8;
            }
            while ((unint64_t)v58 < v59);
            if ((int)v63 >= 1) {
              goto LABEL_82;
            }
          }
LABEL_153:
          int32x2_t v92 = (int32x2_t)vaddvq_s32(vaddq_s32(v64, v65));
          v92.i32[0] = (v92.i32[0] + 0x2000) >> 14;
          int32x2_t v93 = (int32x2_t)vaddvq_s32(vaddq_s32(v62, v66));
          v93.i32[0] = (v93.i32[0] + 0x2000) >> 14;
          *v35++ = vzip1_s32(vmax_s32(vmin_s32(v92, (int32x2_t)0xFF000000FFLL), 0), vmax_s32(vmin_s32(v93, (int32x2_t)0xFF000000FFLL), 0));
          ++v36;
          int32x4_t v37 = (int *)((char *)v37 + v20);
        }
        while (v36 != v18);
      }
      v13 += v15;
      v14 += v16;
      ++v12;
    }
    while (v12 != v30);
  }
  return result;
}

uint64_t resample_vertical<int,unsigned char,1,(AlphaStyle)3>(uint64_t result, double a2, double a3, uint8x8_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9)
{
  int16x8_t v9 = *(_DWORD **)a8;
  int16x4_t v10 = *(_DWORD **)(a8 + 8);
  uint64_t v11 = *(int *)(result + 4);
  uint64_t v12 = (const __int16 *)(result + 8);
  if (a7 >= 4)
  {
    uint64_t v14 = 0;
    unint64_t v15 = 4;
    v16.i64[0] = 0x200000002000;
    v16.i64[1] = 0x200000002000;
    do
    {
      int32x4_t v17 = 0uLL;
      int32x4_t v18 = 0uLL;
      uint64_t v19 = v12;
      if ((int)v11 >= 2)
      {
        uint64_t result = 0;
        uint64_t v19 = v12;
        do
        {
          uint64_t v20 = (void *)(a9 + 8 * result);
          uint64_t v21 = (int32x4_t *)(*v20 + 8 * v14);
          unint64_t v22 = (int32x4_t *)(v20[1] + 8 * v14);
          unsigned int v23 = *(_DWORD *)v19;
          v19 += 2;
          int16x4_t v24 = vdup_n_s16(v23);
          int16x4_t v25 = vdup_n_s16(HIWORD(v23));
          int32x4_t v18 = vmlal_s16(vmlal_s16(v18, vmovn_s32(v21[1]), v24), vmovn_s32(v22[1]), v25);
          int32x4_t v17 = vmlal_s16(vmlal_s16(v17, vmovn_s32(*v21), v24), vmovn_s32(*v22), v25);
          uint64_t v26 = result + 4;
          result += 2;
        }
        while (v26 <= v11);
      }
      if (v11)
      {
        unint64_t v27 = (int32x4_t *)(*(void *)(a9 + 8 * ((int)v11 - 1)) + 8 * v14);
        int16x4_t v28 = vld1_dup_s16(v19);
        int32x4_t v18 = vmlal_s16(v18, vmovn_s32(v27[1]), v28);
        int32x4_t v17 = vmlal_s16(v17, vmovn_s32(*v27), v28);
      }
      v14 += 4;
      int16x8_t v29 = vqmovn_high_s32(vqmovn_s32(vshrq_n_s32(vaddq_s32(v17, v16), 0xEuLL)), vshrq_n_s32(vaddq_s32(v18, v16), 0xEuLL));
      *(int8x8_t *)v29.i8 = vqmovun_s16(v29);
      a4 = (uint8x8_t)vuzp2_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)v16.i8);
      *v9++ = vmovn_s16(v29).u32[0];
      *v10++ = vmax_u8(a4, (uint8x8_t)vuzp1_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)v16.i8)).u32[0];
      v15 += 4;
    }
    while (v15 <= a7);
    int v13 = a7 & 0x7FFFFFFC;
  }
  else
  {
    int v13 = 0;
  }
  for (; v13 < a7; ++v13)
  {
    if ((int)v11 >= 2)
    {
      uint64_t v32 = 0;
      uint64_t v33 = (2 * v13);
      int32x4_t v30 = 0uLL;
      uint64_t v31 = v12;
      do
      {
        int8x16_t v34 = (void *)(a9 + 8 * v32);
        uint64_t result = 4 * v33;
        unsigned int v35 = *(_DWORD *)v31;
        v31 += 2;
        a4 = (uint8x8_t)vuzp1_s16(*(int16x4_t *)(v34[1] + 4 * v33), (int16x4_t)0x200000002000);
        int32x4_t v30 = vmlal_s16(vmlal_s16(v30, vuzp1_s16(*(int16x4_t *)(*v34 + 4 * v33), (int16x4_t)0x200000002000), vdup_n_s16(v35)), (int16x4_t)a4, vdup_n_s16(HIWORD(v35)));
        uint64_t v36 = v32 + 4;
        v32 += 2;
      }
      while (v36 <= v11);
    }
    else
    {
      int32x4_t v30 = 0uLL;
      uint64_t v31 = v12;
    }
    if (v11)
    {
      a4 = (uint8x8_t)vuzp1_s16(*(int16x4_t *)(*(void *)(a9 + 8 * ((int)v11 - 1)) + 4 * (2 * v13)), (int16x4_t)0x200000002000);
      int16x4_t v37 = vld1_dup_s16(v31);
      int32x4_t v30 = vmlal_s16(v30, (int16x4_t)a4, v37);
    }
    *(int32x2_t *)v30.i8 = vadd_s32(*(int32x2_t *)v30.i8, (int32x2_t)0x200000002000);
    int16x8_t v38 = (int16x8_t)vshrq_n_s32(v30, 0xEuLL);
    *(int16x4_t *)v38.i8 = vqmovn_s32((int32x4_t)v38);
    *(int8x8_t *)v38.i8 = vqmovun_s16(v38);
    __int32 v39 = v38.u16[0];
    v38.i32[0] = v38.u8[1];
    *(unsigned char *)int16x8_t v9 = v39;
    int16x8_t v9 = (_DWORD *)((char *)v9 + 1);
    a4.i32[0] = v39;
    *(unsigned char *)int16x4_t v10 = vmax_u8(*(uint8x8_t *)v38.i8, a4).u8[0];
    int16x4_t v10 = (_DWORD *)((char *)v10 + 1);
  }
  return result;
}

uint64_t decode_byte_8bpc(uint64_t result, int a2, char *__src, int a4, char *__dst, int a6, int a7, int a8, double a9, uint8x8_t a10)
{
  int v13 = a8 * result;
  uint64_t v14 = a6;
  if (a7 == 1)
  {
    while (v13 < 5)
    {
      if (v13 > 0)
      {
        int32x4_t v18 = __src - 1;
        uint64_t v20 = __dst - 1;
        int v19 = a8 * result;
LABEL_8:
        uint64_t v21 = v18 + 1;
        unsigned int v22 = v19 + 1;
        unsigned int v23 = v20 + 1;
        do
        {
          char v24 = *v21++;
          *v23++ = ~v24;
          --v22;
        }
        while (v22 > 1);
      }
      __src += a4;
      __dst += a6;
      if (!--a2) {
        return result;
      }
    }
    uint64_t v15 = 0;
    unsigned int v16 = v13 + 4;
    do
    {
      a10.i32[0] = *(_DWORD *)&__src[v15];
      int16x8_t v17 = (int16x8_t)vmovl_u8(a10);
      *(int8x8_t *)v17.i8 = veor_s8(*(int8x8_t *)v17.i8, (int8x8_t)0xFF00FF00FF00FFLL);
      a10 = (uint8x8_t)vmovn_s16(v17);
      *(_DWORD *)&__dst[v15] = a10.i32[0];
      v15 += 4;
      v16 -= 4;
    }
    while (v16 > 8);
    int32x4_t v18 = &__src[v15 - 1];
    int v19 = v13 - v15;
    uint64_t v20 = &__dst[v15 - 1];
    goto LABEL_8;
  }
  size_t v25 = v13;
  uint64_t v26 = a4;
  do
  {
    uint64_t result = (uint64_t)memcpy(__dst, __src, v25);
    __src += v26;
    __dst += v14;
    --a2;
  }
  while (a2);
  return result;
}

uint64_t img_raw_access(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 112);
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4 == -1)
  {
    uint64_t result = *(void *)(a1 + 184);
    if (result)
    {
      if (v3) {
        return 0;
      }
    }
    else
    {
      uint64_t result = (uint64_t)img_blocks_create(*(void *)(a1 + 144), 0, *(int **)(a1 + 152), 0);
      if (!result) {
        return result;
      }
      *(void *)(a1 + 184) = result;
      *(void *)(a1 + 88) = 0;
      if (v3) {
        return 0;
      }
    }
    return *(void *)(result + 40) == *(void *)(result + 48);
  }
  if (v4) {
    return !v3 && !*(void *)(a1 + 152);
  }
  if (get_image_pointer((void *)a1) && !v3) {
    return 1;
  }
  if (!a2) {
    return 0;
  }
  uint64_t result = 0;
  int v7 = *(_DWORD *)(a1 + 56);
  if (v7 >= *a2 && v7 - *a2 <= 64)
  {
    *a2 = v7;
    return 0;
  }
  return result;
}

int *resample_horizontal<unsigned char,int,3,false>(int *result, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if ((int)a4 >= 1 && a8 >= 1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = *a6;
    unint64_t v13 = *a7;
    unint64_t v14 = v13 / 3;
    uint64_t v15 = 2 * a2;
    uint64_t v16 = v15 + 8;
    int16x8_t v17 = (char *)result + (v15 + 8) * a4;
    if (v13 / 3 >= *(int *)&v17[-v15 - 4] + (uint64_t)*(int *)&v17[-v15 - 8]) {
      unint64_t v14 = *(int *)&v17[-v15 - 4] + (uint64_t)*(int *)&v17[-v15 - 8];
    }
    if (a2 <= 3) {
      unint64_t v18 = (2 * a2 + 23) / (2 * a2 + 8);
    }
    else {
      unint64_t v18 = 1;
    }
    unsigned int v19 = a2 % 5;
    BOOL v20 = a2 > 4;
    if (a2 % 5) {
      BOOL v20 = 0;
    }
    else {
      unsigned int v19 = 5;
    }
    uint64_t v21 = ((3 * v19 + 15) & 0x1FFFFFFF0) + 15 * (a2 / 5 - v20);
    unint64_t v22 = a4 - v18;
    int16x8_t v23 = vdupq_n_s16(v19);
    if (a2 >= 5) {
      unsigned int v24 = 5;
    }
    else {
      unsigned int v24 = a2;
    }
    int8x16_t v25 = (int8x16_t)vcgtq_u16((uint16x8_t)vdupq_n_s16(v24), (uint16x8_t)xmmword_1850CD7D0);
    uint64_t v26 = a8;
    BOOL v27 = a2 == (__int16)a2 && a4 > v18;
    char v28 = !v27;
    if (v22 <= 1) {
      unint64_t v22 = 1;
    }
    v29.i64[0] = 0x200000002000;
    v29.i64[1] = 0x200000002000;
    v30.i64[0] = 0xFF000000FFLL;
    v30.i64[1] = 0xFF000000FFLL;
    int8x16_t v31 = (int8x16_t)vcgtq_s16(v23, (int16x8_t)xmmword_1850CD7D0);
    do
    {
      uint64_t v32 = *(void *)(a5 + 8 * v11);
      unint64_t v33 = 0;
      if (v28)
      {
        int8x16_t v34 = result;
      }
      else
      {
        int8x16_t v34 = result;
        while (1)
        {
          unsigned int v35 = (uint8x16_t *)(v12 + 3 * *v34);
          uint64_t v36 = (uint8x16_t *)((char *)v35 + v21);
          if ((unint64_t)v35->u64 + v21 > 3 * v14 + v12) {
            break;
          }
          if (v35 >= v36)
          {
            int32x4_t v40 = 0uLL;
            int32x4_t v41 = 0uLL;
            int32x4_t v42 = 0uLL;
            int32x4_t v43 = 0uLL;
          }
          else
          {
            int16x4_t v37 = (int8x16_t *)(v34 + 2);
            int v38 = v34[1];
            unint64_t v39 = (unint64_t)&v36[-1];
            int32x4_t v40 = 0uLL;
            int32x4_t v41 = 0uLL;
            int32x4_t v42 = 0uLL;
            int32x4_t v43 = 0uLL;
            while ((unint64_t)v35 < v39)
            {
              int8x16_t v44 = *v37;
              int16x4_t v37 = (int8x16_t *)((char *)v37 + 10);
              int8x16_t v45 = vandq_s8(v44, v25);
              uint8x16_t v46 = *v35;
              unsigned int v35 = (uint8x16_t *)((char *)v35 + 15);
              int16x8_t v10 = (int16x8_t)vmovl_high_u8(v46);
              int16x8_t v9 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v46.i8);
              int16x8_t v47 = (int16x8_t)vqtbl1q_s8(v45, (int8x16_t)xmmword_1850CD7E0);
              int16x8_t v48 = (int16x8_t)vqtbl1q_s8(v45, (int8x16_t)xmmword_1850CD7F0);
              int32x4_t v43 = vmlal_high_s16(v43, v10, v47);
              int32x4_t v41 = vmlal_high_s16(v41, v9, v48);
              int32x4_t v42 = vmlal_s16(v42, *(int16x4_t *)v10.i8, *(int16x4_t *)v47.i8);
              int32x4_t v40 = vmlal_s16(v40, *(int16x4_t *)v9.i8, *(int16x4_t *)v48.i8);
              v38 -= 5;
            }
            if (v38 >= 1)
            {
              int8x16_t v49 = vandq_s8(*v37, v31);
              int16x8_t v10 = (int16x8_t)vmovl_high_u8(*v35);
              int16x8_t v9 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v35->i8);
              int16x8_t v50 = (int16x8_t)vqtbl1q_s8(v49, (int8x16_t)xmmword_1850CD7E0);
              int16x8_t v51 = (int16x8_t)vqtbl1q_s8(v49, (int8x16_t)xmmword_1850CD7F0);
              int32x4_t v43 = vmlal_high_s16(v43, v10, v50);
              int32x4_t v41 = vmlal_high_s16(v41, v9, v51);
              int32x4_t v42 = vmlal_s16(v42, *(int16x4_t *)v10.i8, *(int16x4_t *)v50.i8);
              int32x4_t v40 = vmlal_s16(v40, *(int16x4_t *)v9.i8, *(int16x4_t *)v51.i8);
            }
          }
          int16x8_t v8 = (int16x8_t)vextq_s8((int8x16_t)v42, (int8x16_t)v43, 4uLL);
          int32x4_t v52 = vaddq_s32((int32x4_t)v8, v40);
          int8x16_t v53 = (int8x16_t)vaddq_s32((int32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 4uLL).u64[0], v41);
          int32x4_t v54 = vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(vaddq_s32(v52, (int32x4_t)vextq_s8((int8x16_t)v52, v53, 0xCuLL)), vaddq_s32((int32x4_t)vextq_s8(v53, (int8x16_t)v42, 8uLL), v29)), 0xEuLL), v30), (int32x4_t)0);
          *(void *)uint64_t v32 = v54.i64[0];
          *(_DWORD *)(v32 + 8) = v54.i32[2];
          v32 += 12;
          ++v33;
          int8x16_t v34 = (int *)((char *)v34 + v16);
          if (v33 == v22)
          {
            unint64_t v33 = v22;
            break;
          }
        }
      }
      if (v33 < a4)
      {
        do
        {
          uint64_t v55 = *v34;
          if ((int)v55 >= (int)v14) {
            int v56 = v14;
          }
          else {
            int v56 = *v34;
          }
          int v57 = v14 - v56;
          if (v34[1] >= v57) {
            LODWORD(v58) = v57;
          }
          else {
            LODWORD(v58) = v34[1];
          }
          if ((int)v58 < 1)
          {
            int32x4_t v62 = 0uLL;
            int32x4_t v63 = 0uLL;
            int32x4_t v64 = 0uLL;
            int32x4_t v65 = 0uLL;
          }
          else
          {
            unint64_t v59 = (unsigned __int8 *)(v12 + 3 * v55);
            unint64_t v60 = (unint64_t)&v59[3 * (int)v58 - 16];
            uint64_t v61 = (int8x16_t *)(v34 + 2);
            if ((unint64_t)v59 >= v60)
            {
              int32x4_t v62 = 0uLL;
              int32x4_t v63 = 0uLL;
              int32x4_t v64 = 0uLL;
              int32x4_t v65 = 0uLL;
LABEL_76:
              uint64_t v72 = 0;
              unint64_t v73 = v58;
              uint64_t v74 = 3 * v58;
              int v75 = v58 << 16;
              int v76 = 3 * v58;
              while (2)
              {
                uint64_t v77 = v74 + v72;
                unint64_t v78 = v17 - (char *)v61;
                if ((unint64_t)(v17 - (char *)v61) >= 0x10) {
                  unint64_t v78 = 16;
                }
                if (v78 < 0x10)
                {
                  if (v73 >= 4)
                  {
                    if (v73 == 4)
                    {
                      v9.i64[0] = 0;
                    }
                    else if (v73 == 5)
                    {
                      v9.i16[0] = v61->i16[4];
                    }
                    else
                    {
                      if (v77 == 18)
                      {
                        int16x4_t v92 = 0;
                      }
                      else
                      {
                        if (v73) {
                          __int32 v83 = 0;
                        }
                        else {
                          __int32 v83 = v61->u16[7];
                        }
                        v92.i32[0] = v61->u16[6];
                        v92.i32[1] = v83;
                      }
                      v9.i16[0] = v61->i16[4];
                      v9.i16[2] = v61->i16[5];
                      *(int16x4_t *)v9.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v92);
                    }
                    v8.i64[0] = v61->i64[0];
                    v8.i64[1] = v9.i64[0];
                    goto LABEL_83;
                  }
                  if (v77 == 3)
                  {
                    v8.i16[0] = v61->i16[0];
                  }
                  else
                  {
                    if (v74 + v72 == 6) {
                      int16x4_t v82 = 0;
                    }
                    else {
                      int16x4_t v82 = (int16x4_t)v61->u16[2];
                    }
                    v9.i16[0] = v61->i16[0];
                    v9.i16[2] = v61->i16[1];
                    *(int16x4_t *)v8.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v82);
                  }
                  v8.i64[1] = 0;
                  uint64_t v61 = (int8x16_t *)((char *)v61 + 10);
                }
                else
                {
                  unsigned int v79 = v75 >> 16;
                  if (v75 >> 16 >= 8) {
                    unsigned int v79 = 8;
                  }
                  int16x8_t v9 = *(int16x8_t *)v61;
                  int16x8_t v8 = (int16x8_t)vandq_s8(*v61, (int8x16_t)vcgtq_s16(vdupq_n_s16(v79), (int16x8_t)xmmword_1850CD7D0));
LABEL_83:
                  uint64_t v61 = (int8x16_t *)((char *)v61 + 10);
                  if (v73 >= 6)
                  {
                    uint8x16_t v80 = *(uint8x16_t *)v59;
                    goto LABEL_85;
                  }
                }
                uint64_t v84 = v74 + v72;
                if ((v76 + v72) < 8)
                {
                  if ((v76 + v72) < 4)
                  {
                    if (v84)
                    {
                      if (v84 == 1)
                      {
                        int16x4_t v86 = 0;
                        v9.i64[0] = *v59;
                      }
                      else
                      {
                        v9.i8[0] = *v59;
                        v9.i8[4] = v59[1];
                        int16x4_t v86 = (int16x4_t)v59[2];
                      }
                      int16x4_t v91 = vuzp1_s16(*(int16x4_t *)v9.i8, v86);
                    }
                    else
                    {
                      int16x4_t v91 = 0;
                    }
                    v80.i32[1] = 0;
                    v80.i8[0] = v91.i8[0];
                    v80.i8[1] = v91.i8[2];
                    v80.i8[2] = v91.i8[4];
                    v80.i8[3] = v91.i8[6];
                  }
                  else
                  {
                    if (v84 == 4)
                    {
                      int8x8_t v85 = 0;
                    }
                    else if (v84 == 5)
                    {
                      int8x8_t v85 = (int8x8_t)v59[4];
                    }
                    else
                    {
                      if (v74 + v72 == 6) {
                        int16x4_t v90 = 0;
                      }
                      else {
                        int16x4_t v90 = (int16x4_t)v59[6];
                      }
                      v10.i8[0] = v59[4];
                      v10.i8[4] = v59[5];
                      int8x8_t v85 = (int8x8_t)vuzp1_s16(*(int16x4_t *)v10.i8, v90);
                    }
                    v10.i32[0] = *(_DWORD *)v59;
                    *(int8x8_t *)v80.i8 = vuzp1_s8((int8x8_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v10.i8), v85);
                  }
                  v80.i64[1] = 0;
                }
                else
                {
                  if (v84 == 8)
                  {
                    int8x8_t v87 = 0;
                  }
                  else if ((unint64_t)(v84 - 8) < 4)
                  {
                    if (v77 == 9)
                    {
                      uint64_t v89 = 0;
                      uint64_t v88 = v59[8];
                    }
                    else
                    {
                      LOBYTE(v88) = v59[8];
                      BYTE4(v88) = v59[9];
                      uint64_t v89 = v59[10];
                    }
                    v87.i32[1] = 0;
                    v87.i8[0] = v88;
                    v87.i8[1] = BYTE4(v88);
                    v87.i8[2] = v89;
                    v87.i8[3] = BYTE4(v89);
                  }
                  else
                  {
                    if (v84 == 12)
                    {
                      v9.i64[0] = 0;
                    }
                    else if (v84 == 13)
                    {
                      v9.i64[0] = v59[12];
                    }
                    else
                    {
                      if (v84) {
                        __int16 v93 = 0;
                      }
                      else {
                        __int16 v93 = v59[15];
                      }
                      v9.i8[0] = v59[12];
                      v9.i8[4] = v59[13];
                      v9.i16[1] = v9.i16[2];
                      v9.i16[2] = v59[14];
                      v9.i16[3] = v93;
                    }
                    v10.i32[0] = *((_DWORD *)v59 + 2);
                    int8x8_t v87 = vuzp1_s8((int8x8_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v10.i8), *(int8x8_t *)v9.i8);
                  }
                  v80.i64[0] = *(void *)v59;
                  v80.u64[1] = (unint64_t)v87;
                }
LABEL_85:
                v59 += 15;
                int16x8_t v10 = (int16x8_t)vmovl_high_u8(v80);
                int16x8_t v9 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v80.i8);
                int16x8_t v81 = (int16x8_t)vqtbl1q_s8((int8x16_t)v8, (int8x16_t)xmmword_1850CD7E0);
                int16x8_t v8 = (int16x8_t)vqtbl1q_s8((int8x16_t)v8, (int8x16_t)xmmword_1850CD7F0);
                int32x4_t v63 = vmlal_high_s16(v63, v9, v8);
                int32x4_t v65 = vmlal_high_s16(v65, v10, v81);
                int32x4_t v64 = vmlal_s16(v64, *(int16x4_t *)v10.i8, *(int16x4_t *)v81.i8);
                int32x4_t v62 = vmlal_s16(v62, *(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8);
                v72 -= 15;
                v75 -= 327680;
                BOOL v27 = (uint64_t)v73 <= 5;
                v73 -= 5;
                if (v27) {
                  goto LABEL_145;
                }
                continue;
              }
            }
            uint64_t v58 = (int)v58;
            int32x4_t v62 = 0uLL;
            int32x4_t v63 = 0uLL;
            int32x4_t v64 = 0uLL;
            int32x4_t v65 = 0uLL;
            do
            {
              unint64_t v66 = v17 - (char *)v61;
              if ((unint64_t)(v17 - (char *)v61) >= 0x10) {
                unint64_t v66 = 16;
              }
              if (v66 < 0x10)
              {
                if (v58)
                {
                  if (v58 < 4)
                  {
                    if (v58 == 1)
                    {
                      v8.i16[0] = v61->i16[0];
                    }
                    else
                    {
                      if (v58 == 2) {
                        int16x4_t v69 = 0;
                      }
                      else {
                        int16x4_t v69 = (int16x4_t)v61->u16[2];
                      }
                      v9.i16[0] = v61->i16[0];
                      v9.i16[2] = v61->i16[1];
                      *(int16x4_t *)v8.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v69);
                    }
                    v8.i64[1] = 0;
                  }
                  else
                  {
                    if (v58 == 4)
                    {
                      v9.i64[0] = 0;
                    }
                    else if (v58 == 5)
                    {
                      v9.i16[0] = v61->i16[4];
                    }
                    else
                    {
                      if (v58 == 6)
                      {
                        int16x4_t v70 = 0;
                      }
                      else
                      {
                        if (v58) {
                          __int32 v71 = 0;
                        }
                        else {
                          __int32 v71 = v61->u16[7];
                        }
                        v70.i32[0] = v61->u16[6];
                        v70.i32[1] = v71;
                      }
                      v9.i16[0] = v61->i16[4];
                      v9.i16[2] = v61->i16[5];
                      *(int16x4_t *)v9.i8 = vuzp1_s16(*(int16x4_t *)v9.i8, v70);
                    }
                    v8.i64[0] = v61->i64[0];
                    v8.i64[1] = v9.i64[0];
                  }
                }
                else
                {
                  int16x8_t v8 = 0uLL;
                }
              }
              else
              {
                int16x8_t v8 = (int16x8_t)vandq_s8(*v61, v25);
              }
              uint64_t v61 = (int8x16_t *)((char *)v61 + 10);
              uint8x16_t v67 = *(uint8x16_t *)v59;
              v59 += 15;
              int16x8_t v10 = (int16x8_t)vmovl_high_u8(v67);
              int16x8_t v9 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v67.i8);
              int16x8_t v68 = (int16x8_t)vqtbl1q_s8((int8x16_t)v8, (int8x16_t)xmmword_1850CD7E0);
              int16x8_t v8 = (int16x8_t)vqtbl1q_s8((int8x16_t)v8, (int8x16_t)xmmword_1850CD7F0);
              int32x4_t v65 = vmlal_high_s16(v65, v10, v68);
              int32x4_t v64 = vmlal_s16(v64, *(int16x4_t *)v10.i8, *(int16x4_t *)v68.i8);
              int32x4_t v63 = vmlal_high_s16(v63, v9, v8);
              int32x4_t v62 = vmlal_s16(v62, *(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8);
              v58 -= 5;
            }
            while ((unint64_t)v59 < v60);
            if ((int)v58 >= 1) {
              goto LABEL_76;
            }
          }
LABEL_145:
          int16x8_t v8 = (int16x8_t)vextq_s8((int8x16_t)v64, (int8x16_t)v65, 4uLL);
          int32x4_t v94 = vaddq_s32((int32x4_t)v8, v62);
          int8x16_t v95 = (int8x16_t)vaddq_s32((int32x4_t)vextq_s8((int8x16_t)v65, (int8x16_t)v65, 4uLL).u64[0], v63);
          int32x4_t v96 = vmaxq_s32(vminq_s32(vshrq_n_s32(vaddq_s32(vaddq_s32((int32x4_t)vextq_s8((int8x16_t)v94, v95, 0xCuLL), v94), vaddq_s32((int32x4_t)vextq_s8(v95, (int8x16_t)v64, 8uLL), v29)), 0xEuLL), v30), (int32x4_t)0);
          *(void *)uint64_t v32 = v96.i64[0];
          *(_DWORD *)(v32 + 8) = v96.i32[2];
          v32 += 12;
          ++v33;
          int8x16_t v34 = (int *)((char *)v34 + v16);
        }
        while (v33 != a4);
      }
      v12 += v13;
      ++v11;
    }
    while (v11 != v26);
  }
  return result;
}

uint64_t resample_vertical<int,unsigned char,4,(AlphaStyle)1>(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint8x8_t **a5, uint64_t a6)
{
  uint64_t v6 = *a5;
  uint64_t v7 = *(int *)(result + 4);
  int16x8_t v8 = (const __int16 *)(result + 8);
  if (a4 >= 2)
  {
    int v10 = 0;
    unint64_t v11 = 2;
    v12.i64[0] = 0x200000002000;
    v12.i64[1] = 0x200000002000;
    do
    {
      int32x4_t v13 = 0uLL;
      int32x4_t v14 = 0uLL;
      uint64_t v15 = v8;
      if ((int)v7 >= 2)
      {
        uint64_t v16 = 0;
        uint64_t v17 = (4 * v10) & 0xFFFFFFF8;
        uint64_t v15 = v8;
        do
        {
          unint64_t v18 = (void *)(a6 + 8 * v16);
          unsigned int v19 = (int32x4_t *)(*v18 + 4 * v17);
          BOOL v20 = (int32x4_t *)(v18[1] + 4 * v17);
          unsigned int v21 = *(_DWORD *)v15;
          v15 += 2;
          int16x4_t v22 = vdup_n_s16(v21);
          int16x4_t v23 = vdup_n_s16(HIWORD(v21));
          int32x4_t v14 = vmlal_s16(vmlal_s16(v14, vmovn_s32(v19[1]), v22), vmovn_s32(v20[1]), v23);
          int32x4_t v13 = vmlal_s16(vmlal_s16(v13, vmovn_s32(*v19), v22), vmovn_s32(*v20), v23);
          uint64_t result = v16 + 4;
          v16 += 2;
        }
        while (result <= v7);
      }
      if (v7)
      {
        unsigned int v24 = (int32x4_t *)(*(void *)(a6 + 8 * ((int)v7 - 1)) + 4 * ((4 * v10) & 0xFFFFFFF8));
        int16x4_t v25 = vld1_dup_s16(v15);
        int32x4_t v14 = vmlal_s16(v14, vmovn_s32(v24[1]), v25);
        int32x4_t v13 = vmlal_s16(v13, vmovn_s32(*v24), v25);
      }
      int8x8_t v26 = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vshrq_n_s32(vaddq_s32(v13, v12), 0xEuLL)), vshrq_n_s32(vaddq_s32(v14, v12), 0xEuLL)));
      int8x8_t v27 = (int8x8_t)vmax_u8((uint8x8_t)vuzp1_s8(v26, *(int8x8_t *)v12.i8), (uint8x8_t)vuzp2_s8(v26, *(int8x8_t *)v12.i8));
      v27.i16[0] = vmax_u8((uint8x8_t)vuzp1_s8(v27, *(int8x8_t *)v12.i8), (uint8x8_t)vuzp2_s8(v27, *(int8x8_t *)v12.i8)).u16[0];
      v10 += 2;
      v28.i32[0] = v27.u8[0];
      v28.i32[1] = v27.u8[1];
      *v6++ = vmax_u8((uint8x8_t)v26, (uint8x8_t)vand_s8(v28, (int8x8_t)0xFF000000FFLL));
      v11 += 2;
    }
    while (v11 <= a4);
    signed int v9 = a4 & 0xFFFFFFFE;
  }
  else
  {
    signed int v9 = 0;
  }
  if (v9 < a4)
  {
    v29.i64[0] = 0x200000002000;
    v29.i64[1] = 0x200000002000;
    do
    {
      int32x4_t v30 = 0uLL;
      int8x16_t v31 = v8;
      if ((int)v7 >= 2)
      {
        uint64_t v32 = 0;
        int8x16_t v31 = v8;
        do
        {
          unint64_t v33 = (uint64_t *)(a6 + 8 * v32);
          uint64_t result = *v33;
          unsigned int v34 = *(_DWORD *)v31;
          v31 += 2;
          int32x4_t v30 = vmlal_s16(vmlal_s16(v30, vmovn_s32(*(int32x4_t *)(*v33 + 4 * (4 * v9))), vdup_n_s16(v34)), vmovn_s32(*(int32x4_t *)(v33[1] + 4 * (4 * v9))), vdup_n_s16(HIWORD(v34)));
          uint64_t v35 = v32 + 4;
          v32 += 2;
        }
        while (v35 <= v7);
      }
      if (v7)
      {
        int16x4_t v36 = vld1_dup_s16(v31);
        int32x4_t v30 = vmlal_s16(v30, vmovn_s32(*(int32x4_t *)(*(void *)(a6 + 8 * ((int)v7 - 1)) + 4 * (4 * v9))), v36);
      }
      int16x8_t v37 = (int16x8_t)vshrq_n_s32(vaddq_s32(v30, v29), 0xEuLL);
      *(int16x4_t *)v37.i8 = vqmovn_s32((int32x4_t)v37);
      *(int8x8_t *)v37.i8 = vqmovun_s16(v37);
      __int16 v38 = v37.u8[3];
      __int16 v39 = v37.u8[2];
      v37.i8[0] = vmaxv_u8(*(uint8x8_t *)v37.i8);
      v37.i16[1] = v37.u8[1];
      v37.i16[2] = v39;
      v37.i16[3] = v38;
      v6->i32[0] = vmovn_s16(v37).u32[0];
      uint64_t v6 = (uint8x8_t *)((char *)v6 + 4);
      ++v9;
    }
    while (v9 < a4);
  }
  return result;
}

uint64_t decode_byte_8bpc_3(uint64_t result, int a2, int a3, int a4, uint64_t a5, int a6, unsigned char *a7, int a8, uint64_t a9, void *a10, int a11)
{
  uint64_t v11 = a6 - (uint64_t)(a3 * (int)result);
  int v12 = -3 * result + a8;
  if (a9)
  {
    if (a9 == 2)
    {
      uint64_t v20 = *a10 + 20;
      uint64_t v21 = a10[1] + 20;
      uint64_t v22 = a11 + (uint64_t)a4;
      uint64_t v23 = a10[2] + 20;
      uint64_t v24 = 2 * a4 + a11;
      int v25 = result + 1;
      do
      {
        LODWORD(result) = v25;
        do
        {
          char v26 = *(unsigned char *)(v21 + *(unsigned __int8 *)(a5 + v22));
          char v27 = *(unsigned char *)(v23 + *(unsigned __int8 *)(a5 + v24));
          *a7 = *(unsigned char *)(v20 + *(unsigned __int8 *)(a5 + a11));
          a7[1] = v26;
          a7[2] = v27;
          a5 += a3;
          a7 += 3;
          uint64_t result = (result - 1);
        }
        while ((int)result > 1);
        a5 += (int)v11;
        a7 += v12;
        BOOL v16 = __OFSUB__(a2--, 1);
      }
      while (!((a2 < 0) ^ v16 | (a2 == 0)));
    }
    else if (a9 == 1)
    {
      int v13 = result + 1;
      do
      {
        int v14 = v13;
        do
        {
          char v15 = *(unsigned char *)(a5 + a11 + (uint64_t)a4);
          uint64_t result = *(unsigned __int8 *)(a5 + 2 * a4 + a11);
          *a7 = ~*(unsigned char *)(a5 + a11);
          a7[1] = ~v15;
          a7[2] = ~(_BYTE)result;
          a5 += a3;
          a7 += 3;
          --v14;
        }
        while (v14 > 1);
        a5 += (int)v11;
        a7 += v12;
        BOOL v16 = __OFSUB__(a2--, 1);
      }
      while (!((a2 < 0) ^ v16 | (a2 == 0)));
    }
  }
  else
  {
    int v17 = result + 1;
    do
    {
      int v18 = v17;
      do
      {
        char v19 = *(unsigned char *)(a5 + a11 + (uint64_t)a4);
        uint64_t result = *(unsigned __int8 *)(a5 + 2 * a4 + a11);
        *a7 = *(unsigned char *)(a5 + a11);
        a7[1] = v19;
        a7[2] = result;
        a5 += a3;
        a7 += 3;
        --v18;
      }
      while (v18 > 1);
      a5 += v11;
      a7 += v12;
      BOOL v16 = __OFSUB__(a2--, 1);
    }
    while (!((a2 < 0) ^ v16 | (a2 == 0)));
  }
  return result;
}

int32x4_t *resample_vertical<int,unsigned char,1,(AlphaStyle)0>(int32x4_t *result, double a2, double a3, int32x4_t a4, int16x4_t a5, int16x4_t a6, uint64_t a7, uint64_t a8, int a9, int8x8_t **a10, uint64_t a11)
{
  uint64_t v11 = *a10;
  uint64_t v12 = result->i32[1];
  int v13 = &result->i16[4];
  if (a9 >= 8)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 8;
    v17.i64[0] = 0x200000002000;
    v17.i64[1] = 0x200000002000;
    do
    {
      int32x4_t v18 = 0uLL;
      int32x4_t v19 = 0uLL;
      uint64_t v20 = v13;
      if ((int)v12 >= 2)
      {
        uint64_t v21 = 0;
        uint64_t v20 = v13;
        do
        {
          uint64_t v22 = (void *)(a11 + 8 * v21);
          uint64_t result = (int32x4_t *)(*v22 + 4 * v15);
          uint64_t v23 = (int32x4_t *)(v22[1] + 4 * v15);
          a6 = vmovn_s32(result[1]);
          unsigned int v24 = *(_DWORD *)v20;
          v20 += 2;
          int16x4_t v25 = vdup_n_s16(v24);
          a5 = vdup_n_s16(HIWORD(v24));
          int32x4_t v19 = vmlal_s16(vmlal_s16(v19, a6, v25), vmovn_s32(v23[1]), a5);
          int32x4_t v18 = vmlal_s16(vmlal_s16(v18, vmovn_s32(*result), v25), vmovn_s32(*v23), a5);
          uint64_t v26 = v21 + 4;
          v21 += 2;
        }
        while (v26 <= v12);
      }
      if (v12)
      {
        char v27 = (int32x4_t *)(*(void *)(a11 + 8 * ((int)v12 - 1)) + 4 * v15);
        a6 = vmovn_s32(*v27);
        a5 = vmovn_s32(v27[1]);
        int16x4_t v28 = vld1_dup_s16(v20);
        int32x4_t v19 = vmlal_s16(v19, a5, v28);
        int32x4_t v18 = vmlal_s16(v18, a6, v28);
      }
      v15 += 8;
      a4 = vshrq_n_s32(vaddq_s32(v19, v17), 0xEuLL);
      *v11++ = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vshrq_n_s32(vaddq_s32(v18, v17), 0xEuLL)), a4));
      v16 += 8;
    }
    while (v16 <= a9);
    uint64_t v14 = a9 & 0xFFFFFFF8;
  }
  else
  {
    uint64_t v14 = 0;
  }
  uint64_t v29 = v14 | 4;
  if ((int)(v14 | 4) <= a9)
  {
    v30.i64[0] = 0x200000002000;
    v30.i64[1] = 0x200000002000;
    do
    {
      int32x4_t v31 = 0uLL;
      uint64_t v32 = 4 * v14;
      unint64_t v33 = v13;
      if ((int)v12 >= 2)
      {
        uint64_t v34 = 0;
        unint64_t v33 = v13;
        do
        {
          uint64_t v35 = a11 + 8 * v34;
          uint64_t result = *(int32x4_t **)v35;
          unsigned int v36 = *(_DWORD *)v33;
          v33 += 2;
          a6 = vdup_n_s16(v36);
          *(int16x4_t *)a4.i8 = vdup_n_s16(HIWORD(v36));
          a5 = vmovn_s32(*(int32x4_t *)(*(void *)(v35 + 8) + v32));
          int32x4_t v31 = vmlal_s16(vmlal_s16(v31, vmovn_s32(*(int32x4_t *)(*(void *)v35 + v32)), a6), a5, *(int16x4_t *)a4.i8);
          uint64_t v37 = v34 + 4;
          v34 += 2;
        }
        while (v37 <= v12);
      }
      if (v12)
      {
        *(int16x4_t *)a4.i8 = vmovn_s32(*(int32x4_t *)(*(void *)(a11 + 8 * ((int)v12 - 1)) + v32));
        a5 = vld1_dup_s16(v33);
        int32x4_t v31 = vmlal_s16(v31, *(int16x4_t *)a4.i8, a5);
      }
      int16x8_t v38 = (int16x8_t)vshrq_n_s32(vaddq_s32(v31, v30), 0xEuLL);
      *(int16x4_t *)v38.i8 = vqmovn_s32((int32x4_t)v38);
      v11->i32[0] = vqmovun_s16(v38).u32[0];
      uint64_t v11 = (int8x8_t *)((char *)v11 + 4);
      uint64_t v14 = v29;
      v29 += 4;
    }
    while ((int)v29 <= a9);
  }
  for (; (int)v14 < a9; ++v14)
  {
    if ((int)v12 >= 2)
    {
      uint64_t v41 = 0;
      int32x4_t v39 = 0uLL;
      int32x4_t v40 = (unsigned __int32 *)v13;
      do
      {
        int32x4_t v42 = (void *)(a11 + 8 * v41);
        int32x4_t v43 = (unsigned __int16 *)(*v42 + 4 * v14);
        uint64_t result = (int32x4_t *)(v43 + 1);
        a4.i16[0] = *v43;
        a4.i16[2] = v43[1];
        int8x16_t v44 = (__int16 *)(v42[1] + 4 * v14);
        a5.i16[0] = *v44;
        a5.i16[2] = v44[1];
        unsigned __int32 v45 = *v40++;
        a6.i32[0] = v45;
        int32x4_t v46 = vmlal_s16(v39, vuzp1_s16(*(int16x4_t *)a4.i8, (int16x4_t)0x200000002000), a6);
        *(int16x4_t *)a4.i8 = vuzp1_s16(a5, (int16x4_t)0x200000002000);
        a5.i32[0] = HIWORD(v45);
        int32x4_t v39 = vmlal_s16(v46, *(int16x4_t *)a4.i8, a5);
        uint64_t v47 = v41 + 4;
        v41 += 2;
      }
      while (v47 <= v12);
    }
    else
    {
      int32x4_t v39 = 0uLL;
      int32x4_t v40 = (unsigned __int32 *)v13;
    }
    if (v12)
    {
      int16x8_t v48 = (unsigned __int16 *)(*(void *)(a11 + 8 * ((int)v12 - 1)) + 4 * v14);
      a4.i16[0] = *v48;
      a4.i16[2] = v48[1];
      *(int16x4_t *)a4.i8 = vuzp1_s16(*(int16x4_t *)a4.i8, (int16x4_t)0x200000002000);
      a5.i16[0] = *(_WORD *)v40;
      int32x4_t v39 = vmlal_s16(v39, *(int16x4_t *)a4.i8, a5);
    }
    *(int32x2_t *)v39.i8 = vadd_s32(*(int32x2_t *)v39.i8, (int32x2_t)0x200000002000);
    int16x8_t v49 = (int16x8_t)vshrq_n_s32(v39, 0xEuLL);
    *(int16x4_t *)v49.i8 = vqmovn_s32((int32x4_t)v49);
    v11->i8[0] = vqmovun_s16(v49).u8[0];
    uint64_t v11 = (int8x8_t *)((char *)v11 + 1);
  }
  return result;
}

int *resample_horizontal<unsigned char,int,1,false>(int *result, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, int16x8_t a10, uint64_t a11, unsigned int a12, uint64_t a13, uint64_t *a14, int *a15, int a16)
{
  if ((int)a12 >= 1 && a16 >= 1)
  {
    uint64_t v18 = 0;
    uint64_t v19 = *a14;
    uint64_t v20 = *a15;
    unint64_t v21 = a12;
    uint64_t v22 = 2 * a2 + 8;
    uint64_t v23 = (char *)result + v22 * a12;
    int v24 = *(_DWORD *)&v23[-v22 + 4] + *(_DWORD *)&v23[-v22];
    if (v20 < v24) {
      int v24 = *a15;
    }
    if (a2 <= 3) {
      unint64_t v25 = (2 * a2 + 23) / (2 * a2 + 8);
    }
    else {
      unint64_t v25 = 1;
    }
    unint64_t v26 = a12 - v25;
    int v27 = a2 > 7;
    unsigned int v28 = a2 & 7;
    if ((a2 & 7) != 0) {
      int v27 = 0;
    }
    else {
      unsigned int v28 = 8;
    }
    uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(v28);
    unint64_t v30 = ((a2 + 8 * (v27 << 31 >> 31)) & 0xFFFFFFF8) + (unint64_t)(((_BYTE)v28 + 7) & 0x18);
    if (a2 >= 8) {
      unsigned int v31 = 8;
    }
    else {
      unsigned int v31 = a2;
    }
    int8x16_t v32 = (int8x16_t)vcgtq_u16((uint16x8_t)vdupq_n_s16(v31), (uint16x8_t)xmmword_1850CD7D0);
    uint64_t v33 = a16;
    BOOL v35 = a2 == (__int16)a2 && v21 > v25;
    if (v26 <= 1) {
      uint64_t v36 = 1;
    }
    else {
      uint64_t v36 = v21 - v25;
    }
    int8x16_t v37 = (int8x16_t)vcgtq_u16(v29, (uint16x8_t)xmmword_1850CD7D0);
    v38.i64[0] = 0xFF000000FFLL;
    v38.i64[1] = 0xFF000000FFLL;
    do
    {
      int32x4_t v39 = *(_DWORD **)(a13 + 8 * v18);
      unint64_t v40 = 0;
      if (v35)
      {
        uint64_t v41 = result;
        while (1)
        {
          int32x4_t v42 = (uint8x8_t *)(v19 + *v41);
          int32x4_t v43 = (uint8x8_t *)((char *)v42 + v30);
          if ((unint64_t)v42 + v30 > v19 + v24) {
            break;
          }
          if (v42 >= v43)
          {
            int32x4_t v47 = 0uLL;
            int32x4_t v48 = 0uLL;
          }
          else
          {
            int8x16_t v44 = (int8x16_t *)(v41 + 2);
            int v45 = v41[1];
            unint64_t v46 = (unint64_t)&v43[-1];
            int32x4_t v47 = 0uLL;
            int32x4_t v48 = 0uLL;
            while ((unint64_t)v42 < v46)
            {
              int8x16_t v49 = *v44++;
              int8x16_t v50 = v49;
              *(uint8x8_t *)v49.i8 = *v42++;
              a10 = (int16x8_t)vandq_s8(v50, v32);
              int16x8_t v16 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v49.i8);
              int32x4_t v48 = vmlal_high_s16(v48, v16, a10);
              int32x4_t v47 = vmlal_s16(v47, *(int16x4_t *)v16.i8, *(int16x4_t *)a10.i8);
              v45 -= 8;
            }
            if (v45 >= 1)
            {
              a10 = (int16x8_t)vandq_s8(*v44, v37);
              int16x8_t v16 = (int16x8_t)vmovl_u8(*v42);
              int32x4_t v48 = vmlal_high_s16(v48, v16, a10);
              int32x4_t v47 = vmlal_s16(v47, *(int16x4_t *)v16.i8, *(int16x4_t *)a10.i8);
            }
          }
          *v39++ = vmaxq_s32(vminq_s32((int32x4_t)((vaddvq_s32(vaddq_s32(v47, v48)) + 0x2000) >> 14), v38), (int32x4_t)0).u32[0];
          ++v40;
          uint64_t v41 = (int *)((char *)v41 + v22);
          if (v40 == v36)
          {
            unint64_t v40 = v36;
            break;
          }
        }
      }
      else
      {
        uint64_t v41 = result;
      }
      if (v40 < v21)
      {
        do
        {
          uint64_t v51 = *v41;
          if ((int)v51 >= v24) {
            int v52 = v24;
          }
          else {
            int v52 = *v41;
          }
          int v53 = v24 - v52;
          if (v41[1] >= v53) {
            int v54 = v53;
          }
          else {
            int v54 = v41[1];
          }
          if (v54 < 1)
          {
            int32x4_t v58 = 0uLL;
            int32x4_t v60 = 0uLL;
          }
          else
          {
            uint64_t v55 = (uint8x8_t *)(v19 + v51);
            unint64_t v56 = (unint64_t)&v55[-2] + v54;
            int v57 = (int8x16_t *)(v41 + 2);
            int32x4_t v58 = 0uLL;
            if ((unint64_t)v55 >= v56)
            {
              LODWORD(v59) = v54;
              int32x4_t v60 = 0uLL;
LABEL_77:
              int v66 = v59 << 16;
              unsigned int v67 = v59;
              while (2)
              {
                unint64_t v68 = v23 - (char *)v57;
                if ((unint64_t)(v23 - (char *)v57) >= 0x10) {
                  unint64_t v68 = 16;
                }
                if (v68 < 0x10)
                {
                  if (v67 >= 4)
                  {
                    if (v67 == 4)
                    {
                      v16.i64[0] = 0;
                    }
                    else if (v67 == 5)
                    {
                      v16.i16[0] = v57->i16[4];
                    }
                    else
                    {
                      if (v67 == 6)
                      {
                        int16x4_t v74 = 0;
                      }
                      else
                      {
                        if (v59) {
                          __int32 v77 = 0;
                        }
                        else {
                          __int32 v77 = v57->u16[7];
                        }
                        v74.i32[0] = v57->u16[6];
                        v74.i32[1] = v77;
                      }
                      v16.i16[0] = v57->i16[4];
                      v16.i16[2] = v57->i16[5];
                      *(int16x4_t *)v16.i8 = vuzp1_s16(*(int16x4_t *)v16.i8, v74);
                    }
                    a10.i64[0] = v57->i64[0];
                    a10.i64[1] = v16.i64[0];
                    goto LABEL_84;
                  }
                  if (v67 == 1)
                  {
                    a10.i16[0] = v57->i16[0];
                  }
                  else
                  {
                    if (v67 == 2) {
                      int16x4_t v73 = 0;
                    }
                    else {
                      int16x4_t v73 = (int16x4_t)v57->u16[2];
                    }
                    v16.i16[0] = v57->i16[0];
                    v16.i16[2] = v57->i16[1];
                    *(int16x4_t *)a10.i8 = vuzp1_s16(*(int16x4_t *)v16.i8, v73);
                  }
                  a10.i64[1] = 0;
                  ++v57;
                }
                else
                {
                  unsigned int v69 = v66 >> 16;
                  if (v66 >> 16 >= 8) {
                    unsigned int v69 = 8;
                  }
                  a10 = (int16x8_t)vandq_s8(*v57, (int8x16_t)vcgtq_s16(vdupq_n_s16(v69), (int16x8_t)xmmword_1850CD7D0));
LABEL_84:
                  ++v57;
                  if (v67 >= 8)
                  {
                    uint8x8_t v70 = *v55;
                    goto LABEL_86;
                  }
                  if (v67 >= 4)
                  {
                    if (v67 == 4)
                    {
                      int8x8_t v72 = 0;
                    }
                    else if (v67 == 5)
                    {
                      int8x8_t v72 = (int8x8_t)v55->u8[4];
                    }
                    else
                    {
                      if (v67 == 6) {
                        int16x4_t v76 = 0;
                      }
                      else {
                        int16x4_t v76 = (int16x4_t)v55->u8[6];
                      }
                      v17.i8[0] = v55->i8[4];
                      v17.i8[4] = v55->i8[5];
                      int8x8_t v72 = (int8x8_t)vuzp1_s16(v17, v76);
                    }
                    v17.i32[0] = v55->i32[0];
                    int16x4_t v17 = (int16x4_t)vmovl_u8((uint8x8_t)v17).u64[0];
                    uint8x8_t v70 = (uint8x8_t)vuzp1_s8((int8x8_t)v17, v72);
                    goto LABEL_86;
                  }
                }
                if (v67 == 1)
                {
                  int16x4_t v17 = (int16x4_t)v55->u8[0];
                }
                else
                {
                  if (v67 == 2) {
                    int16x4_t v75 = 0;
                  }
                  else {
                    int16x4_t v75 = (int16x4_t)v55->u8[2];
                  }
                  v17.i8[0] = v55->i8[0];
                  v17.i8[4] = v55->i8[1];
                  int16x4_t v17 = vuzp1_s16(v17, v75);
                }
                v70.i32[1] = 0;
                v70.i8[0] = v17.i8[0];
                v70.i8[1] = v17.i8[2];
                v70.i8[2] = v17.i8[4];
                v70.i8[3] = v17.i8[6];
LABEL_86:
                ++v55;
                int16x8_t v16 = (int16x8_t)vmovl_u8(v70);
                int32x4_t v60 = vmlal_high_s16(v60, v16, a10);
                int32x4_t v58 = vmlal_s16(v58, *(int16x4_t *)v16.i8, *(int16x4_t *)a10.i8);
                v66 -= 0x80000;
                BOOL v71 = __OFSUB__(v67, 8);
                v67 -= 8;
                if (((v67 & 0x80000000) != 0) ^ v71 | (v67 == 0)) {
                  goto LABEL_126;
                }
                continue;
              }
            }
            uint64_t v59 = v54;
            int32x4_t v60 = 0uLL;
            do
            {
              unint64_t v61 = v23 - (char *)v57;
              if ((unint64_t)(v23 - (char *)v57) >= 0x10) {
                unint64_t v61 = 16;
              }
              if (v61 < 0x10)
              {
                if (v59)
                {
                  if (v59 < 4)
                  {
                    if (v59 == 1)
                    {
                      a10.i16[0] = v57->i16[0];
                    }
                    else
                    {
                      if (v59 == 2) {
                        int16x4_t v63 = 0;
                      }
                      else {
                        int16x4_t v63 = (int16x4_t)v57->u16[2];
                      }
                      v16.i16[0] = v57->i16[0];
                      v16.i16[2] = v57->i16[1];
                      *(int16x4_t *)a10.i8 = vuzp1_s16(*(int16x4_t *)v16.i8, v63);
                    }
                    a10.i64[1] = 0;
                  }
                  else
                  {
                    if (v59 == 4)
                    {
                      v16.i64[0] = 0;
                    }
                    else if (v59 == 5)
                    {
                      v16.i16[0] = v57->i16[4];
                    }
                    else
                    {
                      if (v59 == 6)
                      {
                        int16x4_t v64 = 0;
                      }
                      else
                      {
                        if (v54) {
                          __int32 v65 = 0;
                        }
                        else {
                          __int32 v65 = v57->u16[7];
                        }
                        v64.i32[0] = v57->u16[6];
                        v64.i32[1] = v65;
                      }
                      v16.i16[0] = v57->i16[4];
                      v16.i16[2] = v57->i16[5];
                      *(int16x4_t *)v16.i8 = vuzp1_s16(*(int16x4_t *)v16.i8, v64);
                    }
                    a10.i64[0] = v57->i64[0];
                    a10.i64[1] = v16.i64[0];
                  }
                }
                else
                {
                  a10 = 0uLL;
                }
              }
              else
              {
                a10 = (int16x8_t)vandq_s8(*v57, v32);
              }
              uint8x8_t v62 = *v55++;
              ++v57;
              int16x8_t v16 = (int16x8_t)vmovl_u8(v62);
              int32x4_t v60 = vmlal_high_s16(v60, v16, a10);
              int32x4_t v58 = vmlal_s16(v58, *(int16x4_t *)v16.i8, *(int16x4_t *)a10.i8);
              v59 -= 8;
            }
            while ((unint64_t)v55 < v56);
            if ((int)v59 >= 1) {
              goto LABEL_77;
            }
          }
LABEL_126:
          *v39++ = vmaxq_s32(vminq_s32((int32x4_t)((vaddvq_s32(vaddq_s32(v58, v60)) + 0x2000) >> 14), v38), (int32x4_t)0).u32[0];
          ++v40;
          uint64_t v41 = (int *)((char *)v41 + v22);
        }
        while (v40 != v21);
      }
      v19 += v20;
      ++v18;
    }
    while (v18 != v33);
  }
  return result;
}

uint64_t CGGStateGetShouldAntialias(uint64_t a1)
{
  return *(unsigned char *)(*(void *)(a1 + 120) + 7) & 1;
}

uint64_t __CGColorConversionInfoIterateFunctionsWithCallbacks_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (!v5) {
    return 1;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v7 = *(uint64_t (**)(uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(v5 + 16);
  long long v8 = *(_OWORD *)(v6 + 56);
  v10[1] = *(_OWORD *)(v6 + 40);
  v10[2] = v8;
  v11[0] = *(_OWORD *)(v6 + 72);
  *(_OWORD *)((char *)v11 + 12) = *(_OWORD *)(v6 + 84);
  v10[0] = *(_OWORD *)(v6 + 24);
  return v7(v5, v10, a2, a3, a4);
}

CFTypeRef CGImageTextureDataRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t (**RIPLayerBltGlyph(_DWORD *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8))()
{
  uint64_t v12 = a4;
  uint64_t v14 = a2;
  uint64_t v232 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    uint64_t v20 = 0;
    goto LABEL_27;
  }
  if (!*(_DWORD *)(a2 + 64))
  {
    if (*(void *)(a2 + 56))
    {
      uint64_t v20 = 0;
      goto LABEL_16;
    }
    BOOL IsEnclosed = ripl_IsEnclosed(a4, (_DWORD *)(a2 + 12));
    goto LABEL_14;
  }
  uint64_t v16 = *(void *)(a2 + 72);
  if (!v16)
  {
    BOOL IsEnclosed = ripl_IsContained(a4, (_DWORD *)(a2 + 12));
LABEL_14:
    uint64_t v20 = 0;
    if (IsEnclosed) {
      uint64_t v14 = 0;
    }
    goto LABEL_16;
  }
  int v17 = a4[3];
  signed int v18 = *(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 16) - (a4[1] + v17);
  uint64_t v19 = shape_enclose_with_bounds(v16, *a4 - *(_DWORD *)(a2 + 12), v18, a4[2] + *a4 - *(_DWORD *)(a2 + 12), v18 + v17);
  uint64_t v20 = v19;
  if (v19)
  {
    if (v19 == (int *)&the_empty_shape) {
      return 0;
    }
    if (v19[v19[1]] == 0x7FFFFFFF) {
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
LABEL_16:
  unint64_t v22 = (int)v12[9] * (uint64_t)(int)v12[8];
  BOOL v76 = v22 >> 31 == 0;
  int v23 = v22 + 15;
  char v25 = v76 && v23 >= 0;
  if (v14 && (v25 & 1) == 0)
  {
    if (v20) {
LABEL_25:
    }
      free(v20);
    return 0;
  }
LABEL_27:
  uint64_t v231 = 0;
  long long v229 = 0u;
  long long v230 = 0u;
  long long v227 = 0u;
  long long v228 = 0u;
  long long v225 = 0u;
  long long v226 = 0u;
  long long v223 = 0u;
  long long v224 = 0u;
  long long v221 = 0u;
  long long v222 = 0u;
  long long v219 = 0u;
  long long v220 = 0u;
  long long v217 = 0u;
  long long v218 = 0u;
  long long v215 = 0u;
  long long v216 = 0u;
  long long v213 = 0u;
  long long v214 = 0u;
  if (a3) {
    int v27 = a3;
  }
  else {
    int v27 = v12;
  }
  unsigned int v28 = (long long *)*((void *)a1 + 5);
  if (!v28)
  {
    long long v225 = 0uLL;
    long long v226 = 0uLL;
    long long v223 = 0uLL;
    long long v224 = 0uLL;
    long long v221 = 0uLL;
    long long v222 = 0uLL;
    long long v219 = 0uLL;
    long long v220 = 0uLL;
    long long v217 = 0uLL;
    long long v218 = 0uLL;
    long long v215 = 0uLL;
    long long v216 = 0uLL;
    long long v213 = 0uLL;
    long long v214 = 0uLL;
    unsigned int v28 = &v213;
    *(void *)&long long v227 = 0;
  }
  *(_OWORD *)int v209 = 0uLL;
  memset(v210, 0, 24);
  long long v207 = 0uLL;
  *(_OWORD *)__b = 0uLL;
  uint64_t result = (uint64_t (**)())(*(uint64_t (**)(_DWORD *, uint64_t, _DWORD *))(*(void *)a1 + 32))(a1, 32, v27);
  if (result)
  {
    uint64_t v204 = 0;
    uint64_t v205 = 0;
    uint64_t v206 = 0;
    BOOL v35 = *result;
    if (*result)
    {
      int v200 = *result;
      BOOL v35 = (uint64_t (*)())*((void *)v35 + 4);
      if (v35)
      {
        int v196 = result;
        if (!*((void *)a1 + 7) && !ripl_CreateMask((uint64_t)a1, 1, v29, v30, v31, v32, v33, v34)) {
          goto LABEL_71;
        }
        *((double *)v28 + 18) = *(float *)(a8 + 64);
        *(unsigned char *)unsigned int v28 = *(_DWORD *)a8;
        v36.n128_f64[0] = ripl_BltOpDestination((uint64_t)v28, (uint64_t)v27, (uint64_t)a1);
        if (!a5)
        {
          uint64_t v38 = 0;
          BOOL v35 = (uint64_t (*)())*((void *)v200 + 3);
          if (!v35)
          {
            BOOL v35 = 0;
            int32x4_t v39 = 0;
            goto LABEL_62;
          }
          int v189 = v27;
          uint64_t v179 = v14;
          int v40 = 0;
          uint64_t v41 = 0;
          float v42 = *(double *)(a8 + 48);
          uint64_t v173 = 0;
          goto LABEL_46;
        }
        int8x16_t v37 = *(uint64_t (***)())a5;
        if (*(_UNKNOWN **)a5 != &ripc_class)
        {
          if (v37)
          {
            while (v37 != RIPLayer_ripl_class)
            {
              BOOL v35 = *v37;
              if (!*v37) {
                goto LABEL_60;
              }
              int8x16_t v37 = (uint64_t (**)())((uint64_t (*)(__n128))v35)(v36);
              uint64_t v38 = 0;
              BOOL v35 = 0;
              int32x4_t v39 = 0;
              if (!v37) {
                goto LABEL_62;
              }
            }
            uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)a5 + 32))(a5, 16, a5 + 12, v36);
            uint64_t v38 = v52;
            if (v52 && *(void *)(*(void *)v52 + 8) == *((void *)v200 + 1))
            {
              uint64_t v174 = v52;
              if (*(void *)(a5 + 56) || ripl_CreateMask(a5, 0, v53, v54, v52, v55, v56, v57))
              {
                unsigned __int8 v58 = ripl_BltOpSourceLayer((uint64_t)v28, v27, a1, a6, a5);
                char v172 = 0;
                int v192 = -1;
                uint64_t v59 = v174;
                if (!a7) {
                  goto LABEL_102;
                }
LABEL_90:
                if (*(_UNKNOWN **)a7 != &ripc_class)
                {
LABEL_102:
                  uint64_t v175 = v59;
                  *((unsigned char *)v28 + 2) = 1;
                  int v71 = v27[1];
                  int v72 = v27[3];
                  int v194 = *((_DWORD *)v28 + 3);
                  int v195 = *v27;
                  int v193 = *((_DWORD *)v28 + 4);
                  int v183 = *((_DWORD *)v28 + 15);
                  int v184 = *((_DWORD *)v28 + 14);
                  LODWORD(v210[0]) = a1[7] & 0x100;
                  v209[1] = 0;
                  *(void *)((char *)v210 + 12) = 4;
                  *(void *)((char *)v210 + 4) = *((void *)v12 + 4);
                  uint64_t v73 = *((void *)v12 + 2);
                  if (v73)
                  {
                    v171 = a1;
                    uint64_t v74 = 0;
                    uint64_t v202 = 0;
                    int v191 = v72 + v71;
                    unsigned int v197 = (int *)(v14 + 12);
                    int v182 = v58 << 8;
                    int v176 = v20;
                    uint64_t v177 = a5;
                    int v178 = v12;
                    uint64_t v180 = v14;
                    uint64_t v181 = *((void *)v12 + 2);
                    char v190 = v27;
                    while (1)
                    {
                      long long v203 = 0uLL;
                      int16x4_t v75 = v209[1];
                      if (v209[1]) {
                        BOOL v76 = DWORD1(v210[0]) == 0;
                      }
                      else {
                        BOOL v76 = 0;
                      }
                      if (v76)
                      {
                        free(v209[1]);
                        int16x4_t v75 = 0;
                        v209[1] = 0;
                      }
                      __int32 v77 = &v12[10 * v74];
                      unint64_t v78 = (long long *)(v77 + 10);
                      if (!v14)
                      {
                        int v93 = 0;
                        int v94 = 0;
                        int v96 = v77[12];
                        int v95 = v77[13];
                        int v97 = *(_DWORD *)v78;
                        int v98 = *((_DWORD *)v78 + 1) + v95;
                        int v99 = *((_DWORD *)v78 + 2);
                        int v100 = *((_DWORD *)v78 + 3);
                        goto LABEL_212;
                      }
                      if (CGSBoundsIntersection(v197, v77 + 10, &v203)) {
                        break;
                      }
LABEL_217:
                      if (++v74 == v73)
                      {
                        int v170 = v209[1];
                        a1 = v171;
                        goto LABEL_221;
                      }
                    }
                    uint8x16_t v80 = &v12[10 * v74];
                    unsigned int v83 = v80[15];
                    int16x4_t v82 = v80 + 15;
                    int v81 = v83;
                    int v84 = HIDWORD(v210[0]);
                    uint64_t v85 = (HIDWORD(v210[0]) - 1);
                    BOOL v86 = v83 >= 8;
                    if (v83 != 8 && (!v86 || LODWORD(v210[0]) == 0))
                    {
                      long long v207 = *v78;
                      int v88 = *((_DWORD *)v78 + 2);
                      unsigned int v89 = (v88 + v85) & -HIDWORD(v210[0]);
                      __b[0] = (void *)(v89 | 0x800000000);
                      LODWORD(v209[0]) = v12[10 * v74 + 18];
                      __b[1] = v75;
                      unsigned int v187 = HIDWORD(v210[0]) - 1;
                      if (v75 && (int v90 = *((_DWORD *)v78 + 3), v90 * v89 <= LODWORD(v210[1])))
                      {
                        int v91 = HIDWORD(v210[0]);
                      }
                      else
                      {
                        int v91 = HIDWORD(v210[0]);
                        if (DWORD1(v210[0])) {
                          int v92 = DWORD2(v210[0]) * ((DWORD1(v210[0]) + v85) & -HIDWORD(v210[0]));
                        }
                        else {
                          int v92 = *((_DWORD *)v78 + 3) * v89;
                        }
                        LODWORD(v210[1]) = v92;
                        free(v75);
                        v101 = malloc_type_malloc((LODWORD(v210[1]) + v91), 0x56B6C8EBuLL);
                        v209[1] = v101;
                        __b[1] = v101;
                        if (!v101)
                        {
                          int v27 = v190;
                          a5 = v177;
                          goto LABEL_217;
                        }
                        int16x4_t v75 = v101;
                        unsigned int v89 = __b[0];
                        int v88 = *((_DWORD *)v78 + 2);
                        int v90 = *((_DWORD *)v78 + 3);
                        int v81 = *v82;
                      }
                      CGSConvertBitsToMask(*(uint16x4_t **)&v12[10 * v74 + 16], v12[10 * v74 + 14], v75, v89, v88, v90, v81);
                      unint64_t v78 = &v207;
                      int v84 = v91;
                      a5 = v177;
                      uint64_t v85 = v187;
                    }
                    int v102 = *(_DWORD *)(v14 + 64);
                    if (v102)
                    {
                      int v103 = v20;
                      if (v20 || (int v103 = *(int **)(v14 + 72)) != 0)
                      {
                        int v185 = v84;
                        int v188 = v85;
                        *(void *)uint64_t v211 = 0;
                        uint64_t v212 = 0;
                        shape_enum_clip_alloc(v85, v79, v103, 1, 1, 0, v203 - *(_DWORD *)(v14 + 12), *(_DWORD *)(v14 + 24) + *(_DWORD *)(v14 + 16) - (DWORD1(v203) + HIDWORD(v203)), SDWORD2(v203), SHIDWORD(v203));
                        if (v104)
                        {
                          int v105 = *((_DWORD *)v78 + 1);
                          uint64_t v106 = *(int *)v78;
                          int v107 = *((_DWORD *)v78 + 3);
                          int v108 = DWORD1(v203);
                          uint64_t v109 = (int)v203;
                          int v110 = HIDWORD(v203);
                          uint64_t v201 = (void *)v104;
                          int v111 = shape_enum_clip_next(v104, (int *)&v212 + 1, &v212, &v211[1], v211);
                          if (v111)
                          {
                            int v112 = v111;
                            if (*(void *)v211 == __PAIR64__(DWORD2(v203), HIDWORD(v203)))
                            {
                              free(v201);
                              uint64_t v20 = v176;
                              a5 = v177;
                              uint64_t v12 = v178;
                              uint64_t v14 = v180;
                              if ((v112 & 0x80000000) == 0) {
                                goto LABEL_142;
                              }
                              goto LABEL_198;
                            }
                            uint64_t v199 = v109 - v106;
                            int v198 = v107 + v105 - (v108 + v110);
                            if (v78 == &v207)
                            {
                              LODWORD(v209[0]) = 0;
                              uint64_t v20 = v176;
                              a5 = v177;
                              uint64_t v12 = v178;
                              uint64_t v14 = v180;
                              int v27 = v190;
                              int v140 = v201;
                              do
                              {
                                if (v112 <= 0) {
                                  CGBlt_fillBytes(v211[1], v211[0], 0, (char *)__b[1]+ SHIDWORD(v212)+ v199+ ((v212 + v198) * LODWORD(__b[0])), (int)__b[0]);
                                }
                                int v112 = shape_enum_clip_next((uint64_t)v201, (int *)&v212 + 1, &v212, &v211[1], v211);
                              }
                              while (v112);
                              unint64_t v78 = &v207;
                              goto LABEL_201;
                            }
                            unsigned int v125 = *((_DWORD *)v78 + 5);
                            unsigned int v126 = v125 >> 3;
                            int v127 = (((v125 >> 1) & 0x1FFFFFFF) + v188) & -v185;
                            long long v207 = v203;
                            int v128 = (v127 - 1 + (v125 >> 3) * DWORD2(v203)) & -v127;
                            __b[0] = (void *)__PAIR64__(v125, v128);
                            LODWORD(v209[0]) = 0;
                            __b[1] = v209[1];
                            if (v209[1] && (HIDWORD(v203) * v128) <= LODWORD(v210[1])
                              || (!DWORD1(v210[0])
                                ? (int v129 = HIDWORD(v203) * v128)
                                : (int v129 = DWORD2(v210[0]) * ((v127 - 1 + DWORD1(v210[0]) * v126) & -v127)),
                                  LODWORD(v210[1]) = v129,
                                  free(v209[1]),
                                  v209[1] = malloc_type_malloc((LODWORD(v210[1]) + v127), 0x10EC260FuLL),
                                  (__b[1] = v209[1]) != 0))
                            {
                              unint64_t v186 = 0;
                              int v159 = 0;
                              int v160 = 0;
                              int v161 = 0;
                              do
                              {
                                unsigned int v162 = v212;
                                unsigned int v163 = HIDWORD(v212);
                                uint64_t v164 = (char *)__b[1] + (LODWORD(__b[0]) * v212) + HIDWORD(v212) * v126;
                                if (v112 < 1)
                                {
                                  CGBlt_fillBytes(v211[1] * v126, v211[0], 0, v164, (int)__b[0]);
                                }
                                else
                                {
                                  int v159 = v211[1];
                                  int v160 = v211[0];
                                  CGBlt_copyBytes(v211[1] * v126, v211[0], (char *)(*((void *)v78 + 3)+ (*((_DWORD *)v78 + 4) * (v212 + v198))+ (HIDWORD(v212) + v199) * v126), v164, *((_DWORD *)v78 + 4), (int)__b[0]);
                                  ++v161;
                                  unint64_t v186 = __PAIR64__(v163, v162);
                                }
                                int v112 = shape_enum_clip_next((uint64_t)v201, (int *)&v212 + 1, &v212, &v211[1], v211);
                              }
                              while (v112);
                              a5 = v177;
                              int v140 = v201;
                              if (v161 == 1)
                              {
                                LODWORD(v203) = v203 + HIDWORD(v186);
                                DWORD1(v203) = DWORD1(v203) - (v160 + v186) + HIDWORD(v203);
                                *((void *)&v203 + 1) = __PAIR64__(v160, v159);
                              }
                              else
                              {
                                unint64_t v78 = &v207;
                              }
                              uint64_t v20 = v176;
                              uint64_t v12 = v178;
                              uint64_t v14 = v180;
                              int v27 = v190;
LABEL_201:
                              uint64_t v73 = v181;
                              free(v140);
                              goto LABEL_211;
                            }
                          }
                          free(v201);
                          a5 = v177;
LABEL_196:
                          uint64_t v20 = v176;
LABEL_197:
                          uint64_t v12 = v178;
                          uint64_t v14 = v180;
                        }
LABEL_198:
                        int v27 = v190;
                        uint64_t v73 = v181;
                        goto LABEL_217;
                      }
                      int v131 = *(_DWORD *)(v14 + 12);
                      int v130 = *(_DWORD *)(v14 + 16);
                      if ((int)v203 <= v131)
                      {
                        int v132 = DWORD2(v203);
                        int v133 = *(_DWORD *)(v14 + 20);
                      }
                      else
                      {
                        int v132 = DWORD2(v203);
                        int v133 = *(_DWORD *)(v14 + 20);
                        if (SDWORD1(v203) > v130)
                        {
                          uint64_t v73 = v181;
                          if (DWORD2(v203) + (int)v203 < v133 + v131
                            && HIDWORD(v203) + DWORD1(v203) < *(_DWORD *)(v14 + 24) + v130)
                          {
                            goto LABEL_210;
                          }
                          goto LABEL_162;
                        }
                      }
                      uint64_t v73 = v181;
LABEL_162:
                      unsigned int v141 = v102 & 0xFF000000;
                      if (v203 != v131) {
                        unsigned int v141 = 0;
                      }
                      int v142 = *(_DWORD *)(v14 + 64);
                      if (DWORD1(v203) != v130) {
                        int v142 = 0;
                      }
                      if (v132 + v203 == v133 + v131) {
                        int v143 = *(_DWORD *)(v14 + 64) & 0xFF00;
                      }
                      else {
                        int v143 = 0;
                      }
                      int v144 = v102 & 0xFF0000;
                      if (HIDWORD(v203) + DWORD1(v203) != *(_DWORD *)(v14 + 24) + v130) {
                        int v144 = 0;
                      }
                      unsigned int v145 = v142 | v141 | v143 | v144;
                      uint64_t v146 = (int)v203 - (uint64_t)*(int *)v78;
                      int v147 = *((_DWORD *)v78 + 1) - (HIDWORD(v203) + DWORD1(v203)) + *((_DWORD *)v78 + 3);
                      if (v78 == &v207)
                      {
                        long long v207 = v203;
                        LODWORD(v209[0]) = 0;
                        int v158 = CGSCombineMask((char *)__b[1] + v146 + (LODWORD(__b[0]) * v147), (int)__b[0], (char *)__b[1], (int)__b[0], v132, SHIDWORD(v203), v145);
                        uint64_t v12 = v178;
                        goto LABEL_208;
                      }
                      uint64_t v148 = a5;
                      unsigned int v149 = *((_DWORD *)v78 + 5);
                      unsigned int v150 = v149 >> 3;
                      int v151 = (((v149 >> 1) & 0x1FFFFFFF) + v85) & -v84;
                      long long v207 = v203;
                      int v152 = (v151 - 1 + (v149 >> 3) * v132) & -v151;
                      __b[0] = (void *)__PAIR64__(v149, v152);
                      LODWORD(v209[0]) = 0;
                      int v153 = (char *)v209[1];
                      __b[1] = v209[1];
                      if (v209[1] && v152 * HIDWORD(v203) <= LODWORD(v210[1])
                        || (!DWORD1(v210[0])
                          ? (int v154 = v152 * HIDWORD(v203))
                          : (int v154 = DWORD2(v210[0]) * ((v151 - 1 + DWORD1(v210[0]) * v150) & -v151)),
                            LODWORD(v210[1]) = v154,
                            free(v209[1]),
                            int v153 = (char *)malloc_type_malloc((LODWORD(v210[1]) + v151), 0xE0EDAC82uLL),
                            v209[1] = v153,
                            (__b[1] = v153) != 0))
                      {
                        int v165 = *((_DWORD *)v78 + 4);
                        uint64_t v166 = *((void *)v78 + 3) + (v165 * v147);
                        a5 = v148;
                        if (v150 == 1) {
                          int v158 = CGSCombineMask((char *)(v166 + (int)v146), v165, v153, (int)__b[0], SDWORD2(v203), SHIDWORD(v203), v145);
                        }
                        else {
                          int v158 = CGSCombineDeepMask((char *)(v166 + v150 * v146), v165, v153, (int)__b[0], SDWORD2(v203), SHIDWORD(v203), v145);
                        }
                        uint64_t v12 = v178;
                        uint64_t v14 = v180;
                        uint64_t v73 = v181;
LABEL_208:
                        if (v158) {
                          unint64_t v78 = &v207;
                        }
LABEL_210:
                        int v27 = v190;
LABEL_211:
                        int v99 = DWORD2(v203);
                        int v100 = HIDWORD(v203);
                        int v97 = v203;
                        int v98 = DWORD1(v203) + HIDWORD(v203);
                        int v96 = *((_DWORD *)v78 + 2);
                        int v95 = *((_DWORD *)v78 + 3);
                        int v93 = v203 - *(_DWORD *)v78;
                        int v94 = v95 - (DWORD1(v203) + HIDWORD(v203)) + *((_DWORD *)v78 + 1);
LABEL_212:
                        *((_DWORD *)v28 + 1) = v99;
                        *((_DWORD *)v28 + 2) = v100;
                        *((_DWORD *)v28 + 26) = v93;
                        *((_DWORD *)v28 + 27) = v94;
                        *((_DWORD *)v28 + 28) = v96;
                        *((_DWORD *)v28 + 29) = v95;
                        int v167 = v97 - v195;
                        *((void *)v28 + 17) = *((void *)v78 + 3);
                        *(void *)((char *)v28 + 124) = *((void *)v78 + 2);
                        *((_DWORD *)v28 + 30) = *((_DWORD *)v78 + 8);
                        *((_DWORD *)v28 + 3) = v167 + v194;
                        *((_DWORD *)v28 + 4) = v191 - v98 + v193;
                        if (!v192
                          || (*(_DWORD *)unsigned int v28 = *(_DWORD *)v28 & 0xFFFF00FF | v182,
                              *((_DWORD *)v28 + 14) = v167 + v184,
                              *((_DWORD *)v28 + 15) = v191 - v98 + v183,
                              CGBlt_initialize((uint64_t)v28)))
                        {
                          int v168 = (*((uint64_t (**)(uint64_t (**)(), long long *))v200 + 4))(v196, v28);
                          v169 = v202;
                          if (v168) {
                            v169 = (uint64_t (*)())v27;
                          }
                          uint64_t v202 = v169;
                        }
                        goto LABEL_217;
                      }
                      a5 = v148;
                      goto LABEL_197;
                    }
                    uint64_t v113 = *(void *)(v14 + 56);
                    if (!v113)
                    {
LABEL_142:
                      int v27 = v190;
                      uint64_t v73 = v181;
                      goto LABEL_211;
                    }
                    uint64_t v114 = (int)v203 - (uint64_t)*(int *)(v14 + 12);
                    int v115 = HIDWORD(v203);
                    int v116 = *(_DWORD *)(v14 + 24) + *(_DWORD *)(v14 + 16) - (HIDWORD(v203) + DWORD1(v203));
                    uint64_t v117 = (int)v203 - (uint64_t)*(int *)v78;
                    int v118 = *((_DWORD *)v78 + 1) - (HIDWORD(v203) + DWORD1(v203)) + *((_DWORD *)v78 + 3);
                    if (v78 == &v207)
                    {
                      long long v207 = v203;
                      LODWORD(v209[0]) = 0;
                      int v123 = __b[1];
                      int v134 = (int)__b[0];
                      int v135 = (char *)__b[1] + v117 + (LODWORD(__b[0]) * v118);
                      int v136 = *(_DWORD *)(v14 + 48);
                      uint64_t v137 = v113 + v114 + (v136 * v116);
                      int v138 = DWORD2(v203);
                      int v139 = (int)__b[0];
                    }
                    else
                    {
                      unsigned int v119 = *((_DWORD *)v78 + 5);
                      unsigned int v120 = v119 >> 3;
                      int v121 = (((v119 >> 1) & 0x1FFFFFFF) + v85) & -v84;
                      long long v207 = v203;
                      int v122 = (v121 - 1 + DWORD2(v203) * (v119 >> 3)) & -v121;
                      __b[0] = (void *)__PAIR64__(v119, v122);
                      LODWORD(v209[0]) = 0;
                      int v123 = v209[1];
                      __b[1] = v209[1];
                      if (!v209[1] || (v122 * HIDWORD(v203)) > LODWORD(v210[1]))
                      {
                        int v124 = DWORD1(v210[0])
                             ? DWORD2(v210[0]) * ((v121 - 1 + DWORD1(v210[0]) * v120) & -v121)
                             : v122 * HIDWORD(v203);
                        LODWORD(v210[1]) = v124;
                        free(v209[1]);
                        int v123 = malloc_type_malloc((LODWORD(v210[1]) + v121), 0x263F05C7uLL);
                        v209[1] = v123;
                        __b[1] = v123;
                        if (!v123) {
                          goto LABEL_196;
                        }
                      }
                      int v134 = *((_DWORD *)v78 + 4);
                      uint64_t v155 = *((void *)v78 + 3) + (v134 * v118);
                      uint64_t v20 = v176;
                      if (v120 != 1)
                      {
                        uint64_t v157 = v155 + v120 * v117;
                        uint64_t v14 = v180;
                        int v156 = CGSCombineDeepMaskToDeepMask(v157, v134, *(void *)(v180 + 56) + (*(_DWORD *)(v180 + 48) * v116) + (int)v114, *(_DWORD *)(v180 + 48), (uint64_t)v123, (int)__b[0], SDWORD2(v203), SHIDWORD(v203));
LABEL_182:
                        uint64_t v12 = v178;
                        int v27 = v190;
                        uint64_t v73 = v181;
                        if (!v156) {
                          goto LABEL_211;
                        }
                        if ((v156 & 0x80000000) == 0)
                        {
                          unint64_t v78 = &v207;
                          goto LABEL_211;
                        }
                        goto LABEL_217;
                      }
                      int v135 = (char *)(v155 + (int)v117);
                      uint64_t v14 = v180;
                      int v136 = *(_DWORD *)(v180 + 48);
                      uint64_t v137 = *(void *)(v180 + 56) + (v136 * v116) + (int)v114;
                      int v139 = (int)__b[0];
                      int v138 = DWORD2(v203);
                      int v115 = HIDWORD(v203);
                    }
                    int v156 = CGSCombineMaskToMask((uint64_t)v135, v134, v137, v136, (uint64_t)v123, v139, v138, v115);
                    goto LABEL_182;
                  }
                  int v170 = 0;
                  uint64_t v202 = 0;
LABEL_221:
                  free(v170);
                  int32x4_t v39 = v172;
                  uint64_t v38 = v175;
                  BOOL v35 = v202;
                  goto LABEL_62;
                }
                int v68 = *(_DWORD *)(a7 + 24);
                if (v68 == 2)
                {
                  int v69 = 4;
                }
                else if (v68 == 1)
                {
                  int v69 = 3;
                }
                else
                {
                  if (v68)
                  {
                    LODWORD(v204) = 0;
                    goto LABEL_101;
                  }
                  int v69 = 1;
                }
                LODWORD(v204) = v69;
LABEL_101:
                uint64_t v205 = a7 + 28;
                float v70 = *(double *)(a8 + 56) * *(float *)(a7 + 156);
                *(float *)&uint64_t v206 = v70;
                *((void *)v28 + 19) = &v204;
                goto LABEL_102;
              }
              BOOL v35 = 0;
              int32x4_t v39 = 0;
              uint64_t v38 = v174;
LABEL_62:
              int32x4_t v48 = v35;
              *((void *)v28 + 19) = 0;
              if (v20)
              {
                uint64_t v49 = v38;
                int8x16_t v50 = v39;
                free(v20);
                int32x4_t v39 = v50;
                uint64_t v38 = v49;
              }
              if (v39 && v39 != (char *)v28 + 184)
              {
                uint64_t v51 = v38;
                free(v39);
                uint64_t v38 = v51;
              }
              if (v38) {
                (*(void (**)(uint64_t, void))(*(void *)a5 + 48))(a5, 0);
              }
              (*(void (**)(_DWORD *, uint64_t (*)()))(*(void *)a1 + 48))(a1, v48);
              return (uint64_t (**)())(v48 != 0);
            }
            goto LABEL_72;
          }
LABEL_71:
          uint64_t v38 = 0;
LABEL_72:
          BOOL v35 = 0;
          goto LABEL_61;
        }
        BOOL v35 = (uint64_t (*)())*((void *)v200 + 3);
        if (v35)
        {
          int v189 = v27;
          uint64_t v179 = v14;
          float v45 = *(double *)(a8 + 48);
          uint64_t v46 = *(void *)(a5 + 8);
          int v40 = *(_DWORD *)(a5 + 16);
          float v42 = *(float *)(a5 + 156) * v45;
          if (v46
            && v40 == *((_DWORD *)v28 + 43)
            && v46 == *((void *)v28 + 20)
            && v40 == *((_DWORD *)v28 + 42)
            && v42 == *((float *)v28 + 44))
          {
            uint64_t v44 = (uint64_t)v28 + 184;
            goto LABEL_81;
          }
          uint64_t v38 = a5 + 28;
          int v47 = *(_DWORD *)(a5 + 24);
          if (v47)
          {
            int32x4_t v43 = v196;
            if (v47 == 2)
            {
              uint64_t v173 = *(void *)(a5 + 8);
              uint64_t v41 = 4;
            }
            else
            {
              if (v47 != 1) {
                goto LABEL_71;
              }
              uint64_t v173 = *(void *)(a5 + 8);
              uint64_t v41 = 3;
            }
            goto LABEL_47;
          }
          uint64_t v173 = *(void *)(a5 + 8);
          uint64_t v41 = 1;
LABEL_46:
          int32x4_t v43 = v196;
LABEL_47:
          uint64_t v44 = ((uint64_t (*)(uint64_t (**)(), char *, uint64_t, uint64_t, uint64_t, void, float))v35)(v43, (char *)v28 + 184, 64, v41, v38, *(unsigned __int8 *)(a8 + 4), v42);
          if ((long long *)v44 == (long long *)((char *)v28 + 184))
          {
            if ((*((_DWORD *)v28 + 46) & 0xFFF00000) == 0x400000)
            {
              *((void *)v28 + 20) = v173;
              *((_DWORD *)v28 + 42) = v40;
              *((_DWORD *)v28 + 43) = v40;
              uint64_t v44 = (uint64_t)v28 + 184;
              *((float *)v28 + 44) = v42;
            }
            else
            {
              *((void *)v28 + 20) = 0;
              *((void *)v28 + 21) = 0;
              uint64_t v44 = (uint64_t)v28 + 184;
            }
          }
LABEL_81:
          int32x4_t v60 = a6;
          unint64_t v61 = (char *)v44;
          unsigned __int8 v58 = ripl_BltOpSourcePattern((uint64_t)v28, a1, v60, v44);
          uint64_t v14 = v179;
          char v172 = v61;
          if (v179)
          {
            uint64_t v59 = 0;
            int v192 = -1;
            int v27 = v189;
            if (!a7) {
              goto LABEL_102;
            }
          }
          else
          {
            int v27 = v189;
            if ((*(_DWORD *)v61 & 0xFFF00000) == 0x400000
              && (unint64_t v62 = *(void *)v12, v63 = a1[3], v63 <= (int)*(void *)v12)
              && (unint64_t v64 = HIDWORD(v62), v65 = a1[4], v65 <= SHIDWORD(v62))
              && (uint64_t v66 = *((void *)v12 + 1), (int)v62 + (int)v66 <= a1[5] + v63))
            {
              uint64_t v59 = 0;
              int v67 = (int)v64 + HIDWORD(v66) > a1[6] + v65;
            }
            else
            {
              uint64_t v59 = 0;
              int v67 = -1;
            }
            int v192 = v67;
            if (!a7) {
              goto LABEL_102;
            }
          }
          goto LABEL_90;
        }
      }
    }
LABEL_60:
    uint64_t v38 = 0;
LABEL_61:
    int32x4_t v39 = 0;
    goto LABEL_62;
  }
  return result;
}

uint64_t A8_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v203 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(v3 + 96);
  uint64_t v8 = *(void *)(v3 + 48);
  signed int v9 = (void *)*(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
  if ((int)v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v3;
  unint64_t v12 = *(unsigned int *)(v3 + 4);
  uint64_t v13 = (v12 - 1);
  if ((int)v12 < 1) {
    return 0;
  }
  int v14 = *(_DWORD *)(v3 + 8);
  uint64_t v15 = (v14 - 1);
  if (v14 < 1) {
    return 0;
  }
  uint64_t v16 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v16)
  {
    int v18 = *(_DWORD *)v3 & 0xFF00;
    if (v18 == 1024)
    {
      v202[0] = *(_DWORD *)(v3 + 4);
      v192[0] = v14;
      int v19 = *(_DWORD *)(v3 + 28);
      uint64_t v20 = *(void *)(v3 + 40);
      unsigned int v21 = **(unsigned __int8 **)(v3 + 88);
      uint64_t v22 = *(int *)(v3 + 12) + *(int *)(v3 + 16) * (uint64_t)v19;
      uint64_t v23 = v20 + v22;
      if (!v16)
      {
        char v25 = 0;
        uint64_t v46 = (unsigned char *)(v20 + v22);
        goto LABEL_319;
      }
      shape_enum_clip_alloc(v2, v3, (int *)v16, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
      char v25 = v24;
      if (!v24) {
        return 1;
      }
      while (shape_enum_clip_next((uint64_t)v25, (int *)&v191 + 1, &v191, v202, v192))
      {
        uint64_t v46 = (unsigned char *)(v23 + (int)v191 * (uint64_t)v19 + SHIDWORD(v191));
        LODWORD(v12) = v202[0];
LABEL_319:
        uint64_t v148 = v19 - (uint64_t)(int)v12;
        switch((int)v9)
        {
          case 0:
            unsigned int v163 = v192[0];
            uint64_t v166 = (v192[0] - 1) * v19;
            if (v19 >= 0) {
              int v160 = v19;
            }
            else {
              int v160 = -v19;
            }
            if (v19 >= 0) {
              uint64_t v166 = 0;
            }
            int v165 = &v46[v166];
            int v164 = v12;
            int v161 = 0;
            goto LABEL_353;
          case 1:
            goto LABEL_347;
          case 2:
            goto LABEL_321;
          case 3:
            do
            {
              int v155 = v202[0];
              do
              {
                int v156 = *v46;
                if (*v46)
                {
                  LOBYTE(v157) = v21;
                  if (v156 != 255) {
                    unsigned int v157 = v21 - (((v156 ^ 0xFF) * v21 + (((v156 ^ 0xFF) * v21) >> 8) + 1) >> 8);
                  }
                }
                else
                {
                  LOBYTE(v157) = *v46;
                }
                *v46++ = v157;
                --v155;
              }
              while (v155);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 4:
            do
            {
              int v167 = v202[0];
              do
              {
                int v168 = *v46;
                if ((_BYTE)v168 == 0xFF)
                {
                  LOBYTE(v169) = 0;
                }
                else
                {
                  LOBYTE(v169) = v21;
                  if (~(_BYTE)v168 != 255) {
                    unsigned int v169 = v21 - ((v168 * v21 + ((v168 * v21) >> 8) + 1) >> 8);
                  }
                }
                *v46++ = v169;
                --v167;
              }
              while (v167);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 5:
            do
            {
              int v158 = v202[0];
              do
              {
                *uint64_t v46 = (unsigned __int16)(255 * *v46
                                        + ((255 * *v46) >> 8)
                                        + 1) >> 8;
                ++v46;
                --v158;
              }
              while (v158);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 6:
            do
            {
              int v170 = v202[0];
              do
              {
                int v171 = *v46;
                if ((_BYTE)v171 != 0xFF)
                {
                  LOBYTE(v172) = v21;
                  if (~(_BYTE)v171 != 255) {
                    int v172 = v171
                  }
                         + ((~(_BYTE)v171 * v21 + ((~(_BYTE)v171 * v21) >> 8) + 1) >> 8);
                  *uint64_t v46 = v172;
                }
                ++v46;
                --v170;
              }
              while (v170);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 7:
            do
            {
              int v173 = v202[0];
              do
              {
                *v46 -= (unsigned __int16)(*v46 * ~(_BYTE)v21
                                         + ((*v46 * ~(_BYTE)v21) >> 8)
                                         + 1) >> 8;
                ++v46;
                --v173;
              }
              while (v173);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 8:
            do
            {
              int v159 = v202[0];
              do
              {
                *v46 -= (unsigned __int16)(*v46 * (_WORD)v21 + ((*v46 * v21) >> 8) + 1) >> 8;
                ++v46;
                --v159;
              }
              while (v159);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 9:
            uint64_t v186 = v23;
            char v190 = v9;
            int v174 = v192[0];
            uint64_t v175 = (v12 - 1);
            do
            {
              memset(v46, (255 * v21 + ((255 * v21) >> 8) + 1) >> 8, v175 + 1);
              v46 += v175 + v148 + 1;
              --v174;
            }
            while (v174);
            v192[0] = 0;
            signed int v9 = v190;
            uint64_t v23 = v186;
            break;
          case 10:
            do
            {
              int v176 = v202[0];
              do
              {
                *uint64_t v46 = (unsigned __int16)((*v46 ^ 0xFF) * v21
                                        + *v46 * ~(_BYTE)v21
                                        + (((*v46 ^ 0xFF) * v21
                                          + *v46 * ~(_BYTE)v21) >> 8)
                                        + 1) >> 8;
                ++v46;
                --v176;
              }
              while (v176);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 11:
            do
            {
              int v177 = v202[0];
              do
              {
                unsigned int v178 = *v46 + v21;
                if (v178 >= 0xFF) {
                  LOBYTE(v178) = -1;
                }
                *v46++ = v178;
                --v177;
              }
              while (v177);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 12:
            do
            {
              int v179 = v202[0];
              do
              {
                unsigned int v180 = *v46 + v21;
                if (v180 >= 0xFF) {
                  LOBYTE(v180) = -1;
                }
                *v46++ = v180;
                --v179;
              }
              while (v179);
              v46 += v148;
              --v192[0];
            }
            while (v192[0]);
            break;
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
            if (*(void *)(v11 + 96))
            {
LABEL_321:
              uint16x4_t v149 = (uint16x4_t)vdup_n_s16(v21);
              uint16x4_t v150 = (uint16x4_t)vdup_n_s16(~(_BYTE)v21);
              do
              {
                int v151 = v202[0];
                if (v202[0] >= 4)
                {
                  unsigned int v152 = (v202[0] >> 2) + 1;
                  do
                  {
                    v5.i32[0] = *(_DWORD *)v46;
                    uint32x4_t v153 = vmull_u16(v150, (uint16x4_t)*(_OWORD *)&vmovl_u8(v5));
                    *(uint16x4_t *)v6.i8 = vsra_n_u16(v149, (uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32(v153, v153, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
                    uint8x8_t v5 = (uint8x8_t)vmovn_s16(v6);
                    *(_DWORD *)uint64_t v46 = v5.i32[0];
                    v46 += 4;
                    --v152;
                  }
                  while (v152 > 1);
                  int v151 = v202[0] & 3;
                }
                if (v151 >= 1)
                {
                  unsigned int v154 = v151 + 1;
                  do
                  {
                    *uint64_t v46 = v21
                         + ((unsigned __int16)(*v46 * ~(_BYTE)v21
                                             + ((*v46 * ~(_BYTE)v21) >> 8)
                                             + 1) >> 8);
                    ++v46;
                    --v154;
                  }
                  while (v154 > 1);
                }
                v46 += v148;
                --v192[0];
              }
              while (v192[0]);
            }
            else
            {
LABEL_347:
              if (v19 < 0)
              {
                v46 += (v192[0] - 1) * v19;
                int v160 = -v19;
              }
              else
              {
                int v160 = v19;
              }
              int v161 = 0;
              unsigned int v162 = *(int **)(v11 + 88);
              if (v162) {
                int v161 = *v162;
              }
              unsigned int v163 = v192[0];
              int v164 = v12;
              int v165 = v46;
LABEL_353:
              CGBlt_fillBytes(v164, v163, v161, v165, v160);
            }
            break;
          default:
            break;
        }
        if (!v25) {
          return 1;
        }
        uint64_t v191 = 0;
      }
LABEL_45:
      uint64_t v56 = v25;
LABEL_310:
      free(v56);
      return 1;
    }
    v202[0] = *(_DWORD *)(v3 + 4);
    v192[0] = v14;
    uint64_t v26 = *(int *)(v3 + 28);
    unint64_t v27 = *(void *)(v3 + 88);
    unsigned int v28 = (unsigned char *)(*(void *)(v3 + 40) + *(int *)(v3 + 12) + *(int *)(v3 + 16) * (uint64_t)(int)v26);
    int v29 = *(_DWORD *)(v3 + 56);
    int v30 = *(_DWORD *)(v3 + 60);
    uint64_t v31 = *(int *)(v3 + 76);
    if (v18 != 256)
    {
      int v37 = *(_DWORD *)(v3 + 64);
      int v185 = *(_DWORD *)(v3 + 68);
      unint64_t v35 = v27 + v185 * (uint64_t)(int)v31;
      BOOL v183 = v7 != 0;
      if (v16)
      {
        int v181 = *(_DWORD *)(v3 + 60);
        int v182 = *(_DWORD *)(v3 + 56);
        uint64_t v184 = *(void *)(v3 + 40) + *(int *)(v3 + 12) + *(int *)(v3 + 16) * (uint64_t)(int)v26;
        uint64_t v34 = 1;
        __n128 v36 = *(unsigned char **)(v3 + 88);
        uint64_t v32 = v36;
        goto LABEL_29;
      }
      unint64_t v54 = v26 - v12;
      if (v27)
      {
        int v189 = 0;
        int v181 = v30 % v185;
        int v182 = v29 % v37;
        uint64_t v187 = *(void *)(v3 + 88);
        unint64_t v55 = v27 + (int)v31 * (uint64_t)(v30 % v185);
        uint64_t v32 = (unsigned char *)(v55 + v29 % v37);
        unint64_t v27 = v55 + v37;
        uint64_t v34 = 1;
        uint64_t v184 = *(void *)(v3 + 40) + *(int *)(v3 + 12) + *(int *)(v3 + 16) * (uint64_t)(int)v26;
        __n128 v36 = v32;
        goto LABEL_46;
      }
      int v181 = *(_DWORD *)(v3 + 60);
      int v182 = *(_DWORD *)(v3 + 56);
      uint64_t v32 = 0;
      uint64_t v34 = 1;
      unint64_t v53 = v12;
LABEL_43:
      int v189 = 0;
      unint64_t v35 = 0;
      __n128 v36 = 0;
      v31 -= v53;
      uint64_t v187 = (uint64_t)v32;
      uint64_t v184 = (uint64_t)v28;
      goto LABEL_46;
    }
    uint64_t v32 = (unsigned char *)(v27 + v29 + (int)v31 * (uint64_t)v30);
    if (v31 == v26 && v28 - v32 >= 1)
    {
      if (v28 - v32 <= v12)
      {
        v28 += v13;
        v32 += v13;
        uint64_t v34 = 0xFFFFFFFFLL;
        goto LABEL_21;
      }
      uint64_t v33 = &v32[v31 * v15];
      if (v28 <= &v33[v13])
      {
        v28 += v26 * v15;
        uint64_t v26 = -v26;
        uint64_t v31 = -v31;
        uint64_t v34 = 1;
        uint64_t v32 = v33;
        goto LABEL_21;
      }
    }
    uint64_t v34 = 1;
LABEL_21:
    BOOL v183 = v7 != 0;
    int v181 = *(_DWORD *)(v3 + 60);
    int v182 = *(_DWORD *)(v3 + 56);
    if (v16)
    {
      uint64_t v184 = (uint64_t)v28;
      int v185 = 0;
      unint64_t v35 = 0;
      __n128 v36 = 0;
      unint64_t v27 = -1;
      int v37 = v31;
LABEL_29:
      uint64_t v44 = v34;
      uint64_t v188 = v26;
      shape_enum_clip_alloc((uint64_t)v28, v3, (int *)v16, v34, v26, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
      if (!v45) {
        return 1;
      }
      while (2)
      {
        int v189 = (void *)v45;
        if (!shape_enum_clip_next(v45, (int *)&v191 + 1, &v191, v202, v192))
        {
          uint64_t v56 = v189;
          goto LABEL_310;
        }
        uint64_t v187 = (uint64_t)v32;
        if (v35)
        {
          uint64_t v26 = v188;
          unsigned int v28 = (unsigned char *)(v184 + v188 * (int)v191 + SHIDWORD(v191));
          LODWORD(v12) = v202[0];
          int v63 = &v32[v31 * (((int)v191 + *(_DWORD *)(v11 + 60)) % v185)];
          uint64_t v32 = &v63[(HIDWORD(v191) + *(_DWORD *)(v11 + 56)) % v37];
          unint64_t v27 = (unint64_t)&v63[v37];
          int v64 = v202[0];
          int v181 = ((int)v191 + *(_DWORD *)(v11 + 60)) % v185;
          int v182 = (HIDWORD(v191) + *(_DWORD *)(v11 + 56)) % v37;
          __n128 v36 = v32;
          uint64_t v34 = v44;
        }
        else
        {
          LODWORD(v12) = v202[0];
          uint64_t v34 = v44;
          int v64 = v202[0] * v44;
          uint64_t v26 = v188;
          unsigned int v28 = (unsigned char *)(v184 + v188 * (int)v191 + SHIDWORD(v191) * (uint64_t)(int)v44);
          v32 += (int)v191 * (uint64_t)v37 + SHIDWORD(v191) * (uint64_t)(int)v44;
          uint64_t v31 = v37 - v202[0] * (int)v44;
        }
        unint64_t v54 = v26 - v64;
LABEL_46:
        uint64_t v188 = v26;
        switch((int)v9)
        {
          case 0:
            uint64_t v84 = v54 - (int)v12;
            uint64_t v85 = v54 + (int)v12;
            uint64_t v44 = v34;
            if ((int)v34 >= 0)
            {
              BOOL v86 = v28;
            }
            else
            {
              uint64_t v85 = v84;
              BOOL v86 = &v28[-(int)v12 + 1];
            }
            if (v85 >= 0) {
              LODWORD(v87) = v85;
            }
            else {
              uint64_t v87 = -v85;
            }
            CGBlt_fillBytes(v12, v192[0], 0, &v86[(v85 * (v192[0] - 1)) & (v85 >> 63)], v87);
            goto LABEL_67;
          case 1:
            goto LABEL_75;
          case 2:
            goto LABEL_48;
          case 3:
            do
            {
              int v88 = v202[0];
              do
              {
                unsigned int v89 = *v28;
                if (*v28)
                {
                  if (v89 == 255) {
                    LOBYTE(v89) = *v32;
                  }
                  else {
                    unsigned int v89 = *v32
                  }
                        - ((*v32 * (v89 ^ 0xFF) + ((*v32 * (v89 ^ 0xFF)) >> 8) + 1) >> 8);
                }
                *unsigned int v28 = v89;
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v90 = -(uint64_t)v37;
                }
                else {
                  uint64_t v90 = 0;
                }
                v32 += (int)v34 + v90;
                --v88;
              }
              while (v88);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v91 = -(v31 * v185);
              }
              else {
                uint64_t v91 = 0;
              }
              int v92 = &v36[v31 + v91];
              unint64_t v93 = v27 + v31 + v91;
              if (v35) {
                uint64_t v32 = v92;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v92;
                unint64_t v27 = v93;
              }
              --v192[0];
            }
            while (v192[0]);
            goto LABEL_66;
          case 4:
            do
            {
              int v94 = v202[0];
              do
              {
                int v95 = *v28;
                if ((_BYTE)v95 == 0xFF)
                {
                  LOBYTE(v96) = 0;
                }
                else if (~(_BYTE)v95 == 255)
                {
                  LOBYTE(v96) = *v32;
                }
                else
                {
                  unsigned int v96 = *v32
                      - ((*v32 * v95 + ((*v32 * v95) >> 8) + 1) >> 8);
                }
                *unsigned int v28 = v96;
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v97 = -(uint64_t)v37;
                }
                else {
                  uint64_t v97 = 0;
                }
                v32 += (int)v34 + v97;
                --v94;
              }
              while (v94);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v98 = -(v31 * v185);
              }
              else {
                uint64_t v98 = 0;
              }
              int v99 = &v36[v31 + v98];
              unint64_t v100 = v27 + v31 + v98;
              if (v35) {
                uint64_t v32 = v99;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v99;
                unint64_t v27 = v100;
              }
              --v192[0];
            }
            while (v192[0]);
            goto LABEL_66;
          case 5:
            uint64_t v32 = (unsigned char *)v187;
            do
            {
              int v101 = v202[0];
              do
              {
                *unsigned int v28 = (unsigned __int16)(255 * *v28
                                        + ((255 * *v28) >> 8)
                                        + 1) >> 8;
                v28 += (int)v34;
                --v101;
              }
              while (v101);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v102 = -(v31 * v185);
              }
              else {
                uint64_t v102 = 0;
              }
              int v103 = &v36[v31 + v102];
              unint64_t v104 = v27 + v31 + v102;
              if (v35)
              {
                __n128 v36 = v103;
                unint64_t v27 = v104;
              }
              --v192[0];
            }
            while (v192[0]);
            uint64_t v44 = v34;
            goto LABEL_68;
          case 6:
            do
            {
              int v105 = v202[0];
              do
              {
                int v106 = *v28;
                if ((_BYTE)v106 != 0xFF)
                {
                  if (~(_BYTE)v106 == 255) {
                    LOBYTE(v107) = *v32;
                  }
                  else {
                    int v107 = v106
                  }
                         + ((*v32 * ~(_BYTE)v106
                           + ((*v32 * ~(_BYTE)v106) >> 8)
                           + 1) >> 8);
                  *unsigned int v28 = v107;
                }
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v108 = -(uint64_t)v37;
                }
                else {
                  uint64_t v108 = 0;
                }
                v32 += (int)v34 + v108;
                --v105;
              }
              while (v105);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v109 = -(v31 * v185);
              }
              else {
                uint64_t v109 = 0;
              }
              int v110 = &v36[v31 + v109];
              unint64_t v111 = v27 + v31 + v109;
              if (v35) {
                uint64_t v32 = v110;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v110;
                unint64_t v27 = v111;
              }
              --v192[0];
            }
            while (v192[0]);
            goto LABEL_66;
          case 7:
            while (1)
            {
              int v112 = v202[0];
              do
              {
                unsigned int v113 = *v32;
                if (*v32)
                {
                  if (v113 == 255) {
                    goto LABEL_211;
                  }
                  unsigned int v113 = *v28
                       - ((*v28 * (v113 ^ 0xFF) + ((*v28 * (v113 ^ 0xFF)) >> 8) + 1) >> 8);
                }
                *unsigned int v28 = v113;
LABEL_211:
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v114 = -(uint64_t)v37;
                }
                else {
                  uint64_t v114 = 0;
                }
                v32 += (int)v34 + v114;
                --v112;
              }
              while (v112);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v115 = -(v31 * v185);
              }
              else {
                uint64_t v115 = 0;
              }
              int v116 = &v36[v31 + v115];
              unint64_t v117 = v27 + v31 + v115;
              if (v35) {
                uint64_t v32 = v116;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v116;
                unint64_t v27 = v117;
              }
              if (!--v192[0]) {
                goto LABEL_66;
              }
            }
          case 8:
            break;
          case 9:
            do
            {
              int v125 = v202[0];
              do
              {
                *unsigned int v28 = (unsigned __int16)(255 * *v32
                                        + ((255 * *v32) >> 8)
                                        + 1) >> 8;
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v126 = -(uint64_t)v37;
                }
                else {
                  uint64_t v126 = 0;
                }
                v32 += (int)v34 + v126;
                --v125;
              }
              while (v125);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v127 = -(v31 * v185);
              }
              else {
                uint64_t v127 = 0;
              }
              int v128 = &v36[v31 + v127];
              unint64_t v129 = v27 + v31 + v127;
              if (v35) {
                uint64_t v32 = v128;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v128;
                unint64_t v27 = v129;
              }
              --v192[0];
            }
            while (v192[0]);
            goto LABEL_66;
          case 10:
            do
            {
              int v130 = v202[0];
              do
              {
                *unsigned int v28 = (unsigned __int16)((*v28 ^ 0xFF) * *v32
                                        + *v28 * (*v32 ^ 0xFF)
                                        + (((*v28 ^ 0xFF) * *v32
                                          + *v28 * (*v32 ^ 0xFFu)) >> 8)
                                        + 1) >> 8;
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v131 = -(uint64_t)v37;
                }
                else {
                  uint64_t v131 = 0;
                }
                v32 += (int)v34 + v131;
                --v130;
              }
              while (v130);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v132 = -(v31 * v185);
              }
              else {
                uint64_t v132 = 0;
              }
              int v133 = &v36[v31 + v132];
              unint64_t v134 = v27 + v31 + v132;
              if (v35) {
                uint64_t v32 = v133;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v133;
                unint64_t v27 = v134;
              }
              --v192[0];
            }
            while (v192[0]);
            goto LABEL_66;
          case 11:
            do
            {
              int v135 = v202[0];
              do
              {
                unsigned int v136 = *v32 + *v28;
                if (v136 >= 0xFF) {
                  LOBYTE(v136) = -1;
                }
                *unsigned int v28 = v136;
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v137 = -(uint64_t)v37;
                }
                else {
                  uint64_t v137 = 0;
                }
                v32 += (int)v34 + v137;
                --v135;
              }
              while (v135);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v138 = -(v31 * v185);
              }
              else {
                uint64_t v138 = 0;
              }
              int v139 = &v36[v31 + v138];
              unint64_t v140 = v27 + v31 + v138;
              if (v35) {
                uint64_t v32 = v139;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v139;
                unint64_t v27 = v140;
              }
              --v192[0];
            }
            while (v192[0]);
            goto LABEL_66;
          case 12:
            do
            {
              int v141 = v202[0];
              do
              {
                unsigned int v142 = *v32 + *v28;
                if (v142 >= 0xFF) {
                  LOBYTE(v142) = -1;
                }
                *unsigned int v28 = v142;
                v28 += (int)v34;
                if ((unint64_t)&v32[(int)v34] >= v27) {
                  uint64_t v143 = -(uint64_t)v37;
                }
                else {
                  uint64_t v143 = 0;
                }
                v32 += (int)v34 + v143;
                --v141;
              }
              while (v141);
              v28 += v54;
              if ((unint64_t)&v36[v31] >= v35) {
                uint64_t v144 = -(v31 * v185);
              }
              else {
                uint64_t v144 = 0;
              }
              unsigned int v145 = &v36[v31 + v144];
              unint64_t v146 = v27 + v31 + v144;
              if (v35) {
                uint64_t v32 = v145;
              }
              else {
                v32 += v31;
              }
              if (v35)
              {
                __n128 v36 = v145;
                unint64_t v27 = v146;
              }
              --v192[0];
            }
            while (v192[0]);
            goto LABEL_66;
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
            if (v183)
            {
              do
              {
LABEL_48:
                int v57 = v202[0];
                do
                {
                  int v58 = *v32;
                  if (*v32)
                  {
                    if (v58 != 255) {
                      v58 += (*v28 * (v58 ^ 0xFF) + ((*v28 * (v58 ^ 0xFFu)) >> 8) + 1) >> 8;
                    }
                    *unsigned int v28 = v58;
                  }
                  v28 += (int)v34;
                  if ((unint64_t)&v32[(int)v34] >= v27) {
                    uint64_t v59 = -(uint64_t)v37;
                  }
                  else {
                    uint64_t v59 = 0;
                  }
                  v32 += (int)v34 + v59;
                  --v57;
                }
                while (v57);
                v28 += v54;
                if ((unint64_t)&v36[v31] >= v35) {
                  uint64_t v60 = -(v31 * v185);
                }
                else {
                  uint64_t v60 = 0;
                }
                unint64_t v61 = &v36[v31 + v60];
                unint64_t v62 = v27 + v31 + v60;
                if (v35) {
                  uint64_t v32 = v61;
                }
                else {
                  v32 += v31;
                }
                if (v35)
                {
                  __n128 v36 = v61;
                  unint64_t v27 = v62;
                }
                --v192[0];
              }
              while (v192[0]);
            }
            else
            {
LABEL_75:
              int v65 = *(unsigned __int8 *)(v11 + 1);
              if (v65 == 2)
              {
                if ((int)v12 >= 32 && v37 <= 0x40)
                {
                  v4.i32[0] = v37;
                  uint8x8_t v68 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v4.i8);
                  v68.i16[0] = vaddlv_u8(v68);
                  if (v68.i32[0] <= 1u)
                  {
                    uint64_t v44 = v34;
                    uint64_t v32 = (unsigned char *)v187;
                    CGSFillDRAM64((unint64_t)v28, v12 + v54, v12, v192[0], v187, v31, v37, v185, v182, v181);
                    goto LABEL_68;
                  }
                }
LABEL_84:
                if (v8 == 0 || v183)
                {
                  do
                  {
                    int v69 = v202[0];
                    do
                    {
                      *unsigned int v28 = *v32;
                      v28 += (int)v34;
                      if ((unint64_t)&v32[(int)v34] >= v27) {
                        uint64_t v70 = -(uint64_t)v37;
                      }
                      else {
                        uint64_t v70 = 0;
                      }
                      v32 += (int)v34 + v70;
                      --v69;
                    }
                    while (v69);
                    v28 += v54;
                    if ((unint64_t)&v36[v31] >= v35) {
                      uint64_t v71 = -(v31 * v185);
                    }
                    else {
                      uint64_t v71 = 0;
                    }
                    int v72 = &v36[v31 + v71];
                    unint64_t v73 = v27 + v31 + v71;
                    if (v35) {
                      uint64_t v32 = v72;
                    }
                    else {
                      v32 += v31;
                    }
                    if (v35)
                    {
                      __n128 v36 = v72;
                      unint64_t v27 = v73;
                    }
                    --v192[0];
                  }
                  while (v192[0]);
                }
                else
                {
                  do
                  {
                    int v74 = v202[0];
                    do
                    {
                      *unsigned int v28 = *v32;
                      v28 += (int)v34;
                      if ((unint64_t)&v32[(int)v34] >= v27) {
                        uint64_t v75 = -(uint64_t)v37;
                      }
                      else {
                        uint64_t v75 = 0;
                      }
                      v32 += (int)v34 + v75;
                      --v74;
                    }
                    while (v74);
                    v28 += v54;
                    if ((unint64_t)&v36[v31] >= v35) {
                      uint64_t v76 = -(v31 * v185);
                    }
                    else {
                      uint64_t v76 = 0;
                    }
                    __int32 v77 = &v36[v31 + v76];
                    unint64_t v78 = v27 + v31 + v76;
                    if (v35) {
                      uint64_t v32 = v77;
                    }
                    else {
                      v32 += v31;
                    }
                    if (v35)
                    {
                      __n128 v36 = v77;
                      unint64_t v27 = v78;
                    }
                    --v192[0];
                  }
                  while (v192[0]);
                }
                goto LABEL_66;
              }
              if (v65 != 1) {
                goto LABEL_84;
              }
              if (v8 == 0 || v183)
              {
                uint64_t v44 = v34;
                if ((v34 & 0x80000000) != 0)
                {
                  uint64_t v66 = v31 - (int)v12;
                  v32 += -(int)v12 + 1;
                  uint64_t v67 = v54 - (int)v12;
                  v28 += -(int)v12 + 1;
                }
                else
                {
                  uint64_t v66 = v31 + (int)v12;
                  uint64_t v67 = v54 + (int)v12;
                }
                if (v66 >= 0) {
                  uint64_t v31 = v66;
                }
                else {
                  uint64_t v31 = -v66;
                }
                if (v67 >= 0) {
                  LODWORD(v147) = v67;
                }
                else {
                  uint64_t v147 = -v67;
                }
                CGBlt_copyBytes(v12, v192[0], &v32[(v66 * (v192[0] - 1)) & (v66 >> 63)], &v28[(v67 * (v192[0] - 1)) & (v67 >> 63)], v31, v147);
                goto LABEL_67;
              }
              do
              {
                int v79 = v202[0];
                do
                {
                  *unsigned int v28 = *v32;
                  v28 += (int)v34;
                  if ((unint64_t)&v32[(int)v34] >= v27) {
                    uint64_t v80 = -(uint64_t)v37;
                  }
                  else {
                    uint64_t v80 = 0;
                  }
                  v32 += (int)v34 + v80;
                  --v79;
                }
                while (v79);
                v28 += v54;
                if ((unint64_t)&v36[v31] >= v35) {
                  uint64_t v81 = -(v31 * v185);
                }
                else {
                  uint64_t v81 = 0;
                }
                int16x4_t v82 = &v36[v31 + v81];
                unint64_t v83 = v27 + v31 + v81;
                if (v35) {
                  uint64_t v32 = v82;
                }
                else {
                  v32 += v31;
                }
                if (v35)
                {
                  __n128 v36 = v82;
                  unint64_t v27 = v83;
                }
                --v192[0];
              }
              while (v192[0]);
            }
LABEL_66:
            uint64_t v44 = v34;
LABEL_67:
            uint64_t v32 = (unsigned char *)v187;
LABEL_68:
            uint64_t v45 = (uint64_t)v189;
            if (!v189) {
              return 1;
            }
            uint64_t v191 = 0;
            continue;
          default:
            goto LABEL_66;
        }
        break;
      }
LABEL_225:
      int v118 = v202[0];
      while (1)
      {
        int v119 = *v32;
        if ((_BYTE)v119 == 0xFF) {
          break;
        }
        if (~(_BYTE)v119 != 255)
        {
          unsigned int v120 = *v28
               - ((*v28 * v119 + ((*v28 * v119) >> 8) + 1) >> 8);
LABEL_230:
          *unsigned int v28 = v120;
        }
        v28 += (int)v34;
        if ((unint64_t)&v32[(int)v34] >= v27) {
          uint64_t v121 = -(uint64_t)v37;
        }
        else {
          uint64_t v121 = 0;
        }
        v32 += (int)v34 + v121;
        if (!--v118)
        {
          v28 += v54;
          if ((unint64_t)&v36[v31] >= v35) {
            uint64_t v122 = -(v31 * v185);
          }
          else {
            uint64_t v122 = 0;
          }
          int v123 = &v36[v31 + v122];
          unint64_t v124 = v27 + v31 + v122;
          if (v35) {
            uint64_t v32 = v123;
          }
          else {
            v32 += v31;
          }
          if (v35)
          {
            __n128 v36 = v123;
            unint64_t v27 = v124;
          }
          if (!--v192[0]) {
            goto LABEL_66;
          }
          goto LABEL_225;
        }
      }
      LOBYTE(v120) = 0;
      goto LABEL_230;
    }
    int v185 = 0;
    unint64_t v53 = (int)v34 * (int)v12;
    unint64_t v54 = v26 - v53;
    unint64_t v27 = -1;
    int v37 = v31;
    goto LABEL_43;
  }
  int v17 = *(_DWORD *)(v3 + 128);
  if ((v17 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      A8_mark_constmask(v3, (int)v9, v4);
    }
    else {
      A8_mark_pixelmask(v3, (int)v9);
    }
    return 1;
  }
  int v38 = *(_DWORD *)(v3 + 112);
  int v39 = *(_DWORD *)(v3 + 116);
  unsigned int v40 = (v38 + 15) & 0xFFFFFFF0;
  size_t v41 = v40 * v39;
  if ((int)v41 <= 4096)
  {
    int v43 = (int)v9;
    char v25 = v202;
LABEL_33:
    CGSConvertBitsToMask(v16, *(_DWORD *)(v11 + 124), v25, v40, v38, v39, v17);
    long long v47 = *(_OWORD *)(v11 + 112);
    long long v198 = *(_OWORD *)(v11 + 96);
    long long v199 = v47;
    long long v48 = *(_OWORD *)(v11 + 144);
    long long v200 = *(_OWORD *)(v11 + 128);
    long long v201 = v48;
    long long v49 = *(_OWORD *)(v11 + 48);
    long long v194 = *(_OWORD *)(v11 + 32);
    long long v195 = v49;
    long long v50 = *(_OWORD *)(v11 + 80);
    long long v196 = *(_OWORD *)(v11 + 64);
    long long v197 = v50;
    int32x4_t v51 = *(int32x4_t *)v11;
    long long v52 = *(_OWORD *)(v11 + 16);
    *(_OWORD *)int v192 = *(_OWORD *)v11;
    long long v193 = v52;
    HIDWORD(v199) = (v38 + 15) & 0xFFFFFFF0;
    *((void *)&v200 + 1) = v25;
    if (BYTE1(v192[0]) << 8 == 1024) {
      A8_mark_constmask((uint64_t)v192, v43, v51);
    }
    else {
      A8_mark_pixelmask((uint64_t)v192, v43);
    }
    if (v25 == (unsigned char *)v202) {
      return 1;
    }
    goto LABEL_45;
  }
  float v42 = malloc_type_malloc(v41, 0x3EE52DA4uLL);
  if (v42)
  {
    char v25 = v42;
    int v43 = (int)v9;
    uint64_t v16 = *(uint16x4_t **)(v11 + 136);
    int v17 = *(_DWORD *)(v11 + 128);
    goto LABEL_33;
  }
  return 1;
}

uint64_t A8_mark(uint64_t a1, __n128 a2)
{
  return A8_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

uint64_t A8_mark_constmask(uint64_t result, int a2, int32x4_t a3)
{
  uint64_t v4 = result;
  int v6 = *(_DWORD *)(result + 4);
  int v5 = *(_DWORD *)(result + 8);
  uint64_t v7 = *(int *)(result + 28);
  uint64_t v8 = *(void *)(result + 40);
  uint64_t v9 = *(void *)(result + 136);
  unsigned int v10 = **(unsigned __int8 **)(result + 88);
  if (A8_cacheColor && *(unsigned __int8 *)(A8_cacheColor + 16) == v10)
  {
    uint64_t v11 = (unsigned char *)(A8_cacheColor + 8);
  }
  else
  {
    pthread_mutex_lock(&A8_colorlookup(int,void const*,void const*)::A8_cacheColorMutex);
    unint64_t v12 = 0;
    uint64_t v13 = A8_cacheColor;
    while (1)
    {
      if (!v13) {
        goto LABEL_9;
      }
      int v14 = v12;
      unint64_t v12 = (char *)v13;
      if (*(unsigned __int8 *)(v13 + 16) == v10) {
        break;
      }
      uint64_t v13 = *(void *)v13;
      if (!*(void *)v12)
      {
        if (A8_cacheColorCount > 6)
        {
          *(void *)int v14 = 0;
        }
        else
        {
LABEL_9:
          uint64_t v15 = (char *)A8_cacheColorBase;
          if (A8_cacheColorBase)
          {
            unsigned int v16 = A8_cacheColorCount;
          }
          else
          {
            uint64_t v15 = (char *)malloc_type_calloc(1uLL, 0x7A8uLL, 0x1020040071ED649uLL);
            unsigned int v16 = 0;
            A8_cacheColorBase = (uint64_t)v15;
          }
          unint64_t v12 = &v15[24 * v16];
          *((void *)v12 + 1) = &v15[256 * (unint64_t)v16 + 168];
          A8_cacheColorCount = v16 + 1;
        }
        *(void *)unint64_t v12 = A8_cacheColor;
        A8_cacheColor = (uint64_t)v12;
        uint64_t result = pthread_mutex_unlock(&A8_colorlookup(int,void const*,void const*)::A8_cacheColorMutex);
        uint64_t v17 = 0;
        a3 = (int32x4_t)xmmword_1850CDF90;
        int32x4_t v18 = (int32x4_t)xmmword_1850CDFA0;
        int32x4_t v19 = (int32x4_t)xmmword_1850CDCC0;
        int32x4_t v20 = (int32x4_t)xmmword_1850CDC50;
        uint64_t v22 = *((void *)v12 + 1);
        uint64_t v11 = v12 + 8;
        uint64_t v21 = v22;
        v23.i64[0] = 0xFF000000FFLL;
        v23.i64[1] = 0xFF000000FFLL;
        v11[8] = v10;
        int32x4_t v24 = vdupq_n_s32(v10);
        v25.i64[0] = 0x1000000010;
        v25.i64[1] = 0x1000000010;
        int8x16_t v26 = vdupq_n_s8(v10);
        do
        {
          int8x16_t v27 = (int8x16_t)vmulq_s32((int32x4_t)veorq_s8((int8x16_t)v20, v23), v24);
          uint32x4_t v28 = (uint32x4_t)vmulq_s32((int32x4_t)veorq_s8((int8x16_t)v19, v23), v24);
          int8x16_t v29 = (int8x16_t)vmulq_s32((int32x4_t)veorq_s8((int8x16_t)v18, v23), v24);
          uint32x4_t v30 = (uint32x4_t)vmulq_s32((int32x4_t)veorq_s8((int8x16_t)a3, v23), v24);
          *(uint16x4_t *)v27.i8 = vshr_n_u16((uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)v27, (uint32x4_t)v27, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
          v27.u64[1] = (unint64_t)vshr_n_u16((uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32(v28, v28, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
          *(uint16x4_t *)v29.i8 = vshr_n_u16((uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)v29, (uint32x4_t)v29, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
          v29.u64[1] = (unint64_t)vshr_n_u16((uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32(v30, v30, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
          *(int8x16_t *)(v21 + v17) = vsubq_s8(v26, vuzp1q_s8(v27, v29));
          v17 += 16;
          int32x4_t v20 = vaddq_s32(v20, v25);
          int32x4_t v19 = vaddq_s32(v19, v25);
          int32x4_t v18 = vaddq_s32(v18, v25);
          a3 = vaddq_s32(a3, v25);
        }
        while (v17 != 256);
        goto LABEL_19;
      }
    }
    if (v14)
    {
      *(void *)int v14 = *(void *)v13;
      *(void *)uint64_t v13 = A8_cacheColor;
      A8_cacheColor = v13;
    }
    uint64_t result = pthread_mutex_unlock(&A8_colorlookup(int,void const*,void const*)::A8_cacheColorMutex);
    uint64_t v11 = v12 + 8;
  }
LABEL_19:
  if (v9)
  {
    uint64_t v31 = *(void *)v11;
    unsigned int v32 = *(unsigned __int8 *)(*(void *)v11 + 255);
    uint64_t v33 = (unsigned __int8 *)(v8 + *(int *)(v4 + 12) + *(int *)(v4 + 16) * (uint64_t)(int)v7);
    uint64_t v34 = *(int *)(v4 + 124);
    unint64_t v35 = v9 + *(int *)(v4 + 104) + *(int *)(v4 + 108) * (uint64_t)(int)v34;
    uint64_t v36 = v34 - v6;
    uint64_t v37 = v7 - v6;
    switch(a2)
    {
      case 0:
        do
        {
          int v53 = v6;
          do
          {
            int v54 = *(unsigned __int8 *)v35;
            if (*(unsigned char *)v35)
            {
              if (v54 == 255) {
                LOBYTE(v55) = 0;
              }
              else {
                unsigned int v55 = *v33 - ((*v33 * v54 + ((*v33 * v54) >> 8) + 1) >> 8);
              }
              *uint64_t v33 = v55;
            }
            ++v35;
            ++v33;
            --v53;
          }
          while (v53);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 1:
        goto LABEL_98;
      case 2:
        goto LABEL_22;
      case 3:
        do
        {
          int v56 = v6;
          do
          {
            int v57 = *(unsigned __int8 *)v35;
            if (*(unsigned char *)v35)
            {
              if (v57 == 255) {
                LOBYTE(v58) = *(unsigned char *)(v31 + *v33);
              }
              else {
                unsigned int v58 = *(unsigned __int8 *)(v31
              }
                                         + ((unint64_t)(*v33 * v57 + ((*v33 * v57) >> 8) + 1) >> 8))
                    + ((*v33 * (v57 ^ 0xFF) + ((*v33 * (v57 ^ 0xFFu)) >> 8) + 1) >> 8);
              *uint64_t v33 = v58;
            }
            ++v35;
            ++v33;
            --v56;
          }
          while (v56);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 4:
        do
        {
          int v59 = v6;
          do
          {
            int v60 = *(unsigned __int8 *)v35;
            if (*(unsigned char *)v35)
            {
              if (v60 == 255) {
                LOBYTE(v61) = *(unsigned char *)(v31 + ~*v33);
              }
              else {
                unsigned int v61 = *(unsigned __int8 *)(v31
              }
                                         + ((unint64_t)((*v33 ^ 0xFF) * v60 + (((*v33 ^ 0xFFu) * v60) >> 8) + 1) >> 8))
                    + ((*v33 * (v60 ^ 0xFF) + ((*v33 * (v60 ^ 0xFFu)) >> 8) + 1) >> 8);
              *uint64_t v33 = v61;
            }
            ++v35;
            ++v33;
            --v59;
          }
          while (v59);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 5:
        do
        {
          uint64_t v86 = 0;
          do
          {
            if (*(unsigned char *)(v35 + v86)) {
              v33[v86] = (unsigned __int16)(255 * v33[v86] + ((255 * v33[v86]) >> 8) + 1) >> 8;
            }
            ++v86;
          }
          while (v6 != v86);
          v35 += (v6 - 1) + 1 + v36;
          v33 += v86 + v37;
          --v5;
        }
        while (v5);
        return result;
      case 6:
        do
        {
          int v87 = v6;
          do
          {
            uint64_t v88 = *(unsigned __int8 *)v35;
            if (*(unsigned char *)v35)
            {
              int v89 = *v33;
              if ((_BYTE)v89 != 0xFF)
              {
                if (~(_BYTE)v89 == 255) {
                  LOBYTE(v88) = *(unsigned char *)(v31 + v88);
                }
                else {
                  LODWORD(v88) = v89
                }
                               + ((*(unsigned __int8 *)(v31 + v88) * ~(_BYTE)v89
                                 + ((*(unsigned __int8 *)(v31 + v88) * ~(_BYTE)v89) >> 8)
                                 + 1) >> 8);
                *uint64_t v33 = v88;
              }
            }
            ++v35;
            ++v33;
            --v87;
          }
          while (v87);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 7:
        do
        {
          int v90 = v6;
          do
          {
            int v91 = *(unsigned __int8 *)v35;
            if (*(unsigned char *)v35)
            {
              LOBYTE(v92) = ~(_BYTE)v32;
              if (v91 != 255) {
                int v92 = v91 - ((v91 * v32 + ((v91 * v32) >> 8) + 1) >> 8);
              }
              *v33 -= (unsigned __int16)(*v33 * v92
                                       + ((*v33 * v92) >> 8)
                                       + 1) >> 8;
            }
            ++v35;
            ++v33;
            --v90;
          }
          while (v90);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 8:
        do
        {
          int v65 = v6;
          do
          {
            int v66 = *(unsigned __int8 *)v35;
            if (*(unsigned char *)v35)
            {
              int v67 = *v33;
              if (v66 == 255) {
                unsigned int v68 = v67 * v32;
              }
              else {
                unsigned int v68 = ((unsigned __int16)(v66 * v32 + ((v66 * v32) >> 8) + 1) >> 8) * v67;
              }
              *uint64_t v33 = v67 - ((unsigned __int16)(v68 + (v68 >> 8) + 1) >> 8);
            }
            ++v35;
            ++v33;
            --v65;
          }
          while (v65);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 9:
        do
        {
          int v62 = v6;
          do
          {
            uint64_t v63 = *(unsigned __int8 *)v35;
            if (*(unsigned char *)v35)
            {
              int v64 = *(unsigned __int8 *)(v31 + v63);
              *uint64_t v33 = (unsigned __int16)((*v33 ^ 0xFF) * v64
                                      + (v64 + ~(_BYTE)v63) * *v33
                                      + (((*v33 ^ 0xFF) * v64 + (v64 + ~(_BYTE)v63)
                                                              * *v33) >> 8)
                                      + 1) >> 8;
            }
            ++v35;
            ++v33;
            --v62;
          }
          while (v62);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 10:
        do
        {
          int v69 = v6;
          do
          {
            if (*(unsigned char *)v35)
            {
              int v70 = *(unsigned __int8 *)(v31 + *(unsigned __int8 *)v35);
              *uint64_t v33 = (unsigned __int16)((*v33 ^ 0xFF) * v70
                                      + *v33 * (v70 ^ 0xFF)
                                      + (((*v33 ^ 0xFF) * v70 + *v33 * (v70 ^ 0xFFu)) >> 8)
                                      + 1) >> 8;
            }
            ++v35;
            ++v33;
            --v69;
          }
          while (v69);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 11:
        do
        {
          int v93 = v6;
          do
          {
            if (*(unsigned char *)v35)
            {
              unsigned int v94 = *v33 + *(unsigned __int8 *)(v31 + *(unsigned __int8 *)v35);
              if (v94 >= 0xFF) {
                LOBYTE(v94) = -1;
              }
              *uint64_t v33 = v94;
            }
            ++v35;
            ++v33;
            --v93;
          }
          while (v93);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 12:
        do
        {
          int v95 = v6;
          do
          {
            if (*(unsigned char *)v35)
            {
              unsigned int v96 = *v33 + *(unsigned __int8 *)(v31 + *(unsigned __int8 *)v35);
              if (v96 >= 0xFF) {
                LOBYTE(v96) = -1;
              }
              *uint64_t v33 = v96;
            }
            ++v35;
            ++v33;
            --v95;
          }
          while (v95);
          v35 += v36;
          v33 += v37;
          --v5;
        }
        while (v5);
        return result;
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
        if (*(void *)(v4 + 96))
        {
LABEL_22:
          int v38 = -1;
          unsigned int v39 = v35 & 3;
          if ((v35 & 3) != 0)
          {
            v6 += v39;
            int v38 = -1 << (8 * v39);
            unint64_t v40 = v35 & 3;
            v35 &= 0xFFFFFFFFFFFFFFFCLL;
            v33 -= v40;
          }
          int v41 = ((_BYTE)v6 + (_BYTE)v35) & 3;
          if ((((_BYTE)v6 + (_BYTE)v35) & 3) != 0)
          {
            int v42 = 4 - v41;
            v39 += v42;
            int v41 = 0xFFFFFFFF >> (8 * v42);
            int v43 = v6 >= 4 ? -1 : v41;
            v38 &= v43;
            if (v6 < 4) {
              int v41 = 0;
            }
          }
          uint64_t v44 = v36 - v39;
          int v45 = ~(_BYTE)v32;
          uint64_t result = 255;
          uint64_t v46 = v37 - v39;
          while (1)
          {
            unsigned int v47 = *(_DWORD *)v35 & v38;
            int v48 = v41;
            int v49 = v6 >> 2;
            if (!v47) {
              goto LABEL_43;
            }
LABEL_32:
            if (v47 == -1) {
              break;
            }
            while (1)
            {
              if ((_BYTE)v47) {
                *uint64_t v33 = *(unsigned char *)(v31 + v47)
              }
                     + ((unsigned __int16)(*v33 * ~*(unsigned char *)(v31 + v47)
                                         + ((*v33
                                           * ~*(unsigned char *)(v31 + v47)) >> 8)
                                         + 1) >> 8);
              if ((v47 & 0xFF00) != 0) {
                v33[1] = *(unsigned char *)(v31 + BYTE1(v47))
              }
                       + ((unsigned __int16)(v33[1] * ~*(unsigned char *)(v31 + BYTE1(v47))
                                           + ((v33[1] * ~*(unsigned char *)(v31 + BYTE1(v47))) >> 8)
                                           + 1) >> 8);
              if ((v47 & 0xFF0000) != 0) {
                v33[2] = *(unsigned char *)(v31 + BYTE2(v47))
              }
                       + ((unsigned __int16)(v33[2] * ~*(unsigned char *)(v31 + BYTE2(v47))
                                           + ((v33[2] * ~*(unsigned char *)(v31 + BYTE2(v47))) >> 8)
                                           + 1) >> 8);
              if (HIBYTE(v47))
              {
                int v51 = *(unsigned __int8 *)(v31 + ((unint64_t)v47 >> 24));
                int v50 = v51 ^ 0xFF;
                goto LABEL_42;
              }
LABEL_43:
              while (1)
              {
                int v52 = v49;
                v33 += 4;
                --v49;
                v35 += 4;
                if (v52 < 2) {
                  break;
                }
                unsigned int v47 = *(_DWORD *)v35;
                if (*(_DWORD *)v35) {
                  goto LABEL_32;
                }
              }
              if (!v48) {
                break;
              }
              int v48 = 0;
              unsigned int v47 = *(_DWORD *)v35 & v41;
            }
            v35 += v44;
            v33 += v46;
            if (!--v5) {
              return result;
            }
          }
          *uint64_t v33 = v32 + ((unsigned __int16)(*v33 * (_WORD)v45 + ((*v33 * v45) >> 8) + 1) >> 8);
          v33[1] = v32 + ((unsigned __int16)(v33[1] * (_WORD)v45 + ((v33[1] * v45) >> 8) + 1) >> 8);
          v33[2] = v32 + ((unsigned __int16)(v33[2] * (_WORD)v45 + ((v33[2] * v45) >> 8) + 1) >> 8);
          int v50 = ~(_BYTE)v32;
          LOBYTE(v51) = v32;
LABEL_42:
          v33[3] = v51 + ((unsigned __int16)(v50 * v33[3] + ((v50 * v33[3]) >> 8) + 1) >> 8);
          goto LABEL_43;
        }
LABEL_98:
        int v71 = -1;
        unsigned int v72 = v35 & 3;
        if ((v35 & 3) != 0)
        {
          v6 += v72;
          int v71 = -1 << (8 * v72);
          unint64_t v73 = v35 & 3;
          v35 &= 0xFFFFFFFFFFFFFFFCLL;
          v33 -= v73;
        }
        uint64_t v74 = ((_BYTE)v6 + (_BYTE)v35) & 3;
        if ((((_BYTE)v6 + (_BYTE)v35) & 3) != 0)
        {
          int v75 = 4 - v74;
          v72 += v75;
          unsigned int v76 = 0xFFFFFFFF >> (8 * v75);
          if (v6 >= 4) {
            uint64_t v74 = v76;
          }
          else {
            uint64_t v74 = 0;
          }
          if (v6 >= 4) {
            unsigned int v76 = -1;
          }
          v71 &= v76;
        }
        uint64_t v77 = v36 - v72;
        uint64_t v78 = v37 - v72;
        *(int16x4_t *)a3.i8 = vdup_n_s16(v32);
        a3.i32[0] = vmovn_s16((int16x8_t)a3).u32[0];
        break;
      default:
        return result;
    }
    do
    {
      unsigned int v79 = *(_DWORD *)v35 & v71;
      int v80 = v6 >> 2;
      uint64_t result = v74;
      if (!v79) {
        goto LABEL_127;
      }
LABEL_109:
      if (v79 == -1)
      {
        *(_DWORD *)uint64_t v33 = a3.i32[0];
        goto LABEL_127;
      }
      while (1)
      {
        if ((_BYTE)v79)
        {
          LOBYTE(v81) = v32;
          if (v79 != 255) {
            unsigned int v81 = *(unsigned __int8 *)(v31 + v79)
          }
                + (((v79 ^ 0xFF) * *v33
                  + (((v79 ^ 0xFF) * *v33) >> 8)
                  + 1) >> 8);
          *uint64_t v33 = v81;
        }
        if (BYTE1(v79))
        {
          LOBYTE(v82) = v32;
          if (BYTE1(v79) != 255) {
            unsigned int v82 = *(unsigned __int8 *)(v31 + BYTE1(v79))
          }
                + (((BYTE1(v79) ^ 0xFF) * v33[1] + (((BYTE1(v79) ^ 0xFF) * v33[1]) >> 8) + 1) >> 8);
          v33[1] = v82;
        }
        if (BYTE2(v79))
        {
          LOBYTE(v83) = v32;
          if (BYTE2(v79) != 255) {
            unsigned int v83 = *(unsigned __int8 *)(v31 + BYTE2(v79))
          }
                + (((BYTE2(v79) ^ 0xFF) * v33[2] + (((BYTE2(v79) ^ 0xFF) * v33[2]) >> 8) + 1) >> 8);
          v33[2] = v83;
        }
        unint64_t v84 = (unint64_t)v79 >> 24;
        if (v84 == 255)
        {
          v33[3] = v32;
        }
        else if (HIBYTE(v79))
        {
          v33[3] = *(unsigned char *)(v31 + v84)
                 + ((unsigned __int16)((v84 ^ 0xFF) * v33[3] + (((v84 ^ 0xFF) * v33[3]) >> 8) + 1) >> 8);
        }
LABEL_127:
        while (1)
        {
          int v85 = v80;
          v33 += 4;
          --v80;
          v35 += 4;
          if (v85 < 2) {
            break;
          }
          unsigned int v79 = *(_DWORD *)v35;
          if (*(_DWORD *)v35) {
            goto LABEL_109;
          }
        }
        if (!result) {
          break;
        }
        uint64_t result = 0;
        unsigned int v79 = *(_DWORD *)v35 & v74;
      }
      v35 += v77;
      v33 += v78;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t RIPLayerBltImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a2;
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (a3) {
    unint64_t v12 = (_DWORD *)a3;
  }
  else {
    unint64_t v12 = (_DWORD *)a4;
  }
  if (a2 && !*(void *)(a2 + 72))
  {
    if (*(_DWORD *)(a2 + 64))
    {
      int v51 = (_DWORD *)(a2 + 12);
      if (v12 == (_DWORD *)(v10 + 12) || !ripl_IsContained(v12, v51))
      {
        char Mask = ripl_CreateMask(v10, 0, a3, a4, a5, a6, a7, a8);
        uint64_t result = 0;
        if ((Mask & 1) == 0) {
          return result;
        }
      }
      else
      {
        uint64_t v10 = 0;
      }
    }
    else if (!*(void *)(a2 + 56) && ripl_IsEnclosed(v12, (_DWORD *)(a2 + 12)))
    {
      uint64_t v10 = 0;
    }
  }
  uint64_t v83 = 0;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  uint64_t v13 = *(long long **)(a1 + 40);
  if (!v13)
  {
    *(void *)&long long v79 = 0;
    long long v77 = 0uLL;
    long long v78 = 0uLL;
    long long v75 = 0uLL;
    long long v76 = 0uLL;
    long long v73 = 0uLL;
    long long v74 = 0uLL;
    long long v71 = 0uLL;
    long long v72 = 0uLL;
    long long v69 = 0uLL;
    long long v70 = 0uLL;
    long long v67 = 0uLL;
    long long v68 = 0uLL;
    uint64_t v13 = &v65;
    long long v65 = 0uLL;
    long long v66 = 0uLL;
  }
  long long v55 = 0uLL;
  long long v56 = 0uLL;
  long long v53 = 0uLL;
  long long v54 = 0uLL;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(void *)a1 + 32))(a1, 32, v12);
  if (result)
  {
    if (!*(void *)result || !*(void *)(*(void *)result + 40)) {
      goto LABEL_30;
    }
    uint64_t v22 = *(_DWORD **)(*(void *)(a4 + 16) + 32);
    if (!v22) {
      uint64_t v22 = (_DWORD *)RIPGetDepthForLayerFormat(0, v15, v16, v17, v18, v19, v20, v21);
    }
    if (!*(void *)(a1 + 56) && !ripl_CreateMask(a1, 1, v16, v17, v18, v19, v20, v21)) {
      goto LABEL_30;
    }
    *(unsigned char *)uint64_t v13 = *(_DWORD *)a5;
    ripl_BltOpDestination((uint64_t)v13, (uint64_t)v12, a1);
    uint64_t v23 = *(void *)(a4 + 16);
    int v24 = *(_DWORD *)a4;
    int v25 = *(_DWORD *)(a4 + 4);
    int v26 = *(_DWORD *)(a4 + 8);
    int v27 = *(_DWORD *)(a4 + 12);
    *((unsigned char *)v13 + 1) = 1;
    *((_DWORD *)v13 + 14) = *v12 - v24;
    *((_DWORD *)v13 + 15) = v27 + v25 - (v12[1] + v12[3]);
    *((_DWORD *)v13 + 16) = v26;
    *((_DWORD *)v13 + 17) = v27;
    *((_DWORD *)v13 + 18) = *(_DWORD *)(v23 + 112);
    *((_DWORD *)v13 + 19) = *(_DWORD *)(v23 + 64);
    *((void *)v13 + 11) = *(void *)(v23 + 72);
    *((_DWORD *)v13 + 20) = *(_DWORD *)(v23 + 80);
    *((void *)v13 + 12) = *(void *)(v23 + 88);
    ripl_BltOpMask((uint64_t)v13, v12, v10);
    if (CGBlt_initialize((uint64_t)v13))
    {
      *(void *)&long long v55 = *(void *)(*(void *)(a4 + 16) + 56);
      int v28 = *(unsigned __int8 *)(a4 + 40) | (unsigned __int16)(*(_WORD *)(a5 + 4) << 8) | (HIBYTE(*(_WORD *)(a5 + 4)) << 16);
      LODWORD(v53) = *v22;
      DWORD1(v53) = v28;
      double v29 = *(double *)(a5 + 48);
      float v30 = 0.0;
      if (v29 >= 0.0)
      {
        float v30 = 1.0;
        if (v29 <= 1.0) {
          float v30 = v29;
        }
      }
      *((float *)&v53 + 2) = v30;
      uint64_t v31 = *(float64x2_t **)(a4 + 24);
      if (v31)
      {
        float32x4_t v63 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*v31), v31[1]);
        float32x2_t v64 = vcvt_f32_f64(v31[2]);
        uint64_t v31 = (float64x2_t *)&v63;
      }
      *((void *)&v54 + 1) = v31;
      unsigned int v32 = *(float **)(a4 + 48);
      if (v32)
      {
        int v33 = *(_DWORD *)(a1 + 24);
        int v34 = v33 + *(_DWORD *)(a1 + 16);
        double v35 = (double)*(int *)(a1 + 12);
        _D2 = (double)v33;
        float v37 = *(double *)v32;
        float v58 = v37;
        _Q3 = *(float64x2_t *)(v32 + 2);
        float32x2_t v59 = vneg_f32(vcvt_f32_f64(_Q3));
        double v39 = *((double *)v32 + 3);
        __asm { FMLA            D5, D2, V3.D[1] }
        *(float *)_Q3.f64 = v39;
        float v45 = _D5 - (double)v34;
        int v60 = LODWORD(_Q3.f64[0]);
        float v61 = v45;
        float v46 = v35 - (*((double *)v32 + 5) + v39 * (double)v33);
        float v62 = v46;
        unsigned int v32 = &v58;
      }
      *(void *)&long long v54 = v32;
      if (*(_WORD *)(a4 + 42)) {
        *((unsigned char *)v13 + 1) = 2;
      }
      unsigned int v47 = *(float64x2_t **)(a4 + 32);
      if (v47)
      {
        float32x2_t v48 = vcvt_f32_f64(vaddq_f64(*v47, v47[1]));
        v57[0] = vcvt_f32_f64(*v47);
        v57[1] = v48;
        unsigned int v47 = (float64x2_t *)v57;
      }
      uint64_t v49 = *(void *)(a4 + 16);
      uint64_t v50 = *(void *)(v49 + 96);
      *((void *)&v55 + 1) = v47;
      *(void *)&long long v56 = v50;
      *((void *)&v56 + 1) = *(void *)(v49 + 120);
      if (!(*(unsigned int (**)(uint64_t, long long *, long long *))(*(void *)a1 + 40))(a1, v13, &v53)) {
        unint64_t v12 = 0;
      }
    }
    else
    {
LABEL_30:
      unint64_t v12 = 0;
    }
    (*(void (**)(uint64_t, _DWORD *))(*(void *)a1 + 48))(a1, v12);
    return v12 != 0;
  }
  return result;
}

void *RIPLayerBltShape(int *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a5;
  uint64_t v11 = a4;
  unint64_t v12 = a3;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  v49[0] = 0;
  v49[1] = 0;
  uint64_t v68 = 0;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  if (!a2)
  {
    if (!a4)
    {
      if (!a3) {
        unint64_t v12 = a1 + 3;
      }
      goto LABEL_32;
    }
    goto LABEL_17;
  }
  if (!a4) {
    goto LABEL_16;
  }
  if (*(_DWORD *)(a4 + 64) || *(void *)(a4 + 56))
  {
    char v14 = ripl_Combine(a4, a2, 0);
    uint64_t result = 0;
    if ((v14 & 1) == 0) {
      return result;
    }
    goto LABEL_17;
  }
  uint64_t v16 = (int *)(a4 + 12);
  if (!a3)
  {
    unint64_t v12 = (int *)(a4 + 12);
    goto LABEL_16;
  }
  if (v16 == a3)
  {
LABEL_16:
    uint64_t v11 = a2;
    goto LABEL_17;
  }
  unint64_t v12 = (int *)v49;
  uint64_t v11 = a2;
  if ((CGSBoundsIntersection(v16, a3, v49) & 1) == 0) {
    return 0;
  }
LABEL_17:
  uint64_t v17 = (int *)(v11 + 12);
  if (!v12) {
    unint64_t v12 = (int *)(v11 + 12);
  }
  if (!*(_DWORD *)(v11 + 64))
  {
    if (*(void *)(v11 + 56)) {
      goto LABEL_32;
    }
    if (v12 == v17)
    {
      uint64_t v11 = 0;
      unint64_t v12 = v17;
      goto LABEL_32;
    }
    if (CGSBoundsIntersection((int *)(v11 + 12), v12, v49))
    {
      uint64_t v11 = 0;
      unint64_t v12 = (int *)v49;
      goto LABEL_32;
    }
    return 0;
  }
  if (!*(void *)(v11 + 72))
  {
    if (v12 == v17 || !ripl_IsContained(v12, v17))
    {
      char Mask = ripl_CreateMask(v11, 0, (uint64_t)a3, a4, a5, (uint64_t)a6, a7, a8);
      uint64_t result = 0;
      if ((Mask & 1) == 0) {
        return result;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
  }
LABEL_32:
  uint64_t v19 = (long long *)*((void *)a1 + 5);
  if (!v19)
  {
    *(void *)&long long v64 = 0;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    uint64_t v19 = &v50;
    long long v50 = 0u;
    long long v51 = 0u;
  }
  uint64_t result = (void *)(*(uint64_t (**)(int *, uint64_t, int *))(*(void *)a1 + 32))(a1, 32, v12);
  if (result)
  {
    int v26 = result;
    int v27 = (void *)*result;
    if (!*result
      || !v27[4]
      || !*((void *)a1 + 7) && !ripl_CreateMask((uint64_t)a1, 1, v20, v21, v22, v23, v24, v25))
    {
      goto LABEL_64;
    }
    *(unsigned char *)uint64_t v19 = *(_DWORD *)a7;
    v28.n128_f64[0] = ripl_BltOpDestination((uint64_t)v19, (uint64_t)v12, (uint64_t)a1);
    if (!v10)
    {
      float v30 = 0;
      uint64_t v31 = (uint64_t (*)(void *, char *, uint64_t, uint64_t, uint64_t, void, float))v27[3];
      if (!v31)
      {
LABEL_65:
        (*(void (**)(int *, int *))(*(void *)a1 + 48))(a1, v30);
        return (void *)(v30 != 0);
      }
      uint64_t v47 = 0;
      float32x2_t v48 = a6;
      uint64_t v46 = 0;
      uint64_t v32 = 0;
      float v33 = *(double *)(a7 + 48);
      uint64_t v34 = 0;
      goto LABEL_48;
    }
    double v29 = *(uint64_t (***)())v10;
    if (*(_UNKNOWN **)v10 != &ripc_class)
    {
      if (v29)
      {
        while (v29 != RIPLayer_ripl_class)
        {
          if (!*v29) {
            goto LABEL_64;
          }
          double v29 = (uint64_t (**)())((uint64_t (*)(__n128))*v29)(v28);
          float v30 = 0;
          if (!v29) {
            goto LABEL_65;
          }
        }
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(*(void *)v10 + 32))(v10, 16, v10 + 12, v28);
        if (v38)
        {
          uint64_t v45 = v38;
          if (*(void *)(*(void *)v38 + 8) != v27[1]
            || !*(void *)(v10 + 56) && !ripl_CreateMask(v10, 0, v39, v40, v41, v42, v43, v44))
          {
            float v30 = 0;
LABEL_78:
            (*(void (**)(uint64_t, void))(*(void *)v10 + 48))(v10, 0);
            goto LABEL_65;
          }
          uint64_t v47 = v10;
          ripl_BltOpSourceLayer((uint64_t)v19, v12, a1, a6, v10);
          double v35 = 0;
LABEL_69:
          ripl_BltOpMask((uint64_t)v19, v12, v11);
          if (CGBlt_initialize((uint64_t)v19))
          {
            if (((unsigned int (*)(void *, long long *))v27[4])(v26, v19)) {
              float v30 = v12;
            }
            else {
              float v30 = 0;
            }
          }
          else
          {
            float v30 = 0;
          }
          if (v35)
          {
            if (v35 != (char *)v19 + 184) {
              free(v35);
            }
          }
          uint64_t v10 = v47;
          if (!v45) {
            goto LABEL_65;
          }
          goto LABEL_78;
        }
      }
      goto LABEL_64;
    }
    uint64_t v31 = (uint64_t (*)(void *, char *, uint64_t, uint64_t, uint64_t, void, float))v27[3];
    if (!v31) {
      goto LABEL_64;
    }
    float32x2_t v48 = a6;
    float v36 = *(double *)(a7 + 48);
    float v30 = *(int **)(v10 + 8);
    float v33 = *(float *)(v10 + 156) * v36;
    if (v30
      && *(_DWORD *)(v10 + 20) == *((_DWORD *)v19 + 43)
      && v30 == *((int **)v19 + 20)
      && *(_DWORD *)(v10 + 16) == *((_DWORD *)v19 + 42)
      && v33 == *((float *)v19 + 44))
    {
      uint64_t v47 = v10;
      double v35 = (char *)v19 + 184;
LABEL_68:
      ripl_BltOpSourcePattern((uint64_t)v19, a1, v48, (uint64_t)v35);
      uint64_t v45 = 0;
      goto LABEL_69;
    }
    uint64_t v34 = v10 + 28;
    int v37 = *(_DWORD *)(v10 + 24);
    if (v37)
    {
      if (v37 != 2)
      {
        if (v37 == 1)
        {
          LODWORD(v46) = *(_DWORD *)(v10 + 20);
          HIDWORD(v46) = *(_DWORD *)(v10 + 16);
          uint64_t v47 = v10;
          uint64_t v32 = 3;
          goto LABEL_48;
        }
LABEL_64:
        float v30 = 0;
        goto LABEL_65;
      }
      LODWORD(v46) = *(_DWORD *)(v10 + 20);
      HIDWORD(v46) = *(_DWORD *)(v10 + 16);
      uint64_t v47 = v10;
      uint64_t v32 = 4;
    }
    else
    {
      LODWORD(v46) = *(_DWORD *)(v10 + 20);
      HIDWORD(v46) = *(_DWORD *)(v10 + 16);
      uint64_t v47 = v10;
      uint64_t v32 = 1;
    }
LABEL_48:
    double v35 = (char *)v31(v26, (char *)v19 + 184, 64, v32, v34, *(unsigned __int8 *)(a7 + 4), v33);
    if (v35 == (char *)v19 + 184)
    {
      if ((*((_DWORD *)v19 + 46) & 0xFFF00000) == 0x400000)
      {
        *((void *)v19 + 20) = v30;
        *((_DWORD *)v19 + 42) = HIDWORD(v46);
        *((_DWORD *)v19 + 43) = v46;
        double v35 = (char *)v19 + 184;
        *((float *)v19 + 44) = v33;
      }
      else
      {
        *((void *)v19 + 20) = 0;
        *((void *)v19 + 21) = 0;
        double v35 = (char *)v19 + 184;
      }
    }
    goto LABEL_68;
  }
  return result;
}

uint64_t ripl_Lock(uint64_t a1)
{
  return a1 + 32;
}

double ripl_BltOpDestination(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 4) = *(void *)(a2 + 8);
  double result = *(double *)(a3 + 20);
  *(double *)(a1 + 20) = result;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)a2 - *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a3 + 24) + *(_DWORD *)(a3 + 16) - (*(_DWORD *)(a2 + 4) + *(_DWORD *)(a2 + 12));
  uint64_t v4 = *(void *)(a3 + 56);
  int v5 = *(_DWORD *)(a3 + 64);
  int v6 = *(_DWORD *)(a3 + 52);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a3 + 48);
  *(_DWORD *)(a1 + 32) = v5;
  uint64_t v7 = *(void *)(a3 + 72);
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v7;
  *(_DWORD *)(a1 + 132) = v6;
  return result;
}

uint64_t CGBlt_initialize(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 40)) {
    return 0xFFFFFFFFLL;
  }
  int32x2_t v1 = *(int32x2_t *)(a1 + 12);
  v2.i32[0] = v1.i32[0];
  v2.i32[1] = *(_DWORD *)(a1 + 8);
  v3.i32[1] = v1.i32[1];
  v3.i32[0] = *(_DWORD *)(a1 + 4);
  int32x2_t v4 = vadd_s32(v2, v3);
  int32x2_t v5 = vmax_s32(v1, 0);
  int32x2_t v6 = vsub_s32(vmin_s32(*(int32x2_t *)(a1 + 20), v4), v5);
  int32x2_t v7 = vsub_s32(v5, v1);
  unsigned int v8 = *(_DWORD *)a1;
  unsigned int v9 = BYTE2(*(_DWORD *)a1);
  if (v9 == 1 || v9 >= 5)
  {
    int32x2_t v14 = *(int32x2_t *)(a1 + 104);
    int32x2_t v11 = vadd_s32(v14, v7);
    int32x2_t v12 = vadd_s32(v11, v6);
    int32x2_t v13 = vmax_s32(v11, 0);
    int32x2_t v6 = vsub_s32(vmin_s32(*(int32x2_t *)(a1 + 112), v12), v13);
    int32x2_t v7 = vsub_s32(v13, v14);
  }
  else
  {
    unsigned int v9 = 0;
    v8 &= 0xFF00FFFF;
    *(_DWORD *)a1 = v8;
    int32x2_t v14 = 0;
  }
  int v15 = BYTE1(v8);
  if (BYTE1(v8) == 4 || !*(void *)(a1 + 88) || (uint64_t v17 = *(void *)(a1 + 64), (int)v17 < 1) || v17 <= 0)
  {
    int v15 = 0;
    unsigned int v8 = v8 & 0xFFFF00FF | 0x400;
    *(_DWORD *)a1 = v8;
    int32x2_t v16 = 0;
    *(void *)(a1 + 76) = 0;
    *(_OWORD *)(a1 + 56) = xmmword_1850CDE50;
    uint64_t v17 = 0x100000001;
    goto LABEL_11;
  }
  if ((v8 & 0xFE00) == 0x200)
  {
    int32x2_t v16 = *(int32x2_t *)(a1 + 56);
    goto LABEL_11;
  }
  if (BYTE1(v8) != 1) {
    return 0xFFFFFFFFLL;
  }
  int32x2_t v16 = *(int32x2_t *)(a1 + 56);
  int32x2_t v22 = vadd_s32(v16, v7);
  int32x2_t v23 = vadd_s32(v22, v6);
  int32x2_t v24 = vmax_s32(v22, 0);
  int32x2_t v6 = vsub_s32(vmin_s32((int32x2_t)v17, v23), v24);
  int32x2_t v7 = vsub_s32(v24, v16);
LABEL_11:
  *(int32x2_t *)(a1 + 4) = v6;
  if (v6.i32[0] < 1 || v6.i32[1] < 1) {
    return 0;
  }
  *(int32x2_t *)(a1 + 12) = vadd_s32(v7, v1);
  if (v15)
  {
    int32x2_t v20 = vadd_s32(v16, v7);
    if (v15 == 3)
    {
      v25.i32[0] = v20.i32[0] % (int)v17;
      v25.i32[1] = v20.i32[1] % SHIDWORD(v17);
      int32x2_t v20 = vadd_s32((int32x2_t)vand_s8((int8x8_t)vcltz_s32(v25), (int8x8_t)v17), v25);
    }
    else if (v15 == 2)
    {
      v20.i32[0] %= (int)v17;
      v20.i32[1] %= SHIDWORD(v17);
      int32x2_t v20 = vadd_s32((int32x2_t)vand_s8((int8x8_t)vcltz_s32(v20), (int8x8_t)v17), v20);
      int32x2_t v21 = vcgt_s32(vadd_s32(v20, v6), (int32x2_t)v17);
      if (((v21.i32[0] | v21.i32[1]) & 1) == 0) {
        *(_DWORD *)a1 = v8 & 0xFFFF00FF | 0x100;
      }
    }
    *(int32x2_t *)(a1 + 56) = v20;
  }
  if (v9) {
    *(int32x2_t *)(a1 + 104) = vadd_s32(v7, v14);
  }
  return 1;
}

uint64_t ripl_BltOpMask(uint64_t result, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)(result + 120) = 0;
  *(_DWORD *)(result + 128) = 0;
  if (a3)
  {
    *(void *)(result + 112) = *(void *)(a3 + 20);
    *(_DWORD *)(result + 104) = *a2 - *(_DWORD *)(a3 + 12);
    *(_DWORD *)(result + 108) = *(_DWORD *)(a3 + 24) + *(_DWORD *)(a3 + 16) - (a2[1] + a2[3]);
    if (*(void *)(a3 + 72))
    {
      *(unsigned char *)(result + 2) = 5;
      *(_DWORD *)(result + 124) = *(_DWORD *)(a3 + 64);
      uint64_t v3 = *(void *)(a3 + 72);
LABEL_12:
      *(void *)(result + 136) = v3;
      return result;
    }
    if (*(void *)(a3 + 56))
    {
      if ((*(_DWORD *)(a3 + 28) & 0x80) != 0) {
        char v4 = 6;
      }
      else {
        char v4 = 1;
      }
      *(unsigned char *)(result + 2) = v4;
      *(_DWORD *)(result + 124) = *(_DWORD *)(a3 + 48);
      uint64_t v3 = *(void *)(a3 + 56);
      goto LABEL_12;
    }
    *(unsigned char *)(result + 2) = 5;
    *(_DWORD *)(result + 124) = 0;
    *(void *)(result + 136) = 0;
  }
  else if ((*(_DWORD *)result & 0xFF0000) != 0)
  {
    *(_DWORD *)result &= 0xFF00FFFF;
    *(_DWORD *)(result + 124) = 0;
    *(void *)(result + 136) = 0;
    *(void *)(result + 104) = 0;
    *(void *)(result + 112) = 0;
  }
  return result;
}

uint64_t ripl_BltOpSourcePattern(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  if ((*(_DWORD *)a4 & 0xFFF00000) == 0x300000)
  {
    int v5 = *(_DWORD *)(a4 + 4);
    int v4 = *(_DWORD *)(a4 + 8);
    int v6 = *(_DWORD *)(a4 + 12);
    int v7 = *(_DWORD *)(a4 + 16);
    if (a3)
    {
      v5 += *a3;
      v4 += a3[1];
    }
    uint64_t v8 = 3;
    *(unsigned char *)(a1 + 1) = 3;
    int v9 = a2[4];
    int v10 = a2[6];
    int v11 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 56) = a2[3] - v5 + *(_DWORD *)(a1 + 12);
    int v12 = v4 + v7 - (v9 + v10) + v11;
  }
  else
  {
    int v12 = 0;
    int v6 = 0;
    int v7 = 0;
    uint64_t v8 = 4;
    *(unsigned char *)(a1 + 1) = 4;
    *(_DWORD *)(a1 + 56) = 0;
  }
  *(_DWORD *)(a1 + 60) = v12;
  *(_DWORD *)(a1 + 64) = v6;
  *(_DWORD *)(a1 + 68) = v7;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 76) = *(void *)(a4 + 20);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a4 + 32);
  return v8;
}

_DWORD *argb32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  unsigned int v8 = PIXELCONSTANT_14645(*(float **)(*(void *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 3 || (a2 = malloc_type_malloc(0x34uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDDC0;
    a2[6] = 0;
    a2[12] = v8;
    *((void *)a2 + 2) = 1;
    if (HIBYTE(v8) == 255) {
      int v9 = 0;
    }
    else {
      int v9 = (char *)(a2 + 12);
    }
    *((void *)a2 + 4) = a2 + 12;
    *((void *)a2 + 5) = v9;
  }
  return a2;
}

_DWORD *A8_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, float a4)
{
  int v5 = *(float **)(*(void *)a1 + 64);
  if (a2 && a3 > 3 || (a2 = malloc_type_malloc(0x34uLL, 0x705560E0uLL)) != 0)
  {
    float v6 = v5[1];
    if (v6 >= a4)
    {
      float v6 = a4;
      if (*v5 > a4) {
        float v6 = *v5;
      }
    }
    int v7 = (int)(float)((float)(v6 * v5[2]) + v5[3]);
    *(_OWORD *)a2 = xmmword_1850CDED0;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    a2[12] = v7 | (v7 << 8) | ((v7 | (v7 << 8)) << 16);
    if (v7 >= 255) {
      unsigned int v8 = 0;
    }
    else {
      unsigned int v8 = (char *)(a2 + 12);
    }
    *((void *)a2 + 4) = a2 + 12;
    *((void *)a2 + 5) = v8;
  }
  return a2;
}

uint64_t ripl_Mark(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t *))(*(void *)(a1 + 32) + 40))(&v2);
}

void CGBlt_fillBytes(int a1, unsigned int a2, int a3, char *__b, int a5)
{
  int __pattern4 = a3;
  if (a1 >= 1 && (int)a2 >= 1)
  {
    int v5 = __b;
    if (a1 == 2)
    {
      if (a2)
      {
        *(_WORD *)__b = HIWORD(a3);
        int v5 = &__b[a5];
      }
      if (a2 >= 2)
      {
        unsigned int v7 = a2 >> 1;
        do
        {
          *(_WORD *)int v5 = HIWORD(a3);
          *(_WORD *)&v5[a5] = HIWORD(a3);
          v5 += a5 + (uint64_t)a5;
          --v7;
        }
        while (v7);
      }
    }
    else if (a1 == 1)
    {
      if (a2)
      {
        *__b = HIBYTE(a3);
        int v5 = &__b[a5];
      }
      if (a2 >= 2)
      {
        unsigned int v6 = a2 >> 1;
        do
        {
          *int v5 = HIBYTE(a3);
          v5[a5] = HIBYTE(a3);
          v5 += a5 + (uint64_t)a5;
          --v6;
        }
        while (v6);
      }
    }
    else
    {
      BOOL v8 = a1 == a5;
      BOOL v9 = (a1 & 3) == 0;
      BOOL v10 = !v9 || !v8;
      if (v9 && v8) {
        int v11 = a2;
      }
      else {
        int v11 = 1;
      }
      size_t v12 = (v11 * a1);
      if (v10) {
        int v13 = a2;
      }
      else {
        int v13 = 1;
      }
      uint64_t v14 = a5;
      if (a3)
      {
        do
        {
          memset_pattern4(v5, &__pattern4, v12);
          v5 += v14;
          --v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          bzero(v5, v12);
          v5 += v14;
          --v13;
        }
        while (v13);
      }
    }
  }
}

uint64_t GRAYA8_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v574 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *(void *)(v5 + 96);
  uint64_t v12 = *(void *)(v5 + 48);
  int v13 = *(_DWORD *)(v4 + 16 * *(_DWORD *)v5 + 8 * (v11 == 0) + 4 * (v12 == 0));
  if (v13 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v15 = v5;
  unint64_t v16 = *(unsigned int *)(v5 + 4);
  unsigned int v17 = v16 - 1;
  if ((int)v16 < 1) {
    return 0;
  }
  int v18 = *(_DWORD *)(v5 + 8);
  uint64_t v19 = (v18 - 1);
  if (v18 < 1) {
    return 0;
  }
  int32x2_t v20 = *(uint16x4_t **)(v5 + 136);
  int v506 = *(_DWORD *)(v4 + 16 * *(_DWORD *)v5 + 8 * (v11 == 0) + 4 * (v12 == 0));
  if ((*(_DWORD *)v5 & 0xFF0000) == 0x50000 || !v20)
  {
    int v22 = *(_DWORD *)v5 & 0xFF00;
    unint64_t v500 = v5;
    if (v22 == 1024)
    {
      v573[0] = *(_DWORD *)(v5 + 4);
      v563[0] = v18;
      int32x2_t v23 = *(unsigned char **)(v5 + 88);
      LOBYTE(v8) = *v23;
      BYTE4(v8) = v23[1];
      *(int8x8_t *)v24.i8 = vdup_lane_s8(*(int8x8_t *)&v8, 0);
      v24.u64[1] = (unint64_t)vdup_lane_s8(*(int8x8_t *)&v8, 4);
      uint64_t v25 = *(void *)(v5 + 40);
      int8x8_t v26 = vqtbl1_s8(v24, (int8x8_t)0xF060D040B020900);
      int8x8_t v535 = *(int8x8_t *)&v8;
      unsigned __int8 v27 = BYTE4(v8);
      unsigned __int8 v527 = ~BYTE4(v8);
      unint64_t v525 = *(int *)(v5 + 28);
      unint64_t v28 = v525 >> 1;
      unint64_t v29 = *(int *)(v5 + 12) + (v525 >> 1) * *(int *)(v5 + 16);
      uint64_t v30 = v25 + 2 * v29;
      uint64_t v529 = v30;
      if (v20)
      {
        shape_enum_clip_alloc(v4, v5, (int *)v20, 1, 1, 1, *(_DWORD *)(v5 + 104), *(_DWORD *)(v5 + 108), v16, v18);
        if (!v31) {
          return 1;
        }
        uint64_t v32 = v31;
LABEL_953:
        if (!shape_enum_clip_next(v32, (int *)&v562 + 1, &v562, v573, v563))
        {
          long long v60 = (void *)v32;
          goto LABEL_956;
        }
        long long v50 = (uint8x8_t *)(v30 + 2 * v28 * (int)v562 + 2 * SHIDWORD(v562));
        LODWORD(v16) = v573[0];
      }
      else
      {
        uint64_t v32 = 0;
        long long v50 = (uint8x8_t *)(v25 + 2 * v29);
      }
      unint64_t v537 = v28 - (int)v16;
      int v524 = v16;
      switch(v13)
      {
        case 0:
          unsigned int v406 = v563[0];
          int v407 = 2 * v16;
          goto LABEL_959;
        case 1:
          uint64_t v408 = *(void *)(v500 + 88);
          if (v408)
          {
            CGSFillDRAM64((unint64_t)v50, v525 & 0xFFFFFFFE, 2 * v16, v563[0], v408, 2, 2, 1, 0, 0);
            if (v32) {
              goto LABEL_952;
            }
            return 1;
          }
          int v407 = 2 * v16;
          unsigned int v406 = v563[0];
LABEL_959:
          CGBlt_fillBytes(v407, v406, 0, (char *)v50, v525 & 0xFFFFFFFE);
          if (!v32) {
            return 1;
          }
LABEL_952:
          uint64_t v562 = 0;
          goto LABEL_953;
        case 2:
          int v409 = v563[0];
          uint16x8_t v410 = (uint16x8_t)vdupq_n_s16(v527);
          do
          {
            if ((int)v16 < 4)
            {
              int v414 = v16;
            }
            else
            {
              unsigned int v411 = (v16 >> 2) + 1;
              do
              {
                uint16x8_t v412 = vmovl_u8(*v50);
                int16x8_t v413 = (int16x8_t)vmull_u16(*(uint16x4_t *)v410.i8, *(uint16x4_t *)v412.i8);
                *(uint16x4_t *)v413.i8 = vshr_n_u16((uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)v413, (uint32x4_t)v413, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
                v413.u64[1] = (unint64_t)vshr_n_u16((uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vmlal_high_u16(vshrq_n_u32(vmull_high_u16(v410, v412), 8uLL), v410, v412)), (int16x4_t)0x1000100010001), 8uLL);
                *v50++ = (uint8x8_t)vadd_s8(v26, vmovn_s16(v413));
                --v411;
              }
              while (v411 > 1);
              int v414 = v16 & 3;
            }
            if (v414 >= 1)
            {
              unsigned int v415 = v414 + 1;
              do
              {
                v50->i8[0] = v535.i8[0]
                           + ((unsigned __int16)(v50->u8[0] * v527 + ((v50->u8[0] * v527) >> 8) + 1) >> 8);
                v50->i8[1] = v27
                           + ((unsigned __int16)(v50->u8[1] * v527 + ((v50->u8[1] * v527) >> 8) + 1) >> 8);
                long long v50 = (uint8x8_t *)((char *)v50 + 2);
                --v415;
              }
              while (v415 > 1);
            }
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v409;
          }
          while (v409);
          goto LABEL_780;
        case 3:
          int32x2_t v416 = (int32x2_t)vand_s8(v535, (int8x8_t)0xFF000000FFLL);
          int v417 = v563[0];
          do
          {
            int v418 = v16;
            do
            {
              unsigned int v419 = v50->u8[1];
              if (v419 == 255)
              {
                v50->i8[0] = v535.i8[0];
                v50->i8[1] = v27;
              }
              else if (v50->i8[1])
              {
                uint32x2_t v420 = (uint32x2_t)vmul_s32(vdup_n_s32(v419), v416);
                uint32x2_t v421 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v420, v420, 8uLL), (int32x2_t)0x100000001), 8uLL);
                v50->i8[1] = v421.i8[4];
                v50->i8[0] = v421.i8[0];
              }
              else
              {
                v50->i16[0] = 0;
              }
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v418;
            }
            while (v418);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v417;
          }
          while (v417);
          goto LABEL_780;
        case 4:
          int32x2_t v422 = (int32x2_t)vand_s8(v535, (int8x8_t)0xFF000000FFLL);
          int v423 = v563[0];
          do
          {
            int v424 = v16;
            do
            {
              __int8 v425 = v50->i8[1];
              if (~v425 == 255)
              {
                v50->i8[0] = v535.i8[0];
                v50->i8[1] = v27;
              }
              else if (v425 == -1)
              {
                v50->i16[0] = 0;
              }
              else
              {
                uint32x2_t v426 = (uint32x2_t)vmul_s32(vdup_n_s32(~v425), v422);
                uint32x2_t v427 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v426, v426, 8uLL), (int32x2_t)0x100000001), 8uLL);
                v50->i8[1] = v427.i8[4];
                v50->i8[0] = v427.i8[0];
              }
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v424;
            }
            while (v424);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v423;
          }
          while (v423);
          goto LABEL_780;
        case 5:
          int v428 = v563[0];
          do
          {
            int v429 = v16;
            do
            {
              int v430 = v50->u8[1];
              v50->i8[0] = (unsigned __int16)(v430 * v535.u8[0]
                                            + v50->u8[0] * v527
                                            + ((v430 * v535.u8[0] + v50->u8[0] * v527) >> 8)
                                            + 1) >> 8;
              v50->i8[1] = (unsigned __int16)(255 * v430 + ((255 * v430) >> 8) + 1) >> 8;
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v429;
            }
            while (v429);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v428;
          }
          while (v428);
          goto LABEL_780;
        case 6:
          int v431 = v563[0];
          do
          {
            int v432 = v16;
            do
            {
              int v433 = v50->u8[1];
              if (v433 != 0xFF)
              {
                if ((v433 ^ 0xFF) == 0xFF)
                {
                  v50->i8[0] = v535.i8[0];
                  LOBYTE(v434) = v27;
                }
                else
                {
                  v50->i8[0] += (unsigned __int16)(v527 * v535.u8[0] + ((v527 * v535.u8[0]) >> 8) + 1) >> 8;
                  int v434 = v433 + ((v527 * v27 + ((v527 * v27) >> 8) + 1) >> 8);
                }
                v50->i8[1] = v434;
              }
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v432;
            }
            while (v432);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v431;
          }
          while (v431);
          goto LABEL_780;
        case 7:
          int v435 = v563[0];
          do
          {
            int v436 = v16;
            do
            {
              v50->i8[0] = (unsigned __int16)(v50->u8[0] * v27 + ((v50->u8[0] * v27) >> 8) + 1) >> 8;
              v50->i8[1] = (unsigned __int16)(v50->u8[1] * v27 + ((v50->u8[1] * v27) >> 8) + 1) >> 8;
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v436;
            }
            while (v436);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v435;
          }
          while (v435);
          goto LABEL_780;
        case 8:
          int v437 = v563[0];
          do
          {
            int v438 = v16;
            do
            {
              v50->i8[0] = (unsigned __int16)(v50->u8[0] * v527 + ((v50->u8[0] * v527) >> 8) + 1) >> 8;
              v50->i8[1] = (unsigned __int16)(v50->u8[1] * v527 + ((v50->u8[1] * v527) >> 8) + 1) >> 8;
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v438;
            }
            while (v438);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v437;
          }
          while (v437);
          goto LABEL_780;
        case 9:
          int v439 = v563[0];
          do
          {
            int v440 = v16;
            do
            {
              unsigned int v441 = (v50->u8[1] ^ 0xFF) * v535.u8[0] + v50->u8[0] * v27;
              v50->i8[0] = (unsigned __int16)(v441 + (v441 >> 8) + 1) >> 8;
              v50->i8[1] = (unsigned __int16)(255 * v27 + ((255 * v27) >> 8) + 1) >> 8;
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v440;
            }
            while (v440);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v439;
          }
          while (v439);
          goto LABEL_780;
        case 10:
          int v442 = v563[0];
          do
          {
            int v443 = v16;
            do
            {
              int v444 = v50->u8[1];
              v50->i8[0] = (unsigned __int16)((v444 ^ 0xFF) * v535.u8[0]
                                            + v50->u8[0] * v527
                                            + (((v444 ^ 0xFF) * v535.u8[0] + v50->u8[0] * v527) >> 8)
                                            + 1) >> 8;
              v50->i8[1] = (unsigned __int16)((v444 ^ 0xFF) * v27
                                            + v444 * v527
                                            + (((v444 ^ 0xFF) * v27 + v444 * v527) >> 8)
                                            + 1) >> 8;
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v443;
            }
            while (v443);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v442;
          }
          while (v442);
          goto LABEL_780;
        case 11:
          int v445 = v563[0];
          do
          {
            int v446 = v16;
            do
            {
              if (v12) {
                int v447 = v50->u8[1];
              }
              else {
                int v447 = 255;
              }
              unsigned int v448 = ((v27 - v535.i8[0]) | (v27 << 16))
                   + (v447 - v50->i8[0])
                   + (v447 << 16);
              int v449 = (255 * ((v448 >> 8) & 0x10001)) | v448;
              v50->i8[0] = BYTE2(v449) - v449;
              v50->i8[1] = BYTE2(v449);
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v446;
            }
            while (v446);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v445;
          }
          while (v445);
LABEL_780:
          v563[0] = 0;
          if (!v32) {
            return 1;
          }
          goto LABEL_952;
        case 12:
          do
          {
            int v450 = v573[0];
            do
            {
              unsigned int v451 = (v535.u8[0] | (v27 << 16)) + v50->i16[0] + ((v50->u16[0] << 8) & 0xFF0000);
              int v452 = (255 * ((v451 >> 8) & 0x10001)) | v451;
              v50->i8[0] = v452;
              v50->i8[1] = BYTE2(v452);
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v450;
            }
            while (v450);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            --v563[0];
          }
          while (v563[0]);
          goto LABEL_951;
        case 13:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v453 = v563[0];
          while (1)
          {
            int v454 = v16;
            do
            {
              if (v12)
              {
                int v455 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_794;
                }
              }
              else
              {
                int v455 = 255;
              }
              unint64_t v559 = v535.u8[0] | ((unint64_t)v27 << 8) | v559 & 0xFFFFFFFFFFFF0000;
              unint64_t v560 = v560 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAmultiplyPDA(v560, v455, v535.u8[0], v27);
LABEL_794:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v454;
            }
            while (v454);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v453;
            LODWORD(v16) = v524;
            if (!v453) {
              goto LABEL_950;
            }
          }
        case 14:
          if (!v27) {
            goto LABEL_951;
          }
          int v456 = v563[0];
          while (1)
          {
            int v457 = v16;
            do
            {
              if (v12)
              {
                int v458 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_805;
                }
              }
              else
              {
                int v458 = 255;
              }
              unsigned int v459 = (v50->u8[0] ^ 0xFF) * v535.u8[0] - v50->u8[0] + (v50->u8[0] << 8);
              v50->i8[0] = (unsigned __int16)(v459 + (v459 >> 8) + 1) >> 8;
              v50->i8[1] = (unsigned __int16)(255 * (v458 + v27)
                                            - v458 * v27
                                            + ((255 * (v458 + v27) - v458 * v27) >> 8)
                                            + 1) >> 8;
LABEL_805:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v457;
            }
            while (v457);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v456;
            if (!v456) {
              goto LABEL_951;
            }
          }
        case 15:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v460 = v563[0];
          while (1)
          {
            int v461 = v16;
            do
            {
              if (v12)
              {
                int v462 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_816;
                }
              }
              else
              {
                int v462 = 255;
              }
              unint64_t v557 = v535.u8[0] | ((unint64_t)v27 << 8) | v557 & 0xFFFFFFFFFFFF0000;
              unint64_t v558 = v558 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAoverlayPDA(v558, v462, v535.u8[0], v27);
LABEL_816:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v461;
            }
            while (v461);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v460;
            LODWORD(v16) = v524;
            if (!v460)
            {
LABEL_950:
              int v13 = v506;
              uint64_t v30 = v529;
              unint64_t v28 = v525 >> 1;
              uint64_t v32 = v533;
              goto LABEL_951;
            }
          }
        case 16:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v463 = v563[0];
          while (1)
          {
            int v464 = v16;
            do
            {
              if (v12)
              {
                int v465 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_827;
                }
              }
              else
              {
                int v465 = 255;
              }
              unint64_t v553 = v535.u8[0] | ((unint64_t)v27 << 8) | v553 & 0xFFFFFFFFFFFF0000;
              unint64_t v554 = v554 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAdarkenPDA(v554, v465, v535.u8[0], v27);
LABEL_827:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v464;
            }
            while (v464);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v463;
            LODWORD(v16) = v524;
            if (!v463) {
              goto LABEL_950;
            }
          }
        case 17:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v466 = v563[0];
          while (1)
          {
            int v467 = v16;
            do
            {
              if (v12)
              {
                int v468 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_838;
                }
              }
              else
              {
                int v468 = 255;
              }
              unint64_t v555 = v535.u8[0] | ((unint64_t)v27 << 8) | v555 & 0xFFFFFFFFFFFF0000;
              unint64_t v556 = v556 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAlightenPDA(v556, v468, v535.u8[0], v27);
LABEL_838:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v467;
            }
            while (v467);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v466;
            LODWORD(v16) = v524;
            if (!v466) {
              goto LABEL_950;
            }
          }
        case 18:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v469 = v563[0];
          while (1)
          {
            int v470 = v16;
            do
            {
              if (v12)
              {
                int v471 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_849;
                }
              }
              else
              {
                int v471 = 255;
              }
              unint64_t v551 = v535.u8[0] | ((unint64_t)v27 << 8) | v551 & 0xFFFFFFFFFFFF0000;
              unint64_t v552 = v552 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAcolordodgePDA(v552, v471, v535.u8[0], v27);
LABEL_849:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v470;
            }
            while (v470);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v469;
            LODWORD(v16) = v524;
            if (!v469) {
              goto LABEL_950;
            }
          }
        case 19:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v472 = v563[0];
          while (1)
          {
            int v473 = v16;
            do
            {
              if (v12)
              {
                int v474 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_860;
                }
              }
              else
              {
                int v474 = 255;
              }
              unint64_t v549 = v535.u8[0] | ((unint64_t)v27 << 8) | v549 & 0xFFFFFFFFFFFF0000;
              unint64_t v550 = v550 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAcolorburnPDA(v550, v474, v535.u8[0], v27);
LABEL_860:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v473;
            }
            while (v473);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v472;
            LODWORD(v16) = v524;
            if (!v472) {
              goto LABEL_950;
            }
          }
        case 20:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v475 = v563[0];
          while (1)
          {
            int v476 = v16;
            do
            {
              if (v12)
              {
                int v477 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_871;
                }
              }
              else
              {
                int v477 = 255;
              }
              unint64_t v545 = v535.u8[0] | ((unint64_t)v27 << 8) | v545 & 0xFFFFFFFFFFFF0000;
              unint64_t v546 = v546 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAsoftlightPDA(v546, v477, v535.u8[0], v27);
LABEL_871:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v476;
            }
            while (v476);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v475;
            LODWORD(v16) = v524;
            if (!v475) {
              goto LABEL_950;
            }
          }
        case 21:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v478 = v563[0];
          while (1)
          {
            int v479 = v16;
            do
            {
              if (v12)
              {
                int v480 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_882;
                }
              }
              else
              {
                int v480 = 255;
              }
              unint64_t v547 = v535.u8[0] | ((unint64_t)v27 << 8) | v547 & 0xFFFFFFFFFFFF0000;
              unint64_t v548 = v548 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAhardlightPDA(v548, v480, v535.u8[0], v27);
LABEL_882:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v479;
            }
            while (v479);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v478;
            LODWORD(v16) = v524;
            if (!v478) {
              goto LABEL_950;
            }
          }
        case 22:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v481 = v563[0];
          while (1)
          {
            int v482 = v16;
            do
            {
              if (v12)
              {
                int v483 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_893;
                }
              }
              else
              {
                int v483 = 255;
              }
              unint64_t v543 = v535.u8[0] | ((unint64_t)v27 << 8) | v543 & 0xFFFFFFFFFFFF0000;
              unint64_t v544 = v544 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAdifferencePDA(v544, v483, v535.u8[0], v27);
LABEL_893:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v482;
            }
            while (v482);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v481;
            LODWORD(v16) = v524;
            if (!v481) {
              goto LABEL_950;
            }
          }
        case 23:
          if (!v27) {
            goto LABEL_951;
          }
          int v484 = v563[0];
          while (1)
          {
            int v485 = v16;
            do
            {
              if (v12)
              {
                int v486 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_904;
                }
              }
              else
              {
                int v486 = 255;
              }
              unsigned int v487 = 255 * (v50->u8[0] + v535.u8[0]) - 2 * v535.u8[0] * v50->u8[0];
              v50->i8[0] = (unsigned __int16)(v487 + (v487 >> 8) + 1) >> 8;
              v50->i8[1] = (unsigned __int16)(255 * (v486 + v27)
                                            - v486 * v27
                                            + ((255 * (v486 + v27) - v486 * v27) >> 8)
                                            + 1) >> 8;
LABEL_904:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v485;
            }
            while (v485);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v484;
            if (!v484)
            {
LABEL_951:
              if (v32) {
                goto LABEL_952;
              }
              return 1;
            }
          }
        case 24:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v488 = v563[0];
          while (1)
          {
            int v489 = v16;
            do
            {
              if (v12)
              {
                int v490 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_915;
                }
              }
              else
              {
                int v490 = 255;
              }
              unint64_t v541 = v535.u8[0] | ((unint64_t)v27 << 8) | v541 & 0xFFFFFFFFFFFF0000;
              unint64_t v542 = v542 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAhuePDA(v542, v490, v535.u8[0], v27);
LABEL_915:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v489;
            }
            while (v489);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v488;
            LODWORD(v16) = v524;
            if (!v488) {
              goto LABEL_950;
            }
          }
        case 25:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v491 = v563[0];
          while (1)
          {
            int v492 = v16;
            do
            {
              if (v12)
              {
                int v493 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_926;
                }
              }
              else
              {
                int v493 = 255;
              }
              unint64_t v539 = v535.u8[0] | ((unint64_t)v27 << 8) | v539 & 0xFFFFFFFFFFFF0000;
              unint64_t v540 = v540 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              v50->i16[0] = PDAhuePDA(v540, v493, v535.u8[0], v27);
LABEL_926:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v492;
            }
            while (v492);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v491;
            LODWORD(v16) = v524;
            if (!v491) {
              goto LABEL_950;
            }
          }
        case 26:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v494 = v563[0];
          while (1)
          {
            int v495 = v16;
            do
            {
              if (v12)
              {
                int v496 = v50->u8[1];
                if (!v50->i8[1])
                {
                  v50->i8[0] = v535.i8[0];
                  v50->i8[1] = v27;
                  goto LABEL_937;
                }
              }
              else
              {
                int v496 = 255;
              }
              unint64_t v15 = v15 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
              unint64_t v538 = v535.u8[0] | ((unint64_t)v27 << 8) | v538 & 0xFFFFFFFFFFFF0000;
              v50->i16[0] = PDAhuePDA(v535.u8[0], v27, v15, v496);
LABEL_937:
              long long v50 = (uint8x8_t *)((char *)v50 + 2);
              --v495;
            }
            while (v495);
            long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
            v563[0] = --v494;
            LODWORD(v16) = v524;
            if (!v494) {
              goto LABEL_950;
            }
          }
        case 27:
          if (!v27) {
            goto LABEL_951;
          }
          uint64_t v533 = v32;
          int v497 = v563[0];
          break;
        default:
          goto LABEL_951;
      }
LABEL_942:
      int v498 = v16;
      while (v12)
      {
        int v499 = v50->u8[1];
        if (v50->i8[1]) {
          goto LABEL_947;
        }
        v50->i8[0] = v535.i8[0];
        v50->i8[1] = v27;
LABEL_948:
        long long v50 = (uint8x8_t *)((char *)v50 + 2);
        if (!--v498)
        {
          long long v50 = (uint8x8_t *)((char *)v50 + 2 * v537);
          v563[0] = --v497;
          LODWORD(v16) = v524;
          if (!v497) {
            goto LABEL_950;
          }
          goto LABEL_942;
        }
      }
      int v499 = 255;
LABEL_947:
      unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v50->u16[0];
      unint64_t v3 = v535.u8[0] | ((unint64_t)v27 << 8) | v3 & 0xFFFFFFFFFFFF0000;
      v50->i16[0] = PDAhuePDA(v2, v499, v3, v27);
      goto LABEL_948;
    }
    v573[0] = *(_DWORD *)(v5 + 4);
    v563[0] = v18;
    uint64_t v33 = *(void *)(v5 + 88);
    unint64_t v34 = (unint64_t)*(int *)(v5 + 28) >> 1;
    double v35 = (unsigned __int8 *)(*(void *)(v5 + 40) + 2 * (*(int *)(v5 + 12) + v34 * *(int *)(v5 + 16)));
    int v36 = *(_DWORD *)(v5 + 56);
    int v37 = *(_DWORD *)(v5 + 60);
    unint64_t v38 = (unint64_t)*(int *)(v5 + 76) >> 1;
    if (v22 != 256)
    {
      LODWORD(v510) = *(_DWORD *)(v5 + 64);
      int v508 = *(_DWORD *)(v5 + 68);
      unint64_t v528 = v33 + 2 * v38 * v508;
      BOOL v48 = v11 != 0;
      if (v20)
      {
        unint64_t v530 = (unint64_t)*(int *)(v5 + 76) >> 1;
        int v501 = *(_DWORD *)(v5 + 60);
        int v502 = *(_DWORD *)(v5 + 56);
        int v41 = 1;
        int v561 = *(unsigned __int8 **)(v5 + 88);
        unint64_t v49 = (unint64_t)v561;
        goto LABEL_43;
      }
      unint64_t v526 = v34 - v16;
      if (v33)
      {
        uint64_t v509 = 0;
        int v61 = v36 % (int)v510;
        unint64_t v530 = (unint64_t)*(int *)(v5 + 76) >> 1;
        unint64_t v62 = v33 + 2 * v38 * (v37 % v508);
        long long v63 = (unsigned __int8 *)(v62 + 2 * v61);
        unint64_t v49 = v62 + 2 * (int)v510;
        int v507 = 1;
        int v561 = v63;
        long long v64 = (unsigned __int8 *)(*(void *)(v5 + 40) + 2 * (*(int *)(v5 + 12) + v34 * *(int *)(v5 + 16)));
        int v501 = v37 % v508;
        int v502 = v61;
        goto LABEL_47;
      }
      int v501 = *(_DWORD *)(v5 + 60);
      int v502 = *(_DWORD *)(v5 + 56);
      unint64_t v49 = 0;
      int v507 = 1;
      unint64_t v65 = v16;
LABEL_46:
      uint64_t v509 = 0;
      int v561 = 0;
      unint64_t v528 = 0;
      unint64_t v530 = v38 - v65;
      long long v63 = (unsigned __int8 *)v33;
      long long v64 = v35;
      goto LABEL_47;
    }
    v33 += 2 * (v36 + v38 * v37);
    if (v38 == v34)
    {
      if ((uint64_t)&v35[-v33] < 1) {
        goto LABEL_20;
      }
      if (v16 < (unint64_t)&v35[-v33] >> 1)
      {
        unint64_t v39 = v34 * v19;
        uint64_t v40 = v33 + 2 * v34 * v19;
        if ((unint64_t)v35 <= v40 + 2 * (unint64_t)v17)
        {
          v35 += 2 * v39;
          unint64_t v34 = -(uint64_t)v34;
          int v41 = 1;
          uint64_t v33 = v40;
          goto LABEL_40;
        }
LABEL_20:
        int v41 = 1;
LABEL_40:
        unint64_t v510 = v34;
        goto LABEL_41;
      }
      v35 += 2 * v17;
      int v41 = -1;
      unint64_t v510 = (unint64_t)*(int *)(v5 + 28) >> 1;
      v33 += 2 * v17;
    }
    else
    {
      int v41 = 1;
      unint64_t v510 = (unint64_t)*(int *)(v5 + 76) >> 1;
    }
LABEL_41:
    int v501 = *(_DWORD *)(v5 + 60);
    int v502 = *(_DWORD *)(v5 + 56);
    BOOL v48 = v11 != 0;
    if (v20)
    {
      int v508 = 0;
      int v561 = 0;
      unint64_t v49 = -1;
      unint64_t v528 = 0;
      unint64_t v530 = v510;
LABEL_43:
      int v507 = v41;
      shape_enum_clip_alloc(v4, v5, (int *)v20, v41, v34, 1, *(_DWORD *)(v5 + 104), *(_DWORD *)(v5 + 108), v16, v18);
      if (!v66) {
        return 1;
      }
      uint64_t v67 = v66;
      while (2)
      {
        if (!shape_enum_clip_next(v67, (int *)&v562 + 1, &v562, v573, v563))
        {
          long long v60 = (void *)v67;
          goto LABEL_956;
        }
        uint64_t v509 = v67;
        if (v528)
        {
          long long v64 = &v35[2 * v34 * (int)v562 + 2 * SHIDWORD(v562)];
          LODWORD(v16) = v573[0];
          unint64_t v400 = v33 + 2 * v530 * (((int)v562 + *(_DWORD *)(v15 + 60)) % v508);
          long long v63 = (unsigned __int8 *)(v400 + 2 * ((HIDWORD(v562) + *(_DWORD *)(v15 + 56)) % (int)v510));
          unint64_t v49 = v400 + 2 * (int)v510;
          int v561 = v63;
          int v401 = v573[0];
          int v501 = ((int)v562 + *(_DWORD *)(v15 + 60)) % v508;
          int v502 = (HIDWORD(v562) + *(_DWORD *)(v15 + 56)) % (int)v510;
        }
        else
        {
          LODWORD(v16) = v573[0];
          int v401 = v573[0] * v507;
          long long v64 = &v35[2 * v34 * (int)v562 + 2 * HIDWORD(v562) * v507];
          long long v63 = (unsigned __int8 *)(v33 + 2 * (int)v562 * (int)v510 + 2 * HIDWORD(v562) * v507);
          unint64_t v530 = (int)v510 - v573[0] * v507;
        }
        unint64_t v526 = v34 - v401;
LABEL_47:
        switch(v13)
        {
          case 0:
            uint64_t v68 = &v64[-2 * (int)v16 + 2];
            uint64_t v69 = v526 + (int)v16;
            if (v507 < 0) {
              uint64_t v69 = v526 - (int)v16;
            }
            else {
              uint64_t v68 = v64;
            }
            long long v70 = (char *)&v68[2 * ((v69 * (v563[0] - 1)) & (v69 >> 63))];
            if (v69 < 0) {
              uint64_t v69 = -v69;
            }
            CGBlt_fillBytes(2 * v16, v563[0], 0, v70, 2 * v69);
            goto LABEL_686;
          case 1:
            int v71 = *(unsigned __int8 *)(v15 + 1);
            if (v71 == 2)
            {
              if ((int)v16 >= 16 && (2 * v510) <= 0x40)
              {
                LODWORD(v6) = 2 * v510;
                uint8x8_t v372 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v6);
                v372.i16[0] = vaddlv_u8(v372);
                if (v372.i32[0] <= 1u)
                {
                  CGSFillDRAM64((unint64_t)v64, 2 * (v16 + v526), 2 * v16, v563[0], v33, 2 * v530, 2 * v510, v508, 2 * v502, v501);
                  goto LABEL_686;
                }
              }
LABEL_639:
              int v373 = v563[0];
              uint64_t v374 = 2 * v507;
              if (v12 == 0 || v48)
              {
                do
                {
                  int v375 = v16;
                  do
                  {
                    *(_WORD *)long long v64 = *(_WORD *)v63;
                    v376 = &v63[2 * v507];
                    if ((unint64_t)v376 >= v49) {
                      uint64_t v377 = -(uint64_t)(int)v510;
                    }
                    else {
                      uint64_t v377 = 0;
                    }
                    long long v63 = &v376[2 * v377];
                    v64 += v374;
                    --v375;
                  }
                  while (v375);
                  v64 += 2 * v526;
                  int v378 = v561;
                  uint64_t v379 = &v561[2 * v530];
                  if ((unint64_t)v379 >= v528) {
                    uint64_t v380 = -(uint64_t)(v530 * v508);
                  }
                  else {
                    uint64_t v380 = 0;
                  }
                  int v381 = &v379[2 * v380];
                  uint64_t v382 = v49 + 2 * v380 + 2 * v530;
                  if (v528)
                  {
                    unint64_t v49 = v382;
                    int v378 = v381;
                  }
                  int v561 = v378;
                  if (v528) {
                    long long v63 = v381;
                  }
                  else {
                    v63 += 2 * v530;
                  }
                  --v373;
                }
                while (v373);
              }
              else
              {
                do
                {
                  int v383 = v16;
                  do
                  {
                    *long long v64 = *v63;
                    v64[1] = -1;
                    uint64_t v384 = &v63[2 * v507];
                    if ((unint64_t)v384 >= v49) {
                      uint64_t v385 = -(uint64_t)(int)v510;
                    }
                    else {
                      uint64_t v385 = 0;
                    }
                    long long v63 = &v384[2 * v385];
                    v64 += v374;
                    --v383;
                  }
                  while (v383);
                  v64 += 2 * v526;
                  v386 = v561;
                  __int16 v387 = &v561[2 * v530];
                  if ((unint64_t)v387 >= v528) {
                    uint64_t v388 = -(uint64_t)(v530 * v508);
                  }
                  else {
                    uint64_t v388 = 0;
                  }
                  __int16 v389 = &v387[2 * v388];
                  uint64_t v390 = v49 + 2 * v388 + 2 * v530;
                  if (v528)
                  {
                    unint64_t v49 = v390;
                    v386 = v389;
                  }
                  int v561 = v386;
                  if (v528) {
                    long long v63 = v389;
                  }
                  else {
                    v63 += 2 * v530;
                  }
                  --v373;
                }
                while (v373);
              }
              goto LABEL_685;
            }
            if (v71 != 1) {
              goto LABEL_639;
            }
            if (v12 != 0 && !v48)
            {
              int v391 = v563[0];
              do
              {
                int v392 = v16;
                do
                {
                  *long long v64 = *v63;
                  v64[1] = -1;
                  int v393 = &v63[2 * v507];
                  if ((unint64_t)v393 >= v49) {
                    uint64_t v394 = -(uint64_t)(int)v510;
                  }
                  else {
                    uint64_t v394 = 0;
                  }
                  long long v63 = &v393[2 * v394];
                  v64 += 2 * v507;
                  --v392;
                }
                while (v392);
                v64 += 2 * v526;
                uint64_t v395 = v561;
                uint64_t v396 = &v561[2 * v530];
                if ((unint64_t)v396 >= v528) {
                  uint64_t v397 = -(uint64_t)(v530 * v508);
                }
                else {
                  uint64_t v397 = 0;
                }
                int v398 = &v396[2 * v397];
                uint64_t v399 = v49 + 2 * v397 + 2 * v530;
                if (v528)
                {
                  unint64_t v49 = v399;
                  uint64_t v395 = v398;
                }
                int v561 = v395;
                if (v528) {
                  long long v63 = v398;
                }
                else {
                  v63 += 2 * v530;
                }
                --v391;
              }
              while (v391);
              goto LABEL_685;
            }
            if (v507 < 0)
            {
              uint64_t v72 = v530 - (int)v16;
              v63 += -2 * (int)v16 + 2;
              uint64_t v73 = v526 - (int)v16;
              v64 += -2 * (int)v16 + 2;
            }
            else
            {
              uint64_t v72 = v530 + (int)v16;
              uint64_t v73 = v526 + (int)v16;
            }
            uint64_t v402 = v563[0] - 1;
            uint64_t v403 = (char *)&v63[2 * ((v72 * v402) & (v72 >> 63))];
            if (v72 >= 0) {
              unint64_t v404 = v72;
            }
            else {
              unint64_t v404 = -v72;
            }
            if (v73 >= 0) {
              LODWORD(v405) = v73;
            }
            else {
              uint64_t v405 = -v73;
            }
            unint64_t v530 = v404;
            CGBlt_copyBytes(2 * v16, v563[0], v403, (char *)&v64[2 * ((v73 * v402) & (v73 >> 63))], 2 * v404, 2 * v405);
LABEL_686:
            uint64_t v67 = v509;
            if (!v509) {
              return 1;
            }
            uint64_t v562 = 0;
            continue;
          case 2:
            int v74 = v563[0];
            do
            {
              int v75 = v16;
              do
              {
                int v76 = v63[1];
                if (v63[1])
                {
                  if (v76 == 255)
                  {
                    *long long v64 = *v63;
                    v64[1] = -1;
                  }
                  else
                  {
                    *long long v64 = *v63 + ((unsigned __int16)(*v64 * (v76 ^ 0xFF) + ((*v64 * (v76 ^ 0xFFu)) >> 8) + 1) >> 8);
                    v64[1] = v76
                           + ((unsigned __int16)(v64[1] * (v76 ^ 0xFF) + ((v64[1] * (v76 ^ 0xFFu)) >> 8) + 1) >> 8);
                  }
                }
                long long v77 = &v63[2 * v507];
                if ((unint64_t)v77 >= v49) {
                  uint64_t v78 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v78 = 0;
                }
                long long v63 = &v77[2 * v78];
                v64 += 2 * v507;
                --v75;
              }
              while (v75);
              v64 += 2 * v526;
              long long v79 = v561;
              long long v80 = &v561[2 * v530];
              if ((unint64_t)v80 >= v528) {
                uint64_t v81 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v81 = 0;
              }
              long long v82 = &v80[2 * v81];
              uint64_t v83 = v49 + 2 * v81 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v83;
                long long v79 = v82;
              }
              int v561 = v79;
              if (v528) {
                long long v63 = v82;
              }
              else {
                v63 += 2 * v530;
              }
              --v74;
            }
            while (v74);
            goto LABEL_685;
          case 3:
            int v84 = v563[0];
            while (1)
            {
              int v85 = v16;
              do
              {
                int v86 = v64[1];
                if (v86 == 255)
                {
                  *long long v64 = *v63;
                  if (v48) {
                    LOBYTE(v87) = v63[1];
                  }
                  else {
                    LOBYTE(v87) = -1;
                  }
                }
                else
                {
                  if (!v64[1])
                  {
                    *(_WORD *)long long v64 = 0;
                    goto LABEL_92;
                  }
                  *long long v64 = (unsigned __int16)(*v63 * (_WORD)v86 + ((*v63 * v86) >> 8) + 1) >> 8;
                  if (v48) {
                    int v88 = v63[1];
                  }
                  else {
                    int v88 = 255;
                  }
                  unsigned int v87 = (v88 * v86 + ((v88 * v86) >> 8) + 1) >> 8;
                }
                v64[1] = v87;
LABEL_92:
                int v89 = &v63[2 * v507];
                if ((unint64_t)v89 >= v49) {
                  uint64_t v90 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v90 = 0;
                }
                long long v63 = &v89[2 * v90];
                v64 += 2 * v507;
                --v85;
              }
              while (v85);
              v64 += 2 * v526;
              int v91 = v561;
              int v92 = &v561[2 * v530];
              if ((unint64_t)v92 >= v528) {
                uint64_t v93 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v93 = 0;
              }
              unsigned int v94 = &v92[2 * v93];
              uint64_t v95 = v49 + 2 * v93 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v95;
                int v91 = v94;
              }
              int v561 = v91;
              if (v528) {
                long long v63 = v94;
              }
              else {
                v63 += 2 * v530;
              }
              if (!--v84) {
                goto LABEL_685;
              }
            }
          case 4:
            int v96 = v563[0];
            while (1)
            {
              int v97 = v16;
              do
              {
                unsigned __int8 v98 = v64[1];
                if (~v98 == 255)
                {
                  *long long v64 = *v63;
                  if (v48) {
                    LOBYTE(v99) = v63[1];
                  }
                  else {
                    LOBYTE(v99) = -1;
                  }
                }
                else
                {
                  if (v98 == 0xFF)
                  {
                    *(_WORD *)long long v64 = 0;
                    goto LABEL_119;
                  }
                  int v100 = ~v98;
                  *long long v64 = (unsigned __int16)(*v63 * (_WORD)v100 + ((*v63 * v100) >> 8) + 1) >> 8;
                  if (v48) {
                    int v101 = v63[1];
                  }
                  else {
                    int v101 = 255;
                  }
                  unsigned int v99 = (v101 * v100 + ((v101 * v100) >> 8) + 1) >> 8;
                }
                v64[1] = v99;
LABEL_119:
                uint64_t v102 = &v63[2 * v507];
                if ((unint64_t)v102 >= v49) {
                  uint64_t v103 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v103 = 0;
                }
                long long v63 = &v102[2 * v103];
                v64 += 2 * v507;
                --v97;
              }
              while (v97);
              v64 += 2 * v526;
              unint64_t v104 = v561;
              int v105 = &v561[2 * v530];
              if ((unint64_t)v105 >= v528) {
                uint64_t v106 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v106 = 0;
              }
              int v107 = &v105[2 * v106];
              uint64_t v108 = v49 + 2 * v106 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v108;
                unint64_t v104 = v107;
              }
              int v561 = v104;
              if (v528) {
                long long v63 = v107;
              }
              else {
                v63 += 2 * v530;
              }
              if (!--v96) {
                goto LABEL_685;
              }
            }
          case 5:
            int v109 = v563[0];
            do
            {
              int v110 = v16;
              do
              {
                int v111 = v64[1];
                unsigned int v112 = v111 * *v63 + (v63[1] ^ 0xFF) * *v64;
                *long long v64 = (unsigned __int16)(v112 + (v112 >> 8) + 1) >> 8;
                v64[1] = (unsigned __int16)(255 * v111 + ((255 * v111) >> 8) + 1) >> 8;
                unsigned int v113 = &v63[2 * v507];
                if ((unint64_t)v113 >= v49) {
                  uint64_t v114 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v114 = 0;
                }
                long long v63 = &v113[2 * v114];
                v64 += 2 * v507;
                --v110;
              }
              while (v110);
              v64 += 2 * v526;
              uint64_t v115 = v561;
              int v116 = &v561[2 * v530];
              if ((unint64_t)v116 >= v528) {
                uint64_t v117 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v117 = 0;
              }
              int v118 = &v116[2 * v117];
              uint64_t v119 = v49 + 2 * v117 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v119;
                uint64_t v115 = v118;
              }
              int v561 = v115;
              if (v528) {
                long long v63 = v118;
              }
              else {
                v63 += 2 * v530;
              }
              --v109;
            }
            while (v109);
            goto LABEL_685;
          case 6:
            int v120 = v563[0];
            do
            {
              int v121 = v16;
              do
              {
                int v122 = v64[1];
                if ((_BYTE)v122 != 0xFF)
                {
                  if (~(_BYTE)v122 == 255)
                  {
                    *long long v64 = *v63;
                    if (v48) {
                      LOBYTE(v123) = v63[1];
                    }
                    else {
                      LOBYTE(v123) = -1;
                    }
                  }
                  else
                  {
                    int v124 = ~(_BYTE)v122;
                    *v64 += (unsigned __int16)(*v63 * (_WORD)v124 + ((*v63 * v124) >> 8) + 1) >> 8;
                    if (v48) {
                      int v125 = v63[1];
                    }
                    else {
                      int v125 = 255;
                    }
                    int v123 = v122 + ((v125 * v124 + ((v125 * v124) >> 8) + 1) >> 8);
                  }
                  v64[1] = v123;
                }
                uint64_t v126 = &v63[2 * v507];
                if ((unint64_t)v126 >= v49) {
                  uint64_t v127 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v127 = 0;
                }
                long long v63 = &v126[2 * v127];
                v64 += 2 * v507;
                --v121;
              }
              while (v121);
              v64 += 2 * v526;
              int v128 = v561;
              unint64_t v129 = &v561[2 * v530];
              if ((unint64_t)v129 >= v528) {
                uint64_t v130 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v130 = 0;
              }
              uint64_t v131 = &v129[2 * v130];
              uint64_t v132 = v49 + 2 * v130 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v132;
                int v128 = v131;
              }
              int v561 = v128;
              if (v528) {
                long long v63 = v131;
              }
              else {
                v63 += 2 * v530;
              }
              --v120;
            }
            while (v120);
            goto LABEL_685;
          case 7:
            int v133 = v563[0];
            do
            {
              int v134 = v16;
              do
              {
                int v135 = v63[1];
                if (v135 != 255)
                {
                  if (v63[1])
                  {
                    *long long v64 = (unsigned __int16)(*v64 * (_WORD)v135 + ((*v64 * v135) >> 8) + 1) >> 8;
                    v64[1] = (unsigned __int16)(v64[1] * (_WORD)v135 + ((v64[1] * v135) >> 8) + 1) >> 8;
                  }
                  else
                  {
                    *(_WORD *)long long v64 = 0;
                  }
                }
                unsigned int v136 = &v63[2 * v507];
                if ((unint64_t)v136 >= v49) {
                  uint64_t v137 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v137 = 0;
                }
                long long v63 = &v136[2 * v137];
                v64 += 2 * v507;
                --v134;
              }
              while (v134);
              v64 += 2 * v526;
              uint64_t v138 = v561;
              int v139 = &v561[2 * v530];
              if ((unint64_t)v139 >= v528) {
                uint64_t v140 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v140 = 0;
              }
              int v141 = &v139[2 * v140];
              uint64_t v142 = v49 + 2 * v140 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v142;
                uint64_t v138 = v141;
              }
              int v561 = v138;
              if (v528) {
                long long v63 = v141;
              }
              else {
                v63 += 2 * v530;
              }
              --v133;
            }
            while (v133);
            goto LABEL_685;
          case 8:
            int v143 = v563[0];
            do
            {
              int v144 = v16;
              do
              {
                unsigned __int8 v145 = v63[1];
                if (~v145 != 255)
                {
                  if (v145 == 0xFF)
                  {
                    *(_WORD *)long long v64 = 0;
                  }
                  else
                  {
                    int v146 = ~v145;
                    *long long v64 = (unsigned __int16)(*v64 * (_WORD)v146 + ((*v64 * v146) >> 8) + 1) >> 8;
                    v64[1] = (unsigned __int16)(v64[1] * (_WORD)v146 + ((v64[1] * v146) >> 8) + 1) >> 8;
                  }
                }
                uint64_t v147 = &v63[2 * v507];
                if ((unint64_t)v147 >= v49) {
                  uint64_t v148 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v148 = 0;
                }
                long long v63 = &v147[2 * v148];
                v64 += 2 * v507;
                --v144;
              }
              while (v144);
              v64 += 2 * v526;
              uint16x4_t v149 = v561;
              uint16x4_t v150 = &v561[2 * v530];
              if ((unint64_t)v150 >= v528) {
                uint64_t v151 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v151 = 0;
              }
              unsigned int v152 = &v150[2 * v151];
              uint64_t v153 = v49 + 2 * v151 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v153;
                uint16x4_t v149 = v152;
              }
              int v561 = v149;
              if (v528) {
                long long v63 = v152;
              }
              else {
                v63 += 2 * v530;
              }
              --v143;
            }
            while (v143);
            goto LABEL_685;
          case 9:
            int v154 = v563[0];
            do
            {
              int v155 = v16;
              do
              {
                int v156 = v63[1];
                unsigned int v157 = (v64[1] ^ 0xFF) * *v63 + v156 * *v64;
                *long long v64 = (unsigned __int16)(v157 + (v157 >> 8) + 1) >> 8;
                v64[1] = (unsigned __int16)(255 * v156 + ((255 * v156) >> 8) + 1) >> 8;
                int v158 = &v63[2 * v507];
                if ((unint64_t)v158 >= v49) {
                  uint64_t v159 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v159 = 0;
                }
                long long v63 = &v158[2 * v159];
                v64 += 2 * v507;
                --v155;
              }
              while (v155);
              v64 += 2 * v526;
              int v160 = v561;
              int v161 = &v561[2 * v530];
              if ((unint64_t)v161 >= v528) {
                uint64_t v162 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v162 = 0;
              }
              unsigned int v163 = &v161[2 * v162];
              uint64_t v164 = v49 + 2 * v162 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v164;
                int v160 = v163;
              }
              int v561 = v160;
              if (v528) {
                long long v63 = v163;
              }
              else {
                v63 += 2 * v530;
              }
              --v154;
            }
            while (v154);
            goto LABEL_685;
          case 10:
            int v165 = v563[0];
            do
            {
              int v166 = v16;
              do
              {
                int v167 = v64[1];
                int v168 = v63[1];
                unsigned int v169 = (v167 ^ 0xFF) * *v63 + (v168 ^ 0xFF) * *v64;
                *long long v64 = (unsigned __int16)(v169 + (v169 >> 8) + 1) >> 8;
                v64[1] = (unsigned __int16)(v168 * (v167 ^ 0xFF)
                                          + (v168 ^ 0xFF) * v167
                                          + ((v168 * (v167 ^ 0xFF) + (v168 ^ 0xFFu) * v167) >> 8)
                                          + 1) >> 8;
                int v170 = &v63[2 * v507];
                if ((unint64_t)v170 >= v49) {
                  uint64_t v171 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v171 = 0;
                }
                long long v63 = &v170[2 * v171];
                v64 += 2 * v507;
                --v166;
              }
              while (v166);
              v64 += 2 * v526;
              int v172 = v561;
              int v173 = &v561[2 * v530];
              if ((unint64_t)v173 >= v528) {
                uint64_t v174 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v174 = 0;
              }
              uint64_t v175 = &v173[2 * v174];
              uint64_t v176 = v49 + 2 * v174 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v176;
                int v172 = v175;
              }
              int v561 = v172;
              if (v528) {
                long long v63 = v175;
              }
              else {
                v63 += 2 * v530;
              }
              --v165;
            }
            while (v165);
            goto LABEL_685;
          case 11:
            int v177 = v563[0];
            while (1)
            {
              int v178 = v16;
              do
              {
                if (v12)
                {
                  int v179 = v64[1];
                  if (v48) {
                    goto LABEL_251;
                  }
                }
                else
                {
                  int v179 = 255;
                  if (v48)
                  {
LABEL_251:
                    int v180 = v63[1];
                    goto LABEL_254;
                  }
                }
                int v180 = 255;
LABEL_254:
                unsigned int v181 = ((v179 - *v64) | (v179 << 16)) + (v180 - *v63) + (v180 << 16);
                int v182 = (255 * ((v181 >> 8) & 0x10001)) | v181;
                *long long v64 = BYTE2(v182) - v182;
                v64[1] = BYTE2(v182);
                BOOL v183 = &v63[2 * v507];
                if ((unint64_t)v183 >= v49) {
                  uint64_t v184 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v184 = 0;
                }
                long long v63 = &v183[2 * v184];
                v64 += 2 * v507;
                --v178;
              }
              while (v178);
              v64 += 2 * v526;
              int v185 = v561;
              uint64_t v186 = &v561[2 * v530];
              if ((unint64_t)v186 >= v528) {
                uint64_t v187 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v187 = 0;
              }
              uint64_t v188 = &v186[2 * v187];
              uint64_t v189 = v49 + 2 * v187 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v189;
                int v185 = v188;
              }
              int v561 = v185;
              if (v528) {
                long long v63 = v188;
              }
              else {
                v63 += 2 * v530;
              }
              if (!--v177)
              {
LABEL_685:
                v563[0] = 0;
                goto LABEL_686;
              }
            }
          case 12:
            do
            {
              int v190 = v573[0];
              do
              {
                if (v48) {
                  int v191 = v63[1];
                }
                else {
                  int v191 = 255;
                }
                unsigned int v192 = ((*v63 + *(_WORD *)v64) & 0xFF00FFFF | (HIBYTE(*(_WORD *)v64) << 16))
                     + (v191 << 16);
                int v193 = (255 * ((v192 >> 8) & 0x10001)) | v192;
                *long long v64 = v193;
                v64[1] = BYTE2(v193);
                long long v194 = &v63[2 * v507];
                if ((unint64_t)v194 >= v49) {
                  uint64_t v195 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v195 = 0;
                }
                long long v63 = &v194[2 * v195];
                v64 += 2 * v507;
                --v190;
              }
              while (v190);
              v64 += 2 * v526;
              long long v196 = v561;
              long long v197 = &v561[2 * v530];
              if ((unint64_t)v197 >= v528) {
                uint64_t v198 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v198 = 0;
              }
              long long v199 = &v197[2 * v198];
              uint64_t v200 = v49 + 2 * v198 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v200;
                long long v196 = v199;
              }
              int v561 = v196;
              if (v528) {
                long long v63 = v199;
              }
              else {
                v63 += 2 * v530;
              }
              --v563[0];
            }
            while (v563[0]);
            goto LABEL_686;
          case 13:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v511 = v16;
            int v201 = v563[0];
            while (1)
            {
              int v202 = v511;
              do
              {
                if (v48)
                {
                  int v203 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_296;
                  }
                  if (!v12)
                  {
LABEL_294:
                    int v204 = 255;
                    goto LABEL_295;
                  }
                }
                else
                {
                  int v203 = 255;
                  if (!v12) {
                    goto LABEL_294;
                  }
                }
                int v204 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v203;
                  goto LABEL_296;
                }
LABEL_295:
                unint64_t v558 = v558 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v559 = v559 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAmultiplyPDA(v559, v204, *(_WORD *)v63, v203);
LABEL_296:
                uint64_t v205 = &v63[2 * v507];
                if ((unint64_t)v205 >= v49) {
                  uint64_t v206 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v206 = 0;
                }
                long long v63 = &v205[2 * v206];
                v64 += 2 * v507;
                --v202;
              }
              while (v202);
              v64 += 2 * v526;
              long long v207 = v561;
              uint64_t v208 = &v561[2 * v530];
              uint64_t v209 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v208 < v528) {
                uint64_t v209 = 0;
              }
              uint64_t v210 = &v208[2 * v209];
              uint64_t v211 = v49 + 2 * v209 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v211;
                long long v207 = v210;
              }
              int v561 = v207;
              if (v528) {
                long long v63 = v210;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v201;
              if (!v201)
              {
LABEL_634:
                double v35 = v505;
                int v13 = v506;
                unint64_t v15 = v500;
                uint64_t v33 = v503;
                unint64_t v34 = v504;
                goto LABEL_686;
              }
            }
          case 14:
            int v212 = v563[0];
            while (1)
            {
              int v213 = v16;
              do
              {
                if (v48)
                {
                  unsigned int v214 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_320;
                  }
                  if (!v12)
                  {
LABEL_317:
                    int v215 = 255;
LABEL_318:
                    unsigned int v217 = (*v64 ^ 0xFF) * *v63 - *v64 + (*v64 << 8);
                    unsigned int v218 = 255 * (v215 + v214) - v215 * v214;
                    unsigned int v216 = (v217 + (v217 >> 8) + 1) >> 8;
                    unsigned int v214 = (v218 + (v218 >> 8) + 1) >> 8;
                    goto LABEL_319;
                  }
                }
                else
                {
                  unsigned int v214 = 255;
                  if (!v12) {
                    goto LABEL_317;
                  }
                }
                int v215 = v64[1];
                if (v64[1]) {
                  goto LABEL_318;
                }
                LOBYTE(v216) = *v63;
LABEL_319:
                *long long v64 = v216;
                v64[1] = v214;
LABEL_320:
                long long v219 = &v63[2 * v507];
                if ((unint64_t)v219 >= v49) {
                  uint64_t v220 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v220 = 0;
                }
                long long v63 = &v219[2 * v220];
                v64 += 2 * v507;
                --v213;
              }
              while (v213);
              v64 += 2 * v526;
              long long v221 = v561;
              long long v222 = &v561[2 * v530];
              if ((unint64_t)v222 >= v528) {
                uint64_t v223 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v223 = 0;
              }
              long long v224 = &v222[2 * v223];
              uint64_t v225 = v49 + 2 * v223 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v225;
                long long v221 = v224;
              }
              int v561 = v221;
              if (v528) {
                long long v63 = v224;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v212;
              if (!v212) {
                goto LABEL_686;
              }
            }
          case 15:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v512 = v16;
            int v226 = v563[0];
            while (1)
            {
              int v227 = v512;
              do
              {
                if (v48)
                {
                  int v228 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_344;
                  }
                  if (!v12)
                  {
LABEL_342:
                    int v229 = 255;
                    goto LABEL_343;
                  }
                }
                else
                {
                  int v228 = 255;
                  if (!v12) {
                    goto LABEL_342;
                  }
                }
                int v229 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v228;
                  goto LABEL_344;
                }
LABEL_343:
                unint64_t v556 = v556 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v557 = v557 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAoverlayPDA(v557, v229, *(_WORD *)v63, v228);
LABEL_344:
                long long v230 = &v63[2 * v507];
                if ((unint64_t)v230 >= v49) {
                  uint64_t v231 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v231 = 0;
                }
                long long v63 = &v230[2 * v231];
                v64 += 2 * v507;
                --v227;
              }
              while (v227);
              v64 += 2 * v526;
              uint64_t v232 = v561;
              int v233 = &v561[2 * v530];
              uint64_t v234 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v233 < v528) {
                uint64_t v234 = 0;
              }
              float v235 = &v233[2 * v234];
              uint64_t v236 = v49 + 2 * v234 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v236;
                uint64_t v232 = v235;
              }
              int v561 = v232;
              if (v528) {
                long long v63 = v235;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v226;
              if (!v226) {
                goto LABEL_634;
              }
            }
          case 16:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v513 = v16;
            int v237 = v563[0];
            while (1)
            {
              int v238 = v513;
              do
              {
                if (v48)
                {
                  int v239 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_367;
                  }
                  if (!v12)
                  {
LABEL_365:
                    int v240 = 255;
                    goto LABEL_366;
                  }
                }
                else
                {
                  int v239 = 255;
                  if (!v12) {
                    goto LABEL_365;
                  }
                }
                int v240 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v239;
                  goto LABEL_367;
                }
LABEL_366:
                unint64_t v552 = v552 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v553 = v553 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAdarkenPDA(v553, v240, *(_WORD *)v63, v239);
LABEL_367:
                v241 = &v63[2 * v507];
                if ((unint64_t)v241 >= v49) {
                  uint64_t v242 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v242 = 0;
                }
                long long v63 = &v241[2 * v242];
                v64 += 2 * v507;
                --v238;
              }
              while (v238);
              v64 += 2 * v526;
              v243 = v561;
              v244 = &v561[2 * v530];
              uint64_t v245 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v244 < v528) {
                uint64_t v245 = 0;
              }
              v246 = &v244[2 * v245];
              uint64_t v247 = v49 + 2 * v245 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v247;
                v243 = v246;
              }
              int v561 = v243;
              if (v528) {
                long long v63 = v246;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v237;
              if (!v237) {
                goto LABEL_634;
              }
            }
          case 17:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v514 = v16;
            int v248 = v563[0];
            while (1)
            {
              int v249 = v514;
              do
              {
                if (v48)
                {
                  int v250 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_390;
                  }
                  if (!v12)
                  {
LABEL_388:
                    int v251 = 255;
                    goto LABEL_389;
                  }
                }
                else
                {
                  int v250 = 255;
                  if (!v12) {
                    goto LABEL_388;
                  }
                }
                int v251 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v250;
                  goto LABEL_390;
                }
LABEL_389:
                unint64_t v554 = v554 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v555 = v555 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAlightenPDA(v555, v251, *(_WORD *)v63, v250);
LABEL_390:
                int v252 = &v63[2 * v507];
                if ((unint64_t)v252 >= v49) {
                  uint64_t v253 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v253 = 0;
                }
                long long v63 = &v252[2 * v253];
                v64 += 2 * v507;
                --v249;
              }
              while (v249);
              v64 += 2 * v526;
              v254 = v561;
              v255 = &v561[2 * v530];
              uint64_t v256 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v255 < v528) {
                uint64_t v256 = 0;
              }
              float v257 = &v255[2 * v256];
              uint64_t v258 = v49 + 2 * v256 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v258;
                v254 = v257;
              }
              int v561 = v254;
              if (v528) {
                long long v63 = v257;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v248;
              if (!v248) {
                goto LABEL_634;
              }
            }
          case 18:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v515 = v16;
            int v259 = v563[0];
            while (1)
            {
              int v260 = v515;
              do
              {
                if (v48)
                {
                  int v261 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_413;
                  }
                  if (!v12)
                  {
LABEL_411:
                    int v262 = 255;
                    goto LABEL_412;
                  }
                }
                else
                {
                  int v261 = 255;
                  if (!v12) {
                    goto LABEL_411;
                  }
                }
                int v262 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v261;
                  goto LABEL_413;
                }
LABEL_412:
                unint64_t v550 = v550 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v551 = v551 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAcolordodgePDA(v551, v262, *(_WORD *)v63, v261);
LABEL_413:
                uint64_t v263 = &v63[2 * v507];
                if ((unint64_t)v263 >= v49) {
                  uint64_t v264 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v264 = 0;
                }
                long long v63 = &v263[2 * v264];
                v64 += 2 * v507;
                --v260;
              }
              while (v260);
              v64 += 2 * v526;
              uint64_t v265 = v561;
              uint64_t v266 = &v561[2 * v530];
              uint64_t v267 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v266 < v528) {
                uint64_t v267 = 0;
              }
              v268 = &v266[2 * v267];
              uint64_t v269 = v49 + 2 * v267 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v269;
                uint64_t v265 = v268;
              }
              int v561 = v265;
              if (v528) {
                long long v63 = v268;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v259;
              if (!v259) {
                goto LABEL_634;
              }
            }
          case 19:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v516 = v16;
            int v270 = v563[0];
            while (1)
            {
              int v271 = v516;
              do
              {
                if (v48)
                {
                  int v272 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_436;
                  }
                  if (!v12)
                  {
LABEL_434:
                    int v273 = 255;
                    goto LABEL_435;
                  }
                }
                else
                {
                  int v272 = 255;
                  if (!v12) {
                    goto LABEL_434;
                  }
                }
                int v273 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v272;
                  goto LABEL_436;
                }
LABEL_435:
                unint64_t v548 = v548 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v549 = v549 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAcolorburnPDA(v549, v273, *(_WORD *)v63, v272);
LABEL_436:
                uint64_t v274 = &v63[2 * v507];
                if ((unint64_t)v274 >= v49) {
                  uint64_t v275 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v275 = 0;
                }
                long long v63 = &v274[2 * v275];
                v64 += 2 * v507;
                --v271;
              }
              while (v271);
              v64 += 2 * v526;
              int v276 = v561;
              int v277 = &v561[2 * v530];
              uint64_t v278 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v277 < v528) {
                uint64_t v278 = 0;
              }
              v279 = &v277[2 * v278];
              uint64_t v280 = v49 + 2 * v278 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v280;
                int v276 = v279;
              }
              int v561 = v276;
              if (v528) {
                long long v63 = v279;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v270;
              if (!v270) {
                goto LABEL_634;
              }
            }
          case 20:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v517 = v16;
            int v281 = v563[0];
            while (1)
            {
              int v282 = v517;
              do
              {
                if (v48)
                {
                  int v283 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_459;
                  }
                  if (!v12)
                  {
LABEL_457:
                    int v284 = 255;
                    goto LABEL_458;
                  }
                }
                else
                {
                  int v283 = 255;
                  if (!v12) {
                    goto LABEL_457;
                  }
                }
                int v284 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v283;
                  goto LABEL_459;
                }
LABEL_458:
                unint64_t v544 = v544 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v545 = v545 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAsoftlightPDA(v545, v284, *(_WORD *)v63, v283);
LABEL_459:
                v285 = &v63[2 * v507];
                if ((unint64_t)v285 >= v49) {
                  uint64_t v286 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v286 = 0;
                }
                long long v63 = &v285[2 * v286];
                v64 += 2 * v507;
                --v282;
              }
              while (v282);
              v64 += 2 * v526;
              uint64_t v287 = v561;
              int v288 = &v561[2 * v530];
              uint64_t v289 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v288 < v528) {
                uint64_t v289 = 0;
              }
              uint64_t v290 = &v288[2 * v289];
              uint64_t v291 = v49 + 2 * v289 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v291;
                uint64_t v287 = v290;
              }
              int v561 = v287;
              if (v528) {
                long long v63 = v290;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v281;
              if (!v281) {
                goto LABEL_634;
              }
            }
          case 21:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v518 = v16;
            int v292 = v563[0];
            while (1)
            {
              int v293 = v518;
              do
              {
                if (v48)
                {
                  int v294 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_482;
                  }
                  if (!v12)
                  {
LABEL_480:
                    int v295 = 255;
                    goto LABEL_481;
                  }
                }
                else
                {
                  int v294 = 255;
                  if (!v12) {
                    goto LABEL_480;
                  }
                }
                int v295 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v294;
                  goto LABEL_482;
                }
LABEL_481:
                unint64_t v546 = v546 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v547 = v547 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAhardlightPDA(v547, v295, *(_WORD *)v63, v294);
LABEL_482:
                int v296 = &v63[2 * v507];
                if ((unint64_t)v296 >= v49) {
                  uint64_t v297 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v297 = 0;
                }
                long long v63 = &v296[2 * v297];
                v64 += 2 * v507;
                --v293;
              }
              while (v293);
              v64 += 2 * v526;
              v298 = v561;
              float v299 = &v561[2 * v530];
              uint64_t v300 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v299 < v528) {
                uint64_t v300 = 0;
              }
              v301 = &v299[2 * v300];
              uint64_t v302 = v49 + 2 * v300 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v302;
                v298 = v301;
              }
              int v561 = v298;
              if (v528) {
                long long v63 = v301;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v292;
              if (!v292) {
                goto LABEL_634;
              }
            }
          case 22:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v519 = v16;
            int v303 = v563[0];
            while (1)
            {
              int v304 = v519;
              do
              {
                if (v48)
                {
                  int v305 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_505;
                  }
                  if (!v12)
                  {
LABEL_503:
                    int v306 = 255;
                    goto LABEL_504;
                  }
                }
                else
                {
                  int v305 = 255;
                  if (!v12) {
                    goto LABEL_503;
                  }
                }
                int v306 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v305;
                  goto LABEL_505;
                }
LABEL_504:
                unint64_t v542 = v542 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v543 = v543 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAdifferencePDA(v543, v306, *(_WORD *)v63, v305);
LABEL_505:
                uint64_t v307 = &v63[2 * v507];
                if ((unint64_t)v307 >= v49) {
                  uint64_t v308 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v308 = 0;
                }
                long long v63 = &v307[2 * v308];
                v64 += 2 * v507;
                --v304;
              }
              while (v304);
              v64 += 2 * v526;
              int v309 = v561;
              v310 = &v561[2 * v530];
              uint64_t v311 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v310 < v528) {
                uint64_t v311 = 0;
              }
              v312 = &v310[2 * v311];
              uint64_t v313 = v49 + 2 * v311 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v313;
                int v309 = v312;
              }
              int v561 = v309;
              if (v528) {
                long long v63 = v312;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v303;
              if (!v303) {
                goto LABEL_634;
              }
            }
          case 23:
            int v314 = v563[0];
            while (1)
            {
              int v315 = v16;
              do
              {
                if (v48)
                {
                  unsigned int v316 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_529;
                  }
                  if (!v12)
                  {
LABEL_526:
                    int v317 = 255;
LABEL_527:
                    unsigned int v319 = 255 * (*v63 + *v64) - 2 * *v64 * *v63;
                    unsigned int v320 = 255 * (v317 + v316) - v317 * v316;
                    unsigned int v318 = (v319 + (v319 >> 8) + 1) >> 8;
                    unsigned int v316 = (v320 + (v320 >> 8) + 1) >> 8;
                    goto LABEL_528;
                  }
                }
                else
                {
                  unsigned int v316 = 255;
                  if (!v12) {
                    goto LABEL_526;
                  }
                }
                int v317 = v64[1];
                if (v64[1]) {
                  goto LABEL_527;
                }
                LOBYTE(v318) = *v63;
LABEL_528:
                *long long v64 = v318;
                v64[1] = v316;
LABEL_529:
                int v321 = &v63[2 * v507];
                if ((unint64_t)v321 >= v49) {
                  uint64_t v322 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v322 = 0;
                }
                long long v63 = &v321[2 * v322];
                v64 += 2 * v507;
                --v315;
              }
              while (v315);
              v64 += 2 * v526;
              v323 = v561;
              v324 = &v561[2 * v530];
              if ((unint64_t)v324 >= v528) {
                uint64_t v325 = -(uint64_t)(v530 * v508);
              }
              else {
                uint64_t v325 = 0;
              }
              float v326 = &v324[2 * v325];
              uint64_t v327 = v49 + 2 * v325 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v327;
                v323 = v326;
              }
              int v561 = v323;
              if (v528) {
                long long v63 = v326;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v314;
              if (!v314) {
                goto LABEL_686;
              }
            }
          case 24:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v520 = v16;
            int v328 = v563[0];
            while (1)
            {
              int v329 = v520;
              do
              {
                if (v48)
                {
                  int v330 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_553;
                  }
                  if (!v12)
                  {
LABEL_551:
                    int v331 = 255;
                    goto LABEL_552;
                  }
                }
                else
                {
                  int v330 = 255;
                  if (!v12) {
                    goto LABEL_551;
                  }
                }
                int v331 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v330;
                  goto LABEL_553;
                }
LABEL_552:
                unint64_t v540 = v540 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v541 = v541 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAhuePDA(v541, v331, *(_WORD *)v63, v330);
LABEL_553:
                uint64_t v332 = &v63[2 * v507];
                if ((unint64_t)v332 >= v49) {
                  uint64_t v333 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v333 = 0;
                }
                long long v63 = &v332[2 * v333];
                v64 += 2 * v507;
                --v329;
              }
              while (v329);
              v64 += 2 * v526;
              uint64_t v334 = v561;
              int v335 = &v561[2 * v530];
              uint64_t v336 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v335 < v528) {
                uint64_t v336 = 0;
              }
              uint64_t v337 = &v335[2 * v336];
              uint64_t v338 = v49 + 2 * v336 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v338;
                uint64_t v334 = v337;
              }
              int v561 = v334;
              if (v528) {
                long long v63 = v337;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v328;
              if (!v328) {
                goto LABEL_634;
              }
            }
          case 25:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v521 = v16;
            int v339 = v563[0];
            while (1)
            {
              int v340 = v521;
              do
              {
                if (v48)
                {
                  int v341 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_576;
                  }
                  if (!v12)
                  {
LABEL_574:
                    int v342 = 255;
                    goto LABEL_575;
                  }
                }
                else
                {
                  int v341 = 255;
                  if (!v12) {
                    goto LABEL_574;
                  }
                }
                int v342 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v341;
                  goto LABEL_576;
                }
LABEL_575:
                unint64_t v538 = v538 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v539 = v539 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAhuePDA(v539, v342, *(_WORD *)v63, v341);
LABEL_576:
                float v343 = &v63[2 * v507];
                if ((unint64_t)v343 >= v49) {
                  uint64_t v344 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v344 = 0;
                }
                long long v63 = &v343[2 * v344];
                v64 += 2 * v507;
                --v340;
              }
              while (v340);
              v64 += 2 * v526;
              float v345 = v561;
              BOOL v346 = &v561[2 * v530];
              uint64_t v347 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v346 < v528) {
                uint64_t v347 = 0;
              }
              int v348 = &v346[2 * v347];
              uint64_t v349 = v49 + 2 * v347 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v349;
                float v345 = v348;
              }
              int v561 = v345;
              if (v528) {
                long long v63 = v348;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v339;
              if (!v339) {
                goto LABEL_634;
              }
            }
          case 26:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v522 = v16;
            int v350 = v563[0];
            while (1)
            {
              int v351 = v522;
              do
              {
                if (v48)
                {
                  int v352 = v63[1];
                  if (!v63[1]) {
                    goto LABEL_599;
                  }
                  if (!v12)
                  {
LABEL_597:
                    int v353 = 255;
                    goto LABEL_598;
                  }
                }
                else
                {
                  int v352 = 255;
                  if (!v12) {
                    goto LABEL_597;
                  }
                }
                int v353 = v64[1];
                if (!v64[1])
                {
                  *long long v64 = *v63;
                  v64[1] = v352;
                  goto LABEL_599;
                }
LABEL_598:
                unint64_t v536 = v536 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
                unint64_t v534 = v534 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
                *(_WORD *)long long v64 = PDAhuePDA(*(_WORD *)v63, v352, *(_WORD *)v64, v353);
LABEL_599:
                int v354 = &v63[2 * v507];
                if ((unint64_t)v354 >= v49) {
                  uint64_t v355 = -(uint64_t)(int)v510;
                }
                else {
                  uint64_t v355 = 0;
                }
                long long v63 = &v354[2 * v355];
                v64 += 2 * v507;
                --v351;
              }
              while (v351);
              v64 += 2 * v526;
              float v356 = v561;
              v357 = &v561[2 * v530];
              uint64_t v358 = -(uint64_t)(v530 * v508);
              if ((unint64_t)v357 < v528) {
                uint64_t v358 = 0;
              }
              uint64_t v359 = &v357[2 * v358];
              uint64_t v360 = v49 + 2 * v358 + 2 * v530;
              if (v528)
              {
                unint64_t v49 = v360;
                float v356 = v359;
              }
              int v561 = v356;
              if (v528) {
                long long v63 = v359;
              }
              else {
                v63 += 2 * v530;
              }
              v563[0] = --v350;
              if (!v350) {
                goto LABEL_634;
              }
            }
          case 27:
            uint64_t v503 = v33;
            unint64_t v504 = v34;
            __int16 v505 = v35;
            int v523 = v16;
            int v361 = v563[0];
            break;
          default:
            goto LABEL_686;
        }
        break;
      }
LABEL_613:
      int v362 = v523;
      while (1)
      {
        if (v48)
        {
          int v363 = v63[1];
          if (!v63[1]) {
            goto LABEL_622;
          }
          if (!v12) {
            goto LABEL_620;
          }
        }
        else
        {
          int v363 = 255;
          if (!v12)
          {
LABEL_620:
            int v364 = 255;
LABEL_621:
            unint64_t v531 = v531 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v63;
            unint64_t v532 = v532 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v64;
            *(_WORD *)long long v64 = PDAhuePDA(v532, v364, *(_WORD *)v63, v363);
            goto LABEL_622;
          }
        }
        int v364 = v64[1];
        if (v64[1]) {
          goto LABEL_621;
        }
        *long long v64 = *v63;
        v64[1] = v363;
LABEL_622:
        v365 = &v63[2 * v507];
        if ((unint64_t)v365 >= v49) {
          uint64_t v366 = -(uint64_t)(int)v510;
        }
        else {
          uint64_t v366 = 0;
        }
        long long v63 = &v365[2 * v366];
        v64 += 2 * v507;
        if (!--v362)
        {
          v64 += 2 * v526;
          uint64_t v367 = v561;
          int v368 = &v561[2 * v530];
          uint64_t v369 = -(uint64_t)(v530 * v508);
          if ((unint64_t)v368 < v528) {
            uint64_t v369 = 0;
          }
          uint64_t v370 = &v368[2 * v369];
          uint64_t v371 = v49 + 2 * v369 + 2 * v530;
          if (v528)
          {
            unint64_t v49 = v371;
            uint64_t v367 = v370;
          }
          int v561 = v367;
          if (v528) {
            long long v63 = v370;
          }
          else {
            v63 += 2 * v530;
          }
          v563[0] = --v361;
          if (!v361) {
            goto LABEL_634;
          }
          goto LABEL_613;
        }
      }
    }
    int v507 = v41;
    int v508 = 0;
    unint64_t v65 = v41 * (int)v16;
    unint64_t v526 = v34 - v65;
    unint64_t v49 = -1;
    unint64_t v38 = v510;
    goto LABEL_46;
  }
  int v21 = *(_DWORD *)(v5 + 128);
  if ((v21 | 8) == 8)
  {
    if ((*(_DWORD *)v5 & 0xFF00) == 0x400) {
      GRAYa8_mark_constmask(v5, v13, v6, v7, v8, v9, v10);
    }
    else {
      GRAYa8_mark_pixelmask(v5, v13);
    }
    return 1;
  }
  int v42 = *(_DWORD *)(v5 + 112);
  int v43 = *(_DWORD *)(v5 + 116);
  unsigned int v44 = (v42 + 15) & 0xFFFFFFF0;
  size_t v45 = v44 * v43;
  if ((int)v45 <= 4096)
  {
    uint64_t v47 = v573;
  }
  else
  {
    uint64_t v46 = malloc_type_malloc(v45, 0x515726E6uLL);
    if (!v46) {
      return 1;
    }
    uint64_t v47 = v46;
    int32x2_t v20 = *(uint16x4_t **)(v15 + 136);
    int v21 = *(_DWORD *)(v15 + 128);
  }
  CGSConvertBitsToMask(v20, *(_DWORD *)(v15 + 124), v47, v44, v42, v43, v21);
  long long v54 = *(_OWORD *)(v15 + 112);
  long long v569 = *(_OWORD *)(v15 + 96);
  long long v570 = v54;
  long long v55 = *(_OWORD *)(v15 + 144);
  long long v571 = *(_OWORD *)(v15 + 128);
  long long v572 = v55;
  long long v56 = *(_OWORD *)(v15 + 48);
  long long v565 = *(_OWORD *)(v15 + 32);
  long long v566 = v56;
  long long v57 = *(_OWORD *)(v15 + 80);
  long long v567 = *(_OWORD *)(v15 + 64);
  long long v568 = v57;
  long long v58 = *(_OWORD *)v15;
  long long v59 = *(_OWORD *)(v15 + 16);
  *(_OWORD *)int v563 = *(_OWORD *)v15;
  long long v564 = v59;
  HIDWORD(v570) = (v42 + 15) & 0xFFFFFFF0;
  *((void *)&v571 + 1) = v47;
  if (BYTE1(v563[0]) << 8 == 1024) {
    GRAYa8_mark_constmask((uint64_t)v563, v506, *(double *)&v58, *(int16x4_t *)&v59, v51, v52, v53);
  }
  else {
    GRAYa8_mark_pixelmask((uint64_t)v563, v506);
  }
  if (v47 != (unsigned char *)v573)
  {
    long long v60 = v47;
LABEL_956:
    free(v60);
  }
  return 1;
}

uint64_t GRAYA8_mark(uint64_t a1, __n128 a2)
{
  return GRAYA8_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

unsigned char *GRAYA8_pattern(uint64_t a1, unsigned char *a2, unsigned int a3, int a4, float *a5, float a6)
{
  uint8x8_t v9 = *(float **)(*(void *)a1 + 64);
  float v11 = *v9;
  float v10 = v9[1];
  float v12 = v9[2];
  float v13 = v9[3];
  if (a2 && a3 > 1 || (a2 = malloc_type_malloc(0x32uLL, 0x705560E0uLL)) != 0)
  {
    int v14 = (int)(float)(v13 + (float)(a6 * v12));
    if (a5) {
      int v15 = a4;
    }
    else {
      int v15 = 0;
    }
    if (v15 == 4)
    {
      float v18 = a5[4];
      float v20 = *a5;
      float v19 = a5[1];
      float v21 = a5[2];
      if (v18 < v11) {
        float v22 = v11;
      }
      else {
        float v22 = a5[4];
      }
      if (v18 <= v10) {
        float v23 = v22;
      }
      else {
        float v23 = v10;
      }
      float v24 = v10;
      if (v20 <= v10)
      {
        float v24 = *a5;
        if (v20 < v11) {
          float v24 = v11;
        }
      }
      if (v19 < v11) {
        float v25 = v11;
      }
      else {
        float v25 = a5[1];
      }
      if (v19 <= v10) {
        float v26 = v25;
      }
      else {
        float v26 = v10;
      }
      if (v21 < v11) {
        float v27 = v11;
      }
      else {
        float v27 = a5[2];
      }
      BOOL v28 = v21 <= v10;
      float v29 = v10 - (float)(v9[4] * v24);
      if (v28) {
        float v30 = v27;
      }
      else {
        float v30 = v10;
      }
      float v31 = (float)((float)(v29 - (float)(v9[5] * v26)) - (float)(v9[6] * v30)) - v23;
      if (v31 >= v11) {
        float v32 = v13 + (float)((float)(v31 * a6) * v12);
      }
      else {
        float v32 = v11 * a6;
      }
    }
    else
    {
      if (v15 == 3)
      {
        float v33 = a5[1];
        float v34 = a5[2];
        if (*a5 < v11) {
          float v35 = v11;
        }
        else {
          float v35 = *a5;
        }
        if (*a5 <= v10) {
          float v36 = v35;
        }
        else {
          float v36 = v10;
        }
        float v37 = v10;
        if (v33 <= v10)
        {
          float v37 = a5[1];
          if (v33 < v11) {
            float v37 = v11;
          }
        }
        if (v34 < v11) {
          float v38 = v11;
        }
        else {
          float v38 = a5[2];
        }
        if (v34 <= v10) {
          float v39 = v38;
        }
        else {
          float v39 = v10;
        }
        float v17 = (float)((float)(v37 * v9[5]) + (float)(v9[4] * v36)) + (float)(v9[6] * v39);
      }
      else
      {
        int v16 = 0;
        if (v15 != 1)
        {
LABEL_55:
          int32x2_t v40 = vmax_s32(vmin_s32((int32x2_t)__PAIR64__(v14, v16), (int32x2_t)0xFF000000FFLL), 0);
          a2[48] = v40.i8[0];
          *(_OWORD *)a2 = xmmword_1850CDC00;
          *((_DWORD *)a2 + 6) = 0;
          *((void *)a2 + 2) = 1;
          if ((float)(v10 * v12) <= (float)v14) {
            int v41 = 0;
          }
          else {
            int v41 = a2 + 48;
          }
          *((void *)a2 + 4) = a2 + 48;
          *((void *)a2 + 5) = v41;
          a2[49] = v40.i8[4];
          return a2;
        }
        float v17 = v10;
        if (*a5 <= v10)
        {
          float v17 = *a5;
          if (*a5 < v11) {
            float v17 = v11;
          }
        }
      }
      float v32 = v13 + (float)(a6 * (float)(v12 * v17));
    }
    int v16 = (int)v32;
    goto LABEL_55;
  }
  return a2;
}

uint64_t GRAYa8_mark_constmask(uint64_t result, int a2, double a3, int16x4_t a4, double a5, uint8x8_t a6, int16x8_t a7)
{
  uint64_t v9 = *(void *)(result + 136);
  if (!v9) {
    return result;
  }
  int v11 = *(_DWORD *)(result + 4);
  int v10 = *(_DWORD *)(result + 8);
  float v12 = *(__int8 **)(result + 88);
  a4.i8[0] = *v12;
  uint64_t v13 = *(void *)(result + 48);
  a4.i8[4] = v12[1];
  unint64_t v14 = (unint64_t)*(int *)(result + 28) >> 1;
  int v15 = (unsigned __int8 *)(*(void *)(result + 40) + 2 * (*(int *)(result + 12) + v14 * *(int *)(result + 16)));
  uint64_t v16 = *(int *)(result + 124);
  unint64_t v17 = v9 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v16;
  uint64_t v231 = v16 - v11;
  unint64_t v18 = v14 - v11;
  switch(a2)
  {
    case 0:
      do
      {
        int v19 = v11;
        do
        {
          int v20 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            if (v20 == 255)
            {
              *(_WORD *)int v15 = 0;
            }
            else
            {
              int v21 = v20 ^ 0xFF;
              *int v15 = (unsigned __int16)(*v15 * (_WORD)v21 + ((*v15 * v21) >> 8) + 1) >> 8;
              v15[1] = (unsigned __int16)(v15[1] * (_WORD)v21 + ((v15[1] * v21) >> 8) + 1) >> 8;
            }
          }
          ++v17;
          v15 += 2;
          --v19;
        }
        while (v19);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 1:
      int v22 = -1;
      unsigned int v23 = v17 & 3;
      if ((v17 & 3) != 0)
      {
        v11 += v23;
        int v22 = -1 << (8 * v23);
        unint64_t v24 = v17 & 3;
        v17 &= 0xFFFFFFFFFFFFFFFCLL;
        v15 -= 2 * v24;
      }
      uint64_t v25 = ((_BYTE)v11 + (_BYTE)v17) & 3;
      if ((((_BYTE)v11 + (_BYTE)v17) & 3) != 0)
      {
        int v26 = 4 - v25;
        v23 += v26;
        unsigned int v27 = 0xFFFFFFFF >> (8 * v26);
        if (v11 >= 4) {
          uint64_t v25 = v27;
        }
        else {
          uint64_t v25 = 0;
        }
        if (v11 >= 4) {
          unsigned int v27 = -1;
        }
        v22 &= v27;
      }
      uint64_t v28 = v231 - v23;
      unint64_t v29 = v18 - v23;
      do
      {
        unsigned int v30 = *(_DWORD *)v17 & v22;
        int v31 = v11 >> 2;
        double result = v25;
        if (!v30) {
          goto LABEL_40;
        }
LABEL_22:
        if (v30 == -1)
        {
          *int v15 = a4.i8[0];
          v15[1] = a4.u8[4];
          v15[2] = a4.i8[0];
          v15[3] = a4.u8[4];
          v15[4] = a4.i8[0];
          v15[5] = a4.u8[4];
LABEL_37:
          v15[6] = a4.i8[0];
          v15[7] = a4.u8[4];
          goto LABEL_40;
        }
        while (1)
        {
          if ((_BYTE)v30)
          {
            if (v30 == 255)
            {
              *int v15 = a4.i8[0];
              v15[1] = a4.u8[4];
            }
            else
            {
              int v32 = v30 ^ 0xFF;
              *int v15 = ((unsigned __int16)(v32 * *v15 + ((v32 * *v15) >> 8) + 1) >> 8)
                   + ((unsigned __int16)(v30 * a4.u8[0]
                                       + ((v30 * a4.u8[0]) >> 8)
                                       + 1) >> 8);
              v15[1] = ((unsigned __int16)(v32 * v15[1] + ((v32 * v15[1]) >> 8) + 1) >> 8)
                     + ((unsigned __int16)(v30 * a4.u8[4]
                                         + ((v30 * a4.u8[4]) >> 8)
                                         + 1) >> 8);
            }
          }
          if (BYTE1(v30))
          {
            if (BYTE1(v30) == 255)
            {
              v15[2] = a4.i8[0];
              v15[3] = a4.u8[4];
            }
            else
            {
              int v33 = BYTE1(v30) ^ 0xFF;
              v15[2] = ((unsigned __int16)(v33 * v15[2] + ((v33 * v15[2]) >> 8) + 1) >> 8)
                     + ((unsigned __int16)(BYTE1(v30) * a4.u8[0] + ((BYTE1(v30) * a4.u8[0]) >> 8) + 1) >> 8);
              v15[3] = ((unsigned __int16)(v33 * v15[3] + ((v33 * v15[3]) >> 8) + 1) >> 8)
                     + ((unsigned __int16)(BYTE1(v30) * a4.u8[4] + ((BYTE1(v30) * a4.u8[4]) >> 8) + 1) >> 8);
            }
          }
          if (BYTE2(v30))
          {
            if (BYTE2(v30) == 255)
            {
              v15[4] = a4.i8[0];
              v15[5] = a4.u8[4];
            }
            else
            {
              int v34 = BYTE2(v30) ^ 0xFF;
              v15[4] = ((unsigned __int16)(v34 * v15[4] + ((v34 * v15[4]) >> 8) + 1) >> 8)
                     + ((unsigned __int16)(BYTE2(v30) * a4.u8[0] + ((BYTE2(v30) * a4.u8[0]) >> 8) + 1) >> 8);
              v15[5] = ((unsigned __int16)(v34 * v15[5] + ((v34 * v15[5]) >> 8) + 1) >> 8)
                     + ((unsigned __int16)(BYTE2(v30) * a4.u8[4] + ((BYTE2(v30) * a4.u8[4]) >> 8) + 1) >> 8);
            }
          }
          unsigned int v35 = HIBYTE(v30);
          if (v35 == 255) {
            goto LABEL_37;
          }
          if (v35)
          {
            unsigned int v36 = v35 * a4.u8[0] + ((v35 * a4.u8[0]) >> 8) + 1;
            unsigned int v37 = v35 * a4.u8[4] + ((v35 * a4.u8[4]) >> 8) + 1;
            int v38 = v35 ^ 0xFF;
            v15[6] = ((unsigned __int16)(v38 * v15[6] + ((v38 * v15[6]) >> 8) + 1) >> 8) + BYTE1(v36);
            v15[7] = ((unsigned __int16)(v38 * v15[7] + ((v38 * v15[7]) >> 8) + 1) >> 8) + BYTE1(v37);
          }
LABEL_40:
          while (1)
          {
            int v39 = v31;
            v15 += 8;
            --v31;
            v17 += 4;
            if (v39 < 2) {
              break;
            }
            unsigned int v30 = *(_DWORD *)v17;
            if (*(_DWORD *)v17) {
              goto LABEL_22;
            }
          }
          if (!result) {
            break;
          }
          double result = 0;
          unsigned int v30 = *(_DWORD *)v17 & v25;
        }
        v17 += v28;
        v15 += 2 * v29;
        BOOL v40 = __OFSUB__(v10--, 1);
      }
      while (!((v10 < 0) ^ v40 | (v10 == 0)));
      return result;
    case 2:
      __int8 v41 = a4.i8[4];
      int v42 = -1;
      unsigned int v43 = v17 & 3;
      if ((v17 & 3) != 0)
      {
        v11 += v43;
        int v42 = -1 << (8 * v43);
        unint64_t v44 = v17 & 3;
        v17 &= 0xFFFFFFFFFFFFFFFCLL;
        v15 -= 2 * v44;
      }
      unsigned int v45 = ((_BYTE)v11 + (_BYTE)v17) & 3;
      if ((((_BYTE)v11 + (_BYTE)v17) & 3) != 0)
      {
        unsigned int v46 = 4 - v45;
        v43 += v46;
        unsigned int v47 = 0xFFFFFFFF >> (8 * v46);
        if (v11 >= 4) {
          unsigned int v45 = 0xFFFFFFFF >> (8 * v46);
        }
        else {
          unsigned int v45 = 0;
        }
        if (v11 >= 4) {
          unsigned int v47 = -1;
        }
        v42 &= v47;
      }
      uint16x4_t v48 = (uint16x4_t)vuzp1_s16(a4, a4);
      uint64_t v49 = v231 - v43;
      unsigned int v50 = ~a4.i8[4];
      int v51 = a4.u8[0];
      int v52 = a4.u8[4];
      uint16x4_t v53 = (uint16x4_t)vdup_n_s16(v50);
      unint64_t v54 = v18 - v43;
      while (2)
      {
        unsigned int v55 = *(_DWORD *)v17 & v42;
        LODWORD(result) = v11 >> 2;
        unsigned int v56 = v45;
        if (!v55) {
          goto LABEL_70;
        }
LABEL_59:
        if (v55 == -1)
        {
          a6.i32[0] = *(_DWORD *)v15;
          uint32x4_t v57 = vmull_u16(v53, (uint16x4_t)*(_OWORD *)&vmovl_u8(a6));
          *(uint16x4_t *)a7.i8 = vsra_n_u16(v48, (uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32(v57, v57, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
          a6 = (uint8x8_t)vmovn_s16(a7);
          *(_DWORD *)int v15 = a6.i32[0];
          v15[4] = v51 + ((unsigned __int16)(v15[4] * (_WORD)v50 + ((v15[4] * v50) >> 8) + 1) >> 8);
          v15[5] = v41 + ((unsigned __int16)(v15[5] * (_WORD)v50 + ((v15[5] * v50) >> 8) + 1) >> 8);
          v15[6] = v51 + ((unsigned __int16)(v15[6] * (_WORD)v50 + ((v15[6] * v50) >> 8) + 1) >> 8);
          unsigned int v58 = (v15[7] * v50 + ((v15[7] * v50) >> 8) + 1) >> 8;
          LOBYTE(v59) = v41;
LABEL_69:
          v15[7] = v59 + v58;
          goto LABEL_70;
        }
        while (1)
        {
          if ((_BYTE)v55)
          {
            unsigned int v60 = v55 * v52 + ((v55 * v52) >> 8) + 1;
            *int v15 = ((unsigned __int16)(~(v60 >> 8) * *v15
                                     + ((~(v60 >> 8) * *v15) >> 8)
                                     + 1) >> 8)
                 + ((unsigned __int16)(v55 * (_WORD)v51
                                     + ((v55 * v51) >> 8)
                                     + 1) >> 8);
            v15[1] = ((unsigned __int16)(~(v60 >> 8) * v15[1]
                                       + ((~(v60 >> 8) * v15[1]) >> 8)
                                       + 1) >> 8)
                   + BYTE1(v60);
          }
          if ((v55 & 0xFF00) != 0)
          {
            unsigned int v61 = BYTE1(v55) * v52 + ((BYTE1(v55) * v52) >> 8) + 1;
            v15[2] = ((unsigned __int16)(~(v61 >> 8) * v15[2]
                                       + ((~(v61 >> 8) * v15[2]) >> 8)
                                       + 1) >> 8)
                   + ((unsigned __int16)(BYTE1(v55) * (_WORD)v51 + ((BYTE1(v55) * v51) >> 8) + 1) >> 8);
            v15[3] = ((unsigned __int16)(~(v61 >> 8) * v15[3]
                                       + ((~(v61 >> 8) * v15[3]) >> 8)
                                       + 1) >> 8)
                   + BYTE1(v61);
          }
          if ((v55 & 0xFF0000) != 0)
          {
            unsigned int v62 = BYTE2(v55) * v52 + ((BYTE2(v55) * v52) >> 8) + 1;
            v15[4] = ((unsigned __int16)(~(v62 >> 8) * v15[4]
                                       + ((~(v62 >> 8) * v15[4]) >> 8)
                                       + 1) >> 8)
                   + ((unsigned __int16)(BYTE2(v55) * (_WORD)v51 + ((BYTE2(v55) * v51) >> 8) + 1) >> 8);
            v15[5] = ((unsigned __int16)(~(v62 >> 8) * v15[5]
                                       + ((~(v62 >> 8) * v15[5]) >> 8)
                                       + 1) >> 8)
                   + BYTE1(v62);
          }
          unsigned int v63 = HIBYTE(v55);
          if (v63)
          {
            unsigned int v64 = v63 * v51 + ((v63 * v51) >> 8) + 1;
            unsigned int v58 = (v63 * v52 + ((v63 * v52) >> 8) + 1) >> 8;
            int v65 = ~(_BYTE)v58;
            v15[6] = ((unsigned __int16)(v65 * v15[6] + ((v65 * v15[6]) >> 8) + 1) >> 8) + BYTE1(v64);
            unsigned int v59 = (v65 * v15[7] + ((v65 * v15[7]) >> 8) + 1) >> 8;
            goto LABEL_69;
          }
LABEL_70:
          while (1)
          {
            int v66 = result;
            v15 += 8;
            double result = (result - 1);
            v17 += 4;
            if (v66 < 2) {
              break;
            }
            unsigned int v55 = *(_DWORD *)v17;
            if (*(_DWORD *)v17) {
              goto LABEL_59;
            }
          }
          if (!v56) {
            break;
          }
          unsigned int v56 = 0;
          unsigned int v55 = *(_DWORD *)v17 & v45;
        }
        v17 += v49;
        v15 += 2 * v54;
        BOOL v40 = __OFSUB__(v10--, 1);
        if (!((v10 < 0) ^ v40 | (v10 == 0))) {
          continue;
        }
        return result;
      }
    case 3:
      int32x2_t v67 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      do
      {
        int v68 = v11;
        do
        {
          int v69 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            if (v69 == 255)
            {
              uint32x2_t v70 = (uint32x2_t)vmul_s32(vdup_n_s32(v15[1]), v67);
              uint32x2_t v71 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v70, v70, 8uLL), (int32x2_t)0x100000001), 8uLL);
              LOBYTE(v72) = v71.i8[4];
              *int v15 = v71.i8[0];
            }
            else
            {
              int v73 = v15[1];
              unsigned int v74 = (v73 * v69 + ((v73 * v69) >> 8) + 1) >> 8;
              int v75 = v69 ^ 0xFF;
              *int v15 = ((unsigned __int16)(v74 * v67.i16[0] + ((v74 * v67.i32[0]) >> 8) + 1) >> 8)
                   + ((unsigned __int16)(*v15 * (_WORD)v75 + ((*v15 * v75) >> 8) + 1) >> 8);
              unsigned int v72 = ((v74 * v67.i32[1] + ((v74 * v67.i32[1]) >> 8) + 1) >> 8)
                  + ((v73 * v75 + ((v73 * v75) >> 8) + 1) >> 8);
            }
            v15[1] = v72;
          }
          ++v17;
          v15 += 2;
          --v68;
        }
        while (v68);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 4:
      int32x2_t v76 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      do
      {
        int v77 = v11;
        do
        {
          int v78 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            if (v78 == 255)
            {
              uint32x2_t v79 = (uint32x2_t)vmul_s32(vdup_n_s32(v15[1] ^ 0xFFu), v76);
              uint32x2_t v80 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v79, v79, 8uLL), (int32x2_t)0x100000001), 8uLL);
              LOBYTE(v81) = v80.i8[4];
              *int v15 = v80.i8[0];
            }
            else
            {
              int v82 = v15[1];
              unsigned int v83 = ((v82 ^ 0xFF) * v78 + (((v82 ^ 0xFFu) * v78) >> 8) + 1) >> 8;
              int v84 = v78 ^ 0xFF;
              *int v15 = ((unsigned __int16)(v83 * v76.i16[0] + ((v83 * v76.i32[0]) >> 8) + 1) >> 8)
                   + ((unsigned __int16)(*v15 * (_WORD)v84 + ((*v15 * v84) >> 8) + 1) >> 8);
              unsigned int v81 = ((v83 * v76.i32[1] + ((v83 * v76.i32[1]) >> 8) + 1) >> 8)
                  + ((v82 * v84 + ((v82 * v84) >> 8) + 1) >> 8);
            }
            v15[1] = v81;
          }
          ++v17;
          v15 += 2;
          --v77;
        }
        while (v77);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 5:
      do
      {
        int v85 = v11;
        do
        {
          int v86 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            unsigned int v87 = v86 * a4.u8[0] + ((v86 * a4.u8[0]) >> 8) + 1;
            unsigned int v88 = v86 * a4.u8[4] + ((v86 * a4.u8[4]) >> 8) + 1;
            unsigned int v89 = v88 >> 8;
            int v90 = v15[1];
            int v91 = BYTE1(v88) ^ 0xFF;
            *int v15 = (unsigned __int16)(BYTE1(v87) * (_WORD)v90
                                    + v91 * *v15
                                    + ((BYTE1(v87) * v90 + v91 * *v15) >> 8)
                                    + 1) >> 8;
            v15[1] = (unsigned __int16)((v91 + v89) * v90
                                      + (((v91 + v89) * v90) >> 8)
                                      + 1) >> 8;
          }
          ++v17;
          v15 += 2;
          --v85;
        }
        while (v85);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 6:
      do
      {
        int v92 = v11;
        do
        {
          int v93 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            int v94 = v15[1];
            if ((_BYTE)v94 != 0xFF)
            {
              if (~(_BYTE)v94 == 255)
              {
                unsigned int v95 = (v93 * a4.u8[4] + ((v93 * a4.u8[4]) >> 8) + 1) >> 8;
                *int v15 = (unsigned __int16)(v93 * a4.u8[0] + ((v93 * a4.u8[0]) >> 8) + 1) >> 8;
              }
              else
              {
                unsigned int v96 = v93 * a4.u8[0] + ((v93 * a4.u8[0]) >> 8) + 1;
                int v97 = ~(_BYTE)v94;
                *v15 += (unsigned __int16)(BYTE1(v96) * (_WORD)v97 + ((BYTE1(v96) * v97) >> 8) + 1) >> 8;
                unsigned int v98 = ((unsigned __int16)(v93 * a4.u8[4] + ((v93 * a4.u8[4]) >> 8) + 1) >> 8)
                    * v97;
                unsigned int v95 = v94 + ((v98 + (v98 >> 8) + 1) >> 8);
              }
              v15[1] = v95;
            }
          }
          ++v17;
          v15 += 2;
          --v92;
        }
        while (v92);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 7:
      do
      {
        int v99 = v11;
        do
        {
          int v100 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            if (v100 == 255)
            {
              unsigned int v101 = *v15 * a4.u8[4];
              int v102 = a4.u8[4];
            }
            else
            {
              int v102 = (~(_BYTE)v100
                                     + ((unsigned __int16)(v100 * a4.u8[4] + ((v100 * a4.u8[4]) >> 8) + 1) >> 8));
              unsigned int v101 = *v15 * v102;
            }
            *int v15 = (unsigned __int16)(v101 + (v101 >> 8) + 1) >> 8;
            v15[1] = (unsigned __int16)(v102 * v15[1] + ((v102 * v15[1]) >> 8) + 1) >> 8;
          }
          ++v17;
          v15 += 2;
          --v99;
        }
        while (v99);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 8:
      do
      {
        int v103 = v11;
        do
        {
          int v104 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            if (v104 == 255)
            {
              *int v15 = (unsigned __int16)(*v15 * ~a4.i8[4]
                                      + ((*v15 * ~a4.i8[4]) >> 8)
                                      + 1) >> 8;
              uint64_t v106 = v15 + 1;
              int v105 = v15[1];
              int v107 = ~a4.i8[4];
            }
            else
            {
              int v105 = ~((v104 * a4.u8[4] + ((v104 * a4.u8[4]) >> 8) + 1) >> 8);
              *int v15 = (unsigned __int16)(v105 * *v15 + ((v105 * *v15) >> 8) + 1) >> 8;
              uint64_t v106 = v15 + 1;
              int v107 = v15[1];
            }
            *uint64_t v106 = (unsigned __int16)(v105 * v107 + ((v105 * v107) >> 8) + 1) >> 8;
          }
          ++v17;
          v15 += 2;
          --v103;
        }
        while (v103);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 9:
      do
      {
        int v108 = v11;
        do
        {
          int v109 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            unsigned int v110 = v109 * a4.u8[0] + ((v109 * a4.u8[0]) >> 8) + 1;
            unsigned int v111 = v109 * a4.u8[4] + ((v109 * a4.u8[4]) >> 8) + 1;
            int v112 = v15[1];
            int v113 = (~(_BYTE)v109 + BYTE1(v111));
            *int v15 = (unsigned __int16)(BYTE1(v110) * (v112 ^ 0xFF)
                                    + *v15 * (_WORD)v113
                                    + ((BYTE1(v110) * (v112 ^ 0xFF) + *v15 * v113) >> 8)
                                    + 1) >> 8;
            v15[1] = (unsigned __int16)(BYTE1(v111) * (v112 ^ 0xFF)
                                      + v112 * v113
                                      + ((BYTE1(v111) * (v112 ^ 0xFFu) + v112 * v113) >> 8)
                                      + 1) >> 8;
          }
          ++v17;
          v15 += 2;
          --v108;
        }
        while (v108);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 10:
      do
      {
        int v114 = v11;
        do
        {
          int v115 = *(unsigned __int8 *)v17;
          if (*(unsigned char *)v17)
          {
            unsigned int v116 = v115 * a4.u8[0] + ((v115 * a4.u8[0]) >> 8) + 1;
            int v117 = v15[1];
            int v118 = ((unsigned __int16)(v115 * a4.u8[4] + ((v115 * a4.u8[4]) >> 8) + 1) >> 8);
            *int v15 = (unsigned __int16)(BYTE1(v116) * (v117 ^ 0xFF)
                                    + (v118 ^ 0xFF) * *v15
                                    + ((BYTE1(v116) * (v117 ^ 0xFF) + (v118 ^ 0xFF) * *v15) >> 8)
                                    + 1) >> 8;
            v15[1] = (unsigned __int16)(v118 * (v117 ^ 0xFF)
                                      + (v118 ^ 0xFF) * v117
                                      + ((v118 * (v117 ^ 0xFF) + (v118 ^ 0xFFu) * v117) >> 8)
                                      + 1) >> 8;
          }
          ++v17;
          v15 += 2;
          --v114;
        }
        while (v114);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 11:
      do
      {
        int v119 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            if (v13) {
              int v120 = v15[1];
            }
            else {
              int v120 = 255;
            }
            unsigned int v121 = ((*(unsigned char *)v17 * (a4.i8[4] - a4.i8[0])) | ((*(unsigned char *)v17
                                                                                                * a4.i8[4]) << 16))
                 + (v120 - *v15)
                 + (v120 << 16);
            int v122 = (255 * ((v121 >> 8) & 0x10001)) | v121;
            *int v15 = BYTE2(v122) - v122;
            v15[1] = BYTE2(v122);
          }
          ++v17;
          v15 += 2;
          --v119;
        }
        while (v119);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 12:
      do
      {
        int v123 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            unsigned int v124 = ((*(unsigned char *)v17 * a4.i8[0]) | ((*(unsigned char *)v17 * a4.i8[4]) << 16))
                 + *(_WORD *)v15
                 + ((*(unsigned __int16 *)v15 << 8) & 0xFF0000);
            int v125 = (255 * ((v124 >> 8) & 0x10001)) | v124;
            *int v15 = v125;
            v15[1] = BYTE2(v125);
          }
          ++v17;
          v15 += 2;
          --v123;
        }
        while (v123);
        v17 += v231;
        v15 += 2 * v18;
        --v10;
      }
      while (v10);
      return result;
    case 13:
      int32x2_t v126 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v127 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v128 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v126);
            uint32x2_t v129 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v128, v128, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v130 = vshr_n_u32(v129, 8uLL);
            if (v130.i8[4])
            {
              if (v13)
              {
                int v131 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v130.u8[4];
                  *int v15 = v130.i8[0];
                  goto LABEL_168;
                }
              }
              else
              {
                int v131 = 255;
              }
              int32x2_t v132 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v129, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v132, (int8x8_t)vdup_lane_s32(v132, 1)).u32[0];
              double result = PDAmultiplyPDA(v8, v131, v7, v130.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_168:
          ++v17;
          v15 += 2;
          --v127;
        }
        while (v127);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 14:
      int32x2_t v133 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v134 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v135 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v133);
            uint32x2_t v136 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v135, v135, 8uLL), (int32x2_t)0x100000001), 8uLL);
            if (v136.i8[4])
            {
              if (v13)
              {
                int v137 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v136.u8[4];
                  *int v15 = v136.i8[0];
                  goto LABEL_180;
                }
              }
              else
              {
                int v137 = 255;
              }
              unsigned int v138 = (*v15 ^ 0xFF) * v136.u8[0] - *v15 + (*v15 << 8);
              *int v15 = (unsigned __int16)(v138 + (v138 >> 8) + 1) >> 8;
              v15[1] = (unsigned __int16)(255 * (v137 + v136.u8[4])
                                        - v136.u8[4] * (_WORD)v137
                                        + ((255 * (v137 + v136.u8[4]) - v136.u8[4] * v137) >> 8)
                                        + 1) >> 8;
            }
          }
LABEL_180:
          ++v17;
          v15 += 2;
          --v134;
        }
        while (v134);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 15:
      int32x2_t v139 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v140 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v141 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v139);
            uint32x2_t v142 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v141, v141, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v143 = vshr_n_u32(v142, 8uLL);
            if (v143.i8[4])
            {
              if (v13)
              {
                int v144 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v143.u8[4];
                  *int v15 = v143.i8[0];
                  goto LABEL_192;
                }
              }
              else
              {
                int v144 = 255;
              }
              int32x2_t v145 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v142, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v145, (int8x8_t)vdup_lane_s32(v145, 1)).u32[0];
              double result = PDAoverlayPDA(v7, v144, v8, v143.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_192:
          ++v17;
          v15 += 2;
          --v140;
        }
        while (v140);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 16:
      int32x2_t v146 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v147 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v148 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v146);
            uint32x2_t v149 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v148, v148, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v150 = vshr_n_u32(v149, 8uLL);
            if (v150.i8[4])
            {
              if (v13)
              {
                int v151 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v150.u8[4];
                  *int v15 = v150.i8[0];
                  goto LABEL_204;
                }
              }
              else
              {
                int v151 = 255;
              }
              int32x2_t v152 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v149, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v152, (int8x8_t)vdup_lane_s32(v152, 1)).u32[0];
              double result = PDAdarkenPDA(v7, v151, v8, v150.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_204:
          ++v17;
          v15 += 2;
          --v147;
        }
        while (v147);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 17:
      int32x2_t v153 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v154 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v155 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v153);
            uint32x2_t v156 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v155, v155, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v157 = vshr_n_u32(v156, 8uLL);
            if (v157.i8[4])
            {
              if (v13)
              {
                int v158 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v157.u8[4];
                  *int v15 = v157.i8[0];
                  goto LABEL_216;
                }
              }
              else
              {
                int v158 = 255;
              }
              int32x2_t v159 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v156, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v159, (int8x8_t)vdup_lane_s32(v159, 1)).u32[0];
              double result = PDAlightenPDA(v7, v158, v8, v157.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_216:
          ++v17;
          v15 += 2;
          --v154;
        }
        while (v154);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 18:
      int32x2_t v160 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v161 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v162 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v160);
            uint32x2_t v163 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v162, v162, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v164 = vshr_n_u32(v163, 8uLL);
            if (v164.i8[4])
            {
              if (v13)
              {
                int v165 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v164.u8[4];
                  *int v15 = v164.i8[0];
                  goto LABEL_228;
                }
              }
              else
              {
                int v165 = 255;
              }
              int32x2_t v166 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v163, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v166, (int8x8_t)vdup_lane_s32(v166, 1)).u32[0];
              double result = PDAcolordodgePDA(v7, v165, v8, v164.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_228:
          ++v17;
          v15 += 2;
          --v161;
        }
        while (v161);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 19:
      __int8 v167 = a4.i8[0];
      __int8 v168 = a4.i8[4];
      int v230 = *(_DWORD *)(result + 4);
      while (1)
      {
        int v169 = v11;
        unint64_t v170 = v18;
        int v171 = v169;
        do
        {
          unsigned __int8 v172 = *(unsigned char *)v17 * v168;
          if (*(unsigned char *)v17) {
            BOOL v173 = (*(unsigned char *)v17 * v168) == 0;
          }
          else {
            BOOL v173 = 1;
          }
          if (!v173)
          {
            if (v13)
            {
              int v174 = v15[1];
              if (!v15[1])
              {
                *int v15 = *(unsigned char *)v17 * v167;
                v15[1] = v172;
                goto LABEL_242;
              }
            }
            else
            {
              int v174 = 255;
            }
            unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
            unint64_t v8 = (*(unsigned char *)v17 * v167) | ((unint64_t)(*(unsigned char *)v17 * v168) << 8) | v8 & 0xFFFFFFFFFFFF0000;
            double result = PDAcolorburnPDA(v7, v174, v8, (*(unsigned char *)v17 * v168));
            *(_WORD *)int v15 = result;
          }
LABEL_242:
          ++v17;
          v15 += 2;
          --v171;
        }
        while (v171);
        v17 += v231;
        unint64_t v18 = v170;
        v15 += 2 * v170;
        --v10;
        int v11 = v230;
        if (!v10) {
          return result;
        }
      }
    case 20:
      int32x2_t v175 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v176 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v177 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v175);
            uint32x2_t v178 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v177, v177, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v179 = vshr_n_u32(v178, 8uLL);
            if (v179.i8[4])
            {
              if (v13)
              {
                int v180 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v179.u8[4];
                  *int v15 = v179.i8[0];
                  goto LABEL_254;
                }
              }
              else
              {
                int v180 = 255;
              }
              int32x2_t v181 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v178, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v181, (int8x8_t)vdup_lane_s32(v181, 1)).u32[0];
              double result = PDAsoftlightPDA(v7, v180, v8, v179.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_254:
          ++v17;
          v15 += 2;
          --v176;
        }
        while (v176);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 21:
      int32x2_t v182 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v183 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v184 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v182);
            uint32x2_t v185 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v184, v184, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v186 = vshr_n_u32(v185, 8uLL);
            if (v186.i8[4])
            {
              if (v13)
              {
                int v187 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v186.u8[4];
                  *int v15 = v186.i8[0];
                  goto LABEL_266;
                }
              }
              else
              {
                int v187 = 255;
              }
              int32x2_t v188 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v185, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v188, (int8x8_t)vdup_lane_s32(v188, 1)).u32[0];
              double result = PDAhardlightPDA(v7, v187, v8, v186.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_266:
          ++v17;
          v15 += 2;
          --v183;
        }
        while (v183);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 22:
      int32x2_t v189 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v190 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v191 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v189);
            uint32x2_t v192 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v191, v191, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v193 = vshr_n_u32(v192, 8uLL);
            if (v193.i8[4])
            {
              if (v13)
              {
                int v194 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v193.u8[4];
                  *int v15 = v193.i8[0];
                  goto LABEL_278;
                }
              }
              else
              {
                int v194 = 255;
              }
              int32x2_t v195 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v192, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v195, (int8x8_t)vdup_lane_s32(v195, 1)).u32[0];
              double result = PDAdifferencePDA(v7, v194, v8, v193.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_278:
          ++v17;
          v15 += 2;
          --v190;
        }
        while (v190);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 23:
      while (1)
      {
        int v196 = v11;
        do
        {
          LOBYTE(v197) = *(unsigned char *)v17 * a4.i8[4];
          if (*(unsigned char *)v17) {
            BOOL v198 = (*(unsigned char *)v17 * a4.i8[4]) == 0;
          }
          else {
            BOOL v198 = 1;
          }
          if (!v198)
          {
            if (v13)
            {
              int v199 = v15[1];
              if (!v15[1])
              {
                *int v15 = *(unsigned char *)v17 * a4.i8[0];
LABEL_291:
                v15[1] = v197;
                goto LABEL_292;
              }
            }
            else
            {
              int v199 = 255;
            }
            unsigned int v200 = 255 * (*v15 + (*(unsigned char *)v17 * a4.i8[0]))
                 - 2 * (*(unsigned char *)v17 * a4.i8[0]) * *v15;
            unsigned int v201 = 255 * (v199 + (*(unsigned char *)v17 * a4.i8[4]))
                 - v199 * (*(unsigned char *)v17 * a4.i8[4]);
            unsigned int v197 = (v201 + (v201 >> 8) + 1) >> 8;
            *int v15 = (unsigned __int16)(v200 + (v200 >> 8) + 1) >> 8;
            goto LABEL_291;
          }
LABEL_292:
          ++v17;
          v15 += 2;
          --v196;
        }
        while (v196);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 24:
      int32x2_t v202 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v203 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v204 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v202);
            uint32x2_t v205 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v204, v204, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v206 = vshr_n_u32(v205, 8uLL);
            if (v206.i8[4])
            {
              if (v13)
              {
                int v207 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v206.u8[4];
                  *int v15 = v206.i8[0];
                  goto LABEL_304;
                }
              }
              else
              {
                int v207 = 255;
              }
              int32x2_t v208 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v205, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v208, (int8x8_t)vdup_lane_s32(v208, 1)).u32[0];
              double result = PDAhuePDA(v7, v207, v8, v206.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_304:
          ++v17;
          v15 += 2;
          --v203;
        }
        while (v203);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 25:
      int32x2_t v209 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v210 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v211 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v209);
            uint32x2_t v212 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v211, v211, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v213 = vshr_n_u32(v212, 8uLL);
            if (v213.i8[4])
            {
              if (v13)
              {
                int v214 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v213.u8[4];
                  *int v15 = v213.i8[0];
                  goto LABEL_316;
                }
              }
              else
              {
                int v214 = 255;
              }
              int32x2_t v215 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v212, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v215, (int8x8_t)vdup_lane_s32(v215, 1)).u32[0];
              double result = PDAhuePDA(v7, v214, v8, v213.u8[4]);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_316:
          ++v17;
          v15 += 2;
          --v210;
        }
        while (v210);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 26:
      int32x2_t v216 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      while (1)
      {
        int v217 = v11;
        do
        {
          if (*(unsigned char *)v17)
          {
            uint32x2_t v218 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v216);
            uint32x2_t v219 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v218, v218, 8uLL), (int32x2_t)0x100000001);
            uint32x2_t v220 = vshr_n_u32(v219, 8uLL);
            if (v220.i8[4])
            {
              if (v13)
              {
                int v221 = v15[1];
                if (!v15[1])
                {
                  v15[1] = v220.u8[4];
                  *int v15 = v220.i8[0];
                  goto LABEL_328;
                }
              }
              else
              {
                int v221 = 255;
              }
              int32x2_t v222 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v219, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
              unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v222, (int8x8_t)vdup_lane_s32(v222, 1)).u32[0];
              unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
              double result = PDAhuePDA(v7, v220.u8[4], v8, v221);
              *(_WORD *)int v15 = result;
            }
          }
LABEL_328:
          ++v17;
          v15 += 2;
          --v217;
        }
        while (v217);
        v17 += v231;
        v15 += 2 * v18;
        if (!--v10) {
          return result;
        }
      }
    case 27:
      int32x2_t v223 = (int32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)0xFF000000FFLL);
      break;
    default:
      return result;
  }
LABEL_332:
  int v224 = v11;
  while (1)
  {
    if (!*(unsigned char *)v17) {
      goto LABEL_340;
    }
    uint32x2_t v225 = (uint32x2_t)vmul_s32(vdup_n_s32(*(unsigned __int8 *)v17), v223);
    uint32x2_t v226 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v225, v225, 8uLL), (int32x2_t)0x100000001);
    uint32x2_t v227 = vshr_n_u32(v226, 8uLL);
    if (!v227.i8[4]) {
      goto LABEL_340;
    }
    if (!v13) {
      break;
    }
    int v228 = v15[1];
    if (v15[1]) {
      goto LABEL_339;
    }
    v15[1] = v227.u8[4];
    *int v15 = v227.i8[0];
LABEL_340:
    ++v17;
    v15 += 2;
    if (!--v224)
    {
      v17 += v231;
      v15 += 2 * v18;
      if (!--v10) {
        return result;
      }
      goto LABEL_332;
    }
  }
  int v228 = 255;
LABEL_339:
  int32x2_t v229 = (int32x2_t)vand_s8((int8x8_t)vshl_u32(v226, (uint32x2_t)4294967288), (int8x8_t)0xFF00000000FFLL);
  unint64_t v7 = v7 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v15;
  unint64_t v8 = v8 & 0xFFFFFFFFFFFF0000 | vorr_s8((int8x8_t)v229, (int8x8_t)vdup_lane_s32(v229, 1)).u32[0];
  double result = PDAhuePDA(v7, v228, v8, v227.u8[4]);
  *(_WORD *)int v15 = result;
  goto LABEL_340;
}

_DWORD *RGBA32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  unsigned int v8 = PIXELCONSTANT_14645(*(float **)(*(void *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 3 || (a2 = malloc_type_malloc(0x34uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDDC0;
    a2[6] = 0;
    a2[12] = v8 & 0xFF00FF00 | (v8 << 16) | BYTE2(v8);
    *((void *)a2 + 2) = 1;
    if (HIBYTE(v8) == 255) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = (char *)(a2 + 12);
    }
    *((void *)a2 + 4) = a2 + 12;
    *((void *)a2 + 5) = v9;
  }
  return a2;
}

uint64_t rgba32_mark(uint64_t a1, __n128 a2)
{
  unint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v3;
  uint64_t v563 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *v2;
  if (*(_DWORD *)(v3 + 132))
  {
    if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken != -1) {
      dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken, &__block_literal_global_15_13639);
    }
    BOOL v7 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result != 0;
  }
  else
  {
    BOOL v7 = 0;
  }
  int v8 = *(_DWORD *)v5;
  uint64_t v9 = *(void *)(v5 + 96);
  uint64_t v10 = *(void *)(v5 + 48);
  uint64_t v11 = *(unsigned int *)(*(void *)(v6 + 56)
                        + 16 * *(_DWORD *)v5
                        + 8 * (v9 == 0)
                        + 4 * (v10 == 0));
  if ((int)v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v13 = *(unsigned int *)(v5 + 4);
  unsigned int v14 = v13 - 1;
  if ((int)v13 < 1) {
    return 0;
  }
  int v15 = *(_DWORD *)(v5 + 8);
  if (v15 < 1) {
    return 0;
  }
  if ((int)v11 >= 24)
  {
    if (*(_DWORD *)v6 == 134755144) {
      uint64_t v11 = (v11 + 4);
    }
    else {
      uint64_t v11 = v11;
    }
  }
  uint64_t v16 = *(uint16x4_t **)(v5 + 136);
  if ((v8 & 0xFF0000) != 0x50000 && v16)
  {
    int v17 = *(_DWORD *)(v5 + 128);
    if ((v17 | 8) == 8)
    {
      if ((*(_DWORD *)v5 & 0xFF00) == 0x400)
      {
        rgba32_mark_constmask(v5, v11);
      }
      else if (v7 && ((1 << v11) & 0xFFFFFE) != 0)
      {
        rgba32_mark_pixelmask_template(v5, v11);
      }
      else
      {
        rgba32_mark_pixelmask(v5, v11);
      }
    }
    else
    {
      int v22 = *(_DWORD *)(v5 + 112);
      int v23 = *(_DWORD *)(v5 + 116);
      unsigned int v24 = (v22 + 15) & 0xFFFFFFF0;
      size_t v25 = v24 * v23;
      if ((int)v25 <= 4096)
      {
        unsigned int v27 = v562;
      }
      else
      {
        int v26 = malloc_type_malloc(v25, 0x8303D2FuLL);
        if (!v26) {
          return 1;
        }
        unsigned int v27 = v26;
        uint64_t v16 = *(uint16x4_t **)(v5 + 136);
        int v17 = *(_DWORD *)(v5 + 128);
      }
      CGSConvertBitsToMask(v16, *(_DWORD *)(v5 + 124), v27, v24, v22, v23, v17);
      long long v39 = *(_OWORD *)(v5 + 112);
      long long v558 = *(_OWORD *)(v5 + 96);
      long long v559 = v39;
      long long v40 = *(_OWORD *)(v5 + 144);
      long long v560 = *(_OWORD *)(v5 + 128);
      long long v561 = v40;
      long long v41 = *(_OWORD *)(v5 + 48);
      long long v554 = *(_OWORD *)(v5 + 32);
      long long v555 = v41;
      long long v42 = *(_OWORD *)(v5 + 80);
      long long v556 = *(_OWORD *)(v5 + 64);
      long long v557 = v42;
      long long v43 = *(_OWORD *)(v5 + 16);
      *(_OWORD *)unint64_t v552 = *(_OWORD *)v5;
      long long v553 = v43;
      HIDWORD(v559) = (v22 + 15) & 0xFFFFFFF0;
      *((void *)&v560 + 1) = v27;
      if (BYTE1(v552[0]) << 8 == 1024) {
        rgba32_mark_constmask((uint64_t)v552, v11);
      }
      else {
        rgba32_mark_pixelmask((uint64_t)v552, v11);
      }
      if (v27 != (unsigned char *)v562)
      {
        unint64_t v44 = v27;
        goto LABEL_1125;
      }
    }
    return 1;
  }
  uint64_t v527 = v5;
  int v540 = v11;
  if (BYTE1(v8) == 1)
  {
    if (v7 && ((1 << v11) & 0xFFFFFE) != 0)
    {
      rgba32_mark_pixelshape_template(v5, v11);
      return 1;
    }
LABEL_34:
    v562[0] = *(_DWORD *)(v5 + 4);
    v552[0] = v15;
    uint64_t v28 = *(void *)(v5 + 88);
    unint64_t v29 = (unint64_t)*(int *)(v5 + 28) >> 2;
    unint64_t v30 = *(void *)(v5 + 40) + 4 * (*(int *)(v5 + 12) + v29 * *(int *)(v5 + 16));
    int v31 = *(_DWORD *)(v5 + 56);
    int v32 = *(_DWORD *)(v5 + 60);
    int v33 = v8 & 0xFF00;
    unint64_t v34 = *(int *)(v5 + 76);
    if (v33 != 256)
    {
      LODWORD(v539) = *(_DWORD *)(v5 + 64);
      int v531 = *(_DWORD *)(v5 + 68);
      unint64_t v543 = v28 + 4 * (v34 >> 2) * v531;
      BOOL v37 = v9 != 0;
      if (v16)
      {
        uint64_t v547 = v34 >> 2;
        unint64_t v550 = *(unsigned int **)(v5 + 88);
        int v528 = *(_DWORD *)(v5 + 60);
        int v529 = *(_DWORD *)(v5 + 56);
        int v36 = 1;
        unint64_t v38 = (unint64_t)v550;
        goto LABEL_59;
      }
      unint64_t v546 = v29 - v13;
      if (v28)
      {
        uint64_t v538 = 0;
        int v45 = v31 % (int)v539;
        uint64_t v46 = v28 + 4 * (v34 >> 2) * (v32 % v531);
        unsigned int v47 = (unsigned int *)(v46 + 4 * v45);
        unint64_t v38 = v46 + 4 * (int)v539;
        int v530 = 1;
        uint64_t v547 = v34 >> 2;
        unint64_t v550 = v47;
        uint16x4_t v48 = (uint32x2_t *)(*(void *)(v5 + 40) + 4 * (*(int *)(v5 + 12) + v29 * *(int *)(v5 + 16)));
        int v528 = v32 % v531;
        int v529 = v45;
        goto LABEL_63;
      }
      int v528 = *(_DWORD *)(v5 + 60);
      int v529 = *(_DWORD *)(v5 + 56);
      unint64_t v49 = v34 >> 2;
      unint64_t v38 = 0;
      int v530 = 1;
      unint64_t v50 = v13;
      goto LABEL_62;
    }
    v28 += 4 * (v31 + (v34 >> 2) * v32);
    uint64_t v539 = v34 >> 2;
    if (v34 >> 2 == v29)
    {
      if ((uint64_t)(v30 - v28) < 1) {
        goto LABEL_39;
      }
      if (v13 < (v30 - v28) >> 2)
      {
        unint64_t v35 = v29 * (v15 - 1);
        if (v30 <= v28 + 4 * v35 + 4 * v14)
        {
          v30 += 4 * v35;
          unint64_t v29 = -(uint64_t)v29;
          int v36 = 1;
          v28 += 4 * v35;
          goto LABEL_56;
        }
LABEL_39:
        int v36 = 1;
LABEL_56:
        uint64_t v539 = v29;
        goto LABEL_57;
      }
      v30 += 4 * v14;
      int v36 = -1;
      uint64_t v539 = (unint64_t)*(int *)(v5 + 28) >> 2;
      v28 += 4 * v14;
    }
    else
    {
      int v36 = 1;
    }
LABEL_57:
    int v528 = *(_DWORD *)(v5 + 60);
    int v529 = *(_DWORD *)(v5 + 56);
    BOOL v37 = v9 != 0;
    if (v16)
    {
      int v531 = 0;
      unint64_t v543 = 0;
      unint64_t v38 = -1;
      uint64_t v547 = v539;
      unint64_t v550 = 0;
LABEL_59:
      int v530 = v36;
      shape_enum_clip_alloc((uint64_t)v2, v3, (int *)v16, v36, v29, 1, *(_DWORD *)(v5 + 104), *(_DWORD *)(v5 + 108), v13, v15);
      uint64_t v52 = v51;
      if (!v51) {
        return 1;
      }
      goto LABEL_788;
    }
    int v530 = v36;
    int v531 = 0;
    unint64_t v50 = v36 * (int)v13;
    unint64_t v546 = v29 - v50;
    unint64_t v38 = -1;
    unint64_t v49 = v539;
LABEL_62:
    uint64_t v538 = 0;
    unint64_t v543 = 0;
    uint64_t v547 = v49 - v50;
    unint64_t v550 = 0;
    unsigned int v47 = (unsigned int *)v28;
    uint16x4_t v48 = (uint32x2_t *)v30;
LABEL_63:
    while (2)
    {
      int v542 = v13;
      switch((int)v11)
      {
        case 0:
          uint16x4_t v53 = (uint32x2_t *)((char *)v48 - 4 * (int)v13 + 4);
          uint64_t v54 = v546 + (int)v13;
          if (v530 < 0) {
            uint64_t v54 = v546 - (int)v13;
          }
          else {
            uint16x4_t v53 = v48;
          }
          unsigned int v55 = (char *)v53 + 4 * ((v54 * (v552[0] - 1)) & (v54 >> 63));
          if (v54 < 0) {
            uint64_t v54 = -v54;
          }
          CGBlt_fillBytes(4 * v13, v552[0], 0, v55, 4 * v54);
          goto LABEL_786;
        case 1:
          if (BYTE1(*(_DWORD *)v5) == 2)
          {
            if ((int)v13 >= 8 && (4 * v539) <= 0x40)
            {
              v4.i32[0] = 4 * v539;
              uint8x8_t v395 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v4.i8);
              v395.i16[0] = vaddlv_u8(v395);
              if (v395.i32[0] <= 1u)
              {
                CGSFillDRAM64((unint64_t)v48, 4 * (v13 + v546), 4 * v13, v552[0], v28, 4 * v547, 4 * v539, v531, 4 * v529, v528);
                goto LABEL_786;
              }
            }
          }
          else if (BYTE1(*(_DWORD *)v5) == 1)
          {
            if (v10 == 0 || v37)
            {
              if (v530 < 0)
              {
                uint64_t v56 = v547 - (int)v13;
                v47 += -(int)v13 + 1;
                uint64_t v57 = v546 - (int)v13;
                uint16x4_t v48 = (uint32x2_t *)((char *)v48 - 4 * (int)v13 + 4);
              }
              else
              {
                uint64_t v56 = v547 + (int)v13;
                uint64_t v57 = v546 + (int)v13;
              }
              uint64_t v421 = v552[0] - 1;
              int32x2_t v422 = (char *)&v47[(v56 * v421) & (v56 >> 63)];
              if (v56 >= 0) {
                uint64_t v423 = v56;
              }
              else {
                uint64_t v423 = -v56;
              }
              if (v57 >= 0) {
                LODWORD(v424) = v57;
              }
              else {
                uint64_t v424 = -v57;
              }
              uint64_t v547 = v423;
              CGBlt_copyBytes(4 * v13, v552[0], v422, (char *)v48 + 4 * ((v57 * v421) & (v57 >> 63)), 4 * v423, 4 * v424);
            }
            else
            {
              do
              {
                int v405 = v562[0];
                do
                {
                  v48->i32[0] = *v47 | 0xFF;
                  unsigned int v406 = &v47[v530];
                  if ((unint64_t)v406 >= v38) {
                    uint64_t v407 = -(uint64_t)(int)v539;
                  }
                  else {
                    uint64_t v407 = 0;
                  }
                  unsigned int v47 = &v406[v407];
                  uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
                  --v405;
                }
                while (v405);
                uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
                uint64_t v408 = v550;
                int v409 = &v550[v547];
                if ((unint64_t)v409 >= v543) {
                  uint64_t v410 = -(v547 * v531);
                }
                else {
                  uint64_t v410 = 0;
                }
                unsigned int v411 = &v409[v410];
                uint64_t v412 = v38 + 4 * v410 + 4 * v547;
                if (v543)
                {
                  unint64_t v38 = v412;
                  uint64_t v408 = v411;
                }
                unint64_t v550 = v408;
                if (v543) {
                  unsigned int v47 = v411;
                }
                else {
                  v47 += v547;
                }
                --v552[0];
              }
              while (v552[0]);
            }
            goto LABEL_786;
          }
          if ((*(_DWORD *)v5 & 0xFF00) == 0x200)
          {
            blt_bitmap_copy_XXXX32((int)v13, v552[0], v48, v546 + (int)v13, (int)v539, v531, v28, v547, v529, v528);
          }
          else
          {
            uint64_t v396 = 4 * v530;
            if (v10 == 0 || v37)
            {
              do
              {
                int v397 = v562[0];
                do
                {
                  v48->i32[0] = *v47;
                  int v398 = &v47[v530];
                  if ((unint64_t)v398 >= v38) {
                    uint64_t v399 = -(uint64_t)(int)v539;
                  }
                  else {
                    uint64_t v399 = 0;
                  }
                  unsigned int v47 = &v398[v399];
                  uint16x4_t v48 = (uint32x2_t *)((char *)v48 + v396);
                  --v397;
                }
                while (v397);
                uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
                unint64_t v400 = v550;
                int v401 = &v550[v547];
                if ((unint64_t)v401 >= v543) {
                  uint64_t v402 = -(v547 * v531);
                }
                else {
                  uint64_t v402 = 0;
                }
                uint64_t v403 = &v401[v402];
                uint64_t v404 = v38 + 4 * v402 + 4 * v547;
                if (v543)
                {
                  unint64_t v38 = v404;
                  unint64_t v400 = v403;
                }
                unint64_t v550 = v400;
                if (v543) {
                  unsigned int v47 = v403;
                }
                else {
                  v47 += v547;
                }
                --v552[0];
              }
              while (v552[0]);
            }
            else
            {
              do
              {
                int v413 = v562[0];
                do
                {
                  v48->i32[0] = *v47 | 0xFF;
                  int v414 = &v47[v530];
                  if ((unint64_t)v414 >= v38) {
                    uint64_t v415 = -(uint64_t)(int)v539;
                  }
                  else {
                    uint64_t v415 = 0;
                  }
                  unsigned int v47 = &v414[v415];
                  uint16x4_t v48 = (uint32x2_t *)((char *)v48 + v396);
                  --v413;
                }
                while (v413);
                uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
                int32x2_t v416 = v550;
                int v417 = &v550[v547];
                if ((unint64_t)v417 >= v543) {
                  uint64_t v418 = -(v547 * v531);
                }
                else {
                  uint64_t v418 = 0;
                }
                unsigned int v419 = &v417[v418];
                uint64_t v420 = v38 + 4 * v418 + 4 * v547;
                if (v543)
                {
                  unint64_t v38 = v420;
                  int32x2_t v416 = v419;
                }
                unint64_t v550 = v416;
                if (v543) {
                  unsigned int v47 = v419;
                }
                else {
                  v47 += v547;
                }
                --v552[0];
              }
              while (v552[0]);
            }
          }
          goto LABEL_786;
        case 2:
          if (*(unsigned __int8 *)(v5 + 1) << 8 != 512)
          {
            uint64_t v532 = v28;
            unint64_t v533 = v29;
            unint64_t v534 = v30;
            do
            {
              int v384 = v562[0];
              do
              {
                unsigned int v385 = *v47;
                if (*v47)
                {
                  if (*v47 == 255) {
                    v48->i32[0] = v385;
                  }
                  else {
                    DplusDM_21364(v48, v385, v48->i32[0], ~*(unsigned char *)v47);
                  }
                }
                v386 = &v47[v530];
                if ((unint64_t)v386 >= v38) {
                  uint64_t v387 = -(uint64_t)(int)v539;
                }
                else {
                  uint64_t v387 = 0;
                }
                unsigned int v47 = &v386[v387];
                uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
                --v384;
              }
              while (v384);
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
              uint64_t v388 = v550;
              __int16 v389 = &v550[v547];
              uint64_t v390 = -(v547 * v531);
              if ((unint64_t)v389 < v543) {
                uint64_t v390 = 0;
              }
              int v391 = &v389[v390];
              uint64_t v392 = v38 + 4 * v390 + 4 * v547;
              if (v543)
              {
                unint64_t v38 = v392;
                uint64_t v388 = v391;
              }
              unint64_t v550 = v388;
              if (v543) {
                unsigned int v47 = v391;
              }
              else {
                v47 += v547;
              }
              --v552[0];
            }
            while (v552[0]);
            goto LABEL_784;
          }
          blt_bitmap_blend_XXXA32((int)v13, v552[0], v48, v546 + (int)v13, (int)v539, v531, v28, v547, v529, v528);
          goto LABEL_786;
        case 3:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          do
          {
            int v58 = v562[0];
            do
            {
              if (v48->i32[0] == 255)
              {
                int v59 = *v47;
                if (!v37) {
                  int v59 = 255;
                }
                v48->i32[0] = v59 | *v47 & 0xFFFFFF00;
              }
              else if (v48->i32[0])
              {
                if (v37) {
                  unsigned __int8 v60 = *v47;
                }
                else {
                  unsigned __int8 v60 = -1;
                }
                DAM_21387(v48, *v47, v60, v48->i32[0]);
              }
              else
              {
                v48->i32[0] = 0;
              }
              unsigned int v61 = &v47[v530];
              if ((unint64_t)v61 >= v38) {
                uint64_t v62 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v62 = 0;
              }
              unsigned int v47 = &v61[v62];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v58;
            }
            while (v58);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            unsigned int v63 = v550;
            unsigned int v64 = &v550[v547];
            uint64_t v65 = -(v547 * v531);
            if ((unint64_t)v64 < v543) {
              uint64_t v65 = 0;
            }
            int v66 = &v64[v65];
            uint64_t v67 = v38 + 4 * v65 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v67;
              unsigned int v63 = v66;
            }
            unint64_t v550 = v63;
            if (v543) {
              unsigned int v47 = v66;
            }
            else {
              v47 += v547;
            }
            --v552[0];
          }
          while (v552[0]);
          goto LABEL_784;
        case 4:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          do
          {
            int v68 = v562[0];
            do
            {
              if (~v48->i8[0] == 255)
              {
                int v69 = *v47;
                if (!v37) {
                  int v69 = 255;
                }
                v48->i32[0] = v69 | *v47 & 0xFFFFFF00;
              }
              else if (v48->i8[0] == -1)
              {
                v48->i32[0] = 0;
              }
              else
              {
                if (v37) {
                  unsigned __int8 v70 = *v47;
                }
                else {
                  unsigned __int8 v70 = -1;
                }
                DAM_21387(v48, *v47, v70, ~v48->i8[0]);
              }
              uint32x2_t v71 = &v47[v530];
              if ((unint64_t)v71 >= v38) {
                uint64_t v72 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v72 = 0;
              }
              unsigned int v47 = &v71[v72];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v68;
            }
            while (v68);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v73 = v550;
            unsigned int v74 = &v550[v547];
            uint64_t v75 = -(v547 * v531);
            if ((unint64_t)v74 < v543) {
              uint64_t v75 = 0;
            }
            int32x2_t v76 = &v74[v75];
            uint64_t v77 = v38 + 4 * v75 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v77;
              int v73 = v76;
            }
            unint64_t v550 = v73;
            if (v543) {
              unsigned int v47 = v76;
            }
            else {
              v47 += v547;
            }
            --v552[0];
          }
          while (v552[0]);
          goto LABEL_784;
        case 5:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          int v78 = v552[0];
          do
          {
            int v535 = v78;
            int v79 = v13;
            do
            {
              DMplusDM_21363((unsigned int *)v48, *v47, v48->i32[0], v48->i32[0], ~*(unsigned char *)v47);
              uint32x2_t v80 = &v47[v530];
              if ((unint64_t)v80 >= v38) {
                uint64_t v81 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v81 = 0;
              }
              unsigned int v47 = &v80[v81];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v79;
            }
            while (v79);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v82 = v550;
            unsigned int v83 = &v550[v547];
            LODWORD(v13) = v542;
            uint64_t v84 = -(v547 * v531);
            if ((unint64_t)v83 < v543) {
              uint64_t v84 = 0;
            }
            int v85 = &v83[v84];
            uint64_t v86 = v38 + 4 * v84 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v86;
              int v82 = v85;
            }
            unint64_t v550 = v82;
            if (v543) {
              unsigned int v47 = v85;
            }
            else {
              v47 += v547;
            }
            int v78 = v535 - 1;
            v552[0] = v535 - 1;
          }
          while (v535 != 1);
          goto LABEL_784;
        case 6:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          do
          {
            int v87 = v562[0];
            do
            {
              if (v48->i32[0] != 0xFF)
              {
                if (~v48->i8[0] == 255)
                {
                  int v88 = *v47;
                  if (!v37) {
                    int v88 = 255;
                  }
                  v48->i32[0] = v88 | *v47 & 0xFFFFFF00;
                }
                else
                {
                  if (v37) {
                    unsigned __int8 v89 = *v47;
                  }
                  else {
                    unsigned __int8 v89 = -1;
                  }
                  DplusDAM_21386(v48, v48->i32[0], *v47, v89, ~v48->i8[0]);
                }
              }
              int v90 = &v47[v530];
              if ((unint64_t)v90 >= v38) {
                uint64_t v91 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v91 = 0;
              }
              unsigned int v47 = &v90[v91];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v87;
            }
            while (v87);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v92 = v550;
            int v93 = &v550[v547];
            uint64_t v94 = -(v547 * v531);
            if ((unint64_t)v93 < v543) {
              uint64_t v94 = 0;
            }
            unsigned int v95 = &v93[v94];
            uint64_t v96 = v38 + 4 * v94 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v96;
              int v92 = v95;
            }
            unint64_t v550 = v92;
            if (v543) {
              unsigned int v47 = v95;
            }
            else {
              v47 += v547;
            }
            --v552[0];
          }
          while (v552[0]);
          goto LABEL_784;
        case 7:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v97 = v562[0];
            do
            {
              __int32 v98 = *v47;
              if (*v47)
              {
                if (v98 == 255) {
                  goto LABEL_172;
                }
                __int32 v98 = PDM_21362(v48->i32[0], *v47);
              }
              v48->i32[0] = v98;
LABEL_172:
              int v99 = &v47[v530];
              if ((unint64_t)v99 >= v38) {
                uint64_t v100 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v100 = 0;
              }
              unsigned int v47 = &v99[v100];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v97;
            }
            while (v97);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            unsigned int v101 = v550;
            int v102 = &v550[v547];
            if ((unint64_t)v102 >= v543) {
              uint64_t v103 = -(v547 * v531);
            }
            else {
              uint64_t v103 = 0;
            }
            int v104 = &v102[v103];
            uint64_t v105 = v38 + 4 * v103 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v105;
              unsigned int v101 = v104;
            }
            unint64_t v550 = v101;
            if (v543) {
              unsigned int v47 = v104;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_784;
            }
          }
        case 8:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          do
          {
            int v106 = v562[0];
            do
            {
              int v107 = *(unsigned __int8 *)v47 ^ 0xFF;
              if (v107)
              {
                if (v107 == 255) {
                  goto LABEL_192;
                }
                int v107 = PDM_21362(v48->i32[0], v107);
              }
              v48->i32[0] = v107;
LABEL_192:
              int v108 = &v47[v530];
              if ((unint64_t)v108 >= v38) {
                uint64_t v109 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v109 = 0;
              }
              unsigned int v47 = &v108[v109];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v106;
            }
            while (v106);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            unsigned int v110 = v550;
            unsigned int v111 = &v550[v547];
            if ((unint64_t)v111 >= v543) {
              uint64_t v112 = -(v547 * v531);
            }
            else {
              uint64_t v112 = 0;
            }
            int v113 = &v111[v112];
            uint64_t v114 = v38 + 4 * v112 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v114;
              unsigned int v110 = v113;
            }
            unint64_t v550 = v110;
            if (v543) {
              unsigned int v47 = v113;
            }
            else {
              v47 += v547;
            }
            --v552[0];
          }
          while (v552[0]);
LABEL_784:
          uint64_t v5 = v527;
LABEL_785:
          LODWORD(v11) = v540;
          unint64_t v29 = v533;
          unint64_t v30 = v534;
          uint64_t v28 = v532;
LABEL_786:
          uint64_t v52 = v538;
          if (!v538) {
            return 1;
          }
          uint64_t v551 = 0;
LABEL_788:
          if (!shape_enum_clip_next(v52, (int *)&v551 + 1, &v551, v562, v552))
          {
            unint64_t v44 = (void *)v52;
            goto LABEL_1125;
          }
          uint64_t v538 = v52;
          if (v543)
          {
            uint16x4_t v48 = (uint32x2_t *)(v30 + 4 * v29 * (int)v551 + 4 * SHIDWORD(v551));
            LODWORD(v13) = v562[0];
            uint64_t v393 = v28 + 4 * v547 * (((int)v551 + *(_DWORD *)(v5 + 60)) % v531);
            unsigned int v47 = (unsigned int *)(v393 + 4 * ((HIDWORD(v551) + *(_DWORD *)(v5 + 56)) % (int)v539));
            unint64_t v38 = v393 + 4 * (int)v539;
            unint64_t v550 = v47;
            int v394 = v562[0];
            int v528 = ((int)v551 + *(_DWORD *)(v5 + 60)) % v531;
            int v529 = (HIDWORD(v551) + *(_DWORD *)(v5 + 56)) % (int)v539;
          }
          else
          {
            LODWORD(v13) = v562[0];
            int v394 = v562[0] * v530;
            uint16x4_t v48 = (uint32x2_t *)(v30 + 4 * v29 * (int)v551 + 4 * HIDWORD(v551) * v530);
            unsigned int v47 = (unsigned int *)(v28 + 4 * (int)v551 * (int)v539 + 4 * HIDWORD(v551) * v530);
            uint64_t v547 = (int)v539 - v562[0] * v530;
          }
          unint64_t v546 = v29 - v394;
          continue;
        case 9:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          int v115 = v552[0];
          do
          {
            int v536 = v115;
            int v116 = v13;
            do
            {
              DMplusDM_21363((unsigned int *)v48, *v47, ~v48->i8[0], v48->i32[0], *v47);
              int v117 = &v47[v530];
              if ((unint64_t)v117 >= v38) {
                uint64_t v118 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v118 = 0;
              }
              unsigned int v47 = &v117[v118];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v116;
            }
            while (v116);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v119 = v550;
            int v120 = &v550[v547];
            LODWORD(v13) = v542;
            uint64_t v121 = -(v547 * v531);
            if ((unint64_t)v120 < v543) {
              uint64_t v121 = 0;
            }
            int v122 = &v120[v121];
            uint64_t v123 = v38 + 4 * v121 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v123;
              int v119 = v122;
            }
            unint64_t v550 = v119;
            if (v543) {
              unsigned int v47 = v122;
            }
            else {
              v47 += v547;
            }
            int v115 = v536 - 1;
            v552[0] = v536 - 1;
          }
          while (v536 != 1);
          goto LABEL_784;
        case 10:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          int v124 = v552[0];
          do
          {
            int v537 = v124;
            int v125 = v13;
            do
            {
              DMplusDM_21363((unsigned int *)v48, *v47, ~v48->i8[0], v48->i32[0], ~*(unsigned char *)v47);
              int32x2_t v126 = &v47[v530];
              if ((unint64_t)v126 >= v38) {
                uint64_t v127 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v127 = 0;
              }
              unsigned int v47 = &v126[v127];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v125;
            }
            while (v125);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            uint32x2_t v128 = v550;
            uint32x2_t v129 = &v550[v547];
            LODWORD(v13) = v542;
            uint64_t v130 = -(v547 * v531);
            if ((unint64_t)v129 < v543) {
              uint64_t v130 = 0;
            }
            int v131 = &v129[v130];
            uint64_t v132 = v38 + 4 * v130 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v132;
              uint32x2_t v128 = v131;
            }
            unint64_t v550 = v128;
            if (v543) {
              unsigned int v47 = v131;
            }
            else {
              v47 += v547;
            }
            int v124 = v537 - 1;
            v552[0] = v537 - 1;
          }
          while (v537 != 1);
          goto LABEL_784;
        case 11:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          int v133 = v552[0];
          do
          {
            int v134 = v13;
            do
            {
              if (v10) {
                unsigned __int8 v135 = v48->i32[0];
              }
              else {
                unsigned __int8 v135 = -1;
              }
              if (v37) {
                unsigned __int8 v136 = *v47;
              }
              else {
                unsigned __int8 v136 = -1;
              }
              *(int32x2_t *)v4.i8 = DAplusdDA_21365(v48, v48->i32[0], v135, *v47, v136, v4);
              int v137 = &v47[v530];
              if ((unint64_t)v137 >= v38) {
                uint64_t v138 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v138 = 0;
              }
              unsigned int v47 = &v137[v138];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v134;
            }
            while (v134);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int32x2_t v139 = v550;
            int v140 = &v550[v547];
            LODWORD(v13) = v542;
            uint64_t v141 = -(v547 * v531);
            if ((unint64_t)v140 < v543) {
              uint64_t v141 = 0;
            }
            uint32x2_t v142 = &v140[v141];
            uint64_t v143 = v38 + 4 * v141 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v143;
              int32x2_t v139 = v142;
            }
            unint64_t v550 = v139;
            if (v543) {
              unsigned int v47 = v142;
            }
            else {
              v47 += v547;
            }
            v552[0] = --v133;
          }
          while (v133);
          goto LABEL_784;
        case 12:
          do
          {
            int v144 = v562[0];
            do
            {
              int v145 = *v47;
              if (!v37) {
                int v145 = 255;
              }
              int v146 = ((*v47 >> 8) & 0xFF00FF) + (((unsigned __int32)v48->i32[0] >> 8) & 0xFF00FF);
              v48->i32[0] = (v146 << 8) & 0xFF00FF00 | ((v145 | *v47 & 0xFF0000) + (v48->i32[0] & 0xFF00FF)) & 0xFF00FF | (15 * ((((v145 | *v47 & 0xFF0000) + (v48->i32[0] & 0xFF00FF)) >> 8) & 0x10001 | v146 & 0x1000100)) | (240 * ((((v145 | *v47 & 0xFF0000) + (v48->i32[0] & 0xFF00FF)) >> 8) & 0x10001 | v146 & 0x1000100));
              int v147 = &v47[v530];
              if ((unint64_t)v147 >= v38) {
                uint64_t v148 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v148 = 0;
              }
              unsigned int v47 = &v147[v148];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v144;
            }
            while (v144);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            uint32x2_t v149 = v550;
            uint32x2_t v150 = &v550[v547];
            if ((unint64_t)v150 >= v543) {
              uint64_t v151 = -(v547 * v531);
            }
            else {
              uint64_t v151 = 0;
            }
            int32x2_t v152 = &v150[v151];
            uint64_t v153 = v38 + 4 * v151 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v153;
              uint32x2_t v149 = v152;
            }
            unint64_t v550 = v149;
            if (v543) {
              unsigned int v47 = v152;
            }
            else {
              v47 += v547;
            }
            --v552[0];
          }
          while (v552[0]);
          goto LABEL_786;
        case 13:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v154 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v155) = -1;
LABEL_280:
                if (v10)
                {
                  unsigned int v156 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v157 = v48->i32[0];
                    goto LABEL_284;
                  }
                  __int32 v158 = v156 & 0xFFFFFF00 | v155;
                }
                else
                {
                  unsigned int v156 = *v47;
                  LOBYTE(v157) = -1;
LABEL_284:
                  __int32 v158 = PDAmultiplyPDA_21366(v48->i32[0], v157, v156, v155);
                }
                v48->i32[0] = v158;
                goto LABEL_287;
              }
              unsigned int v155 = *v47;
              if (*v47) {
                goto LABEL_280;
              }
LABEL_287:
              int32x2_t v159 = &v47[v530];
              if ((unint64_t)v159 >= v38) {
                uint64_t v160 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v160 = 0;
              }
              unsigned int v47 = &v159[v160];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v154;
            }
            while (v154);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v161 = v550;
            uint32x2_t v162 = &v550[v547];
            uint64_t v163 = -(v547 * v531);
            if ((unint64_t)v162 < v543) {
              uint64_t v163 = 0;
            }
            uint32x2_t v164 = &v162[v163];
            uint64_t v165 = v38 + 4 * v163 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v165;
              int v161 = v164;
            }
            unint64_t v550 = v161;
            if (v543) {
              unsigned int v47 = v164;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 14:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v166 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v167) = -1;
LABEL_306:
                if (v10)
                {
                  unsigned int v168 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v169 = v48->i32[0];
                    goto LABEL_310;
                  }
                  __int32 v170 = v168 & 0xFFFFFF00 | v167;
                }
                else
                {
                  unsigned int v168 = *v47;
                  LOBYTE(v169) = -1;
LABEL_310:
                  __int32 v170 = PDAscreenPDA_21367(v48->i32[0], v169, v168, v167);
                }
                v48->i32[0] = v170;
                goto LABEL_313;
              }
              unsigned int v167 = *v47;
              if (*v47) {
                goto LABEL_306;
              }
LABEL_313:
              int v171 = &v47[v530];
              if ((unint64_t)v171 >= v38) {
                uint64_t v172 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v172 = 0;
              }
              unsigned int v47 = &v171[v172];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v166;
            }
            while (v166);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            BOOL v173 = v550;
            int v174 = &v550[v547];
            uint64_t v175 = -(v547 * v531);
            if ((unint64_t)v174 < v543) {
              uint64_t v175 = 0;
            }
            int v176 = &v174[v175];
            uint64_t v177 = v38 + 4 * v175 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v177;
              BOOL v173 = v176;
            }
            unint64_t v550 = v173;
            if (v543) {
              unsigned int v47 = v176;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 15:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v178 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v179) = -1;
LABEL_332:
                if (v10)
                {
                  unsigned int v180 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v181 = v48->i32[0];
                    goto LABEL_336;
                  }
                  __int32 v182 = v180 & 0xFFFFFF00 | v179;
                }
                else
                {
                  unsigned int v180 = *v47;
                  LOBYTE(v181) = -1;
LABEL_336:
                  __int32 v182 = PDAoverlayPDA_21368(v48->i32[0], v181, v180, v179);
                }
                v48->i32[0] = v182;
                goto LABEL_339;
              }
              unsigned int v179 = *v47;
              if (*v47) {
                goto LABEL_332;
              }
LABEL_339:
              int v183 = &v47[v530];
              if ((unint64_t)v183 >= v38) {
                uint64_t v184 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v184 = 0;
              }
              unsigned int v47 = &v183[v184];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v178;
            }
            while (v178);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            uint32x2_t v185 = v550;
            uint32x2_t v186 = &v550[v547];
            uint64_t v187 = -(v547 * v531);
            if ((unint64_t)v186 < v543) {
              uint64_t v187 = 0;
            }
            int32x2_t v188 = &v186[v187];
            uint64_t v189 = v38 + 4 * v187 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v189;
              uint32x2_t v185 = v188;
            }
            unint64_t v550 = v185;
            if (v543) {
              unsigned int v47 = v188;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 16:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v190 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v191) = -1;
LABEL_358:
                if (v10)
                {
                  unsigned int v192 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v193 = v48->i32[0];
                    goto LABEL_362;
                  }
                  __int32 v194 = v192 & 0xFFFFFF00 | v191;
                }
                else
                {
                  unsigned int v192 = *v47;
                  LOBYTE(v193) = -1;
LABEL_362:
                  __int32 v194 = PDAdarkenPDA_21370(v48->i32[0], v193, v192, v191);
                }
                v48->i32[0] = v194;
                goto LABEL_365;
              }
              unsigned int v191 = *v47;
              if (*v47) {
                goto LABEL_358;
              }
LABEL_365:
              int32x2_t v195 = &v47[v530];
              if ((unint64_t)v195 >= v38) {
                uint64_t v196 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v196 = 0;
              }
              unsigned int v47 = &v195[v196];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v190;
            }
            while (v190);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            unsigned int v197 = v550;
            BOOL v198 = &v550[v547];
            uint64_t v199 = -(v547 * v531);
            if ((unint64_t)v198 < v543) {
              uint64_t v199 = 0;
            }
            unsigned int v200 = &v198[v199];
            uint64_t v201 = v38 + 4 * v199 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v201;
              unsigned int v197 = v200;
            }
            unint64_t v550 = v197;
            if (v543) {
              unsigned int v47 = v200;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 17:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v202 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v203) = -1;
LABEL_384:
                if (v10)
                {
                  unsigned int v204 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v205 = v48->i32[0];
                    goto LABEL_388;
                  }
                  __int32 v206 = v204 & 0xFFFFFF00 | v203;
                }
                else
                {
                  unsigned int v204 = *v47;
                  LOBYTE(v205) = -1;
LABEL_388:
                  __int32 v206 = PDAlightenPDA_21369(v48->i32[0], v205, v204, v203);
                }
                v48->i32[0] = v206;
                goto LABEL_391;
              }
              unsigned int v203 = *v47;
              if (*v47) {
                goto LABEL_384;
              }
LABEL_391:
              int v207 = &v47[v530];
              if ((unint64_t)v207 >= v38) {
                uint64_t v208 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v208 = 0;
              }
              unsigned int v47 = &v207[v208];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v202;
            }
            while (v202);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int32x2_t v209 = v550;
            int v210 = &v550[v547];
            uint64_t v211 = -(v547 * v531);
            if ((unint64_t)v210 < v543) {
              uint64_t v211 = 0;
            }
            uint32x2_t v212 = &v210[v211];
            uint64_t v213 = v38 + 4 * v211 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v213;
              int32x2_t v209 = v212;
            }
            unint64_t v550 = v209;
            if (v543) {
              unsigned int v47 = v212;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 18:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v214 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v215) = -1;
LABEL_410:
                if (v10)
                {
                  unsigned int v216 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v217 = v48->i32[0];
                    goto LABEL_414;
                  }
                  __int32 v218 = v216 & 0xFFFFFF00 | v215;
                }
                else
                {
                  unsigned int v216 = *v47;
                  LOBYTE(v217) = -1;
LABEL_414:
                  __int32 v218 = PDAcolordodgePDA_21371(v48->i32[0], v217, v216, v215);
                }
                v48->i32[0] = v218;
                goto LABEL_417;
              }
              unsigned int v215 = *v47;
              if (*v47) {
                goto LABEL_410;
              }
LABEL_417:
              uint32x2_t v219 = &v47[v530];
              if ((unint64_t)v219 >= v38) {
                uint64_t v220 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v220 = 0;
              }
              unsigned int v47 = &v219[v220];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v214;
            }
            while (v214);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v221 = v550;
            int32x2_t v222 = &v550[v547];
            uint64_t v223 = -(v547 * v531);
            if ((unint64_t)v222 < v543) {
              uint64_t v223 = 0;
            }
            int v224 = &v222[v223];
            uint64_t v225 = v38 + 4 * v223 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v225;
              int v221 = v224;
            }
            unint64_t v550 = v221;
            if (v543) {
              unsigned int v47 = v224;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 19:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v226 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v227) = -1;
LABEL_436:
                if (v10)
                {
                  unsigned int v228 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v229 = v48->i32[0];
                    goto LABEL_440;
                  }
                  __int32 v230 = v228 & 0xFFFFFF00 | v227;
                }
                else
                {
                  unsigned int v228 = *v47;
                  LOBYTE(v229) = -1;
LABEL_440:
                  __int32 v230 = PDAcolorburnPDA_21372(v48->i32[0], v229, v228, v227);
                }
                v48->i32[0] = v230;
                goto LABEL_443;
              }
              unsigned int v227 = *v47;
              if (*v47) {
                goto LABEL_436;
              }
LABEL_443:
              uint64_t v231 = &v47[v530];
              if ((unint64_t)v231 >= v38) {
                uint64_t v232 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v232 = 0;
              }
              unsigned int v47 = &v231[v232];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v226;
            }
            while (v226);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v233 = v550;
            uint64_t v234 = &v550[v547];
            uint64_t v235 = -(v547 * v531);
            if ((unint64_t)v234 < v543) {
              uint64_t v235 = 0;
            }
            uint64_t v236 = &v234[v235];
            uint64_t v237 = v38 + 4 * v235 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v237;
              int v233 = v236;
            }
            unint64_t v550 = v233;
            if (v543) {
              unsigned int v47 = v236;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 20:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v238 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v239) = -1;
LABEL_462:
                if (v10)
                {
                  unsigned int v240 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v241 = v48->i32[0];
                    goto LABEL_466;
                  }
                  __int32 v242 = v240 & 0xFFFFFF00 | v239;
                }
                else
                {
                  unsigned int v240 = *v47;
                  LOBYTE(v241) = -1;
LABEL_466:
                  __int32 v242 = PDAsoftlightPDA_21374(v48->i32[0], v241, v240, v239);
                }
                v48->i32[0] = v242;
                goto LABEL_469;
              }
              unsigned int v239 = *v47;
              if (*v47) {
                goto LABEL_462;
              }
LABEL_469:
              v243 = &v47[v530];
              if ((unint64_t)v243 >= v38) {
                uint64_t v244 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v244 = 0;
              }
              unsigned int v47 = &v243[v244];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v238;
            }
            while (v238);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            uint64_t v245 = v550;
            v246 = &v550[v547];
            uint64_t v247 = -(v547 * v531);
            if ((unint64_t)v246 < v543) {
              uint64_t v247 = 0;
            }
            int v248 = &v246[v247];
            uint64_t v249 = v38 + 4 * v247 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v249;
              uint64_t v245 = v248;
            }
            unint64_t v550 = v245;
            if (v543) {
              unsigned int v47 = v248;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 21:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v250 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v251) = -1;
LABEL_488:
                if (v10)
                {
                  unsigned int v252 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v253 = v48->i32[0];
                    goto LABEL_492;
                  }
                  __int32 v254 = v252 & 0xFFFFFF00 | v251;
                }
                else
                {
                  unsigned int v252 = *v47;
                  LOBYTE(v253) = -1;
LABEL_492:
                  __int32 v254 = PDAhardlightPDA_21373(v48->i32[0], v253, v252, v251);
                }
                v48->i32[0] = v254;
                goto LABEL_495;
              }
              unsigned int v251 = *v47;
              if (*v47) {
                goto LABEL_488;
              }
LABEL_495:
              v255 = &v47[v530];
              if ((unint64_t)v255 >= v38) {
                uint64_t v256 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v256 = 0;
              }
              unsigned int v47 = &v255[v256];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v250;
            }
            while (v250);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            float v257 = v550;
            uint64_t v258 = &v550[v547];
            uint64_t v259 = -(v547 * v531);
            if ((unint64_t)v258 < v543) {
              uint64_t v259 = 0;
            }
            int v260 = &v258[v259];
            uint64_t v261 = v38 + 4 * v259 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v261;
              float v257 = v260;
            }
            unint64_t v550 = v257;
            if (v543) {
              unsigned int v47 = v260;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 22:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v262 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v263) = -1;
LABEL_514:
                if (v10)
                {
                  unsigned int v264 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v265 = v48->i32[0];
                    goto LABEL_518;
                  }
                  __int32 v266 = v264 & 0xFFFFFF00 | v263;
                }
                else
                {
                  unsigned int v264 = *v47;
                  LOBYTE(v265) = -1;
LABEL_518:
                  __int32 v266 = PDAdifferencePDA_21375(v48->i32[0], v265, v264, v263);
                }
                v48->i32[0] = v266;
                goto LABEL_521;
              }
              unsigned int v263 = *v47;
              if (*v47) {
                goto LABEL_514;
              }
LABEL_521:
              uint64_t v267 = &v47[v530];
              if ((unint64_t)v267 >= v38) {
                uint64_t v268 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v268 = 0;
              }
              unsigned int v47 = &v267[v268];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v262;
            }
            while (v262);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            uint64_t v269 = v550;
            int v270 = &v550[v547];
            uint64_t v271 = -(v547 * v531);
            if ((unint64_t)v270 < v543) {
              uint64_t v271 = 0;
            }
            int v272 = &v270[v271];
            uint64_t v273 = v38 + 4 * v271 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v273;
              uint64_t v269 = v272;
            }
            unint64_t v550 = v269;
            if (v543) {
              unsigned int v47 = v272;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 23:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v274 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v275) = -1;
LABEL_540:
                if (v10)
                {
                  unsigned int v276 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v277 = v48->i32[0];
                    goto LABEL_544;
                  }
                  __int32 v278 = v276 & 0xFFFFFF00 | v275;
                }
                else
                {
                  unsigned int v276 = *v47;
                  LOBYTE(v277) = -1;
LABEL_544:
                  __int32 v278 = PDAexclusionPDA_21376(v48->i32[0], v277, v276, v275);
                }
                v48->i32[0] = v278;
                goto LABEL_547;
              }
              unsigned int v275 = *v47;
              if (*v47) {
                goto LABEL_540;
              }
LABEL_547:
              v279 = &v47[v530];
              if ((unint64_t)v279 >= v38) {
                uint64_t v280 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v280 = 0;
              }
              unsigned int v47 = &v279[v280];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v274;
            }
            while (v274);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v281 = v550;
            int v282 = &v550[v547];
            uint64_t v283 = -(v547 * v531);
            if ((unint64_t)v282 < v543) {
              uint64_t v283 = 0;
            }
            int v284 = &v282[v283];
            uint64_t v285 = v38 + 4 * v283 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v285;
              int v281 = v284;
            }
            unint64_t v550 = v281;
            if (v543) {
              unsigned int v47 = v284;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 24:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v286 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v287) = -1;
LABEL_566:
                if (v10)
                {
                  unsigned int v288 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v289 = v48->i32[0];
                    goto LABEL_570;
                  }
                  __int32 v290 = v288 & 0xFFFFFF00 | v287;
                }
                else
                {
                  unsigned int v288 = *v47;
                  LOBYTE(v289) = -1;
LABEL_570:
                  __int32 v290 = PDAhuePDA_21377(v48->i32[0], v289, v288, v287);
                }
                v48->i32[0] = v290;
                goto LABEL_573;
              }
              unsigned int v287 = *v47;
              if (*v47) {
                goto LABEL_566;
              }
LABEL_573:
              uint64_t v291 = &v47[v530];
              if ((unint64_t)v291 >= v38) {
                uint64_t v292 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v292 = 0;
              }
              unsigned int v47 = &v291[v292];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v286;
            }
            while (v286);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v293 = v550;
            int v294 = &v550[v547];
            uint64_t v295 = -(v547 * v531);
            if ((unint64_t)v294 < v543) {
              uint64_t v295 = 0;
            }
            int v296 = &v294[v295];
            uint64_t v297 = v38 + 4 * v295 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v297;
              int v293 = v296;
            }
            unint64_t v550 = v293;
            if (v543) {
              unsigned int v47 = v296;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 25:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v298 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v299) = -1;
LABEL_592:
                if (v10)
                {
                  unsigned int v300 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v301 = v48->i32[0];
                    goto LABEL_596;
                  }
                  __int32 v302 = v300 & 0xFFFFFF00 | v299;
                }
                else
                {
                  unsigned int v300 = *v47;
                  LOBYTE(v301) = -1;
LABEL_596:
                  __int32 v302 = PDAsaturationPDA_21378(v48->i32[0], v301, v300, v299);
                }
                v48->i32[0] = v302;
                goto LABEL_599;
              }
              unsigned int v299 = *v47;
              if (*v47) {
                goto LABEL_592;
              }
LABEL_599:
              int v303 = &v47[v530];
              if ((unint64_t)v303 >= v38) {
                uint64_t v304 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v304 = 0;
              }
              unsigned int v47 = &v303[v304];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v298;
            }
            while (v298);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v305 = v550;
            int v306 = &v550[v547];
            uint64_t v307 = -(v547 * v531);
            if ((unint64_t)v306 < v543) {
              uint64_t v307 = 0;
            }
            uint64_t v308 = &v306[v307];
            uint64_t v309 = v38 + 4 * v307 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v309;
              int v305 = v308;
            }
            unint64_t v550 = v305;
            if (v543) {
              unsigned int v47 = v308;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 26:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v310 = v562[0];
            do
            {
              if (v37)
              {
                unsigned int v311 = *v47;
                if (!*v47) {
                  goto LABEL_624;
                }
                if (!v10)
                {
LABEL_620:
                  unsigned int v313 = *v47;
                  unsigned int v312 = v48->i32[0];
                  LOBYTE(v314) = -1;
                  goto LABEL_621;
                }
              }
              else
              {
                LOBYTE(v311) = -1;
                if (!v10) {
                  goto LABEL_620;
                }
              }
              unsigned int v312 = v48->i32[0];
              unsigned int v313 = *v47;
              if (!v48->i32[0])
              {
                __int32 v315 = v313 & 0xFFFFFF00 | v311;
                goto LABEL_623;
              }
              __int32 v314 = v48->i32[0];
LABEL_621:
              __int32 v315 = PDAluminosityPDA_21379(v313, v311, v312, v314);
LABEL_623:
              v48->i32[0] = v315;
LABEL_624:
              unsigned int v316 = &v47[v530];
              if ((unint64_t)v316 >= v38) {
                uint64_t v317 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v317 = 0;
              }
              unsigned int v47 = &v316[v317];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v310;
            }
            while (v310);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            unsigned int v318 = v550;
            unsigned int v319 = &v550[v547];
            uint64_t v320 = -(v547 * v531);
            if ((unint64_t)v319 < v543) {
              uint64_t v320 = 0;
            }
            int v321 = &v319[v320];
            uint64_t v322 = v38 + 4 * v320 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v322;
              unsigned int v318 = v321;
            }
            unint64_t v550 = v318;
            if (v543) {
              unsigned int v47 = v321;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 27:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v323 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v324) = -1;
LABEL_643:
                if (v10)
                {
                  unsigned int v325 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v326 = v48->i32[0];
                    goto LABEL_647;
                  }
                  __int32 v327 = v325 & 0xFFFFFF00 | v324;
                }
                else
                {
                  unsigned int v325 = *v47;
                  LOBYTE(v326) = -1;
LABEL_647:
                  __int32 v327 = PDAluminosityPDA_21379(v48->i32[0], v326, v325, v324);
                }
                v48->i32[0] = v327;
                goto LABEL_650;
              }
              unsigned int v324 = *v47;
              if (*v47) {
                goto LABEL_643;
              }
LABEL_650:
              int v328 = &v47[v530];
              if ((unint64_t)v328 >= v38) {
                uint64_t v329 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v329 = 0;
              }
              unsigned int v47 = &v328[v329];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v323;
            }
            while (v323);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v330 = v550;
            int v331 = &v550[v547];
            uint64_t v332 = -(v547 * v531);
            if ((unint64_t)v331 < v543) {
              uint64_t v332 = 0;
            }
            uint64_t v333 = &v331[v332];
            uint64_t v334 = v38 + 4 * v332 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v334;
              int v330 = v333;
            }
            unint64_t v550 = v330;
            if (v543) {
              unsigned int v47 = v333;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 28:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v335 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v336) = -1;
LABEL_669:
                if (v10)
                {
                  unsigned int v337 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v338 = v48->i32[0];
                    goto LABEL_673;
                  }
                  __int32 v339 = v337 & 0xFFFFFF00 | v336;
                }
                else
                {
                  unsigned int v337 = *v47;
                  LOBYTE(v338) = -1;
LABEL_673:
                  __int32 v339 = PDAtranspose_huePDA_21380(v48->i32[0], v338, v337, v336);
                }
                v48->i32[0] = v339;
                goto LABEL_676;
              }
              unsigned int v336 = *v47;
              if (*v47) {
                goto LABEL_669;
              }
LABEL_676:
              int v340 = &v47[v530];
              if ((unint64_t)v340 >= v38) {
                uint64_t v341 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v341 = 0;
              }
              unsigned int v47 = &v340[v341];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v335;
            }
            while (v335);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v342 = v550;
            float v343 = &v550[v547];
            uint64_t v344 = -(v547 * v531);
            if ((unint64_t)v343 < v543) {
              uint64_t v344 = 0;
            }
            float v345 = &v343[v344];
            uint64_t v346 = v38 + 4 * v344 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v346;
              int v342 = v345;
            }
            unint64_t v550 = v342;
            if (v543) {
              unsigned int v47 = v345;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 29:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v347 = v562[0];
            do
            {
              if (!v37)
              {
                LOBYTE(v348) = -1;
LABEL_695:
                if (v10)
                {
                  unsigned int v349 = *v47;
                  if (v48->i32[0])
                  {
                    __int32 v350 = v48->i32[0];
                    goto LABEL_699;
                  }
                  __int32 v351 = v349 & 0xFFFFFF00 | v348;
                }
                else
                {
                  unsigned int v349 = *v47;
                  LOBYTE(v350) = -1;
LABEL_699:
                  __int32 v351 = PDAtranspose_saturationPDA_21381(v48->i32[0], v350, v349, v348);
                }
                v48->i32[0] = v351;
                goto LABEL_702;
              }
              unsigned int v348 = *v47;
              if (*v47) {
                goto LABEL_695;
              }
LABEL_702:
              int v352 = &v47[v530];
              if ((unint64_t)v352 >= v38) {
                uint64_t v353 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v353 = 0;
              }
              unsigned int v47 = &v352[v353];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v347;
            }
            while (v347);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            int v354 = v550;
            uint64_t v355 = &v550[v547];
            uint64_t v356 = -(v547 * v531);
            if ((unint64_t)v355 < v543) {
              uint64_t v356 = 0;
            }
            v357 = &v355[v356];
            uint64_t v358 = v38 + 4 * v356 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v358;
              int v354 = v357;
            }
            unint64_t v550 = v354;
            if (v543) {
              unsigned int v47 = v357;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 30:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          while (1)
          {
            int v359 = v562[0];
            do
            {
              if (v37)
              {
                unsigned int v360 = *v47;
                if (!*v47) {
                  goto LABEL_727;
                }
                if (!v10)
                {
LABEL_723:
                  unsigned int v362 = *v47;
                  unsigned int v361 = v48->i32[0];
                  LOBYTE(v363) = -1;
                  goto LABEL_724;
                }
              }
              else
              {
                LOBYTE(v360) = -1;
                if (!v10) {
                  goto LABEL_723;
                }
              }
              unsigned int v361 = v48->i32[0];
              unsigned int v362 = *v47;
              if (!v48->i32[0])
              {
                __int32 v364 = v362 & 0xFFFFFF00 | v360;
                goto LABEL_726;
              }
              __int32 v363 = v48->i32[0];
LABEL_724:
              __int32 v364 = PDAtranspose_luminosityPDA_21382(v362, v360, v361, v363);
LABEL_726:
              v48->i32[0] = v364;
LABEL_727:
              v365 = &v47[v530];
              if ((unint64_t)v365 >= v38) {
                uint64_t v366 = -(uint64_t)(int)v539;
              }
              else {
                uint64_t v366 = 0;
              }
              unsigned int v47 = &v365[v366];
              uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
              --v359;
            }
            while (v359);
            uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
            uint64_t v367 = v550;
            int v368 = &v550[v547];
            uint64_t v369 = -(v547 * v531);
            if ((unint64_t)v368 < v543) {
              uint64_t v369 = 0;
            }
            uint64_t v370 = &v368[v369];
            uint64_t v371 = v38 + 4 * v369 + 4 * v547;
            if (v543)
            {
              unint64_t v38 = v371;
              uint64_t v367 = v370;
            }
            unint64_t v550 = v367;
            if (v543) {
              unsigned int v47 = v370;
            }
            else {
              v47 += v547;
            }
            if (!--v552[0]) {
              goto LABEL_785;
            }
          }
        case 31:
          uint64_t v532 = v28;
          unint64_t v533 = v29;
          unint64_t v534 = v30;
          break;
        default:
          goto LABEL_786;
      }
      break;
    }
LABEL_741:
    int v372 = v562[0];
    while (1)
    {
      if (v37)
      {
        unsigned int v373 = *v47;
        if (!*v47) {
          goto LABEL_753;
        }
      }
      else
      {
        LOBYTE(v373) = -1;
      }
      if (v10)
      {
        unsigned int v374 = *v47;
        if (!v48->i32[0])
        {
          __int32 v376 = v374 & 0xFFFFFF00 | v373;
          goto LABEL_752;
        }
        __int32 v375 = v48->i32[0];
      }
      else
      {
        unsigned int v374 = *v47;
        LOBYTE(v375) = -1;
      }
      __int32 v376 = PDAtranspose_luminosityPDA_21382(v48->i32[0], v375, v374, v373);
LABEL_752:
      v48->i32[0] = v376;
LABEL_753:
      uint64_t v377 = &v47[v530];
      if ((unint64_t)v377 >= v38) {
        uint64_t v378 = -(uint64_t)(int)v539;
      }
      else {
        uint64_t v378 = 0;
      }
      unsigned int v47 = &v377[v378];
      uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v530);
      if (!--v372)
      {
        uint16x4_t v48 = (uint32x2_t *)((char *)v48 + 4 * v546);
        uint64_t v379 = v550;
        uint64_t v380 = &v550[v547];
        uint64_t v381 = -(v547 * v531);
        if ((unint64_t)v380 < v543) {
          uint64_t v381 = 0;
        }
        uint64_t v382 = &v380[v381];
        uint64_t v383 = v38 + 4 * v381 + 4 * v547;
        if (v543)
        {
          unint64_t v38 = v383;
          uint64_t v379 = v382;
        }
        unint64_t v550 = v379;
        if (v543) {
          unsigned int v47 = v382;
        }
        else {
          v47 += v547;
        }
        if (!--v552[0]) {
          goto LABEL_785;
        }
        goto LABEL_741;
      }
    }
  }
  if (BYTE1(v8) != 4) {
    goto LABEL_34;
  }
  v562[0] = *(_DWORD *)(v5 + 4);
  v552[0] = v15;
  unsigned int v18 = **(_DWORD **)(v5 + 88);
  unint64_t v541 = *(int *)(v5 + 28);
  unint64_t v549 = v541 >> 2;
  int v19 = (unsigned int *)(*(void *)(v5 + 40) + 4 * (*(int *)(v5 + 12) + (v541 >> 2) * *(int *)(v5 + 16)));
  unint64_t v545 = v19;
  if (v16)
  {
    shape_enum_clip_alloc((uint64_t)v2, v3, (int *)v16, 1, 1, 1, *(_DWORD *)(v5 + 104), *(_DWORD *)(v5 + 108), v13, v15);
    uint64_t v21 = v20;
    if (v20) {
      goto LABEL_1122;
    }
    return 1;
  }
  uint64_t v548 = 0;
  while (2)
  {
    unint64_t v425 = v549 - (int)v13;
    int v426 = v13;
    switch((int)v11)
    {
      case 0:
        unsigned int v427 = v552[0];
        int v428 = 4 * v13;
        int v429 = v541 & 0xFFFFFFFC;
        int v430 = 0;
        goto LABEL_882;
      case 1:
        int v430 = 0;
        int v439 = *(int **)(v527 + 88);
        if (v439) {
          int v430 = *v439;
        }
        int v428 = 4 * v13;
        unsigned int v427 = v552[0];
        int v429 = v541 & 0xFFFFFFFC;
LABEL_882:
        CGBlt_fillBytes(v428, v427, v430, (char *)v19, v429);
        goto LABEL_1120;
      case 2:
        int v544 = v13 & 3;
        int v440 = v552[0];
        unsigned int v441 = (v13 >> 2) + 1;
        do
        {
          if ((int)v13 < 4)
          {
            int v445 = v13;
          }
          else
          {
            unsigned int v442 = v441;
            do
            {
              DplusDM_21364(v19, v18, *v19, ~(_BYTE)v18);
              DplusDM_21364(v19 + 1, v18, v19[1], ~(_BYTE)v18);
              DplusDM_21364(v19 + 2, v18, v19[2], ~(_BYTE)v18);
              unsigned int v444 = v19[3];
              int v443 = v19 + 3;
              DplusDM_21364(v443, v18, v444, ~(_BYTE)v18);
              int v19 = v443 + 1;
              --v442;
            }
            while (v442 > 1);
            int v445 = v544;
          }
          if (v445 < 1)
          {
            int v447 = v19;
          }
          else
          {
            unsigned int v446 = v445 + 1;
            int v447 = v19;
            do
            {
              unsigned int v448 = *v447++;
              DplusDM_21364(v19, v18, v448, ~(_BYTE)v18);
              --v446;
              int v19 = v447;
            }
            while (v446 > 1);
          }
          int v19 = &v447[v425];
          v552[0] = --v440;
          LODWORD(v13) = v426;
        }
        while (v440);
        goto LABEL_1120;
      case 3:
        do
        {
          int v431 = v562[0];
          do
          {
            unsigned int v432 = *v19;
            if (*v19)
            {
              BOOL v433 = v432 == 255;
              unsigned int v432 = v18;
              if (!v433) {
                unsigned int v432 = PDM_21362(v18, *v19);
              }
            }
            *v19++ = v432;
            --v431;
          }
          while (v431);
          v19 += v425;
          --v552[0];
        }
        while (v552[0]);
        goto LABEL_1120;
      case 4:
        do
        {
          int v434 = v562[0];
          do
          {
            int v435 = *(unsigned __int8 *)v19 ^ 0xFF;
            if (v435)
            {
              unsigned int v436 = v18;
              if (v435 != 255) {
                unsigned int v436 = PDM_21362(v18, v435);
              }
            }
            else
            {
              unsigned int v436 = 0;
            }
            *v19++ = v436;
            --v434;
          }
          while (v434);
          v19 += v425;
          --v552[0];
        }
        while (v552[0]);
        goto LABEL_1120;
      case 5:
        int v449 = v552[0];
        do
        {
          int v450 = v13;
          unsigned int v451 = v19;
          do
          {
            unsigned int v452 = *v451++;
            DMplusDM_21363(v19, v18, v452, v452, ~(_BYTE)v18);
            int v19 = v451;
            --v450;
          }
          while (v450);
          int v19 = &v451[v425];
          v552[0] = --v449;
          LODWORD(v13) = v426;
        }
        while (v449);
        goto LABEL_1120;
      case 6:
        do
        {
          int v453 = v562[0];
          do
          {
            if (*v19 != 0xFF)
            {
              if (~*(unsigned char *)v19 == 255) {
                *int v19 = v18;
              }
              else {
                DplusDM_21364(v19, *v19, v18, ~*(unsigned char *)v19);
              }
            }
            ++v19;
            --v453;
          }
          while (v453);
          v19 += v425;
          --v552[0];
        }
        while (v552[0]);
        goto LABEL_1120;
      case 7:
        do
        {
          int v437 = v562[0];
          do
          {
            *int v19 = PDM_21362(*v19, v18);
            ++v19;
            --v437;
          }
          while (v437);
          v19 += v425;
          --v552[0];
        }
        while (v552[0]);
        goto LABEL_1120;
      case 8:
        do
        {
          int v438 = v562[0];
          do
          {
            *int v19 = PDM_21362(*v19, ~(_BYTE)v18);
            ++v19;
            --v438;
          }
          while (v438);
          v19 += v425;
          --v552[0];
        }
        while (v552[0]);
        goto LABEL_1120;
      case 9:
        int v454 = v552[0];
        do
        {
          int v455 = v13;
          int v456 = v19;
          do
          {
            unsigned int v457 = *v456++;
            DMplusDM_21363(v19, v18, ~(_BYTE)v457, v457, v18);
            int v19 = v456;
            --v455;
          }
          while (v455);
          int v19 = &v456[v425];
          v552[0] = --v454;
          LODWORD(v13) = v426;
        }
        while (v454);
        goto LABEL_1120;
      case 10:
        int v458 = v552[0];
        do
        {
          int v459 = v13;
          int v460 = v19;
          do
          {
            unsigned int v461 = *v460++;
            DMplusDM_21363(v19, v18, ~(_BYTE)v461, v461, ~(_BYTE)v18);
            int v19 = v460;
            --v459;
          }
          while (v459);
          int v19 = &v460[v425];
          v552[0] = --v458;
          LODWORD(v13) = v426;
        }
        while (v458);
        goto LABEL_1120;
      case 11:
        int v462 = v552[0];
        do
        {
          int v463 = v13;
          int v464 = (int *)v19;
          do
          {
            int v466 = *v464++;
            int v465 = v466;
            if (v10) {
              unsigned __int8 v467 = v465;
            }
            else {
              unsigned __int8 v467 = -1;
            }
            *(int32x2_t *)v4.i8 = DAplusdDA_21365(v19, v465, v467, v18, v18, v4);
            int v19 = (unsigned int *)v464;
            --v463;
          }
          while (v463);
          int v19 = (unsigned int *)&v464[v425];
          v552[0] = --v462;
          LODWORD(v13) = v426;
        }
        while (v462);
        goto LABEL_1120;
      case 12:
        do
        {
          int v469 = v562[0];
          do
          {
            int v468 = (v18 >> 8) & 0xFF00FF;
            *int v19 = ((((*v19 >> 8) & 0xFF00FF) + v468) << 8) & 0xFF00FF00 | ((*v19 & 0xFF00FF) + (v18 & 0xFF00FF)) & 0xFF00FF | (15 * ((((*v19 >> 8) & 0xFF00FF) + v468) & 0x1000100 | (((*v19 & 0xFF00FF) + (v18 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * ((((*v19 >> 8) & 0xFF00FF) + v468) & 0x1000100 | (((*v19 & 0xFF00FF) + (v18 & 0xFF00FF)) >> 8) & 0x10001));
            ++v19;
            --v469;
          }
          while (v469);
          v19 += v425;
          --v552[0];
        }
        while (v552[0]);
        goto LABEL_1120;
      case 13:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v470 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v471) = -1;
LABEL_937:
              unsigned int v472 = PDAmultiplyPDA_21366(*v19, v471, v18, v18);
              goto LABEL_938;
            }
            unsigned int v471 = *v19;
            unsigned int v472 = v18;
            if (*v19) {
              goto LABEL_937;
            }
LABEL_938:
            *v19++ = v472;
            --v470;
          }
          while (v470);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 14:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v473 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v474) = -1;
LABEL_947:
              unsigned int v475 = PDAscreenPDA_21367(*v19, v474, v18, v18);
              goto LABEL_948;
            }
            unsigned int v474 = *v19;
            unsigned int v475 = v18;
            if (*v19) {
              goto LABEL_947;
            }
LABEL_948:
            *v19++ = v475;
            --v473;
          }
          while (v473);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 15:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v476 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v477) = -1;
LABEL_957:
              unsigned int v478 = PDAoverlayPDA_21368(*v19, v477, v18, v18);
              goto LABEL_958;
            }
            unsigned int v477 = *v19;
            unsigned int v478 = v18;
            if (*v19) {
              goto LABEL_957;
            }
LABEL_958:
            *v19++ = v478;
            --v476;
          }
          while (v476);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 16:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v479 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v480) = -1;
LABEL_967:
              unsigned int v481 = PDAdarkenPDA_21370(*v19, v480, v18, v18);
              goto LABEL_968;
            }
            unsigned int v480 = *v19;
            unsigned int v481 = v18;
            if (*v19) {
              goto LABEL_967;
            }
LABEL_968:
            *v19++ = v481;
            --v479;
          }
          while (v479);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 17:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v482 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v483) = -1;
LABEL_977:
              unsigned int v484 = PDAlightenPDA_21369(*v19, v483, v18, v18);
              goto LABEL_978;
            }
            unsigned int v483 = *v19;
            unsigned int v484 = v18;
            if (*v19) {
              goto LABEL_977;
            }
LABEL_978:
            *v19++ = v484;
            --v482;
          }
          while (v482);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 18:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v485 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v486) = -1;
LABEL_987:
              unsigned int v487 = PDAcolordodgePDA_21371(*v19, v486, v18, v18);
              goto LABEL_988;
            }
            unsigned int v486 = *v19;
            unsigned int v487 = v18;
            if (*v19) {
              goto LABEL_987;
            }
LABEL_988:
            *v19++ = v487;
            --v485;
          }
          while (v485);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 19:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v488 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v489) = -1;
LABEL_997:
              unsigned int v490 = PDAcolorburnPDA_21372(*v19, v489, v18, v18);
              goto LABEL_998;
            }
            unsigned int v489 = *v19;
            unsigned int v490 = v18;
            if (*v19) {
              goto LABEL_997;
            }
LABEL_998:
            *v19++ = v490;
            --v488;
          }
          while (v488);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 20:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v491 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v492) = -1;
LABEL_1007:
              unsigned int v493 = PDAsoftlightPDA_21374(*v19, v492, v18, v18);
              goto LABEL_1008;
            }
            unsigned int v492 = *v19;
            unsigned int v493 = v18;
            if (*v19) {
              goto LABEL_1007;
            }
LABEL_1008:
            *v19++ = v493;
            --v491;
          }
          while (v491);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 21:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v494 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v495) = -1;
LABEL_1017:
              unsigned int v496 = PDAhardlightPDA_21373(*v19, v495, v18, v18);
              goto LABEL_1018;
            }
            unsigned int v495 = *v19;
            unsigned int v496 = v18;
            if (*v19) {
              goto LABEL_1017;
            }
LABEL_1018:
            *v19++ = v496;
            --v494;
          }
          while (v494);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 22:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v497 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v498) = -1;
LABEL_1027:
              unsigned int v499 = PDAdifferencePDA_21375(*v19, v498, v18, v18);
              goto LABEL_1028;
            }
            unsigned int v498 = *v19;
            unsigned int v499 = v18;
            if (*v19) {
              goto LABEL_1027;
            }
LABEL_1028:
            *v19++ = v499;
            --v497;
          }
          while (v497);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 23:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v500 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v501) = -1;
LABEL_1037:
              unsigned int v502 = PDAexclusionPDA_21376(*v19, v501, v18, v18);
              goto LABEL_1038;
            }
            unsigned int v501 = *v19;
            unsigned int v502 = v18;
            if (*v19) {
              goto LABEL_1037;
            }
LABEL_1038:
            *v19++ = v502;
            --v500;
          }
          while (v500);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 24:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v503 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v504) = -1;
LABEL_1047:
              unsigned int v505 = PDAhuePDA_21377(*v19, v504, v18, v18);
              goto LABEL_1048;
            }
            unsigned int v504 = *v19;
            unsigned int v505 = v18;
            if (*v19) {
              goto LABEL_1047;
            }
LABEL_1048:
            *v19++ = v505;
            --v503;
          }
          while (v503);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 25:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v506 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v507) = -1;
LABEL_1057:
              unsigned int v508 = PDAsaturationPDA_21378(*v19, v507, v18, v18);
              goto LABEL_1058;
            }
            unsigned int v507 = *v19;
            unsigned int v508 = v18;
            if (*v19) {
              goto LABEL_1057;
            }
LABEL_1058:
            *v19++ = v508;
            --v506;
          }
          while (v506);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 26:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v509 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v510) = -1;
LABEL_1067:
              unsigned int v511 = PDAluminosityPDA_21379(v18, v18, *v19, v510);
              goto LABEL_1068;
            }
            unsigned int v510 = *v19;
            unsigned int v511 = v18;
            if (*v19) {
              goto LABEL_1067;
            }
LABEL_1068:
            *v19++ = v511;
            --v509;
          }
          while (v509);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 27:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v512 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v513) = -1;
LABEL_1077:
              unsigned int v514 = PDAluminosityPDA_21379(*v19, v513, v18, v18);
              goto LABEL_1078;
            }
            unsigned int v513 = *v19;
            unsigned int v514 = v18;
            if (*v19) {
              goto LABEL_1077;
            }
LABEL_1078:
            *v19++ = v514;
            --v512;
          }
          while (v512);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 28:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v515 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v516) = -1;
LABEL_1087:
              unsigned int v517 = PDAtranspose_huePDA_21380(*v19, v516, v18, v18);
              goto LABEL_1088;
            }
            unsigned int v516 = *v19;
            unsigned int v517 = v18;
            if (*v19) {
              goto LABEL_1087;
            }
LABEL_1088:
            *v19++ = v517;
            --v515;
          }
          while (v515);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 29:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        while (1)
        {
          int v518 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v519) = -1;
LABEL_1097:
              unsigned int v520 = PDAtranspose_saturationPDA_21381(*v19, v519, v18, v18);
              goto LABEL_1098;
            }
            unsigned int v519 = *v19;
            unsigned int v520 = v18;
            if (*v19) {
              goto LABEL_1097;
            }
LABEL_1098:
            *v19++ = v520;
            --v518;
          }
          while (v518);
          v19 += v425;
          if (!--v552[0]) {
            goto LABEL_1120;
          }
        }
      case 30:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        do
        {
          int v521 = v562[0];
          do
          {
            if (!v10)
            {
              LOBYTE(v522) = -1;
LABEL_1107:
              unsigned int v523 = PDAtranspose_luminosityPDA_21382(v18, v18, *v19, v522);
              goto LABEL_1108;
            }
            unsigned int v522 = *v19;
            unsigned int v523 = v18;
            if (*v19) {
              goto LABEL_1107;
            }
LABEL_1108:
            *v19++ = v523;
            --v521;
          }
          while (v521);
          v19 += v425;
          --v552[0];
        }
        while (v552[0]);
LABEL_1120:
        int v19 = v545;
        uint64_t v21 = v548;
        if (!v548) {
          return 1;
        }
        uint64_t v551 = 0;
LABEL_1122:
        if (shape_enum_clip_next(v21, (int *)&v551 + 1, &v551, v562, v552))
        {
          uint64_t v548 = v21;
          v19 += v549 * (int)v551 + SHIDWORD(v551);
          LODWORD(v13) = v562[0];
          continue;
        }
        unint64_t v44 = (void *)v21;
LABEL_1125:
        free(v44);
        return 1;
      case 31:
        if (!(_BYTE)v18) {
          goto LABEL_1120;
        }
        break;
      default:
        goto LABEL_1120;
    }
    break;
  }
LABEL_1112:
  int v524 = v562[0];
  while (1)
  {
    if (v10)
    {
      unsigned int v525 = *v19;
      unsigned int v526 = v18;
      if (!*v19) {
        goto LABEL_1118;
      }
    }
    else
    {
      LOBYTE(v525) = -1;
    }
    unsigned int v526 = PDAtranspose_luminosityPDA_21382(*v19, v525, v18, v18);
LABEL_1118:
    *v19++ = v526;
    if (!--v524)
    {
      v19 += v425;
      if (!--v552[0]) {
        goto LABEL_1120;
      }
      goto LABEL_1112;
    }
  }
}

BOOL ripl_IsContained(_DWORD *a1, _DWORD *a2)
{
  BOOL result = 0;
  if (*a1 > *a2)
  {
    int v2 = a1[1];
    int v3 = a2[1];
    if (v2 > v3 && a1[2] + *a1 < a2[2] + *a2 && a1[3] + v2 < a2[3] + v3) {
      return 1;
    }
  }
  return result;
}

_DWORD *W8_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  uint64_t v9 = *(float **)(*(void *)a1 + 64);
  float v10 = *v9;
  float v11 = v9[1];
  float v12 = v9[3];
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    float v13 = v11;
    if (v11 >= a6)
    {
      float v13 = a6;
      if (v10 > a6) {
        float v13 = v10;
      }
    }
    float v14 = v13 * v9[2];
    if (a5) {
      int v15 = a4;
    }
    else {
      int v15 = 0;
    }
    if (v15 == 4)
    {
      float v25 = a5[4];
      float v26 = *a5;
      float v27 = v11;
      if (v25 <= v11)
      {
        float v27 = a5[4];
        if (v25 < v10) {
          float v27 = v10;
        }
      }
      float v29 = a5[1];
      float v28 = a5[2];
      float v30 = v11;
      if (v26 <= v11)
      {
        float v30 = *a5;
        if (v26 < v10) {
          float v30 = v10;
        }
      }
      if (v29 < v10) {
        float v31 = v10;
      }
      else {
        float v31 = a5[1];
      }
      if (v29 > v11) {
        float v31 = v11;
      }
      if (v28 < v10) {
        float v32 = v10;
      }
      else {
        float v32 = a5[2];
      }
      BOOL v33 = v28 <= v11;
      float v34 = v11 - (float)(v9[4] * v30);
      if (v33) {
        float v35 = v32;
      }
      else {
        float v35 = v11;
      }
      float v36 = (float)((float)(v34 - (float)(v9[5] * v31)) - (float)(v9[6] * v35)) - v27;
      if (v36 >= v10) {
        float v24 = v12 + (float)(v36 * v14);
      }
      else {
        float v24 = v10;
      }
    }
    else
    {
      if (v15 == 3)
      {
        float v19 = a5[1];
        float v20 = v11;
        if (*a5 <= v11)
        {
          float v20 = *a5;
          if (*a5 < v10) {
            float v20 = v10;
          }
        }
        float v21 = a5[2];
        float v22 = v11;
        if (v19 <= v11)
        {
          float v22 = a5[1];
          if (v19 < v10) {
            float v22 = v10;
          }
        }
        if (v21 < v10) {
          float v23 = v10;
        }
        else {
          float v23 = a5[2];
        }
        if (v21 > v11) {
          float v23 = v11;
        }
        float v18 = (float)((float)(v22 * v9[5]) + (float)(v9[4] * v20)) + (float)(v9[6] * v23);
      }
      else
      {
        int v16 = 0;
        if (v15 != 1) {
          goto LABEL_53;
        }
        if (*a5 < v10) {
          float v17 = v10;
        }
        else {
          float v17 = *a5;
        }
        if (*a5 <= v11) {
          float v18 = v17;
        }
        else {
          float v18 = v11;
        }
      }
      float v24 = v12 + (float)(v18 * v14);
    }
    int v16 = (int)v24;
LABEL_53:
    int v37 = (int)(float)(v12 + v14);
    *(_OWORD *)a2 = xmmword_1850CDED0;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    a2[12] = v16 | (v16 << 8) | ((v16 | (v16 << 8)) << 16);
    *((void *)a2 + 4) = a2 + 12;
    if (v37 > 254)
    {
      *((void *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = v37 | (v37 << 8) | ((v37 | (v37 << 8)) << 16);
      *((void *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

uint64_t W8_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  memset(v47, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v30, (uint64_t)v47) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = 34083076;
  unsigned int v19 = *(_DWORD *)a3;
  *((void *)&v30 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 34083076)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_21:
        int v21 = 255;
        char v22 = 1;
      }
      else
      {
        char v22 = 0;
        int v21 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_21;
            }
            char v22 = 0;
            int v21 = 16;
            break;
          case 5u:
            char v22 = 0;
            int v21 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v22 = 0;
            int v21 = 32;
            break;
          case 8u:
            char v22 = 0;
            int v21 = 8;
            break;
          case 9u:
            char v22 = 0;
            int v21 = 40;
            break;
          default:
            goto LABEL_21;
        }
      }
      *(void *)&long long v30 = *(void *)&W8_image_sample[2 * v20 + 2];
      if ((void)v30)
      {
LABEL_28:
        DWORD2(v30) = v18;
        if (v22) {
          goto LABEL_36;
        }
        goto LABEL_29;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 0x10)
      {
        *(void *)&long long v30 = *(void *)&W16_image_sample[2 * v20 + 2];
        if ((void)v30)
        {
          int v18 = 68161828;
          goto LABEL_28;
        }
      }
      *(void *)&long long v30 = *(void *)&WF_image_sample[2 * v20 + 2];
      if ((void)v30)
      {
        LODWORD(v31) = 8;
        int v18 = 136319269;
        goto LABEL_28;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(void)v41 && (~DWORD1(v31) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((BYTE4(v31) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      W8_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(void *)&long long v30 = W8_sample_W8;
  if (*((void *)a2 + 12)) {
    goto LABEL_36;
  }
  unsigned int v20 = 2;
  int v21 = 16;
LABEL_29:
  if ((v8 - 1) <= 1 && (BYTE4(v31) & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
  {
    HIDWORD(v23) = v21;
    LODWORD(v23) = v21;
    switch((v23 >> 3))
    {
      case 0u:
        DWORD2(v30) = *(_DWORD *)a3;
        float v24 = W8_image_mark_RGB32;
        goto LABEL_51;
      case 1u:
        DWORD2(v30) = *(_DWORD *)a3;
        float v25 = W8_image_mark_RGB32;
        goto LABEL_53;
      case 2u:
        DWORD2(v30) = *(_DWORD *)a3;
        float v24 = W8_image_mark_W8;
        goto LABEL_51;
      case 3u:
        DWORD2(v30) = *(_DWORD *)a3;
        float v24 = W8_image_mark_RGB24;
        goto LABEL_51;
      case 4u:
        DWORD2(v30) = *(_DWORD *)a3;
        float v24 = W8_image_mark_rgb32;
LABEL_51:
        float v26 = v24;
        uint64_t v27 = (uint64_t)a2;
        int v28 = v8;
        int v29 = 0;
        break;
      case 5u:
        DWORD2(v30) = *(_DWORD *)a3;
        float v25 = W8_image_mark_rgb32;
LABEL_53:
        float v26 = v25;
        uint64_t v27 = (uint64_t)a2;
        int v28 = v8;
        int v29 = 8;
        break;
      default:
        goto LABEL_36;
    }
    W8_image_mark_image(v27, (uint64_t)&v30, v28, v29, (void (*)(void, void))v26);
    return 1;
  }
LABEL_36:
  W8_image_mark((uint64_t)a2, (uint64_t)&v30, v8, v17);
  return 1;
}

_DWORD *RGBAf16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  uint64_t v9 = *(float **)(*(void *)a1 + 64);
  _S10 = *v9;
  float v10 = v9[1];
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    if (_S10 <= a6) {
      _S0 = a6;
    }
    else {
      _S0 = _S10;
    }
    if (v10 < a6) {
      _S0 = v10;
    }
    if (a5) {
      int v13 = a4;
    }
    else {
      int v13 = 0;
    }
    if (v13 == 1)
    {
      _S10 = _S0 * *a5;
      _S1 = _S10;
      _S2 = _S10;
    }
    else
    {
      if (v13 == 4)
      {
        float v17 = a5[4];
        _S10 = _S0 * (float)((float)(v10 - *a5) - v17);
        _S1 = _S0 * (float)((float)(v10 - a5[1]) - v17);
        float v16 = (float)(v10 - a5[2]) - v17;
        goto LABEL_18;
      }
      _S1 = _S10;
      _S2 = _S10;
      if (v13 == 3)
      {
        _S10 = _S0 * *a5;
        _S1 = _S0 * a5[1];
        float v16 = a5[2];
LABEL_18:
        _S2 = _S0 * v16;
      }
    }
    *(_OWORD *)a2 = xmmword_1850CDE10;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    __asm { FCVT            H3, S10 }
    *((_WORD *)a2 + 24) = _H3;
    if (_S0 >= v10) {
      unint64_t v23 = 0;
    }
    else {
      unint64_t v23 = (char *)(a2 + 12);
    }
    *((void *)a2 + 4) = a2 + 12;
    *((void *)a2 + 5) = v23;
    __asm { FCVT            H1, S1 }
    *((_WORD *)a2 + 25) = _H1;
    __asm { FCVT            H1, S2 }
    *((_WORD *)a2 + 26) = _H1;
    __asm { FCVT            H0, S0 }
    *((_WORD *)a2 + 27) = _H0;
  }
  return a2;
}

uint64_t CGSCombineMaskToMask(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8)
{
  if (a8 < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  int v10 = 0;
  uint64_t v11 = a5 - 1;
  uint64_t v12 = a3 - 1;
  uint64_t v13 = a1 - 1;
  do
  {
    if (a7 >= 1)
    {
      unsigned int v14 = a7 + 1;
      do
      {
        int v16 = *(unsigned __int8 *)++v12;
        int v15 = v16;
        int v17 = *(unsigned __int8 *)++v13;
        v10 |= v15;
        unsigned int v18 = v17 * v15 + ((v17 * v15) >> 8) + 1;
        uint64_t result = v17 ^ (v18 >> 8) | result;
        *(unsigned char *)++uint64_t v11 = BYTE1(v18);
        --v14;
      }
      while (v14 > 1);
    }
    v13 += a2 - (uint64_t)a7;
    v12 += a4 - (uint64_t)a7;
    v11 += a6 - (uint64_t)a7;
  }
  while (a8-- > 1);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

_OWORD *colorsync_transform_data_key_retain(_OWORD *a1, void *a2)
{
  uint64_t result = malloc_type_malloc(0x20uLL, 0x1000040E0EAB150uLL);
  if (result)
  {
    long long v5 = a1[1];
    *uint64_t result = *a1;
    result[1] = v5;
  }
  *a2 = result;
  return result;
}

void CGContextDrawLinearGradient(CGContextRef c, CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (gradient)
      {
        uint64_t v12 = *((void *)c + 5);
        if (v12)
        {
          double y = endPoint.y;
          double x = endPoint.x;
          double v16 = startPoint.y;
          double v17 = startPoint.x;
          unsigned int v18 = *(unsigned int (**)(__n128, __n128, __n128, __n128))(v12 + 104);
          if (!v18
            || v18((__n128)startPoint, *(__n128 *)&startPoint.y, (__n128)endPoint, *(__n128 *)&endPoint.y) == 1006)
          {
            unsigned int v19 = (void *)*((void *)gradient + 3);
            CGFunctionRef Function = CGGradientGetFunction((uint64_t)gradient, (uint64_t)gradient, *(uint64_t *)&options, v5, v6, v7, v8, v9);
            char v22 = Function ? (double *)*((void *)Function + 5) : 0;
            AxialInternal = (CGShading *)CGShadingCreateAxialInternal(v19, 0, 0, v22, Function, options & 1, (options >> 1) & 1, v21, v17, v16, x, y);
            CGContextDrawShading(c, AxialInternal);
            if (AxialInternal)
            {
              CFRelease(AxialInternal);
            }
          }
        }
      }
      return;
    }
    CGContextRef v23 = c;
  }
  else
  {
    CGContextRef v23 = 0;
  }

  handle_invalid_context((char)"CGContextDrawLinearGradient", (uint64_t)v23, *(uint64_t *)&options, v5, v6, v7, v8, v9);
}

uint64_t ripc_DrawShading(double *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  uint64_t v428 = *MEMORY[0x1E4F143B8];
  if (a1) {
    double v9 = a1[36];
  }
  else {
    double v9 = 0.0;
  }
  long long v409 = 0u;
  long long v410 = 0u;
  long long v408 = 0u;
  long long v403 = 0u;
  long long v404 = 0u;
  long long v405 = 0u;
  long long v406 = 0u;
  uint64_t v407 = 0;
  uint64_t v402 = 0;
  float64x2_t v399 = 0u;
  float64x2_t v400 = 0u;
  long long v401 = 0u;
  memset(&v398, 0, sizeof(v398));
  unint64_t v396 = 0;
  uint64_t v397 = 0;
  uint64_t v424 = 0;
  long long v422 = 0u;
  long long v423 = 0u;
  int64x2_t v420 = 0u;
  long long v421 = 0u;
  long long v418 = 0u;
  long long v419 = 0u;
  long long v416 = 0u;
  long long v417 = 0u;
  memset(v415, 0, sizeof(v415));
  uint64_t result = ripc_GetRenderingState(*(uint64_t *)&v9, a2, a3, (uint64_t)&v408);
  if (!result) {
    return result;
  }
  unsigned int v19 = (long long *)(v6 + 24);
  _Q16 = *(float64x2_t *)(v6 + 24);
  float64x2_t v21 = *(float64x2_t *)(v6 + 40);
  double v23 = *(double *)(v6 + 56);
  double v22 = *(double *)(v6 + 64);
  double v24 = *(double *)(*(void *)&v9 + 40);
  if (v24 != 1.0)
  {
    _Q16 = vmulq_n_f64(_Q16, v24);
    float64x2_t v21 = vmulq_n_f64(v21, v24);
    double v23 = v23 * v24;
    double v22 = v22 * v24;
  }
  if (*(unsigned char *)(a4 + 40))
  {
    float v25 = (const CGRect *)(a4 + 48);
    p_CGFloat y = (CGFloat *)(a4 + 56);
    p_size = (CGSize *)(a4 + 64);
    p_double height = (CGFloat *)(a4 + 72);
  }
  else
  {
    float v25 = &CGRectInfinite;
    p_double height = &CGRectInfinite.size.height;
    p_CGFloat y = &CGRectInfinite.origin.y;
    p_size = &CGRectInfinite.size;
  }
  v29.n64_f64[0] = (double)SDWORD2(v409);
  double v30 = (double)SHIDWORD(v409);
  double v31 = (double)(int)v410;
  double v32 = (double)SDWORD1(v410);
  double v33 = *p_height;
  CGFloat x = v25->origin.x;
  double v35 = *p_y;
  double width = p_size->width;
  if (v25->origin.x == -8.98846567e307 && v35 == -8.98846567e307 && width == 1.79769313e308 && v33 == 1.79769313e308)
  {
    long long v37 = 0;
    uint64_t v407 = 0;
    CGFloat y = -8.98846567e307;
    double height = 1.79769313e308;
    uint64_t v40 = 0x7FEFFFFFFFFFFFFFLL;
    *(double *)&unint64_t v41 = -8.98846567e307;
  }
  else
  {
    float64x2_t v392 = v21;
    float64x2_t v393 = _Q16;
    *(float64x2_t *)&v425.a = _Q16;
    *(float64x2_t *)&v425.c = v21;
    CGFloat v389 = v23;
    CGFloat v390 = v22;
    v425.tCGFloat x = v23;
    v425.tCGFloat y = v22;
    CGFloat v387 = (double)SDWORD2(v409);
    double v388 = (double)(int)v410;
    double v394 = (double)SHIDWORD(v409);
    v395.f64[0] = (double)SDWORD1(v410);
    v52.n64_u64[0] = CGRectApplyInverseAffineTransform(&v425.a, v29, (double)SHIDWORD(v409), v31, (double)SDWORD1(v410)).n64_u64[0];
    CGFloat v54 = v53;
    CGFloat v56 = v55;
    CGFloat v58 = v57;
    v429.origin.CGFloat x = x;
    v429.origin.CGFloat y = v35;
    v429.size.double width = width;
    v429.size.double height = v33;
    v463.origin.CGFloat x = v52.n64_f64[0];
    v463.origin.CGFloat y = v54;
    v463.size.double width = v56;
    v463.size.double height = v58;
    CGRect v430 = CGRectIntersection(v429, v463);
    CGFloat v59 = v430.origin.x;
    uint64_t result = 0;
    if (v430.origin.x == INFINITY) {
      return result;
    }
    CGFloat y = v430.origin.y;
    if (v430.origin.y == INFINITY) {
      return result;
    }
    CGFloat v60 = v430.size.width;
    uint64_t result = 0;
    if (v430.size.width == 0.0) {
      return result;
    }
    double height = v430.size.height;
    if (v430.size.height == 0.0) {
      return result;
    }
    v431.origin.CGFloat x = v52.n64_f64[0];
    v431.origin.CGFloat y = v54;
    v431.size.double width = v56;
    v431.size.double height = v58;
    CGFloat v61 = v59;
    CGFloat v62 = y;
    double v63 = height;
    double v64 = v60;
    if (CGRectContainsRect(v431, *(CGRect *)&v59))
    {
      long long v37 = 0;
      uint64_t v407 = 0;
      double v30 = v394;
      double v32 = v395.f64[0];
      v29.n64_f64[0] = v387;
      double v31 = v388;
      float64x2_t v21 = v392;
      _Q16 = v393;
      double v23 = v389;
      double v22 = v390;
      uint64_t v40 = *(void *)&v64;
    }
    else
    {
      CGFloat v136 = v64;
      *(double *)v384.i64 = v64;
      CGFloat v137 = v61;
      if (v64 < 0.0 || (_D0 = v61, double v139 = y, v140 = v64, v141 = height, height < 0.0))
      {
        v432.origin.CGFloat x = v61;
        v432.origin.CGFloat y = y;
        v432.size.double width = v64;
        v432.size.double height = height;
        *(CGRect *)&_D0 = CGRectStandardize(v432);
        CGFloat v137 = v61;
        CGFloat v136 = *(double *)v384.i64;
      }
      uint64_t v385 = v6;
      _V6.D[1] = v393.f64[1];
      CGFloat v143 = v389 + vmlad_n_f64(v139 * v392.f64[0], _D0, v393.f64[0]);
      __asm { FMLA            D1, D0, V6.D[1] }
      float64x2_t v399 = vmlaq_n_f64(vmulq_f64(v392, (float64x2_t)0), v393, v140);
      float64x2_t v400 = vmlaq_f64(vmulq_n_f64(v392, v141), (float64x2_t)0, v393);
      *(CGFloat *)&long long v401 = v143;
      *((double *)&v401 + 1) = _D1 + v390;
      uint64_t v407 = &v399;
      *(float64x2_t *)&v425.a = v393;
      *(float64x2_t *)&v425.c = v392;
      v425.tCGFloat x = v389;
      v425.tCGFloat y = v390;
      v433.origin.CGFloat x = v137;
      v433.origin.CGFloat y = y;
      v433.size.double width = v136;
      v433.size.double height = height;
      *(CGRect *)((char *)&v14 - 24) = CGRectApplyAffineTransform(v433, &v425);
      v29.n64_u64[0] = *(unint64_t *)&v434.origin.x;
      double v30 = v434.origin.y;
      double v32 = v14.f64[0];
      if (v31 < 0.0 || v14.f64[0] < 0.0)
      {
        CGFloat v234 = v31;
        CGFloat v235 = v434.origin.x;
        unsigned int v145 = vcvtmd_s64_f64(COERCE_DOUBLE(CGRectStandardize(*(CGRect *)((char *)&v14 - 24))) + 0.00390625);
        v453.origin.CGFloat x = v235;
        v453.origin.CGFloat y = v30;
        v453.size.double width = v234;
        v453.size.double height = v32;
        CGRect v454 = CGRectStandardize(v453);
        unsigned int v146 = vcvtpd_s64_f64(v454.origin.x + v454.size.width + -0.00390625);
        v454.origin.CGFloat x = v235;
        v454.origin.CGFloat y = v30;
        v454.size.double width = v234;
        v454.size.double height = v32;
        CGRect v455 = CGRectStandardize(v454);
        LODWORD(v6) = vcvtmd_s64_f64(v455.origin.y + 0.00390625);
        v455.origin.CGFloat x = v235;
        v455.origin.CGFloat y = v30;
        v455.size.double width = v234;
        v455.size.double height = v32;
        *(CGRect *)((char *)&v14 - 24) = CGRectStandardize(v455);
        v29.n64_f64[0] = v235;
        double v31 = v234;
      }
      else
      {
        unsigned int v145 = vcvtmd_s64_f64(v434.origin.x + 0.00390625);
        unsigned int v146 = vcvtpd_s64_f64(v434.origin.x + v31 + -0.00390625);
        LODWORD(v6) = vcvtmd_s64_f64(v434.origin.y + 0.00390625);
      }
      unint64_t v396 = v145 | (unint64_t)(v6 << 32);
      LODWORD(v397) = v146 - v145;
      HIDWORD(v397) = vcvtpd_s64_f64(v434.origin.y + v14.f64[0] + -0.00390625) - v6;
      long long v37 = &v399;
      uint64_t v6 = v385;
      float64x2_t v21 = v392;
      _Q16 = v393;
      double v23 = v389;
      double v22 = v390;
      uint64_t v40 = v384.i64[0];
    }
    *(double *)&unint64_t v41 = v61;
  }
  int v42 = *(_DWORD *)(*(void *)(v6 + 120) + 4);
  switch(*(_DWORD *)(a4 + 20))
  {
    case 0:
      CGFloat v43 = v31;
      CGFloat v44 = v29.n64_f64[0];
      CopCGFloat y = CGGStateCreateCopy(v6);
      *(CGAffineTransform *)(Copy + 24) = CGAffineTransformIdentity;
      CGGStateClipToRect((uint64_t)Copy, v44, v30, v43, v32);
      long long v46 = *v19;
      long long v47 = v19[1];
      *(_OWORD *)(Copy + 56) = v19[2];
      *(_OWORD *)(Copy + 40) = v47;
      *(_OWORD *)(Copy + 24) = v46;
      CGShadingDrawInContextDelegate(a4, a1, v7, (uint64_t)Copy, v48, v49, v50, v51);
      CGGStateRelease((uint64_t)Copy);
      return 0;
    case 1:
      double v394 = v30;
      v395.f64[0] = v32;
      double v66 = *(double *)(a4 + 120);
      double v65 = *(double *)(a4 + 128);
      double v67 = *(double *)(a4 + 144) - v66;
      double v68 = *(double *)(a4 + 152) - v65;
      double v69 = *(double *)(a4 + 168);
      double v70 = *(double *)(a4 + 176);
      float v71 = v69;
      float v72 = v70;
      float v411 = v71;
      float v412 = v72;
      unint64_t v413 = 0x3F80000000000000;
      double v73 = v70 - v69;
      if (v67 == 0.0 && v68 == 0.0)
      {
        double v74 = 1.0;
        double v75 = 0.0;
        double v76 = 1.0;
      }
      else
      {
        double v76 = sqrt(v68 * v68 + v67 * v67);
        double v74 = v67 / v76;
        double v75 = v68 / v76;
      }
      double v147 = v76 / v73;
      *(double *)&long long v16 = v74 * v147;
      *(double *)&long long v17 = v75 * v147;
      *(double *)&long long v18 = -(v75 * v147);
      double v148 = -(v69 * v147);
      _D10 = v66 + v148 * v74;
      double v150 = v65 + v148 * v75;
      double v151 = v23 + vmlad_n_f64(v150 * v21.f64[0], _D10, _Q16.f64[0]);
      __asm { FMLA            D0, D10, V16.D[1] }
      double v153 = _D0 + v22;
      float64x2_t v14 = vmlaq_n_f64(vmulq_n_f64(v21, *(double *)&v17), _Q16, *(double *)&v16);
      *(float64x2_t *)&v398.a = v14;
      *(float64x2_t *)&v398.c = vmlaq_n_f64(vmulq_n_f64(v21, *(double *)&v16), _Q16, *(double *)&v18);
      v398.tCGFloat x = v151;
      v398.tCGFloat y = _D0 + v22;
      int v391 = *(double **)(a4 + 32);
      if (v391 || *(unsigned char *)(a4 + 136) || *(unsigned char *)(a4 + 160))
      {
        double v155 = v394;
        double v154 = v395.f64[0];
      }
      else
      {
        long long v378 = v18;
        long long v379 = v17;
        long long v381 = v16;
        float64x2_t v383 = v14;
        CGFloat v382 = v70 - v69;
        CGFloat v380 = *(double *)&v41;
        v384.i64[0] = v40;
        CGFloat v389 = v23;
        CGFloat v390 = v22;
        float64x2_t v392 = v21;
        float64x2_t v393 = _Q16;
        CGAffineTransform v425 = v398;
        CGFloat v387 = v29.n64_f64[0];
        double v388 = v31;
        v346.n64_u64[0] = CGRectApplyInverseAffineTransform(&v425.a, v29, v394, v31, v395.f64[0]).n64_u64[0];
        uint64_t result = 0;
        if (v346.n64_f64[0] > v70 || v346.n64_f64[0] + v348.n64_f64[0] < v69) {
          return result;
        }
        v466.origin.CGFloat x = v69;
        v466.origin.CGFloat y = v347.n64_f64[0];
        v466.size.double width = v382;
        v466.size.double height = v349.n64_f64[0];
        CGRect v456 = CGRectIntersection(*(CGRect *)v346.n64_u64, v466);
        if (v37)
        {
          *(void *)&v425.a = v381;
          *(void *)&v425.b = v379;
          *(void *)&v425.c = v378;
          *(void *)&v425.d = v381;
          v425.tCGFloat x = _D10;
          v425.tCGFloat y = v150;
          CGRect v467 = CGRectApplyAffineTransform(v456, &v425);
          v457.origin.CGFloat x = v380;
          v457.origin.CGFloat y = y;
          *(void *)&v457.size.double width = v384.i64[0];
          v457.size.double height = height;
          CGRect v456 = CGRectIntersection(v457, v467);
          *(float64x2_t *)&v425.a = v393;
          *(float64x2_t *)&v425.c = v392;
          v425.tCGFloat x = v389;
          v425.tCGFloat y = v390;
        }
        else
        {
          CGAffineTransform v425 = v398;
        }
        CGRect v470 = CGRectApplyAffineTransform(v456, &v425);
        v461.origin.CGFloat x = v387;
        v461.size.double width = v388;
        v461.origin.CGFloat y = v394;
        v461.size.double height = v395.f64[0];
        *(CGRect *)(&v31 - 2) = CGRectIntersection(v461, v470);
        v29.n64_u64[0] = v364;
        double v155 = v365;
        double v154 = v366;
        double v73 = v382;
        float64x2_t v14 = v383;
      }
      uint64_t v133 = v6;
      if (v31 < 0.0 || v154 < 0.0)
      {
        unint64_t v176 = v29.n64_u64[0];
        double v177 = v155;
        float64x2_t v383 = v14;
        double v178 = v154;
        CGFloat v179 = v31;
        CGFloat v180 = v29.n64_f64[0];
        double v181 = v73;
        int v156 = vcvtmd_s64_f64(COERCE_DOUBLE(CGRectStandardize(*(CGRect *)(&v31 - 2))) + 0.00390625);
        v439.origin.CGFloat x = v180;
        v439.origin.CGFloat y = v155;
        v439.size.double width = v179;
        v439.size.double height = v154;
        CGRect v440 = CGRectStandardize(v439);
        unsigned int v157 = vcvtpd_s64_f64(v440.origin.x + v440.size.width + -0.00390625);
        v440.origin.CGFloat x = v180;
        v440.origin.CGFloat y = v155;
        v440.size.double width = v179;
        v440.size.double height = v154;
        CGRect v441 = CGRectStandardize(v440);
        LODWORD(v6) = vcvtmd_s64_f64(v441.origin.y + 0.00390625);
        v441.origin.CGFloat x = v180;
        v441.origin.CGFloat y = v155;
        v441.size.double width = v179;
        v441.size.double height = v154;
        CGRect v442 = CGRectStandardize(v441);
        double v73 = v181;
        double v155 = v442.origin.y;
        double v154 = v442.size.height;
        float64x2_t v14 = v383;
      }
      else
      {
        int v156 = vcvtmd_s64_f64(v29.n64_f64[0] + 0.00390625);
        unsigned int v157 = vcvtpd_s64_f64(v29.n64_f64[0] + v31 + -0.00390625);
        LODWORD(v6) = vcvtmd_s64_f64(v155 + 0.00390625);
      }
      int v182 = vcvtpd_s64_f64(v155 + v154 + -0.00390625);
      *(void *)&long long v403 = v156 | (unint64_t)(v6 << 32);
      DWORD2(v403) = v157 - v156;
      HIDWORD(v403) = v182 - v6;
      v398.tCGFloat x = v151 - (double)v156;
      v398.tCGFloat y = (double)v182 - v153;
      float64x2_t v183 = *(float64x2_t *)&v398.b;
      *(float64x2_t *)&v398.b = vnegq_f64(*(float64x2_t *)&v398.b);
      *(void *)&long long v406 = &v398;
      *((void *)&v404 + 1) = 0;
      *(void *)&long long v405 = 0;
      *(void *)&long long v404 = &v411;
      int v184 = *(unsigned __int8 *)(a4 + 136);
      DWORD2(v405) = v184;
      if (*(unsigned char *)(a4 + 160)) {
        DWORD2(v405) = v184 | 2;
      }
      int v174 = (void *)(a4 + 184);
LABEL_72:
      *(void *)&v14.f64[0] = vcvtpd_s64_f64(fabs(v73) * sqrt(vmlad_n_f64(vmulq_f64(v183, v183).f64[0], v14.f64[0], v14.f64[0]))) | 0x100000000;
      goto LABEL_81;
    case 2:
      double v394 = v30;
      v395.f64[0] = v32;
      _D14 = *(double *)(a4 + 120);
      double v77 = *(double *)(a4 + 128);
      double v79 = *(double *)(a4 + 152) - _D14;
      double v80 = *(double *)(a4 + 160) - v77;
      double v81 = *(double *)(a4 + 184);
      double v82 = *(double *)(a4 + 192);
      float v83 = v81;
      float v84 = v82;
      float v411 = v83;
      float v412 = v84;
      double v85 = *(double *)(a4 + 136);
      double v86 = *(double *)(a4 + 168);
      double v73 = v82 - v81;
      unint64_t v413 = 0x3F80000000000000;
      if (v79 == 0.0 && v80 == 0.0)
      {
        double v87 = 1.0;
        double v88 = 0.0;
        double v89 = 0.0;
        double v90 = vabdd_f64(v86, v85) / v73;
      }
      else
      {
        double v158 = sqrt(v80 * v80 + v79 * v79);
        double v87 = v79 / v158;
        double v89 = v80 / v158;
        double v90 = (v158 + vabdd_f64(v86, v85)) / v73;
        double v88 = v158 / v90;
      }
      double v159 = v85 / v90;
      double v160 = v86 / v90;
      *(double *)&long long v15 = v87 * v90;
      *(double *)&long long v17 = v89 * v90;
      *(double *)&long long v16 = -(v89 * v90);
      double v161 = v23 + vmlad_n_f64(v77 * v21.f64[0], _D14, _Q16.f64[0]);
      __asm { FMLA            D0, D14, V16.D[1] }
      double v163 = _D0 + v22;
      float64x2_t v14 = vmlaq_n_f64(vmulq_n_f64(v21, *(double *)&v17), _Q16, *(double *)&v15);
      *(float64x2_t *)&v398.a = v14;
      *(float64x2_t *)&v398.c = vmlaq_n_f64(vmulq_n_f64(v21, *(double *)&v15), _Q16, *(double *)&v16);
      v398.tCGFloat x = v161;
      v398.tCGFloat y = _D0 + v22;
      *(float *)&_D0 = v159;
      float v164 = v88;
      v414[0] = LODWORD(_D0);
      *(float *)&v414[1] = v164;
      *(float *)&_D0 = v160;
      v414[2] = LODWORD(_D0);
      int v391 = *(double **)(a4 + 32);
      if (v391 || *(unsigned char *)(a4 + 144) || *(unsigned char *)(a4 + 176))
      {
        double v166 = v394;
        double v165 = v395.f64[0];
      }
      else
      {
        long long v377 = v16;
        long long v378 = v17;
        long long v379 = v15;
        CGFloat v380 = *(double *)&v41;
        *(double *)&long long v381 = v161;
        float64x2_t v383 = v14;
        CGFloat v382 = v73;
        v384.i64[0] = v40;
        CGFloat v389 = v23;
        CGFloat v390 = v22;
        float64x2_t v392 = v21;
        float64x2_t v393 = _Q16;
        CGAffineTransform v425 = v398;
        CGFloat v387 = v29.n64_f64[0];
        double v388 = v31;
        v350.n64_u64[0] = CGRectApplyInverseAffineTransform(&v425.a, v29, v394, v31, v395.f64[0]).n64_u64[0];
        double v354 = -v159;
        if (v159 <= v88 + v160) {
          double v355 = v88 + v160;
        }
        else {
          double v355 = v159;
        }
        if (v88 - v160 < v354) {
          double v354 = v88 - v160;
        }
        if (v160 <= v159) {
          double v356 = v159;
        }
        else {
          double v356 = v160;
        }
        if (v350.n64_f64[0] > v355 || v350.n64_f64[0] + v352.n64_f64[0] < v354 || v351.n64_f64[0] > v356) {
          return 0;
        }
        double v359 = -v356;
        if (v351.n64_f64[0] + v353.n64_f64[0] < -v356) {
          return 0;
        }
        double v360 = v355 - v354;
        double v361 = v356 + v356;
        CGRect v458 = CGRectIntersection(*(CGRect *)v350.n64_u64, *(CGRect *)&v354);
        if (v37)
        {
          *(void *)&v425.a = v379;
          *(void *)&v425.b = v378;
          *(void *)&v425.c = v377;
          *(void *)&v425.d = v379;
          v425.tCGFloat x = _D14;
          v425.tCGFloat y = v77;
          CGRect v468 = CGRectApplyAffineTransform(v458, &v425);
          v459.origin.CGFloat x = v380;
          v459.origin.CGFloat y = y;
          *(void *)&v459.size.double width = v384.i64[0];
          v459.size.double height = height;
          CGRect v458 = CGRectIntersection(v459, v468);
          *(float64x2_t *)&v425.a = v393;
          *(float64x2_t *)&v425.c = v392;
          v425.tCGFloat x = v389;
          v425.tCGFloat y = v390;
        }
        else
        {
          CGAffineTransform v425 = v398;
        }
        CGRect v471 = CGRectApplyAffineTransform(v458, &v425);
        v462.origin.CGFloat x = v387;
        v462.size.double width = v388;
        v462.origin.CGFloat y = v394;
        v462.size.double height = v395.f64[0];
        *(CGRect *)(&v31 - 2) = CGRectIntersection(v462, v471);
        v29.n64_u64[0] = v367;
        double v166 = v368;
        double v165 = v369;
        double v73 = v382;
        float64x2_t v14 = v383;
        double v161 = *(double *)&v381;
      }
      uint64_t v133 = v6;
      if (v31 < 0.0 || v165 < 0.0)
      {
        unint64_t v185 = v29.n64_u64[0];
        double v186 = v166;
        float64x2_t v383 = v14;
        double v187 = v165;
        CGFloat v188 = v31;
        CGFloat v189 = v29.n64_f64[0];
        double v190 = v73;
        double v191 = v161;
        int v167 = vcvtmd_s64_f64(COERCE_DOUBLE(CGRectStandardize(*(CGRect *)(&v31 - 2))) + 0.00390625);
        v443.origin.CGFloat x = v189;
        v443.origin.CGFloat y = v166;
        v443.size.double width = v188;
        v443.size.double height = v165;
        CGRect v444 = CGRectStandardize(v443);
        unsigned int v168 = vcvtpd_s64_f64(v444.origin.x + v444.size.width + -0.00390625);
        v444.origin.CGFloat x = v189;
        v444.origin.CGFloat y = v166;
        v444.size.double width = v188;
        v444.size.double height = v165;
        CGRect v445 = CGRectStandardize(v444);
        LODWORD(v6) = vcvtmd_s64_f64(v445.origin.y + 0.00390625);
        v445.origin.CGFloat x = v189;
        v445.origin.CGFloat y = v166;
        v445.size.double width = v188;
        v445.size.double height = v165;
        CGRect v446 = CGRectStandardize(v445);
        double v161 = v191;
        double v73 = v190;
        double v166 = v446.origin.y;
        double v165 = v446.size.height;
        float64x2_t v14 = v383;
      }
      else
      {
        int v167 = vcvtmd_s64_f64(v29.n64_f64[0] + 0.00390625);
        unsigned int v168 = vcvtpd_s64_f64(v29.n64_f64[0] + v31 + -0.00390625);
        LODWORD(v6) = vcvtmd_s64_f64(v166 + 0.00390625);
      }
      int v192 = vcvtpd_s64_f64(v166 + v165 + -0.00390625);
      *(void *)&long long v403 = v167 | (unint64_t)(v6 << 32);
      DWORD2(v403) = v168 - v167;
      HIDWORD(v403) = v192 - v6;
      v398.tCGFloat x = v161 - (double)v167;
      v398.tCGFloat y = (double)v192 - v163;
      float64x2_t v183 = *(float64x2_t *)&v398.b;
      *(float64x2_t *)&v398.b = vnegq_f64(*(float64x2_t *)&v398.b);
      *(void *)&long long v406 = &v398;
      *(void *)&long long v404 = &v411;
      *((void *)&v404 + 1) = v414;
      *(void *)&long long v405 = 0;
      int v193 = *(unsigned __int8 *)(a4 + 144);
      DWORD2(v405) = v193;
      if (*(unsigned char *)(a4 + 176)) {
        DWORD2(v405) = v193 | 2;
      }
      int v174 = (void *)(a4 + 200);
      goto LABEL_72;
    case 3:
      double v91 = v29.n64_f64[0];
      double v92 = *(double *)(a4 + 136);
      float v93 = *(double *)(a4 + 144);
      float v94 = *(double *)(a4 + 152);
      float v411 = v93;
      float v412 = v94;
      unint64_t v413 = 0x3F80000000000000;
      float v95 = v94 - v93;
      float v96 = v92;
      *(float *)int v414 = v96;
      int v391 = *(double **)(a4 + 32);
      double v97 = v31;
      float64x2_t v392 = v21;
      float64x2_t v393 = _Q16;
      double v98 = v22;
      double v99 = v23;
      __float2 v100 = __sincosf_stret(v96);
      double v101 = (float)-v100.__sinval;
      float64x2_t v102 = *(float64x2_t *)(a4 + 120);
      double v103 = v99 + vmlad_n_f64(vmuld_lane_f64(v392.f64[0], v102, 1), v393.f64[0], v102.f64[0]);
      double v104 = vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(v392, v102).f64[1]), v393.f64[1], v102.f64[0]) + v98;
      float64x2_t v14 = vmlaq_n_f64(vmulq_n_f64(v392, v101), v393, (float)-v100.__cosval);
      *(float64x2_t *)&v398.a = v14;
      *(float64x2_t *)&v398.c = vmlaq_n_f64(vmulq_n_f64(v392, v100.__cosval), v393, v101);
      if (v97 < 0.0 || v32 < 0.0)
      {
        v435.origin.CGFloat x = v91;
        v435.origin.CGFloat y = v30;
        v435.size.double width = v97;
        v435.size.double height = v32;
        int v105 = vcvtmd_s64_f64(COERCE_DOUBLE(CGRectStandardize(v435)) + 0.00390625);
        v436.origin.CGFloat x = v91;
        v436.origin.CGFloat y = v30;
        v436.size.double width = v97;
        v436.size.double height = v32;
        CGRect v437 = CGRectStandardize(v436);
        int v106 = vcvtpd_s64_f64(v437.origin.x + v437.size.width + -0.00390625);
        v437.origin.CGFloat x = v91;
        v437.origin.CGFloat y = v30;
        v437.size.double width = v97;
        v437.size.double height = v32;
        CGRect v438 = CGRectStandardize(v437);
        LODWORD(v4) = vcvtmd_s64_f64(v438.origin.y + 0.00390625);
        v438.origin.CGFloat x = v91;
        v438.origin.CGFloat y = v30;
        v438.size.double width = v97;
        v438.size.double height = v32;
        *(CGRect *)((char *)&v14 - 24) = CGRectStandardize(v438);
        double v30 = v169;
        double v32 = v14.f64[0];
      }
      else
      {
        int v105 = vcvtmd_s64_f64(v91 + 0.00390625);
        int v106 = vcvtpd_s64_f64(v91 + v97 + -0.00390625);
        LODWORD(v4) = vcvtmd_s64_f64(v30 + 0.00390625);
      }
      int v170 = vcvtpd_s64_f64(v30 + v32 + -0.00390625);
      *(void *)&long long v403 = v105 | (unint64_t)(v4 << 32);
      DWORD2(v403) = v106 - v105;
      HIDWORD(v403) = v170 - v4;
      v398.tCGFloat x = v103 - (double)v105;
      v398.tCGFloat y = (double)v170 - v104;
      *(float64x2_t *)&v398.b = vnegq_f64(*(float64x2_t *)&v398.b);
      double v171 = ((double)(int)v4 - v398.ty) * ((double)(int)v4 - v398.ty);
      double v172 = ((double)v170 - v398.ty) * ((double)v170 - v398.ty);
      float v173 = fmax(fmax(v171 + ((double)v105 - v398.tx) * ((double)v105 - v398.tx), v171 + ((double)v106 - v398.tx) * ((double)v106 - v398.tx)), fmax(v172 + ((double)v105 - v398.tx) * ((double)v105 - v398.tx), v172 + ((double)v106 - v398.tx) * ((double)v106 - v398.tx)));
      *(void *)&long long v406 = &v398;
      *(void *)&long long v404 = &v411;
      *((void *)&v404 + 1) = 0;
      *(void *)&long long v405 = v414;
      DWORD2(v405) = 0;
      int v174 = (void *)(a4 + 160);
      int v175 = vcvtpd_s64_f64(fabsf(v95) * (float)(sqrtf(v173) * 3.1416));
      if (v175 <= 128) {
        int v175 = 128;
      }
      *(void *)&v14.f64[0] = v175 | 0x100000000;
      goto LABEL_82;
    case 4:
      double v394 = v30;
      v395.f64[0] = v32;
      double v108 = *(double *)(a4 + 120);
      double v107 = *(double *)(a4 + 128);
      float v109 = v108;
      double v111 = *(double *)(a4 + 136);
      double v110 = *(double *)(a4 + 144);
      *(float *)&unsigned int v112 = v111;
      float v113 = v107;
      float v411 = v109;
      float v412 = v113;
      *(float *)&unsigned int v114 = v110;
      unint64_t v413 = __PAIR64__(v114, v112);
      double v115 = v107 - v108;
      v14.f64[0] = v110 - v111;
      _D1 = *(double *)(a4 + 160);
      double v117 = *(double *)(a4 + 168);
      _D25 = *(double *)(a4 + 176);
      double v118 = *(double *)(a4 + 184);
      _D26 = *(double *)(a4 + 192);
      double v121 = *(double *)(a4 + 200);
      double v122 = vmlad_n_f64(v117 * v21.f64[0], _D1, _Q16.f64[0]);
      __asm { FMLA            D6, D1, V16.D[1] }
      double v126 = vmlad_n_f64(v118 * v21.f64[0], _D25, _Q16.f64[0]);
      __asm { FMLA            D22, D25, V16.D[1] }
      double v128 = v23 + vmlad_n_f64(v121 * v21.f64[0], _D26, _Q16.f64[0]);
      __asm { FMLA            D0, D26, V16.D[1] }
      double v130 = _D0 + v22;
      v398.a = v122;
      v398.b = _D6;
      v398.c = v126;
      v398.d = _D22;
      v398.tCGFloat x = v128;
      v398.tCGFloat y = _D0 + v22;
      int v391 = *(double **)(a4 + 32);
      if (v391)
      {
        double v132 = v394;
        double v131 = v395.f64[0];
      }
      else
      {
        double v376 = v126;
        *(double *)&long long v377 = v121;
        *(double *)&long long v378 = _D26;
        *(double *)&long long v379 = _D25;
        CGFloat v373 = _D1;
        double v374 = _D0 + v22;
        double v375 = v128;
        CGFloat v380 = *(double *)&v41;
        *(double *)&long long v381 = _D22;
        CGFloat v382 = v122;
        v383.f64[0] = _D6;
        v384.i64[0] = v40;
        CGFloat v389 = v23;
        CGFloat v390 = v22;
        float64x2_t v392 = v21;
        float64x2_t v393 = _Q16;
        CGAffineTransform v425 = v398;
        CGFloat v387 = v29.n64_f64[0];
        double v388 = v31;
        CGFloat v194 = v14.f64[0];
        v447.origin.CGFloat x = CGRectApplyInverseAffineTransform(&v425.a, v29, v394, v31, v395.f64[0]).n64_f64[0];
        v464.origin.CGFloat x = v108;
        v464.origin.CGFloat y = v111;
        v464.size.double width = v115;
        CGFloat v195 = v194;
        v464.size.double height = v194;
        CGRect v448 = CGRectIntersection(v447, v464);
        uint64_t result = 0;
        if (v448.origin.x == INFINITY) {
          return result;
        }
        if (v448.origin.y == INFINITY) {
          return result;
        }
        uint64_t result = 0;
        if (v448.size.width == 0.0 || v448.size.height == 0.0) {
          return result;
        }
        if (v37)
        {
          v425.a = v373;
          v425.b = v117;
          *(void *)&v425.c = v379;
          v425.d = v118;
          *(void *)&v425.tCGFloat x = v378;
          *(void *)&v425.tCGFloat y = v377;
          CGRect v465 = CGRectApplyAffineTransform(v448, &v425);
          v449.origin.CGFloat x = v380;
          v449.origin.CGFloat y = y;
          *(void *)&v449.size.double width = v384.i64[0];
          v449.size.double height = height;
          CGRect v448 = CGRectIntersection(v449, v465);
          *(float64x2_t *)&v425.a = v393;
          *(float64x2_t *)&v425.c = v392;
          v425.tCGFloat x = v389;
          v425.tCGFloat y = v390;
        }
        else
        {
          CGAffineTransform v425 = v398;
        }
        CGRect v469 = CGRectApplyAffineTransform(v448, &v425);
        v460.origin.CGFloat x = v387;
        v460.size.double width = v388;
        v460.origin.CGFloat y = v394;
        v460.size.double height = v395.f64[0];
        *(CGRect *)((char *)&v14 - 24) = CGRectIntersection(v460, v469);
        v29.n64_u64[0] = v362;
        double v132 = v363;
        double v131 = v14.f64[0];
        v14.f64[0] = v195;
        double v122 = v382;
        _D6 = v383.f64[0];
        _D22 = *(double *)&v381;
        double v128 = v375;
        double v126 = v376;
        double v130 = v374;
      }
      uint64_t v133 = v6;
      if (v31 < 0.0 || v131 < 0.0)
      {
        unint64_t v196 = v29.n64_u64[0];
        double v197 = v132;
        double v394 = v115;
        v395.f64[0] = v14.f64[0];
        double v198 = v131;
        CGFloat v199 = v31;
        CGFloat v200 = v29.n64_f64[0];
        CGFloat v382 = v122;
        v383.f64[0] = _D6;
        *(double *)&long long v381 = _D22;
        double v201 = v126;
        double v202 = v128;
        double v203 = v130;
        int v134 = vcvtmd_s64_f64(COERCE_DOUBLE(CGRectStandardize(*(CGRect *)(&v31 - 2))) + 0.00390625);
        v450.origin.CGFloat x = v200;
        v450.origin.CGFloat y = v132;
        v450.size.double width = v199;
        v450.size.double height = v131;
        CGRect v451 = CGRectStandardize(v450);
        unsigned int v135 = vcvtpd_s64_f64(v451.origin.x + v451.size.width + -0.00390625);
        v451.origin.CGFloat x = v200;
        v451.origin.CGFloat y = v132;
        v451.size.double width = v199;
        v451.size.double height = v131;
        CGRect v452 = CGRectStandardize(v451);
        LODWORD(v6) = vcvtmd_s64_f64(v452.origin.y + 0.00390625);
        v452.origin.CGFloat x = v200;
        v452.origin.CGFloat y = v132;
        v452.size.double width = v199;
        v452.size.double height = v131;
        *(CGRect *)((char *)&v14 - 24) = CGRectStandardize(v452);
        double v130 = v203;
        double v128 = v202;
        double v126 = v201;
        _D22 = *(double *)&v381;
        double v122 = v382;
        _D6 = v383.f64[0];
        double v132 = v204;
        double v131 = v14.f64[0];
        v14.f64[0] = v395.f64[0];
      }
      else
      {
        int v134 = vcvtmd_s64_f64(v29.n64_f64[0] + 0.00390625);
        unsigned int v135 = vcvtpd_s64_f64(v29.n64_f64[0] + v31 + -0.00390625);
        LODWORD(v6) = vcvtmd_s64_f64(v132 + 0.00390625);
      }
      int v205 = vcvtpd_s64_f64(v132 + v131 + -0.00390625);
      *(void *)&long long v403 = v134 | (unint64_t)(v6 << 32);
      DWORD2(v403) = v135 - v134;
      HIDWORD(v403) = v205 - v6;
      v398.tCGFloat x = v128 - (double)v134;
      v398.tCGFloat y = (double)v205 - v130;
      v398.b = -_D6;
      v398.d = -_D22;
      *(void *)&long long v406 = &v398;
      int v174 = (void *)(a4 + 152);
      *((void *)&v404 + 1) = 0;
      *(void *)&long long v405 = 0;
      *(void *)&long long v404 = &v411;
      DWORD2(v405) = 0;
      *(void *)&v14.f64[0] = __PAIR64__(vcvtpd_s64_f64(sqrt(v14.f64[0] * _D22 * (v14.f64[0] * _D22) + v14.f64[0]* v126* (v14.f64[0]* v126))), vcvtpd_s64_f64(sqrt(v115 * _D6 * (v115 * _D6) + v115 * v122 * (v115 * v122))));
LABEL_81:
      uint64_t v6 = v133;
LABEL_82:
      __int32 v206 = (void *)*v174;
      float64_t v207 = *(double *)(a4 + 24);
      *(void *)&long long v416 = 0;
      DWORD1(v417) = 0;
      uint64_t v208 = &qword_1EB28A000;
      if (RIPGetCacheState_predicate != -1)
      {
        float64x2_t v395 = v14;
        dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
        float64x2_t v14 = v395;
      }
      uint64_t v209 = (v42 << 12 >> 28);
      int v210 = &qword_1EB28A000;
      if (!*(unsigned char *)(RIPGetCacheState_cache_state + 32)) {
        goto LABEL_92;
      }
      uint32x2_t v211 = vmin_u32(*(uint32x2_t *)&v14.f64[0], (uint32x2_t)0x100000001000);
      *(void *)&long long v212 = v211.u32[0];
      *((void *)&v212 + 1) = v211.u32[1];
      long long v213 = v212;
      float64x2_t v395 = v14;
      if (v206) {
        uint64_t v214 = v206[12];
      }
      else {
        uint64_t v214 = 0;
      }
      *(void *)&v425.a = MEMORY[0x1E4F143A8];
      *(void *)&v425.b = 0x40000000;
      *(void *)&v425.c = __lookup_function_entry_block_invoke;
      *(void *)&v425.d = &__block_descriptor_tmp_7395;
      v425.tCGFloat x = v9;
      *(void *)&v425.tCGFloat y = &v411;
      long long v426 = v213;
      int v427 = v209;
      EntrCGFloat y = RIPDataGetEntry(*(uint64_t *)&v9, v214, 0, (uint64_t)&v425);
      if (Entry)
      {
        unsigned int v216 = Entry;
        *(void *)&CGFloat v217 = Entry + 8;
LABEL_146:
        *((CGFloat *)&v406 + 1) = v217;
        if (*(unsigned char *)(v7 + 81) && (*(unsigned char *)(*(void *)(v6 + 120) + 7) & 1) != 0)
        {
          *(_WORD *)(*(void *)&v9 + 108) = *(_WORD *)(*(void *)&v9 + 108) | 0xFF00;
          __int16 v286 = -256;
        }
        else
        {
          __int16 v286 = 0;
          *(_WORD *)(*(void *)&v9 + 108) = *(unsigned __int8 *)(*(void *)&v9 + 108);
        }
        __int16 v287 = v286 | *(unsigned __int8 *)(v7 + 82);
        *(_WORD *)(*(void *)&v9 + 108) = v287;
        *(_DWORD *)(*(void *)&v9 + 112) = v209;
        uint64_t v288 = *(void *)(v6 + 120);
        *(_DWORD *)(*(void *)&v9 + 104) = (int)(*(_DWORD *)(v288 + 4) << 16) >> 24;
        float v289 = *(double *)(v288 + 8);
        *(double *)(*(void *)&v9 + 152) = v289;
        if (!v391)
        {
          uint64_t v291 = 0;
LABEL_172:
          if ((_BYTE)v287 && (*(unsigned char *)(*(void *)(*(void *)&v9 + 48) + 29) & 2) != 0)
          {
            uint64_t v303 = *(void *)(v6 + 120);
            double v304 = *(double *)(v303 + 24);
            double v305 = *(double *)(v303 + 32);
            double v306 = *(double *)(*(void *)&v9 + 40);
            _ZF = v306 == 1.0;
            double v308 = *(double *)(v7 + 24) * v306;
            double v309 = *(double *)(v7 + 32) * v306;
            double v310 = *(double *)(v7 + 40) * v306;
            double v311 = *(double *)(v7 + 48) * v306;
            double v312 = *(double *)(v7 + 56) * v306;
            double v313 = *(double *)(v7 + 64) * v306;
            if (_ZF)
            {
              double v308 = *(double *)(v7 + 24);
              double v314 = *(double *)(v7 + 32);
            }
            else
            {
              double v314 = v309;
            }
            if (_ZF) {
              double v315 = *(double *)(v7 + 40);
            }
            else {
              double v315 = v310;
            }
            if (_ZF) {
              double v316 = *(double *)(v7 + 48);
            }
            else {
              double v316 = v311;
            }
            if (_ZF) {
              double v317 = *(double *)(v7 + 56);
            }
            else {
              double v317 = v312;
            }
            if (_ZF) {
              double v318 = *(double *)(v7 + 64);
            }
            else {
              double v318 = v313;
            }
            double v319 = v305 * v315 + v308 * v304 + v317;
            if (v319 <= 1073741820.0)
            {
              unsigned int v321 = vcvtmd_s64_f64(v319);
              if (v319 >= -1073741820.0) {
                int v320 = v321;
              }
              else {
                int v320 = -1073741823;
              }
            }
            else
            {
              int v320 = 0x3FFFFFFF;
            }
            LODWORD(v402) = v320;
            double v322 = v305 * v316 + v314 * v304 + v318;
            if (v322 <= 1073741820.0)
            {
              if (v322 >= -1073741820.0) {
                unsigned int v323 = vcvtmd_s64_f64(v322);
              }
              else {
                unsigned int v323 = -1073741823;
              }
            }
            else
            {
              unsigned int v323 = 0x3FFFFFFF;
            }
            HIDWORD(v402) = v323;
          }
          else
          {
            uint64_t v402 = 0;
          }
          if (*((void *)&v410 + 1) && (*(unsigned char *)(*((void *)&v410 + 1) + 12) & 0x80) != 0)
          {
            (*(void (**)(void))(**((void **)&v410 + 1) + 80))();
          }
          else
          {
            if (v407) {
              unsigned int v324 = &v396;
            }
            else {
              unsigned int v324 = 0;
            }
            RIPLayerBltShade(*(void *)(*(void *)&v9 + 48), v408, (uint64_t)v324, (uint64_t)&v403, (uint64_t)v291, *(void *)&v9 + 104, v12, v13);
          }
          free(v291);
          double v332 = v9;
          if (v208[43] != -1) {
            dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
          }
          if (!*(unsigned char *)(v210[42] + 32) || (uint64_t v333 = v216[5]) == 0)
          {
            free((void *)v216[16]);
            free((void *)v216[17]);
            return 0;
          }
          uint64_t v334 = (void *)v216[4];
          if (!v334)
          {
            int v335 = RIPDataCreate(v216[5], v325, v326, v327, v328, v329, v330, v331);
            uint64_t v334 = v335;
            uint64_t v336 = 0;
            atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v333 + 96), (unint64_t *)&v336, (unint64_t)v335, memory_order_relaxed, memory_order_relaxed);
            unsigned int v337 = *(void **)(v333 + 96);
            if (v337 != v335)
            {
              CFRelease(v335);
              uint64_t v334 = v337;
            }
          }
          if (*((_DWORD *)v216 + 13))
          {
            RIPLockCacheState();
            --*((_DWORD *)v216 + 13);
LABEL_223:
            RIPUnlockCacheState();
            return 0;
          }
          __int32 v338 = RIPCacheEntryCreate(0, (uint64_t)v334);
          *((_OWORD *)v338 + 4) = *((_OWORD *)v216 + 4);
          long long v339 = *((_OWORD *)v216 + 8);
          long long v341 = *((_OWORD *)v216 + 5);
          long long v340 = *((_OWORD *)v216 + 6);
          *((_OWORD *)v338 + 7) = *((_OWORD *)v216 + 7);
          *((_OWORD *)v338 + 8) = v339;
          *((_OWORD *)v338 + 5) = v341;
          *((_OWORD *)v338 + 6) = v340;
          RIPLockCacheState();
          int v342 = (void *)v334[3];
          uint64_t v343 = *v338;
          v334[3] = v338;
          void *v338 = v334 + 2;
          *int v342 = v343;
          *(void *)(v343 + 8) = v342;
          ++v334[5];
          ripc_AddEntry(*(void *)(*(void *)&v332 + 208), (uint64_t)v338);
          if (v334[5] <= 0x20uLL) {
            goto LABEL_223;
          }
          uint64_t v344 = (uint64_t *)v334[2];
          RIPCacheEntryRemove(v344);
          v344[1] = 0;
          RIPUnlockCacheState();
          do
          {
            float v345 = (uint64_t *)v344[1];
            RIPCacheEntryRelease(v344);
            uint64_t result = 0;
            uint64_t v344 = v345;
          }
          while (v345);
          return result;
        }
        if (v207 == 0.0) {
          uint64_t v290 = 0;
        }
        else {
          uint64_t v290 = *(void *)(*(void *)(*(void *)&v207 + 24) + 48);
        }
        double v292 = v391[v290];
        Cache = CGColorTransformGetCache(*(void **)(*(void *)&v9 + 120));
        uint64_t v386 = v7;
        v392.f64[0] = v207;
        if (Cache)
        {
          uint64_t v295 = Cache[2];
          if (v295)
          {
            unint64_t v296 = *(void *)(*(void *)(v295 + 24) + 48);
            if (v296 >> 61)
            {
              uint64_t v297 = v209;
              MEMORY[0x1F4188790](Cache, v294);
              int v298 = (double *)&v372;
              unsigned int v299 = 0;
LABEL_166:
              if (CGColorTransformConvertColorComponents(*(void *)(*(void *)&v9 + 120), *(void **)&v392.f64[0], v297, v391, v299))
              {
                RIPColorCreateWithColor(*(_DWORD *)(*(void *)&v9 + 128), v299, v296, v292);
                uint64_t v291 = v302;
              }
              else
              {
                uint64_t v291 = 0;
              }
              if (v299 != v298) {
                free(v299);
              }
              __int16 v287 = *(_WORD *)(*(void *)&v9 + 108);
              uint64_t v7 = v386;
              uint64_t v208 = &qword_1EB28A000;
              int v210 = &qword_1EB28A000;
              goto LABEL_172;
            }
            Cache = (void *)(8 * v296);
          }
          else
          {
            unint64_t v296 = 0;
            Cache = 0;
          }
        }
        else
        {
          unint64_t v296 = 0;
        }
        uint64_t v297 = v209;
        size_t v300 = MEMORY[0x1F4188790](Cache, v294);
        int v298 = (CGFloat *)((char *)&v373 - ((v301 + 15) & 0xFFFFFFFFFFFFFFF0));
        if (v296 <= 0x1FFFFFFFFFFFFFFELL) {
          unsigned int v299 = (CGFloat *)((char *)&v373 - ((v301 + 15) & 0xFFFFFFFFFFFFFFF0));
        }
        else {
          unsigned int v299 = 0;
        }
        if (v296 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022) {
          unsigned int v299 = (double *)malloc_type_malloc(v300, 0x373664ABuLL);
        }
        goto LABEL_166;
      }
      v14.f64[0] = v395.f64[0];
      if (RIPGetCacheState_predicate != -1)
      {
        dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
        v14.f64[0] = v395.f64[0];
      }
LABEL_92:
      if (*(unsigned char *)(RIPGetCacheState_cache_state + 32))
      {
        if (v206) {
          uint64_t v218 = v206[12];
        }
        else {
          uint64_t v218 = 0;
        }
        *(void *)&long long v416 = v218;
      }
      uint64_t result = 1000;
      if (*(_DWORD *)(*(void *)&v9 + 128) <= 2u && v206)
      {
        uint64_t v219 = v206[4];
        *(void *)&v393.f64[0] = v206;
        if (v219 == 2)
        {
          v392.f64[0] = v207;
          CGFloat v389 = COERCE_DOUBLE(&v418);
          if (v207 != 0.0) {
            float64_t v207 = *(double *)(*(void *)(*(void *)&v207 + 24) + 48);
          }
          float v223 = v411;
          float v224 = *(float *)&v413;
          uint64_t v225 = v206[6];
          if (*(void *)&v207 != v225 && *(void *)&v207 + 1 != v225) {
            _CGHandleAssert("acquire_function_2d", 261, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPFunction.c", "(components == CGFunctionGetRangeDimension(function)) || (components + 1 == CGFunctionGetRangeDimension(function))", "", v11, v12, v13, SLOBYTE(v373));
          }
          CGFloat v387 = v9;
          int8x16_t v226 = vandq_s8((int8x16_t)vaddw_u32((uint64x2_t)vdupq_n_s64(3uLL), (uint32x2_t)vadd_s32(*(int32x2_t *)&v14.f64[0], (int32x2_t)0x200000002)), (int8x16_t)vdupq_n_s64(0x1FFFFFFFCuLL));
          int8x16_t v227 = (int8x16_t)vdupq_n_s64(0x1000uLL);
          int8x16_t v384 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v227, (uint64x2_t)v226), v226, v227);
          float v228 = v412 - v411;
          float v229 = *((float *)&v413 + 1) - *(float *)&v413;
          *(void *)&v395.f64[0] = v384.i64[1];
          double v230 = COERCE_DOUBLE(malloc_type_malloc(4 * *(void *)&v207 * v384.i64[1] * v384.i64[0], 0x100004052888210uLL));
          unint64_t v232 = v206[6];
          uint64_t v385 = v6;
          uint64_t v386 = v7;
          LODWORD(v390) = v209;
          double v388 = v230;
          *(void *)&v383.f64[0] = v384.i64[1] * v384.i64[0];
          if (v232 <= *(void *)&v207) {
            int v233 = 0;
          }
          else {
            int v233 = (float *)malloc_type_calloc(v384.i64[1] * v384.i64[0], 4uLL, 0x100004052888210uLL);
          }
          float v236 = v228 / (float)(unint64_t)(v384.i64[0] - 2);
          float v237 = v229 / (float)(unint64_t)(v384.i64[1] - 2);
          if (*(void *)&v395.f64[0])
          {
            unint64_t v238 = 0;
            float v239 = v223 - (float)(v236 * 0.5);
            float v240 = v224 - (float)(v237 * 0.5);
            uint64_t v241 = 4 * *(void *)&v207;
            *(void *)&double v394 = 4 * v384.i64[0];
            __int32 v242 = v233;
            v243 = *(float **)&v388;
            do
            {
              *((float *)&v425.a + 1) = v240 + (float)((float)v238 * v237);
              if (v384.i64[0])
              {
                unint64_t v244 = 0;
                uint64_t v245 = v242;
                do
                {
                  *(float *)&v425.a = v239 + (float)((float)v244 * v236);
                  if (v233) {
                    v246 = v245;
                  }
                  else {
                    v246 = 0;
                  }
                  v231.n128_f32[0] = v239 + (float)((float)v244 * v236);
                  function_evaluate(*(uint64_t *)&v393.f64[0], (float *)&v425, v243, v246, v231);
                  ++v244;
                  v243 = (float *)((char *)v243 + v241);
                  ++v245;
                }
                while (v384.i64[0] != v244);
              }
              ++v238;
              __int32 v242 = (float *)((char *)v242 + *(void *)&v394);
            }
            while (v238 != *(void *)&v395.f64[0]);
          }
          double v9 = v387;
          uint64_t v247 = *(unsigned int *)(*(void *)&v387 + 128);
          if (v247 < 3)
          {
            int v248 = malloc_type_calloc(qword_185210578[v247] * *(void *)&v383.f64[0], 4uLL, 0x100004052888210uLL);
            uint64_t v209 = LODWORD(v390);
            uint64_t v6 = v385;
            uint64_t v7 = v386;
            uint64_t v208 = &qword_1EB28A000;
            int v210 = &qword_1EB28A000;
            if ((CGColorTransformConvertComponentData(*(void **)(*(void *)&v387 + 120), *(void **)&v392.f64[0], 4, LODWORD(v390), *(uint64_t *)&v383.f64[0], 1, v249, *(uint64_t *)&v388, v370, 0, (uint64_t)v248, v371, 0) & 1) == 0)CGPostError((uint64_t)"%s - CGColorTransformConvertComponentData failed", v250, v251, v252, v253, {
                v254,
            }
                v255,
                v256,
                (char)"acquire_function_2d");
            free(*(void **)&v388);
            CGFloat v217 = v389;
            **(_OWORD **)&CGFloat v389 = *(_OWORD *)(*(void *)&v387 + 132);
            *(float *)&unsigned int v257 = v411 - v236;
            *(float *)&unsigned int v258 = v236 + v412;
            *(_DWORD *)(*(void *)&v217 + 16) = *(_DWORD *)(*(void *)&v9 + 148);
            *(void *)((char *)&v419 + 4) = __PAIR64__(v209, *(_DWORD *)(*(void *)&v9 + 128));
            *(void *)&long long v421 = __PAIR64__(v258, v257);
            *((float *)&v421 + 2) = *(float *)&v413 - v237;
            float v259 = v237 + *((float *)&v413 + 1);
            int64x2_t v260 = (int64x2_t)v384;
            goto LABEL_145;
          }
        }
        else
        {
          if (v219 != 1) {
            return result;
          }
          CGFloat v389 = COERCE_DOUBLE(&v418);
          LODWORD(v390) = v209;
          uint64_t v385 = v6;
          uint64_t v386 = v7;
          uint64_t v220 = (LODWORD(v14.f64[0]) + 2) + 15;
          if ((v220 & 0x1FFFFF000) != 0) {
            uint64_t v221 = 4096;
          }
          else {
            uint64_t v221 = v220 & 0x1FFFFFFF0;
          }
          if (v207 == 0.0) {
            unint64_t v222 = 0;
          }
          else {
            unint64_t v222 = *(void *)(*(void *)(*(void *)&v207 + 24) + 48);
          }
          float v261 = v411;
          uint64_t v262 = v206[6];
          if (v222 != v262 && v222 + 1 != v262) {
            _CGHandleAssert("acquire_function_1d", 170, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPFunction.c", "(components == CGFunctionGetRangeDimension(function)) || (components + 1 == CGFunctionGetRangeDimension(function))", "", v11, v12, v13, SLOBYTE(v373));
          }
          double v263 = v9;
          float v264 = v412 - v411;
          __int32 v265 = (float *)malloc_type_malloc(4 * v222 * v221, 0x100004052888210uLL);
          unint64_t v267 = v206[6];
          v392.f64[0] = v207;
          if (v267 <= v222) {
            int v233 = 0;
          }
          else {
            int v233 = (float *)malloc_type_calloc(v221, 4uLL, 0x100004052888210uLL);
          }
          float v268 = v264 / (float)(unint64_t)(v221 - 2);
          if (v221)
          {
            unint64_t v269 = 0;
            float v270 = v261 + (float)(v268 * -0.5);
            uint64_t v271 = 4 * v222;
            int v272 = v233;
            uint64_t v273 = v265;
            do
            {
              *(float *)&v425.a = v270 + (float)((float)v269 * v268);
              if (v233) {
                int v274 = v272;
              }
              else {
                int v274 = 0;
              }
              v266.n128_f32[0] = v270 + (float)((float)v269 * v268);
              function_evaluate(*(uint64_t *)&v393.f64[0], (float *)&v425, v273, v274, v266);
              ++v269;
              uint64_t v273 = (float *)((char *)v273 + v271);
              ++v272;
            }
            while (v221 != v269);
          }
          uint64_t v275 = *(unsigned int *)(*(void *)&v263 + 128);
          if (v275 < 3)
          {
            double v9 = v263;
            int v248 = malloc_type_calloc(qword_185210578[v275] * v221, 4uLL, 0x100004052888210uLL);
            uint64_t v6 = v385;
            uint64_t v208 = &qword_1EB28A000;
            if ((CGColorTransformConvertComponentData(*(void **)(*(void *)&v263 + 120), *(void **)&v392.f64[0], 4, LODWORD(v390), v221, 1, v276, (uint64_t)v265, v370, 0, (uint64_t)v248, v371, 0) & 1) == 0)CGPostError((uint64_t)"%s - CGColorTransformConvertComponentData failed", v277, v278, v279, v280, {
                v281,
            }
                v282,
                v283,
                (char)"acquire_function_1d");
            free(v265);
            CGFloat v217 = v389;
            **(_OWORD **)&CGFloat v389 = *(_OWORD *)(*(void *)&v263 + 132);
            *(float *)&unsigned int v284 = v411 - v268;
            *(float *)&unsigned int v285 = v268 + v412;
            *(_DWORD *)(*(void *)&v217 + 16) = *(_DWORD *)(*(void *)&v263 + 148);
            uint64_t v209 = LODWORD(v390);
            *(void *)((char *)&v419 + 4) = __PAIR64__(LODWORD(v390), *(_DWORD *)(*(void *)&v263 + 128));
            *(void *)&long long v421 = __PAIR64__(v285, v284);
            DWORD2(v421) = 0;
            int64x2_t v260 = vdupq_n_s64(1uLL);
            v260.i64[0] = v221;
            float v259 = 1.0;
            uint64_t v7 = v386;
            int v210 = &qword_1EB28A000;
LABEL_145:
            *((float *)&v421 + 3) = v259;
            int64x2_t v420 = v260;
            *(void *)&long long v422 = v248;
            *((void *)&v422 + 1) = v233;
            unsigned int v216 = (uint64_t *)v415;
            *((void *)&v416 + 1) = *(void *)&v393.f64[0];
            float64_t v207 = v392.f64[0];
            goto LABEL_146;
          }
        }
        abort();
      }
      return result;
    default:
      return 1000;
  }
}

void function_evaluate(uint64_t a1, float *a2, float *a3, float *a4, __n128 a5)
{
  uint64_t v8 = a1;
  v33[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    unint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 48);
    if (v9 >> 61)
    {
      uint64_t v11 = (char *)MEMORY[0x1F4188790](a1, a5);
      uint64_t v13 = (char *)&v32;
      float64x2_t v14 = 0;
      goto LABEL_11;
    }
    a1 = 8 * v9;
  }
  else
  {
    unint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  uint64_t v11 = (char *)MEMORY[0x1F4188790](a1, a5);
  uint64_t v13 = (char *)v33 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v9 <= 0x1FFFFFFFFFFFFFFELL) {
    float64x2_t v14 = (char *)v33 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  }
  else {
    float64x2_t v14 = 0;
  }
  if (v9 - 0x1FFFFFFFFFFFFFFFLL >= v16)
  {
    uint64_t v11 = (char *)malloc_type_malloc((size_t)v11, 0xAA0F682AuLL);
    float64x2_t v14 = v11;
  }
LABEL_11:
  MEMORY[0x1F4188790](v11, v12);
  unsigned int v20 = (double *)((char *)v33 - v18);
  if (v17 <= 0x1FFFFFFFFFFFFFFELL) {
    float64x2_t v21 = (double *)((char *)v33 - v18);
  }
  else {
    float64x2_t v21 = 0;
  }
  if (v17 - 0x1FFFFFFFFFFFFFFFLL >= v19) {
    float64x2_t v21 = (double *)malloc_type_malloc(8 * v10, 0x763212C9uLL);
  }
  if (v9)
  {
    double v22 = (double *)v14;
    do
    {
      float v23 = *a2++;
      *v22++ = v23;
      --v9;
    }
    while (v9);
  }
  CGFunctionEvaluate(v8, v14, v21);
  if (a4)
  {
    if (v10 != 1)
    {
      double v24 = v21;
      uint64_t v25 = v10 - 1;
      do
      {
        double v26 = *v24++;
        float v27 = v26;
        *a3++ = v27;
        --v25;
      }
      while (v25);
    }
    float v28 = v21[v10 - 1];
    *a4 = v28;
  }
  else if (v10)
  {
    __n64 v29 = v21;
    do
    {
      double v30 = *v29++;
      float v31 = v30;
      *a3++ = v31;
      --v10;
    }
    while (v10);
  }
  if (v21 != v20) {
    free(v21);
  }
  if (v14 != v13) {
    free(v14);
  }
}

uint64_t CGFunctionEvaluate(uint64_t a1, char *a2, double *a3)
{
  v21[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790]();
  if (v7 <= 0x1FFFFFFFFFFFFFFELL) {
    unint64_t v9 = (char *)v21 - v8;
  }
  else {
    unint64_t v9 = 0;
  }
  if (v7 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000012) {
    unint64_t v9 = (char *)malloc_type_malloc(8 * v6, 0x5FF19727uLL);
  }
  uint64_t v10 = *(void *)(a1 + 40);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      uint64_t v12 = 0;
      uint64_t v13 = (double *)(v10 + 8);
      do
      {
        double v14 = *(v13 - 1);
        double v15 = *(double *)&a2[8 * v12];
        if (v15 >= v14 && (double v14 = *v13, v15 <= *v13)) {
          *(double *)&v9[8 * v12] = v15;
        }
        else {
          *(double *)&v9[8 * v12] = v14;
        }
        ++v12;
        v13 += 2;
      }
      while (v11 != v12);
    }
    a2 = v9;
  }
  uint64_t result = (*(uint64_t (**)(void, char *, double *))(a1 + 72))(*(void *)(a1 + 24), a2, a3);
  uint64_t v17 = *(void *)(a1 + 56);
  if (v17)
  {
    uint64_t v18 = *(void *)(a1 + 48);
    if (v18)
    {
      unint64_t v19 = (double *)(v17 + 8);
      do
      {
        double v20 = *(v19 - 1);
        if (*a3 < v20 || (double v20 = *v19, *a3 > *v19)) {
          *a3 = v20;
        }
        ++a3;
        v19 += 2;
        --v18;
      }
      while (v18);
    }
  }
  return result;
}

void *gradient_evaluate(void *result, double *a2, double *a3)
{
  unint64_t v3 = result[2];
  unint64_t v4 = v3 - 2;
  if (v3 >= 2)
  {
    double v5 = *a2;
    uint64_t v6 = result[1];
    uint64_t v7 = result[3];
    uint64_t v8 = v6 + 1;
    double v9 = *(double *)(v7 + 8 * (v6 + 1));
    uint64_t v10 = 0;
    if (*a2 <= v9)
    {
      double v14 = 0.0;
      uint64_t v12 = v6 + 1;
      if (v6)
      {
LABEL_9:
        double v15 = (v5 - v14) / (v9 - v14);
        uint64_t v16 = v7 + 8;
        uint64_t v17 = (double *)(v16 + 8 * v10 * v8);
        uint64_t v18 = (double *)(v16 + 8 * v12);
        do
        {
          double v19 = *v17++;
          double v20 = v19;
          double v21 = *v18++;
          *a3++ = v15 * v21 + (1.0 - v15) * v20;
          --v6;
        }
        while (v6);
      }
    }
    else
    {
      uint64_t v11 = (double *)(v7 + 16 * v6 + 16);
      uint64_t v12 = v6 + 1;
      double v13 = *(double *)(v7 + 8 * (v6 + 1));
      while (v4 != v10)
      {
        double v9 = *v11;
        ++v10;
        v12 += v8;
        v11 += v6 + 1;
        double v14 = v13;
        double v13 = v9;
        if (v5 <= v9)
        {
          if (v6) {
            goto LABEL_9;
          }
          return result;
        }
      }
    }
  }
  return result;
}

void *RIPLayerBltShade(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (_DWORD *)a3;
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  v63[0] = 0;
  v63[1] = 0;
  if (a3 || (uint64_t v11 = v63, result = (void *)CGSBoundsIntersection((int *)(a1 + 12), (int *)a4, v63), result))
  {
    uint64_t v89 = 0;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v58 = 0u;
    if (a2 && !*(void *)(a2 + 72))
    {
      if (*(_DWORD *)(a2 + 64))
      {
        if (v11 == (_DWORD *)(a2 + 12) || !ripl_IsContained(v11, (_DWORD *)(a2 + 12)))
        {
          char Mask = ripl_CreateMask(a2, 0, a3, a4, a5, a6, a7, a8);
          uint64_t result = 0;
          if ((Mask & 1) == 0) {
            return result;
          }
        }
        else
        {
          a2 = 0;
        }
      }
      else if (!*(void *)(a2 + 56) && ripl_IsEnclosed(v11, (_DWORD *)(a2 + 12)))
      {
        a2 = 0;
      }
    }
    double v15 = *(long long **)(a1 + 40);
    if (!v15)
    {
      *(void *)&long long v85 = 0;
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      double v15 = &v71;
      long long v71 = 0u;
      long long v72 = 0u;
    }
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(void *)a1 + 32))(a1, 32, v11);
    if (result)
    {
      double v22 = result;
      uint64_t v23 = *result;
      if (!*result
        || !*(void *)(v23 + 48)
        || !*(void *)(a1 + 56) && !ripl_CreateMask(a1, 1, v16, v17, v18, v19, v20, v21))
      {
        goto LABEL_45;
      }
      *(unsigned char *)double v15 = *(_DWORD *)a6;
      ripl_BltOpDestination((uint64_t)v15, (uint64_t)v11, a1);
      uint64_t v24 = *(void *)(a4 + 56);
      int v25 = *(_DWORD *)a4;
      int v26 = *(_DWORD *)(a4 + 4);
      int v27 = *(_DWORD *)(a4 + 8);
      unsigned int v28 = *(_DWORD *)(a4 + 12);
      *((unsigned char *)v15 + 1) = 1;
      *((_DWORD *)v15 + 14) = *v11 - v25;
      *((_DWORD *)v15 + 15) = v28 + v26 - (v11[1] + v11[3]);
      *((_DWORD *)v15 + 16) = v27;
      *(void *)((char *)v15 + 68) = v28;
      int v29 = *(_DWORD *)(v24 + 20);
      if (v29 == 2)
      {
        int v30 = *(_DWORD *)(v24 + 32);
        int v31 = 4 * v30;
      }
      else if (v29 == 1)
      {
        int v30 = *(_DWORD *)(v24 + 32);
        int v31 = 3 * v30;
      }
      else
      {
        int v30 = *(_DWORD *)(v24 + 32);
        int v31 = v30;
      }
      *((_DWORD *)v15 + 19) = 4 * v31;
      *((void *)v15 + 11) = *(void *)(v24 + 64);
      uint64_t v33 = *(void *)(v24 + 72);
      int v34 = 4 * v30;
      if (!v33) {
        int v34 = 0;
      }
      *((_DWORD *)v15 + 20) = v34;
      *((void *)v15 + 12) = v33;
      ripl_BltOpMask((uint64_t)v15, v11, a2);
      if (!CGBlt_initialize((uint64_t)v15)) {
        goto LABEL_45;
      }
      if (a5)
      {
        if (*(_UNKNOWN **)a5 != &ripc_class) {
          goto LABEL_45;
        }
        float v36 = *(float *)(a5 + 156);
        uint64_t v35 = a5 + 156;
        *(void *)&long long v62 = v35 - 128;
        if (v36 >= 1.0) {
          *((void *)&v62 + 1) = 0;
        }
        else {
          *((void *)&v62 + 1) = v35;
        }
      }
      else
      {
        long long v62 = 0uLL;
      }
      int v37 = (*(unsigned __int16 *)(a6 + 4) << 8) | 0xFF;
      LODWORD(v58) = v37;
      double v38 = *(double *)(a6 + 48);
      float v39 = 0.0;
      if (v38 >= 0.0)
      {
        float v39 = 1.0;
        if (v38 <= 1.0) {
          float v39 = v38;
        }
      }
      *((float *)&v58 + 1) = v39;
      uint64_t v40 = *(float **)(a4 + 64);
      if (v40)
      {
        int v41 = *(_DWORD *)(a1 + 24);
        int v42 = v41 + *(_DWORD *)(a1 + 16);
        double v43 = (double)*(int *)(a1 + 12);
        _D2 = (double)v41;
        float v45 = *(double *)v40;
        float v66 = v45;
        _Q3 = *(float64x2_t *)(v40 + 2);
        float32x2_t v67 = vneg_f32(vcvt_f32_f64(_Q3));
        double v47 = *((double *)v40 + 3);
        __asm { FMLA            D5, D2, V3.D[1] }
        *(float *)_Q3.f64 = v47;
        float v53 = _D5 - (double)v42;
        int v68 = LODWORD(_Q3.f64[0]);
        float v69 = v53;
        float v54 = v43 - (*((double *)v40 + 5) + v47 * (double)v41);
        float v70 = v54;
        uint64_t v40 = &v66;
      }
      *((void *)&v58 + 1) = v40;
      double v55 = *(int64x2_t **)(a4 + 56);
      *((void *)&v61 + 1) = v55 + 3;
      *(int32x2_t *)&long long v61 = vmovn_s64(v55[2]);
      uint64_t v56 = v55[1].u32[1];
      if (v56 <= 2)
      {
        LODWORD(v58) = dword_1852932B0[v56] | (*(_DWORD *)(a4 + 40) << 28) | v37;
        long long v59 = *(_OWORD *)(a4 + 24);
        *(void *)&long long v60 = *(void *)(a4 + 16);
        double v57 = *(float64x2_t **)(a4 + 48);
        float32x4_t v64 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*v57), v57[1]);
        float32x2_t v65 = vcvt_f32_f64(v57[2]);
        *((void *)&v60 + 1) = &v64;
        if (!(*(unsigned int (**)(void *, long long *, long long *))(v23 + 48))(v22, v15, &v58)) {
          uint64_t v11 = 0;
        }
        goto LABEL_46;
      }
LABEL_45:
      uint64_t v11 = 0;
LABEL_46:
      (*(void (**)(uint64_t, _DWORD *))(*(void *)a1 + 48))(a1, v11);
      return (void *)(v11 != 0);
    }
  }
  return result;
}

BOOL ripl_IsEnclosed(_DWORD *a1, _DWORD *a2)
{
  BOOL result = 0;
  if (*a1 >= *a2)
  {
    int v2 = a1[1];
    int v3 = a2[1];
    if (v2 >= v3 && a1[2] + *a1 <= a2[2] + *a2 && a1[3] + v2 <= a2[3] + v3) {
      return 1;
    }
  }
  return result;
}

uint64_t *RIPDataGetEntry(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  RIPLockCacheState();
  uint64_t v8 = (uint64_t *)(a2 + 16);
  double v9 = *(uint64_t **)(a2 + 24);
  if (v9 == (uint64_t *)(a2 + 16))
  {
LABEL_6:
    double v9 = 0;
  }
  else
  {
    while (*((_DWORD *)v9 + 12) != a3 || !(*(unsigned int (**)(uint64_t, uint64_t *))(a4 + 16))(a4, v9))
    {
      double v9 = (uint64_t *)v9[1];
      if (v9 == v8) {
        goto LABEL_6;
      }
    }
    uint64_t v10 = *v9;
    if ((uint64_t *)*v9 != v8)
    {
      uint64_t v11 = (void *)v9[1];
      *(void *)(v10 + 8) = v11;
      *uint64_t v11 = v10;
      uint64_t v12 = *(uint64_t ***)(a2 + 24);
      *double v9 = (uint64_t)v8;
      v9[1] = (uint64_t)v12;
      *(void *)(a2 + 24) = v9;
      *uint64_t v12 = v9;
    }
    uint64_t v13 = *(void *)(a1 + 208);
    ++*((_DWORD *)v9 + 14);
    if (RIPGetCacheState_predicate != -1) {
      dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
    }
    uint64_t v14 = v9[5];
    uint64_t v15 = *(void *)(RIPGetCacheState_cache_state + 8);
    if (v14 != v13)
    {
      if (v14 == v15)
      {
        uint64_t v15 = v9[5];
      }
      else
      {
        --*(void *)(v14 + 16);
        v9[5] = v15;
        ++*(void *)(v15 + 16);
      }
    }
    uint64_t v16 = v9 + 2;
    uint64_t v17 = v9[2];
    if (v17 != v15)
    {
      uint64_t v18 = (void *)v9[3];
      *(void *)(v17 + 8) = v18;
      *uint64_t v18 = v17;
      uint64_t v19 = *(uint64_t ***)(v15 + 8);
      v9[2] = v15;
      v9[3] = (uint64_t)v19;
      *(void *)(v15 + 8) = v16;
      *uint64_t v19 = v16;
    }
    ++*((_DWORD *)v9 + 13);
  }
  RIPUnlockCacheState();
  return v9;
}

uint64_t CGShadingCreateAxialInternal(void *a1, uint64_t a2, uint64_t a3, double *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  EmptCGFloat y = 0;
  if (a1 && a5)
  {
    uint64_t v15 = *(void *)(a1[3] + 48);
    uint64_t v16 = a5[6];
    if (v16 == v15 || v16 == v15 + 1)
    {
      char v18 = a7;
      char v19 = a6;
      EmptCGFloat y = CGShadingCreateEmpty(1, a1, a2, a3, (uint64_t)a5, a6, a7, a8);
      *(double *)(Empty + 120) = a9;
      *(double *)(Empty + 128) = a10;
      *(unsigned char *)(Empty + 136) = v19;
      *(double *)(Empty + 144) = a11;
      *(double *)(Empty + 152) = a12;
      *(unsigned char *)(Empty + 160) = v18;
      CFRetain(a5);
      *(void *)(Empty + 184) = a5;
      if (a4)
      {
        *(double *)(Empty + 168) = *a4;
        double v24 = a4[1];
      }
      else
      {
        *(void *)(Empty + 168) = 0;
        double v24 = 1.0;
      }
      *(double *)(Empty + 176) = v24;
    }
    else
    {
      return 0;
    }
  }
  return Empty;
}

uint64_t CGShadingCreateEmpty(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v9 = (uint64_t *)a3;
  if ((a1 - 1) > 3) {
    uint64_t v12 = 104;
  }
  else {
    uint64_t v12 = qword_185210918[a1 - 1];
  }
  if (_block_invoke_once_10723 != -1) {
    dispatch_once(&_block_invoke_once_10723, &__block_literal_global_5_10724);
  }
  uint64_t Instance = CGTypeCreateInstance(CGShadingGetTypeID_shading_type_id, v12, a3, a4, a5, a6, a7, a8);
  uint64_t v14 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = atomic_fetch_add_explicit(CGShadingCreateEmpty_identifier, 1u, memory_order_relaxed)
                               + 1;
    if (a2)
    {
      CFRetain(a2);
      *(void *)(v14 + 24) = a2;
      *(_DWORD *)(v14 + 20) = a1;
      if (v9)
      {
        uint64_t v15 = *(void *)(a2[3] + 48);
LABEL_11:
        uint64_t v16 = v15 + 1;
        BOOL v17 = v15 == -1;
        char v18 = malloc_type_malloc(8 * (v15 + 1), 0x705560E0uLL);
        if (!v17)
        {
          char v19 = v18;
          do
          {
            uint64_t v20 = *v9++;
            *v19++ = v20;
            --v16;
          }
          while (v16);
        }
        *(void *)(v14 + 32) = v18;
      }
    }
    else
    {
      uint64_t v15 = 0;
      *(void *)(Instance + 24) = 0;
      *(_DWORD *)(Instance + 20) = a1;
      if (v9) {
        goto LABEL_11;
      }
    }
    uint64_t v21 = &CGRectNull;
    if (a4) {
      uint64_t v21 = (const CGRect *)a4;
    }
    *(unsigned char *)(v14 + 40) = a4 != 0;
    CGSize size = v21->size;
    *(CGPoint *)(v14 + 48) = v21->origin;
    *(CGSize *)(v14 + 64) = size;
    *(void *)(v14 + 88) = 0;
  }
  return v14;
}

CGFunctionRef CGGradientGetFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("CGGradientGetFunction", 396, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/API/CGGradient.c", "g != NULL", "gradient is missing", a6, a7, a8, v17);
  }
  CGFunctionRef result = *(CGFunctionRef *)(a1 + 32);
  if (!result)
  {
    uint64_t v10 = (CFTypeRef *)malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
    uint64_t v11 = *(const void **)(a1 + 40);
    v10[2] = *(CFTypeRef *)(a1 + 48);
    *uint64_t v10 = CFRetain(v11);
    _OWORD v10[3] = CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
    uint64_t v12 = *(void *)(a1 + 24);
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 24);
      size_t v14 = *(void *)(v13 + 48) + 1;
      v10[1] = (CFTypeRef)v14;
      if (*(unsigned char *)(v13 + 13)) {
        uint64_t v15 = (const CGFloat *)&create_function_extended_range;
      }
      else {
        uint64_t v15 = (const CGFloat *)&create_function_default_range;
      }
    }
    else
    {
      size_t v14 = 1;
      v10[1] = (CFTypeRef)1;
      uint64_t v15 = (const CGFloat *)&create_function_default_range;
    }
    if (*(unsigned char *)(a1 + 20)) {
      uint64_t v16 = (const CGFunctionCallbacks *)&create_function_premul_callbacks;
    }
    else {
      uint64_t v16 = (const CGFunctionCallbacks *)&create_function_default_callbacks;
    }
    CGFunctionRef result = CGFunctionCreate(v10, 1uLL, create_function_domain, v14, &v15[10 - 2 * v14], v16);
    *(void *)(a1 + 32) = result;
    if (!result)
    {
      CFRelease(*v10);
      free(v10);
      return 0;
    }
  }
  return result;
}

void CGContextDrawShading(CGContextRef c, CGShadingRef shading)
{
  if (!c)
  {
    CGContextRef v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextDrawShading", (uint64_t)v10, v2, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v10 = c;
    goto LABEL_8;
  }
  if (shading)
  {
    uint64_t v8 = *((void *)c + 5);
    if (v8)
    {
      double v9 = *(void (**)(void))(v8 + 96);
      if (v9) {
        v9();
      }
    }
  }
}

CGFunctionRef CGFunctionCreate(void *info, size_t domainDimension, const CGFloat *domain, size_t rangeDimension, const CGFloat *range, const CGFunctionCallbacks *callbacks)
{
  uint64_t v8 = 0;
  if (domainDimension && rangeDimension && callbacks)
  {
    if (callbacks->evaluate)
    {
      if (_block_invoke_once_6090 != -1) {
        dispatch_once(&_block_invoke_once_6090, &__block_literal_global_8_6091);
      }
      uint64_t Instance = CGTypeCreateInstance(CGFunctionGetTypeID_function_type_id, 96, (uint64_t)domain, rangeDimension, (uint64_t)range, (uint64_t)callbacks, v6, v7);
      uint64_t v8 = (CGFunction *)Instance;
      *(_DWORD *)(Instance + 16) = atomic_fetch_add_explicit(CGFunctionCreate_identifier, 1u, memory_order_relaxed) + 1;
      *(void *)(Instance + 24) = info;
      CGFunctionReleaseInfoCallback releaseInfo = callbacks->releaseInfo;
      *(_OWORD *)(Instance + 64) = *(_OWORD *)&callbacks->version;
      *(void *)(Instance + 80) = releaseInfo;
      *(void *)(Instance + 88) = 0;
      *(void *)(Instance + 96) = 0;
      *(void *)(Instance + 104) = 0;
      *(void *)(Instance + 32) = domainDimension;
      if (domain)
      {
        size_t v17 = 16 * domainDimension;
        char v18 = malloc_type_malloc(v17, 0x2062DE7BuLL);
        *((void *)v8 + 5) = v18;
        memcpy(v18, domain, v17);
      }
      else
      {
        *(void *)(Instance + 40) = 0;
      }
      *((void *)v8 + 6) = rangeDimension;
      if (range)
      {
        size_t v19 = 16 * rangeDimension;
        uint64_t v20 = malloc_type_malloc(v19, 0x2062DE7BuLL);
        *((void *)v8 + 7) = v20;
        memcpy(v20, range, v19);
      }
      else
      {
        *((void *)v8 + 7) = 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v8;
}

void ripc_AddEntry(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 40) = a1;
  ++*(void *)(a1 + 16);
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  uint64_t v3 = *(void *)(RIPGetCacheState_cache_state + 8);
  ++*(void *)(RIPGetCacheState_cache_state + 16);
  uint64_t v4 = *(void **)(v3 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = (void *)(a2 + 16);
  *(void *)(v3 + 8) = v5;
  *uint64_t v5 = v3;
  *uint64_t v4 = v6;
  *(void *)(v6 + 8) = v4;
}

void *RIPDataCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_block_invoke_once_4683 != -1) {
    dispatch_once(&_block_invoke_once_4683, &__block_literal_global_4_4684);
  }
  CGFunctionRef result = (void *)CGTypeCreateInstance(RIPDataGetTypeID_data_type_id, 32, a3, a4, a5, a6, a7, a8);
  result[2] = result + 2;
  result[3] = result + 2;
  result[4] = a1;
  result[5] = 0;
  return result;
}

void *RIPCacheEntryCreate(int a1, uint64_t a2)
{
  RIPLockCacheState();
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  if (*(void *)(RIPGetCacheState_cache_state + 16) <= *(void *)(RIPGetCacheState_cache_state + 24)
    || (v4 = *(void **)(RIPGetCacheState_cache_state + 8), uint64_t v5 = (void *)*v4, (void *)*v4 == v4))
  {
    RIPUnlockCacheState();
  }
  else
  {
    uint64_t v6 = v5 - 2;
    RIPCacheEntryRemove(v5 - 2);
    RIPUnlockCacheState();
    RIPCacheEntryRelease(v6);
  }
  CGFunctionRef result = malloc_type_malloc(0xA8uLL, 0x10E20404CCF93ECuLL);
  if (result)
  {
    *CGFunctionRef result = result;
    result[1] = result;
    result[2] = result + 2;
    result[3] = result + 2;
    result[4] = a2;
    result[5] = 0;
    *((_DWORD *)result + 13) = 0;
    *((_DWORD *)result + 14) = 0;
    *((_DWORD *)result + 12) = a1;
  }
  return result;
}

void *CGColorTransformConvertComponentData(void *a1, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, uint64_t a11, uint64_t a12, int a13)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v27 = CFGetTypeID(a1);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v27 != CGColorTransformGetTypeID_type_id) {
    return 0;
  }
  int v28 = 4096;
  uint64_t v53 = a8;
  float v54 = a2;
  uint64_t BitsPerComponent = CGPixelComponentGetBitsPerComponent(a3, v20, v21, v22, v23, v24, v25, v26);
  uint64_t v51 = a5;
  uint64_t v52 = a6;
  if (a3 != 2 && a3 != 5)
  {
    if (a3 == 4)
    {
      if (a2) {
        uint64_t v48 = *(void *)(a2[3] + 48);
      }
      else {
        uint64_t v48 = 0;
      }
      int v37 = a10;
      int v28 = 0x2000;
      uint64_t v38 = 32;
      uint64_t v49 = a13;
      uint64_t v39 = a4;
      int v40 = 0x2000;
      goto LABEL_21;
    }
    int v28 = 0;
  }
  if (a2) {
    uint64_t v48 = *(void *)(a2[3] + 48);
  }
  else {
    uint64_t v48 = 0;
  }
  uint64_t v36 = CGPixelComponentGetBitsPerComponent(a3, v29, v30, v31, v32, v33, v34, v35);
  if (a3 == 2)
  {
    int v40 = 4096;
    uint64_t v38 = v36;
    uint64_t v49 = a13;
    uint64_t v39 = a4;
    int v37 = a10;
  }
  else
  {
    int v37 = a10;
    if (a3 == 5)
    {
      int v40 = 4096;
      uint64_t v38 = v36;
      uint64_t v49 = a13;
      uint64_t v39 = a4;
    }
    else
    {
      uint64_t v38 = v36;
      uint64_t v49 = a13;
      uint64_t v39 = a4;
      int v40 = 0;
    }
  }
LABEL_21:
  uint64_t v41 = v37;
  Cache = CGColorTransformGetCache(a1);
  if (Cache)
  {
    uint64_t v43 = Cache[2];
    if (v43) {
      uint64_t v43 = *(void *)(*(void *)(v43 + 24) + 48);
    }
  }
  else
  {
    uint64_t v43 = 0;
  }
  v81[0] = v53;
  v81[1] = v51;
  v81[2] = v52;
  v81[3] = v41;
  int v82 = v39;
  int v83 = 0;
  int v84 = a3;
  int v85 = 0;
  uint64_t v86 = BitsPerComponent;
  uint64_t v87 = v48;
  int v88 = 0;
  int v89 = v28;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  v55[0] = a11;
  v55[1] = v51;
  v55[2] = v52;
  v55[3] = v49;
  int v56 = v39;
  int v57 = 0;
  int v58 = a3;
  int v59 = 0;
  uint64_t v60 = v38;
  uint64_t v61 = v43;
  int v62 = 0;
  int v63 = v40;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  CFTypeID v44 = CFGetTypeID(a1);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v44 != CGColorTransformGetTypeID_type_id) {
    return 0;
  }
  CGCMSConverter = CGColorTransformCreateCGCMSConverter(a1, v54, v39);
  long long v46 = CGCMSConverterConvert(CGCMSConverter, (uint64_t)v81, (uint64_t)v55);
  if (CGCMSConverter) {
    CFRelease(CGCMSConverter);
  }
  return v46;
}

const void *CGColorTransformCreateCGCMSConverter(void *a1, void *a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v6 != CGColorTransformGetTypeID_type_id) {
    return 0;
  }
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  _OWORD v11[2] = __create_resolved_source_space_block_invoke;
  v11[3] = &__block_descriptor_tmp_36_17179;
  v11[4] = a1;
  ResolvedColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)v11);
  Cache = CGColorTransformGetCache(a1);
  Converter = CGColorTransformCacheCreateConverter((uint64_t)Cache, ResolvedColorSpace, a3);
  CGColorSpaceRelease(ResolvedColorSpace);
  return Converter;
}

uint64_t rip_auto_context_draw_shading(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1)
  {
    uint64_t v7 = 112;
    pthread_mutex_lock((pthread_mutex_t *)0x70);
    uint64_t v6 = 0;
    goto LABEL_6;
  }
  uint64_t v6 = *(void *)(a1 + 288);
  uint64_t v7 = v6 + 112;
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 112));
  if (!v6)
  {
LABEL_6:
    uint64_t v8 = 0;
    goto LABEL_7;
  }
  uint64_t v8 = *(void *)(v6 + 88);
  if (!v8) {
    uint64_t v8 = *(void *)(v6 + 80);
  }
LABEL_7:
  rip_auto_context_update_content_info_from_GState(v6, a3);
  uint64_t v9 = *(void *)(a4 + 24);
  int content_type_from_color_space = rip_auto_context_get_content_type_from_color_space(v9);
  *(_DWORD *)(v6 + 108) |= content_type_from_color_space;
  if (content_type_from_color_space != 1)
  {
    if (content_type_from_color_space == 2)
    {
      if (v9) {
        BOOL v18 = *(unsigned char *)(*(void *)(v9 + 24) + 14) != 0;
      }
      else {
        BOOL v18 = 0;
      }
      char v19 = *(unsigned char *)(v6 + 104) | v18;
    }
    else
    {
      char v19 = 1;
    }
    *(unsigned char *)(v6 + 104) = v19;
  }
  if (v8)
  {
    uint64_t v20 = *(void *)(v8 + 40);
    if (v20)
    {
      uint64_t v21 = *(uint64_t (**)(void))(v20 + 96);
      if (v21) {
        uint64_t v22 = v21();
      }
      else {
        uint64_t v22 = 1006;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    *(unsigned char *)(v6 + 105) |= rip_auto_context_contains_transparency(v6, v11, v12, v13, v14, v15, v16, v17);
  }
  else
  {
    uint64_t v22 = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)v7);
  return v22;
}

uint64_t dlRecorder_DrawShading(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v8 = *(CFArrayRef **)(a1 + 288)) == 0)
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"dlRecorder_DrawShading");
    return 1000;
  }
  uint64_t v12 = (double *)CG::DisplayListRecorder::currentDisplayList(v8);
  if (!v12) {
    return 1000;
  }
  uint64_t v13 = v12;
  if (v12[5] == INFINITY || v12[6] == INFINITY) {
    return 0;
  }
  uint64_t result = 0;
  if (v13[7] != 0.0 && v13[8] != 0.0)
  {
    long long v16 = *(_OWORD *)(a3 + 40);
    long long v42 = *(_OWORD *)(a3 + 24);
    long long v43 = v16;
    long long v44 = *(_OWORD *)(a3 + 56);
    if (!*((unsigned char *)v13 + 73)) {
      goto LABEL_23;
    }
    if (a4[40])
    {
      uint64_t v17 = (const CGRect *)(a4 + 48);
      p_CGFloat y = (CGFloat *)(a4 + 56);
      p_CGSize size = (CGSize *)(a4 + 64);
      p_double height = (CGFloat *)(a4 + 72);
    }
    else
    {
      uint64_t v17 = &CGRectInfinite;
      p_double height = &CGRectInfinite.size.height;
      p_CGFloat y = &CGRectInfinite.origin.y;
      p_CGSize size = &CGRectInfinite.size;
    }
    double v21 = *p_height;
    double v22 = *p_y;
    CGFloat width = p_size->width;
    CGFloat x = v17->origin.x;
    double v39 = v22;
    double v40 = width;
    double v41 = v21;
    CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(&x, a2, *(double **)(a3 + 112), *(void *)(*(void *)(a3 + 120) + 16));
    uint64_t result = 0;
    CGFloat x = v27;
    double v39 = v24;
    double v40 = v25;
    double v41 = v26;
    if (v27 != INFINITY && v24 != INFINITY)
    {
      uint64_t result = 0;
      if (v25 != 0.0 && v26 != 0.0)
      {
LABEL_23:
        uint64_t v28 = CG::DisplayList::shadingResourceForShading((CG::DisplayList *)(v13 + 2), (CGShading *)a4);
        if (v28)
        {
          uint64_t v29 = v28;
          EntryDrawingState = (void *)CG::DisplayList::getEntryDrawingState((uint64_t)(v13 + 2), (void *)a3, a2);
          uint64_t v31 = EntryDrawingState[1];
          if (v31)
          {
            int v32 = *(_DWORD *)(v31 + 8);
            uint64_t v33 = EntryDrawingState[2];
            if (v33) {
              v32 |= *(_DWORD *)(v33 + 8);
            }
            int v34 = v32 & 0x1000;
            uint64_t v35 = EntryDrawingState[3];
            if (v35) {
              v34 |= *(_DWORD *)(v35 + 8) & 0x3400;
            }
            uint64_t v36 = *(void *)(a3 + 120);
            if (*(double *)(v36 + 8) >= 1.0) {
              int v37 = *(_DWORD *)(v29 + 8) & 0x1000 | v34;
            }
            else {
              LOWORD(v37) = v34 | 0x1000;
            }
            if ((v37 & 0x1000) == 0 && (((int)(*(_DWORD *)(v36 + 4) << 16) >> 24) - 3) < 0xFFFFFFFE) {
              LOWORD(v37) = v37 | 0x1000;
            }
            if ((v37 & 0x3000) != 0) {
              *((_DWORD *)v13 + 20) |= v37 & 0x3000;
            }
            if (*((unsigned char *)v13 + 74))
            {
              if ((v37 & 0x400) != 0) {
                CG::DisplayList::getEntryPatternState((uint64_t)(v13 + 2), a3, a2);
              }
              operator new();
            }
            return 0;
          }
        }
        return 1000;
      }
    }
  }
  return result;
}

uint64_t CG::DisplayList::shadingResourceForShading(CG::DisplayList *this, CGShading *a2)
{
  if (!a2) {
    return 0;
  }
  ++*((void *)this + 82);
  uint64_t v3 = (char *)this + 280;
  uint64_t v4 = (char *)*((void *)this + 35);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = (char *)this + 280;
  do
  {
    uint64_t v7 = *((void *)v4 + 4);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 5);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 16);
    }
    uint64_t v9 = (char **)(v4 + 8);
    if (v8 >= (unint64_t)a2)
    {
      uint64_t v9 = (char **)v4;
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_15;
  }
  uint64_t v10 = *((void *)v5 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)v5 + 5);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(void *)(v10 + 16) < (unint64_t)a2)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
    uint64_t v14 = *((void *)v5 + 4);
    uint64_t v13 = (std::__shared_weak_count *)*((void *)v5 + 5);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v15 = *(void *)(v14 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    else
    {
      unint64_t v15 = *(void *)(v14 + 16);
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    if (v15 <= (unint64_t)a2) {
      return *((void *)v5 + 4);
    }
LABEL_15:
    operator new();
  }
  if (*(CGShading **)(v10 + 16) != a2) {
    goto LABEL_15;
  }
  return *((void *)v5 + 4);
}

void sub_184C755B0(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x10E1C40974E4E7ALL);
  _Unwind_Resume(a1);
}

BOOL __lookup_function_entry_block_invoke(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (*(_DWORD *)(a2 + 88) == *(_DWORD *)(a1 + 64) && *(void *)(a2 + 96) >= *(void *)(a1 + 48))
  {
    uint64_t v2 = *(float **)(a1 + 40);
    if (*(float *)(a2 + 112) <= *v2
      && *(float *)(a2 + 116) >= v2[1]
      && *(void *)(a2 + 104) >= *(void *)(a1 + 56)
      && *(float *)(a2 + 120) <= v2[2]
      && *(float *)(a2 + 124) >= v2[3])
    {
      uint64_t v3 = *(void *)(a1 + 32);
      if (*(_DWORD *)(a2 + 64) == *(_DWORD *)(v3 + 132)) {
        return 1;
      }
      uint64_t v5 = *(void *)(v3 + 136);
      uint64_t v4 = *(void *)(v3 + 144);
      if (*(void *)(a2 + 68) == v5 && *(void *)(a2 + 76) == v4) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t CGContextDelegateDrawLinearGradient(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 104);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

BOOL CGFontGetGlyphBBoxes(CGFontRef font, const CGGlyph *glyphs, size_t count, CGRect *bboxes)
{
  if (font)
  {
    CGFontRef v7 = font;
    font_info = get_font_info(font);
    if (font_info) {
      BOOL v9 = font_info[104] == 0;
    }
    else {
      BOOL v9 = 1;
    }
    uint64_t v10 = *(uint64_t (**)(uint64_t, void, BOOL, const CGGlyph *, size_t, CGRect *))(*((void *)v7 + 2)
                                                                                               + 312);
    uint64_t v11 = *((void *)v7 + 14);
    LOBYTE(font) = v10(v11, 0, v9, glyphs, count, bboxes);
  }
  return (char)font;
}

void vm_allocator_deallocate(unint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (MEMORY[0x18532BC60](*MEMORY[0x1E4F14960], -*MEMORY[0x1E4F14B00] & a1, a2)) {
      CGPostError((uint64_t)"%s: vm_deallocate failed: status %d.", v2, v3, v4, v5, v6, v7, v8, (char)"release_copied_data");
    }
  }
  else
  {
    free((void *)a1);
  }
}

void CGContextErase(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v10 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextErase", v10, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v10 = a1;
    goto LABEL_7;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    BOOL v9 = *(void (**)(void))(v8 + 168);
    if (v9) {
      v9();
    }
  }
}

void CGContextClipToRect(CGContextRef c, CGRect rect)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
      {
        CGGStateClipToRect(*((void *)c + 12), rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
        uint64_t v14 = (const void *)*((void *)c + 21);
        if (v14)
        {
          CFRelease(v14);
          *((void *)c + 21) = 0;
        }
      }
      return;
    }
    CGContextRef v15 = c;
  }
  else
  {
    CGContextRef v15 = 0;
  }

  handle_invalid_context((char)"CGContextClipToRect", (uint64_t)v15, v2, v3, v4, v5, v6, v7);
}

double CGGStateGetAlpha(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 120) + 8);
}

uint64_t CGColorFunctionGetProperties(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (CGColorTRCGetTypeID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorTRCGetTypeID_cglibrarypredicate, &__block_literal_global_785);
  }
  if (v2 == CGColorTRCGetTypeID_f())
  {
    if (trc_get_properties_cglibrarypredicate != -1) {
      dispatch_once(&trc_get_properties_cglibrarypredicate, &__block_literal_global_50);
    }
    uint64_t v3 = &trc_get_properties_f;
  }
  else
  {
    if (CGColorMatrixGetTypeID_cglibrarypredicate != -1) {
      dispatch_once(&CGColorMatrixGetTypeID_cglibrarypredicate, &__block_literal_global_16);
    }
    if (v2 == CGColorMatrixGetTypeID_f())
    {
      if (matrix_get_properties_cglibrarypredicate != -1) {
        dispatch_once(&matrix_get_properties_cglibrarypredicate, &__block_literal_global_54);
      }
      uint64_t v3 = &matrix_get_properties_f;
    }
    else
    {
      if (CGColorNxMTransformGetTypeID_cglibrarypredicate != -1) {
        dispatch_once(&CGColorNxMTransformGetTypeID_cglibrarypredicate, &__block_literal_global_24);
      }
      if (v2 != CGColorNxMTransformGetTypeID_f()) {
        return 0;
      }
      if (nxm_get_properties_cglibrarypredicate != -1) {
        dispatch_once(&nxm_get_properties_cglibrarypredicate, &__block_literal_global_58);
      }
      uint64_t v3 = &nxm_get_properties_f;
    }
  }
  uint64_t v4 = (uint64_t (*)(const void *))*v3;

  return v4(a1);
}

void CGGradientRelease(CGGradientRef gradient)
{
  if (gradient) {
    CFRelease(gradient);
  }
}

uint64_t CGImageProviderCopyIOSurface(uint64_t a1)
{
  if (a1
    && ((int v1 = *(_DWORD *)(a1 + 64), v1 == 3) || v1 == 2)
    && (CFTypeID v2 = *(uint64_t (**)(void))(a1 + 80)) != 0)
  {
    return v2(*(void *)(a1 + 56));
  }
  else
  {
    return 0;
  }
}

uint64_t img_data_lock(uint64_t a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, int a12, unsigned __int8 a13, unsigned int a14)
{
  char v14 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v17 = v16;
  unsigned int v353 = v18;
  unsigned int v20 = v19;
  uint64_t v22 = v21;
  unint64_t v364 = v23;
  unint64_t v25 = v24;
  uint64_t v26 = v15;
  uint64_t v389 = *MEMORY[0x1E4F143B8];
  if (a11)
  {
    unint64_t v27 = *(_WORD *)(a11 + 2) & 0x3FLL;
    uint64_t v28 = v27;
  }
  else if ((a12 - 2) > 3)
  {
    unint64_t v27 = 8;
    uint64_t v28 = 8;
  }
  else
  {
    uint64_t v28 = qword_1852223D8[a12 - 2];
    unint64_t v27 = 8;
  }
  uint64_t v363 = a11;
  char v357 = v14;
  if (v16)
  {
    if (a11) {
      BOOL v29 = *(void *)(v15 + 128) == 0;
    }
    else {
      BOOL v29 = 0;
    }
    if (v29) {
      char v30 = a10;
    }
    else {
      char v30 = 0;
    }
  }
  else
  {
    char v30 = 0;
  }
  uint64_t v365 = 0;
  unint64_t v366 = 0;
  bzero(&v368, 0xB40uLL);
  uint64_t v38 = *(void *)v26;
  uint64_t v37 = *(void *)(v26 + 8);
  unint64_t v360 = v25;
  if (v25 == (int)*(void *)v26)
  {
    __int16 v39 = 0;
    uint64_t v40 = v364;
    if (v20 - 3 <= 1)
    {
      uint64_t v41 = *(void *)(v26 + 8);
      uint64_t v362 = *(void *)v26;
      if ((int)v37 == v364) {
        goto LABEL_22;
      }
      goto LABEL_19;
    }
LABEL_21:
    uint64_t v41 = *(void *)(v26 + 8);
    uint64_t v362 = *(void *)v26;
    goto LABEL_22;
  }
  uint64_t v40 = v364;
  if (v20 - 3 > 1)
  {
    __int16 v39 = 0;
    goto LABEL_21;
  }
LABEL_19:
  __int16 v39 = 2;
  LODWORD(v41) = v40;
  LODWORD(v362) = v360;
LABEL_22:
  int v42 = *(_DWORD *)(v26 + 28);
  if ((v42 - 3) <= 2 && (v38 != *(void *)(v26 + 48) || v37 != *(void *)(v26 + 56))) {
    v39 |= 0x80u;
  }
  if (!v22)
  {
    char v346 = a10;
    int v44 = 0;
    goto LABEL_34;
  }
  uint64_t v43 = *(int *)(v22 + 4);
  int v44 = v43 & ~((int)v43 >> 31);
  if (*(int *)(v22 + 12) + v43 <= v40) {
    int v45 = *(_DWORD *)(v22 + 12) + v43;
  }
  else {
    int v45 = v40;
  }
  if (v45 <= v44) {
    goto LABEL_592;
  }
  char v346 = a10;
  if (v45 - v44 == v40)
  {
    uint64_t v22 = 0;
LABEL_34:
    int v46 = v41;
    goto LABEL_54;
  }
  if (v40 != (int)v41)
  {
    double v47 = (double)(int)v41 / (double)(unint64_t)v40;
    int v45 = vcvtpd_s64_f64(v47 * (double)v45);
    int v44 = vcvtmd_s64_f64(v47 * (double)v44);
    if (v45 >= (int)v41) {
      int v45 = v41;
    }
  }
  if (v44 >= 17) {
    int v48 = 16;
  }
  else {
    int v48 = 16 - v44;
  }
  if (v44 >= 17) {
    int v49 = v44;
  }
  else {
    int v49 = 0;
  }
  uint64_t v50 = v48 + v45;
  if (v45 - v49 + 15 >= v40) {
    int v45 = v40;
  }
  if (v50 >= v40) {
    int v45 = v40;
  }
  uint64_t v51 = v45 - v49;
  if (v51 < v40)
  {
    int v44 = v49;
  }
  else
  {
    int v45 = v40;
    int v44 = 0;
  }
  if (v51 >= v40) {
    uint64_t v22 = 0;
  }
  int v46 = v45;
LABEL_54:
  uint64_t v52 = *(_DWORD **)(v26 + 120);
  if (v52)
  {
    if (v22)
    {
      if (*v52 > (int)v38 || v52[2] + *v52 < 0) {
        goto LABEL_592;
      }
      unsigned int v53 = v44;
      int v54 = v46;
      if (v37 != v41)
      {
        if (v46 - v44 == v41)
        {
          unsigned int v53 = 0;
          int v54 = *(void *)(v26 + 8);
        }
        else
        {
          double v55 = (double)(int)v37 / (double)(int)v41;
          int v54 = vcvtpd_s64_f64(v55 * (double)v46);
          unsigned int v53 = vcvtmd_s64_f64(v55 * (double)v44);
          if (v54 >= (int)v37) {
            int v54 = *(void *)(v26 + 8);
          }
        }
      }
      int v56 = v37 - v53;
      int v57 = v52[1];
      if (v56 < v57 || (int)v37 - v54 > v52[3] + v57) {
        goto LABEL_592;
      }
    }
    v39 |= 1u;
  }
  if (v42 < 3) {
    char v58 = 1;
  }
  else {
    char v58 = v30;
  }
  int v358 = v41;
  int v355 = v44;
  unsigned int v352 = v20;
  if ((v58 & 1) == 0)
  {
    if (CGImageGetMaskingColors(*(void **)(v26 + 40)))
    {
      v39 |= 0x10u;
    }
    else if (CGImageGetMask(*(void **)(v26 + 40)))
    {
      Matte = CGImageGetMatte(*(void **)(v26 + 40));
      __int16 v60 = 48;
      if (!Matte) {
        __int16 v60 = 16;
      }
      v39 |= v60;
    }
    LODWORD(v41) = v358;
    int v44 = v355;
  }
  uint64_t v61 = *(void **)(v26 + 16);
  if (!v61)
  {
    if (img_globals_once != -1)
    {
      dispatch_once(&img_globals_once, &__block_literal_global_11955);
      int v44 = v355;
      LODWORD(v41) = v358;
    }
    unint64_t v62 = 0;
    long long v67 = 0;
    uint64_t v68 = img_globals_globals[0];
    uint64_t v345 = img_globals_globals[0];
    if (!a11) {
      uint64_t v68 = 0;
    }
    uint64_t v363 = v68;
    goto LABEL_134;
  }
  unint64_t v62 = *(unsigned int *)(v26 + 24);
  uint64_t v345 = *(void *)(v26 + 112);
  if ((v39 & 0xA2) != 0)
  {
    int v63 = v46;
    uint64_t v64 = v22;
    unint64_t v65 = *(unsigned int *)(v26 + 24);
    if (CGColorSpaceGetType(v61) == 7)
    {
      uint64_t v66 = v61[3];
      if ((*(_DWORD *)(v66 + 28) - 5) > 1) {
        long long v67 = 0;
      }
      else {
        long long v67 = **(void ***)(v66 + 96);
      }
      LODWORD(v41) = v358;
      int v44 = v355;
      unint64_t v62 = v65;
      v39 |= 8u;
      unint64_t v27 = 8;
    }
    else
    {
      long long v67 = v61;
      unint64_t v27 = v28;
      LODWORD(v41) = v358;
      int v44 = v355;
      unint64_t v62 = v65;
    }
    uint64_t v22 = v64;
    int v46 = v63;
    if (!v17) {
      goto LABEL_94;
    }
  }
  else
  {
    long long v67 = *(void **)(v26 + 16);
    unint64_t v27 = v28;
    if (!v17) {
      goto LABEL_94;
    }
  }
  if (*(unsigned char *)(v26 + 32))
  {
LABEL_94:
    long long v69 = (_DWORD *)a11;
    goto LABEL_95;
  }
  uint64_t v80 = v22;
  unint64_t v349 = v62;
  long long v81 = v67;
  if (CGColorTransformConvertNeedsCMS(v17, v67, v353)) {
    goto LABEL_108;
  }
  int v342 = v81;
  unsigned int Type = CGColorSpaceGetType(v81);
  if (Type > 0xB) {
    goto LABEL_285;
  }
  int v44 = v355;
  if (((1 << Type) & 0x1F) != 0)
  {
    uint64_t v22 = v80;
    long long v69 = (_DWORD *)a11;
    LODWORD(v41) = v358;
    unint64_t v62 = v349;
    long long v67 = v342;
    goto LABEL_95;
  }
  if (((1 << Type) & 0xC40) == 0)
  {
LABEL_285:
    if ((v30 & 1) == 0) {
      goto LABEL_108;
    }
    long long v67 = v61;
LABEL_287:
    long long v69 = (_DWORD *)a11;
    LODWORD(v41) = v358;
    int v44 = v355;
    unint64_t v62 = v349;
    uint64_t v22 = v80;
    goto LABEL_95;
  }
  long long v67 = v81;
  if (v81)
  {
    unint64_t v86 = *(void *)(v81[3] + 48);
    if (v86 <= 4 && ((1 << v86) & 0x1A) != 0) {
      goto LABEL_287;
    }
  }
LABEL_108:
  Cache = CGColorTransformGetCache(v17);
  if (Cache) {
    long long v67 = (void *)Cache[2];
  }
  else {
    long long v67 = 0;
  }
  long long v69 = (_DWORD *)a11;
  LODWORD(v41) = v358;
  int v44 = v355;
  unint64_t v62 = v349;
  uint64_t v22 = v80;
  v39 |= 4u;
LABEL_95:
  if (v69)
  {
    BOOL v70 = *v69 == 67637640;
    BOOL v71 = *v69 == 134886228;
    if (!v67) {
      goto LABEL_106;
    }
  }
  else
  {
    BOOL v70 = 0;
    BOOL v71 = 0;
    if (!v67) {
      goto LABEL_106;
    }
  }
  uint64_t v72 = *(void *)(v67[3] + 48);
  switch(v72)
  {
    case 4:
      if ((v39 & 0x10) != 0 || *(_DWORD *)(v26 + 24) != 0) {
        unint64_t v62 = 8;
      }
      break;
    case 3:
      int v84 = *(_DWORD *)(v26 + 24);
      if (v84 && v71)
      {
        unint64_t v62 = 8;
      }
      else
      {
        switch(v84)
        {
          case 0:
            if ((v39 & 0x10) != 0) {
              goto LABEL_123;
            }
            break;
          case 3:
            unint64_t v62 = 1;
            break;
          case 4:
          case 8:
          case 9:
LABEL_123:
            unint64_t v62 = 2;
            break;
          default:
            goto LABEL_134;
        }
      }
      break;
    case 1:
      if (!*(_DWORD *)(v26 + 24)) {
        BOOL v70 = 1;
      }
      if (!v70) {
        unint64_t v62 = 8;
      }
      break;
    default:
LABEL_106:
      img_release_resources(v26);
      CGPostError((uint64_t)"%s: Cannot convert to destination", v73, v74, v75, v76, v77, v78, v79, v357);
      return 0;
  }
LABEL_134:
  uint64_t v87 = *(unsigned int **)(v26 + 112);
  int v88 = *(_DWORD *)(v26 + 28);
  unsigned int v89 = v88 - 3;
  if (v88 != 3 && (v39 & 0x96) == 0)
  {
    if (v88 == 2)
    {
      if (*(void *)(v26 + 128) && v87) {
        goto LABEL_157;
      }
    }
    else
    {
      if (v88 == 5)
      {
        uint64_t v32 = *(void *)(v26 + 96);
        if (v32) {
          goto LABEL_143;
        }
      }
      if (v87)
      {
        if (v88 != 4)
        {
          if (v88 == 5)
          {
            uint64_t v32 = *(void *)(v26 + 96);
LABEL_143:
            uint64_t v343 = v67;
            unint64_t v350 = v62;
            LODWORD(v365) = 0;
            HIDWORD(v365) = v41 - v46;
            LODWORD(v366) = v362;
            HIDWORD(v366) = v46 - v44;
            if (v22) {
              long long v90 = (int *)&v365;
            }
            else {
              long long v90 = 0;
            }
            long long v91 = (int64x2_t *)img_blocks_create(*(void *)(v26 + 136), 0, v90, v32);
            if (!v91) {
              goto LABEL_592;
            }
            long long v93 = (uint64_t *)v91;
            uint64_t v87 = (unsigned int *)v91->i64[1];
            unsigned int v341 = a13;
            if (v87 || (uint64_t v87 = *(unsigned int **)(v26 + 112)) != 0)
            {
              int v94 = v358;
              unint64_t v95 = v360;
              unsigned int v96 = v355;
              if (v91[2].i64[1] == 1)
              {
                uint64_t v97 = *(void *)v91[5].i64[0];
                if (v97)
                {
                  int v98 = v46;
                  long long v99 = malloc_type_calloc(1uLL, 0x88uLL, 0x10F00409D9D9E87uLL);
                  long long v101 = v99;
                  if (v99)
                  {
                    *((_DWORD *)v99 + 22) = v353;
                    *((_DWORD *)v99 + 23) = v352;
                    *((_DWORD *)v99 + 24) = a12;
                    v99[14] = 0;
                    v99[15] = v93;
                    v99[13] = 0;
                    v99[10] = 0;
                    v99[2] = v93[2];
                    uint64_t v102 = v93[3];
                    v99[3] = v102;
                    *((_DWORD *)v99 + 8) = *((_DWORD *)v93 + 14);
                    int v103 = *((_DWORD *)v93 + 17);
                    *((_DWORD *)v99 + 9) = v102 - (*((_DWORD *)v93 + 15) + v103);
                    *((_DWORD *)v99 + 10) = *((_DWORD *)v93 + 16);
                    *((_DWORD *)v99 + 11) = v103;
                    uint64_t v104 = *(void *)v93[10];
                    v99[7] = v104;
                    int v105 = *(_DWORD *)v93[11];
                    *((_DWORD *)v99 + 12) = v105;
                    if (*(_DWORD *)(v26 + 24) && (unsigned int v106 = (*v87 >> 2) & 3, v106 >= 2))
                    {
                      double v107 = (unsigned int *)v363;
                      char v108 = v346;
                      if (v106 != 2) {
                        goto LABEL_282;
                      }
                      *long long v99 = *(void *)(*((void *)v87 + 1) + 8);
                      v99[8] = v104;
                    }
                    else
                    {
                      int v105 = 0;
                      *long long v99 = **((void **)v87 + 1);
                      v99[8] = 0;
                      double v107 = (unsigned int *)v363;
                      char v108 = v346;
                    }
                    goto LABEL_281;
                  }
                  CGImageBlockSetRelease(*v93);
                  free(v93);
LABEL_604:
                  img_release_resources(v26);
                  CGPostError((uint64_t)"%s: Cannot allocate memory", v327, v328, v329, v330, v331, v332, v333, v357);
                  return (uint64_t)v101;
                }
              }
              else
              {
                LOBYTE(v97) = 0;
              }
            }
            else
            {
              LOBYTE(v97) = 1;
              int v94 = v358;
              unsigned int v96 = v355;
            }
            long long v383 = 0u;
            long long v384 = 0u;
            long long v381 = 0u;
            long long v382 = 0u;
            long long v379 = 0u;
            long long v380 = 0u;
            long long v377 = 0u;
            long long v378 = 0u;
            memset(v376, 0, sizeof(v376));
            long long v374 = 0u;
            long long v375 = 0u;
            long long v372 = 0u;
            long long v373 = 0u;
            long long v370 = 0u;
            long long v371 = 0u;
            long long v368 = 0u;
            *(void *)&long long v369 = 0;
            *((void *)&v369 + 1) = img_decode_end;
            *(int32x2_t *)&long long v371 = vmovn_s64(v91[1]);
            uint64_t v174 = *(void *)(v26 + 16);
            if (v174) {
              int v175 = *(_DWORD *)(*(void *)(v174 + 24) + 48);
            }
            else {
              int v175 = 1;
            }
            *(void *)((char *)&v370 + 4) = __PAIR64__(*(void *)(v26 + 64), v175);
            HIDWORD(v370) = *(_DWORD *)(v26 + 24);
            if (v91[2].i64[1] != 1 || v91[3].i64[0] != 1 || (unint64_t v176 = img_raw_read, !*(void *)v91[5].i64[0])) {
              unint64_t v176 = img_blocks_read;
            }
            uint64_t v177 = *(void *)(v26 + 128);
            *(void *)&long long v369 = v176;
            *(void *)&long long v374 = v177;
            *((void *)&v375 + 1) = v91[1].i64[0];
            *(void *)&v376[0] = v175;
            __n128 v164 = (__n128)vextq_s8(*(int8x16_t *)(v26 + 136), *(int8x16_t *)(v26 + 136), 8uLL);
            *(__n128 *)((char *)v376 + 8) = v164;
            *((void *)&v376[1] + 1) = (char *)v91 + 56;
            *((void *)&v378 + 1) = v91;
            *((void *)&v374 + 1) = (unint64_t)(v91[1].i64[0] * *(void *)(v26 + 72) + 7) >> 3;
            if (v22)
            {
              __int32 v178 = v91[3].i32[3];
              __int32 v165 = v91[3].i32[2];
              __int32 v166 = v91[4].i32[0] + v165;
              int v46 = v94 - v178;
              unsigned int v96 = v94 - (v178 + v91[4].i32[1]);
            }
            else
            {
              __int32 v165 = 0;
              __int32 v166 = v362;
            }
            CGFloat v179 = (int *)v363;
            if (v97)
            {
              int v180 = v46;
              double v181 = &v368;
              __int32 v182 = v165;
              goto LABEL_422;
            }
LABEL_275:
            __int32 v344 = v165;
            unsigned int v183 = v166 - v165;
            int v180 = v46;
            int v184 = v46 - v96;
            double v181 = &v368;
            uint64_t v345 = (uint64_t)v87;
            goto LABEL_466;
          }
LABEL_157:
          int v98 = v46;
          float v109 = malloc_type_calloc(1uLL, 0x88uLL, 0x10F00409D9D9E87uLL);
          long long v101 = v109;
          if (!v109) {
            goto LABEL_604;
          }
          *((_DWORD *)v109 + 22) = v353;
          *((_DWORD *)v109 + 23) = v352;
          *((_DWORD *)v109 + 24) = a12;
          v109[14] = 0;
          v109[15] = 0;
          v109[13] = *(void *)(v26 + 40);
          v109[10] = 0;
          double v110 = *(int **)v26;
          v109[2] = *(void *)v26;
          uint64_t v111 = *(void *)(v26 + 8);
          v109[3] = v111;
          unsigned int v341 = a13;
          if (v39)
          {
            double v110 = *(int **)(v26 + 120);
            int v112 = *v110;
            int v141 = v110[1];
            uint32x2_t v142 = v110 + 2;
            LODWORD(v110) = v110[2];
            int v114 = v142[1];
            int v113 = v111 - (v141 + v114);
          }
          else
          {
            int v112 = 0;
            int v113 = 0;
            int v114 = v111;
          }
          double v107 = (unsigned int *)v363;
          char v108 = v346;
          *((_DWORD *)v109 + 8) = v112;
          *((_DWORD *)v109 + 9) = v113;
          *((_DWORD *)v109 + 10) = v110;
          *((_DWORD *)v109 + 11) = v114;
          v109[7] = **(void **)(v26 + 136);
          *((_DWORD *)v109 + 12) = **(_DWORD **)(v26 + 144);
          unint64_t v95 = v360;
          if (*(_DWORD *)(v26 + 24))
          {
            int v143 = (*v87 >> 2) & 3;
            if (v143 == 2)
            {
              *float v109 = *(void *)(*((void *)v87 + 1) + 8);
              v109[8] = **(void **)(v26 + 136);
              int v105 = **(_DWORD **)(v26 + 144);
              goto LABEL_281;
            }
            if (v143 == 1)
            {
              *float v109 = *(void *)(*((void *)v87 + 1) + 8);
              v109[8] = *(void *)(*(void *)(v26 + 136) + 8);
              int v105 = *(_DWORD *)(*(void *)(v26 + 144) + 4);
              goto LABEL_281;
            }
            if (v143)
            {
LABEL_282:
              v101[9] = 0;
              v101[1] = v87;
              if (!v107) {
                return (uint64_t)v101;
              }
              uint64_t v185 = v352;
              if ((v108 & 1) == 0) {
                return (uint64_t)v101;
              }
              goto LABEL_586;
            }
          }
          int v105 = 0;
          *float v109 = **((void **)v87 + 1);
          v109[8] = 0;
LABEL_281:
          *((_DWORD *)v101 + 13) = v105;
          goto LABEL_282;
        }
        unint64_t v350 = v62;
        double v130 = CGAccessSessionCreate(*(CGDataProvider **)(v26 + 136));
        if (!v130)
        {
          img_release_resources(v26);
          CGPostError((uint64_t)"%s: Cannot create session", v167, v168, v169, v170, v171, v172, v173, v357);
          return 0;
        }
        double v131 = v130;
        if ((v346 & 1) != 0 || (uint64_t v132 = v130[1]) == 0)
        {
          unsigned int v341 = a13;
          __n128 v164 = (__n128)img_stream_stage((uint64_t)&v368, v26, (uint64_t)v130);
          __int32 v165 = 0;
          __int32 v166 = v362;
          int v94 = v358;
          unsigned int v96 = v355;
          goto LABEL_275;
        }
        uint64_t v133 = malloc_type_calloc(1uLL, 0x88uLL, 0x10F00409D9D9E87uLL);
        long long v101 = v133;
        if (!v133)
        {
          CGAccessSessionRelease(v131);
          goto LABEL_604;
        }
        uint64_t v134 = *(void *)(v26 + 136);
        *((_DWORD *)v133 + 22) = v353;
        *((_DWORD *)v133 + 23) = v352;
        *((_DWORD *)v133 + 24) = a12;
        v133[15] = 0;
        v133[16] = v134;
        v133[13] = 0;
        v133[14] = v131;
        v133[10] = 0;
        unsigned int v135 = *(int **)v26;
        v133[2] = *(void *)v26;
        uint64_t v136 = *(void *)(v26 + 8);
        v133[3] = v136;
        if (v39)
        {
          unsigned int v135 = *(int **)(v26 + 120);
          int v137 = *v135;
          int v334 = v135[1];
          int v335 = v135 + 2;
          LODWORD(v135) = v135[2];
          int v139 = v335[1];
          int v138 = v136 - (v334 + v139);
        }
        else
        {
          int v137 = 0;
          int v138 = 0;
          int v139 = v136;
        }
        *((_DWORD *)v133 + 8) = v137;
        *((_DWORD *)v133 + 9) = v138;
        *((_DWORD *)v133 + 10) = v135;
        *((_DWORD *)v133 + 11) = v139;
        v133[7] = v132;
        int v336 = *(_DWORD *)(v26 + 144);
        *((_DWORD *)v133 + 12) = v336;
        if (*(_DWORD *)(v26 + 24) && (unsigned int v337 = (*v87 >> 2) & 3, v337 >= 2))
        {
          if (v337 != 2) {
            goto LABEL_610;
          }
          __int32 v338 = (void *)(*((void *)v87 + 1) + 8);
        }
        else
        {
          uint64_t v132 = 0;
          int v336 = 0;
          __int32 v338 = (void *)*((void *)v87 + 1);
        }
        *uint64_t v133 = *v338;
        v133[8] = v132;
        *((_DWORD *)v133 + 13) = v336;
LABEL_610:
        v133[9] = 0;
        v133[1] = v87;
        return (uint64_t)v101;
      }
    }
  }
  uint64_t v347 = v22;
  unint64_t v350 = v62;
  int v115 = v46;
  long long v368 = 0u;
  long long v369 = 0u;
  if (v62 <= 7 && (v39 & 0xC) == 0) {
    __int16 v117 = v39;
  }
  else {
    __int16 v117 = v39 | 0x100;
  }
  long long v370 = 0uLL;
  long long v371 = 0uLL;
  long long v372 = 0uLL;
  long long v373 = 0uLL;
  long long v374 = 0uLL;
  long long v375 = 0uLL;
  memset(v376, 0, sizeof(v376));
  long long v377 = 0uLL;
  long long v378 = 0uLL;
  long long v379 = 0uLL;
  long long v380 = 0uLL;
  long long v381 = 0uLL;
  long long v382 = 0uLL;
  long long v383 = 0uLL;
  long long v384 = 0uLL;
  LODWORD(v370) = 1024;
  *((void *)&v369 + 1) = img_decode_end;
  uint64_t v118 = 48;
  if (v89 >= 3) {
    uint64_t v118 = 0;
  }
  uint64_t v119 = 8;
  if (v89 < 3) {
    uint64_t v119 = 56;
  }
  uint64_t v120 = *(void *)(v26 + v118);
  uint64_t v121 = *(void *)(v26 + v119);
  *(void *)&long long v371 = __PAIR64__(v121, v120);
  uint64_t v122 = *(void *)(v26 + 16);
  if (v122) {
    uint64_t v123 = *(unsigned int *)(*(void *)(v122 + 24) + 48);
  }
  else {
    uint64_t v123 = 1;
  }
  *(void *)((char *)&v370 + 4) = v123;
  uint64_t v124 = *(void *)(v26 + 120);
  *(void *)&long long v374 = *(void *)(v26 + 128);
  *((void *)&v375 + 1) = (int)v120;
  int v125 = *(_DWORD *)(v26 + 24);
  HIDWORD(v370) = v125;
  __n128 v126 = *(__n128 *)(v26 + 136);
  *(int8x16_t *)((char *)v376 + 8) = vextq_s8((int8x16_t)v126, (int8x16_t)v126, 8uLL);
  *(void *)&v376[0] = (int)v123;
  *((void *)&v376[1] + 1) = v124;
  *(void *)&long long v380 = a12;
  if (v122)
  {
    int v127 = 0;
    uint64_t v128 = 0;
    switch(v125)
    {
      case 0:
      case 5:
      case 6:
      case 8:
      case 9:
        break;
      case 1:
        if ((v117 & 0x100) == 0) {
          goto LABEL_187;
        }
        int v129 = 8;
        goto LABEL_199;
      case 2:
        if ((v117 & 0x100) == 0) {
          goto LABEL_189;
        }
        int v140 = 8;
        goto LABEL_202;
      case 3:
        if ((v117 & 0x100) != 0)
        {
          int v129 = 9;
LABEL_199:
          HIDWORD(v370) = v129;
          uint64_t v128 = -1;
        }
        else
        {
LABEL_187:
          uint64_t v128 = 0;
        }
        uint64_t v123 = (v123 + 1);
        int v127 = 0x400000;
        break;
      case 4:
        if ((v117 & 0x100) != 0)
        {
          int v140 = 9;
LABEL_202:
          HIDWORD(v370) = v140;
          uint64_t v128 = -1;
        }
        else
        {
LABEL_189:
          uint64_t v128 = 0;
        }
        uint64_t v123 = (v123 + 1);
        int v127 = 0x200000;
        break;
      default:
        CGPostError((uint64_t)"%s: Assertion failed - unknown alpha", (uint64_t)v67, v31, v32, v33, v34, v35, v36, (char)"img_decode_stage");
        goto LABEL_217;
    }
  }
  else
  {
    int v127 = 0;
    uint64_t v128 = 0;
  }
  uint64_t v340 = (int)v41;
  if ((v88 - 1) < 2)
  {
    uint64_t v343 = v67;
    unint64_t v146 = *v87;
    unsigned int v147 = v146 >> 22;
    *((void *)&v374 + 1) = (uint64_t)(int)((v146 >> 22) * v120 + 7) >> 3;
    uint64_t v92 = (v146 >> 16) & 0x3F;
    if (v92 == 32)
    {
      if (v27 > 8)
      {
        if (v27 > 0x10)
        {
          unsigned int v148 = v127 | 0x80;
          LODWORD(v149) = 32;
        }
        else
        {
          unsigned int v148 = v127 | 0x82;
          uint64_t v128 = -1;
          LODWORD(v149) = 16;
        }
      }
      else
      {
        unsigned int v148 = v127 | 0x81;
        uint64_t v128 = -1;
        LODWORD(v149) = 8;
      }
    }
    else
    {
      BOOL v158 = v27 < 9 || v92 < 9;
      BOOL v159 = !v158;
      if (v158) {
        int v160 = 1;
      }
      else {
        int v160 = 2;
      }
      unsigned int v148 = v160 | v127;
      uint64_t v149 = 16;
      if (!v159) {
        uint64_t v149 = 8;
      }
      if (v149 != v92) {
        uint64_t v128 = -1;
      }
    }
    DWORD2(v370) = v149;
    if (v92 * v123 == v147)
    {
      uint64_t v161 = v128;
    }
    else
    {
      if (v128) {
        uint64_t v161 = v128;
      }
      else {
        uint64_t v161 = -1;
      }
      if ((v146 & 0xC0) != 0x80) {
        v148 |= 0x100000u;
      }
    }
    unsigned int v162 = (v146 >> 4) & 3;
    if (v162 == 2)
    {
      if (v92 == 32)
      {
        if (v161)
        {
          v148 |= 0x200u;
          LODWORD(v92) = 32;
          goto LABEL_382;
        }
        goto LABEL_278;
      }
      if (v92 == 16)
      {
        if (v161)
        {
          v148 |= 0x100u;
          LODWORD(v92) = 16;
          goto LABEL_382;
        }
        goto LABEL_278;
      }
    }
    else
    {
      if (v162 != 1)
      {
        if (v161) {
          goto LABEL_382;
        }
        if (v92 != 32)
        {
          if (v92 != 16) {
            goto LABEL_381;
          }
          uint64_t v161 = 0;
LABEL_278:
          *(void *)&long long v375 = v161;
          goto LABEL_381;
        }
LABEL_249:
        uint64_t v161 = 0x2000;
        goto LABEL_278;
      }
      if (v147 == 16)
      {
        double v163 = 0;
        v148 |= 0x100u;
        *(void *)&long long v375 = 4096;
        unsigned int v147 = 16;
LABEL_258:
        if (v161) {
          goto LABEL_375;
        }
        goto LABEL_381;
      }
      if (v147 == 32)
      {
        if (v161)
        {
          v148 |= 0x200u;
          unsigned int v147 = 32;
          goto LABEL_382;
        }
        goto LABEL_249;
      }
    }
    double v163 = 0;
    goto LABEL_258;
  }
  if (v89 < 2) {
    goto LABEL_293;
  }
  if (v88 != 5)
  {
LABEL_217:
    img_release_resources(v26);
    CGPostError((uint64_t)"%s: Cannot read image", v150, v151, v152, v153, v154, v155, v156, v357);
    return 0;
  }
  if ((v117 & 2) != 0
    && ((int)v362 < (unint64_t)v120 || (int)v41 < (unint64_t)v121)
    && v126.n128_u64[0]
    && *(unsigned char *)(v126.n128_u64[0] + 128))
  {
    int v144 = v67;
    double v387 = (double)(unint64_t)(int)v362;
    double v388 = (double)(unint64_t)(int)v41;
    unsigned int v145 = (__n128 *)img_blocks_create(v126.n128_i64[0], &v387, 0, 0);
    if (v145)
    {
      *((void *)&v378 + 1) = v145;
      *((void *)&v376[1] + 1) = (char *)v145 + 56;
      *((void *)&v375 + 1) = v145[1].n128_u64[0];
      __n128 v126 = v145[1];
      v126.n128_u64[0] = (unint64_t)vmovn_s64((int64x2_t)v126);
      *(void *)&long long v371 = v126.n128_u64[0];
      LODWORD(v120) = v126.n128_u32[0];
      long long v67 = v144;
      goto LABEL_293;
    }
    LODWORD(v120) = v371;
    long long v67 = v144;
  }
  *((void *)&v368 + 1) = img_blocks_extent;
LABEL_293:
  unsigned int v147 = *(_DWORD *)(v26 + 72);
  *((void *)&v374 + 1) = (uint64_t)(int)(v120 * v147 + 7) >> 3;
  double v186 = *(float64x2_t **)(v26 + 88);
  uint64_t v343 = v67;
  if (!v186)
  {
    double v190 = *(void **)(v26 + 16);
    if (v190)
    {
      double v191 = 0;
      goto LABEL_301;
    }
    v126.n128_u64[0] = 1065353216;
LABEL_310:
    *(void *)uint64_t v386 = v126.n128_u64[0];
    double v163 = v386;
    uint64_t v128 = -1;
    LODWORD(v41) = v358;
    goto LABEL_311;
  }
  if ((int)v123 >= 1)
  {
    uint64_t v187 = v123;
    CGFloat v188 = v386;
    do
    {
      float64x2_t v189 = *v186++;
      v126.n128_u64[1] = *(void *)&v189.f64[1];
      v126.n128_u64[0] = (unint64_t)vcvt_f32_f64(v189);
      *(void *)CGFloat v188 = v126.n128_u64[0];
      v188 += 2;
      --v187;
    }
    while (v187);
  }
  double v190 = *(void **)(v26 + 16);
  if (!v190)
  {
    v126.n128_u32[0] = v386[0];
    if (*(float *)v386 != 1.0 || *(float *)&v386[1] != 0.0)
    {
      LODWORD(v41) = v358;
      if (*(float *)v386 != 1.0 || *(float *)&v386[1] == 0.0)
      {
        *(void *)uint64_t v386 = __PAIR64__(v386[0], v386[1]);
        double v163 = v386;
        uint64_t v128 = -1;
      }
      else
      {
        double v163 = v386;
      }
      goto LABEL_311;
    }
    v126.n128_u64[0] = 0x3F80000000000000;
    goto LABEL_310;
  }
  double v191 = v386;
LABEL_301:
  if ((CGColorSpaceGetType(v190) & 0xFFFFFFFD) == 5) {
    v127 |= 0x400u;
  }
  if (v191) {
    uint64_t v128 = -1;
  }
  LODWORD(v41) = v358;
  double v163 = v191;
LABEL_311:
  uint64_t v92 = *(void *)(v26 + 64);
  int v192 = *(_DWORD *)(v26 + 80);
  if ((v192 & 0x100) != 0 && v92 == 32)
  {
    if (v27 <= 8)
    {
      unsigned int v148 = v127 | 0x81;
      uint64_t v128 = -1;
      LODWORD(v193) = 8;
      goto LABEL_336;
    }
    if (v27 <= 0x10)
    {
      unsigned int v148 = v127 | 0x82;
      uint64_t v128 = -1;
      goto LABEL_320;
    }
    unsigned int v148 = v127 | 0x80;
    LODWORD(v193) = 32;
  }
  else
  {
    if ((v192 & 0x100) != 0 && v92 == 16)
    {
      unsigned int v148 = v127 | 4;
LABEL_320:
      LODWORD(v193) = 16;
      goto LABEL_336;
    }
    BOOL v195 = v27 < 9 || (int)v92 < 9;
    BOOL v196 = !v195;
    if (v195) {
      int v197 = 1;
    }
    else {
      int v197 = 2;
    }
    unsigned int v148 = v197 | v127;
    uint64_t v193 = 16;
    if (!v196) {
      uint64_t v193 = 8;
    }
    if (v193 != (int)v92) {
      uint64_t v128 = -1;
    }
  }
LABEL_336:
  DWORD2(v370) = v193;
  if (v123 * v92 != v147)
  {
    if (!v128) {
      uint64_t v128 = -1;
    }
    if ((v192 & 0x1Fu) <= 6 && ((1 << (v192 & 0x1F)) & 0x54) != 0) {
      v148 |= 0x100000u;
    }
  }
  switch(((v192 & 0x7000u) - 4096) >> 12)
  {
    case 0u:
      v148 |= v192 & 0x100 ^ 0x100;
      if (v128) {
        goto LABEL_358;
      }
      if (v92 == 8) {
        goto LABEL_369;
      }
      if (v92 != 16) {
        goto LABEL_371;
      }
      unint64_t v198 = 0;
      goto LABEL_370;
    case 1u:
      v148 |= 0x200u;
      if (v128) {
        goto LABEL_358;
      }
      unint64_t v198 = (unint64_t)(v92 == 8) << 13;
      if (v92 != 8 && v92 != 32) {
        goto LABEL_371;
      }
      goto LABEL_370;
    case 2u:
      if (v128) {
        goto LABEL_358;
      }
      if (v92 == 16)
      {
LABEL_369:
        unint64_t v198 = 4096;
        goto LABEL_370;
      }
LABEL_371:
      uint64_t v199 = -1;
      break;
    case 3u:
      if (v128) {
        uint64_t v199 = v128;
      }
      else {
        uint64_t v199 = -1;
      }
      if (v128 || v92 != 32) {
        break;
      }
      unint64_t v198 = 0x2000;
      goto LABEL_370;
    default:
      if (v128)
      {
LABEL_358:
        uint64_t v199 = v128;
      }
      else
      {
        unint64_t v198 = 4096;
        if (v92 != 16) {
          unint64_t v198 = 0x2000;
        }
        if (v92 == 32 || v92 == 16)
        {
LABEL_370:
          uint64_t v199 = 0;
          *(void *)&long long v375 = v198;
        }
        else
        {
          uint64_t v199 = 0;
        }
      }
      break;
  }
  if (*((uint64_t *)&v376[0] + 1) >= 1
    && *((uint64_t *)&v376[0] + 1) <= (uint64_t)((*((void *)&v374 + 1) + 63) & 0xFFFFFFFFFFFFFFBFLL))
  {
    DWORD2(v371) = DWORD2(v376[0]);
    if (v199)
    {
LABEL_375:
      if (v163)
      {
        CGFloat v200 = v163;
        switch(HIDWORD(v370))
        {
          case 1:
            HIDWORD(v370) = 3;
            *(void *)&long long v369 = img_decode_read_alpha;
            *(void *)&long long v377 = decode_create(v123, v92, v147, 0, v148, v126);
            int v202 = 4195463;
            goto LABEL_386;
          case 8:
            HIDWORD(v370) = 9;
            *(void *)&long long v369 = img_decode_read_alpha;
            *(void *)&long long v377 = decode_create(v123, v92, v147, 0, v148, v126);
            int v210 = v148 & 0x487;
            if (DWORD2(v370) == 16) {
              int v210 = v148 & 0x487 | 0x100;
            }
            if (DWORD2(v370) == 32) {
              int v211 = v148 & 0x487 | 0x200;
            }
            else {
              int v211 = v210;
            }
            *((void *)&v377 + 1) = decode_create(DWORD1(v370), SDWORD2(v370), DWORD1(v370) * DWORD2(v370), (uint64_t)&v200[(v148 >> 20) & 2], v211, v209);
            *(void *)&long long v378 = decode_create(1, SDWORD2(v370), SDWORD2(v370), (uint64_t)&v200[((int)(v148 << 9) >> 31) & (2 * DWORD1(v370))], v211, v212);
            goto LABEL_384;
          case 2:
            HIDWORD(v370) = 4;
            *(void *)&long long v369 = img_decode_read_alpha;
            *(void *)&long long v377 = decode_create(v123, v92, v147, 0, v148, v126);
            int v202 = 2098311;
LABEL_386:
            int v207 = v148 & v202;
            if (DWORD2(v370) == 32)
            {
              v207 |= 0x200u;
              int v203 = v352;
              uint64_t v208 = (uint64_t)v200;
            }
            else
            {
              int v203 = v352;
              uint64_t v208 = (uint64_t)v200;
              if (DWORD2(v370) == 16) {
                v207 |= 0x100u;
              }
            }
            *((void *)&v377 + 1) = decode_create(v123, SDWORD2(v370), DWORD2(v370) * (int)v123, v208, v207, v201);
            goto LABEL_398;
        }
        *(void *)&long long v369 = img_decode_read;
        uint64_t v204 = v123;
        int v205 = v147;
        uint64_t v206 = (uint64_t)v163;
LABEL_383:
        *(void *)&long long v377 = decode_create(v204, v92, v205, v206, v148, v126);
LABEL_384:
        int v203 = v352;
LABEL_398:
        LODWORD(v41) = v358;
        goto LABEL_399;
      }
LABEL_382:
      *(void *)&long long v369 = img_decode_read;
      uint64_t v204 = v123;
      int v205 = v147;
      uint64_t v206 = 0;
      goto LABEL_383;
    }
  }
  else
  {
    DWORD2(v371) = DWORD2(v374);
    if (v199) {
      goto LABEL_375;
    }
  }
LABEL_381:
  *(void *)&long long v369 = img_raw_read;
  int v203 = v352;
LABEL_399:
  if ((v117 & 0x28) == 0x28) {
    goto LABEL_613;
  }
  double v181 = &v368;
  if ((v117 & 0x80) != 0)
  {
    double v181 = (long long *)img_interpolate_stage((uint64_t)&v385, (uint64_t)&v368, v26, 1, *(void *)v26, *(void *)(v26 + 8), a12, a14);
    LODWORD(v41) = v358;
  }
  if ((v117 & 0x10) != 0) {
    _CGHandleAssert("img_colormask_stage", 2270, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "", "Unimplemented", v34, v35, v36, v339);
  }
  if ((v117 & 0x28) == 8) {
LABEL_613:
  }
    _CGHandleAssert("img_colorindex_stage", 2380, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "", "Unimplemented", v34, v35, v36, v339);
  CGFloat v179 = (int *)v363;
  unsigned int v341 = a13;
  if ((v117 & 2) != 0)
  {
    uint64_t v214 = img_interpolate_stage((uint64_t)(v181 + 18), (uint64_t)v181, v26, v203, (int)v362, v340, a12, a14);
    if ((long long *)v214 == v181)
    {
      LOBYTE(v117) = v117 & 0xFD;
      unsigned int v96 = v355;
      __int32 v166 = *((_DWORD *)v181 + 12);
      int v213 = *((_DWORD *)v181 + 13);
      if (v115 - v355 == v358)
      {
        int v115 = *((_DWORD *)v181 + 13);
      }
      else
      {
        double v231 = (double)v213 / (double)v358;
        signed int v232 = vcvtpd_s64_f64(v231 * (double)v115);
        unsigned int v96 = vcvtmd_s64_f64(v231 * (double)v355);
        if (v213 >= v232) {
          int v115 = v232;
        }
        else {
          int v115 = *((_DWORD *)v181 + 13);
        }
      }
      goto LABEL_409;
    }
    __int32 v166 = v362;
    int v213 = v358;
    double v181 = (long long *)v214;
  }
  else
  {
    __int32 v166 = v362;
    int v213 = v41;
  }
  unsigned int v96 = v355;
LABEL_409:
  if ((v117 & 4) != 0) {
    _CGHandleAssert("img_colormatch_stage", 2796, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "", "Unimplemented", v34, v35, v36, v339);
  }
  if (v347)
  {
    if (*(void *)(v26 + 120))
    {
      int v180 = v115;
      __int32 v182 = 0;
    }
    else
    {
      __int32 v182 = 0;
      unsigned int v215 = (v213 - v115) & 0xFFFFFFF0;
      int v216 = v213 - v96 + 15;
      if ((v216 | 0xF) >= v213) {
        unsigned int v217 = v213;
      }
      else {
        unsigned int v217 = v216 & 0xFFFFFFF0;
      }
      int v218 = v217 - v215 + 32;
      unsigned int v219 = v213 - v217;
      if (v218 < v213)
      {
        unsigned int v96 = v219;
      }
      else
      {
        unsigned int v215 = 0;
        unsigned int v96 = 0;
      }
      int v180 = v213 - v215;
    }
    int v94 = v213;
    LODWORD(v362) = v166;
  }
  else
  {
    __int32 v182 = 0;
    int v94 = v213;
    LODWORD(v362) = v166;
    int v180 = v115;
  }
LABEL_422:
  int v220 = v94;
  unsigned int v221 = v96;
  unint64_t v222 = v350;
  if (!v350) {
    goto LABEL_454;
  }
  int v223 = *((_DWORD *)v181 + 10);
  if (v223 >= 9)
  {
    if (v350 == 4)
    {
      unint64_t v222 = 3;
    }
    else if (v350 == 2)
    {
      unint64_t v222 = 1;
    }
  }
  uint64_t v224 = *((unsigned int *)v181 + 11);
  if (v222 == v224) {
    goto LABEL_454;
  }
  *(long long *)((char *)v181 + 296) = 0u;
  *((void *)v181 + 71) = 0;
  *(long long *)((char *)v181 + 536) = 0u;
  *(long long *)((char *)v181 + 520) = 0u;
  *(long long *)((char *)v181 + 504) = 0u;
  *(long long *)((char *)v181 + 488) = 0u;
  *(long long *)((char *)v181 + 472) = 0u;
  *(long long *)((char *)v181 + 456) = 0u;
  *(long long *)((char *)v181 + 440) = 0u;
  *(long long *)((char *)v181 + 424) = 0u;
  *(long long *)((char *)v181 + 408) = 0u;
  *(long long *)((char *)v181 + 392) = 0u;
  *(long long *)((char *)v181 + 376) = 0u;
  *(long long *)((char *)v181 + 360) = 0u;
  *(long long *)((char *)v181 + 344) = 0u;
  *(long long *)((char *)v181 + 328) = 0u;
  *(long long *)((char *)v181 + 312) = 0u;
  *(long long *)((char *)v181 + 552) = 0u;
  *((void *)v181 + 36) = v181;
  if (*((void *)v181 + 1)) {
    *((void *)v181 + 37) = img_extent;
  }
  *((void *)v181 + 38) = img_alphamerge_read;
  *((void *)v181 + 39) = img_alphamerge_end;
  *((_DWORD *)v181 + 80) = 512;
  uint64_t v225 = *((void *)v181 + 6);
  *((void *)v181 + 42) = v225;
  int v226 = *((_DWORD *)v181 + 9);
  *((_DWORD *)v181 + 81) = v226;
  *((_DWORD *)v181 + 82) = v223;
  *((_DWORD *)v181 + 83) = v222;
  unint64_t v227 = v222;
  if (v224 > 9)
  {
LABEL_450:
    CGPostError((uint64_t)"%s: Assertion failed - unknown source alpha", v92, v31, v32, v33, v34, v35, v36, (char)"img_alphamerge_stage");
LABEL_453:
    unint64_t v222 = v227;
    goto LABEL_454;
  }
  int v228 = 1;
  if (((1 << v224) & 0x1E) != 0) {
    goto LABEL_437;
  }
  int v229 = 1 << v224;
  if ((v229 & 0x301) == 0)
  {
    if ((v229 & 0x60) != 0) {
      goto LABEL_454;
    }
    goto LABEL_450;
  }
  int v228 = 0;
LABEL_437:
  if (v222 > 9)
  {
LABEL_452:
    CGPostError((uint64_t)"%s: Assertion failed - unknown destination alpha", v92, v31, v32, v33, v34, v35, v36, (char)"img_alphamerge_stage");
    goto LABEL_453;
  }
  if (((1 << v222) & 0x1E) == 0)
  {
    if (((1 << v222) & 0x301) != 0)
    {
      if (v228)
      {
        *((void *)v181 + 47) = 1;
        *((_DWORD *)v181 + 86) = (v225 + v225 * v226) * (v223 / 8);
        goto LABEL_445;
      }
LABEL_444:
      *((void *)v181 + 47) = 0;
      goto LABEL_445;
    }
    goto LABEL_452;
  }
  if (v228) {
    goto LABEL_444;
  }
  *((void *)v181 + 47) = 2;
  int v230 = v223 / 8;
  *((_DWORD *)v181 + 86) = v226 * v225 * v230;
  *((_DWORD *)v181 + 87) = v230 * v225;
LABEL_445:
  *((void *)v181 + 50) = a12;
  v181 += 18;
LABEL_454:
  unint64_t v350 = v222;
  if (v179)
  {
    int v233 = *v179;
    Componentunsigned int Type = CGImageGetComponentType(*(void *)(v26 + 40));
    BOOL v240 = v233 == 34082816;
    if (v233 == 34082816) {
      int v241 = ComponentType;
    }
    else {
      int v241 = a12;
    }
    if (v233 == 34082816 && v241 == 5)
    {
      int v241 = 5;
      *((void *)v181 + 14) = 5;
      BOOL v240 = 1;
    }
  }
  else
  {
    CGImageGetComponentType(*(void *)(v26 + 40));
    BOOL v240 = 0;
    int v241 = a12;
  }
  if (v343)
  {
    uint64_t v345 = img_data_depth(v181, v241, v240, v235, v236, v237, v238, v239);
    if (!v345)
    {
      (*((void (**)(long long *))v181 + 3))(v181);
      img_release_resources(v26);
      CGPostError((uint64_t)"%s: Cannot process image", v276, v277, v278, v279, v280, v281, v282, v357);
      return 0;
    }
  }
  __int32 v344 = v182;
  unsigned int v183 = v166 - v182;
  unsigned int v96 = v221;
  int v184 = v180 - v221;
  if (!v181)
  {
    int v244 = 0;
    int v243 = 0;
    unsigned int v242 = 0;
    char v248 = 1;
    int v94 = v220;
    goto LABEL_475;
  }
  int v94 = v220;
LABEL_466:
  unsigned int v242 = 0;
  int v243 = 0;
  int v244 = 0;
  uint64_t v245 = v181;
  do
  {
    int v246 = *((_DWORD *)v245 + 14);
    if (v246)
    {
      v243 += v246;
      ++v244;
      v242 |= *((_DWORD *)v245 + 8);
    }
    int v247 = *((_DWORD *)v245 + 15);
    if (v247)
    {
      v243 += v247;
      ++v244;
      v242 |= *((_DWORD *)v245 + 8);
    }
    uint64_t v245 = *(long long **)v245;
  }
  while (v245 && (v243 & 0x80000000) == 0);
  char v248 = 0;
LABEL_475:
  unsigned int v356 = v96;
  unsigned int v249 = v183;
  int v359 = v94;
  if (*(void *)(v26 + 128))
  {
    uint64_t v250 = 0;
LABEL_477:
    int v251 = 0;
    goto LABEL_478;
  }
  uint64_t v250 = *(void *)(v26 + 136);
  if (!v250) {
    goto LABEL_477;
  }
  uint64_t v255 = *(uint64_t (**)(void, __n128))(v250 + 168);
  if (!v255) {
    goto LABEL_477;
  }
  int v251 = v255(*(void *)(v250 + 24), v164);
LABEL_478:
  int v348 = v180;
  unint64_t v252 = (v243 + v251);
  if ((int)v252 < 1)
  {
    LODWORD(v254) = 1;
    if ((v252 & 0x80000000) != 0)
    {
LABEL_562:
      (*((void (**)(long long *, __n128))v181 + 3))(v181, v164);
      img_release_resources(v26);
      CGPostError((uint64_t)"%s: Cannot allocate memory", v305, v306, v307, v308, v309, v310, v311, v357);
      return 0;
    }
  }
  else
  {
    int v253 = 16 * v244 + 16;
    unint64_t v254 = (4096 - v253) / v252;
    if (!v254)
    {
      LODWORD(v252) = v252 + v253;
      if ((v252 & 0x80000000) != 0) {
        goto LABEL_562;
      }
    }
  }
  if (v254) {
    uint64_t v256 = 0;
  }
  else {
    uint64_t v256 = v252;
  }
  unsigned int v257 = malloc_type_calloc(1uLL, v256 + 136, 0x4BC742A8uLL);
  if (!v257) {
    goto LABEL_562;
  }
  long long v101 = v257;
  v257[22] = v353;
  v257[23] = v352;
  v257[24] = a12;
  if (v252)
  {
    int v261 = v254 <= 1 ? 1 : v254;
    if ((v248 & 1) == 0)
    {
      uint64_t v262 = v257 + 34;
      if (v254) {
        uint64_t v262 = v386;
      }
      unint64_t v263 = ((unint64_t)v262 + 15) & 0xFFFFFFFFFFFFFFF0;
      float v264 = v181;
      do
      {
        int v265 = *((_DWORD *)v264 + 14);
        if (v265)
        {
          *((_DWORD *)v264 + 16) = v261;
          *((void *)v264 + 9) = v263;
          v263 += (v265 * (uint64_t)v261 + 15) & 0xFFFFFFFFFFFFFFF0;
        }
        int v266 = *((_DWORD *)v264 + 15);
        if (v266)
        {
          *((_DWORD *)v264 + 16) = v261;
          *((void *)v264 + 10) = v263;
          v263 += (v266 * (uint64_t)v261 + 15) & 0xFFFFFFFFFFFFFFF0;
        }
        float v264 = *(long long **)v264;
      }
      while (v264);
    }
  }
  unsigned int v267 = *(_DWORD *)v345;
  unsigned int v268 = (((*(_DWORD *)v345 >> 22) * v249) >> 3) + 15;
  int v269 = v268 & 0x3FFFFFF0;
  if (v350)
  {
    int v270 = (v267 >> 2) & 3;
    unsigned int v271 = ((((((BYTE2(v267) & 0x3F) + 7) & 0x78) * v249) >> 3) + 15) & 0x3FFFFFF0;
    unsigned int v272 = v271 + v269;
    if (v270 != 1)
    {
      unsigned int v271 = 0;
      unsigned int v272 = v269;
    }
    if (v270 == 2) {
      unsigned int v271 = v269;
    }
    unsigned int v354 = v271;
    BOOL v273 = v270 != 2 && v270 == 1;
    BOOL v361 = v273;
    BOOL v274 = v270 != 2 && v270 != 1;
    int v351 = v274;
    if (v270 == 2) {
      unsigned int v275 = v269;
    }
    else {
      unsigned int v275 = v272;
    }
  }
  else
  {
    unsigned int v354 = 0;
    BOOL v361 = 0;
    int v351 = 1;
    unsigned int v275 = v268 & 0x3FFFFFF0;
  }
  uint64_t v283 = 0;
  if (v242 && *MEMORY[0x1E4F1CBC0])
  {
    unsigned int v284 = "";
    unsigned int v285 = "DECODE";
    if ((v242 & 0x400) == 0) {
      unsigned int v285 = "";
    }
    __int16 v286 = "|";
    if ((((v242 & 0x3FF) != 0) & (v242 >> 10)) != 0) {
      __int16 v287 = "|";
    }
    else {
      __int16 v287 = "";
    }
    uint64_t v288 = "ALPHAM";
    if ((v242 & 0x200) == 0) {
      uint64_t v288 = "";
    }
    if ((((v242 & 0x1FF) != 0) & (v242 >> 9)) != 0) {
      float v289 = "|";
    }
    else {
      float v289 = "";
    }
    uint64_t v290 = "ALPHA";
    if ((v242 & 0x100) == 0) {
      uint64_t v290 = "";
    }
    if (((v242 != 0) & (v242 >> 8)) != 0) {
      uint64_t v291 = "|";
    }
    else {
      uint64_t v291 = "";
    }
    double v292 = "COLORMASK";
    if ((v242 & 0x10) == 0) {
      double v292 = "";
    }
    if ((((v242 & 0xF) != 0) & (v242 >> 4)) != 0) {
      int v293 = "|";
    }
    else {
      int v293 = "";
    }
    __n128 v294 = "COLORINDEX";
    if ((v242 & 8) == 0) {
      __n128 v294 = "";
    }
    if ((((v242 & 7) != 0) & (v242 >> 3)) != 0) {
      uint64_t v295 = "|";
    }
    else {
      uint64_t v295 = "";
    }
    unint64_t v296 = "COLORSPACE";
    if ((v242 & 4) == 0) {
      unint64_t v296 = "";
    }
    if ((((v242 & 3) != 0) & (v242 >> 2)) == 0) {
      __int16 v286 = "";
    }
    if ((v242 & 2) != 0) {
      unsigned int v284 = "INTERP";
    }
    uint64_t v283 = __str;
    snprintf(__str, 0x100uLL, "CGSImageData (%s%s%s%s%s%s%s%s%s%s%s%s%s)", v285, v287, v288, v289, v290, v291, v292, v293, v294, v295, v296, v286, v284);
  }
  if (v250)
  {
    uint64_t v297 = *(uint64_t (**)(void))(v250 + 168);
    uint64_t v185 = v352;
    if (v297) {
      uint64_t v298 = v297(*(void *)(v250 + 24));
    }
    else {
      uint64_t v298 = 0;
    }
  }
  else
  {
    uint64_t v298 = 0;
    uint64_t v185 = v352;
  }
  image_data_handle = create_image_data_handle(v275, v184, v298 + 15, v341, (uint64_t)v283, v258, v259, v260);
  v101[9] = image_data_handle;
  if (!image_data_handle)
  {
    free(v101);
    goto LABEL_562;
  }
  *((_DWORD *)v101 + 12) = v269;
  v101[10] = 0;
  uint64_t v300 = image_data_handle[2];
  v101[7] = v300;
  if (v361)
  {
    v101[8] = v300 + v269 * v184;
    unsigned int v301 = v356;
    *((_DWORD *)v101 + 13) = v354;
    uint64_t v302 = v345;
    uint64_t v303 = (void *)(*(void *)(v345 + 8) + 8);
    int v304 = v359;
  }
  else
  {
    int v304 = v359;
    unsigned int v301 = v356;
    if (v351)
    {
      v101[8] = 0;
      *((_DWORD *)v101 + 13) = 0;
      uint64_t v302 = v345;
      uint64_t v303 = *(void **)(v345 + 8);
    }
    else
    {
      v101[8] = v300;
      *((_DWORD *)v101 + 13) = v354;
      uint64_t v302 = v345;
      uint64_t v303 = (void *)(*(void *)(v345 + 8) + 8);
    }
  }
  void *v101 = *v303;
  v101[1] = v302;
  v101[2] = (int)v362;
  v101[3] = v304;
  *((_DWORD *)v101 + 8) = v344;
  *((_DWORD *)v101 + 9) = v301;
  *((_DWORD *)v101 + 10) = v249;
  *((_DWORD *)v101 + 11) = v184;
  int v312 = v304 - v348;
  double v313 = (uint64_t (*)(void, void))*((void *)v181 + 1);
  if (v313)
  {
    LODWORD(v365) = v344;
    HIDWORD(v365) = v304 - v348;
    unint64_t v366 = __PAIR64__(v184, v249);
    if ((v313(v181, &v365) & 0x80000000) != 0)
    {
      CGSImageDataHandleRelease(v101[9]);
      free(v101);
      (*((void (**)(long long *))v181 + 3))(v181);
LABEL_592:
      img_release_resources(v26);
      return 0;
    }
  }
  if (v184 >= 1
    && *((_DWORD *)v101 + 12) <= (signed int)(0x7FFFFFFFu / v184)
    && *((_DWORD *)v101 + 13) <= (signed int)(0x7FFFFFFFu / v184))
  {
    int v323 = 0;
    do
    {
      int v314 = v323;
      uint64_t v324 = (v184 - v323);
      if (v184 <= v323) {
        break;
      }
      double v325 = *((double *)v101 + 8);
      *(void *)&double v387 = v101[7] + *((int *)v101 + 12) * (uint64_t)v314;
      if (v325 != 0.0) {
        *(void *)&v325 += *((int *)v101 + 13) * (uint64_t)v314;
      }
      double v388 = v325;
      int v326 = (*((uint64_t (**)(long long *, void, uint64_t, double *, void *, void))v181 + 2))(v181, (v314 + v312), v324, &v387, v101 + 6, a14);
      int v323 = v326 + v314;
    }
    while (v326 > 0);
  }
  else
  {
    int v314 = 0;
  }
  if (v363)
  {
    if ((*(unsigned char *)(v363 + 1) & 0xF) == 0)
    {
      uint64_t v315 = v101[1];
      if (!v315 || (*(unsigned char *)(v315 + 1) & 0xF) != 0)
      {
        if (CGImageGetComponentType(*(void *)(v26 + 40)) == 5) {
          int v321 = 5;
        }
        else {
          int v321 = 1;
        }
        v101[1] = img_data_depth(v181, v321, 1, v316, v317, v318, v319, v320);
      }
    }
  }
  (*((void (**)(long long *))v181 + 3))(v181);
  img_release_resources(v26);
  v101[13] = 0;
  v101[14] = 0;
  v101[15] = 0;
  int v98 = v184 - v314;
  if (v184 <= v314)
  {
    int v98 = 0;
  }
  else
  {
    if (v184 != *((_DWORD *)v101 + 11))
    {
      *((_DWORD *)v101 + 11) = 0;
LABEL_596:
      CGSImageDataHandleRelease(v101[9]);
      free(v101);
      return 0;
    }
    *((_DWORD *)v101 + 9) += v98;
    *((_DWORD *)v101 + 11) = v314;
    if (!v314) {
      goto LABEL_596;
    }
  }
  unint64_t v95 = v360;
  double v107 = (unsigned int *)v363;
  if (!v363) {
    return (uint64_t)v101;
  }
LABEL_586:
  if (*v107 != 134886228 && ((unsigned int *)v101[1] != v107 || v101[2] != v95 || v101[3] != v364)) {
    return img_data_lock_depth((uint64_t)v101, v95, v364, v98, v107, v185, v341, v100);
  }
  return (uint64_t)v101;
}

void *CGImageGetMaskingColors(void *result)
{
  if (result)
  {
    int v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (void *)v1[21];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t img_raw_read(uint64_t a1, unsigned int a2, uint64_t a3, char **a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  if ((a2 & 0x80000000) != 0) {
    return result;
  }
  uint64_t v10 = a3;
  if ((int)a3 < 1) {
    return result;
  }
  uint64_t v14 = *(void *)(a1 + 96);
  uint64_t v15 = *(void **)(a1 + 144);
  long long v16 = *(int **)(a1 + 152);
  if (v14 == -1)
  {
    uint64_t v28 = *(void **)(a1 + 184);
    if (!v28)
    {
      BOOL v29 = img_blocks_create(*(void *)(a1 + 144), 0, *(int **)(a1 + 152), 0);
      if (!v29) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v28 = v29;
      *(void *)(a1 + 184) = v29;
      *(void *)(a1 + 88) = 0;
    }
    int v30 = v10 + a2;
    int v31 = *((_DWORD *)v28 + 15);
    int v32 = *((_DWORD *)v28 + 17) + v31;
    if (v31 >= (int)(v10 + a2) || v32 <= (int)a2) {
      return 0;
    }
    BOOL v34 = __OFSUB__(v32, v30);
    int v35 = v32 - v30;
    if (v35 < 0 != v34)
    {
      uint64_t v10 = (v35 + v10);
      if ((int)v10 < 1) {
        return 0;
      }
    }
    *(void *)(a1 + 88) = a2;
    int v138 = 0;
    unsigned int v139 = a2;
    int v140 = *(void *)(a1 + 120);
    int v141 = v10;
    if (*((int *)v28 + 10) >= 1)
    {
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      while (1)
      {
        uint64_t v136 = 0;
        *(void *)int v137 = 0;
        long long v135 = 0uLL;
        long long v135 = *(_OWORD *)(v28[9] + v36);
        if (CGSBoundsIntersection(&v138, (int *)&v135, &v136))
        {
          uint64_t v38 = SHIDWORD(v136) - (uint64_t)(int)v139;
          uint64_t v39 = *a5;
          uint64_t v40 = v38 * v39;
          if (v38 * v39 != v38 * v39) {
            return 0;
          }
          if ((v40 & 0x80000000) != 0) {
            return 0;
          }
          uint64_t v41 = v28[4];
          if (v41 != (int)v41) {
            return 0;
          }
          uint64_t v42 = v41 * ((int)v136 - (uint64_t)v138);
          if ((unint64_t)(v42 - 0x80000000) < 0xFFFFFFFF00000000) {
            return 0;
          }
          uint64_t v43 = v41 * v137[0];
          if (v43 != (int)v43) {
            return 0;
          }
          uint64_t v44 = *(void *)(v28[10] + 8 * v37);
          int v45 = &(*a4)[v40 + v42];
          if (v44)
          {
            uint64_t v46 = *(void *)(v28[11] + 8 * v37);
            uint64_t v47 = v46 * (SHIDWORD(v136) - (uint64_t)SDWORD1(v135));
            if (v47 != (int)v47 || (unint64_t)(v46 - 0x80000000) < 0xFFFFFFFF00000000) {
              return 0;
            }
            if ((v47 & 0x80000000) != 0) {
              return 0;
            }
            uint64_t v49 = v41 * ((int)v136 - (uint64_t)(int)v135);
            if (v49 != (int)v49 || (v49 & 0x80000000) != 0) {
              return 0;
            }
            uint64_t v50 = (void *)(v44 + v47 + v49);
            int v51 = *(_DWORD *)(a1 + 112);
            if (v51)
            {
              CGBlt_swapBytes(v43, v137[1], v50, v45, v46, v39, v51);
            }
            else if (v28[6] == v28[5] && v46 == v39)
            {
              if (v46 * v137[1] != v46 * v137[1]) {
                return 0;
              }
              memcpy(v45, v50, v46 * v137[1]);
            }
            else
            {
              CGBlt_copyBytes(v43, v137[1], (char *)v50, v45, v46, v39);
            }
          }
          else
          {
            CGBlt_fillBytes(v43, v137[1], 0, v45, *a5);
          }
        }
        ++v37;
        v36 += 16;
        if (v37 >= *((int *)v28 + 10)) {
          goto LABEL_185;
        }
      }
    }
    goto LABEL_185;
  }
  if (v14)
  {
    if (v16)
    {
      double v131 = *(void **)(a1 + 144);
      uint64_t v52 = *(void *)(a1 + 128);
      unsigned int v53 = *(int **)(a1 + 136);
      int v54 = *(_DWORD *)(a1 + 40);
      if (v54 >= 0) {
        int v55 = *(_DWORD *)(a1 + 40);
      }
      else {
        int v55 = v54 + 7;
      }
      int v56 = a3 + a2;
      int v57 = v16[1];
      int v58 = v16[3] + v57;
      *(void *)(a1 + 88) = a2;
      if (v58 <= (int)a2 || v56 <= v57)
      {
        int v57 = 0;
        int v56 = 0;
        unsigned int v133 = 0;
        unsigned int v60 = 0;
      }
      else
      {
        if (v58 < v56) {
          int v56 = v58;
        }
        unsigned int v87 = a2 - v57;
        unsigned int v89 = v57 - a2;
        BOOL v88 = v57 <= (int)a2;
        if (v57 <= (int)a2)
        {
          int v57 = a2;
          unsigned int v89 = 0;
        }
        unsigned int v133 = v89;
        if (v88) {
          unsigned int v60 = v87;
        }
        else {
          unsigned int v60 = 0;
        }
      }
      int v132 = v52;
      BOOL v90 = v14 == 2 && a4[1] && (*(_DWORD *)(a1 + 44) & 0xFFFFFFFE) == 8;
      uint64_t v91 = (v56 - v57);
      if (v91 != a3 || *(void *)(a1 + 120) != v16[2])
      {
        int v92 = v55;
        unsigned int v93 = v60;
        uint64_t v94 = (v56 - v57);
        if (v90) {
          CGBlt_fillBytes(a5[1], a3, 0, a4[1], a5[1]);
        }
        CGBlt_fillBytes(*a5, v10, 0, *a4, *a5);
        uint64_t v91 = v94;
        unsigned int v60 = v93;
        int v55 = v92;
      }
      int v95 = v55 >> 3;
      int v96 = *(_DWORD *)(a1 + 112);
      if (v90)
      {
        int v97 = v53[1];
        uint64_t v98 = v97 * (uint64_t)(int)v60;
        if (v98 != (int)v98) {
          return 0;
        }
        if ((v98 & 0x80000000) != 0) {
          return 0;
        }
        int v99 = a5[1];
        uint64_t v100 = v99 * (uint64_t)(int)v133;
        if (v100 != (int)v100) {
          return 0;
        }
        if ((v100 & 0x80000000) != 0) {
          return 0;
        }
        uint64_t v101 = *v16 * (uint64_t)v95;
        if (v101 != (int)v101) {
          return 0;
        }
        if ((v101 & 0x80000000) != 0) {
          return 0;
        }
        uint64_t v102 = v16[2] * (uint64_t)v95;
        if (v102 != (int)v102) {
          return 0;
        }
        int v103 = (void *)(v131[1] + v98);
        uint64_t v104 = &a4[1][v100 + v101];
        if (v54 >= 16 && v96)
        {
          uint64_t v105 = v91;
          int v106 = *(_DWORD *)(a1 + 112);
          unsigned int v107 = v60;
          CGBlt_swapBytes(v102, v91, v103, v104, v97, v99, v96);
LABEL_165:
          int v96 = v106;
          unsigned int v60 = v107;
          uint64_t v91 = v105;
          goto LABEL_166;
        }
        if (v97 < 0 || v97 != v99)
        {
          uint64_t v105 = v91;
          unsigned int v107 = v60;
          int v106 = *(_DWORD *)(a1 + 112);
          CGBlt_copyBytes(v102, v91, (char *)v103, v104, v97, v99);
          goto LABEL_165;
        }
        size_t v110 = v97 * (uint64_t)(int)v91;
        if (v110 != (int)v110) {
          return 0;
        }
        int v111 = *(_DWORD *)(a1 + 112);
        unsigned int v112 = v60;
        uint64_t v113 = v91;
        memcpy(v104, v103, v110);
        uint64_t v91 = v113;
        unsigned int v60 = v112;
        int v96 = v111;
      }
LABEL_166:
      if ((int)v91 < 1) {
        goto LABEL_185;
      }
      if (*a4 == a4[1]) {
        int v123 = v132 + 1;
      }
      else {
        int v123 = v132;
      }
      uint64_t v114 = *v53;
      uint64_t v124 = (int)v114 * (uint64_t)(int)v60;
      if (v124 != (int)v124) {
        return 0;
      }
      if ((v124 & 0x80000000) != 0) {
        return 0;
      }
      int v118 = *a5;
      uint64_t v125 = *a5 * (uint64_t)(int)v133;
      if (v125 != (int)v125) {
        return 0;
      }
      if ((v125 & 0x80000000) != 0) {
        return 0;
      }
      int v126 = v123;
      uint64_t v127 = v123 * (uint64_t)*v16;
      if (v127 != (int)v127) {
        return 0;
      }
      uint64_t v128 = v127 * v95;
      if (v128 != (int)v128) {
        return 0;
      }
      if ((v128 & 0x80000000) != 0) {
        return 0;
      }
      uint64_t v129 = v126 * (uint64_t)v16[2];
      if (v129 != (int)v129) {
        return 0;
      }
      int v119 = v129 * v95;
      if (v129 * v95 != v129 * v95) {
        return 0;
      }
      int v116 = (char *)(*v131 + v124);
      __int16 v117 = &(*a4)[v125 + v128];
      if (!v96)
      {
        if (v114 == v118)
        {
          if ((int)v114 < 1) {
            goto LABEL_185;
          }
          size_t v130 = v114 * v91;
          if (v114 * v91 == v114 * v91)
          {
            uint64_t v121 = &(*a4)[v125 + v128];
            uint64_t v122 = (const void *)(*v131 + v124);
            size_t v120 = v130;
            goto LABEL_161;
          }
          return 0;
        }
LABEL_163:
        CGBlt_copyBytes(v119, v91, v116, v117, v114, v118);
        goto LABEL_185;
      }
      goto LABEL_156;
    }
    int v61 = *(_DWORD *)(a1 + 104);
    unint64_t v62 = *(int **)(a1 + 136);
    int v63 = *v62;
    if (*v62 >= *a5) {
      int v63 = *a5;
    }
    if (v63 <= v61 || v61 <= 0) {
      int v65 = v63;
    }
    else {
      int v65 = *(_DWORD *)(a1 + 104);
    }
    *(void *)(a1 + 88) = a2;
    if (v14 == 2)
    {
      long long v67 = a4[1];
      if (v67)
      {
        if ((*(_DWORD *)(a1 + 44) & 0xFFFFFFFE) == 8)
        {
          uint64_t v68 = v62[1];
          uint64_t v69 = v68 * a2;
          if (v69 != v68 * a2) {
            return 0;
          }
          int v70 = *(_DWORD *)(a1 + 40);
          uint64_t v71 = *(int *)(a1 + 120) * (uint64_t)(v70 / 8);
          if (v71 != (int)v71) {
            return 0;
          }
          if (v70 >= 9 && (int v72 = *(_DWORD *)(a1 + 112)) != 0)
          {
            CGBlt_swapBytes(v71, a3, (void *)(v15[1] + v69), v67, v68, a5[1], v72);
          }
          else
          {
            int v108 = a5[1];
            if (v68 == v108)
            {
              if ((int)v68 >= 1)
              {
                size_t v109 = v68 * a3;
                if (v109 != (int)v109) {
                  return 0;
                }
                memcpy(a4[1], (const void *)(v15[1] + v69), v109);
              }
            }
            else
            {
              CGBlt_copyBytes(v71, a3, (char *)(v15[1] + v69), v67, v68, v108);
            }
          }
        }
      }
    }
    uint64_t v114 = *v62;
    uint64_t v115 = v114 * a2;
    if (v115 != v114 * a2) {
      return 0;
    }
    int v96 = *(_DWORD *)(a1 + 112);
    if (v96)
    {
      int v116 = (char *)(*v15 + v115);
      __int16 v117 = *a4;
      int v118 = *a5;
      int v119 = v65;
      LODWORD(v91) = v10;
LABEL_156:
      CGBlt_swapBytes(v119, v91, v116, v117, v114, v118, v96);
      goto LABEL_185;
    }
    int v118 = *a5;
    if (v114 != *a5)
    {
      int v116 = (char *)(*v15 + v115);
      __int16 v117 = *a4;
      int v119 = v65;
      LODWORD(v91) = v10;
      goto LABEL_163;
    }
    if ((int)v114 >= 1)
    {
      size_t v120 = v114 * v10;
      if (v120 == (int)v120)
      {
        uint64_t v121 = *a4;
        uint64_t v122 = (const void *)(*v15 + v115);
LABEL_161:
        memcpy(v121, v122, v120);
        goto LABEL_185;
      }
      return 0;
    }
LABEL_185:
    uint64_t v86 = *(void *)(a1 + 88) + v10;
    goto LABEL_186;
  }
  if (v14) {
    _CGHandleAssert("img_raw_read_with_data_provider", 504, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "stage->param[IMG_DECODE_NDATA] == 0", "param = %ld", a6, a7, a8, *(void *)(a1 + 96));
  }
  uint64_t image_pointer = get_image_pointer((void *)a1);
  if (!image_pointer)
  {
    access_session = get_access_session(a1);
    uint64_t v75 = *(void *)(a1 + 104);
    uint64_t v76 = *(void *)(a1 + 136);
    int v77 = *a5;
    if (*a5 >= (int)v76) {
      int v78 = *(void *)(a1 + 136);
    }
    else {
      int v78 = *a5;
    }
    if (v78 > (int)v75 && (int)v75 > 0) {
      int v78 = *(void *)(a1 + 104);
    }
    int v80 = *(_DWORD *)(a1 + 88);
    if (v80 <= (int)a2)
    {
      if (v80 >= (int)a2)
      {
LABEL_99:
        if (v77 == v76) {
          int v82 = v76;
        }
        else {
          int v82 = v78;
        }
        uint64_t ChunksAtPosition = CGAccessSessionGetChunksAtPosition(access_session, (int)v76 * (unint64_t)a2, v82, (int)v76 - v82, v10, *a4, v77 - v82, v74);
        uint64_t v10 = ((int)ChunksAtPosition / (int)v76);
        if ((int)v75 >= 1)
        {
          if (ChunksAtPosition - (int)v10 * (int)v76 < v75) {
            uint64_t v10 = v10;
          }
          else {
            uint64_t v10 = (v10 + 1);
          }
        }
        int v84 = *(_DWORD *)(a1 + 112);
        if (v84) {
          CGBlt_swapBytes(v82, v10, *a4, *a4, *a5, *a5, v84);
        }
        uint64_t v85 = (int)v10;
        goto LABEL_109;
      }
    }
    else
    {
      int v80 = 0;
    }
    if (v80 >= (int)a2) {
      uint64_t v81 = 0;
    }
    else {
      uint64_t v81 = a2;
    }
    *(void *)(a1 + 88) = v81;
    goto LABEL_99;
  }
  uint64_t v18 = image_pointer;
  int v19 = *(_DWORD *)(a1 + 104);
  uint64_t v20 = *(void *)(a1 + 136);
  int v21 = *a5;
  if (*a5 >= (int)v20) {
    int v22 = *(void *)(a1 + 136);
  }
  else {
    int v22 = *a5;
  }
  if (v22 <= v19 || v19 <= 0) {
    int v24 = v22;
  }
  else {
    int v24 = *(_DWORD *)(a1 + 104);
  }
  *(void *)(a1 + 88) = a2;
  unint64_t v25 = (int)v20 * (unint64_t)a2;
  if (v25 != (int)v25 || (v25 & 0x80000000) != 0 || (int)v20 < 1) {
    return 0;
  }
  uint64_t v26 = (void *)(v18 + v25);
  int v27 = *(_DWORD *)(a1 + 112);
  if (v27)
  {
    CGBlt_swapBytes(v24, v10, v26, *a4, v20, v21, v27);
LABEL_151:
    uint64_t v85 = v10;
LABEL_109:
    uint64_t v86 = *(void *)(a1 + 88) + v85;
LABEL_186:
    *(void *)(a1 + 88) = v86;
    return v10;
  }
  if (v21 != v20)
  {
    CGBlt_copyBytes(v24, v10, (char *)v26, *a4, v20, v21);
    goto LABEL_151;
  }
  uint64_t result = 0;
  if (((v20 << 32) & 0x8000000000000000) == 0 && !(((int)v20 * (unint64_t)v10) >> 32))
  {
    memcpy(*a4, v26, (int)v20 * (unint64_t)v10);
    goto LABEL_151;
  }
  return result;
}

uint64_t CGAccessSessionGetChunksAtPosition(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a3 || !a6) {
    return 0;
  }
  uint64_t v11 = *a1;
  if (!v11) {
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", (uint64_t)a6, a7, a8, v20);
  }
  switch(*(_DWORD *)(v11 + 20))
  {
    case 0:
    case 2:
      a1[2] = a2;
      uint64_t result = get_chunks_direct(a1, a3, a4, a5, a6, a7);
      break;
    case 1:
    case 3:
      uint64_t v17 = a1[2];
      uint64_t v18 = a2 - v17;
      if (a2 != v17)
      {
        if (a2 <= v17)
        {
          CGDataProviderRewind(v11);
          uint64_t v19 = CGDataProviderSkipForwardInternal(*a1, a2);
        }
        else
        {
          uint64_t v19 = a1[2] + CGDataProviderSkipForwardInternal(v11, v18);
        }
        a1[2] = v19;
      }
      uint64_t result = get_chunks_sequential(a1, a3, a4, a5, (uint64_t)a6, a7);
      break;
    default:
      return 0;
  }
  return result;
}

void *get_access_session(uint64_t a1)
{
  if (*(void *)(a1 + 96)) {
    return 0;
  }
  uint64_t result = *(void **)(a1 + 184);
  if (!result)
  {
    uint64_t result = CGAccessSessionCreate(*(CGDataProvider **)(a1 + 144));
    if (result)
    {
      uint64_t v3 = result[1];
      *(void *)(a1 + 184) = result;
      *(void *)(a1 + 192) = v3;
      *(void *)(a1 + 88) = 0;
    }
  }
  return result;
}

void *create_image_data_handle(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  if (a1 && a2)
  {
    int v9 = a4;
    if (~a3 / a2 <= a1)
    {
      CGPostError((uint64_t)"%s overflow detected w = %zu h = %zu extra = %zu transient %s %s", a2, a3, a4, a5, a6, a7, a8, (char)"create_image_data_handle");
      return 0;
    }
    uint64_t v8 = 0;
    unint64_t v10 = a1 + a1 * a2 + a3;
    if ((v10 & 0xF) != 0) {
      uint64_t v11 = 16 - (v10 & 0xF);
    }
    else {
      uint64_t v11 = 0;
    }
    if (-25 - v11 > v10)
    {
      uint64_t v8 = malloc_type_malloc(0x18uLL, 0x1080040CCC1B60FuLL);
      if (v8)
      {
        uint64_t v12 = v10 + v11 + 24;
        if (v9)
        {
          uint64_t v13 = malloc_default_zone();
          size_t v14 = v12;
          malloc_type_id_t v15 = 1509754142;
        }
        else
        {
          uint64_t v13 = malloc_default_purgeable_zone();
          size_t v14 = v12;
          malloc_type_id_t v15 = 3604067616;
        }
        uint64_t v17 = malloc_type_zone_calloc(v13, v14, 1uLL, v15);
        v8[2] = v17;
        if (v17)
        {
          __CFSetLastAllocationEventName();
          *uint64_t v8 = v12;
          *((unsigned char *)v8 + 8) = v9 ^ 1;
          return v8;
        }
        free(v8);
        return 0;
      }
    }
  }
  return v8;
}

uint64_t provider_for_destination_get_work_buffer_size(uint64_t a1)
{
  return *(void *)(a1 + 736);
}

void CGAccessSessionRelease(uint64_t *a1)
{
  if (a1)
  {
    CGAccessSessionRewind((uint64_t)a1);
    CFTypeID v2 = (CGDataProvider *)*a1;
    CGDataProviderReleaseBytePtr(*a1);
    CGDataProviderReleaseData((uint64_t)v2);
    CGDataProviderUnlock((uint64_t)v2);
    CGDataProviderRelease(v2);
    free(a1);
  }
}

uint64_t CGDataProviderReleaseData(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 128))
    {
      pthread_mutex_lock((pthread_mutex_t *)(result + 184));
      if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 256), 0xFFFFFFFF, memory_order_relaxed) == 1)
      {
        CFTypeID v2 = *(void (**)(void))(v1 + 136);
        if (v2) {
          v2(*(void *)(v1 + 24));
        }
      }
      CFRelease((CFTypeRef)v1);
      return pthread_mutex_unlock((pthread_mutex_t *)(v1 + 184));
    }
  }
  return result;
}

void *CGAccessSessionCreate(CGDataProvider *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x10E00404CFD562DuLL);
  if (v2)
  {
    pthread_t v3 = pthread_self();
    if (get_session_key_pred != -1) {
      dispatch_once(&get_session_key_pred, &__block_literal_global_20420);
    }
    pthread_setspecific(get_session_key_session_key, v3);
    CGDataProviderRef v4 = CGDataProviderRetain(a1);
    CGDataProviderLock((uint64_t)v4);
    CGDataProviderRetainData((uint64_t)a1);
    *CFTypeID v2 = a1;
    v2[1] = CGDataProviderRetainBytePtr((uint64_t)a1);
    CGAccessSessionRewind((uint64_t)v2);
  }
  return v2;
}

uint64_t CGAccessSessionRewind(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t *)result;
    check_same_thread();
    switch(*(_DWORD *)(*v1 + 20))
    {
      case 0:
      case 2:
        v1[2] = 0;
        goto LABEL_5;
      case 1:
      case 3:
        CGDataProviderRewind(*v1);
LABEL_5:
        uint64_t result = 1;
        break;
      default:
        uint64_t result = 0;
        break;
    }
  }
  return result;
}

uint64_t CGDataProviderRetainData(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 128))
    {
      pthread_mutex_lock((pthread_mutex_t *)(result + 184));
      CFRetain((CFTypeRef)v1);
      if (!atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 256), 1u, memory_order_relaxed)) {
        (*(void (**)(void))(v1 + 128))(*(void *)(v1 + 24));
      }
      return pthread_mutex_unlock((pthread_mutex_t *)(v1 + 184));
    }
  }
  return result;
}

uint64_t CGDataProviderLock(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  if (v2 != CGDataProviderGetTypeID_id) {
    return 0xFFFFFFFFLL;
  }
  CFRetain((CFTypeRef)a1);
  pthread_t v3 = *(uint64_t (**)(uint64_t))(a1 + 144);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 24);
    return v3(v4);
  }
  else if (*(void *)(a1 + 80))
  {
    return 0;
  }
  else
  {
    return pthread_mutex_lock((pthread_mutex_t *)(a1 + 184));
  }
}

uint64_t CGDataProviderUnlock(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
    }
    if (v2 == CGDataProviderGetTypeID_id)
    {
      pthread_t v3 = *(uint64_t (**)(void))(a1 + 152);
      if (v3)
      {
        uint64_t v4 = v3(*(void *)(a1 + 24));
      }
      else
      {
        if (*(void *)(a1 + 80))
        {
          uint64_t v5 = 0;
          goto LABEL_11;
        }
        uint64_t v4 = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 184));
      }
      uint64_t v5 = v4;
LABEL_11:
      CFRelease((CFTypeRef)a1);
      return v5;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t CGImageGetComponentType(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 56);
    if (v1 > 15)
    {
      if (v1 == 16)
      {
        if ((CGImageGetBitmapInfo((CGImageRef)result) & 0x100) != 0) {
          return 5;
        }
        else {
          return 2;
        }
      }
      else if (v1 == 32)
      {
        if ((CGImageGetBitmapInfo((CGImageRef)result) & 0x100) != 0) {
          return 4;
        }
        else {
          return 3;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      if (v1 == 10) {
        unsigned int v2 = 6;
      }
      else {
        unsigned int v2 = 0;
      }
      if (v1 == 8) {
        return 1;
      }
      else {
        return v2;
      }
    }
  }
  return result;
}

void img_release_resources(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 28);
  if ((v2 - 3) >= 3)
  {
    if (v2 == 1)
    {
      uint64_t v4 = *(CGColorSpace **)(a1 + 40);
      if (v4) {
        CGColorSpaceRelease(v4);
      }
    }
  }
  else if (*(unsigned char *)(a1 + 104))
  {
    pthread_t v3 = *(const void **)(a1 + 40);
    if (v3) {
      CFRelease(v3);
    }
  }
  if (!*(void *)(a1 + 128))
  {
    uint64_t v5 = *(CGDataProvider **)(a1 + 136);
    CGDataProviderRelease(v5);
  }
}

uint64_t img_data_depth(_DWORD *a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3)
  {
    uint64_t v9 = (int)a1[10];
    switch(v9)
    {
      case 32:
        if (a2 != 4) {
          _CGHandleAssert("img_data_depth", 4574, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "0", "Bad image component type for 32-bit pipeline: %d", a6, a7, a8, a2);
        }
LABEL_15:
        int v12 = a1[9];
        switch(v12)
        {
          case 4:
            if (img_globals_once != -1) {
              dispatch_once(&img_globals_once, &__block_literal_global_11955);
            }
            uint64_t v11 = &qword_1EB28A078;
            return *v11;
          case 3:
            int v15 = a1[11];
            if ((v15 - 5) < 2) {
              goto LABEL_48;
            }
            if (v15 == 1)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB28A058;
              return *v11;
            }
            if (!v15)
            {
LABEL_48:
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB28A048;
              return *v11;
            }
            break;
          case 1:
            if (img_globals_once != -1) {
              dispatch_once(&img_globals_once, &__block_literal_global_11955);
            }
            uint64_t v11 = &qword_1EB28A068;
            return *v11;
        }
        break;
      case 16:
        if (a2 == 5)
        {
LABEL_29:
          int v14 = a1[9];
          switch(v14)
          {
            case 4:
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB28A0C0;
              return *v11;
            case 3:
              int v17 = a1[11];
              switch(v17)
              {
                case 5:
                  goto LABEL_66;
                case 1:
                  if (img_globals_once != -1) {
                    dispatch_once(&img_globals_once, &__block_literal_global_11955);
                  }
                  uint64_t v11 = &qword_1EB28A0B0;
                  return *v11;
                case 0:
LABEL_66:
                  if (img_globals_once != -1) {
                    dispatch_once(&img_globals_once, &__block_literal_global_11955);
                  }
                  uint64_t v11 = &qword_1EB28A0A0;
                  return *v11;
              }
              break;
            case 1:
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB28A090;
              return *v11;
          }
        }
        else
        {
          if (a2 != 2) {
            _CGHandleAssert("img_data_depth", 4554, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "0", "Bad image component type for 16-bit pipeline: %d", a6, a7, a8, a2);
          }
LABEL_23:
          int v13 = a1[9];
          switch(v13)
          {
            case 4:
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB28A038;
              return *v11;
            case 3:
              int v16 = a1[11];
              if ((v16 - 5) < 2) {
                goto LABEL_57;
              }
              if (v16 == 1)
              {
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                uint64_t v11 = &qword_1EB28A028;
                return *v11;
              }
              if (!v16)
              {
LABEL_57:
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                uint64_t v11 = &qword_1EB28A018;
                return *v11;
              }
              break;
            case 1:
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB28A008;
              return *v11;
          }
        }
        break;
      case 8:
        if (a2 != 1) {
          _CGHandleAssert("img_data_depth", 4521, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "0", "Bad image component type for 8-bit pipeline: %d", a6, a7, a8, a2);
        }
LABEL_7:
        int v10 = a1[9];
        switch(v10)
        {
          case 4:
            if (img_globals_once != -1) {
              dispatch_once(&img_globals_once, &__block_literal_global_11955);
            }
            uint64_t v11 = &qword_1EB289FF0;
            return *v11;
          case 3:
            uint64_t v8 = 0;
            switch(a1[11])
            {
              case 0:
              case 5:
              case 6:
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                uint64_t v11 = &qword_1EB289FC8;
                return *v11;
              case 1:
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                uint64_t v11 = &qword_1EB289FD0;
                return *v11;
              case 2:
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                uint64_t v11 = &qword_1EB289FE0;
                return *v11;
              default:
                return v8;
            }
            return v8;
          case 1:
            if (a1[11] == 1)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB28A0D0;
            }
            else
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              uint64_t v11 = &qword_1EB289FB0;
            }
            return *v11;
        }
        break;
    }
    return 0;
  }
  uint64_t v8 = 0;
  switch(a2)
  {
    case 1:
      goto LABEL_7;
    case 2:
      goto LABEL_23;
    case 4:
      goto LABEL_15;
    case 5:
      goto LABEL_29;
    default:
      return v8;
  }
  return v8;
}

_DWORD *decode_create(uint64_t a1, int a2, int a3, uint64_t a4, int a5, __n128 a6)
{
  uint64_t v74 = a4;
  uint64_t v6 = 0;
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  if ((a1 - 256) < 0xFFFFFF01) {
    return v6;
  }
  if ((a2 - 256) < 0xFFFFFF01) {
    return v6;
  }
  uint64_t v6 = 0;
  if (a3 < a2 || a3 >= 0x10000) {
    return v6;
  }
  LODWORD(v9) = a5;
  int v10 = a1;
  if ((a5 & 0x400000) != 0) {
    unsigned int v11 = a1 - 1;
  }
  else {
    unsigned int v11 = -1;
  }
  if ((a5 & 0x200000) != 0) {
    unsigned int v11 = 0;
  }
  if ((a5 & 0x400) != 0) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0xFFFFFFFFLL;
  }
  if ((a5 & 0x87) == 0 || a2 != 32 && (a5 & 0x80) != 0 || a2 != 16 && (a5 & 4) != 0) {
    return 0;
  }
  if (a5)
  {
    int v68 = a5 & 0x81;
    int v14 = 8;
    if (a2 >= 8) {
      int v15 = 8;
    }
    else {
      int v15 = a2;
    }
    unsigned int v67 = v15;
    uint64_t v73 = ((1 << v15) + 3) & 0x7FFFFFFC;
  }
  else
  {
    if ((a5 & 2) != 0)
    {
      uint64_t v73 = 0;
      int v68 = a5 & 0x82;
      int v14 = 16;
      if (a2 >= 16) {
        int v17 = 16;
      }
      else {
        int v17 = a2;
      }
      unsigned int v67 = v17;
      double v16 = 65535.0;
      goto LABEL_32;
    }
    unsigned int v67 = 0;
    int v68 = a5 & 0x87;
    int v14 = 0;
    uint64_t v73 = 0;
  }
  double v16 = 255.0;
LABEL_32:
  int v69 = a1 - 1;
  LODWORD(v70) = v14;
  unsigned int v18 = a5 & 0x400;
  LODWORD(v72) = v18;
  if (v74)
  {
    uint64_t v19 = a1;
    uint64_t v20 = 8 * a1;
    MEMORY[0x1F4188790](a1, a6);
    int v22 = &v66[-v21];
    bzero(&v66[-v21], 8 * v10);
    int v23 = (int)v72;
    uint64_t v24 = 0;
    unsigned int v25 = 0;
    if (a2 >= v14) {
      unsigned int v26 = v14;
    }
    else {
      unsigned int v26 = a2;
    }
    int v27 = (void **)(&_decode_range + 2 * v26);
    uint64_t v28 = (float *)(v74 + 4);
    int v29 = -1;
    while (1)
    {
      int v30 = (float *)(v74 + 8 * v24);
      float v31 = *v30;
      float v32 = v30[1];
      if (v23)
      {
        if (v24 != v12) {
          break;
        }
      }
      float v33 = v32 - v31;
      if (v31 == 0.0 && v33 == 1.0)
      {
        int v29 = 2 * ((v29 + 1) > 1);
        uint64_t v38 = *v27;
      }
      else
      {
        if (v31 != 1.0 || v33 != -1.0) {
          break;
        }
        if (v29 == 1 || v29 == -1) {
          int v29 = 1;
        }
        else {
          int v29 = 2;
        }
        uint64_t v38 = v27[1];
      }
      *(void *)&v22[8 * v24] = v38;
LABEL_67:
      if (++v24 == v10) {
        goto LABEL_70;
      }
    }
    *(void *)&v22[8 * v24] = 0;
    uint64_t v36 = 0;
    if (v24)
    {
      uint64_t v37 = v28;
      while (v12 == v36 || !*(void *)&v22[8 * v36] || *(v37 - 1) != v31 || *v37 != v32)
      {
        ++v36;
        v37 += 2;
        if (v24 == v36)
        {
          LODWORD(v36) = v24;
          break;
        }
      }
    }
    if (v24 == v36) {
      ++v25;
    }
    int v29 = 2;
    goto LABEL_67;
  }
  int v22 = 0;
  unsigned int v25 = v18 != 0;
  int v29 = v18 >> 9;
  uint64_t v19 = a1;
  uint64_t v20 = 8 * a1;
LABEL_70:
  uint64_t v40 = malloc_type_malloc(v20 + (v73 + 20) * (unint64_t)v25 + 40, 0x705560E0uLL);
  uint64_t v6 = v40;
  int v41 = v68;
  *uint64_t v40 = v29;
  v40[1] = v41;
  v40[3] = v10;
  v40[4] = a2;
  v40[5] = a3;
  if (v9 & 0x200)
  {
    v40[7] = 4;
    int v42 = v69;
    int v43 = v70;
  }
  else
  {
    int v42 = v69;
    int v43 = v70;
    if (v9 & 0x100) {
      v40[7] = 2;
    }
    else {
      v40[7] = 0;
    }
  }
  int v44 = (int)v72;
  v40[6] = (v9 >> 20) & 1;
  if (v9 & 0x400000) {
    int v45 = v42;
  }
  else {
    int v45 = -1;
  }
  if (v9 & 0x200000) {
    int v45 = 0;
  }
  v40[2] = v45;
  uint64_t v46 = (uint64_t *)(v40 + 10);
  *((void *)v40 + 4) = v40 + 10;
  if (v22)
  {
    BOOL v47 = v44 != 0;
    if (v10 >= 1)
    {
      uint64_t v48 = 0;
      uint64_t v49 = v73;
      int v72 = (float *)(v74 + 4);
      int v50 = -1;
      uint64_t v51 = (uint64_t)&v46[v19];
      uint64_t v70 = v67;
      BOOL v71 = v9;
      do
      {
        ++v50;
        uint64_t v52 = *(void *)&v22[8 * v48];
        v46[v48] = v52;
        if (!v52)
        {
          unsigned int v53 = (float *)(v74 + 8 * v48);
          float v54 = *v53;
          float v55 = v53[1];
          int v56 = v48 == v12 || v47;
          if (v56 | ((v9 & 4) >> 2)) {
            double v57 = 1.0;
          }
          else {
            double v57 = v16;
          }
          if (v48)
          {
            uint64_t v58 = 0;
            int v59 = v72;
            while (v12 == v58 || *(v59 - 1) != v54 || *v59 != v55)
            {
              ++v58;
              v59 += 2;
              if (v48 == v58)
              {
                LODWORD(v58) = v50;
                goto LABEL_99;
              }
            }
            uint64_t v60 = *(void *)&v22[8 * v58];
            *(void *)&v22[8 * v48] = v60;
            v46[v48] = v60;
          }
          else
          {
            LODWORD(v58) = 0;
          }
LABEL_99:
          if (v48 == v58)
          {
            int v61 = v46;
            BOOL v9 = v47;
            DECODE_RANGE(v51, v70, v49, v54, v55, v57);
            BOOL v47 = v9;
            LOBYTE(v9) = v71;
            uint64_t v46 = v61;
            *(void *)&v22[8 * v48] = v51;
            v61[v48] = v51;
            v51 += v49 + 20;
          }
        }
        ++v48;
      }
      while (v48 != v19);
    }
  }
  else
  {
    if ((v9 & 0x480) == 0x400)
    {
      uint64_t v62 = (uint64_t)&v46[v19];
      DECODE_RANGE(v62, v67, v73, 0.0, (double)~(-1 << v67), 1.0);
      uint64_t v46 = (uint64_t *)(v6 + 10);
    }
    else
    {
      if (a2 >= v43) {
        unsigned int v63 = v43;
      }
      else {
        unsigned int v63 = a2;
      }
      uint64_t v62 = (uint64_t)*(&_decode_range + 2 * v63);
    }
    if (v10 >= 1)
    {
      uint64_t v64 = v46;
      do
      {
        *v64++ = v62;
        --v19;
      }
      while (v19);
    }
    if (v12 != -1)
    {
      if (a2 >= v43) {
        unsigned int v65 = v43;
      }
      else {
        unsigned int v65 = a2;
      }
      v46[v12] = (uint64_t)*(&_decode_range + 2 * v65);
    }
  }
  return v6;
}

void provider_for_destination_release_data(uint64_t *a1)
{
  CGDataProviderReleaseData(*a1);
  uint64_t v2 = *a1;

  CGDataProviderReleaseBytePtr(v2);
}

uint64_t provider_for_destination_retain_data(uint64_t *a1)
{
  CGDataProviderRetainData(*a1);
  uint64_t v2 = *a1;

  return CGDataProviderRetainBytePtr(v2);
}

void img_interpolate_end(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    (*(void (**)(void))(v2 + 24))();
  }
  pthread_t v3 = (void *)a1[11];
  if (v3)
  {
    resample_destroy(v3);
  }
}

void img_decode_end(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = (void *)a1[20];
  if (v9) {
    free(v9);
  }
  int v10 = (void *)a1[21];
  if (v10) {
    free(v10);
  }
  unsigned int v11 = (void *)a1[22];
  if (v11) {
    free(v11);
  }
  uint64_t v12 = (uint64_t *)a1[23];
  if (v12 || a1[24])
  {
    uint64_t v13 = a1[12];
    if (v13 == -1)
    {
      if (v12)
      {
        CGImageBlockSetRelease(*v12);
        free(v12);
      }
    }
    else
    {
      if (v13) {
        _CGHandleAssert("img_decode_end", 1581, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "stage->param[IMG_DECODE_NDATA] == 0", "param = %ld", a6, a7, a8, a1[12]);
      }
      uint64_t v14 = a1[24];
      if (v14 && v12) {
        _CGHandleAssert("img_decode_end", 1585, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "ptr == NULL || session == NULL", "ptr = %p, session = %p", a6, a7, a8, a1[24]);
      }
      if (v14)
      {
        uint64_t v15 = a1[18];
        CGDataProviderReleaseBytePtr(v15);
      }
      else if (v12)
      {
        double v16 = (uint64_t *)a1[23];
        CGAccessSessionRelease(v16);
      }
    }
  }
}

void resample_destroy(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[7];
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

uint64_t img_data_lock_depth(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v81 = a5;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0uLL;
  unint64_t v9 = *(void *)(a1 + 16);
  if (v9 == a2)
  {
    int v10 = 0;
    int v11 = *(_DWORD *)(a1 + 32);
    unint64_t v12 = *(int *)(a1 + 40);
    double v13 = 1.0;
    unsigned int v14 = *(_DWORD *)(a1 + 40);
  }
  else
  {
    double v13 = (double)a2 / (double)v9;
    uint64_t v15 = *(int *)(a1 + 40);
    if (v9 == v15)
    {
      int v11 = 0;
      unint64_t v12 = (int)a2;
      unsigned int v14 = a2;
    }
    else
    {
      int v16 = *(_DWORD *)(a1 + 32);
      int v17 = vcvtmd_s64_f64((double)v16 * v13 + 0.00390625);
      int v11 = v17 & ~(v17 >> 31);
      signed int v18 = vcvtpd_s64_f64((double)(v16 + (int)v15) * v13 + -0.00390625);
      if (v18 > (uint64_t)a2) {
        signed int v18 = a2;
      }
      int v19 = v18 - v11;
      if (v18 <= v11) {
        goto LABEL_65;
      }
      unint64_t v12 = v19;
      double v13 = (double)v19 / (double)(int)v15;
      unsigned int v14 = v19;
    }
    int v10 = &v82;
    *((void *)&v67 + 1) = &v82;
  }
  unint64_t v20 = *(void *)(a1 + 24);
  if (v20 == a3)
  {
    int v21 = *(_DWORD *)(a1 + 36);
    int v22 = *(_DWORD *)(a1 + 44);
    uint64_t v23 = v22;
    unint64_t v24 = a4 + v22;
    double v25 = 1.0;
  }
  else
  {
    double v25 = (double)a3 / (double)v20;
    uint64_t v26 = *(unsigned int *)(a1 + 44);
    if (v20 == v26)
    {
      int v21 = 0;
      unint64_t v24 = a4 + (int)a3;
      int v22 = a3;
    }
    else
    {
      int v27 = *(_DWORD *)(a1 + 36);
      int v28 = vcvtmd_s64_f64((double)v27 * v25 + 0.00390625);
      int v21 = v28 & ~(v28 >> 31);
      signed int v29 = vcvtpd_s64_f64((double)(v27 + (int)v26) * v25 + -0.00390625);
      if (v29 > (uint64_t)a3) {
        signed int v29 = a3;
      }
      int v22 = v29 - v21;
      if (v29 <= v21) {
        goto LABEL_65;
      }
      unint64_t v24 = v22;
      unint64_t v30 = vcvtpd_s64_f64((double)(unint64_t)((int)v26 + a4) * v25 + -0.00390625);
      if (a4) {
        unint64_t v24 = v30;
      }
      double v25 = (double)v22 / (double)(int)v26;
    }
    int v10 = &v82;
    *((void *)&v67 + 1) = &v82;
    uint64_t v23 = v22;
  }
  long long v71 = 0u;
  long long v72 = 0u;
  uint64_t v80 = 0;
  long long v79 = 0u;
  long long v78 = 0u;
  long long v77 = 0u;
  long long v76 = 0u;
  long long v75 = 0u;
  long long v74 = 0u;
  *(_OWORD *)uint64_t v73 = 0u;
  if (v12 >= a2) {
    unint64_t v31 = a2;
  }
  else {
    unint64_t v31 = v12;
  }
  if (v24 >= a3) {
    unint64_t v32 = a3;
  }
  else {
    unint64_t v32 = v24;
  }
  v70[1] = v31;
  LODWORD(v71) = v32;
  unint64_t v33 = *a5;
  uint64_t v34 = (((v31 * (v33 >> 22)) >> 3) + 31) & 0x3FFFFFFFFFFFFFE0;
  DWORD1(v72) = (((v31 * (v33 >> 22)) >> 3) + 31) & 0xFFFFFFE0;
  int v63 = v11;
  int v60 = v21;
  uint64_t v64 = v10;
  int v65 = v22;
  if (!*(void *)(a1 + 64) && v31 == v14 && v32 == v23)
  {
    int v35 = a6;
    int v36 = 0;
    unint64_t v37 = 0;
  }
  else
  {
    int v35 = a6;
    int v38 = v33 & 0xC;
    unint64_t v39 = (((v31 * (((BYTE2(v33) & 0x3F) + 7) & 0x78)) >> 3) + 3) & 0x3FFFFFFFFFFFFFFCLL;
    if (v38 == 8) {
      int v36 = v34;
    }
    else {
      int v36 = v39;
    }
    if (v38 == 8) {
      unint64_t v37 = 0;
    }
    else {
      unint64_t v37 = v39;
    }
    DWORD2(v72) = v36;
  }
  if (v20 == a3) {
    uint64_t v40 = 0;
  }
  else {
    uint64_t v40 = "CGSImageData HeightMismatch";
  }
  if (v9 == a2) {
    int v41 = v40;
  }
  else {
    int v41 = "CGSImageData WidthMismatch";
  }
  if (*(unsigned int **)(a1 + 8) == a5) {
    int v43 = v41;
  }
  else {
    int v43 = "CGSImageData DepthMismatch";
  }
  image_data_handle = create_image_data_handle(v37 + v34, v32, 31, a7, (uint64_t)v43, a6, a7, a8);
  if (!image_data_handle)
  {
LABEL_65:
    CGSImageDataUnlock((uint64_t *)v8);
    return 0;
  }
  int v45 = (char *)image_data_handle[2];
  v73[0] = v45;
  if (v36)
  {
    uint64_t v46 = a5;
    BOOL v47 = v64;
    if (v37) {
      v45 += v34 * v32;
    }
    int v48 = v65;
  }
  else
  {
    int v45 = 0;
    uint64_t v46 = a5;
    BOOL v47 = v64;
    int v48 = v65;
  }
  uint64_t v49 = image_data_handle;
  unint64_t v50 = *(void *)(v8 + 40);
  *(void *)((char *)&v75 + 4) = *(void *)(v8 + 48);
  long long v76 = *(_OWORD *)(v8 + 56);
  v73[1] = v45;
  v70[0] = 257;
  HIDWORD(v71) = v14;
  LODWORD(v72) = v48;
  *((void *)&v74 + 1) = __PAIR64__(v48, v14);
  if (v35 == 1) {
    unsigned int v51 = 65280;
  }
  else {
    unsigned int v51 = 0xFFFF;
  }
  LODWORD(v66) = **(_DWORD **)(v8 + 8);
  *(void *)((char *)&v66 + 4) = v51 | 0x3F80000000000000;
  long long v68 = v50;
  *(void *)&long long v69 = *(void *)(v8 + 80);
  *((void *)&v69 + 1) = v8;
  if (v47)
  {
    uint64_t v85 = 0;
    uint64_t v83 = 0;
    float v52 = v13;
    float v53 = v25;
    float v82 = v52;
    float v84 = v53;
  }
  if (!(*((unsigned int (**)(unsigned int **, _DWORD *, long long *))v46 + 5))(&v81, v70, &v66))
  {
    free(v73[0]);
    goto LABEL_65;
  }
  CGSImageDataHandleRelease(*(void *)(v8 + 72));
  *(void *)(v8 + 72) = 0;
  float v54 = *(uint64_t **)(v8 + 112);
  if (v54) {
    CGAccessSessionRelease(v54);
  }
  *(void *)(v8 + 112) = 0;
  float v55 = *(uint64_t **)(v8 + 120);
  if (v55)
  {
    CGImageBlockSetRelease(*v55);
    free(v55);
  }
  *(void *)(v8 + 120) = 0;
  double v57 = v73[0];
  int v56 = v73[1];
  uint64_t v58 = v81;
  *(void *)uint64_t v8 = *(void *)(*((void *)v81 + 1) + 8 * (v73[1] != 0));
  *(void *)(v8 + 8) = v58;
  *(void *)(v8 + 16) = a2;
  *(void *)(v8 + 24) = a3;
  *(_DWORD *)(v8 + 40) = v31;
  *(_DWORD *)(v8 + 44) = v32;
  *(_DWORD *)(v8 + 32) = v63;
  *(_DWORD *)(v8 + 36) = v60 - v32 + v48;
  *(void *)(v8 + 56) = v57;
  *(void *)(v8 + 64) = v56;
  *(void *)(v8 + 48) = *(void *)((char *)&v72 + 4);
  *(void *)(v8 + 72) = v49;
  *(void *)(v8 + 80) = 0;
  return v8;
}

void CGBlt_swapBytes(int a1, unsigned int a2, void *a3, void *a4, int a5, int a6, __int16 a7)
{
  if (a1 >= 1 && (int)a2 >= 1)
  {
    if ((a7 & 0xF000) == 0x2000)
    {
      *(_DWORD *)permuteMap = 66051;
      src.data = a3;
      src.double height = a2;
      src.CGFloat width = a1 >> 2;
      src.rowBytes = a5;
      dest.data = a4;
      dest.double height = a2;
      dest.CGFloat width = src.width;
      dest.rowBytes = a6;
      vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
    }
    else if ((a7 & 0xF000) == 0x1000)
    {
      src.data = a3;
      src.double height = a2;
      src.CGFloat width = a1 >> 1;
      src.rowBytes = a5;
      dest.data = a4;
      dest.double height = a2;
      dest.CGFloat width = src.width;
      dest.rowBytes = a6;
      vImageByteSwap_Planar16U(&src, &dest, 0);
    }
    else if (a3 != a4)
    {
      CGBlt_copyBytes(a1, a2, (char *)a3, (char *)a4, a5, a6);
    }
  }
}

int8x16_t img_stream_stage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 16) = img_raw_read;
  *(void *)(a1 + 24) = img_decode_end;
  uint64_t v3 = 48;
  if ((*(_DWORD *)(a2 + 28) - 3) >= 3) {
    uint64_t v3 = 0;
  }
  uint64_t v4 = 8;
  uint64_t v5 = *(void *)(a2 + v3);
  if ((*(_DWORD *)(a2 + 28) - 3) < 3) {
    uint64_t v4 = 56;
  }
  *(_DWORD *)(a1 + 48) = v5;
  *(_DWORD *)(a1 + 52) = *(void *)(a2 + v4);
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6) {
    int v7 = *(_DWORD *)(*(void *)(v6 + 24) + 48);
  }
  else {
    int v7 = 1;
  }
  uint64_t v8 = *(void *)(a2 + 120);
  unsigned int v9 = **(_DWORD **)(a2 + 112);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = HIWORD(v9) & 0x3F;
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 24);
  uint64_t v10 = *(void *)(a2 + 128);
  *(void *)(a1 + 120) = (int)v5;
  *(void *)(a1 + 128) = v7;
  int8x16_t result = vextq_s8(*(int8x16_t *)(a2 + 136), *(int8x16_t *)(a2 + 136), 8uLL);
  *(int8x16_t *)(a1 + 136) = result;
  *(void *)(a1 + 152) = v8;
  *(void *)(a1 + 184) = a3;
  *(void *)(a1 + 96) = v10;
  *(void *)(a1 + 104) = ((v9 >> 22) * v5 + 7) >> 3;
  return result;
}

uint64_t CGContextGetRenderingState(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t CGContextGetGState(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t CGFontDBGetLocal()
{
  if (CGFontDBGetLocal_once != -1) {
    dispatch_once_f(&CGFontDBGetLocal_once, 0, (dispatch_function_t)create_local_db);
  }
  return local_db;
}

_DWORD *CGColorTransformConvertImage(_DWORD *image, int a2, CFDictionaryRef theDict)
{
  uint64_t v3 = image;
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  if (!image) {
    return v3;
  }
  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, @"kCGColorTransformCreateMask");
    uint64_t v6 = (const void *)*MEMORY[0x1E4F1CFD0];
    int v7 = (char *)(v3 + 9);
    int v8 = v3[9] & 0xC000000;
    BOOL v9 = v8 != 0;
    uint64_t v10 = CFDictionaryGetValue(theDict, @"kCGColorTransformFlattenImage");
    BOOL v11 = v10 == v6;
    BOOL v74 = Value == v6;
    if (Value == v6)
    {
      if (!v8)
      {
        CGColorSpaceRef v18 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
        goto LABEL_31;
      }
LABEL_27:
      CGColorSpaceRef v18 = 0;
LABEL_31:
      CGColorSpaceRef ColorSpace = 0;
      uint64_t v76 = 0;
      *(void *)&long long valuePtr = 0;
      CGInterpolationQuality v75 = kCGInterpolationDefault;
      goto LABEL_50;
    }
    unint64_t v12 = v10;
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)v3);
    if (!ColorSpace)
    {
      if (v12 == v6) {
        goto LABEL_19;
      }
      goto LABEL_27;
    }
  }
  else
  {
    int v7 = (char *)(image + 9);
    BOOL v9 = (image[9] & 0xC000000) != 0;
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)image);
    if (!ColorSpace)
    {
      CGColorSpaceRef v18 = 0;
      BOOL v74 = 0;
      uint64_t v76 = 0;
      *(void *)&long long valuePtr = 0;
LABEL_58:
      CGInterpolationQuality v75 = kCGInterpolationDefault;
      goto LABEL_59;
    }
    BOOL v74 = 0;
    BOOL v11 = 0;
  }
  uint64_t v14 = *((void *)ColorSpace + 3);
  if (*(unsigned char *)(v14 + 10) && *(_DWORD *)(v14 + 28) != 3)
  {
    CFRetain(ColorSpace);
    CGColorSpaceRef v18 = ColorSpace;
    goto LABEL_48;
  }
  if (!v11)
  {
    CFRetain(ColorSpace);
    uint64_t v15 = *(void *)(*((void *)ColorSpace + 3) + 48);
    switch(v15)
    {
      case 4:
        CFStringRef v16 = @"kCGColorSpaceGenericCMYK";
        break;
      case 3:
        CFStringRef v16 = @"kCGColorSpaceSRGB";
        break;
      case 1:
        CFStringRef v16 = @"kCGColorSpaceGenericGrayGamma2_2";
        break;
      default:
        CGColorSpaceRef v18 = 0;
        goto LABEL_49;
    }
    CGColorSpaceRef v18 = CGColorSpaceCreateWithName(v16);
    goto LABEL_49;
  }
LABEL_19:
  while (1)
  {
    CGColorSpaceRef v18 = ColorSpace;
    int Type = CGColorSpaceGetType(ColorSpace);
    if (Type != 7) {
      break;
    }
    CGColorSpaceRef ColorSpace = 0;
    if (v18)
    {
      CGColorSpaceRef ColorSpace = 0;
      uint64_t v17 = *((void *)v18 + 3);
      if ((*(_DWORD *)(v17 + 28) - 5) <= 1) {
        CGColorSpaceRef ColorSpace = **(CGColorSpaceRef **)(v17 + 96);
      }
    }
  }
  if (Type == 8)
  {
    if (!ColorSpace) {
      goto LABEL_48;
    }
    uint64_t v20 = *((void *)ColorSpace + 3);
    int v21 = *(_DWORD *)(v20 + 24);
    switch(v21)
    {
      case 6:
        int v22 = (CGColorSpaceRef *)(*(void *)(v20 + 96) + 56);
        break;
      case 10:
        int v22 = (CGColorSpaceRef *)(*(void *)(v20 + 96) + 48);
        break;
      case 8:
        int v22 = (CGColorSpaceRef *)(*(void *)(v20 + 96) + 8);
        break;
      default:
LABEL_44:
        CGColorSpaceRef v18 = 0;
        goto LABEL_48;
    }
    CGColorSpaceRef v18 = *v22;
  }
  if (v18)
  {
    uint64_t v23 = *(void *)(*((void *)v18 + 3) + 48);
    switch(v23)
    {
      case 4:
        CFStringRef v24 = @"kCGColorSpaceGenericCMYK";
        goto LABEL_47;
      case 3:
        CFStringRef v24 = @"kCGColorSpaceSRGB";
        goto LABEL_47;
      case 1:
        CFStringRef v24 = @"kCGColorSpaceGenericGrayGamma2_2";
LABEL_47:
        CGColorSpaceRef v18 = CGColorSpaceCreateWithName(v24);
        goto LABEL_48;
    }
    goto LABEL_44;
  }
LABEL_48:
  CGColorSpaceRef ColorSpace = 0;
LABEL_49:
  uint64_t v76 = 0;
  *(void *)&long long valuePtr = 0;
  CGInterpolationQuality v75 = kCGInterpolationDefault;
  if (!theDict) {
    goto LABEL_59;
  }
LABEL_50:
  CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kCGColorTransformConvertImageWidth");
  if (v25 && !CFNumberGetValue(v25, kCFNumberCFIndexType, &valuePtr)) {
    *(void *)&long long valuePtr = 0;
  }
  CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kCGColorTransformConvertImageHeight");
  if (v26 && !CFNumberGetValue(v26, kCFNumberCFIndexType, &v76)) {
    uint64_t v76 = 0;
  }
  CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kCGColorTransformConvertImageQuality");
  if (v27 && !CFNumberGetValue(v27, kCFNumberSInt32Type, &v75)) {
    goto LABEL_58;
  }
LABEL_59:
  unint64_t Size = CGImageGetSize(v3);
  if ((void)valuePtr) {
    unint64_t v30 = valuePtr;
  }
  else {
    unint64_t v30 = Size;
  }
  if (v76) {
    uint64_t v31 = v76;
  }
  else {
    uint64_t v31 = v29;
  }
  unsigned __int8 RenderingIntent = CGImageGetRenderingIntent((CGImageRef)v3);
  CGInterpolationQuality v32 = v75;
  if (v75 == kCGInterpolationDefault)
  {
    if (CGImageGetShouldInterpolate((CGImageRef)v3)) {
      CGInterpolationQuality v32 = kCGInterpolationHigh;
    }
    else {
      CGInterpolationQuality v32 = kCGInterpolationNone;
    }
  }
  if (ColorSpace && *(_DWORD *)(*((void *)ColorSpace + 3) + 28) == 5) {
    CGInterpolationQuality v32 = kCGInterpolationNone;
  }
  UpscaledComponentint Type = CGImageGetUpscaledComponentType((CGImage *)v3);
  unint64_t BitsPerComponent = CGPixelComponentGetBitsPerComponent(UpscaledComponentType, v34, v35, v36, v37, v38, v39, v40);
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo((CGImageRef)v3);
  if (v18)
  {
    int v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    switch(*(void *)(*((void *)v18 + 3) + 48))
    {
      case 0:
        break;
      case 1:
        if (v74)
        {
          uint64_t v46 = 0;
          BOOL v9 = 0;
          int v43 = 0;
          uint64_t v44 = 8;
          uint64_t v45 = 8;
          goto LABEL_83;
        }
        unint64_t v67 = BitsPerComponent >> 3;
        uint64_t v45 = BitsPerComponent;
LABEL_124:
        uint64_t v46 = v30 * v67;
        if (v9)
        {
          BOOL v47 = (CGContext *)CGBitmapContextCreateWithAlpha(0, v30, v31, BitsPerComponent, v45, v46, v18, 0, 72.0, 72.0, (uint64_t)theDict);
          goto LABEL_85;
        }
        int v43 = 0;
        goto LABEL_84;
      case 3:
        uint64_t v45 = 4 * BitsPerComponent;
        uint64_t v46 = v30 * ((BitsPerComponent >> 1) & 0x7FFFFFFFFFFFFFFCLL);
        if (v9)
        {
          if ((v7[3] & 4) == 0)
          {
LABEL_109:
            BOOL v9 = 1;
            uint64_t v44 = BitsPerComponent;
            int v43 = 1;
            goto LABEL_83;
          }
          if (AlphaInfo == kCGImageAlphaFirst)
          {
            int v43 = 2;
            BOOL v9 = 1;
          }
          else
          {
            if (AlphaInfo == kCGImageAlphaLast) {
              goto LABEL_109;
            }
            int v43 = 1;
            if (AlphaInfo)
            {
              uint64_t v44 = BitsPerComponent;
              BOOL v9 = 1;
              int v43 = AlphaInfo;
              goto LABEL_83;
            }
          }
        }
        else
        {
          int v43 = 5;
        }
        uint64_t v44 = BitsPerComponent;
        goto LABEL_83;
      case 4:
        uint64_t v45 = 4 * BitsPerComponent;
        unint64_t v67 = (BitsPerComponent >> 1) & 0x7FFFFFFFFFFFFFFCLL;
        goto LABEL_124;
      default:
        goto LABEL_83;
    }
  }
  if (v74) {
    uint64_t v44 = 8;
  }
  else {
    uint64_t v44 = 0;
  }
  if (v74) {
    uint64_t v45 = 8;
  }
  else {
    uint64_t v45 = 0;
  }
  uint64_t v46 = 0;
  if (v74)
  {
    BOOL v9 = 1;
    int v43 = 7;
  }
  else
  {
    int v43 = 0;
  }
LABEL_83:
  unint64_t BitsPerComponent = v44;
LABEL_84:
  BOOL v47 = (CGContext *)CGBitmapContextCreateWithDataAndDictionary(0, v30, v31, BitsPerComponent, v45, v46, v18, v43, 72.0, 72.0, 0, 0, (uint64_t)theDict);
LABEL_85:
  float v55 = v47;
  if (v47)
  {
    if (v9) {
      CGContextClear((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54);
    }
    else {
      CGContextErase((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54);
    }
    double v56 = (double)v30;
    CGContextSetInterpolationQuality(v55, v32);
    BOOL ShouldInterpolate = CGImageGetShouldInterpolate((CGImageRef)v3);
    if (CGImageGetRenderingIntent((CGImageRef)v3) != a2 || ColorSpace)
    {
      CopCGFloat y = CGImageCreateCopy((CGImageRef)v3);
      uint64_t v3 = Copy;
      *((unsigned char *)Copy + 37) = a2;
      if (ColorSpace)
      {
        CGColorSpaceRelease(*((CGColorSpaceRef *)Copy + 18));
        if (v18) {
          CFRetain(v18);
        }
        *((void *)v3 + 18) = v18;
      }
      uint64_t v58 = v3;
    }
    else
    {
      uint64_t v58 = 0;
    }
    v79.origin.CGFloat x = 0.0;
    v79.origin.CGFloat y = 0.0;
    v79.size.CGFloat width = v56;
    v79.size.double height = (double)(unint64_t)v31;
    CGContextDrawImage(v55, v79, (CGImageRef)v3);
    if (v58) {
      CFRelease(v58);
    }
    CGImageRef v60 = CGBitmapContextCreateImage(v55);
    uint64_t v3 = v60;
    BOOL v61 = v74;
    if (!v18) {
      BOOL v61 = 0;
    }
    if (v61)
    {
      long long valuePtr = xmmword_185293280;
      if (v60)
      {
        unint64_t v62 = *((void *)v60 + 5);
        unint64_t v63 = *((void *)v60 + 6);
        unint64_t v65 = *((void *)v60 + 7);
        unint64_t v64 = *((void *)v60 + 8);
        unint64_t v66 = *((void *)v60 + 9);
      }
      else
      {
        unint64_t v64 = 0;
        unint64_t v63 = 0;
        unint64_t v62 = 0;
        unint64_t v65 = 0;
        unint64_t v66 = 0;
      }
      DataProviderInternal = CGImageGetDataProviderInternal((char *)v60, 0);
      long long v69 = mask_create(v62, v63, v65, v64, v66, (CGDataProviderRef)DataProviderInternal, (double *)&valuePtr, 1, 4);
      if (v3) {
        CFRelease(v3);
      }
      uint64_t v3 = v69;
    }
    if (ColorSpace)
    {
      CGColorSpaceRelease(*((CGColorSpaceRef *)v3 + 18));
      *((void *)v3 + 18) = ColorSpace;
    }
    if (ShouldInterpolate) {
      int v70 = 0x1000000;
    }
    else {
      int v70 = 0;
    }
    v3[9] = v70 & 0xFFFF00FF | (RenderingIntent << 8) | v3[9] & 0xFEFF00FF;
    CFRelease(v55);
  }
  else
  {
    uint64_t v3 = 0;
  }
  CGColorSpaceRelease(v18);
  CGColorSpaceRelease(ColorSpace);
  return v3;
}

uint64_t ripc_Operation(uint64_t a1, uint64_t a2, int a3, __CFString *cf1, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v10 = *(void *)(a1 + 288);
    if (a5) {
      return 1006;
    }
  }
  else
  {
    uint64_t v10 = 0;
    if (a5) {
      return 1006;
    }
  }
  if (cf1 == @"kCGContextFlush")
  {
LABEL_13:
    uint64_t result = *(void *)(v10 + 48);
    if (!result) {
      return result;
    }
    unint64_t v12 = *(void (**)(void))(*(void *)result + 64);
    goto LABEL_18;
  }
  if (cf1 == @"kCGContextSynchronize")
  {
LABEL_16:
    uint64_t result = *(void *)(v10 + 48);
    if (!result) {
      return result;
    }
    unint64_t v12 = *(void (**)(void))(*(void *)result + 64);
    goto LABEL_18;
  }
  if (cf1 == @"kCGContextClear") {
    goto LABEL_22;
  }
  if (cf1 == @"kCGContextErase") {
    goto LABEL_25;
  }
  if (cf1 == @"kCGContextWait") {
    goto LABEL_40;
  }
  if (cf1 == @"kCGContextLog")
  {
LABEL_43:
    RIPPrint();
    return 0;
  }
  if (CFEqual(cf1, @"kCGContextFlush")) {
    goto LABEL_13;
  }
  if (CFEqual(cf1, @"kCGContextSynchronize")) {
    goto LABEL_16;
  }
  if (CFEqual(cf1, @"kCGContextClear"))
  {
LABEL_22:
    uint64_t result = *(void *)(v10 + 48);
    if (result)
    {
      *(_DWORD *)(v10 + 104) = 0;
      uint64_t v13 = v10 + 104;
      *(void *)(v13 + 48) = 0x3FF0000000000000;
      *(_DWORD *)(v13 + 8) = 0;
      *(unsigned char *)(v13 + 4) = *(unsigned char *)(a2 + 82);
      RIPLayerBltShape((int *)result, 0, 0, 0, 0, 0, v13, a8);
      return 0;
    }
    return result;
  }
  if (CFEqual(cf1, @"kCGContextErase"))
  {
LABEL_25:
    if (!*(void *)(v10 + 48)) {
      return 0;
    }
    ripc_InitializeColorTransform(v10);
    Cache = CGColorTransformGetCache(*(void **)(v10 + 120));
    if (Cache) {
      uint64_t v15 = Cache[2];
    }
    else {
      uint64_t v15 = 0;
    }
    CFStringRef v16 = (char *)malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
    CGColorSpaceRef v18 = v16;
    *((void *)v16 + 1) = 0;
    *((void *)v16 + 2) = 0;
    *(void *)CFStringRef v16 = &ripc_class;
    if (v15)
    {
      int v19 = *(_DWORD *)(*(void *)(v15 + 24) + 28);
      *((_DWORD *)v16 + 6) = v19;
      uint64_t v20 = v16 + 24;
      switch(v19)
      {
        case 2:
          *(void *)(v16 + 36) = 0;
          *(void *)(v16 + 28) = 0;
          goto LABEL_38;
        case 1:
          *((_DWORD *)v16 + 9) = 1065353216;
          __asm { FMOV            V0.2S, #1.0 }
          *(void *)(v16 + 28) = _D0;
          goto LABEL_38;
        case 0:
          *((_DWORD *)v16 + 7) = 1065353216;
LABEL_38:
          *((_DWORD *)v16 + 39) = 1065353216;
          *(_DWORD *)(v10 + 104) = 1;
          *(void *)(v10 + 152) = 0x3FF0000000000000;
          *(_DWORD *)(v10 + 112) = 0;
          *(unsigned char *)(v10 + 108) = *(unsigned char *)(a2 + 82);
          RIPLayerBltShape(*(int **)(v10 + 48), 0, 0, 0, (uint64_t)v16, 0, v10 + 104, v17);
          free(v18);
          return 0;
      }
    }
    else
    {
      uint64_t v20 = v16 + 24;
    }
    *uint64_t v20 = -1;
    goto LABEL_38;
  }
  if (!CFEqual(cf1, @"kCGContextWait"))
  {
    if (CFEqual(cf1, @"kCGContextLog")) {
      goto LABEL_43;
    }
    return 1006;
  }
LABEL_40:
  uint64_t result = *(void *)(v10 + 48);
  if (result)
  {
    unint64_t v12 = *(void (**)(void))(*(void *)result + 64);
LABEL_18:
    v12();
    return 0;
  }
  return result;
}

void CGContextClear(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v10 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextClear", v10, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v10 = a1;
    goto LABEL_7;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    BOOL v9 = *(void (**)(void))(v8 + 168);
    if (v9) {
      v9();
    }
  }
}

void CGContextSetInterpolationQuality(CGContextRef c, CGInterpolationQuality quality)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetInterpolationQuality(*((void *)c + 12), quality);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetInterpolationQuality", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

uint64_t CGImageGetUpscaledComponentType(CGImage *a1)
{
  uint64_t result = CGImageGetComponentType((uint64_t)a1);
  if (result > 6 || ((1 << result) & 0x49) == 0) {
    return result;
  }
  if (!a1)
  {
    LOBYTE(v6) = 0;
    goto LABEL_16;
  }
  unint64_t v6 = *((void *)a1 + 7);
  CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(a1);
  if (v6 > 0xF) {
    goto LABEL_13;
  }
  if (((1 << v6) & 0xFE) != 0) {
    return 1;
  }
  if (((1 << v6) & 0xF800) != 0) {
    return 2;
  }
  if (((1 << v6) & 0x600) == 0)
  {
LABEL_13:
    if (v6 - 33 > 0xFFFFFFFFFFFFFFDFLL) {
      return 4;
    }
LABEL_16:
    _CGHandleAssert("CGImageGetUpscaledComponentType", 3441, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "bits_per_component > 0 && bits_per_component < 33", "bpc %zu", v3, v4, v5, v6);
  }
  if ((BitmapInfo & 0xF0000) != 0x40000) {
    return 2;
  }
  return 5;
}

CGLayerRef CGLayerCreateWithContext(CGContextRef context, CGSize size, CFDictionaryRef auxiliaryInfo)
{
  BOOL v9 = 0;
  if (size.width > 0.0)
  {
    double height = size.height;
    if (size.height > 0.0)
    {
      double width = size.width;
      if (_block_invoke_once_2249 != -1) {
        dispatch_once(&_block_invoke_once_2249, &__block_literal_global_5_2250);
      }
      uint64_t Instance = CGTypeCreateInstance(CGLayerGetTypeID_layer_type_id, 24, v3, v4, v5, v6, v7, v8);
      BOOL v9 = (CGLayer *)Instance;
      if (Instance)
      {
        v23.n128_f64[0] = ceil(width);
        v24.n128_f64[0] = ceil(height);
        *(void *)(Instance + 24) = v23.n128_u64[0];
        *(void *)(Instance + 32) = v24.n128_u64[0];
        v21.n128_u64[0] = 0;
        v22.n128_u64[0] = 0;
        CFNumberRef v25 = (const void *)CGContextDelegateCreateForContext(auxiliaryInfo, (uint64_t)context, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24);
        if (v25)
        {
          int v28 = v25;
          if (context) {
            uint64_t v29 = *((void *)context + 14);
          }
          else {
            uint64_t v29 = 0;
          }
          *((void *)v9 + 2) = CGContextCreateWithDelegateAndInfo(v25, 0, v29, 0, 0, 0, v26, v27);
          CFRelease(v28);
          uint64_t v30 = *((void *)v9 + 2);
          if (v30)
          {
            if (context) {
              *(CGAffineTransform *)(*(void *)(v30 + 112) + 24) = CGAffineTransformIdentity;
            }
            return v9;
          }
          CFRelease(v9);
        }
        return 0;
      }
    }
  }
  return v9;
}

uint64_t CGContextDelegateCreateForContext(CFDictionaryRef theDict, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9, __n128 a10, __n128 a11, __n128 a12)
{
  CGFloat v13 = a12.n128_f64[0];
  CGFloat v14 = a11.n128_f64[0];
  CGFloat v15 = a10.n128_f64[0];
  CGFloat v16 = a9.n128_f64[0];
  if (!a2) {
    goto LABEL_85;
  }
  if (*(_DWORD *)(a2 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextDelegateCreateForContext", a2, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  uint64_t v18 = *(void **)(a2 + 40);
  if (!v18) {
    goto LABEL_85;
  }
  uint64_t v19 = (uint64_t (*)(__n128, __n128, __n128, __n128))v18[26];
  if (v19)
  {
    uint64_t v20 = v19(a9, a10, a11, a12);
    if (v20) {
      return v20;
    }
    uint64_t v18 = *(void **)(a2 + 40);
    if (!v18) {
      goto LABEL_85;
    }
  }
  if (v18[16]) {
    goto LABEL_85;
  }
  if (!theDict) {
    goto LABEL_13;
  }
  Value = CFDictionaryGetValue(theDict, @"kCGContextColorSpace");
  if (Value)
  {
LABEL_10:
    CFRetain(Value);
    goto LABEL_18;
  }
  uint64_t v18 = *(void **)(a2 + 40);
  if (v18)
  {
LABEL_13:
    uint64_t v29 = (uint64_t (*)(void))v18[4];
    if (v29)
    {
      uint64_t v30 = (void *)v29();
      if (v30)
      {
        Cache = CGColorTransformGetCache(v30);
        if (Cache)
        {
          Value = (void *)Cache[2];
          if (Value) {
            goto LABEL_10;
          }
        }
      }
    }
  }
  Value = CGColorSpaceCreateDeviceRGB();
LABEL_18:
  if (theDict) {
    unint64_t v32 = (unint64_t)CFDictionaryGetValue(theDict, @"kCGContextBackgroundColor");
  }
  else {
    unint64_t v32 = 0;
  }
  if (*(_DWORD *)(a2 + 24) != 4) {
    goto LABEL_29;
  }
  if (*(_DWORD *)(a2 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGBitmapContextGetBitmapInfo", a2, v23, v24, v25, v26, v27, v28);
    if (*(_DWORD *)(a2 + 16) == 1129601108 && *(_DWORD *)(a2 + 24) == 4)
    {
      int v33 = 0;
      goto LABEL_27;
    }
    handle_invalid_context((char)"CGBitmapContextGetBitsPerComponent", a2, v23, v24, v25, v26, v27, v28);
LABEL_29:
    unint64_t v34 = 0;
    int v33 = 0;
    goto LABEL_30;
  }
  int v33 = *(unsigned char *)(*(void *)(a2 + 32) + 41) & 1;
LABEL_27:
  unint64_t v34 = *(void *)(*(void *)(a2 + 32) + 80);
LABEL_30:
  if (v32)
  {
    if ((v32 & 0x8000000000000000) != 0) {
      double Alpha = CGTaggedColorGetAlpha(v32, v22, v23, v24, v25, v26, v27, v28);
    }
    else {
      double Alpha = *(double *)(v32 + 8 * *(void *)(v32 + 56) + 56);
    }
    BOOL v36 = Alpha < 1.0;
  }
  else
  {
    BOOL v36 = 1;
  }
  if (Value)
  {
    int v37 = *(_DWORD *)(Value[3] + 28);
    switch(v37)
    {
      case 2:
        uint64_t v46 = 16;
        if (v34 >= 9)
        {
          int v47 = v33;
        }
        else
        {
          uint64_t v46 = 8;
          int v47 = 1;
        }
        if (v33) {
          uint64_t v39 = 32;
        }
        else {
          uint64_t v39 = v46;
        }
        if (v47) {
          int v40 = 0x2000;
        }
        else {
          int v40 = 4096;
        }
        unsigned int v41 = 4;
        goto LABEL_80;
      case 1:
        if (v36) {
          int v42 = 4097;
        }
        else {
          int v42 = 4101;
        }
        uint64_t v43 = 16;
        if (v36) {
          int v44 = 8194;
        }
        else {
          int v44 = 8198;
        }
        if (v34 > 8) {
          int v44 = v42;
        }
        else {
          uint64_t v43 = 8;
        }
        if (v36) {
          int v45 = 8193;
        }
        else {
          int v45 = 8197;
        }
        unsigned int v41 = 4;
        if (v33) {
          uint64_t v39 = 32;
        }
        else {
          uint64_t v39 = v43;
        }
        if (!v33) {
          unsigned int v41 = 4;
        }
        BOOL v36 = 0;
        if (v33) {
          int v40 = v45;
        }
        else {
          int v40 = v44;
        }
LABEL_80:
        uint64_t v48 = v41 * (unint64_t)v39;
        v65.origin.CGFloat x = v16;
        v65.origin.CGFloat y = v15;
        v65.size.double width = v14;
        v65.size.double height = v13;
        CGRect v66 = CGRectIntegral(v65);
        uint64_t v49 = *(void *)(a2 + 112);
        double v50 = *(double *)(v49 + 8);
        double v51 = *(double *)(v49 + 16);
        if (v36) {
          uint64_t v52 = v39;
        }
        else {
          uint64_t v52 = 0;
        }
        uint64_t v53 = CGBitmapContextInfoCreate(0, (int)v66.origin.x, (int)v66.origin.y, (unint64_t)v66.size.width, (unint64_t)v66.size.height, v39, v48, 0, v50, v51, Value, v40, v52, 0, 0);
        CGColorSpaceRelease((CGColorSpaceRef)Value);
        if (v53)
        {
          uint64_t v20 = bitmap_context_delegate_create(v53, (uint64_t)theDict);
          CGBitmapContextInfoRelease(v53);
          if (v20) {
            return v20;
          }
        }
        goto LABEL_85;
      case 0:
        uint64_t v38 = 16;
        if (v34 < 9) {
          uint64_t v38 = 8;
        }
        if (v33) {
          uint64_t v39 = 32;
        }
        else {
          uint64_t v39 = v38;
        }
        if (v33) {
          int v40 = 0x2000;
        }
        else {
          int v40 = (v34 > 8) << 12;
        }
        unsigned int v41 = 1;
        goto LABEL_80;
    }
  }
  CGColorSpaceRelease((CGColorSpaceRef)Value);
LABEL_85:
  if (theDict)
  {
    MutableCopCGFloat y = CFDictionaryCreateMutableCopy(0, 0, theDict);
    if (!CFDictionaryGetValue(MutableCopy, @"kCGContextGroup")
      && !CFDictionaryGetValue(MutableCopy, @"kCGContextColorSpace")
      && MutableCopy
      && *MEMORY[0x1E4F1CFD0])
    {
      CFDictionarySetValue(MutableCopy, @"kCGContextGroup", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    CFDictionaryRemoveValue(MutableCopy, @"kCGContextBoundingBox");
  }
  else
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    MutableCopCGFloat y = Mutable;
    float v55 = (const CGRect *)*MEMORY[0x1E4F1CFD0];
    if (Mutable) {
      BOOL v62 = v55 == 0;
    }
    else {
      BOOL v62 = 1;
    }
    if (!v62) {
      CFDictionarySetValue(Mutable, @"kCGContextGroup", v55);
    }
  }
  *(CGFloat *)unint64_t v64 = v16;
  *(CGFloat *)&v64[1] = v15;
  *(CGFloat *)&v64[2] = v14;
  *(CGFloat *)&v64[3] = v13;
  if (CG::DisplayList::createCGDisplayList(MutableCopy, (const __CFDictionary *)v64, v55, v56, v57, v58, v59, v60)) {
    CG::DisplayList::createContextDelegate();
  }
  uint64_t v20 = 0;
  CFRelease(MutableCopy);
  return v20;
}

uint64_t dlRecorder_BeginLayer(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, CGFloat x, double a10, CGFloat a11, CGFloat a12)
{
  if (!a1 || (uint64_t v12 = a1, (v13 = *(void *)(a1 + 288)) == 0))
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, (char)"dlRecorder_BeginLayer");
    return 0;
  }
  uint64_t v22 = (double *)CG::DisplayListRecorder::currentDisplayList(*(CFArrayRef **)(a1 + 288));
  if (!v22) {
    return 0;
  }
  uint64_t v23 = v22;
  if (!a5 || *(void *)(v13 + 16) || CFArrayGetCount(*(CFArrayRef *)(v13 + 8)) > 1)
  {
    double Bounds = CGClipStackGetBounds(*(double **)(a3 + 112));
    CGFloat y = v25;
    CGFloat width = v26;
    CGFloat height = v27;
    double v32 = v23[5];
    double v33 = v23[6];
    double v34 = v23[7];
    double v35 = v23[8];
    if (v32 != -8.98846567e307 || v33 != -8.98846567e307 || v34 != 1.79769313e308 || v35 != 1.79769313e308)
    {
      double v39 = Bounds;
      CGRect v75 = CGRectIntersection(*(CGRect *)(&v25 - 1), *(CGRect *)&v32);
      double Bounds = v75.origin.x;
      CGFloat y = v75.origin.y;
      CGFloat width = v75.size.width;
      CGFloat height = v75.size.height;
    }
    uint64_t v40 = *(void *)(*(void *)(a3 + 120) + 16);
    if (v40)
    {
      long long v41 = *(_OWORD *)(a2 + 40);
      v72[0] = *(_OWORD *)(a2 + 24);
      v72[1] = v41;
      v72[2] = *(_OWORD *)(a2 + 56);
      double Bounds = CGStyleGetDrawBoundingBoxWithMatrix(v40, v72, Bounds, y, width, height);
      CGFloat y = v42;
      CGFloat width = v43;
      CGFloat height = v44;
    }
    if (a4 && CGCFDictionaryGetRect(a4, @"kCGContextBoundingBox", (UInt8 *)&v73))
    {
      v76.origin.CGFloat x = x;
      v76.origin.CGFloat y = a10;
      v76.size.CGFloat width = a11;
      v76.size.CGFloat height = a12;
      CGRect v77 = CGRectIntersection(v76, v73);
      CGFloat x = v77.origin.x;
      a10 = v77.origin.y;
      a11 = v77.size.width;
      a12 = v77.size.height;
      CGRect v73 = v77;
    }
    else
    {
      v73.origin.CGFloat x = x;
      v73.origin.CGFloat y = a10;
      v73.size.CGFloat width = a11;
      v73.size.CGFloat height = a12;
    }
    if (x != -8.98846567e307 || a10 != -8.98846567e307 || a11 != 1.79769313e308 || a12 != 1.79769313e308)
    {
      long long v45 = *(_OWORD *)(a3 + 40);
      *(_OWORD *)&v71.a = *(_OWORD *)(a3 + 24);
      *(_OWORD *)&v71.c = v45;
      *(_OWORD *)&v71.tCGFloat x = *(_OWORD *)(a3 + 56);
      CGFloat v46 = x;
      *(double *)&long long v45 = a10;
      CGFloat v47 = a11;
      CGFloat v48 = a12;
      CGRect v78 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v45 - 8), &v71);
      DrawBoundingBoxWithMatriCGFloat x = v78.origin.x;
      CGFloat v50 = v78.origin.y;
      CGFloat v51 = v78.size.width;
      CGFloat v52 = v78.size.height;
      CGRect v73 = v78;
      uint64_t v53 = *(void *)(*(void *)(a3 + 120) + 16);
      if (v53)
      {
        long long v54 = *(_OWORD *)(a2 + 40);
        v70[0] = *(_OWORD *)(a2 + 24);
        v70[1] = v54;
        _DWORD v70[2] = *(_OWORD *)(a2 + 56);
        DrawBoundingBoxWithMatriCGFloat x = CGStyleGetDrawBoundingBoxWithMatrix(v53, v70, v78.origin.x, v50, v78.size.width, v78.size.height);
        CGFloat v50 = v55;
        CGFloat v51 = v56;
        CGFloat v52 = v57;
        v73.origin.CGFloat x = DrawBoundingBoxWithMatrix;
        v73.origin.CGFloat y = v55;
        v73.size.CGFloat width = v56;
        v73.size.CGFloat height = v57;
      }
      v79.origin.CGFloat x = Bounds;
      v79.origin.CGFloat y = y;
      v79.size.CGFloat width = width;
      v79.size.CGFloat height = height;
      CGRect v80 = CGRectIntersection(v79, *(CGRect *)&DrawBoundingBoxWithMatrix);
      double Bounds = v80.origin.x;
      CGFloat y = v80.origin.y;
      CGFloat width = v80.size.width;
      CGFloat height = v80.size.height;
    }
    v81.origin.CGFloat x = Bounds;
    v81.origin.CGFloat y = y;
    v81.size.CGFloat width = width;
    v81.size.CGFloat height = height;
    CGRect v82 = CGRectIntegral(v81);
    CGFloat v58 = v82.origin.x;
    CGFloat v59 = v82.origin.y;
    CGFloat v60 = v82.size.width;
    CGFloat v61 = v82.size.height;
    BOOL v62 = CG::DisplayListRecorder::initializeGroupInfoDictionary((uint64_t)v23, a4);
    *(CGFloat *)BOOL v74 = v58;
    *(CGFloat *)&v74[1] = v59;
    *(CGFloat *)&v74[2] = v60;
    *(CGFloat *)&v74[3] = v61;
    CGDisplayList = (const void *)CG::DisplayList::createCGDisplayList(v62, (const __CFDictionary *)v74, v63, v64, v65, v66, v67, v68);
    if (v62) {
      CFRelease(v62);
    }
    if (CGDisplayList)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(v13 + 8), CGDisplayList);
      CFRelease(CGDisplayList);
      return v12;
    }
    return 0;
  }
  CG::DisplayListResourceImage::setImage((CG::DisplayListResourceImage *)v13, a5);
  return v12;
}

void *CGBitmapContextCreateWithDictionary(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, int a8, double a9, double a10, uint64_t a11)
{
  return CGBitmapContextCreateWithDataAndDictionary(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0, 0, a11);
}

CGImageRef rip_auto_context_create_image(uint64_t a1)
{
  if (a1) {
    uint64_t v1 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v1 = 0;
  }
  uint64_t v2 = (pthread_mutex_t *)(v1 + 112);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 112));
  uint64_t v3 = (CGContext *)rip_auto_context_rasterization_loop(v1);
  CGImageRef Image = CGBitmapContextCreateImage(v3);
  if (v3) {
    CFRelease(v3);
  }
  pthread_mutex_unlock(v2);
  return Image;
}

uint64_t rip_auto_context_rasterization_loop(uint64_t a1)
{
  values[1] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v2 = *(const void **)(a1 + 88);
  if (v2)
  {
    CFRetain(v2);
    return 0;
  }
  uint64_t v4 = *(const void **)(a1 + 80);
  if (!v4) {
    return 0;
  }
  CFRelease(v4);
  *(void *)(a1 + 80) = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 100);
  uint64_t v6 = *(unsigned int *)(a1 + 108);
  uint64_t v7 = *(unsigned __int8 *)(a1 + 104);
  uint64_t v148 = *(unsigned __int8 *)(a1 + 105);
  if (*(unsigned char *)(a1 + 104))
  {
    int v8 = 1;
  }
  else
  {
    if (v5 == 1 && v6 == 1)
    {
      int v9 = *(_DWORD *)(a1 + 96);
      int v10 = *(unsigned __int8 *)(a1 + 105);
      uint64_t v11 = *(void *)a1;
      uint64_t v154 = *(void *)(a1 + 8);
LABEL_17:
      if (v10 == 1) {
        int v12 = 2;
      }
      else {
        int v12 = 1;
      }
      uint64_t v13 = (CFStringRef *)&kCGColorSpaceGenericGrayGamma2_2;
      goto LABEL_31;
    }
    if (v5 == 1) {
      int v8 = 2;
    }
    else {
      int v8 = 1;
    }
  }
  if (*(unsigned char *)(a1 + 105)) {
    int v10 = v8;
  }
  else {
    int v10 = 5;
  }
  int v9 = *(_DWORD *)(a1 + 96);
  uint64_t v11 = *(void *)a1;
  uint64_t v154 = *(void *)(a1 + 8);
  if (v6 == 1) {
    goto LABEL_17;
  }
  switch(v10)
  {
    case 1u:
      int v12 = 3;
      goto LABEL_27;
    case 2u:
      int v12 = 7;
LABEL_27:
      uint64_t v13 = (CFStringRef *)&kCGColorSpaceExtendedSRGB;
      if (!*(unsigned char *)(a1 + 104)) {
        uint64_t v13 = (CFStringRef *)&kCGColorSpaceSRGB;
      }
      goto LABEL_31;
    case 5u:
      int v12 = 5;
      goto LABEL_27;
  }
  uint64_t v13 = (CFStringRef *)&kCGColorSpaceGenericGrayGamma2_2;
  int v12 = 1;
LABEL_31:
  CGColorSpaceRef v14 = CGColorSpaceCreateWithName(*v13);
  CGColorSpaceRef v18 = v14;
  if (v14)
  {
    if (*(unsigned char *)(*((void *)v14 + 3) + 14)) {
      int v19 = v9;
    }
    else {
      int v19 = 1;
    }
  }
  else
  {
    int v19 = 1;
  }
  int v20 = (v10 - 1) < 2;
  int v22 = v12 == 7 || v19 != 1;
  if (v14) {
    uint64_t v23 = *(void *)(*((void *)v14 + 3) + 48);
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v150 = v6;
  uint64_t v151 = v5;
  uint64_t v149 = v7;
  switch(v19)
  {
    case 1:
      uint64_t v24 = 1;
      break;
    case 4:
      uint64_t v24 = 4;
      break;
    case 5:
      uint64_t v24 = 2;
      break;
    default:
      _CGHandleAssert("rip_auto_context_get_aligned_bytes_per_row_for_info", 961, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/AutomaticBitmapContext/RIPAutomaticContext.c", "component_size != 0", "component type not supported (%u)", v15, v16, v17, v19);
  }
  int v152 = v12;
  if (v12 != 1) {
    ++v23;
  }
  uint64_t v25 = v24 * v23;
  uint64_t v27 = *(void *)(a1 + 184);
  uint64_t v26 = *(void *)(a1 + 192);
  uint64_t v28 = (long long *)(a1 + 184);
  float64_t v29 = *(double *)(a1 + 200);
  float64_t v30 = *(double *)(a1 + 208);
  unint64_t v31 = (v24 * v23 * v11 + 31) & 0xFFFFFFFFFFFFFFE0;
  uint64_t v32 = *(void *)(a1 + 216);
  unsigned int v33 = *(_DWORD *)(a1 + 224);
  unsigned int v34 = *(_DWORD *)(a1 + 228);
  uint64_t v35 = *(void *)(a1 + 232);
  BOOL v36 = *(CGColorSpace **)(a1 + 240);
  unsigned int v37 = *(unsigned __int8 *)(a1 + 248);
  int v38 = *(_DWORD *)(a1 + 252);
  uint64_t v147 = v11;
  char v146 = v20;
  if (v11 != v26 || v154 != *(void *)&v29) {
    goto LABEL_78;
  }
  BOOL v39 = v25 == *(void *)&v30 && v31 == v32;
  BOOL v40 = v39 && v19 == v33;
  BOOL v41 = v40 && v12 == v34;
  BOOL v42 = v41 && v35 == 0;
  BOOL v43 = v42 && v37 == v20;
  if (!v43 || v38 != v22) {
    goto LABEL_78;
  }
  uint64_t v143 = v24 * v23;
  space = v14;
  int v45 = v22;
  unint64_t v46 = (v24 * v23 * v11 + 31) & 0xFFFFFFFFFFFFFFE0;
  int v47 = *(_DWORD *)(a1 + 252);
  double v141 = *(double *)(a1 + 200);
  int v142 = v19;
  CGFloat v48 = *(CGColorSpace **)(a1 + 240);
  uint64_t v49 = *(void *)(a1 + 192);
  double v50 = *(double *)(a1 + 208);
  uint64_t v140 = *(void *)(a1 + 216);
  char v137 = *(unsigned char *)(a1 + 248);
  unsigned int v37 = *(_DWORD *)(a1 + 224);
  unsigned int v139 = *(_DWORD *)(a1 + 228);
  uint64_t v138 = *(void *)(a1 + 232);
  BOOL v51 = CGColorSpaceEqualToColorSpace((uint64_t)v14, (uint64_t)v36);
  uint64_t v35 = v138;
  unsigned int v34 = v139;
  unsigned int v33 = v37;
  LOBYTE(v37) = v137;
  uint64_t v32 = v140;
  float64_t v29 = v141;
  float64_t v30 = v50;
  uint64_t v26 = v49;
  BOOL v36 = v48;
  CGColorSpaceRef v18 = space;
  int v38 = v47;
  unint64_t v31 = v46;
  int v22 = v45;
  int v19 = v142;
  uint64_t v25 = v143;
  if (!v51) {
    goto LABEL_78;
  }
  if (*(void *)(a1 + 40))
  {
    CGColorSpaceRelease(space);
    int v57 = 0;
  }
  else
  {
LABEL_78:
    uint64_t v58 = v150 | (v149 << 32) | (v148 << 40);
    uint64_t v59 = *(void *)(a1 + 48);
    int v145 = v22;
    if (v59)
    {
      unint64_t v60 = v31;
      uint64_t v61 = *(void *)(a1 + 256);
      if (v61)
      {
        BOOL v62 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, long long *))(v59 + 16);
        *(void *)&long long v156 = v27;
        *((void *)&v156 + 1) = v26;
        v157.f64[0] = v29;
        v157.f64[1] = v30;
        *(void *)&long long v158 = v32;
        *((void *)&v158 + 1) = __PAIR64__(v34, v33);
        *(void *)&long long v159 = v35;
        *((void *)&v159 + 1) = v36;
        LOBYTE(v160) = v37;
        *(_WORD *)((char *)&v160 + 1) = *(_WORD *)(a1 + 249);
        uint64_t v63 = a1 + 249;
        BYTE3(v160) = *(unsigned char *)(a1 + 251);
        HIDWORD(v160) = v38;
        v62(v59, v61, v151 << 32, v58, &v156);
        *(void *)(a1 + 256) = 0;
        BOOL v36 = *(CGColorSpace **)(a1 + 240);
      }
      else
      {
        uint64_t v63 = a1 + 249;
      }
    }
    else
    {
      uint64_t v63 = a1 + 249;
      unint64_t v60 = v31;
    }
    CGColorSpaceRelease(v36);
    *(void *)(a1 + 248) = 0;
    *(_OWORD *)(a1 + 216) = 0u;
    *(_OWORD *)(a1 + 232) = 0u;
    *uint64_t v28 = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    if (v18) {
      CFRetain(v18);
    }
    *(void *)(a1 + 184) = 0;
    *(void *)(a1 + 192) = v147;
    *(void *)(a1 + 200) = v154;
    *(void *)(a1 + 208) = v25;
    *(void *)(a1 + 216) = v60;
    *(_DWORD *)(a1 + 224) = v19;
    *(_DWORD *)(a1 + 228) = v152;
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = v18;
    *(unsigned char *)(a1 + 248) = v146;
    *(_WORD *)uint64_t v63 = 0;
    *(unsigned char *)(v63 + 2) = 0;
    *(_DWORD *)(a1 + 252) = v145;
    uint64_t v64 = *(void *)(a1 + 32);
    if (v64)
    {
      long long v65 = *(_OWORD *)(a1 + 232);
      long long v158 = *(_OWORD *)(a1 + 216);
      long long v159 = v65;
      uint64_t v160 = *(void *)(a1 + 248);
      float64x2_t v66 = *(float64x2_t *)(a1 + 200);
      long long v156 = *v28;
      float64x2_t v157 = v66;
      if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, long long *))(v64 + 16))(v64, v151 << 32, v58, &v156) & 1) == 0)
      {
        CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 240));
        *(void *)(a1 + 248) = 0;
        *(_OWORD *)(a1 + 216) = 0u;
        *(_OWORD *)(a1 + 232) = 0u;
        *uint64_t v28 = 0u;
        *(_OWORD *)(a1 + 200) = 0u;
        *(_OWORD *)keys = v156;
        float64x2_t v162 = v157;
        long long v163 = v158;
        uint64_t v67 = *((void *)&v159 + 1);
        uint64_t v164 = v159;
        uint64_t v68 = v160;
        if (*((void *)&v159 + 1)) {
          CFRetain(*((CFTypeRef *)&v159 + 1));
        }
        float64x2_t v69 = v162;
        *uint64_t v28 = *(_OWORD *)keys;
        *(float64x2_t *)(a1 + 200) = v69;
        *(_OWORD *)(a1 + 216) = v163;
        *(void *)(a1 + 232) = v164;
        *(void *)(a1 + 240) = v67;
        *(void *)(a1 + 248) = v68;
      }
    }
    int v57 = 1;
  }
  unint64_t v70 = *(void *)(a1 + 192);
  uint64_t v71 = *(void *)(a1 + 200);
  uint64_t v72 = *(void *)(a1 + 216);
  int v73 = *(_DWORD *)(a1 + 224);
  BOOL v74 = *(void **)(a1 + 240);
  uint64_t v75 = *(unsigned __int8 *)(a1 + 248);
  double v76 = *(double *)(a1 + 16);
  double v77 = *(double *)(a1 + 24);
  int v78 = 7;
  uint64_t v79 = *(void *)(a1 + 64);
  switch(*(_DWORD *)(a1 + 228))
  {
    case 0:
      goto LABEL_105;
    case 1:
    case 9:
      goto LABEL_92;
    case 2:
      int v78 = 1;
      goto LABEL_105;
    case 3:
      if (*(unsigned char *)(a1 + 248)) {
        int v78 = 1;
      }
      else {
        int v78 = 3;
      }
      goto LABEL_105;
    case 4:
      if (*(unsigned char *)(a1 + 248)) {
        int v78 = 2;
      }
      else {
        int v78 = 4;
      }
      goto LABEL_105;
    case 5:
      BOOL v80 = v75 == 0;
      int v81 = 5;
      goto LABEL_102;
    case 6:
      BOOL v80 = v75 == 0;
      int v81 = 6;
LABEL_102:
      if (v80) {
        int v78 = v81;
      }
      else {
        int v78 = 0;
      }
      goto LABEL_105;
    case 7:
      if (v73 != 1) {
        goto LABEL_92;
      }
      BOOL v113 = v75 == 0;
      int v114 = 8194;
      goto LABEL_136;
    case 8:
      if (v73 == 1)
      {
        BOOL v113 = v75 == 0;
        int v114 = 8193;
LABEL_136:
        if (v113) {
          int v78 = 0;
        }
        else {
          int v78 = v114;
        }
        uint64_t v84 = 8;
        if (!v74) {
          goto LABEL_107;
        }
      }
      else
      {
LABEL_92:
        int v78 = 0;
LABEL_105:
        CGRect v82 = @"Provided CGBitmapContextInfo results in bits_per_component equal zero";
        CFIndex v83 = -1;
        uint64_t v84 = 8;
        switch(v73)
        {
          case 1:
            break;
          case 2:
          case 5:
            uint64_t v84 = 16;
            if (!v74) {
              goto LABEL_107;
            }
            goto LABEL_110;
          case 4:
            uint64_t v84 = 32;
            break;
          default:
            goto LABEL_142;
        }
        if (!v74)
        {
LABEL_107:
          int v85 = 0;
          uint64_t v86 = v78 != 0;
          goto LABEL_116;
        }
      }
LABEL_110:
      uint64_t v87 = v74[3];
      if (v78) {
        uint64_t v86 = *(void *)(v87 + 48) + 1;
      }
      else {
        uint64_t v86 = *(void *)(v87 + 48);
      }
      if (*(unsigned char *)(v87 + 13)) {
        int v85 = 4352;
      }
      else {
        int v85 = 0;
      }
LABEL_116:
      BOOL v88 = *(char **)(a1 + 40);
      if (v88)
      {
        unsigned int v89 = *(char **)(a1 + 256);
        int v155 = v57;
        uint64_t v153 = *(void *)(a1 + 64);
        if (v57)
        {
          if (v89) {
            _CGHandleAssert("rip_auto_context_create_bitmap_context", 469, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/AutomaticBitmapContext/RIPAutomaticContext.c", "data->current_provider == NULL", "buffer provider is missing", v72, v55, v56, v136);
          }
          uint64_t v90 = *(void *)(a1 + 216);
          uint64_t v91 = (uint64_t (*)(char *, unint64_t, unint64_t, long long *))*((void *)v88 + 2);
          unint64_t v92 = *(unsigned int *)(a1 + 108) | ((unint64_t)*(unsigned __int8 *)(a1 + 104) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 105) << 40);
          unint64_t v93 = (unint64_t)*(unsigned int *)(a1 + 100) << 32;
          long long v94 = *(_OWORD *)(a1 + 232);
          long long v158 = *(_OWORD *)(a1 + 216);
          long long v159 = v94;
          uint64_t v160 = *(void *)(a1 + 248);
          float64x2_t v95 = *(float64x2_t *)(a1 + 200);
          long long v156 = *v28;
          float64x2_t v157 = v95;
          uint64_t v96 = v91(v88, v93, v92, &v156);
          if (!v96)
          {
            CGRect v82 = @"allocate callback returned NULL CGBufferProviderRef";
            CFIndex v83 = -3;
            goto LABEL_142;
          }
          unsigned int v89 = (char *)v96;
          *(void *)(a1 + 256) = v96;
        }
        else
        {
          uint64_t v90 = *(void *)(a1 + 216);
          if (!v89) {
            _CGHandleAssert("rip_auto_context_create_bitmap_context", 486, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/AutomaticBitmapContext/RIPAutomaticContext.c", "buffer_provider != NULL", "buffer provider is missing2", v72, v55, v56, v136);
          }
        }
        BOOL v88 = CGBufferLockBytePtr(v89);
        int v97 = (void (*)(uint64_t, uint64_t))rip_auto_context_release_bitmap_context_data;
        if (!v88) {
          _CGHandleAssert("rip_auto_context_handle_error", 162, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/AutomaticBitmapContext/RIPAutomaticContext.c", "0", "unhandled error code %d", v99, v100, v101, -4);
        }
        uint64_t v98 = a1;
        uint64_t v72 = v90;
        int v57 = v155;
        uint64_t v79 = v153;
      }
      else
      {
        int v97 = 0;
        uint64_t v98 = 0;
      }
      uint64_t v102 = CGBitmapContextCreateWithDataAndDictionary((uint64_t)v88, v70, v71, v84, v86 * v84, v72, v74, v85 | v78, v76, v77, v97, v98, v79);
      if (v102)
      {
        uint64_t v3 = (uint64_t)v102;
        if (v57)
        {
          CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 176));
          if (Count)
          {
            CFIndex v104 = Count;
            for (CFIndex i = 0; i != v104; ++i)
            {
              ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), i);
              CGDisplayListDrawInContext((uint64_t)ValueAtIndex, v3, v107, v108, v109, v110, v111, v112);
            }
          }
        }
        goto LABEL_146;
      }
      CGRect v82 = @"Failed to create bitmap context when using provided CGBitmapContextInfo";
      CFIndex v83 = -2;
LABEL_142:
      if (*(void *)(a1 + 56))
      {
        keys[0] = *(void **)MEMORY[0x1E4F1D140];
        values[0] = v82;
        CFDictionaryRef v115 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFErrorRef v116 = CFErrorCreate(0, @"CGBitmapContextWithCallbacksDomain", v83, v115);
        CFRelease(v115);
        __int16 v117 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
        long long v118 = *(_OWORD *)(a1 + 232);
        long long v158 = *(_OWORD *)(a1 + 216);
        long long v159 = v118;
        uint64_t v160 = *(void *)(a1 + 248);
        float64x2_t v119 = *(float64x2_t *)(a1 + 200);
        long long v156 = *v28;
        float64x2_t v157 = v119;
        v117();
        CFRelease(v116);
        uint64_t v3 = 0;
        if (*(void *)(a1 + 56)) {
          goto LABEL_147;
        }
      }
      else
      {
        uint64_t v3 = 0;
      }
LABEL_146:
      CGDisplayListDrawInContext(*(void *)(a1 + 72), v3, v52, v53, v54, v72, v55, v56);
LABEL_147:
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 176), *(const void **)(a1 + 72));
      int v126 = *(const void **)(a1 + 72);
      if (v126) {
        CFRelease(v126);
      }
      long long v156 = 0uLL;
      float64x2_t v157 = vcvtq_f64_u64(*(uint64x2_t *)a1);
      uint64_t CGDisplayList = CG::DisplayList::createCGDisplayList(0, (const __CFDictionary *)&v156, v120, v121, v122, v123, v124, v125);
      *(void *)(a1 + 72) = CGDisplayList;
      *(void *)(a1 + 80) = CGDisplayListContextCreate(CGDisplayList, v128, v129, v130, v131, v132, v133, v134);
      return v3;
    default:
      _CGHandleAssert("rip_auto_context_get_alpha_info_from_bitmap_context_info", 406, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/AutomaticBitmapContext/RIPAutomaticContext.c", "0", "unhandled context model %d", v72, v55, v56, *(_DWORD *)(a1 + 228));
  }
}

void CGDisplayListDrawInContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 && *(_DWORD *)(a2 + 16) == 1129601108) {
    CGDisplayListDrawInContextDelegate(a1, *(void *)(a2 + 40), *(_DWORD **)(a2 + 112), *(void *)(a2 + 96), 0);
  }
  else {
    handle_invalid_context((char)"CGDisplayListDrawInContext", a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t CGDisplayListCreateWithRect(CG::DisplayList *a1, double a2, double a3, double a4, double a5, uint64_t a6, const CGRect *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(double *)uint64_t v13 = a2;
  *(double *)&v13[1] = a3;
  *(double *)&v13[2] = a4;
  *(double *)&v13[3] = a5;
  return CG::DisplayList::createCGDisplayList(a1, (const __CFDictionary *)v13, a7, a8, a9, a10, a11, a12);
}

uint64_t CG::DisplayList::createCGDisplayList(CG::DisplayList *this, const __CFDictionary *a2, const CGRect *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_ZZZ22CGDisplayListGetTypeIDEUb_E4once != -1) {
    dispatch_once(&_ZZZ22CGDisplayListGetTypeIDEUb_E4once, &__block_literal_global_161_15385);
  }
  uint64_t Instance = CGTypeCreateInstance(CGDisplayListGetTypeID::display_list2_type_id, 824, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v11 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = &unk_1ED094828;
    *(void *)(Instance + 24) = Instance;
    *(void *)(Instance + 32) = 0;
    long long v12 = *(_OWORD *)a2;
    *(_OWORD *)(Instance + 56) = *((_OWORD *)a2 + 1);
    *(_OWORD *)(Instance + 40) = v12;
    *(_DWORD *)(Instance + 72) = 16843008;
    *(_WORD *)(Instance + 76) = 0;
    *(unsigned char *)(Instance + 78) = 0;
    *(_DWORD *)(Instance + 80) = 0;
    *(CGRect *)(Instance + 88) = CGRectNull;
    *(_OWORD *)(Instance + 120) = 0u;
    uint64_t v13 = malloc_type_malloc(0x58uLL, 0xBDE48346uLL);
    *(void *)(v11 + 136) = v13;
    *uint64_t v13 = 0u;
    v13[1] = 0u;
    v13[2] = 0u;
    v13[3] = 0u;
    void v13[4] = 0u;
    *((void *)v13 + 10) = 0;
    *(_OWORD *)((char *)v13 + 8) = xmmword_1850CDE60;
    *((void *)v13 + 4) = 0x61C8864E7A143579;
    *(_OWORD *)(v11 + 152) = 0u;
    *(void *)(v11 + 144) = v11 + 152;
    *(_OWORD *)(v11 + 176) = 0u;
    *(void *)(v11 + 168) = v11 + 176;
    *(_OWORD *)(v11 + 200) = 0u;
    *(void *)(v11 + 192) = v11 + 200;
    *(_OWORD *)(v11 + 224) = 0u;
    *(void *)(v11 + 216) = v11 + 224;
    *(_OWORD *)(v11 + 248) = 0u;
    *(void *)(v11 + 240) = v11 + 248;
    *(_OWORD *)(v11 + 272) = 0u;
    *(void *)(v11 + 264) = v11 + 272;
    *(_OWORD *)(v11 + 296) = 0u;
    *(_OWORD *)(v11 + 320) = 0u;
    *(void *)(v11 + 288) = v11 + 296;
    *(void *)(v11 + 312) = v11 + 320;
    *(_OWORD *)(v11 + 344) = 0u;
    *(void *)(v11 + 336) = v11 + 344;
    *(_OWORD *)(v11 + 368) = 0u;
    *(void *)(v11 + 360) = v11 + 368;
    *(_OWORD *)(v11 + 392) = 0u;
    *(void *)(v11 + 384) = v11 + 392;
    *(_OWORD *)(v11 + 416) = 0u;
    *(void *)(v11 + 408) = v11 + 416;
    *(_OWORD *)(v11 + 432) = 0u;
    *(_OWORD *)(v11 + 448) = 0u;
    *(_DWORD *)(v11 + 464) = 1065353216;
    *(_OWORD *)(v11 + 480) = 0u;
    *(void *)(v11 + 472) = v11 + 480;
    *(_OWORD *)(v11 + 504) = 0u;
    *(void *)(v11 + 496) = v11 + 504;
    *(_OWORD *)(v11 + 528) = 0u;
    *(void *)(v11 + 520) = v11 + 528;
    *(_OWORD *)(v11 + 552) = 0u;
    *(void *)(v11 + 544) = v11 + 552;
    *(_OWORD *)(v11 + 576) = 0u;
    *(void *)(v11 + 568) = v11 + 576;
    *(_OWORD *)(v11 + 592) = 0u;
    *(void *)(v11 + 608) = 0;
    CG::DisplayList::setAuxInfo((CG::DisplayList *)(v11 + 16), this);
    CGColorSpaceRef v14 = (char *)operator new(0x90uLL);
    long long v15 = 0uLL;
    *(_OWORD *)(v14 + 8) = 0u;
    *(void *)CGColorSpaceRef v14 = &unk_1ED095548;
    *(_OWORD *)(v14 + 24) = 0u;
    *(CGRect *)(v14 + 40) = CGRectNull;
    *((_DWORD *)v14 + 18) = 0;
    *((void *)v14 + 10) = 850045863;
    *(_OWORD *)(v14 + 88) = 0u;
    *(_OWORD *)(v14 + 104) = 0u;
    *(_OWORD *)(v14 + 120) = 0u;
    *((void *)v14 + 17) = 0;
    *(void *)&long long v16 = v14 + 24;
    *((void *)&v16 + 1) = v14;
    uint64_t v17 = *(std::__shared_weak_count **)(v11 + 128);
    *(_OWORD *)(v11 + 120) = v16;
    if (v17)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v17);
      long long v15 = 0uLL;
    }
    *(_DWORD *)(v11 + 616) = -1;
    *(_OWORD *)(v11 + 624) = v15;
    *(_OWORD *)(v11 + 640) = v15;
    *(_OWORD *)(v11 + 656) = v15;
    *(_OWORD *)(v11 + 672) = v15;
    *(_OWORD *)(v11 + 688) = v15;
    *(_OWORD *)(v11 + 704) = v15;
    *(_OWORD *)(v11 + 720) = v15;
    *(_OWORD *)(v11 + 736) = v15;
    *(_OWORD *)(v11 + 752) = v15;
    *(_OWORD *)(v11 + 768) = v15;
    *(_OWORD *)(v11 + 784) = v15;
    *(_OWORD *)(v11 + 800) = v15;
    *(_OWORD *)(v11 + 816) = v15;
    *(void *)(v11 + 832) = 0;
  }
  return v11;
}

void sub_184C7C268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::vector<std::shared_ptr<CG::DisplayListEntry const>>::__destroy_vector::operator()[abi:fe180100]((void ***)va);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 576));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 552));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 528));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 504));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 480));
  std::__hash_table<std::shared_ptr<CG::DisplayListResourceDisplayList>,CG::HashResourceDisplayList,CG::EqualsResourceDisplayList,std::allocator<std::shared_ptr<CG::DisplayListResourceDisplayList>>>::~__hash_table(v8);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 416));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 392));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 368));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 344));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 320));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 296));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 272));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 248));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 224));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 200));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 176));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*(void **)(v6 + 152));
  free(*(void **)(v6 + 136));
  int v10 = *(std::__shared_weak_count **)(v6 + 128);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v10);
  }
  applesauce::CF::ObjectRef<__CFDictionary const*>::~ObjectRef(v7);
  _Unwind_Resume(a1);
}

double CG::DisplayList::setAuxInfo(CG::DisplayList *this, const __CFDictionary *a2)
{
  if (a2)
  {
    CopCGFloat y = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    uint64_t v5 = (const void *)*((void *)this + 2);
    *((void *)this + 2) = Copy;
    if (v5) {
      CFRelease(v5);
    }
    BOOL v19 = 0;
    int v6 = CGCFDictionaryGetBoolean(a2, @"trackShape", &v19) ^ 1;
    if (v19) {
      LOBYTE(v6) = 1;
    }
    *((unsigned char *)this + 57) = v6;
    BOOL v20 = 0;
    int v7 = CGCFDictionaryGetBoolean(a2, @"trackDrawing", &v20) ^ 1;
    if (v20) {
      LOBYTE(v7) = 1;
    }
    *((unsigned char *)this + 58) = v7;
    BOOL v21 = 0;
    int v8 = CGCFDictionaryGetBoolean(a2, @"trackColors", &v21) ^ 1;
    if (v21) {
      LOBYTE(v8) = 1;
    }
    *((unsigned char *)this + 59) = v8;
    BOOL v22 = 0;
    char Boolean = CGCFDictionaryGetBoolean(a2, @"trackGlyphs", &v22);
    if (v22) {
      char v10 = Boolean;
    }
    else {
      char v10 = 0;
    }
    *((unsigned char *)this + 60) = v10;
    BOOL v23 = 0;
    char v11 = CGCFDictionaryGetBoolean(a2, @"decodeImages", &v23);
    if (v23) {
      char v12 = v11;
    }
    else {
      char v12 = 0;
    }
    *((unsigned char *)this + 61) = v12;
    BOOL v24 = 0;
    char v13 = CGCFDictionaryGetBoolean(a2, @"clipRecordingToFrame", &v24);
    if (v24) {
      char v14 = v13;
    }
    else {
      char v14 = 0;
    }
    *((unsigned char *)this + 56) = v14;
    BOOL v25 = 0;
    char v15 = CGCFDictionaryGetBoolean(a2, @"evaluateShadingsOnRecord", &v25);
    if (v25) {
      char v17 = v15;
    }
    else {
      char v17 = 0;
    }
    *((unsigned char *)this + 62) = v17;
  }
  else
  {
    CGColorSpaceRef v18 = (const void *)*((void *)this + 2);
    *((void *)this + 2) = 0;
    if (v18) {
      CFRelease(v18);
    }
    *((_WORD *)this + 30) = 0;
    *(void *)&double result = 16843008;
    *((_DWORD *)this + 14) = 16843008;
    *((unsigned char *)this + 62) = 0;
  }
  return result;
}

void *CGBitmapContextCreateWithDataAndDictionary(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, int a8, double a9, double a10, void (*a11)(uint64_t, uint64_t), uint64_t a12, uint64_t a13)
{
  double result = (void *)CGBitmapContextInfoCreate(a1, 0, 0, a2, a3, a4, a5, a6, a9, a10, a7, a8, 0, a11, a12);
  if (result)
  {
    return bitmap_context_create((uint64_t)result, a13, (char)"CGBitmapContextCreateWithDataAndDictionary", v14, v15, v16, v17, v18);
  }
  return result;
}

uint64_t CGBitmapContextSetData(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 4)
  {
    uint64_t result = CGBitmapContextInfoCreate(a6, a2, a3, a4, a5, a7, a8, a9, *(double *)(*(void *)(a1 + 32) + 48), *(double *)(*(void *)(a1 + 32) + 56), *(void **)(*(void *)(a1 + 32) + 32), *(_DWORD *)(*(void *)(a1 + 32) + 40), 0, 0, 0);
    if (!result) {
      return result;
    }
    uint64_t v18 = result;
    if (bitmap_context_delegate_set_data_once != -1) {
      dispatch_once_f(&bitmap_context_delegate_set_data_once, 0, (dispatch_function_t)load_set_data);
    }
    if (set_data && (set_data() & 1) != 0)
    {
      CGBitmapContextInfoRelease(*(void *)(a1 + 32));
      *(void *)(a1 + 32) = v18;
      return 1;
    }
    CGPostError((uint64_t)"%s: unable to set bitmap context data", v11, v12, v13, v14, v15, v16, v17, (char)"CGBitmapContextSetData");
    CGBitmapContextInfoRelease(v18);
  }
  else
  {
    handle_invalid_context((char)"CGBitmapContextSetData", a1, a3, a4, a5, a6, a7, a8);
  }
  return 0;
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return CGBitmapContextCreateWithData(data, width, height, bitsPerComponent, bytesPerRow, space, bitmapInfo, 0, 0);
}

CGContextRef CGBitmapContextCreateWithData(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo, CGBitmapContextReleaseDataCallback releaseCallback, void *releaseInfo)
{
  if (space) {
    unint64_t v9 = *(void *)(*((void *)space + 3) + 48);
  }
  else {
    unint64_t v9 = 0;
  }
  if (v9 <= 1) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = v9;
  }
  uint64_t v11 = v10 * bitsPerComponent;
  if ((bitmapInfo & 0x1F) != 0 && (bitmapInfo & 0x1F) != 7) {
    ++v9;
  }
  uint64_t v12 = 32;
  if ((bitmapInfo & 0xF0000) != 0x40000) {
    uint64_t v12 = v11;
  }
  if (v9 <= 1) {
    unint64_t v9 = 1;
  }
  size_t v13 = v9 * bitsPerComponent;
  uint32_t v14 = bitmapInfo & 0xFFF0FFFF | 0x10000;
  if ((bitmapInfo & 0xF0000) != 0) {
    uint32_t v14 = bitmapInfo;
  }
  if (bitsPerComponent == 5)
  {
    size_t v13 = 16;
    uint32_t v15 = v14;
  }
  else
  {
    uint32_t v15 = bitmapInfo;
  }
  if (bitsPerComponent == 10)
  {
    size_t v13 = v12;
    uint32_t v16 = bitmapInfo;
  }
  else
  {
    uint32_t v16 = v15;
  }
  if (bitsPerComponent)
  {
    uint64_t v11 = v13;
    uint32_t v17 = v16;
  }
  else
  {
    uint32_t v17 = bitmapInfo;
  }
  CGContextRef result = (CGContextRef)CGBitmapContextInfoCreate((uint64_t)data, 0, 0, width, height, bitsPerComponent, v11, bytesPerRow, 72.0, 72.0, space, v17, 0, (void (*)(uint64_t, uint64_t))releaseCallback, (uint64_t)releaseInfo);
  if (result)
  {
    return (CGContextRef)bitmap_context_create((uint64_t)result, 0, (char)"CGBitmapContextCreateWithData", v19, v20, v21, v22, v23);
  }
  return result;
}

uint64_t CGBitmapContextInfoCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, void *a11, int a12, uint64_t a13, void (*a14)(uint64_t, uint64_t), uint64_t a15)
{
  int v20 = a3;
  int v21 = a2;
  uint64_t v23 = a11;
  if ((a12 & 0x40000) != 0)
  {
    if (!a11 || (CGColorSpaceRef v26 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedSRGB"), !CFEqual(a11, v26)))
    {
      CGPostError((uint64_t)"%s: CIF10 bitmap context requires extended sRGB color space", a2, a3, a4, a5, a6, a7, a8, (char)"CGBitmapContextInfoCreate");
      goto LABEL_23;
    }
    uint64_t v24 = a11[3];
  }
  else
  {
    if (!a11) {
      goto LABEL_12;
    }
    uint64_t v24 = a11[3];
    if ((a12 & 0x40100) == 0 && *(unsigned char *)(v24 + 13) != 0)
    {
      CGPostError((uint64_t)"%s: CGColorSpace which uses extended range requires floating point or CIF10 bitmap context", a2, a3, a4, a5, a6, a7, a8, (char)"CGBitmapContextInfoCreate");
      goto LABEL_23;
    }
  }
  if (*(unsigned char *)(v24 + 10))
  {
LABEL_12:
    unint64_t v57 = a5;
    uint64_t v27 = malloc_type_calloc(1uLL, 0x90uLL, 0xA3729uLL);
    if (!v27)
    {
      if (!a14) {
        return 0;
      }
      goto LABEL_24;
    }
    uint64_t v28 = (uint64_t)v27;
    *uint64_t v27 = 1;
    v27[6] = v21;
    v27[7] = v20;
    *((void *)v27 + 1) = a4;
    *((void *)v27 + 2) = v57;
    if ((a12 & 0x1F) == 7 || a11 == 0) {
      uint64_t v23 = 0;
    }
    else {
      CFRetain(a11);
    }
    unint64_t v30 = a8;
    *(void *)(v28 + 32) = v23;
    *(_DWORD *)(v28 + 40) = a12;
    *(double *)(v28 + 48) = a9;
    *(double *)(v28 + 56) = a10;
    *(unsigned char *)(v28 + 100) = 0;
    *(void *)(v28 + 64) = a1;
    *(void *)(v28 + 72) = a7;
    *(void *)(v28 + 80) = a6;
    *(void *)(v28 + 88) = a8;
    *(void *)(v28 + 104) = a14;
    *(void *)(v28 + 112) = a15;
    if (!a1 && !a8)
    {
      if (a4 >= 0xFFFFFFFFFFFFFFLL) {
        goto LABEL_68;
      }
      unint64_t v30 = (((a7 * a4 + 7) >> 3) + 31) & 0x3FFFFFFFFFFFFFE0;
      *(void *)(v28 + 88) = v30;
    }
    *(void *)(v28 + 120) = 0;
    *(void *)(v28 + 128) = a13;
    *(void *)(v28 + 136) = 0;
    *(_DWORD *)(v28 + 96) = 3;
    if (a13)
    {
      if (a4 >= 0xFFFFFFFFFFFFFFLL) {
        goto LABEL_68;
      }
      uint64_t v31 = *(void *)(v28 + 8);
      *(void *)(v28 + 136) = v30 + ((a13 * a4 + 7) >> 3) - ((unint64_t)(v31 * a7 + 7) >> 3);
      if (!v31) {
        goto LABEL_68;
      }
LABEL_34:
      if (*(void *)(v28 + 16))
      {
        switch(CGColorSpaceGetType(v23))
        {
          case 0xFFFFFFFF:
            int v42 = *(_DWORD *)(v28 + 40);
            if ((v42 & 0x1F) != 7
              || (v42 & 0x7000) != 0
              || *(void *)(v28 + 80) != 8
              || *(void *)(v28 + 72) != 8
              || (v42 & 0xF0000) != 0)
            {
              BOOL v41 = "Valid parameters for alpha only bitmap are:\n"
                    "\tNULL color space\n"
                    "\t8 bits per pixel, 8 bits per component, kCGImageAlphaOnly";
              goto LABEL_45;
            }
            if ((check_sizes((void *)v28, 8, v33, v34, v35, v36, v37, v38) & 1) == 0) {
              goto LABEL_68;
            }
            goto LABEL_55;
          case 0u:
          case 3u:
            goto LABEL_50;
          case 1u:
          case 4u:
            goto LABEL_52;
          case 2u:
            goto LABEL_54;
          case 6u:
          case 0xAu:
          case 0xBu:
            uint64_t v39 = *(void *)(v28 + 32);
            if (!v39) {
              goto LABEL_38;
            }
            uint64_t v40 = *(void *)(v39 + 24);
            if (*(_DWORD *)(v40 + 28) == 7) {
              goto LABEL_38;
            }
            uint64_t v44 = *(void *)(v40 + 48);
            switch(v44)
            {
              case 4:
LABEL_54:
                if ((validate_cmyk_bitmap_info(v28, v32, v33, v34, v35, v36, v37, v38) & 1) == 0) {
                  goto LABEL_68;
                }
                break;
              case 3:
LABEL_52:
                if ((validate_rgb_bitmap_info(v28, v32, v33, v34, v35, v36, v37, v38) & 1) == 0) {
                  goto LABEL_68;
                }
                break;
              case 1:
LABEL_50:
                if ((validate_gray_bitmap_info(v28, v32, v33, v34, v35, v36, v37, v38) & 1) == 0) {
                  goto LABEL_68;
                }
                break;
              default:
LABEL_38:
                BOOL v41 = "Unsupported color space";
LABEL_45:
                unsupported(v28, (uint64_t)v41, v33, v34, v35, v36, v37, v38);
                goto LABEL_68;
            }
LABEL_55:
            if (a1) {
              goto LABEL_60;
            }
            if (v30 && 0xFFFFFFFFFFFFFFFFLL / v30 <= v57) {
              goto LABEL_68;
            }
            unint64_t Data = CGBitmapAllocateData(v30 * v57);
            if (Data)
            {
              *(unsigned char *)(v28 + 100) = 1;
              *(void *)(v28 + 64) = Data;
LABEL_60:
              if (!a13) {
                return v28;
              }
              unint64_t v46 = *(void *)(v28 + 136);
              if (!v46 || 0xFFFFFFFFFFFFFFFFLL / v46 > v57)
              {
                unint64_t v47 = CGBitmapAllocateData(v46 * v57);
                if (v47)
                {
                  *(void *)(v28 + 120) = v47;
                  return v28;
                }
                CGPostError((uint64_t)"%s: unable to allocate %zu bytes for alpha data", v48, v49, v50, v51, v52, v53, v54, (char)"CGBitmapContextInfoCreate");
              }
            }
            else
            {
              uint64_t v56 = "CGBitmapContextInfoCreate";
              BOOL v43 = "%s: unable to allocate %zu bytes for bitmap data";
LABEL_67:
              CGPostError((uint64_t)v43, v32, v33, v34, v35, v36, v37, v38, (char)v56);
            }
            break;
          default:
            BOOL v43 = "CGBitmapContextCreate: unsupported color space.";
            goto LABEL_67;
        }
      }
      goto LABEL_68;
    }
    if (*(void *)(v28 + 8)) {
      goto LABEL_34;
    }
LABEL_68:
    CGBitmapContextInfoRelease(v28);
    return 0;
  }
  CGPostError((uint64_t)"%s: CGColorSpace doesn't support output", a2, a3, a4, a5, a6, a7, a8, (char)"CGBitmapContextInfoCreate");
LABEL_23:
  if (a14) {
LABEL_24:
  }
    a14(a15, a1);
  return 0;
}

uint64_t check_sizes(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a1[1];
  if (v8 < 0xFFFFFFFFFFFFFFLL)
  {
    unint64_t v10 = a1[9] * v8 + 7;
    if (a1[11] < v10 >> 3)
    {
      CGPostError((uint64_t)"CGBitmapContextCreate: invalid data bytes/row: should be at least %zu for %zu %s bits/component, %zu components, %s.", a2, a3, a4, a5, a6, a7, a8, v10 >> 3);
      return 0;
    }
    unint64_t v11 = a1[17];
    if (v11)
    {
      if (a1[16] != a2)
      {
        unint64_t v9 = "alpha bits per pixel value is incorrect";
        goto LABEL_3;
      }
      unint64_t v12 = v8 * a2 + 7;
      if (v11 < v12 >> 3)
      {
        CGPostError((uint64_t)"CGBitmapContextCreate: invalid alpha bytes/row: should be at least %zu for %zu %s bits/component.", a2, a3, a4, a5, a6, a7, a8, v12 >> 3);
        return 0;
      }
    }
    return 1;
  }
  unint64_t v9 = "info->width >= SIZE_MAX / 256";
LABEL_3:
  unsupported((uint64_t)a1, (uint64_t)v9, a3, a4, a5, a6, a7, a8);
  return 0;
}

unint64_t CGBitmapAllocateData(unint64_t a1)
{
  if (a1 > 0x7FFFFFFFFFFFFFFELL) {
    return 0;
  }
  size_t v2 = (a1 + *MEMORY[0x1E4F14B00] + 48) & -*MEMORY[0x1E4F14B00];
  uint64_t v3 = mmap(0, v2, 3, 4098, 872415232, 0);
  if (v3 == (void *)-1) {
    return 0;
  }
  uint64_t v4 = v3;
  unint64_t result = ((unint64_t)v3 + 48) & 0xFFFFFFFFFFFFFFE0;
  *(void *)(result - 16) = v2;
  *(void *)(result - 8) = result - (void)v4;
  return result;
}

uint64_t validate_rgb_bitmap_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8 <= 9)
  {
    if (v8 == 5)
    {
      if ((*(_DWORD *)(a1 + 40) & 0xF0000) != 0x10000) {
        goto LABEL_45;
      }
      if ((*(_DWORD *)(a1 + 40) & 0x1F) != 6) {
        goto LABEL_45;
      }
      uint64_t v10 = 8;
      uint64_t v11 = 2;
      int v20 = *(_DWORD *)(a1 + 40) & 0x7000;
      if (v20)
      {
        if (v20 != 4096 && v20 != 12288) {
          goto LABEL_45;
        }
      }
    }
    else
    {
      if (v8 != 8) {
        goto LABEL_45;
      }
      int v14 = *(_DWORD *)(a1 + 40);
      if ((v14 & 0xF0000) != 0) {
        goto LABEL_45;
      }
      if ((*(_DWORD *)(a1 + 40) & 0x1Fu) > 6 || ((1 << (v14 & 0x1F)) & 0x66) == 0) {
        goto LABEL_45;
      }
      uint64_t v10 = 0;
      uint64_t v11 = 4;
      int v16 = *(_DWORD *)(a1 + 40) & 0x7000;
      if (v16)
      {
        if (v16 != 0x2000 && v16 != 0x4000) {
          goto LABEL_45;
        }
      }
    }
  }
  else
  {
    switch(v8)
    {
      case 10:
        int v17 = *(_DWORD *)(a1 + 40);
        if ((v17 & 0xF0000) != 0x40000 || (v17 & 0x1F) != 0 || (*(_DWORD *)(a1 + 40) & 0x7000) != 0x2000) {
          goto LABEL_45;
        }
        uint64_t v10 = *(void *)(a1 + 128);
        uint64_t v11 = 4;
        break;
      case 16:
        int v18 = *(_DWORD *)(a1 + 40);
        if ((v18 & 0xF0000) != 0 || (v18 & 0x1B | 4) != 5) {
          goto LABEL_45;
        }
        int v19 = *(_DWORD *)(a1 + 40) & 0x7000;
        if ((v18 & 0x100) != 0)
        {
          if (v19 != 4096)
          {
            size_t v13 = "Valid parameters for RGB color space model are:\n"
                  "\t16  bits per pixel,\t\t 5  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedFirst\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                  "\t32  bits per pixel,\t\t 10 bits per component,\t\t kCGImageAlphaNone|kCGImagePixelFormatRGBCIF10|kCG"
                  "ImageByteOrder32Little\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatComp"
                  "onents|kCGImageByteOrder16Little\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponent"
                  "s|kCGImageByteOrder16Little\n"
                  "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatComp"
                  "onents\n"
                  "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponent"
                  "s\n"
                  "required byte order flag is kCGBitmapByteOrder16Little";
            goto LABEL_46;
          }
          uint64_t v10 = 0;
          uint64_t v11 = 8;
        }
        else
        {
          uint64_t v10 = 0;
          uint64_t v11 = 8;
          if (v19 && v19 != 4096 && v19 != 12288)
          {
            size_t v13 = "Valid parameters for RGB color space model are:\n"
                  "\t16  bits per pixel,\t\t 5  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedFirst\n"
                  "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                  "\t32  bits per pixel,\t\t 10 bits per component,\t\t kCGImageAlphaNone|kCGImagePixelFormatRGBCIF10|kCG"
                  "ImageByteOrder32Little\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatComp"
                  "onents|kCGImageByteOrder16Little\n"
                  "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponent"
                  "s|kCGImageByteOrder16Little\n"
                  "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatComp"
                  "onents\n"
                  "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponent"
                  "s\n"
                  "valid byte order flags are kCGBitmapByteOrderDefault, kCGBitmapByteOrder16Big, kCGBitmapByteOrder16Little";
            goto LABEL_46;
          }
        }
        break;
      case 32:
        int v9 = *(_DWORD *)(a1 + 40);
        if ((v9 & 0xF0000) != 0 || (v9 & 0x100) == 0 || (v9 & 0x1B | 4) != 5) {
          goto LABEL_45;
        }
        uint64_t v10 = 0;
        uint64_t v11 = 16;
        int v12 = *(_DWORD *)(a1 + 40) & 0x7000;
        if (v12 && v12 != 0x2000 && v12 != 0x4000)
        {
          size_t v13 = "Valid parameters for RGB color space model are:\n"
                "\t16  bits per pixel,\t\t 5  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
                "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
                "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedFirst\n"
                "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                "\t32  bits per pixel,\t\t 10 bits per component,\t\t kCGImageAlphaNone|kCGImagePixelFormatRGBCIF10|kCGIm"
                "ageByteOrder32Little\n"
                "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatCompon"
                "ents|kCGImageByteOrder16Little\n"
                "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponents|"
                "kCGImageByteOrder16Little\n"
                "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatCompon"
                "ents\n"
                "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponents\n"
                "valid byte order flags are kCGBitmapByteOrderDefault, kCGBitmapByteOrder32Big, kCGBitmapByteOrder32Little";
LABEL_46:
          unsupported(a1, (uint64_t)v13, a3, a4, a5, a6, a7, a8);
          return 0;
        }
        break;
      default:
        goto LABEL_45;
    }
  }
  if (*(void *)(a1 + 72) != 8 * v11)
  {
LABEL_45:
    size_t v13 = "Valid parameters for RGB color space model are:\n"
          "\t16  bits per pixel,\t\t 5  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
          "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipFirst\n"
          "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
          "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedFirst\n"
          "\t32  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
          "\t32  bits per pixel,\t\t 10 bits per component,\t\t kCGImageAlphaNone|kCGImagePixelFormatRGBCIF10|kCGImageByt"
          "eOrder32Little\n"
          "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
          "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
          "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatComponents|k"
          "CGImageByteOrder16Little\n"
          "\t64  bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponents|kCGIma"
          "geByteOrder16Little\n"
          "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaPremultipliedLast|kCGBitmapFloatComponents\n"
          "\t128 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNoneSkipLast|kCGBitmapFloatComponents";
    goto LABEL_46;
  }
  if ((*(void *)(a1 + 88) & (v11 - 1)) != 0)
  {
    CGPostError((uint64_t)"\nCGBitmapContextCreate: unsupported parameter combination:\n\t%zu %% %zu!= 0; bytes per row must be a multiple of bytes per pixel",
      v10,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      *(void *)(a1 + 88));
    return 0;
  }

  return check_sizes((void *)a1, v10, a3, a4, a5, a6, a7, a8);
}

uint64_t validate_gray_bitmap_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 40);
  int v9 = v8 & 0x1F;
  if ((v8 & 0x1F) != 0)
  {
    BOOL v10 = v9 == 5 || v9 == 1;
    if (!v10 || *(void *)(a1 + 80) != 8 || *(void *)(a1 + 72) != 16) {
      goto LABEL_23;
    }
    uint64_t v11 = 2;
LABEL_10:
    if ((v8 & 0x7000) == 0)
    {
      uint64_t v12 = 8;
      goto LABEL_12;
    }
LABEL_23:
    uint32_t v15 = "Valid parameters for Gray color space model are:\n"
          "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaOnly\n"
          "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNone\n"
          "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
          "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
          "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone\n"
          "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents|kCGBitmapByteOr"
          "der16Little\n"
          "\t32 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents";
LABEL_24:
    unsupported(a1, (uint64_t)v15, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  uint64_t v14 = *(void *)(a1 + 72);
  if (v14 != *(void *)(a1 + 80)) {
    goto LABEL_23;
  }
  switch(v14)
  {
    case 32:
      if ((v8 & 0x100) == 0) {
        goto LABEL_23;
      }
      uint64_t v11 = 4;
      uint64_t v12 = 32;
      int v17 = v8 & 0x7000;
      if ((v8 & 0x7000) != 0 && v17 != 0x2000 && v17 != 0x4000)
      {
        uint32_t v15 = "Valid parameters for Gray color space model are:\n"
              "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaOnly\n"
              "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNone\n"
              "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
              "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
              "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone\n"
              "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents|kCGBitmapBy"
              "teOrder16Little\n"
              "\t32 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents\n"
              "valid byte order flags are kCGBitmapByteOrderDefault, kCGBitmapByteOrder32Big, kCGBitmapByteOrder32Little";
        goto LABEL_24;
      }
      break;
    case 16:
      int v16 = v8 & 0x7000;
      if ((v8 & 0x100) != 0)
      {
        if (v16 != 4096)
        {
          uint32_t v15 = "Valid parameters for Gray color space model are:\n"
                "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaOnly\n"
                "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNone\n"
                "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone\n"
                "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents|kCGBitmap"
                "ByteOrder16Little\n"
                "\t32 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents\n"
                "required byte order flag is kCGBitmapByteOrder16Little";
          goto LABEL_24;
        }
        uint64_t v11 = 2;
        uint64_t v12 = 16;
      }
      else
      {
        uint64_t v11 = 2;
        uint64_t v12 = 16;
        if ((v8 & 0x7000) != 0 && v16 != 4096 && v16 != 12288)
        {
          uint32_t v15 = "Valid parameters for Gray color space model are:\n"
                "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaOnly\n"
                "\t8  bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNone\n"
                "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaNoneSkipLast\n"
                "\t16 bits per pixel,\t\t 8  bits per component,\t\t kCGImageAlphaPremultipliedLast\n"
                "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone\n"
                "\t16 bits per pixel,\t\t 16 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents|kCGBitmap"
                "ByteOrder16Little\n"
                "\t32 bits per pixel,\t\t 32 bits per component,\t\t kCGImageAlphaNone|kCGBitmapFloatComponents\n"
                "valid byte order flags are kCGBitmapByteOrderDefault, kCGBitmapByteOrder16Big, kCGBitmapByteOrder16Little";
          goto LABEL_24;
        }
      }
      break;
    case 8:
      uint64_t v11 = 1;
      goto LABEL_10;
    default:
      goto LABEL_23;
  }
LABEL_12:
  if ((*(void *)(a1 + 88) & (v11 - 1)) != 0 || (v8 & 0xF0000) != 0) {
    goto LABEL_23;
  }

  return check_sizes((void *)a1, v12, a3, a4, a5, a6, a7, a8);
}

uint64_t CGCFDictionaryGetBoolean(CFDictionaryRef theDict, const void *a2, BOOL *a3)
{
  uint64_t result = 0;
  if (theDict)
  {
    if (a2)
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, a2);
      if (result)
      {
        CFBooleanRef v6 = (const __CFBoolean *)result;
        CFTypeID v7 = CFGetTypeID((CFTypeRef)result);
        if (v7 == CFBooleanGetTypeID())
        {
          if (a3) {
            *a3 = CFBooleanGetValue(v6) != 0;
          }
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

__CFDictionary *CG::DisplayListRecorder::initializeGroupInfoDictionary(uint64_t a1, const __CFDictionary *a2)
{
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 32);
    if (v5)
    {
      uint64_t v6 = 0;
      v10[0] = @"trackGlyphs";
      v10[1] = @"decodeImages";
      v10[2] = @"clipRecordingToFrame";
      _OWORD v10[3] = @"evaluateShadingsOnRecord";
      do
      {
        Value = CFDictionaryGetValue(v5, (const void *)v10[v6]);
        if (Value) {
          CFDictionarySetValue(Mutable, (const void *)v10[v6], Value);
        }
        ++v6;
      }
      while (v6 != 4);
    }
    if (a2)
    {
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 0x40000000;
      context[2] = ___ZN2CG19DisplayListRecorder29initializeGroupInfoDictionaryEP13CGDisplayListPK14__CFDictionary_block_invoke;
      context[3] = &__block_descriptor_tmp_4862;
      context[4] = Mutable;
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)call_dict_block, context);
      CFDictionaryRemoveValue(Mutable, @"kCGContextBoundingBox");
    }
    if (!CFDictionaryContainsKey(Mutable, @"kCGContextGroup")
      && !CFDictionaryContainsKey(Mutable, @"kCGContextColorSpace")
      && *MEMORY[0x1E4F1CFD0])
    {
      CFDictionarySetValue(Mutable, @"kCGContextGroup", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
  }
  return Mutable;
}

uint64_t CG::dasher::dash_path_element<CG::LineSegment>(uint64_t this, float64x2_t *a2)
{
  double v2 = a2->f64[1];
  double v3 = a2[1].f64[0];
  double v4 = a2[1].f64[1];
  double v5 = *(double *)(this + 48);
  double v6 = *(double *)(this + 56);
  double v7 = *(double *)(this + 32);
  double v8 = *(double *)(this + 40);
  double v9 = sqrt((v4 * v6 + v3 * v8 - (v2 * v6 + a2->f64[0] * v8)) * (v4 * v6 + v3 * v8 - (v2 * v6 + a2->f64[0] * v8))+ (v4 * v5 + v3 * v7 - (v2 * v5 + a2->f64[0] * v7)) * (v4 * v5 + v3 * v7 - (v2 * v5 + a2->f64[0] * v7)));
  if (v9 != 0.0)
  {
    uint64_t v11 = this;
    double v12 = *(double *)(this + 120);
    if (v9 <= v12)
    {
      if (*(unsigned char *)(this + 104))
      {
        this = CG::dasher::add_path_dash_segment<CG::LineSegment>(this, a2, 0.0, v9);
        *(unsigned char *)(v11 + 144) = 0;
        double v12 = *(double *)(v11 + 120);
      }
      double v15 = v12 - v9;
      goto LABEL_15;
    }
    double v13 = 0.0;
    for (double i = v12 + 0.0; i < v9; double i = v13 + v12)
    {
      if (*(unsigned char *)(v11 + 104))
      {
        CG::dasher::add_path_dash_segment<CG::LineSegment>(v11, a2, v13, i);
        double v12 = *(double *)(v11 + 120);
      }
      double v13 = v13 + v12;
      this = CG::dasher::advance_dash_index(v11);
      double v12 = *(double *)(v11 + 120);
    }
    if (v13 < v9)
    {
      if (*(unsigned char *)(v11 + 104))
      {
        this = CG::dasher::add_path_dash_segment<CG::LineSegment>(v11, a2, v13, v9);
        *(unsigned char *)(v11 + 144) = 0;
        double v12 = *(double *)(v11 + 120);
      }
      double v15 = v12 - (v9 - v13);
LABEL_15:
      *(double *)(v11 + 120) = v15;
    }
  }
  return this;
}

uint64_t CG::dasher::advance_dash_index(uint64_t this)
{
  *(unsigned char *)(this + 104) ^= 1u;
  uint64_t v1 = *(void *)(this + 112);
  uint64_t v2 = *(void *)(this + 8);
  unint64_t v3 = (*(void *)(this + 16) - v2) >> 3;
  if (v1 == v3 - 1) {
    unint64_t v4 = 0;
  }
  else {
    unint64_t v4 = v1 + 1;
  }
  *(void *)(this + 112) = v4;
  if (v3 <= v4)
  {
    __break(1u);
  }
  else
  {
    *(void *)(this + 120) = *(void *)(v2 + 8 * v4);
    *(unsigned char *)(this + 144) = 1;
  }
  return this;
}

uint64_t CG::dasher::add_path_dash_segment<CG::LineSegment>(uint64_t result, float64x2_t *a2, double a3, double a4)
{
  double v6 = (double *)result;
  double v7 = 0.0;
  if (a3 > 0.0)
  {
    double v8 = a2[1].f64[0];
    double v9 = a2[1].f64[1];
    double v11 = *(double *)(result + 48);
    double v10 = *(double *)(result + 56);
    double v13 = *(double *)(result + 32);
    double v12 = *(double *)(result + 40);
    double v14 = a2->f64[1];
    double v15 = sqrt((v9 * v10 + v8 * v12 - (v14 * v10 + a2->f64[0] * v12))* (v9 * v10 + v8 * v12 - (v14 * v10 + a2->f64[0] * v12))+ (v9 * v11 + v8 * v13 - (v14 * v11 + a2->f64[0] * v13))* (v9 * v11 + v8 * v13 - (v14 * v11 + a2->f64[0] * v13)));
    double v16 = a3 / v15;
    BOOL v17 = v15 > a3;
    double v7 = 1.0;
    if (v17) {
      double v7 = v16;
    }
  }
  float64x2_t v18 = a2[1];
  float64x2_t v19 = vaddq_f64(*a2, vmulq_n_f64(vsubq_f64(v18, *a2), v7));
  if (*(unsigned char *)(result + 144))
  {
    uint64_t v20 = *(void *)result;
    float64x2_t v37 = v19;
    if (v20)
    {
      float64x2_t v35 = v18;
      float64x2_t v36 = v19;
      uint64_t result = (*(uint64_t (**)(void, void, float64x2_t *, void))(v20 + 24))(*(void *)(v20 + 8), 0, &v37, *(void *)(v20 + 48));
      float64x2_t v18 = v35;
      float64x2_t v19 = v36;
    }
  }
  if (a3 == a4)
  {
    float64x2_t v21 = vsubq_f64(v18, v19);
    if (v21.f64[0] != 0.0 || v21.f64[1] != 0.0) {
      float64x2_t v21 = vdivq_f64(v21, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(v21.f64[1] * v21.f64[1] + v21.f64[0] * v21.f64[0])), 0));
    }
    double v22 = *v6;
    float64x2_t v23 = vaddq_f64(v19, vmulq_f64(v21, (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL)));
  }
  else
  {
    double v24 = a4 - a3;
    double v25 = 0.0;
    if (a4 - a3 > 0.0)
    {
      double v27 = v6[6];
      double v26 = v6[7];
      double v29 = v6[4];
      double v28 = v6[5];
      double v30 = vmlad_n_f64(vmuld_lane_f64(v26, v18, 1), v28, v18.f64[0]);
      double v31 = vmlad_n_f64(vmuld_lane_f64(v27, v18, 1), v29, v18.f64[0]);
      double v32 = vmlad_n_f64(vmuld_lane_f64(v26, v19, 1), v28, v19.f64[0]);
      double v33 = vmlad_n_f64(vmuld_lane_f64(v27, v19, 1), v29, v19.f64[0]);
      double v34 = sqrt((v30 - v32) * (v30 - v32) + (v31 - v33) * (v31 - v33));
      if (v34 <= v24) {
        double v25 = 1.0;
      }
      else {
        double v25 = v24 / v34;
      }
    }
    float64x2_t v23 = vaddq_f64(v19, vmulq_n_f64(vsubq_f64(v18, v19), v25));
    double v22 = *v6;
  }
  float64x2_t v37 = v23;
  if (v22 != 0.0) {
    return (*(uint64_t (**)(void, uint64_t, float64x2_t *, void))(*(void *)&v22 + 24))(*(void *)(*(void *)&v22 + 8), 1, &v37, *(void *)(*(void *)&v22 + 48));
  }
  return result;
}

void CG::Path::apply_iterator(CG::Path *this, path_iterator *a2)
{
  if (a2)
  {
    unint64_t v4 = (void (*)(void, void, void))*((void *)a2 + 2);
    if (v4) {
      v4(*((void *)a2 + 1), 0, *((void *)a2 + 6));
    }
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = ___ZNK2CG4Path14apply_iteratorEP13path_iterator_block_invoke;
  v6[3] = &__block_descriptor_tmp_13699;
  v6[4] = a2;
  CG::Path::apply((double *)this, (uint64_t)v6);
  if (a2)
  {
    double v5 = (void (*)(void, void))*((void *)a2 + 4);
    if (v5) {
      v5(*((void *)a2 + 1), *((void *)a2 + 6));
    }
  }
}

uint64_t anonymous namespace'::begin(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 72);
  if (v2)
  {
    unint64_t v3 = (uint64_t (*)(void, uint64_t, void))v2[2];
    if (v3) {
      return v3(v2[1], a2, v2[6]);
    }
  }
  return result;
}

uint64_t anonymous namespace'::end(uint64_t this, void *a2, path_iterator *a3)
{
  uint64_t v3 = this;
  if ((*(_DWORD *)(this + 80) - 3) <= 1) {
    this = CG::stroker::end_contour(this);
  }
  unint64_t v4 = *(void **)(v3 + 72);
  if (v4)
  {
    double v5 = (uint64_t (*)(uint64_t, uint64_t))v4[4];
    if (v5)
    {
      uint64_t v6 = v4[1];
      uint64_t v7 = v4[6];
      return v5(v6, v7);
    }
  }
  return this;
}

void CG::stroker::path_stroke_round_cube_offset(CG::stroker *this, float64x2_t *a2, int a3, int a4)
{
  v103[15] = *MEMORY[0x1E4F143B8];
  double v7 = a2[3].f64[0];
  double v8 = a2[3].f64[1];
  double v9 = a2->f64[0];
  double v10 = a2->f64[1];
  if ((v8 - v10) * (v8 - v10) + (v7 - a2->f64[0]) * (v7 - a2->f64[0]) <= 0.00000001)
  {
    double v34 = v7 + CG::stroker::offset_normal((double *)this, a2, 0, 1.0);
    double v36 = v8 + v35;
    *(double *)&v79[0].v = v34;
    *(double *)&v79[2].v = v36;
    if (a4 < 0)
    {
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v79);
      double v69 = a2->f64[0];
      double v70 = a2->f64[1];
      *((double *)this + 25) = v69 + CG::stroker::offset_normal((double *)this, a2, 0, 0.0);
      *((double *)this + 26) = v70 + v71;
    }
    else
    {
      uint64_t v37 = *((void *)this + 9);
      v100[0].f64[0] = v34;
      v100[0].f64[1] = v36;
      if (v37) {
        (*(void (**)(void, uint64_t, float64x2_t *, void))(v37 + 24))(*(void *)(v37 + 8), 1, v100, *(void *)(v37 + 48));
      }
    }
  }
  else
  {
    double v98 = 0.0;
    double v99 = 0.0;
    double v12 = v9 + CG::stroker::offset_normal((double *)this, a2, &v98, 0.0);
    double v14 = v10 + v13;
    double v96 = 0.0;
    double v97 = 0.0;
    double v15 = v7 + CG::stroker::offset_normal((double *)this, a2, &v96, 1.0);
    double v17 = v8 + v16;
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v23 = a2[4];
    float64x2_t v24 = vaddq_f64(vmulq_f64(a2[6], _Q1), a2[5]);
    *(double *)&v95[0].v = v15;
    *(double *)&v95[2].v = v17;
    double v93 = 0.0;
    double v94 = 0.0;
    float64x2_t v77 = vaddq_f64(*a2, vmulq_f64(vaddq_f64(vmulq_f64(v24, _Q1), v23), _Q1));
    double v26 = v77.f64[0] + CG::stroker::offset_normal((double *)this, a2, &v93, 0.5);
    double v28 = v77.f64[1] + v27;
    double v29 = v26 + ((v26 - v12) * 0.5 + (v26 - v15) * 0.5) / 3.0;
    double v30 = v28 + ((v28 - v14) * 0.5 + (v28 - v17) * 0.5) / 3.0;
    v92[0] = v29;
    v92[1] = v30;
    double v31 = -v94;
    double v32 = v93 * v99 - v94 * v98;
    double v33 = fabs(v32);
    if (v33 >= 0.0001)
    {
      double v38 = ((v29 - v12) * v31 + v93 * (v30 - v14)) / v32;
      double v90 = v12 + v98 * v38;
      double v91 = v14 + v99 * v38;
    }
    else
    {
      double v90 = 0.0;
      double v91 = 0.0;
    }
    uint64_t v39 = &v90;
    if (v33 < 0.0001) {
      uint64_t v39 = v92;
    }
    *(_OWORD *)&v89[0].v = *(_OWORD *)v39;
    double v40 = v96 * v31 + v93 * v97;
    double v41 = fabs(v40);
    if (v41 >= 0.0001)
    {
      double v42 = ((v29 - v15) * v31 + v93 * (v30 - v17)) / v40;
      double v87 = v15 + v96 * v42;
      double v88 = v17 + v97 * v42;
    }
    else
    {
      double v87 = 0.0;
      double v88 = 0.0;
    }
    BOOL v43 = &v87;
    if (v41 < 0.0001) {
      BOOL v43 = v92;
    }
    *(_OWORD *)&v86[0].v = *(_OWORD *)v43;
    _VF = __OFSUB__(a3, 1);
    int v44 = a3 - 1;
    if (v44 < 0 != _VF)
    {
LABEL_57:
      if (a4 < 0)
      {
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v89);
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v86);
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v95);
        *((double *)this + 25) = v12;
        *((double *)this + 26) = v14;
      }
      else
      {
        uint64_t v68 = *((void *)this + 9);
        if (v68)
        {
          v100[0] = *(float64x2_t *)&v89[0].v;
          v100[1] = *(float64x2_t *)&v86[0].v;
          double v101 = v15;
          double v102 = v17;
          (*(void (**)(void, uint64_t, float64x2_t *, void))(v68 + 24))(*(void *)(v68 + 8), 3, v100, *(void *)(v68 + 48));
        }
      }
    }
    else
    {
      uint64_t v45 = 0;
      *(double *)&v79[0].v = v12;
      *(double *)&v79[2].v = v14;
      float64x2_t v46 = *(float64x2_t *)v43;
      float64x2_t v80 = *(float64x2_t *)v39;
      float64x2_t v81 = v46;
      float64x2_t v47 = vsubq_f64(v80, *(float64x2_t *)&v79[0].v);
      __asm { FMOV            V4.2D, #3.0 }
      long long v82 = *(_OWORD *)&v95[0].v;
      float64x2_t v83 = vmulq_f64(v47, _Q4);
      float64x2_t v49 = vsubq_f64(v46, v80);
      float64x2_t v50 = vmulq_f64(vsubq_f64(v49, v47), _Q4);
      float64x2_t v84 = v50;
      float64x2_t v85 = vaddq_f64(v47, vsubq_f64(vsubq_f64(*(float64x2_t *)&v95[0].v, v46), vaddq_f64(v49, v49)));
      BOOL v51 = (*(void *)&v85.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL;
      BOOL v61 = (*(void *)&v12 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v14 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v80.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v80.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v46.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v46.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v95[0].v & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v95[2].v & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v83.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
         || (*(void *)&v50.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL;
      while (1)
      {
        *(void *)&v50.f64[0] = CG::stroker::path_stroke_round_cube_offset(CG::Cubic const&,int,int)::samples[v45];
        double v62 = v28;
        double v63 = v26;
        if (v45 * 8)
        {
          float64x2_t v76 = vaddq_f64(*a2, vmulq_n_f64(vaddq_f64(vmulq_n_f64(vaddq_f64(vmulq_n_f64(a2[6], v50.f64[0]), a2[5]), v50.f64[0]), a2[4]), v50.f64[0]));
          float64x2_t v78 = v50;
          double v64 = CG::stroker::offset_normal((double *)this, a2, 0, v50.f64[0]);
          float64x2_t v50 = v78;
          double v63 = v76.f64[0] + v64;
          double v62 = v76.f64[1] + v65;
        }
        BOOL v66 = (*(void *)&v63 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
           && (*(void *)&v62 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL;
        BOOL v67 = !v66 || v61;
        if (!v67
          && !v51
          && (CG::Cubic::is_near((CG::Cubic *)v79, v25, v63, v62, v50.f64[0], *((double *)this + 8)) & 1) == 0)
        {
          break;
        }
        if (++v45 == 5) {
          goto LABEL_57;
        }
      }
      CG::Cubic::split(v100, 0.5, a2);
      if (a4 < 0)
      {
        CG::stroker::path_stroke_round_cube_offset(this, (const CG::Cubic *)v103, v44, -1);
        uint64_t v72 = (const CG::Cubic *)v100;
        int v73 = this;
        int v74 = v44;
        int v75 = -1;
      }
      else
      {
        CG::stroker::path_stroke_round_cube_offset(this, (const CG::Cubic *)v100, v44, a4);
        uint64_t v72 = (const CG::Cubic *)v103;
        int v73 = this;
        int v74 = v44;
        int v75 = a4;
      }
      CG::stroker::path_stroke_round_cube_offset(v73, v72, v74, v75);
    }
  }
}

double CG::stroker::offset_normal(double *a1, float64x2_t *this, double *a3, double a4)
{
  *(void *)&double v6 = *(_OWORD *)&CG::Cubic::derivative(this, a4);
  if (a3)
  {
    *a3 = v6;
    a3[1] = v7;
  }
  double v8 = *a1;
  double v9 = a1[1];
  double v11 = a1[2];
  double v10 = a1[3];
  if (*a1 * v10 - v9 * v11 >= 0.0)
  {
    double v14 = -v9;
    double v15 = -v11;
    double v12 = a1[3];
    double v13 = *a1;
  }
  else
  {
    double v12 = -v10;
    double v13 = -v8;
    double v14 = a1[1];
    double v15 = a1[2];
  }
  double v16 = v7 * v15 + v6 * v12;
  double v17 = v7 * v13 + v6 * v14;
  double v18 = -v17;
  if (v17 != 0.0 || v16 != 0.0)
  {
    double v19 = sqrt(v16 * v16 + v17 * v17);
    double v18 = v18 / v19;
    double v16 = v16 / v19;
  }
  return v11 * v16 + v18 * v8;
}

float64x2_t CG::Cubic::derivative(float64x2_t *this, double a2)
{
  if (a2 == 0.0)
  {
    float64x2_t v2 = *this;
    float64x2_t result = vsubq_f64(this[1], *this);
    if (vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(result, result).f64[1]), result.f64[0], result.f64[0]) <= 0.00000001)
    {
      float64x2_t result = vsubq_f64(this[2], v2);
      if (vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(result, result).f64[1]), result.f64[0], result.f64[0]) <= 0.00000001) {
        return vsubq_f64(this[3], v2);
      }
    }
  }
  else if (a2 == 1.0)
  {
    float64x2_t v4 = this[3];
    float64x2_t result = vsubq_f64(v4, this[2]);
    if (vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(result, result).f64[1]), result.f64[0], result.f64[0]) <= 0.00000001)
    {
      float64x2_t result = vsubq_f64(v4, this[1]);
      if (vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(result, result).f64[1]), result.f64[0], result.f64[0]) <= 0.00000001) {
        return vsubq_f64(v4, *this);
      }
    }
  }
  else
  {
    __asm { FMOV            V2.2D, #3.0 }
    return vaddq_f64(this[4], vmulq_n_f64(vaddq_f64(vmulq_n_f64(vmulq_f64(this[6], _Q2), a2), vaddq_f64(this[5], this[5])), a2));
  }
  return result;
}

uint64_t CG::Cubic::is_near(CG::Cubic *this, const Point *a2, double a3, double a4, double a5, double a6)
{
  double v6 = a6 * a6;
  double v7 = *((double *)this + 8);
  double v8 = *((double *)this + 9);
  double v9 = *((double *)this + 10);
  double v10 = *((double *)this + 11);
  double v11 = *((double *)this + 12);
  double v12 = *((double *)this + 13);
  double v13 = *(double *)this - a3;
  double v14 = *((double *)this + 1) - a4;
  double v15 = v13 + (v7 + (v9 + v11 * 0.0) * 0.0) * 0.0;
  double v16 = (v14 + (v8 + (v10 + v12 * 0.0) * 0.0) * 0.0) * (v14 + (v8 + (v10 + v12 * 0.0) * 0.0) * 0.0) + v15 * v15;
  if (v16 < v6) {
    return 1;
  }
  double v17 = (v14 + v8 + v10 + v12) * (v14 + v8 + v10 + v12) + (v13 + v7 + v9 + v11) * (v13 + v7 + v9 + v11);
  if (v17 < v6) {
    return 1;
  }
  double v18 = v13 + (v7 + (v9 + v11 * a5) * a5) * a5;
  double v19 = v14 + (v8 + (v10 + v12 * a5) * a5) * a5;
  double v20 = v19 * v19 + v18 * v18;
  if (v20 < v6) {
    return 1;
  }
  if (v20 >= v16 || v20 >= v17) {
    return 0;
  }
  float64x2_t v23 = (double *)&unk_1EB289000;
  {
    double v46 = a5;
    double v47 = v7;
    double v43 = v6;
    double v44 = v8;
    double v48 = v9;
    double v45 = v10;
    double v49 = v11;
    double v50 = v12;
    double v51 = v13;
    double v52 = v14;
    double v53 = v20;
    float64x2_t v23 = (double *)&unk_1EB289000;
    double v14 = v52;
    double v20 = v53;
    double v12 = v50;
    double v13 = v51;
    double v11 = v49;
    double v8 = v44;
    double v10 = v45;
    double v7 = v47;
    double v9 = v48;
    double v6 = v43;
    a5 = v46;
    if (v42)
    {
      CG::Cubic::is_near(CG::Point const&,double,double)const::G = 0x3FE3C6EF372FE950;
      float64x2_t v23 = (double *)&unk_1EB289000;
      double v14 = v52;
      double v20 = v53;
      double v12 = v50;
      double v13 = v51;
      double v11 = v49;
      double v8 = v44;
      double v10 = v45;
      double v7 = v47;
      double v9 = v48;
      double v6 = v43;
      a5 = v46;
    }
  }
  double v24 = v23[260];
  double v25 = 1.0 - v24;
  if (a5 <= 0.5)
  {
    double v26 = a5;
    a5 = a5 + v25 * (1.0 - a5);
    double v30 = v13 + a5 * (v7 + a5 * (v9 + v11 * a5));
    double v31 = v14 + a5 * (v8 + a5 * (v10 + v12 * a5));
    double v32 = v31 * v31;
    double v29 = v20;
    double v20 = v32 + v30 * v30;
    if (v20 >= v6) {
      goto LABEL_16;
    }
    return 1;
  }
  double v26 = a5 - v25 * a5;
  double v27 = v13 + v26 * (v7 + v26 * (v9 + v11 * v26));
  double v28 = v14 + v26 * (v8 + v26 * (v10 + v12 * v26));
  double v29 = v28 * v28 + v27 * v27;
  if (v29 < v6) {
    return 1;
  }
LABEL_16:
  double v33 = 1.0;
  if ((v26 + a5) * 0.00000003 >= 1.0) {
    return 0;
  }
  double v34 = 0.0;
  uint64_t result = 0;
  do
  {
    if (v20 >= v29)
    {
      double v33 = a5;
      a5 = v34 * v25 + v24 * v26;
      double v37 = v13 + a5 * (v7 + a5 * (v9 + v11 * a5));
      double v38 = v14 + a5 * (v8 + a5 * (v10 + v12 * a5));
      double v20 = v38 * v38 + v37 * v37;
      if (v20 <= v6) {
        return 1;
      }
    }
    else
    {
      double v34 = v26;
      double v26 = v33 * v25 + v24 * a5;
      double v35 = v13 + v26 * (v7 + v26 * (v9 + v11 * v26));
      double v36 = v14 + v26 * (v8 + v26 * (v10 + v12 * v26));
      double v29 = v36 * v36 + v35 * v35;
      if (v29 <= v6) {
        return 1;
      }
    }
    double v39 = v20;
    double v40 = a5;
    BOOL v41 = v33 - v34 <= (a5 + v26) * 0.00000003;
    double v20 = v29;
    double v29 = v39;
    a5 = v26;
    double v26 = v40;
  }
  while (!v41);
  return result;
}

uint64_t ___ZNK2CG4Path14apply_iteratorEP13path_iterator_block_invoke(uint64_t result, int a2, long long *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  switch(a2)
  {
    case 0:
      uint64_t v3 = *(void *)(result + 32);
      long long v13 = *a3;
      if (v3) {
        uint64_t result = (*(uint64_t (**)(void, void, long long *, void))(v3 + 24))(*(void *)(v3 + 8), 0, &v13, *(void *)(v3 + 48));
      }
      break;
    case 1:
      uint64_t v4 = *(void *)(result + 32);
      long long v13 = *a3;
      if (v4) {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, long long *, void))(v4 + 24))(*(void *)(v4 + 8), 1, &v13, *(void *)(v4 + 48));
      }
      break;
    case 2:
      uint64_t v5 = *(void *)(result + 32);
      if (v5)
      {
        long long v6 = a3[1];
        long long v13 = *a3;
        long long v14 = v6;
        uint64_t result = (*(uint64_t (**)(void, uint64_t, long long *, void))(v5 + 24))(*(void *)(v5 + 8), 2, &v13, *(void *)(v5 + 48));
      }
      break;
    case 3:
      uint64_t v7 = *(void *)(result + 32);
      if (v7)
      {
        long long v8 = a3[1];
        long long v13 = *a3;
        long long v14 = v8;
        long long v15 = a3[2];
        uint64_t result = (*(uint64_t (**)(void, uint64_t, long long *, void))(v7 + 24))(*(void *)(v7 + 8), 3, &v13, *(void *)(v7 + 48));
      }
      break;
    case 4:
      double v9 = *(void **)(result + 32);
      if (v9)
      {
        double v10 = (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v9[3];
        uint64_t v11 = v9[1];
        uint64_t v12 = v9[6];
        uint64_t result = v10(v11, 4, 0, v12);
      }
      break;
    default:
      abort();
  }
  return result;
}

uint64_t ripr_path_stroke(uint64_t result, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  float64x2_t v2 = *(long long **)(a2 + 8);
  switch(*(_DWORD *)a2)
  {
    case 0:
      long long v9 = *v2;
      if (result) {
        uint64_t result = (*(uint64_t (**)(void, void, long long *, void))(result + 24))(*(void *)(result + 8), 0, &v9, *(void *)(result + 48));
      }
      break;
    case 1:
      long long v9 = *v2;
      if (result) {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, long long *, void))(result + 24))(*(void *)(result + 8), 1, &v9, *(void *)(result + 48));
      }
      break;
    case 2:
      if (result)
      {
        long long v3 = v2[1];
        long long v9 = *v2;
        long long v10 = v3;
        uint64_t result = (*(uint64_t (**)(void, uint64_t, long long *, void))(result + 24))(*(void *)(result + 8), 2, &v9, *(void *)(result + 48));
      }
      break;
    case 3:
      if (result)
      {
        long long v4 = v2[1];
        long long v5 = v2[2];
        long long v9 = *v2;
        long long v10 = v4;
        long long v11 = v5;
        uint64_t result = (*(uint64_t (**)(void, uint64_t, long long *, void))(result + 24))(*(void *)(result + 8), 3, &v9, *(void *)(result + 48));
      }
      break;
    case 4:
      if (result)
      {
        long long v6 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(result + 24);
        uint64_t v7 = *(void *)(result + 48);
        uint64_t v8 = *(void *)(result + 8);
        uint64_t result = v6(v8, 4, 0, v7);
      }
      break;
    default:
      return result;
  }
  return result;
}

__n128 anonymous namespace'::iterate(_anonymous_namespace_ *this, void *a2, float64x2_t *a3, const CGPoint *a4, path_iterator *a5)
{
  switch((int)a2)
  {
    case 0:
      if ((*((_DWORD *)this + 20) - 3) <= 1) {
        CG::stroker::end_contour((uint64_t)this);
      }
      *((_DWORD *)this + 20) = 2;
      *(float64x2_t *)((char *)this + 184) = *a3;
      __n128 result = *(__n128 *)((char *)this + 184);
      *(__n128 *)((char *)this + 136) = result;
      *(__n128 *)((char *)this + 88) = result;
      return result;
    case 1:
      int v8 = *((_DWORD *)this + 20);
      if (!v8) {
        return result;
      }
      if (v8 == 1) {
        *((_DWORD *)this + 20) = 2;
      }
      *(float64x2_t *)((char *)this + 184) = *a3;
      long long v9 = (__n128 *)((char *)this + 184);
      long long v10 = (__n128 *)((char *)this + 136);
      if (!CG::stroker::add_line_segment(this, (const Point *)this + 34, (const Point *)this + 46)) {
        return result;
      }
      goto LABEL_14;
    case 2:
      int v11 = *((_DWORD *)this + 20);
      if (v11)
      {
        if (v11 == 1) {
          *((_DWORD *)this + 20) = 2;
        }
        float64x2_t v12 = *a3;
        float64x2_t v13 = a3[1];
        *(float64x2_t *)((char *)this + 184) = v13;
        long long v9 = (__n128 *)((char *)this + 184);
        long long v10 = (__n128 *)((char *)this + 136);
        __asm { FMOV            V3.2D, #3.0 }
        float64x2_t v19 = vsubq_f64(v12, vdivq_f64(vsubq_f64(v12, *(float64x2_t *)((char *)this + 136)), _Q3));
        float64x2_t v20 = vaddq_f64(v12, vdivq_f64(vsubq_f64(v13, v12), _Q3));
        float64x2_t v40 = *(float64x2_t *)((char *)this + 136);
        float64x2_t v41 = v19;
        float64x2_t v21 = *(float64x2_t *)((char *)this + 184);
        float64x2_t v42 = v20;
        float64x2_t v43 = v21;
        float64x2_t v22 = vsubq_f64(v19, v40);
        float64x2_t v23 = vsubq_f64(v20, v19);
        float64x2_t v44 = vmulq_f64(v22, _Q3);
        float64x2_t v45 = vmulq_f64(vsubq_f64(v23, v22), _Q3);
        float64x2_t v46 = vaddq_f64(v22, vsubq_f64(vsubq_f64(v43, v20), vaddq_f64(v23, v23)));
        CG::stroker::add_cubic_segment(this, &v40);
        if (v24)
        {
LABEL_14:
          __n128 result = *v9;
          *long long v10 = *v9;
        }
      }
      break;
    case 3:
      int v25 = *((_DWORD *)this + 20);
      if (v25)
      {
        if (v25 == 1) {
          *((_DWORD *)this + 20) = 2;
        }
        float64x2_t v26 = *a3;
        float64x2_t v27 = a3[1];
        *(float64x2_t *)((char *)this + 184) = a3[2];
        double v28 = (__n128 *)((char *)this + 184);
        float64x2_t v40 = *(float64x2_t *)((char *)this + 136);
        float64x2_t v41 = v26;
        float64x2_t v29 = *(float64x2_t *)((char *)this + 184);
        float64x2_t v42 = v27;
        float64x2_t v43 = v29;
        float64x2_t v30 = vsubq_f64(v26, v40);
        __asm { FMOV            V4.2D, #3.0 }
        float64x2_t v32 = vsubq_f64(v27, v26);
        float64x2_t v44 = vmulq_f64(v30, _Q4);
        float64x2_t v45 = vmulq_f64(vsubq_f64(v32, v30), _Q4);
        float64x2_t v46 = vaddq_f64(v30, vsubq_f64(vsubq_f64(v43, v27), vaddq_f64(v32, v32)));
        CG::stroker::add_cubic_segment(this, &v40);
        if (v33)
        {
          __n128 result = *v28;
          *(__n128 *)((char *)this + 136) = *v28;
        }
      }
      break;
    case 4:
      unsigned int v34 = *((_DWORD *)this + 20);
      if (v34 >= 2)
      {
        if (v34 == 4)
        {
          CG::stroker::add_line_segment(this, (const Point *)this + 34, (const Point *)this + 22);
          *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)this + 88);
          CG::stroker::add_join(this, (double *)this + 11, (double *)this + 13, (double *)this + 15);
          uint64_t v35 = *((void *)this + 9);
          if (v35)
          {
            (*(void (**)(void, uint64_t, void, void))(v35 + 24))(*(void *)(v35 + 8), 4, 0, *(void *)(v35 + 48));
            uint64_t v36 = *((void *)this + 9);
            float64x2_t v40 = *(float64x2_t *)((char *)this + 200);
            if (v36) {
              (*(void (**)(void, void, float64x2_t *, void))(v36 + 24))(*(void *)(v36 + 8), 0, &v40, *(void *)(v36 + 48));
            }
          }
          CG::stroker::unroll_path(this);
          uint64_t v37 = *((void *)this + 9);
          if (v37) {
            (*(void (**)(void, uint64_t, void, void))(v37 + 24))(*(void *)(v37 + 8), 4, 0, *(void *)(v37 + 48));
          }
        }
        else
        {
          double v38 = (_OWORD *)((char *)this + 88);
          float64x2_t v39 = vsubq_f64(*(float64x2_t *)((char *)this + 184), *(float64x2_t *)((char *)this + 88));
          CG::stroker::add_point((uint64_t)this, (double *)this + 11, v39.f64[0], v39.f64[1]);
          *(_OWORD *)((char *)this + 136) = *v38;
        }
        *((_DWORD *)this + 20) = 1;
        __n128 result = *(__n128 *)((char *)this + 88);
        *(__n128 *)((char *)this + 184) = result;
      }
      break;
    default:
      abort();
  }
  return result;
}

BOOL CG::stroker::add_line_segment(CG::stroker *this, const Point *a2, const Point *a3)
{
  float64x2_t v4 = vsubq_f64(*(float64x2_t *)&a3->v, *(float64x2_t *)&a2->v);
  float64x2_t v32 = v4;
  double v5 = vmlad_n_f64(vmuld_lane_f64(v4.f64[1], v4, 1), v4.f64[0], v4.f64[0]);
  if (v5 <= 0.00000001)
  {
    if (*((_DWORD *)this + 20) == 2) {
      *((_DWORD *)this + 20) = 3;
    }
  }
  else
  {
    double v8 = *(double *)this;
    double v9 = *((double *)this + 1);
    double v11 = *((double *)this + 2);
    double v10 = *((double *)this + 3);
    if (*(double *)this * v10 - v9 * v11 >= 0.0)
    {
      double v14 = -v9;
      double v15 = -v11;
      double v12 = *((double *)this + 3);
      double v13 = *(double *)this;
    }
    else
    {
      double v12 = -v10;
      double v13 = -v8;
      double v14 = *((double *)this + 1);
      double v15 = *((double *)this + 2);
    }
    double v16 = v15 * v4.f64[1] + v4.f64[0] * v12;
    double v17 = v13 * v4.f64[1] + v4.f64[0] * v14;
    if (v16 != 0.0 || v17 != 0.0)
    {
      double v18 = sqrt(v17 * v17 + v16 * v16);
      double v16 = v16 / v18;
      double v17 = v17 / v18;
    }
    *(double *)&long long v31 = v16;
    *((double *)&v31 + 1) = v17;
    double v19 = v11 * v16 - v17 * v8;
    double v20 = v10 * v16 - v17 * v9;
    float64x2_t v21 = (float64x2_t *)((char *)this + 152);
    if (*((_DWORD *)this + 20) == 4)
    {
      CG::stroker::add_join(this, (double *)&a2->v, v32.f64, (double *)&v31);
      *float64x2_t v21 = v32;
      *(_OWORD *)((char *)this + 168) = v31;
    }
    else
    {
      *((_DWORD *)this + 20) = 4;
      float64x2_t v22 = v32;
      *float64x2_t v21 = v32;
      *(float64x2_t *)((char *)this + 104) = v22;
      long long v23 = v31;
      *(_OWORD *)((char *)this + 168) = v31;
      *(_OWORD *)((char *)this + 120) = v23;
      double v24 = v20 + *(double *)&a2[2].v;
      uint64_t v25 = *((void *)this + 9);
      *(double *)&v33[0].v = v19 + *(double *)&a2->v;
      double v34 = v24;
      if (v25) {
        (*(void (**)(void, void, Point *, void))(v25 + 24))(*(void *)(v25 + 8), 0, v33, *(void *)(v25 + 48));
      }
    }
    double v26 = *(double *)&a2[2].v - v20;
    *(double *)&v33[0].v = *(double *)&a2->v - v19;
    double v34 = v26;
    CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v33);
    double v27 = *(double *)&a3->v;
    double v28 = *(double *)&a3[2].v;
    uint64_t v29 = *((void *)this + 9);
    *(double *)&v33[0].v = v19 + *(double *)&a3->v;
    double v34 = v20 + v28;
    if (v29)
    {
      (*(void (**)(void, uint64_t, Point *, void))(v29 + 24))(*(void *)(v29 + 8), 1, v33, *(void *)(v29 + 48));
      double v27 = *(double *)&a3->v;
      double v28 = *(double *)&a3[2].v;
    }
    *((double *)this + 25) = v27 - v19;
    *((double *)this + 26) = v28 - v20;
  }
  return v5 > 0.00000001;
}

void CG::stroker::push_opposite_element(CG::stroker *this, CGPathElementType a2, const Point *a3)
{
  *(_OWORD *)&v15[4] = *(_OWORD *)&a3->v;
  long long v6 = (char *)*((void *)this + 28);
  unint64_t v5 = *((void *)this + 29);
  if ((unint64_t)v6 >= v5)
  {
    double v8 = (char *)*((void *)this + 27);
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v8) >> 3) + 1;
    if (v9 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)v8) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:fe180100]();
      }
      double v12 = (char *)operator new(24 * v11);
    }
    else
    {
      double v12 = 0;
    }
    double v13 = &v12[8 * ((v6 - v8) >> 3)];
    *(_DWORD *)double v13 = a2;
    *(_OWORD *)(v13 + 4) = *(_OWORD *)v15;
    *((_DWORD *)v13 + 5) = *(_DWORD *)&v15[16];
    uint64_t v7 = v13 + 24;
    if (v6 != v8)
    {
      do
      {
        long long v14 = *(_OWORD *)(v6 - 24);
        *((void *)v13 - 1) = *((void *)v6 - 1);
        *(_OWORD *)(v13 - 24) = v14;
        v13 -= 24;
        v6 -= 24;
      }
      while (v6 != v8);
      long long v6 = (char *)*((void *)this + 27);
    }
    *((void *)this + 27) = v13;
    *((void *)this + 28) = v7;
    *((void *)this + 29) = &v12[24 * v11];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *(_DWORD *)long long v6 = a2;
    *(_OWORD *)(v6 + 4) = *(_OWORD *)v15;
    *((_DWORD *)v6 + 5) = *(_DWORD *)&v15[16];
    uint64_t v7 = v6 + 24;
  }
  *((void *)this + 28) = v7;
}

uint64_t CG::stroker::end_contour(uint64_t this)
{
  uint64_t v1 = this;
  int v2 = *(_DWORD *)(this + 80);
  if (v2 == 4)
  {
    CG::stroker::add_cap(this, (double *)(this + 136), *(double *)(this + 168), *(double *)(this + 176));
    CG::stroker::unroll_path((void *)v1);
    float64x2_t v4 = vnegq_f64(*(float64x2_t *)(v1 + 120));
    this = CG::stroker::add_cap(v1, (double *)(v1 + 88), v4.f64[0], v4.f64[1]);
    unint64_t v5 = *(void **)(v1 + 72);
    if (v5)
    {
      long long v6 = (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v5[3];
      uint64_t v7 = v5[1];
      uint64_t v8 = v5[6];
      return v6(v7, 4, 0, v8);
    }
  }
  else if (v2 == 3)
  {
    float64x2_t v3 = vsubq_f64(*(float64x2_t *)(this + 184), *(float64x2_t *)(this + 88));
    return CG::stroker::add_point(this, (double *)(this + 88), v3.f64[0], v3.f64[1]);
  }
  return this;
}

uint64_t CG::stroker::add_cap(uint64_t result, double *a2, double a3, double a4)
{
  uint64_t v5 = result;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  double v6 = *(double *)(result + 16);
  double v7 = *(double *)(result + 24);
  double v8 = *(double *)(result + 8);
  double v9 = v6 * a3 - a4 * *(double *)result;
  double v10 = v7 * a3 - a4 * v8;
  int v11 = *(_DWORD *)(result + 40);
  if (v11 && v10 * v10 + v9 * v9 > 0.0025)
  {
    double v12 = v6 * a4 + a3 * *(double *)result;
    double v13 = v7 * a4 + a3 * v8;
    if (v11 != 2)
    {
      if (v11 != 1) {
        abort();
      }
      uint64_t v14 = *(void *)(result + 72);
      if (v14)
      {
        double v15 = a2[1];
        double v16 = v12 + *a2;
        double v28 = v12 * 0.55228475 + v9 + *a2;
        double v29 = v13 * 0.55228475 + v10 + v15;
        double v30 = v9 * 0.55228475 + v16;
        double v31 = v10 * 0.55228475 + v13 + v15;
        double v32 = v16;
        double v33 = v13 + v15;
        __n128 result = (*(uint64_t (**)(void, uint64_t, double *, void))(v14 + 24))(*(void *)(v14 + 8), 3, &v28, *(void *)(v14 + 48));
        uint64_t v17 = *(void *)(v5 + 72);
        if (v17)
        {
          double v18 = a2[1];
          double v19 = *a2 - v9;
          double v28 = v12 + *a2 - v9 * 0.55228475;
          double v29 = v13 + v18 - v10 * 0.55228475;
          double v30 = v12 * 0.55228475 + v19;
          double v31 = v13 * 0.55228475 + v18 - v10;
          double v32 = v19;
          double v33 = v18 - v10;
          return (*(uint64_t (**)(void, uint64_t, double *, void))(v17 + 24))(*(void *)(v17 + 8), 3, &v28, *(void *)(v17 + 48));
        }
      }
      return result;
    }
    double v23 = *a2;
    double v24 = a2[1];
    uint64_t v25 = *(void *)(result + 72);
    double v28 = v12 + v9 + *a2;
    double v29 = v13 + v10 + v24;
    if (v25)
    {
      __n128 result = (*(uint64_t (**)(void, uint64_t, double *, void))(v25 + 24))(*(void *)(v25 + 8), 1, &v28, *(void *)(v25 + 48));
      double v23 = *a2;
      double v24 = a2[1];
      uint64_t v25 = *(void *)(v5 + 72);
    }
    double v26 = v23 - v9;
    double v27 = v24 - v10;
    double v28 = v12 + v26;
    double v29 = v13 + v27;
    if (!v25)
    {
      double v28 = v26;
      double v29 = v27;
      return result;
    }
    __n128 result = (*(uint64_t (**)(void, uint64_t, double *, void))(v25 + 24))(*(void *)(v25 + 8), 1, &v28, *(void *)(v25 + 48));
    uint64_t v22 = *(void *)(v5 + 72);
    double v20 = *a2 - v9;
    double v21 = a2[1] - v10;
  }
  else
  {
    double v20 = *a2 - v9;
    double v21 = a2[1] - v10;
    uint64_t v22 = *(void *)(result + 72);
  }
  double v28 = v20;
  double v29 = v21;
  if (v22) {
    return (*(uint64_t (**)(void, uint64_t, double *, void))(v22 + 24))(*(void *)(v22 + 8), 1, &v28, *(void *)(v22 + 48));
  }
  return result;
}

void anonymous namespace'::add_element_to_path(_anonymous_namespace_ *this, void *a2, uint64_t a3, const CGAffineTransform *a4, const CGAffineTransform *a5)
{
  switch((int)a2)
  {
    case -3:
      v15.origin.CGFloat x = *(CGFloat *)a3;
      v15.origin.CGFloat y = *(CGFloat *)(a3 + 8);
      v15.size.CGFloat width = *(double *)(a3 + 16) - *(double *)a3;
      v15.size.CGFloat height = *(double *)(a3 + 24) - v15.origin.y;
      CGRect v13 = CGRectStandardize(v15);
      CG::Path::append_rect((uint64_t)this, &v13, 0);
      break;
    case 0:
      __n128 v6 = *(__n128 *)a3;
      CG::Path::move_to_point((int *)this, 0, (const CGAffineTransform *)a3, v6);
      break;
    case 1:
      float64x2_t v7 = *(float64x2_t *)a3;
      CG::Path::add_line_to_point(this, 0, (const CGAffineTransform *)a3, v7);
      break;
    case 2:
      float64x2_t v8 = *(float64x2_t *)a3;
      CG::Path::add_quad_curve_to_point(this, (float64x2_t *)(a3 + 16), 0, a4, v8);
      break;
    case 3:
      double v9 = (float64x2_t *)(a3 + 16);
      float64x2_t v11 = *(float64x2_t *)a3;
      double v10 = (float64x2_t *)(a3 + 32);
      float64x2_t v12 = v11;
      CG::Path::add_curve_to_point(this, v9, v10, 0, a5, v12);
      break;
    case 4:
      CG::Path::close_subpath((uint64_t)this);
      break;
    default:
      abort();
  }
}

void *CG::stroker::unroll_path(void *this)
{
  uint64_t v1 = this;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = this[27];
  for (uint64_t i = this[28]; i != v2; i -= 24)
  {
    int v4 = *(_DWORD *)(i - 24);
    if (v4 == 3)
    {
      uint64_t v6 = v1[9];
      if (v6)
      {
        long long v7 = *(_OWORD *)(i - 40);
        long long v8 = *(_OWORD *)(i - 16);
        v9[0] = *(_OWORD *)(i - 64);
        v9[1] = v7;
        v9[2] = v8;
        this = (void *)(*(uint64_t (**)(void, uint64_t, _OWORD *, void))(v6 + 24))(*(void *)(v6 + 8), 3, v9, *(void *)(v6 + 48));
      }
      i -= 48;
    }
    else if (v4 == 1)
    {
      uint64_t v5 = v1[9];
      v9[0] = *(_OWORD *)(i - 16);
      if (v5) {
        this = (void *)(*(uint64_t (**)(void, uint64_t, _OWORD *, void))(v5 + 24))(*(void *)(v5 + 8), 1, v9, *(void *)(v5 + 48));
      }
    }
    uint64_t v2 = v1[27];
  }
  v1[28] = i;
  return this;
}

void ripr_stroke_iterate(uint64_t a1, int a2, double *a3)
{
  switch(a2)
  {
    case -3:
      float v3 = *a3;
      float v4 = a3[1];
      float v5 = a3[2];
      float v6 = a3[3];
      aa_rectat(a1, v3, v4, v5, v6);
      break;
    case 0:
      float v7 = *a3;
      float v8 = a3[1];
      aa_moveto(a1, v7, v8);
      break;
    case 1:
      float v9 = *a3;
      float v10 = a3[1];
      aa_lineto(a1, v9, v10);
      break;
    case 2:
      float v11 = *a3;
      float v12 = a3[1];
      float v13 = a3[2];
      float v14 = a3[3];
      aa_quadto(a1, v11, v12, v13, v14);
      break;
    case 3:
      float v15 = *a3;
      float v16 = a3[1];
      float v17 = a3[2];
      float v18 = a3[3];
      float v19 = a3[4];
      float v20 = a3[5];
      aa_cubeto(a1, v15, v16, v17, v18, v19, v20);
      break;
    case 4:
      aa_close(a1);
      break;
    default:
      abort();
  }
}

void CG::stroker::add_join(CG::stroker *this, double *a2, double *a3, double *a4)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  int v8 = *((_DWORD *)this + 11);
  if (v8)
  {
    if (v8 != 1)
    {
      if (v8 != 2) {
        abort();
      }
      goto LABEL_15;
    }
    double v32 = *((double *)this + 21);
    double v33 = *((double *)this + 22);
    double v34 = *((double *)this + 2);
    double v35 = *((double *)this + 3);
    double v37 = *(double *)this;
    double v36 = *((double *)this + 1);
    double v38 = v32 * v34 - v33 * *(double *)this;
    double v39 = v32 * v35 - v33 * v36;
    double v40 = a4[1];
    double v17 = v34 * *a4 - v40 * *(double *)this;
    double v18 = v35 * *a4 - v40 * v36;
    if ((v39 - v18) * (v39 - v18) + (v38 - v17) * (v38 - v17) < 0.05)
    {
LABEL_15:
      CG::stroker::add_bevel_join((uint64_t)this, a2, a3, a4);
      return;
    }
    double v41 = -v33;
    double v42 = a2[1] - v18;
    *((double *)this + 25) = *a2 - v17;
    *((double *)this + 26) = v42;
    double v43 = *a4;
    double v44 = a4[1];
    double v45 = v32 + *a4;
    double v46 = v33 + v44;
    double v47 = sqrt(v46 * v46 + v45 * v45);
    if (v47 >= 0.001)
    {
      double v49 = 2.66666667 / v47;
      if (vabdd_f64(v33, v44) <= vabdd_f64(v32, v43)) {
        double v48 = -(v46 * -1.33333333 + v49 * v46) / (v32 - v43);
      }
      else {
        double v48 = (v45 * -1.33333333 + v49 * v45) / (v33 - v44);
      }
    }
    else
    {
      double v48 = -1.33333333;
    }
    double v60 = v32 + v33 * v48;
    double v61 = v33 - v32 * v48;
    double v62 = v34 * v60 - v61 * v37;
    double v63 = v35 * v60 - v61 * v36;
    double v64 = v43 * v48;
    double v65 = v43 - v44 * v48;
    double v66 = v44 + v64;
    double v67 = v34 * v65 - v66 * v37;
    double v68 = v35 * v65 - v66 * v36;
    if (v43 * v41 + v32 * v44 < 0.0 && v47 >= 0.001)
    {
      double v69 = a2[1] - v39;
      *(double *)&v80[0].v = *a2 - v38;
      *(double *)&v80[2].v = v69;
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v80);
      if (sqrt(*((double *)this + 20) * *((double *)this + 20) + *((double *)this + 19) * *((double *)this + 19)) < sqrt(v39 * v39 + v38 * v38)
        || sqrt(a3[1] * a3[1] + *a3 * *a3) < sqrt(v18 * v18 + v17 * v17))
      {
        CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)a2);
      }
      uint64_t v70 = *((void *)this + 9);
      if (v70)
      {
        double v71 = a2[1];
        double v72 = v17 + *a2;
        double v73 = v67 + *a2;
        *(double *)&v80[0].v = v62 + *a2;
        *(double *)&v80[2].v = v63 + v71;
        double v81 = v73;
        double v82 = v68 + v71;
        double v83 = v72;
        double v84 = v18 + v71;
        (*(void (**)(void, uint64_t, Point *, void))(v70 + 24))(*(void *)(v70 + 8), 3, v80, *(void *)(v70 + 48));
      }
      return;
    }
    double v74 = a2[1] - v68;
    *(double *)&v80[0].v = *a2 - v67;
    *(double *)&v80[2].v = v74;
    CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v80);
    double v75 = a2[1] - v63;
    *(double *)&v80[0].v = *a2 - v62;
    *(double *)&v80[2].v = v75;
    CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v80);
    double v76 = a2[1] - v39;
    *(double *)&v80[0].v = *a2 - v38;
    *(double *)&v80[2].v = v76;
    CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v80);
    if (sqrt(*((double *)this + 20) * *((double *)this + 20) + *((double *)this + 19) * *((double *)this + 19)) < sqrt(v39 * v39 + v38 * v38)
      || sqrt(a3[1] * a3[1] + *a3 * *a3) < sqrt(v18 * v18 + v17 * v17))
    {
      uint64_t v31 = *((void *)this + 9);
      *(_OWORD *)&v80[0].v = *(_OWORD *)a2;
      if (v31) {
LABEL_39:
      }
        (*(void (**)(void, uint64_t, Point *, void))(v31 + 24))(*(void *)(v31 + 8), 1, v80, *(void *)(v31 + 48));
    }
  }
  else
  {
    double v10 = *((double *)this + 21);
    double v9 = *((double *)this + 22);
    double v11 = *((double *)this + 2);
    double v12 = *((double *)this + 3);
    double v13 = *((double *)this + 1);
    double v14 = v10 * v11 - v9 * *(double *)this;
    double v15 = v10 * v12 - v9 * v13;
    double v16 = a4[1];
    double v17 = v11 * *a4 - v16 * *(double *)this;
    double v18 = v12 * *a4 - v16 * v13;
    if ((v15 - v18) * (v15 - v18) + (v14 - v17) * (v14 - v17) < 0.05) {
      goto LABEL_15;
    }
    double v19 = a2[1] - v18;
    *((double *)this + 25) = *a2 - v17;
    *((double *)this + 26) = v19;
    if (*((double *)this + 6) * *((double *)this + 6) * (v9 * a4[1] + v10 * *a4 + 1.0) < 2.0) {
      goto LABEL_15;
    }
    double v20 = a2[1] - v15;
    *(double *)&v80[0].v = *a2 - v14;
    *(double *)&v80[2].v = v20;
    CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v80);
    if (*((double *)this + 21) * a4[1] - *((double *)this + 22) * *a4 >= 0.0)
    {
      double v50 = *((double *)this + 19);
      double v51 = *((double *)this + 20);
      double v52 = a3[1];
      double v53 = *a3 * v51 - v52 * v50;
      if (fabs(v53) >= 0.0001)
      {
        double v54 = a2[1];
        double v55 = v54 - v18;
        double v56 = v54 - v15;
        double v57 = *a2 - v14;
        double v58 = ((*a2 - v17 - v57) * -v52 + *a3 * (v55 - v56)) / v53;
        *(double *)&v80[2].v = v57 + v50 * v58;
        double v81 = v56 + v51 * v58;
        LOBYTE(v80[0].v) = 1;
        CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, &v80[2]);
        double v50 = *((double *)this + 19);
        double v51 = *((double *)this + 20);
      }
      if (sqrt(v51 * v51 + v50 * v50) < sqrt(v15 * v15 + v14 * v14)
        || sqrt(a3[1] * a3[1] + *a3 * *a3) < sqrt(v18 * v18 + v17 * v17))
      {
        uint64_t v59 = *((void *)this + 9);
        long long v79 = *(_OWORD *)a2;
        if (v59) {
          (*(void (**)(void, uint64_t, long long *, void))(v59 + 24))(*(void *)(v59 + 8), 1, &v79, *(void *)(v59 + 48));
        }
      }
      goto LABEL_40;
    }
    double v21 = *((double *)this + 19);
    double v22 = *((double *)this + 20);
    if (sqrt(v22 * v22 + v21 * v21) < sqrt(v15 * v15 + v14 * v14)
      || (double v23 = *a3, v24 = a3[1], sqrt(v24 * v24 + v23 * v23) < sqrt(v18 * v18 + v17 * v17)))
    {
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)a2);
      double v21 = *((double *)this + 19);
      double v22 = *((double *)this + 20);
      double v23 = *a3;
      double v24 = a3[1];
    }
    double v25 = v23 * v22 - v24 * v21;
    if (fabs(v25) >= 0.0001)
    {
      double v26 = a2[1];
      double v27 = v18 + v26;
      double v28 = v15 + v26;
      double v29 = v14 + *a2;
      double v30 = ((v17 + *a2 - v29) * -v24 + v23 * (v27 - v28)) / v25;
      uint64_t v31 = *((void *)this + 9);
      *(double *)&v80[0].v = v29 + v21 * v30;
      *(double *)&v80[2].v = v28 + v22 * v30;
      if (v31) {
        goto LABEL_39;
      }
    }
  }
LABEL_40:
  double v77 = v18 + a2[1];
  uint64_t v78 = *((void *)this + 9);
  *(double *)&v80[0].v = v17 + *a2;
  *(double *)&v80[2].v = v77;
  if (v78) {
    (*(void (**)(void, uint64_t, Point *, void))(v78 + 24))(*(void *)(v78 + 8), 1, v80, *(void *)(v78 + 48));
  }
}

void CG::stroker::add_cubic_segment(CG::stroker *this, float64x2_t *a2)
{
  uint64_t v2 = a2;
  double v4 = a2[1].f64[0];
  double v5 = a2[1].f64[1];
  if ((v5 - a2->f64[1]) * (v5 - a2->f64[1]) + (v4 - a2->f64[0]) * (v4 - a2->f64[0]) <= 0.00000001
    && (double v6 = a2[2].f64[0], v7 = a2[2].f64[1], (v7 - v5) * (v7 - v5) + (v6 - v4) * (v6 - v4) <= 0.00000001)
    && (a2[3].f64[1] - v7) * (a2[3].f64[1] - v7) + (a2[3].f64[0] - v6) * (a2[3].f64[0] - v6) <= 0.00000001)
  {
    if (*((_DWORD *)this + 20) == 2) {
      *((_DWORD *)this + 20) = 3;
    }
  }
  else
  {
    *(void *)&double v8 = *(_OWORD *)&CG::Cubic::derivative(a2, 0.0);
    *(double *)&long long v78 = v8;
    *((double *)&v78 + 1) = v9;
    double v10 = *(double *)this;
    double v11 = *((double *)this + 1);
    double v13 = *((double *)this + 2);
    double v12 = *((double *)this + 3);
    if (*(double *)this * v12 - v11 * v13 >= 0.0)
    {
      double v16 = -v11;
      double v17 = -v13;
      double v14 = *((double *)this + 3);
      double v15 = *(double *)this;
    }
    else
    {
      double v14 = -v12;
      double v15 = -v10;
      double v16 = *((double *)this + 1);
      double v17 = *((double *)this + 2);
    }
    double v18 = v17 * v9 + v8 * v14;
    double v19 = v15 * v9 + v8 * v16;
    if (v18 != 0.0 || v19 != 0.0)
    {
      double v20 = sqrt(v19 * v19 + v18 * v18);
      double v18 = v18 / v20;
      double v19 = v19 / v20;
    }
    *(double *)&long long v77 = v18;
    *((double *)&v77 + 1) = v19;
    if (*((_DWORD *)this + 20) == 4)
    {
      float64x2_t v62 = *v2;
      CG::stroker::add_join(this, v62.f64, (double *)&v78, (double *)&v77);
    }
    else
    {
      *((_DWORD *)this + 20) = 4;
      *(_OWORD *)((char *)this + 104) = v78;
      *(_OWORD *)((char *)this + 120) = v77;
      double v21 = v13 * v18 - v19 * v10 + v2->f64[0];
      double v22 = v12 * v18 - v19 * v11 + v2->f64[1];
      uint64_t v23 = *((void *)this + 9);
      v62.f64[0] = v21;
      v62.f64[1] = v22;
      if (v23) {
        (*(void (**)(void, void, float64x2_t *, void))(v23 + 24))(*(void *)(v23 + 8), 0, &v62, *(void *)(v23 + 48));
      }
    }
    *(void *)&double v24 = *(_OWORD *)&CG::Cubic::derivative(v2, 1.0);
    *((double *)this + 19) = v24;
    *((double *)this + 20) = v25;
    double v26 = *(double *)this;
    double v27 = *((double *)this + 1);
    double v29 = *((double *)this + 2);
    double v28 = *((double *)this + 3);
    if (*(double *)this * v28 - v27 * v29 >= 0.0)
    {
      double v27 = -v27;
      double v29 = -v29;
    }
    else
    {
      double v28 = -v28;
      double v26 = -v26;
    }
    double v30 = v29 * v25 + v24 * v28;
    double v31 = v26 * v25 + v24 * v27;
    if (v30 != 0.0 || v31 != 0.0)
    {
      double v32 = sqrt(v31 * v31 + v30 * v30);
      double v30 = v30 / v32;
      double v31 = v31 / v32;
    }
    *((double *)this + 21) = v30;
    *((double *)this + 22) = v31;
    CG::Cubic::points((CG::Cubic *)v76, v2);
    double v33 = (void *)v76[0];
    if (v76[1] - v76[0] > 0x30uLL)
    {
      double v34 = *(double *)(v76[0] + 16);
      if (((v34 - *(double *)v76[0]) * (*(double *)(v76[0] + 40) - *(double *)(v76[0] + 24))
          - (*(double *)(v76[0] + 24) - *(double *)(v76[0] + 8)) * (*(double *)(v76[0] + 32) - v34))
         * ((*(double *)(v76[0] + 32) - v34) * (*(double *)(v76[0] + 56) - *(double *)(v76[0] + 40))
          - (*(double *)(v76[0] + 40) - *(double *)(v76[0] + 24))
          * (*(double *)(v76[0] + 48) - *(double *)(v76[0] + 32))) > 0.0)
        goto LABEL_48;
      double v35 = v2[6].f64[0];
      double v36 = -1.0;
      if (v35 == 0.0)
      {
        char v40 = 1;
      }
      else
      {
        double v37 = v2[5].f64[0];
        double v38 = v35 * 3.0;
        double v39 = -v37;
        if (v37 < 0.0 && v38 > v39) {
          goto LABEL_27;
        }
        char v40 = 1;
        if (v37 > 0.0)
        {
          double v41 = -1.0;
          if (v38 >= v39)
          {
LABEL_31:
            double v42 = v2[6].f64[1];
            if (v42 != 0.0)
            {
              if ((double v43 = v2[5].f64[1], v44 = v42 * 3.0, v45 = -v43, v43 < 0.0) && v44 > v45 || v43 > 0.0 && v44 < v45)
              {
                double v46 = v45 / v44;
                if (v40)
                {
                  double v41 = v46;
                }
                else if (vabdd_f64(v41, v46) >= 0.000001)
                {
                  double v36 = v41 >= v46 ? v41 : v46;
                  if (v41 >= v46) {
                    double v41 = v46;
                  }
                }
              }
            }
            if (v41 != -1.0 || v36 != -1.0)
            {
              CG::Cubic::split(&v62, v41, v2);
              if (((v64 - v62.f64[1]) * (v64 - v62.f64[1]) + (v63 - v62.f64[0]) * (v63 - v62.f64[0]) > 0.00000001
                 || (v66 - v64) * (v66 - v64) + (v65 - v63) * (v65 - v63) > 0.00000001
                 || (v68 - v66) * (v68 - v66) + (v67 - v65) * (v67 - v65) > 0.00000001)
                && ((v71 - v69.f64[1]) * (v71 - v69.f64[1]) + (v70 - v69.f64[0]) * (v70 - v69.f64[0]) > 0.00000001
                 || (v73 - v71) * (v73 - v71) + (v72 - v70) * (v72 - v70) > 0.00000001
                 || (v75 - v73) * (v75 - v73) + (v74 - v72) * (v74 - v72) > 0.00000001))
              {
                CG::stroker::path_stroke_round_cube(this, &v62);
                uint64_t v2 = &v69;
                if (v36 != -1.0)
                {
                  CG::Cubic::split(&v47, (v36 - v41) / (1.0 - v41), &v69);
                  if (((v49 - v47.f64[1]) * (v49 - v47.f64[1]) + (v48 - v47.f64[0]) * (v48 - v47.f64[0]) > 0.00000001
                     || (v51 - v49) * (v51 - v49) + (v50 - v48) * (v50 - v48) > 0.00000001
                     || (v53 - v51) * (v53 - v51) + (v52 - v50) * (v52 - v50) > 0.00000001)
                    && ((v57 - v55) * (v57 - v55) + (v56 - v54) * (v56 - v54) > 0.00000001
                     || (v59 - v57) * (v59 - v57) + (v58 - v56) * (v58 - v56) > 0.00000001
                     || (v61 - v59) * (v61 - v59) + (v60 - v58) * (v60 - v58) > 0.00000001))
                  {
                    CG::stroker::path_stroke_round_cube(this, &v47);
                    uint64_t v2 = (float64x2_t *)&v54;
                  }
                  CG::stroker::path_stroke_round_cube(this, v2);
                  goto LABEL_65;
                }
              }
            }
LABEL_48:
            CG::stroker::path_stroke_round_cube(this, v2);
LABEL_65:
            operator delete(v33);
            return;
          }
LABEL_27:
          char v40 = 0;
          double v41 = v39 / v38;
          goto LABEL_31;
        }
      }
      double v41 = -1.0;
      goto LABEL_31;
    }
    __break(1u);
  }
}

void sub_184C7FDEC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void CG::stroker::add_bevel_join(uint64_t a1, double *a2, double *a3, double *a4)
{
  double v5 = *(double *)(a1 + 168);
  double v4 = *(double *)(a1 + 176);
  double v6 = *(double *)(a1 + 16);
  double v7 = *(double *)(a1 + 24);
  double v8 = *(double *)(a1 + 8);
  double v9 = v5 * v6 - v4 * *(double *)a1;
  double v10 = v5 * v7 - v4 * v8;
  double v11 = a4[1];
  double v12 = v6 * *a4 - v11 * *(double *)a1;
  double v13 = v7 * *a4 - v11 * v8;
  if ((v10 - v13) * (v10 - v13) + (v9 - v12) * (v9 - v12) >= *(double *)(a1 + 64) * *(double *)(a1 + 64))
  {
    double v18 = a2[1] - v13;
    *(double *)(a1 + 200) = *a2 - v12;
    *(double *)(a1 + 208) = v18;
    double v19 = a2[1] - v10;
    *(double *)&long long v23 = *a2 - v9;
    *((double *)&v23 + 1) = v19;
    CG::stroker::push_opposite_element((CG::stroker *)a1, kCGPathElementAddLineToPoint, (const Point *)&v23);
    if (sqrt(*(double *)(a1 + 160) * *(double *)(a1 + 160) + *(double *)(a1 + 152) * *(double *)(a1 + 152)) < sqrt(v10 * v10 + v9 * v9)
      || sqrt(a3[1] * a3[1] + *a3 * *a3) < sqrt(v13 * v13 + v12 * v12))
    {
      if (*(double *)(a1 + 168) * a4[1] - *(double *)(a1 + 176) * *a4 >= 0.0)
      {
        uint64_t v20 = *(void *)(a1 + 72);
        long long v23 = *(_OWORD *)a2;
        if (v20) {
          (*(void (**)(void, uint64_t, long long *, void))(v20 + 24))(*(void *)(v20 + 8), 1, &v23, *(void *)(v20 + 48));
        }
      }
      else
      {
        CG::stroker::push_opposite_element((CG::stroker *)a1, kCGPathElementAddLineToPoint, (const Point *)a2);
      }
    }
    double v21 = v13 + a2[1];
    uint64_t v22 = *(void *)(a1 + 72);
    *(double *)&long long v23 = v12 + *a2;
    *((double *)&v23 + 1) = v21;
    if (v22) {
      (*(void (**)(void, uint64_t, long long *, void))(v22 + 24))(*(void *)(v22 + 8), 1, &v23, *(void *)(v22 + 48));
    }
  }
}

void CG::stroker::path_stroke_round_cube(CG::stroker *this, float64x2_t *a2)
{
  CG::Cubic::points((CG::Cubic *)v43, a2);
  double v4 = (void *)v43[0];
  if (v43[1] - v43[0] <= 0x30uLL)
  {
    __break(1u);
  }
  else
  {
    double v5 = *(double *)(v43[0] + 16);
    double v6 = *(double *)(v43[0] + 24);
    double v7 = v5 - *(double *)v43[0];
    double v8 = v6 - *(double *)(v43[0] + 8);
    double v9 = *(double *)(v43[0] + 32);
    double v10 = *(double *)(v43[0] + 40);
    double v11 = v9 - v5;
    double v12 = v10 - v6;
    if (v8 * v12 + v7 * v11 >= 0.0
      && v12 * (*(double *)(v43[0] + 56) - v10) + v11 * (*(double *)(v43[0] + 48) - v9) >= 0.0)
    {
      CG::stroker::path_stroke_round_cube_offset(this, a2, 4, 1);
      float64x2_t v19 = a2[2];
      float64x2_t v35 = a2[3];
      float64x2_t v36 = v19;
      float64x2_t v20 = *a2;
      float64x2_t v37 = a2[1];
      float64x2_t v38 = v20;
      float64x2_t v21 = vsubq_f64(v36, v35);
      __asm { FMOV            V2.2D, #3.0 }
      float64x2_t v27 = vsubq_f64(v37, v36);
      float64x2_t v39 = vmulq_f64(v21, _Q2);
      float64x2_t v40 = vmulq_f64(vsubq_f64(v27, v21), _Q2);
      float64x2_t v41 = vaddq_f64(v21, vsubq_f64(vsubq_f64(v38, v37), vaddq_f64(v27, v27)));
      CG::stroker::path_stroke_round_cube_offset(this, &v35, 4, -1);
    }
    else
    {
      double v14 = a2[1].f64[0];
      double v13 = a2[1].f64[1];
      double v16 = a2->f64[0];
      double v15 = a2->f64[1];
      if ((v13 - v15) * (v13 - v15) + (v14 - a2->f64[0]) * (v14 - a2->f64[0]) <= 0.00000001
        && (double v17 = a2[2].f64[0], v18 = a2[2].f64[1], (v18 - v13) * (v18 - v13) + (v17 - v14) * (v17 - v14) <= 0.00000001)
        && (a2[3].f64[1] - v18) * (a2[3].f64[1] - v18) + (a2[3].f64[0] - v17) * (a2[3].f64[0] - v17) <= 0.00000001)
      {
        v35.f64[0] = v16 - CG::stroker::offset_normal((double *)this, a2, 0, 0.0);
        v35.f64[1] = v15 - v28;
        CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)&v35);
        double v29 = a2[3].f64[0];
        double v30 = a2[3].f64[1];
        double v31 = CG::stroker::offset_normal((double *)this, a2, 0, 1.0);
        double v33 = v32;
        uint64_t v34 = *((void *)this + 9);
        v35.f64[0] = v29 + v31;
        v35.f64[1] = v30 + v32;
        if (v34) {
          (*(void (**)(void, uint64_t, float64x2_t *, void))(v34 + 24))(*(void *)(v34 + 8), 1, &v35, *(void *)(v34 + 48));
        }
        *((double *)this + 25) = v29 - v31;
        *((double *)this + 26) = v30 - v33;
      }
      else
      {
        CG::Cubic::split(&v35, 0.5, a2);
        if (v16 != v35.f64[0]
          || v15 != v35.f64[1]
          || v14 != v36.f64[0]
          || v13 != v36.f64[1]
          || a2[2].f64[0] != v37.f64[0]
          || a2[2].f64[1] != v37.f64[1]
          || a2[3].f64[0] != v38.f64[0]
          || a2[3].f64[1] != v38.f64[1])
        {
          CG::stroker::path_stroke_round_cube(this, (const CG::Cubic *)&v35);
          if (a2->f64[0] != v42[0]
            || a2->f64[1] != v42[1]
            || a2[1].f64[0] != v42[2]
            || a2[1].f64[1] != v42[3]
            || a2[2].f64[0] != v42[4]
            || a2[2].f64[1] != v42[5]
            || a2[3].f64[0] != v42[6]
            || a2[3].f64[1] != v42[7])
          {
            CG::stroker::path_stroke_round_cube(this, (const CG::Cubic *)v42);
          }
        }
      }
    }
    operator delete(v4);
  }
}

void sub_184C803E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void CG::Cubic::points(CG::Cubic *this, _OWORD *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  double v4 = operator new(0x10uLL);
  *double v4 = *a2;
  *(void *)this = v4;
  *((void *)this + 1) = v4 + 1;
  *((void *)this + 2) = v4 + 1;
  double v5 = std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(2uLL);
  uint64_t v7 = v6;
  double v8 = (char *)&v5[v6];
  v5[1] = a2[1];
  double v9 = v5 + 2;
  *double v5 = *v4;
  double v10 = *(void **)this;
  *(void *)this = v5;
  *((void *)this + 1) = v5 + 2;
  *((void *)this + 2) = v8;
  if (v10) {
    operator delete(v10);
  }
  *((void *)this + 1) = v9;
  double v11 = a2 + 2;
  if (v7 < 3)
  {
    uint64_t v13 = 3;
    if ((unint64_t)((v8 - (char *)v5) >> 3) > 3) {
      uint64_t v13 = (v8 - (char *)v5) >> 3;
    }
    if ((unint64_t)(v8 - (char *)v5) >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v14);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = 0;
    unint64_t v17 = v14 + 32;
    double v8 = (char *)(v14 + 16 * v15);
    *(_OWORD *)(v14 + 32) = *v11;
    double v12 = (char *)(v14 + 48);
    do
    {
      *(_OWORD *)(v17 + v16 * 16 - 16) = v5[v16 + 1];
      --v16;
    }
    while (v16 != -2);
    double v18 = *(void **)this;
    *(void *)this = v17 - 32;
    *((void *)this + 1) = v12;
    *((void *)this + 2) = v8;
    if (v18)
    {
      operator delete(v18);
      double v8 = (char *)*((void *)this + 2);
    }
  }
  else
  {
    *double v9 = *v11;
    double v12 = (char *)(v5 + 3);
  }
  *((void *)this + 1) = v12;
  float64x2_t v19 = a2 + 3;
  if (v12 < v8)
  {
    *(_OWORD *)double v12 = *v19;
    float64x2_t v20 = v12 + 16;
    goto LABEL_34;
  }
  float64x2_t v21 = *(char **)this;
  uint64_t v22 = (uint64_t)&v12[-*(void *)this] >> 4;
  unint64_t v23 = v22 + 1;
  if ((unint64_t)(v22 + 1) >> 60) {
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
  }
  if ((v8 - v21) >> 3 > v23) {
    unint64_t v23 = (v8 - v21) >> 3;
  }
  if ((unint64_t)(v8 - v21) >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24) {
    unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v24);
  }
  else {
    uint64_t v25 = 0;
  }
  double v26 = (_OWORD *)(v24 + 16 * v22);
  unint64_t v27 = v24 + 16 * v25;
  *double v26 = *v19;
  float64x2_t v20 = v26 + 1;
  if (v12 == v21)
  {
    *(void *)this = v26;
    *((void *)this + 1) = v20;
    *((void *)this + 2) = v27;
LABEL_33:
    operator delete(v12);
    goto LABEL_34;
  }
  do
  {
    *--double v26 = *((_OWORD *)v12 - 1);
    v12 -= 16;
  }
  while (v12 != v21);
  double v12 = *(char **)this;
  *(void *)this = v26;
  *((void *)this + 1) = v20;
  *((void *)this + 2) = v27;
  if (v12) {
    goto LABEL_33;
  }
LABEL_34:
  *((void *)this + 1) = v20;
}

void sub_184C8062C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

void CG::dasher::add_path_dash_segment<CG::Cubic>(double *a1, float64x2_t *a2, double a3, double a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  float64x2_t v8 = a2[1];
  float64x2_t v47 = *a2;
  float64x2_t v48 = v8;
  float64x2_t v9 = a2[3];
  float64x2_t v49 = a2[2];
  float64x2_t v50 = v9;
  float64x2_t v10 = a2[5];
  float64x2_t v51 = a2[4];
  float64x2_t v52 = v10;
  float64x2_t v53 = a2[6];
  double v11 = a1[6];
  double v12 = a1[7];
  double v13 = a1[4];
  double v14 = a1[5];
  float64_t v15 = v47.f64[1] * v12 + v47.f64[0] * v14;
  v10.f64[0] = v12 * v48.f64[1] + v48.f64[0] * v14;
  double v16 = v12 * v49.f64[1] + v49.f64[0] * v14;
  double v17 = v12 * v50.f64[1] + v50.f64[0] * v14;
  v47.f64[0] = v47.f64[1] * v11 + v47.f64[0] * v13;
  v47.f64[1] = v15;
  v48.f64[0] = v11 * v48.f64[1] + v48.f64[0] * v13;
  v48.f64[1] = v10.f64[0];
  v49.f64[0] = v11 * v49.f64[1] + v49.f64[0] * v13;
  v49.f64[1] = v16;
  v50.f64[0] = v11 * v50.f64[1] + v50.f64[0] * v13;
  v50.f64[1] = v17;
  float64x2_t v18 = vsubq_f64(v48, v47);
  __asm { FMOV            V5.2D, #3.0 }
  float64x2_t v24 = vsubq_f64(v49, v48);
  float64x2_t v39 = _Q5;
  float64x2_t v51 = vmulq_f64(v18, _Q5);
  float64x2_t v52 = vmulq_f64(vsubq_f64(v24, v18), _Q5);
  float64x2_t v53 = vaddq_f64(v18, vsubq_f64(vsubq_f64(v50, v49), vaddq_f64(v24, v24)));
  CG::Cubic::index(&v47, a3);
  CG::Cubic::split(&v47, v25, a2);
  if (*((unsigned char *)a1 + 144))
  {
    double v26 = *a1;
    float64x2_t v40 = v54;
    if (v26 != 0.0) {
      (*(void (**)(void, void, float64x2_t *, void))(*(void *)&v26 + 24))(*(void *)(*(void *)&v26 + 8), 0, &v40, *(void *)(*(void *)&v26 + 48));
    }
  }
  if (a3 == a4)
  {
    double v27 = CG::Cubic::derivative(&v54, 0.0).f64[0];
    v29.f64[0] = v27;
    v29.f64[1] = v28;
    if (v27 != 0.0 || v28 != 0.0) {
      float64x2_t v29 = vdivq_f64(v29, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(v28 * v28 + v27 * v27)), 0));
    }
    double v30 = *a1;
    float64x2_t v40 = vaddq_f64(vmulq_f64(v29, (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL)), v54);
    if (v30 != 0.0) {
      (*(void (**)(void, uint64_t, float64x2_t *, void))(*(void *)&v30 + 24))(*(void *)(*(void *)&v30 + 8), 1, &v40, *(void *)(*(void *)&v30 + 48));
    }
  }
  else
  {
    float64x2_t v40 = v54;
    float64x2_t v41 = v55;
    float64x2_t v42 = v56;
    float64x2_t v43 = v57;
    float64x2_t v44 = v58;
    float64x2_t v45 = v59;
    float64x2_t v46 = v60;
    double v31 = a1[6];
    double v32 = a1[7];
    double v33 = a1[4];
    double v34 = a1[5];
    v40.f64[0] = v54.f64[1] * v31 + v54.f64[0] * v33;
    v40.f64[1] = v54.f64[1] * v32 + v54.f64[0] * v34;
    v41.f64[0] = v31 * v55.f64[1] + v55.f64[0] * v33;
    v41.f64[1] = v32 * v55.f64[1] + v55.f64[0] * v34;
    v42.f64[0] = v31 * v56.f64[1] + v56.f64[0] * v33;
    v42.f64[1] = v32 * v56.f64[1] + v56.f64[0] * v34;
    v43.f64[0] = v31 * v57.f64[1] + v57.f64[0] * v33;
    v43.f64[1] = v32 * v57.f64[1] + v57.f64[0] * v34;
    float64x2_t v35 = vsubq_f64(v41, v40);
    float64x2_t v36 = vsubq_f64(v42, v41);
    float64x2_t v44 = vmulq_f64(v35, v39);
    float64x2_t v45 = vmulq_f64(vsubq_f64(v36, v35), v39);
    float64x2_t v46 = vaddq_f64(v35, vsubq_f64(vsubq_f64(v43, v42), vaddq_f64(v36, v36)));
    CG::Cubic::index(&v40, a4 - a3);
    CG::Cubic::split(&v40, v37, &v54);
    double v38 = *a1;
    if (*(void *)a1)
    {
      v61[0] = v41;
      v61[1] = v42;
      v61[2] = v43;
      (*(void (**)(void, uint64_t, _OWORD *, void))(*(void *)&v38 + 24))(*(void *)(*(void *)&v38 + 8), 3, v61, *(void *)(*(void *)&v38 + 48));
    }
  }
}

float64x2_t *CG::Cubic::index(float64x2_t *this, double a2)
{
  if (a2 > 0.0)
  {
    float v3 = this;
    this = CG::Cubic::length(this, 0);
    if (v4 > a2)
    {
      double v5 = 1.0;
      double v6 = 0.0;
      do
      {
        CG::Cubic::split(v8, (v5 + v6) * 0.5, v3);
        this = CG::Cubic::length(v8, 0);
        if (v7 <= a2) {
          double v6 = (v5 + v6) * 0.5;
        }
        else {
          double v5 = (v5 + v6) * 0.5;
        }
      }
      while (v5 - v6 > 0.0001);
    }
  }
  return this;
}

float64x2_t *CG::Cubic::length(float64x2_t *this, int a2)
{
  __asm { FMOV            V2.2D, #3.0 }
  float64x2_t v7 = this[3];
  float64x2_t v8 = vaddq_f64(vmulq_f64(vsubq_f64(this[1], *this), _Q2), vsubq_f64(*this, v7));
  float64x2_t v9 = vaddq_f64(vsubq_f64(v7, *this), vmulq_f64(vsubq_f64(this[2], v7), _Q2));
  float64x2_t v10 = vmulq_f64(v8, v8);
  float64x2_t v11 = vmulq_f64(v9, v9);
  if (vaddvq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v11, v10), (int8x16_t)v11, (int8x16_t)v10)) >= 4.0
    && a2 <= 500)
  {
    CG::Cubic::split(v14, 0.5, this);
    int v13 = a2 + 1;
    CG::Cubic::length((CG::Cubic *)v14, v13);
    return (float64x2_t *)CG::Cubic::length((CG::Cubic *)&v15, v13);
  }
  return this;
}

float64x2_t CG::Cubic::split(float64x2_t *this, double a2, float64x2_t *a3)
{
  float64x2_t v4 = *a3;
  float64x2_t v3 = a3[1];
  float64x2_t v5 = vaddq_f64(*a3, vmulq_n_f64(vsubq_f64(v3, *a3), a2));
  float64x2_t v6 = a3[2];
  float64x2_t v7 = a3[3];
  float64x2_t v8 = vaddq_f64(v3, vmulq_n_f64(vsubq_f64(v6, v3), a2));
  float64x2_t v9 = vaddq_f64(v6, vmulq_n_f64(vsubq_f64(v7, v6), a2));
  float64x2_t v10 = vaddq_f64(v5, vmulq_n_f64(vsubq_f64(v8, v5), a2));
  float64x2_t v11 = vaddq_f64(v8, vmulq_n_f64(vsubq_f64(v9, v8), a2));
  float64x2_t v12 = vaddq_f64(v10, vmulq_n_f64(vsubq_f64(v11, v10), a2));
  *this = *a3;
  this[1] = v5;
  this[2] = v10;
  this[3] = v12;
  float64x2_t v13 = vsubq_f64(v5, v4);
  __asm { FMOV            V7.2D, #3.0 }
  float64x2_t v19 = vsubq_f64(v10, v5);
  this[4] = vmulq_f64(v13, _Q7);
  this[5] = vmulq_f64(vsubq_f64(v19, v13), _Q7);
  this[6] = vaddq_f64(v13, vsubq_f64(vsubq_f64(v12, v10), vaddq_f64(v19, v19)));
  this[7] = v12;
  this[8] = v11;
  this[9] = v9;
  float64x2_t v20 = vsubq_f64(v11, v12);
  this[10] = v7;
  this[11] = vmulq_f64(v20, _Q7);
  float64x2_t v21 = vsubq_f64(v9, v11);
  float64x2_t v22 = vmulq_f64(vsubq_f64(v21, v20), _Q7);
  float64x2_t result = vaddq_f64(vsubq_f64(vsubq_f64(v7, v9), vaddq_f64(v21, v21)), v20);
  this[12] = v22;
  this[13] = result;
  return result;
}

uint64_t CG::stroker::add_point(uint64_t result, double *a2, double a3, double a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(result + 40);
  if (!v4) {
    return result;
  }
  BOOL v6 = a3 == 0.0;
  BOOL v7 = a4 == 0.0;
  if (v6 && v7) {
    double v8 = 1.0;
  }
  else {
    double v8 = a3;
  }
  if (v6 && v7) {
    double v9 = 1.0;
  }
  else {
    double v9 = a4;
  }
  double v10 = *(double *)result;
  double v11 = *(double *)(result + 8);
  double v13 = *(double *)(result + 16);
  double v12 = *(double *)(result + 24);
  if (*(double *)result * v12 - v11 * v13 >= 0.0)
  {
    double v16 = -v11;
    double v17 = -v13;
    double v14 = *(double *)(result + 24);
    double v15 = *(double *)result;
  }
  else
  {
    double v14 = -v12;
    double v15 = -v10;
    double v16 = *(double *)(result + 8);
    double v17 = *(double *)(result + 16);
  }
  double v18 = v9 * v17 + v8 * v14;
  double v19 = v9 * v15 + v8 * v16;
  if (v18 != 0.0 || v19 != 0.0)
  {
    double v20 = sqrt(v19 * v19 + v18 * v18);
    double v18 = v18 / v20;
    double v19 = v19 / v20;
  }
  double v21 = v13 * v18 - v19 * v10;
  double v22 = v12 * v18 - v19 * v11;
  double v23 = v13 * v19 + v18 * v10;
  double v24 = v12 * v19 + v18 * v11;
  if (v4 == 2)
  {
    double v44 = *a2;
    double v45 = a2[1];
    double v46 = v21 + *a2;
    double v27 = (void *)(result + 72);
    float64x2_t v47 = *(void **)(result + 72);
    double v56 = v46 - v23;
    double v57 = v22 + v45 - v24;
    if (v47)
    {
      float64x2_t result = ((uint64_t (*)(void, void, double *, void))v47[3])(v47[1], 0, &v56, v47[6]);
      double v44 = *a2;
      double v45 = a2[1];
      float64x2_t v47 = (void *)*v27;
      double v56 = v23 + v21 + *a2;
      double v57 = v24 + v22 + v45;
      if (v47)
      {
        float64x2_t result = ((uint64_t (*)(void, uint64_t, double *, void))v47[3])(v47[1], 1, &v56, v47[6]);
        double v44 = *a2;
        double v45 = a2[1];
        float64x2_t v47 = (void *)*v27;
      }
    }
    else
    {
      double v56 = v23 + v46;
      double v57 = v24 + v22 + v45;
    }
    double v48 = v44 - v21;
    double v49 = v45 - v22;
    double v56 = v23 + v48;
    double v57 = v24 + v49;
    if (v47)
    {
      float64x2_t result = ((uint64_t (*)(void, uint64_t, double *, void))v47[3])(v47[1], 1, &v56, v47[6]);
      float64x2_t v50 = (void *)*v27;
      double v51 = a2[1] - v22 - v24;
      double v56 = *a2 - v21 - v23;
      double v57 = v51;
      if (v50) {
        float64x2_t result = ((uint64_t (*)(void, uint64_t, double *, void))v50[3])(v50[1], 1, &v56, v50[6]);
      }
    }
    else
    {
      double v56 = v48 - v23;
      double v57 = v49 - v24;
    }
    goto LABEL_30;
  }
  if (v4 != 1) {
    abort();
  }
  double v25 = v22 + a2[1];
  double v27 = (void *)(result + 72);
  uint64_t v26 = *(void *)(result + 72);
  double v56 = v21 + *a2;
  double v57 = v25;
  if (v26)
  {
    float64x2_t result = (*(uint64_t (**)(void, void, double *, void))(v26 + 24))(*(void *)(v26 + 8), 0, &v56, *(void *)(v26 + 48));
    double v28 = (void *)*v27;
    if (*v27)
    {
      double v29 = v23 * 0.55228475;
      double v30 = v24 * 0.55228475;
      double v31 = v21 * 0.55228475;
      double v32 = v22 * 0.55228475;
      double v33 = a2[1];
      double v34 = v23 + *a2;
      double v56 = v23 * 0.55228475 + v21 + *a2;
      double v57 = v24 * 0.55228475 + v22 + v33;
      double v58 = v21 * 0.55228475 + v34;
      double v59 = v22 * 0.55228475 + v24 + v33;
      double v60 = v34;
      double v61 = v24 + v33;
      float64x2_t result = ((uint64_t (*)(void, uint64_t, double *, void))v28[3])(v28[1], 3, &v56, v28[6]);
      float64x2_t v35 = (void *)*v27;
      if (*v27)
      {
        double v36 = a2[1];
        double v37 = *a2 - v21;
        double v56 = v23 + *a2 - v31;
        double v57 = v24 + v36 - v32;
        double v58 = v29 + v37;
        double v59 = v30 + v36 - v22;
        double v60 = v37;
        double v61 = v36 - v22;
        float64x2_t result = ((uint64_t (*)(void, uint64_t, double *, void))v35[3])(v35[1], 3, &v56, v35[6]);
        double v38 = (void *)*v27;
        if (*v27)
        {
          double v39 = a2[1];
          double v40 = *a2 - v23;
          double v56 = *a2 - v21 - v29;
          double v57 = v39 - v22 - v30;
          double v58 = v40 - v31;
          double v59 = v39 - v24 - v32;
          double v60 = v40;
          double v61 = v39 - v24;
          float64x2_t result = ((uint64_t (*)(void, uint64_t, double *, void))v38[3])(v38[1], 3, &v56, v38[6]);
          float64x2_t v41 = (void *)*v27;
          if (*v27)
          {
            double v42 = a2[1];
            double v43 = v21 + *a2;
            double v56 = v31 + *a2 - v23;
            double v57 = v32 + v42 - v24;
            double v58 = v43 - v29;
            double v59 = v22 + v42 - v30;
            double v60 = v43;
            double v61 = v22 + v42;
            float64x2_t result = ((uint64_t (*)(void, uint64_t, double *, void))v41[3])(v41[1], 3, &v56, v41[6]);
LABEL_30:
            float64x2_t v52 = (void *)*v27;
            if (*v27)
            {
              float64x2_t v53 = (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v52[3];
              uint64_t v54 = v52[1];
              uint64_t v55 = v52[6];
              return v53(v54, 4, 0, v55);
            }
          }
        }
      }
    }
  }
  return result;
}

void fstream_zfree(int a1, void *a2)
{
}

uint64_t CGGlyphLockLockGlyphBitmaps(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CGGlyphBuilderLockBitmaps(*a1, a2, a3, a4, a5, a6, a7, a8);
}

double CGGStateGetFontSize(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 136) + 16);
}

double CGGStateGetFontDilation(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 136) + 72);
}

uint64_t CGGStateGetFont(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 136) + 8);
}

void CGContextSetMiterLimit(CGContextRef c, CGFloat limit)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    if (limit >= 1.0) {
      double v8 = limit;
    }
    else {
      double v8 = 1.0;
    }
    uint64_t v9 = *((void *)c + 12);
    if (*(double *)(*(void *)(v9 + 128) + 16) != v8)
    {
      maybe_copy_stroke_state(*((void *)c + 12));
      *(double *)(*(void *)(v9 + 128) + 16) = v8;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetMiterLimit", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  check_clients_buffer("CGDataProviderCreateWithData", data, size);

  return CGDataProviderCreateWithDataInternal((uint64_t)info, (uint64_t)data, size, (uint64_t)releaseData, 0);
}

void check_clients_buffer(const char *a1, const void *a2, size_t a3)
{
  uint64_t v6 = a1;
  uint64_t v5 = a2;
  size_t v4 = a3;
  if (a2)
  {
    uint64_t v3 = 0;
    if ((log_buffer_check_in_crash_reporter() & 1) == 1)
    {
      asprintf(&v3, "%s: %p %zu\n", v6, v5, v4);
      qword_1EB288DD0 = (uint64_t)v3;
    }
    ERROR_CGDataProvider_BufferIsNotReadable();
    ERROR_CGDataProvider_BufferIsNotBigEnough();
    if ((log_buffer_check_in_crash_reporter() & 1) == 1)
    {
      qword_1EB288DD0 = 0;
      free(v3);
    }
  }
}

uint64_t log_buffer_check_in_crash_reporter()
{
  if (log_buffer_check_in_crash_reporter_predicate != -1) {
    dispatch_once(&log_buffer_check_in_crash_reporter_predicate, &__block_literal_global_7311);
  }
  return log_buffer_check_in_crash_reporter_status;
}

float CGColorFunctionGetOutputRange(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (CGColorTRCGetTypeID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorTRCGetTypeID_cglibrarypredicate, &__block_literal_global_785);
  }
  if (v2 == CGColorTRCGetTypeID_f())
  {
    if (trc_get_output_range_cglibrarypredicate != -1) {
      dispatch_once(&trc_get_output_range_cglibrarypredicate, &__block_literal_global_89);
    }
    float output_range_f = trc_get_output_range_f(a1);
    if (trc_get_output_range_cglibrarypredicate_92 != -1) {
      dispatch_once(&trc_get_output_range_cglibrarypredicate_92, &__block_literal_global_95);
    }
    size_t v4 = &trc_get_output_range_f_91;
LABEL_25:
    ((void (*)(const void *))*v4)(a1);
    return output_range_f;
  }
  if (CGColorMatrixGetTypeID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorMatrixGetTypeID_cglibrarypredicate, &__block_literal_global_16);
  }
  if (v2 == CGColorMatrixGetTypeID_f())
  {
    if (matrix_get_output_range_cglibrarypredicate != -1) {
      dispatch_once(&matrix_get_output_range_cglibrarypredicate, &__block_literal_global_98);
    }
    float output_range_f = matrix_get_output_range_f(a1);
    if (matrix_get_output_range_cglibrarypredicate_101 != -1) {
      dispatch_once(&matrix_get_output_range_cglibrarypredicate_101, &__block_literal_global_104);
    }
    size_t v4 = &matrix_get_output_range_f_100;
    goto LABEL_25;
  }
  if (CGColorNxMTransformGetTypeID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorNxMTransformGetTypeID_cglibrarypredicate, &__block_literal_global_24);
  }
  float output_range_f = 0.0;
  if (v2 == CGColorNxMTransformGetTypeID_f())
  {
    if (nxm_get_output_range_cglibrarypredicate != -1) {
      dispatch_once(&nxm_get_output_range_cglibrarypredicate, &__block_literal_global_107);
    }
    float output_range_f = nxm_get_output_range_f(a1);
    if (nxm_get_output_range_cglibrarypredicate_110 != -1) {
      dispatch_once(&nxm_get_output_range_cglibrarypredicate_110, &__block_literal_global_113);
    }
    size_t v4 = &nxm_get_output_range_f_109;
    goto LABEL_25;
  }
  return output_range_f;
}

float CGColorFunctionGetInputRange(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (CGColorTRCGetTypeID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorTRCGetTypeID_cglibrarypredicate, &__block_literal_global_785);
  }
  if (v2 == CGColorTRCGetTypeID_f())
  {
    if (trc_get_input_range_cglibrarypredicate != -1) {
      dispatch_once(&trc_get_input_range_cglibrarypredicate, &__block_literal_global_62);
    }
    float input_range_f = trc_get_input_range_f(a1);
    if (trc_get_input_range_cglibrarypredicate_65 != -1) {
      dispatch_once(&trc_get_input_range_cglibrarypredicate_65, &__block_literal_global_68);
    }
    size_t v4 = &trc_get_input_range_f_64;
LABEL_25:
    ((void (*)(const void *))*v4)(a1);
    return input_range_f;
  }
  if (CGColorMatrixGetTypeID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorMatrixGetTypeID_cglibrarypredicate, &__block_literal_global_16);
  }
  if (v2 == CGColorMatrixGetTypeID_f())
  {
    if (matrix_get_input_range_cglibrarypredicate != -1) {
      dispatch_once(&matrix_get_input_range_cglibrarypredicate, &__block_literal_global_71_802);
    }
    float input_range_f = matrix_get_input_range_f(a1);
    if (matrix_get_input_range_cglibrarypredicate_74 != -1) {
      dispatch_once(&matrix_get_input_range_cglibrarypredicate_74, &__block_literal_global_77);
    }
    size_t v4 = &matrix_get_input_range_f_73;
    goto LABEL_25;
  }
  if (CGColorNxMTransformGetTypeID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorNxMTransformGetTypeID_cglibrarypredicate, &__block_literal_global_24);
  }
  float input_range_f = 0.0;
  if (v2 == CGColorNxMTransformGetTypeID_f())
  {
    if (nxm_get_input_range_cglibrarypredicate != -1) {
      dispatch_once(&nxm_get_input_range_cglibrarypredicate, &__block_literal_global_80);
    }
    float input_range_f = nxm_get_input_range_f(a1);
    if (nxm_get_input_range_cglibrarypredicate_83 != -1) {
      dispatch_once(&nxm_get_input_range_cglibrarypredicate_83, &__block_literal_global_86);
    }
    size_t v4 = &nxm_get_input_range_f_82;
    goto LABEL_25;
  }
  return input_range_f;
}

uint64_t colorspace_from_ICC_data_data_key_hash(long long *a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  long long v2 = *a1;
  return MEMORY[0x18532A6B0](&v2, 16);
}

void CGContextSetTextDrawingMode(CGContextRef c, CGTextDrawingMode mode)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetTextDrawingMode(*((void *)c + 12), mode);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetTextDrawingMode", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

uint64_t __CGColorConversionInfoIterateFunctionsWithCallbacks_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    return 1;
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v6 = *(uint64_t (**)(uint64_t, _OWORD *, uint64_t, uint64_t))(v4 + 16);
  long long v7 = *(_OWORD *)(v5 + 56);
  v9[1] = *(_OWORD *)(v5 + 40);
  v9[2] = v7;
  v10[0] = *(_OWORD *)(v5 + 72);
  *(_OWORD *)((char *)v10 + 12) = *(_OWORD *)(v5 + 84);
  v9[0] = *(_OWORD *)(v5 + 24);
  return v6(v4, v9, a2, a3);
}

CFTypeRef icc_create_icc_profile_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v8 + 24) != 6) {
    _CGHandleAssert("icc_create_icc_profile_description", 165, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased", "Colorspace must be ICC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
  }
  uint64_t v9 = *(void *)(v8 + 96);
  CFTypeRef result = *(CFTypeRef *)(v9 + 40);
  if (result) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(v9 + 16);
  if (copy_icc_profile_description_cglibrarypredicate != -1) {
    dispatch_once(&copy_icc_profile_description_cglibrarypredicate, &__block_literal_global_66);
  }
  double v12 = (__CFString *)copy_icc_profile_description_f(v11);
  uint64_t v13 = 0;
  if (!v12) {
    double v12 = @"<no description>";
  }
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v9 + 40), (unint64_t *)&v13, (unint64_t)v12, memory_order_relaxed, memory_order_relaxed);
  if (v13) {
    CFRelease(v12);
  }
  CFTypeRef result = *(CFTypeRef *)(v9 + 40);
  if (result)
  {
LABEL_10:
    return CFRetain(result);
  }
  return result;
}

int CGFontGetXHeight(CGFontRef font)
{
  font_info = get_font_info(font);
  if (font_info) {
    LODWORD(font_info) = font_info[7];
  }
  return (int)font_info;
}

void CGFontGetGlyphsForUnichars(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  if (a1)
  {
    (*(void (**)(void, uint64_t, void *))(*(void *)(a1 + 16) + 376))(*(void *)(a1 + 112), a2, a3);
  }
  else if (a4)
  {
    bzero(a3, 2 * a4);
  }
}

uint64_t CGGStateGetShouldDrawBitmapRuns(uint64_t a1)
{
  return (**(unsigned __int16 **)(a1 + 136) >> 7) & 1;
}

CFStringRef CGColorSpaceCopyName(CGColorSpaceRef space)
{
  if (space && (uint64_t v1 = *(const void **)(*((void *)space + 3) + 80)) != 0) {
    return (CFStringRef)CFRetain(v1);
  }
  else {
    return 0;
  }
}

CFTypeID CGDataProviderGetTypeID(void)
{
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  return CGDataProviderGetTypeID_id;
}

void *CGvImage_converter_data_key_retain(void *a1, void *a2)
{
  CFTypeRef result = malloc_type_malloc(0x288uLL, 0x10E0040AB895360uLL);
  if (result)
  {
    uint64_t v5 = result;
    memcpy(result, a1, 0x288uLL);
    *a2 = v5;
    uint64_t v6 = (const void *)a1[5];
    if (v6) {
      CFRetain(v6);
    }
    CFTypeRef result = (void *)a1[10];
    if (result)
    {
      return (void *)CFRetain(result);
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

CGContextRef CGLayerGetContext(CGContextRef layer)
{
  if (layer) {
    return (CGContextRef)*((void *)layer + 2);
  }
  return layer;
}

uint64_t __CGColorConversionInfoIterateFunctionsWithCallbacks_block_invoke_2(uint64_t a1, _OWORD *a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v6 = *(_OWORD *)((char *)a2 + 60);
  *(_OWORD *)(v3 + 40) = a2[1];
  *(_OWORD *)(v3 + 84) = v6;
  *(_OWORD *)(v3 + 72) = v4;
  *(_OWORD *)(v3 + 56) = v5;
  *(_OWORD *)(v3 + 24) = *a2;
  uint64_t v7 = *(void *)(a1 + 32);
  if (!v7) {
    return 1;
  }
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v9 = *(uint64_t (**)(uint64_t, _OWORD *))(v7 + 16);
  long long v10 = *(_OWORD *)(v8 + 56);
  v12[1] = *(_OWORD *)(v8 + 40);
  v12[2] = v10;
  v13[0] = *(_OWORD *)(v8 + 72);
  *(_OWORD *)((char *)v13 + 12) = *(_OWORD *)(v8 + 84);
  v12[0] = *(_OWORD *)(v8 + 24);
  return v9(v7, v12);
}

double CGColorMatrixGetMatrix@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  if (CGColorMatrixGetMatrix_cglibrarypredicate != -1) {
    dispatch_once(&CGColorMatrixGetMatrix_cglibrarypredicate, &__block_literal_global_20);
  }
  long long v7 = 0u;
  long long v8 = 0u;
  long long v6 = 0u;
  CGColorMatrixGetMatrix_f(&v6, a1);
  long long v4 = v7;
  *a2 = v6;
  a2[1] = v4;
  double result = *(double *)&v8;
  a2[2] = v8;
  return result;
}

void CGPathApplyWithBlock2(double *cf, uint64_t a2)
{
  if (cf)
  {
    if (CGPathDisableTypeValidation || (CFTypeID v4 = CFGetTypeID(cf), v4 == CGPathGetTypeID()))
    {
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 0x40000000;
      v5[2] = __CGPathApplyWithBlock2_block_invoke;
      v5[3] = &unk_1E52CD2F8;
      v5[4] = a2;
      CG::Path::apply(cf + 2, (uint64_t)v5);
    }
  }
}

_DWORD *ARGB32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  unsigned int v8 = PIXELCONSTANT_21389(*(float **)(*(void *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 3 || (a2 = malloc_type_malloc(0x34uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDDC0;
    a2[6] = 0;
    a2[12] = v8 & 0xFF00FF | (BYTE1(v8) << 24) | (HIBYTE(v8) << 8);
    *((void *)a2 + 2) = 1;
    if ((_BYTE)v8 == 0xFF) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = (char *)(a2 + 12);
    }
    *((void *)a2 + 4) = a2 + 12;
    *((void *)a2 + 5) = v9;
  }
  return a2;
}

_DWORD *rgba32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  int v8 = PIXELCONSTANT_21389(*(float **)(*(void *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 3 || (a2 = malloc_type_malloc(0x34uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDDC0;
    a2[6] = 0;
    a2[12] = v8;
    *((void *)a2 + 2) = 1;
    if ((_BYTE)v8 == 0xFF) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = (char *)(a2 + 12);
    }
    *((void *)a2 + 4) = a2 + 12;
    *((void *)a2 + 5) = v9;
  }
  return a2;
}

void CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)
{
  double v8 = fabs(rect.origin.x);
  double v9 = fabs(rect.origin.y);
  if (rect.origin.x == INFINITY || rect.origin.y == INFINITY || v8 == INFINITY || v9 == INFINITY)
  {
    *slice = CGRectNull;
    *remainder = CGRectNull;
  }
  else
  {
    if (rect.size.width < 0.0 || rect.size.height < 0.0) {
      rect = CGRectStandardize(rect);
    }
    *remainder = rect;
    CGSize size = remainder->size;
    slice->origin = remainder->origin;
    slice->CGSize size = size;
    double width = 0.0;
    if (amount >= 0.0) {
      double width = amount;
    }
    if ((edge | 2) == 2)
    {
      if (width > rect.size.width) {
        double width = rect.size.width;
      }
      slice->size.double width = width;
      double v16 = remainder->size.width - width;
      remainder->size.double width = v16;
      if (edge) {
        slice->origin.CGFloat x = v16 + slice->origin.x;
      }
      else {
        remainder->origin.CGFloat x = width + remainder->origin.x;
      }
    }
    else
    {
      if (width > rect.size.height) {
        double width = rect.size.height;
      }
      slice->size.CGFloat height = width;
      double v17 = remainder->size.height - width;
      remainder->size.CGFloat height = v17;
      if (edge == CGRectMinYEdge) {
        remainder->origin.CGFloat y = width + remainder->origin.y;
      }
      else {
        slice->origin.CGFloat y = v17 + slice->origin.y;
      }
    }
  }
}

BOOL colorspace_from_ICC_data_data_key_is_equal(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

void *CGFontDBSetInitializer(void *result)
{
  fontDBInitializer = result;
  return result;
}

uint64_t CGImageProviderCreateWithImageProviderInRect(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  if (!a1) {
    return 0;
  }
  CGFloat v9 = *(double *)(a1 + 16);
  CGFloat v8 = *(double *)(a1 + 24);
  CGRect v40 = CGRectIntegral(*(CGRect *)&a3);
  v38.origin.CGFloat x = 0.0;
  v38.origin.CGFloat y = 0.0;
  v38.size.CGFloat width = v9;
  v38.size.CGFloat height = v8;
  CGRect v39 = CGRectIntersection(v38, v40);
  CGFloat x = v39.origin.x;
  if (v39.origin.x == INFINITY || v39.origin.y == INFINITY) {
    return 0;
  }
  CGFloat y = v39.origin.y;
  CGFloat width = v39.size.width;
  CGFloat height = v39.size.height;
  v41.origin.CGFloat x = 0.0;
  v41.origin.CGFloat y = 0.0;
  v41.size.CGFloat width = v9;
  v41.size.CGFloat height = v8;
  if (CGRectEqualToRect(v39, v41))
  {
    CFRetain((CFTypeRef)a1);
    return a1;
  }
  else
  {
    if (kCGImageProviderContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGImageProviderContentHeadroom_block_invoke_once, &__block_literal_global_89_3449);
    }
    uint64_t Instance = CGTypeCreateInstance(CGImageProviderGetTypeID_image_provider_type_id, 168, v18, v19, v20, v21, v22, v23);
    if (Instance)
    {
      double v24 = *(const void **)(a1 + 40);
      if (a2 && !CGColorSpaceEqualToColorSpace(a2, *(void *)(a1 + 40)))
      {
        CGLog(1, (uint64_t)"%s: Given colorspace does not match source colorspace.", v25, v26, v27, v28, v29, v30, (char)"CGImageProviderRef CGImageProviderCreateWithImageProviderInRect(CGImageProviderRef, CGRect, CGColorSpaceRef)");
        double v24 = (const void *)a2;
      }
      *(CGFloat *)(Instance + 16) = width;
      *(CGFloat *)(Instance + 24) = height;
      *(void *)(Instance + 48) = *(void *)(a1 + 48);
      *(void *)(Instance + 56) = Instance;
      *(void *)(Instance + 32) = *(void *)(a1 + 32);
      if (v24) {
        CFRetain(v24);
      }
      *(void *)(Instance + 40) = v24;
      *(_OWORD *)(Instance + 64) = subImageProviderCallbacks;
      *(void *)(Instance + 80) = off_1ED0990D0;
      *(void *)(Instance + 112) = 0;
      *(_WORD *)(Instance + 128) = 256;
      CFRetain((CFTypeRef)a1);
      *(void *)(Instance + 144) = a1;
      *(CGFloat *)(Instance + 152) = x;
      *(CGFloat *)(Instance + 160) = y;
      *(CGFloat *)(Instance + 168) = width;
      *(CGFloat *)(Instance + 176) = height;
      *(_DWORD *)(Instance + 132) = *(_DWORD *)(a1 + 132);
      *(void *)(Instance + 136) = create_debug_string(Instance, v31, v32, v33, v34, v35, v36, v37);
    }
  }
  return Instance;
}

uint64_t CGImageProviderCreate(int a1, void *a2, uint64_t a3, uint64_t a4, CFDictionaryRef theDict, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  uint64_t v10 = 0;
  if (a2 && a4)
  {
    if (a9 >= 1.0 && a9 == (double)(unint64_t)a9 && a10 >= 1.0 && a10 == (double)(unint64_t)a10)
    {
      switch(*(_DWORD *)a4)
      {
        case 0:
        case 1:
        case 2:
        case 3:
          if (!*(void *)(a4 + 8)) {
            return 0;
          }
          uint64_t v22 = *(void *)(a2[3] + 48);
          int valuePtr = 0;
          if (theDict)
          {
            if (CFDictionaryContainsKey(theDict, @"kCGImageProviderBitmapInfo"))
            {
              CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kCGImageProviderBitmapInfo");
              CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
              BOOL v24 = 1;
            }
            else
            {
              uint64_t v25 = CFDictionaryGetValue(theDict, @"kCGImageProviderAlphaIsOne");
              BOOL v24 = v25 != 0;
              if (v25)
              {
                int v26 = 5;
              }
              else if (CFDictionaryGetValue(theDict, @"kCGImageProviderAlphaIsPremultiplied"))
              {
                int v26 = 1;
              }
              else if (CFDictionaryGetValue(theDict, @"kCGImageProviderAlphaIsNotPremultiplied"))
              {
                int v26 = 3;
              }
              else
              {
                int v26 = 0;
              }
              int valuePtr = v26;
            }
            if (CFDictionaryContainsKey(theDict, @"kCGImageProviderBitmapInfo")) {
              goto LABEL_41;
            }
          }
          else
          {
            BOOL v24 = 0;
          }
          switch(a1)
          {
            case 1:
              goto LABEL_41;
            case 2:
              int v27 = valuePtr;
              goto LABEL_38;
            case 3:
              int v28 = valuePtr | 0x2000;
              break;
            case 4:
              int v28 = valuePtr | 0x2100;
              break;
            case 5:
              int v27 = valuePtr | 0x100;
LABEL_38:
              int v28 = v27 | 0x1000;
              break;
            case 6:
              int v28 = 204806;
              break;
            default:
              CGPostError((uint64_t)"%s: invalid image componenttype %d.", (uint64_t)a2, a3, a4, (uint64_t)theDict, a6, a7, a8, (char)"CGImageProviderCreate");
              return 0;
          }
          int valuePtr = v28;
LABEL_41:
          if ((valuePtr & 0x1F) != 0) {
            uint64_t v29 = v22 + 1;
          }
          else {
            uint64_t v29 = v22;
          }
          unsigned int v30 = *(_DWORD *)(a2[3] + 28);
          if (v30 > 7) {
            goto LABEL_52;
          }
          if (((1 << v30) & 0x97) != 0) {
            goto LABEL_46;
          }
          if (((1 << v30) & 0x28) == 0)
          {
LABEL_52:
            CGPostError((uint64_t)"%s: unsupported image provider color space model.", (uint64_t)a2, a3, a4, (uint64_t)theDict, a6, a7, a8, (char)"CGImageProviderCreate");
            return 0;
          }
          if ((valuePtr & 0x1Fu) - 1 <= 1)
          {
            CGPostError((uint64_t)"%s: unsupported image provider color space and alpha combination.", (uint64_t)a2, a3, a4, (uint64_t)theDict, a6, a7, a8, (char)"CGImageProviderCreate");
            return 0;
          }
LABEL_46:
          switch(a1)
          {
            case 1:
              goto LABEL_56;
            case 2:
            case 5:
              v29 *= 2;
              goto LABEL_56;
            case 3:
            case 4:
              v29 *= 4;
              goto LABEL_56;
            case 6:
              if (v30 != 1)
              {
                CGPostError((uint64_t)"%s: invalid image provider component type color space type combination.", (uint64_t)a2, a3, a4, (uint64_t)theDict, a6, a7, a8, (char)"CGImageProviderCreate");
                return 0;
              }
              uint64_t v29 = 4;
LABEL_56:
              if (kCGImageProviderContentHeadroom_block_invoke_once != -1) {
                dispatch_once(&kCGImageProviderContentHeadroom_block_invoke_once, &__block_literal_global_89_3449);
              }
              uint64_t Instance = CGTypeCreateInstance(CGImageProviderGetTypeID_image_provider_type_id, 128, a3, a4, (uint64_t)theDict, a6, a7, a8);
              uint64_t v10 = Instance;
              if (Instance)
              {
                *(double *)(Instance + 16) = a9;
                *(double *)(Instance + 24) = a10;
                int v32 = valuePtr;
                *(_DWORD *)(Instance + 32) = a1;
                *(_DWORD *)(Instance + 36) = v32;
                CFRetain(a2);
                *(void *)(v10 + 40) = a2;
                *(void *)(v10 + 48) = v29;
                *(void *)(v10 + 56) = a3;
                *(_DWORD *)(v10 + 64) = *(_DWORD *)a4;
                switch(*(_DWORD *)a4)
                {
                  case 0:
                  case 1:
                    long long v40 = *(_OWORD *)a4;
                    *(void *)(v10 + 80) = *(void *)(a4 + 16);
                    goto LABEL_64;
                  case 2:
                    long long v40 = *(_OWORD *)a4;
                    long long v41 = *(_OWORD *)(a4 + 16);
                    goto LABEL_63;
                  case 3:
                    long long v40 = *(_OWORD *)a4;
                    long long v41 = *(_OWORD *)(a4 + 16);
                    *(_OWORD *)(v10 + 96) = *(_OWORD *)(a4 + 32);
LABEL_63:
                    *(_OWORD *)(v10 + 80) = v41;
LABEL_64:
                    *(_OWORD *)(v10 + 64) = v40;
                    if (theDict)
                    {
                      *(void *)(v10 + 112) = CFRetain(theDict);
                      BOOL v42 = CFDictionaryGetValue(theDict, @"kCGImageProviderSupportsMultipleResolutions") != 0;
                    }
                    else
                    {
                      BOOL v42 = 0;
                      *(void *)(v10 + 112) = 0;
                    }
                    *(unsigned char *)(v10 + 128) = v42;
                    *(unsigned char *)(v10 + 129) = 0;
                    *(unsigned char *)(v10 + 130) = v24;
                    *(void *)(v10 + 136) = create_debug_string(v10, v33, v34, v35, v36, v37, v38, v39);
                    double v47 = 0.0;
                    int Float = CGCFDictionaryGetFloat(theDict, @"kCGImageProviderContentHeadroom", &v47);
                    float v44 = v47;
                    if (!Float) {
                      float v44 = 0.0;
                    }
                    *(float *)(v10 + 132) = v44;
                    break;
                  default:
                    _CGHandleAssert("CGImageProviderCreate", 380, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageProvider.c", "", "Unimplemented", v37, v38, v39, v45);
                }
              }
              return result;
            default:
              CGPostError((uint64_t)"%s: invalid image provider component type.", (uint64_t)a2, a3, a4, (uint64_t)theDict, a6, a7, a8, (char)"CGImageProviderCreate");
              return 0;
          }
        default:
          CGPostError((uint64_t)"%s: invalid image provider callbacks version: %d.", (uint64_t)a2, a3, a4, (uint64_t)theDict, a6, a7, a8, (char)"CGImageProviderCreate");
          return 0;
      }
    }
    else
    {
      CGPostError((uint64_t)"%s: invalid image provider size: %g x %g.", (uint64_t)a2, a3, a4, (uint64_t)theDict, a6, a7, a8, (char)"CGImageProviderCreate");
      return 0;
    }
  }
  return v10;
}

CFStringRef create_debug_string(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  if (data_provider_debug_info_enabled_predicate != -1) {
    dispatch_once(&data_provider_debug_info_enabled_predicate, &__block_literal_global_42);
  }
  CFStringRef v9 = 0;
  if (a1 && data_provider_debug_info_enabled_enabled)
  {
    int v26 = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 64);
    if (v10 >= 2)
    {
      if (v10 == 2)
      {
        uint64_t v11 = 3;
      }
      else
      {
        if (v10 != 3) {
          _CGHandleAssert("create_debug_string", 108, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageProvider.c", "count != 0 && count <= kMaxCount", "count: %lu", a6, a7, a8, 0);
        }
        uint64_t v11 = 5;
      }
    }
    else
    {
      uint64_t v11 = 2;
    }
    uint64_t v12 = *(void *)(a1 + 80);
    v34[0] = *(void *)(a1 + 72);
    v34[1] = v12;
    v33[0] = v34[0];
    v33[1] = v12;
    v32[0] = v34[0];
    v32[1] = v12;
    v29[0] = v34[0];
    v29[1] = v12;
    long long v13 = *(_OWORD *)(a1 + 88);
    v32[2] = *(void *)(a1 + 88);
    long long v30 = v13;
    uint64_t v31 = *(void *)(a1 + 104);
    bzero(v28, 0x285uLL);
    double v14 = create_debug_string_names_v2;
    double v15 = (const void **)v32;
    double v16 = (const void **)v33;
    if (!v10) {
      double v16 = (const void **)v34;
    }
    double v17 = (const void **)v29;
    if (v10 != 3) {
      double v17 = 0;
    }
    uint64_t v18 = create_debug_string_names_v3;
    if (v10 != 3) {
      uint64_t v18 = 0;
    }
    if (v10 != 2)
    {
      double v15 = v17;
      double v14 = v18;
    }
    if (v10 >= 2) {
      uint64_t v19 = v15;
    }
    else {
      uint64_t v19 = v16;
    }
    if (v10 >= 2) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = create_debug_string_names_v1;
    }
    do
    {
      uint64_t v21 = *v19;
      if (*v19)
      {
        memset(&v25, 0, sizeof(v25));
        if (dladdr(v21, &v25)) {
          snprintf(__str, 0x80uLL, "%s %s:%s");
        }
        else {
          snprintf(__str, 0x80uLL, "%s %p");
        }
        __strcat_chk();
        __strcat_chk();
      }
      ++v20;
      ++v19;
      --v11;
    }
    while (v11);
    if (*(unsigned char *)(a1 + 129)) {
      asprintf(&v26, "CGImageProvider: version: %d size: [%f, %f] headroom: %f subImage rect [[%f, %f][%f, %f]]\n%s");
    }
    else {
      asprintf(&v26, "CGImageProvider: version: %d size: [%f, %f] headroom: %f\n%s");
    }
    if (*(unsigned char *)(a1 + 129)) {
      debug_string = (__CFString *)create_debug_string(*(void *)(a1 + 144));
    }
    else {
      debug_string = 0;
    }
    if (debug_string) {
      uint64_t v23 = debug_string;
    }
    else {
      uint64_t v23 = &stru_1ED0A02B0;
    }
    CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"%s%@%@", v26, v23, &stru_1ED0A02B0);
    if (debug_string) {
      CFRelease(debug_string);
    }
    free(v26);
  }
  return v9;
}

uint64_t CGContextGetBlendMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 120) + 4);
    if ((unsigned __int16)((unsigned __int16)v8 >> 10) <= 6u) {
      return CGContextGetBlendMode_mode[(__int16)v8 >> 8];
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextGetBlendMode", a1, a3, a4, a5, a6, a7, a8);
  }
  return 0;
}

void CGContextSetShouldAntialias(CGContextRef c, BOOL shouldAntialias)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetShouldAntialias(*((void *)c + 12), shouldAntialias);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldAntialias", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

void layerFinalize(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

void *fstream_zalloc(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return malloc_type_malloc(a3 * (unint64_t)a2, 0x86B5D5E7uLL);
}

CFDataRef CGPDFStreamCopyData(CGPDFStreamRef stream, CGPDFDataFormat *format)
{
  uint64_t v2 = ((uint64_t (*)(CGPDFStreamRef))MEMORY[0x1F4188790])(stream);
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  FilterChain = CGPDFStreamCreateFilterChain(v2, v3);
  if (!FilterChain) {
    return 0;
  }
  uint64_t v5 = FilterChain;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (Mutable)
  {
    do
    {
      unint64_t v12 = CGPDFSourceRead((uint64_t)v5, (uint64_t)bytes, 0x1000uLL, v6, v7, v8, v9, v10);
      CFDataAppendBytes(Mutable, bytes, v12);
    }
    while (v12 > 0xFFF);
    CFRelease(v5);
  }
  return Mutable;
}

void sub_184C829FC(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    pdf_error("Exception in CGPDFStreamCopyData");
    CFRelease(v2);
    objc_end_catch();
    JUMPOUT(0x184C829B4);
  }
  _Unwind_Resume(exception_object);
}

void sub_184C82A44(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x184C82A2CLL);
}

CGPDFDocumentRef CGPDFDocumentCreateWithProvider(CGDataProviderRef provider)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (sInLockdownModeForPDF) {
    goto LABEL_5;
  }
  if (read_entitlements_once != -1) {
    dispatch_once(&read_entitlements_once, &__block_literal_global_11367);
  }
  if (sHasLockdownModeForPDFEntitlement)
  {
LABEL_5:
    pdf_error("Attempt to create CGPDFDocument in Lockdown Mode for PDF");
    return 0;
  }
  if (CGPDFDocumentCreateWithProvider::onceToken != -1)
  {
    dispatch_once(&CGPDFDocumentCreateWithProvider::onceToken, &__block_literal_global_1324);
    if (provider) {
      goto LABEL_10;
    }
LABEL_12:
    uint64_t v5 = (void *)MEMORY[0x18532AD60]();
    send_analytics_event((uint64_t)"com.apple.CoreGraphics.CGPDFDocumentCreateWithProvider");
    goto LABEL_13;
  }
  if (!provider) {
    goto LABEL_12;
  }
LABEL_10:
  uint64_t v4 = *((void *)provider + 34);
  if (!v4 || !CGPropertiesGetProperty(v4, @"from_url")) {
    goto LABEL_12;
  }
LABEL_13:
  if (CGPDFDocumentGetTypeID::onceToken != -1) {
    dispatch_once(&CGPDFDocumentGetTypeID::onceToken, &__block_literal_global_25);
  }
  uint64_t cftype = pdf_create_cftype();
  if (!provider || (uint64_t v6 = *((void *)provider + 4), v6 == -1))
  {
    uint64_t v7 = CGAccessSessionCreate(provider);
    if (v7)
    {
      long long v13 = v7;
      uint64_t v14 = 0;
      do
      {
        uint64_t v6 = v14;
        uint64_t Bytes = CGAccessSessionGetBytes(v13, v39, 0x800uLL, v8, v9, v10, v11, v12);
        uint64_t v14 = Bytes + v6;
      }
      while (Bytes);
      if (CGAccessSessionSkipForward((uint64_t)v13, 1) >= 1) {
        CGLog(2, (uint64_t)"Sequential data provider %p skips forward beyond available data", v16, v17, v18, v19, v20, v21, (char)provider);
      }
      CGAccessSessionRelease(v13);
    }
    else
    {
      uint64_t v6 = 0;
    }
  }
  uint64_t v22 = CGPDFSourceCreate(provider, 0, v6);
  if (!v22) {
    goto LABEL_40;
  }
  uint64_t v23 = v22;
  BOOL v24 = (uint64_t *)malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  int v32 = pdf_xref_create((uint64_t)v23, v25, v26, v27, v28, v29, v30, v31);
  *BOOL v24 = (uint64_t)v32;
  *((_DWORD *)v24 + 4) = 0;
  if (!v32)
  {
    pdf_reader_release(v24);
    CFRelease(v23);
LABEL_40:
    *(void *)(cftype + 16) = 0;
LABEL_41:
    CFRelease((CFTypeRef)cftype);
    return 0;
  }
  CFRelease(v23);
  if (pdf_document_get_type_id_onceToken != -1) {
    dispatch_once(&pdf_document_get_type_id_onceToken, &__block_literal_global_18407);
  }
  uint64_t v33 = pdf_create_cftype();
  if (!v33) {
    goto LABEL_40;
  }
  uint64_t v34 = v33;
  *(void *)(v33 + 16) = v24;
  *(void *)(v33 + 80) = 0;
  *(void *)(v33 + 64) = 0;
  *(unsigned char *)(v33 + 72) = 0;
  *(unsigned char *)(v33 + 88) = 1;
  uint64_t v35 = *(void *)(*v24 + 40);
  if (v35) {
    pdf_document_unlock_with_password(v35, "");
  }
  *(void *)(cftype + 16) = v34;
  *(void *)(cftype + 40) = 0;
  *(void *)(cftype + 48) = 0;
  pthread_mutex_init((pthread_mutex_t *)(cftype + 56), 0);
  *(unsigned char *)(cftype + 120) = 1;
  pthread_mutex_init((pthread_mutex_t *)(cftype + 128), 0);
  *(void *)(cftype + 192) = 0;
  *(_DWORD *)(cftype + 208) = 0;
  if (CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken != -1) {
    dispatch_once(&CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken, &__block_literal_global_18_13644);
  }
  if (CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result) {
    operator new();
  }
  *(_DWORD *)(cftype + 212) = 0;
  uint64_t v36 = *(void *)(**(void **)(*(void *)(cftype + 16) + 16) + 160);
  uint64_t v37 = (char *)malloc_type_malloc(0x38uLL, 0x10600403E806431uLL);
  *(void *)uint64_t v37 = cftype;
  *((void *)v37 + 1) = v36;
  *((void *)v37 + 2) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(_OWORD *)(v37 + 24) = 0u;
  *(_OWORD *)(v37 + 40) = 0u;
  *(void *)(cftype + 216) = v37;
  *(_DWORD *)(cftype + 224) = 0;
  *(void *)(cftype + 232) = 0;
  uint64_t v38 = **(void **)(*(void *)(cftype + 16) + 16);
  if (!*(void *)(v38 + 24) && !*(void *)(v38 + 40) && !CGPDFDocumentGetPage((CGPDFDocumentRef)cftype, 1uLL)) {
    goto LABEL_41;
  }
  return (CGPDFDocumentRef)cftype;
}

CGPDFPageRef CGPDFDocumentGetPage(CGPDFPageRef document, size_t pageNumber)
{
  if (document)
  {
    CGPDFPageRef v3 = document;
    uint64_t v4 = *(uint64_t **)(*((void *)document + 2) + 16);
    uint64_t v5 = *(void *)(*v4 + 40);
    if ((!v5 || (uint64_t v6 = *(void *)(v5 + 16)) != 0 && *(unsigned char *)(v6 + 184))
      && (size_t v7 = pageNumber - 1, pageNumber - 1 < (unint64_t)pdf_reader_get_number_of_pages(v4))
      && (ensure_page_array_exists((uint64_t)v3), (uint64_t v8 = *((void *)v3 + 3)) != 0))
    {
      document = *(CGPDFPageRef *)(v8 + 8 * v7);
      if (!document)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)v3 + 56));
        if (!*(void *)(v8 + 8 * v7)) {
          *(void *)(v8 + 8 * v7) = CGPDFPageCreate2((CFTypeRef *)v3, pageNumber, 0);
        }
        pthread_mutex_unlock((pthread_mutex_t *)((char *)v3 + 56));
        return *(CGPDFPageRef *)(v8 + 8 * v7);
      }
    }
    else
    {
      return 0;
    }
  }
  return document;
}

uint64_t ensure_page_array_exists(uint64_t result)
{
  if (!*(void *)(result + 24))
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = (pthread_mutex_t *)(result + 56);
    pthread_mutex_lock((pthread_mutex_t *)(result + 56));
    if (!v1[3])
    {
      number_of_pages = pdf_reader_get_number_of_pages(*(uint64_t **)(v1[2] + 16));
      v1[4] = number_of_pages;
      uint64_t v4 = malloc_type_calloc((size_t)number_of_pages, 8uLL, 0x33BCE901uLL);
      __CFSetLastAllocationEventName();
      v1[3] = v4;
    }
    return pthread_mutex_unlock(v2);
  }
  return result;
}

unsigned char *CGPDFStreamCreateFilterChain(uint64_t a1, int *a2)
{
  if (a1)
  {
    CopCGFloat y = CGPDFSourceCreateCopy(*(void *)(a1 + 72), *(void *)(a1 + 56), *(void *)(a1 + 64));
    if (Copy)
    {
      uint64_t v5 = Copy;
      int v6 = *(unsigned __int8 *)(a1 + 40);
      size_t v7 = *(CGPDFDictionary **)(a1 + 48);
      uint64_t v8 = *(void *)(a1 + 16);
      if (!v8
        || *(unsigned char *)(a1 + 41)
        || (uint64_t v15 = *(void *)(v8 + 40)) == 0
        || has_crypt_filter(*(CGPDFDictionary **)(a1 + 48), v6 != 0))
      {
        CFRetain(v5);
        Decryptor = v5;
      }
      else
      {
        Decryptor = CGPDFSecurityManagerCreateDecryptor(v15, a1, 0, v5);
        if (!Decryptor)
        {
          pdf_error("failed to create default crypt filter.");
          uint64_t v14 = 0;
LABEL_43:
          CFRelease(v5);
          return v14;
        }
      }
      CGPDFObjectRef filter_object = get_filter_object(v7, v6 != 0);
      if (filter_object)
      {
        int v11 = *((_DWORD *)filter_object + 2);
        if (v11 == 5)
        {
          uint64_t v16 = (const char *)*((void *)filter_object + 4);
          CGPDFDictionaryRef value = 0;
          uint64_t v17 = *(CGPDFDictionary **)(a1 + 48);
          if (!CGPDFDictionaryGetDictionary(v17, "DecodeParms", &value)
            && !CGPDFDictionaryGetDictionary(v17, "DP", &value))
          {
            CGPDFDictionaryRef value = 0;
          }
          uint64_t v14 = add_filter(a1, Decryptor, v16, value, a2);
        }
        else if (v11 == 7)
        {
          uint64_t v12 = (CGPDFArray *)*((void *)filter_object + 4);
          arraCGFloat y = 0;
          CGPDFDictionaryRef value = 0;
          CGPDFDictionaryRef v24 = 0;
          if (v12) {
            uint64_t v13 = *((void *)v12 + 2);
          }
          else {
            uint64_t v13 = 0;
          }
          uint64_t v18 = *(CGPDFDictionary **)(a1 + 48);
          if (!CGPDFDictionaryGetArray(v18, "DecodeParms", &array) && !CGPDFDictionaryGetArray(v18, "DP", &array)) {
            arraCGFloat y = 0;
          }
          CFRetain(Decryptor);
          if (a2) {
            *a2 = 0;
          }
          if (v13)
          {
            size_t v19 = 0;
            uint64_t v20 = Decryptor;
            while (CGPDFArrayGetName(v12, v19, (const char **)&value))
            {
              if (array && CGPDFArrayGetDictionary(array, v19, &v24))
              {
                uint64_t v21 = v24;
              }
              else
              {
                uint64_t v21 = 0;
                CGPDFDictionaryRef v24 = 0;
              }
              uint64_t v22 = add_filter(a1, v20, (const char *)value, v21, a2);
              if (!v22) {
                break;
              }
              uint64_t v14 = v22;
              CFRelease(v20);
              ++v19;
              uint64_t v20 = v14;
              if (v13 == v19) {
                goto LABEL_42;
              }
            }
            CFRelease(v20);
            uint64_t v14 = 0;
          }
          else
          {
            uint64_t v14 = Decryptor;
          }
        }
        else
        {
          uint64_t v14 = 0;
        }
LABEL_42:
        CFRelease(Decryptor);
      }
      else
      {
        if (a2) {
          *a2 = 0;
        }
        uint64_t v14 = Decryptor;
      }
      goto LABEL_43;
    }
  }
  return 0;
}

void *CGPDFSourceCreate(const void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (a3 >= 0x4000) {
    size_t v6 = 0x4000;
  }
  else {
    size_t v6 = a3;
  }
  Internal = CGPDFSourceCreateInternal(v6);
  uint64_t v8 = Internal;
  if (Internal)
  {
    Internal[5] = a1;
    CFRetain(a1);
    *((unsigned char *)v8 + 209) = 0;
    v8[2] = a3;
    v8[3] = a2;
    v8[4] = 0;
  }
  return v8;
}

void *CGPDFSourceCreateInternal(size_t a1)
{
  if (CGPDFSourceGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFSourceGetTypeID_onceToken, &__block_literal_global_4765);
  }
  uint64_t cftype = pdf_create_cftype();
  CGPDFPageRef v3 = (void *)cftype;
  if (cftype)
  {
    *(void *)(cftype + 96) = a1;
    uint64_t v4 = malloc_type_calloc(1uLL, a1, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    v3[11] = v4;
    if (v4)
    {
      v3[2] = -1;
      v3[13] = 0;
      v3[14] = 0;
      v3[15] = 0;
      v3[16] = v4;
    }
    else
    {
      CFRelease(v3);
      return 0;
    }
  }
  return v3;
}

CGPDFObjectRef get_filter_object(CGPDFDictionary *a1, int a2)
{
  CGPDFObjectRef value = 0;
  if (CGPDFDictionaryGetObject(a1, "Filter", &value)) {
    return value;
  }
  if (!a2) {
    return 0;
  }
  if (CGPDFDictionaryGetObject(a1, "F", &value)) {
    return value;
  }
  return 0;
}

unsigned char *add_filter(uint64_t a1, void *a2, const char *a3, CGPDFDictionary *a4, int *a5)
{
  if (a3)
  {
    switch(filter_kind_from_name(a3))
    {
      case 1u:
        if (a5) {
          *a5 = 0;
        }
        uint64_t v9 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x10200405F07FB98uLL);
        if (!v9) {
          return 0;
        }
        uint64_t v10 = v9;
        *((unsigned char *)v9 + 8) = 0;
        if (a2) {
          CFRetain(a2);
        }
        *uint64_t v10 = a2;
        Internal = CGPDFSourceCreateInternal(0xF80uLL);
        if (!Internal) {
          goto LABEL_70;
        }
        a2 = Internal;
        uint64_t v12 = &pdf_source_create_ascii_hex_filter_callbacks;
        goto LABEL_55;
      case 2u:
        if (a5) {
          *a5 = 0;
        }
        uint64_t v14 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x20uLL, 0x10300404B55CAD2uLL);
        if (!v14) {
          return 0;
        }
        uint64_t v10 = v14;
        *((unsigned char *)v14 + 8) = 0;
        if (a2) {
          CFRetain(a2);
        }
        *uint64_t v10 = a2;
        uint64_t v15 = CGPDFSourceCreateInternal(0xF80uLL);
        if (!v15) {
          goto LABEL_70;
        }
        a2 = v15;
        uint64_t v12 = &pdf_source_create_ascii85_filter_callbacks;
        goto LABEL_55;
      case 3u:
        if (a5) {
          *a5 = 0;
        }
        uint64_t v16 = malloc_type_calloc(1uLL, 0x28uLL, 0x1020040239958B0uLL);
        if (!v16) {
          return 0;
        }
        uint64_t v17 = v16;
        v16[4] = 0;
        v16[5] = 1728;
        v16[3] = 0;
        v16[6] = 0x10000;
        v16[7] = 0;
        if (a4)
        {
          CGPDFInteger value = 0;
          LOBYTE(v58) = 0;
          if (CGPDFDictionaryGetInteger(a4, "K", &value))
          {
            if (value == (int)value) {
              v17[3] = value;
            }
            else {
              pdf_error("/%s is outside the range of allowed values.", "K");
            }
          }
          if (CGPDFDictionaryGetBoolean(a4, "EndOfLine", (CGPDFBoolean *)&v58)) {
            *((unsigned char *)v17 + 24) = (_BYTE)v58 != 0;
          }
          if (CGPDFDictionaryGetBoolean(a4, "EncodedByteAlign", (CGPDFBoolean *)&v58)) {
            *((unsigned char *)v17 + 25) = (_BYTE)v58 != 0;
          }
          if (CGPDFDictionaryGetInteger(a4, "Columns", &value))
          {
            if ((unint64_t)value >> 31) {
              pdf_error("/%s is outside the range of allowed values.", "Columns");
            }
            else {
              v17[5] = value;
            }
          }
          if (CGPDFDictionaryGetInteger(a4, "Rows", &value))
          {
            if ((unint64_t)value >> 31) {
              pdf_error("/%s is outside the range of allowed values.", "Rows");
            }
            else {
              v17[4] = value;
            }
          }
          if (CGPDFDictionaryGetBoolean(a4, "EndOfBlock", (CGPDFBoolean *)&v58)) {
            *((unsigned char *)v17 + 26) = (_BYTE)v58 != 0;
          }
          if (CGPDFDictionaryGetBoolean(a4, "BlackIs1", (CGPDFBoolean *)&v58)) {
            *((unsigned char *)v17 + 27) = (_BYTE)v58 != 0;
          }
          if (CGPDFDictionaryGetInteger(a4, "DamagedRowsBeforeError", &value))
          {
            if ((unint64_t)value >> 31) {
              pdf_error("/%s is outside the range of allowed values.", "DamagedRowsBeforeError");
            }
            else {
              v17[7] = value;
            }
          }
        }
        int v36 = v17[3];
        if (v36 >= 0) {
          int v37 = 3;
        }
        else {
          int v37 = 4;
        }
        int v38 = v36 > 0;
        if (*((unsigned char *)v17 + 24)) {
          v38 |= 2u;
        }
        if (*((unsigned char *)v17 + 25)) {
          v38 |= 4u;
        }
        if (*((unsigned char *)v17 + 26))
        {
          v38 |= 8u;
          v17[4] = 0;
        }
        if (*((unsigned char *)v17 + 27)) {
          int v39 = v38;
        }
        else {
          int v39 = v38 | 0x10;
        }
        *((unsigned char *)v17 + 8) = 0;
        if (a2) {
          CFRetain(a2);
        }
        *(void *)uint64_t v17 = a2;
        signed int v40 = v17[5];
        if (v40 > 0x3FFFFFFF) {
          goto LABEL_131;
        }
        long long v41 = malloc_type_calloc(1uLL, 0x50uLL, 0x1090040B0F722C2uLL);
        if (!v41) {
          goto LABEL_131;
        }
        BOOL v42 = v41;
        BOOL v43 = v36 < 0;
        *long long v41 = v37;
        v41[1] = v39;
        int v44 = v40 + 7;
        if (v40 < -7) {
          int v44 = v40 + 14;
        }
        v41[2] = v44 >> 3;
        v41[3] = v40;
        char v45 = v43 | v39;
        uint64_t v46 = ((v43 | v39) & 1) != 0 ? (2 * v40 + 62) & 0xFFFFFFC0 : v40;
        double v47 = (char *)malloc_type_malloc(4 * v46 + 12, 0x1000040BDFB0063uLL);
        *((void *)v42 + 4) = v47;
        if (v47)
        {
          *((void *)v42 + 6) = v47;
          v42[14] = v46;
          if (v45)
          {
            double v48 = &v47[2 * v46];
            *((void *)v42 + 5) = v48 + 6;
            *(_DWORD *)(v48 + 6) = (unsigned __int16)v42[3];
          }
          else
          {
            *((void *)v42 + 5) = 0;
          }
          *((void *)v42 + 2) = 0;
          v42[6] = 0;
          *((void *)v17 + 4) = v42;
          *((void *)v42 + 8) = ccitt_fax_filter_getc;
          *((void *)v42 + 9) = a2;
          int v51 = v17[5];
          int v53 = v51 + 7;
          BOOL v52 = v51 < -7;
          int v54 = v51 + 14;
          if (!v52) {
            int v54 = v53;
          }
          uint64_t v55 = CGPDFSourceCreateInternal((uint64_t)v54 >> 3);
          if (v55)
          {
            a2 = v55;
            *((unsigned char *)v55 + 209) = 1;
            long long v56 = *(_OWORD *)&off_1ED098970;
            *((_OWORD *)v55 + 3) = pdf_source_create_ccitt_fax_filter_callbacks;
            *((_OWORD *)v55 + 4) = v56;
            v55[10] = v17;
            return a2;
          }
        }
        else
        {
LABEL_131:
          *((void *)v17 + 4) = 0;
        }
        ccitt_fax_filter_finalize((CFTypeRef *)v17);
        return 0;
      case 4u:
        if (!a5) {
          goto LABEL_59;
        }
        int v18 = 1;
        goto LABEL_58;
      case 5u:
        if (a5) {
          *a5 = 0;
        }
        if (!a2) {
          return a2;
        }
        size_t v19 = (char *)malloc_type_malloc(0x88uLL, 0x10B004050FB1E12uLL);
        if (!v19) {
          return 0;
        }
        uint64_t v20 = (z_stream *)v19;
        *(_OWORD *)(v19 + 60) = 0u;
        *(_OWORD *)(v19 + 76) = 0u;
        *((_DWORD *)v19 + 27) = 0;
        *(_OWORD *)(v19 + 92) = 0u;
        *(_OWORD *)(v19 + 44) = 0u;
        *(_OWORD *)(v19 + 28) = 0u;
        *(_OWORD *)(v19 + 12) = 0u;
        *((void *)v19 + 8) = fstream_zalloc;
        *((void *)v19 + 9) = fstream_zfree;
        *(void *)size_t v19 = 0;
        *((_DWORD *)v19 + 2) = 0;
        v19[114] = 0;
        *((_WORD *)v19 + 56) = 0;
        CFRetain(a2);
        *(void *)&v20[1].avail_in = a2;
        uint64_t v21 = malloc_type_malloc(0xF00uLL, 0xBDF5EA43uLL);
        v20[1].total_in = (uLong)v21;
        if (!v21) {
          goto LABEL_142;
        }
        if (inflateInit_(v20, "1.2.12", 112))
        {
          if (v20->msg) {
            pdf_error("FlateDecode: initialization error: %s.");
          }
          else {
            pdf_error("FlateDecode: initialization error.");
          }
LABEL_142:
          fstream_release(v20);
          return 0;
        }
        double v49 = CGPDFSourceCreateInternal(0x3000uLL);
        a2 = v49;
        if (!v49)
        {
          fstream_release(v20);
          return a2;
        }
        *((unsigned char *)v49 + 209) = 1;
        long long v50 = *(_OWORD *)&off_1ED098990;
        *((_OWORD *)v49 + 3) = pdf_source_create_flate_filter_callbacks;
        *((_OWORD *)v49 + 4) = v50;
        v49[10] = v20;
        CGPDFInteger value = 0;
        if (!CGPDFDictionaryGetInteger(a4, "Predictor", &value)) {
          return a2;
        }
        CGPDFInteger v33 = value;
        goto LABEL_78;
      case 6u:
        if (a5) {
          *a5 = 0;
        }
        return pdf_source_create_jbig2_filter(a2, (CGPDFStream *)a1, a4);
      case 7u:
        if (a5) {
          *a5 = 0;
        }
        char v22 = 1;
        uint64_t v23 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x10200405F07FB98uLL);
        if (!v23) {
          return 0;
        }
        CGPDFDictionaryRef v24 = v23;
        CGPDFInteger v58 = 0;
        CGPDFInteger value = 0;
        *((unsigned char *)v23 + 8) = 1;
        if (a4)
        {
          if (CGPDFDictionaryGetInteger(a4, "EarlyChange", &value))
          {
            char v22 = value != 0;
            *((unsigned char *)v24 + 8) = value != 0;
          }
          else
          {
            char v22 = *((unsigned char *)v24 + 8) != 0;
          }
        }
        uint64_t v30 = lzw_decoder_create(a2, v22);
        *CGPDFDictionaryRef v24 = v30;
        if (!v30)
        {
          uint64_t v29 = v24;
          goto LABEL_82;
        }
        uint64_t v31 = CGPDFSourceCreateInternal(0xF80uLL);
        a2 = v31;
        if (v31)
        {
          *((unsigned char *)v31 + 209) = 1;
          long long v32 = *(_OWORD *)&off_1ED0989D0;
          *((_OWORD *)v31 + 3) = pdf_source_create_lzw_filter_callbacks;
          *((_OWORD *)v31 + 4) = v32;
          v31[10] = v24;
          if (CGPDFDictionaryGetInteger(a4, "Predictor", &v58))
          {
            CGPDFInteger v33 = v58;
LABEL_78:
            if (v33 != 1)
            {
              if (v33 == 2) {
                predictor2_filter = pdf_source_create_predictor2_filter(a2, a4);
              }
              else {
                predictor2_filter = pdf_source_create_png_filter(a2, a4);
              }
              double v57 = predictor2_filter;
              CFRelease(a2);
              return v57;
            }
          }
        }
        else
        {
          lzw_decoder_release((void **)*v24);
          free(v24);
        }
        return a2;
      case 8u:
        if (a5) {
          *a5 = 0;
        }
        uint64_t v25 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x20uLL, 0x10300404B55CAD2uLL);
        if (!v25) {
          return 0;
        }
        uint64_t v10 = v25;
        *((unsigned char *)v25 + 8) = 0;
        if (a2) {
          CFRetain(a2);
        }
        *uint64_t v10 = a2;
        uint64_t v26 = CGPDFSourceCreateInternal(0xF00uLL);
        if (v26)
        {
          a2 = v26;
          uint64_t v12 = &pdf_source_create_rle_filter_callbacks;
LABEL_55:
          *((unsigned char *)a2 + 209) = 1;
          long long v27 = v12[1];
          *((_OWORD *)a2 + 3) = *v12;
          *((_OWORD *)a2 + 4) = v27;
          a2[10] = v10;
          return a2;
        }
LABEL_70:
        if (*v10) {
          CFRelease(*v10);
        }
        uint64_t v29 = v10;
LABEL_82:
        free(v29);
        return 0;
      case 9u:
        if (!a5) {
          goto LABEL_59;
        }
        int v18 = 2;
LABEL_58:
        *a5 = v18;
LABEL_59:
        if (a2) {
          CFRetain(a2);
        }
        return a2;
      case 0xAu:
        if (a5) {
          *a5 = 0;
        }
        CGPDFInteger value = 0;
        if (!a4 || !CGPDFDictionaryGetName(a4, "Name", (const char **)&value)) {
          CGPDFInteger value = (CGPDFInteger)"Identity";
        }
        if (!a1 || (uint64_t v28 = *(void *)(a1 + 16)) == 0 || *(unsigned char *)(a1 + 41) || (v35 = *(void *)(v28 + 40)) == 0)
        {
          pdf_error("crypt filter specified without encryption parameters.");
          return 0;
        }
        return CGPDFSecurityManagerCreateDecryptor(v35, a1, (char *)value, a2);
      default:
        return 0;
    }
  }
  pdf_error("filter name cannot be null.");
  return 0;
}

uint64_t filter_kind_from_name(const char *a1)
{
  if (!a1)
  {
    pdf_error("filter name cannot be null.");
    return 0;
  }
  if (!strcmp(a1, "ASCIIHexDecode") || !strcmp(a1, "AHx")) {
    return 1;
  }
  if (!strcmp(a1, "ASCII85Decode") || !strcmp(a1, "A85")) {
    return 2;
  }
  if (!strcmp(a1, "CCITTFaxDecode") || !strcmp(a1, "CCF")) {
    return 3;
  }
  if (!strcmp(a1, "DCTDecode") || !strcmp(a1, "DCT")) {
    return 4;
  }
  if (!strcmp(a1, "FlateDecode") || !strcmp(a1, "Fl")) {
    return 5;
  }
  if (!strcmp(a1, "JBIG2Decode")) {
    return 6;
  }
  if (!strcmp(a1, "LZWDecode") || !strcmp(a1, "LZW")) {
    return 7;
  }
  if (!strcmp(a1, "RunLengthDecode") || !strcmp(a1, "RL")) {
    return 8;
  }
  if (!strcmp(a1, "JPXDecode")) {
    return 9;
  }
  if (strcmp(a1, "Crypt"))
  {
    return 0;
  }
  return 10;
}

void *CGPDFSourceCreateCopy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 || (a3 | a2) < 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = v3 - a2;
  if (v3 < a2) {
    uint64_t v4 = 0;
  }
  if (a3 + a2 > v3 && v3 != -1) {
    a3 = v4;
  }
  return CGPDFSourceCreate(*(const void **)(a1 + 40), *(void *)(a1 + 24) + a2, a3);
}

void CGContextDrawPDFPage(CGContextRef c, CGPDFPageRef page)
{
  memset(v6, 0, sizeof(v6));
  CGContextDrawPDFPageWithDrawingCallbacks((uint64_t)c, (unint64_t)page, (uint64_t)v6, 0, v2, v3, v4, v5);
}

void CGContextDrawPDFPageWithDrawingCallbacks(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return;
  }
  unint64_t v8 = a2;
  if (!a2) {
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108) {
    handle_invalid_context((char)"CGContextGetCTM", a1, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v12 = *(void *)(*(void *)(v8 + 40) + 8);
  uint64_t v13 = (void *)MEMORY[0x18532AD60]();
  *(void *)&v178.a = @"pageNumber";
  *(void *)&long long v179 = [NSNumber numberWithUnsignedLong:v12];
  [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v179 forKeys:&v178 count:1];
  send_analytics_event((uint64_t)"com.apple.CoreGraphics.CGContextDrawPDFPageWithDrawingCallbacks");
  uint64_t v21 = *(void *)(v8 + 16);
  char v22 = *(os_unfair_lock_s **)(v8 + 40);
  if (v22) {
    os_unfair_lock_lock(v22 + 23);
  }
  if (v21 && *(unsigned char *)(v21 + 120))
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      if (*(_DWORD *)(a1 + 24) == 1)
      {
        uint64_t v23 = *(void *)(v8 + 40);
        if (!v23 || !*(void *)(v23 + 96))
        {
          uint64_t v24 = CGPDFTaggedPagePropertiesCreate(v8);
          uint64_t v25 = *(void *)(v8 + 40);
          if (!v25) {
            goto LABEL_21;
          }
          uint64_t v26 = v24;
          long long v27 = *(const void **)(v25 + 96);
          if (v27) {
            CFRelease(v27);
          }
          *(void *)(v25 + 96) = v26;
        }
      }
    }
    else
    {
      handle_invalid_context((char)"CGContextGetType", a1, v15, v16, v17, v18, v19, v20);
    }
  }
  uint64_t v28 = *(os_unfair_lock_s **)(v8 + 40);
  if (v28) {
    os_unfair_lock_unlock(v28 + 23);
  }
  if (!v21)
  {
    BOOL v32 = 0;
    goto LABEL_34;
  }
LABEL_21:
  uint64_t v29 = (os_unfair_lock_s *)(v21 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v21 + 208));
  uint64_t v30 = *(void *)(v21 + 200);
  if (v30)
  {
    *(void *)&long long v179 = v8;
    uint64_t v31 = *(void *)(v30 + 64);
    BOOL v32 = v31 != 0;
    if (v31)
    {
      if (*(unsigned char *)(v30 + 72)) {
        printf("LRUCache: adding page: %lu\n", *(void *)(*(void *)(v8 + 40) + 8));
      }
      if (std::__hash_table<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::__unordered_map_hasher<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::hash<CGPDFPage *>,std::equal_to<CGPDFPage *>,true>,std::__unordered_map_equal<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::equal_to<CGPDFPage *>,std::hash<CGPDFPage *>,true>,std::allocator<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>>>::find<CGPDFPage *>((void *)(v30 + 24), v8))
      {
        CGPDFInteger v33 = std::__hash_table<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::__unordered_map_hasher<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::hash<CGPDFPage *>,std::equal_to<CGPDFPage *>,true>,std::__unordered_map_equal<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::equal_to<CGPDFPage *>,std::hash<CGPDFPage *>,true>,std::allocator<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>>>::__emplace_unique_key_args<CGPDFPage *,std::piecewise_construct_t const&,std::tuple<CGPDFPage * const&>,std::tuple<>>((float *)(v30 + 24), v8, &v179);
        std::list<CGPDFPage *>::erase((uint64_t *)v30, (uint64_t *)v33[3]);
      }
      else if (*(void *)(v30 + 16) >= *(void *)(v30 + 64))
      {
        LRUCache::pop_back((uint64_t **)v30);
      }
      uint64_t v34 = operator new(0x18uLL);
      v34[2] = v8;
      *uint64_t v34 = v30;
      uint64_t v35 = *(void **)(v30 + 8);
      v34[1] = v35;
      *uint64_t v35 = v34;
      uint64_t v36 = *(void *)(v30 + 16) + 1;
      *(void *)(v30 + 8) = v34;
      *(void *)(v30 + 16) = v36;
      std::__hash_table<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::__unordered_map_hasher<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::hash<CGPDFPage *>,std::equal_to<CGPDFPage *>,true>,std::__unordered_map_equal<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::equal_to<CGPDFPage *>,std::hash<CGPDFPage *>,true>,std::allocator<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>>>::__emplace_unique_key_args<CGPDFPage *,std::piecewise_construct_t const&,std::tuple<CGPDFPage * const&>,std::tuple<>>((float *)(v30 + 24), v8, &v179)[3] = v34;
      if (*(unsigned char *)(v30 + 72))
      {
        putchar(9);
        LRUCache::print((LRUCache *)v30);
      }
    }
  }
  else
  {
    BOOL v32 = 0;
  }
  os_unfair_lock_unlock(v29);
LABEL_34:
  uint64_t v37 = *(void *)(v8 + 40);
  if (pdf_page_draw_in_context_onceToken != -1) {
    dispatch_once(&pdf_page_draw_in_context_onceToken, &__block_literal_global_7164);
  }
  int v38 = &create_profile_from_set_cglibrarypredicate;
  if (pdf_page_draw_in_context_highlight_content)
  {
    CGContextSaveGState((CGContextRef)a1);
    CGContextSetRGBFillColor((CGContextRef)a1, 1.0, 0.43, 0.71, 1.0);
    v183.origin.CGFloat x = pdf_page_get_box_rect(v37, 1);
    CGContextFillRect((CGContextRef)a1, v183);
  }
  if (*(_DWORD *)(a1 + 16) == 1129601108)
  {
    int v39 = (const CGAffineTransform *)(a1 + 120);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetTextMatrix", a1, v15, v16, v17, v18, v19, v20);
    int v39 = &CGAffineTransformIdentity;
  }
  long long v166 = *(_OWORD *)&v39->a;
  long long v167 = *(_OWORD *)&v39->c;
  long long v168 = *(_OWORD *)&v39->tx;
  if (CGContextIsEmptyClipBoundingBox(a1, v14, v15, v16, v17, v18, v19, v20)) {
    goto LABEL_121;
  }
  uint64_t v46 = (char *)malloc_type_calloc(1uLL, 0xC8uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *(void *)uint64_t v46 = CGPDFContentStreamCreate(v37);
  *(_OWORD *)(v46 + 40) = xmmword_1850CD840;
  double v47 = (long long **)malloc_type_malloc(0x40uLL, 0x2004093837F09uLL);
  *((void *)v46 + 7) = v47;
  BOOL v165 = v32;
  if (*((void *)v46 + 6))
  {
    unint64_t v48 = 0;
    do
      *(void *)(*((void *)v46 + 7) + 8 * v48++) = CGPDFGStateCreate();
    while (v48 < *((void *)v46 + 6));
    double v47 = (long long **)*((void *)v46 + 7);
  }
  double v49 = *v47;
  *((void *)v46 + 4) = v49;
  CopCGFloat y = CGPDFGStateCreateCopy(v49);
  uint64_t v51 = *(void *)(v37 + 56);
  *((void *)v46 + 12) = 0;
  BOOL v52 = (uint64_t *)(v46 + 96);
  *((void *)v46 + 2) = v51;
  *((void *)v46 + 3) = Copy;
  v46[8] = 0;
  *((void *)v46 + 13) = 0;
  v46[112] = 1;
  os_unfair_lock_lock((os_unfair_lock_t)(v37 + 32));
  uint64_t v53 = *(void *)(v37 + 24);
  os_unfair_lock_unlock((os_unfair_lock_t)(v37 + 32));
  *((void *)v46 + 15) = v53;
  *((void *)v46 + 16) = 0;
  *((double *)v46 + 17) = pdf_page_get_box_rect(v37, 1);
  *((void *)v46 + 18) = v54;
  *((void *)v46 + 19) = v55;
  *((void *)v46 + 20) = v56;
  *((void *)v46 + 21) = 0;
  v46[176] = 0;
  *((void *)v46 + 23) = a3;
  *((void *)v46 + 24) = a4;
  if (CGContextGetAlpha(a1, v57, v58, v59, v60, v61, v62, v63) != 1.0
    || CGContextGetStyle(a1, v64, v65, v66, v67, v68, v69, v70)
    || CGContextGetSoftMask(a1, v64, v65, v66, v67, v68, v69, v70)
    || CGContextGetCompositeOperation(a1, v64, v65, v66, v67, v68, v69, v70) != 2)
  {
    uint64_t GStateMark = CGContextGetGStateMark(a1, v64, v65, v66, v67, v68, v69, v70);
  }
  else
  {
    xinfo = (unsigned __int8 *)pdf_page_get_xinfo(v37);
    if (!xinfo)
    {
      uint64_t GStateMark = CGContextGetGStateMark(a1, v72, v73, v74, v75, v76, v77, v78);
LABEL_130:
      int v162 = 0;
      goto LABEL_59;
    }
    int v79 = *xinfo;
    uint64_t GStateMark = CGContextGetGStateMark(a1, v72, v73, v74, v75, v76, v77, v78);
    if (!v79) {
      goto LABEL_130;
    }
  }
  set_initial_group_gstate(*((void *)v46 + 4));
  set_initial_group_gstate(*((void *)v46 + 3));
  if (*((void *)v46 + 2))
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(Mutable, @"kCGContextColorSpace", *((const void **)v46 + 2));
    CGContextBeginTransparencyLayer((CGContextRef)a1, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    v184.origin.CGFloat x = -8.98846567e307;
    v184.size.CGFloat width = 1.79769313e308;
    v184.origin.CGFloat y = -8.98846567e307;
    v184.size.CGFloat height = 1.79769313e308;
    CGContextBeginTransparencyLayerWithRect((CGContextRef)a1, v184, 0);
  }
  int v162 = 1;
LABEL_59:
  long long v180 = 0u;
  long long v181 = 0u;
  long long v179 = 0u;
  CGContextGetBaseCTM(a1, v80, v81, v82, v83, v84, v85, (uint64_t)&v179);
  CGContextGetCTM(&v178, (CGContextRef)a1);
  CGContextSetBaseCTM(a1, (long long *)&v178, v87, v88, v89, v90, v91, v92);
  double v93 = (int *)*((void *)v46 + 23);
  if (v93)
  {
    int v94 = *v93;
    *((void *)v46 + 11) = a1;
    if (CGPDFDrawingContextGetOperatorTable_predicate != -1) {
      dispatch_once(&CGPDFDrawingContextGetOperatorTable_predicate, &__block_literal_global_7866);
    }
    if (v94 == 1)
    {
      ContentTypesTable = CGPDFDrawingContextCreateContentTypesTable(*(void *)(*((void *)v46 + 23) + 24));
      uint64_t v96 = 0;
      goto LABEL_67;
    }
  }
  else
  {
    *((void *)v46 + 11) = a1;
    if (CGPDFDrawingContextGetOperatorTable_predicate != -1) {
      dispatch_once(&CGPDFDrawingContextGetOperatorTable_predicate, &__block_literal_global_7866);
    }
  }
  ContentTypesTable = (CGPDFOperatorTable *)CGPDFDrawingContextGetOperatorTable_operator_table;
  uint64_t v96 = 1;
LABEL_67:
  CGPDFScannerRef v97 = CGPDFScannerCreate(*(CGPDFContentStreamRef *)v46, ContentTypesTable, v46);
  uint64_t v105 = *((void *)v46 + 23);
  if (v105 && v97)
  {
    *((void *)v97 + 15) = *(void *)(v105 + 8);
    *((void *)v97 + 16) = a4;
  }
  scanner = v97;
  uint64_t v106 = *(void *)v37;
  if (*(void *)v37)
  {
    uint64_t v107 = *(uint64_t **)(v106 + 16);
    uint64_t v108 = *(void *)(*v107 + 40);
    if (!v108 || (uint64_t v109 = *(void *)(v108 + 16)) != 0 && *(unsigned char *)(v109 + 184))
    {
      value[0] = 0;
      uint64_t v161 = v106;
      trailer = (CGPDFDictionary *)pdf_xref_get_trailer(*v107);
      if (CGPDFDictionaryGetDictionary(trailer, "Root", value))
      {
        uint64_t v111 = value[0];
        if (value[0])
        {
          uint64_t v112 = (os_unfair_lock_s *)(v161 + 68);
          os_unfair_lock_lock((os_unfair_lock_t)(v161 + 68));
          uint64_t v113 = v161;
          if (!*(unsigned char *)(v161 + 72))
          {
            *(unsigned char *)(v161 + 88) = 1;
            CGPDFDictionaryRef v177 = 0;
            if (CGPDFDictionaryGetDictionary(v111, "OCProperties", &v177))
            {
              CGPDFDictionaryRef v175 = 0;
              CGPDFArrayRef v176 = 0;
              if (CGPDFDictionaryGetDictionary(v177, "D", &v175) && CGPDFDictionaryGetArray(v177, "OCGs", &v176))
              {
                __s1 = 0;
                if (CGPDFDictionaryGetName(v175, "BaseState", (const char **)&__s1) && !strcmp(__s1, "OFF")) {
                  *(unsigned char *)(v161 + 88) = 0;
                }
                uint64_t v114 = 0;
                CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                long long v156 = (void *)*MEMORY[0x1E4F1CFD0];
                int v155 = (void *)*MEMORY[0x1E4F1CFC8];
                char v115 = 1;
                do
                {
                  char v157 = v115;
                  arraCGFloat y = 0;
                  if (CGPDFDictionaryGetArray(v175, off_1E52CD710[v114], &array))
                  {
                    if (array)
                    {
                      uint64_t v116 = *((void *)array + 2);
                      if (v116)
                      {
                        size_t v117 = 0;
                        long long v118 = v156;
                        if ((v157 & 1) == 0) {
                          long long v118 = v155;
                        }
                        long long v158 = v118;
                        uint64_t v159 = *((void *)array + 2);
                        do
                        {
                          CGPDFObjectRef v172 = 0;
                          if (CGPDFArrayGetObject(array, v117, &v172))
                          {
                            unint64_t v119 = v8;
                            uint64_t v120 = v96;
                            uint64_t v121 = v37;
                            uint64_t v122 = ContentTypesTable;
                            if (!*(void *)(v161 + 80)) {
                              *(void *)(v161 + 80) = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                            }
                            value[0] = (CGPDFDictionaryRef)(*((unsigned __int16 *)v172 + 12) | (*((void *)v172 + 2) << 36));
                            CFNumberRef v123 = CFNumberCreate(allocator, kCFNumberSInt64Type, value);
                            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v161 + 80), v123, v158);
                            CFRelease(v123);
                            ContentTypesTable = v122;
                            uint64_t v37 = v121;
                            uint64_t v96 = v120;
                            unint64_t v8 = v119;
                            uint64_t v112 = (os_unfair_lock_s *)(v161 + 68);
                            uint64_t v116 = v159;
                          }
                          ++v117;
                        }
                        while (v116 != v117);
                      }
                    }
                  }
                  char v115 = 0;
                  uint64_t v114 = 1;
                }
                while ((v157 & 1) != 0);
              }
            }
            uint64_t v113 = v161;
            *(unsigned char *)(v161 + 72) = 1;
          }
          uint64_t v124 = v113;
          os_unfair_lock_unlock(v112);
          *((void *)v46 + 13) = *(void *)(v124 + 80);
          v46[112] = *(unsigned char *)(v124 + 88);
        }
      }
    }
  }
  if (CGContextGetType(a1, v98, v99, v100, v101, v102, v103, v104) == 1) {
    uint64_t *v52 = *(void *)(v37 + 96);
  }
  uint64_t v125 = *(void *)(v37 + 72);
  int v38 = &create_profile_from_set_cglibrarypredicate;
  if (v125 && CGPropertiesGetProperty(v125, @"drawocr")) {
    v46[176] = 1;
  }
  CGPDFScannerScan(scanner);
  if (scanner) {
    CFRelease(scanner);
  }
  if (CGContextGetType(a1, v126, v127, v128, v129, v130, v131, v132) == 1)
  {
    uint64_t StructureTree = CGPDFTaggedPagePropertiesGetStructureTree(*v52);
    CGPDFContextSetPageTagStructureTree(a1, StructureTree, v134, v135, v136, v137, v138, v139);
  }
  if (ContentTypesTable) {
    char v140 = v96;
  }
  else {
    char v140 = 1;
  }
  if ((v140 & 1) == 0) {
    CFRelease(ContentTypesTable);
  }
  double v141 = (const void *)*((void *)v46 + 16);
  BOOL v32 = v165;
  if (v141)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v37 + 88));
    int v142 = *(const void **)(v37 + 104);
    if (v142 != v141)
    {
      if (v142) {
        CFRelease(v142);
      }
      CFRetain(v141);
      *(void *)(v37 + 104) = v141;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v37 + 88));
    int v38 = &create_profile_from_set_cglibrarypredicate;
  }
  CGPDFDrawingContextRelease(v46);
  if (v162) {
    CGContextEndTransparencyLayer((CGContextRef)a1);
  }
  CGContextRestoreToGStateMark(a1, GStateMark, v143, v144, v145, v146, v147, v148);
  *(_OWORD *)CGPDFInteger value = v179;
  long long v170 = v180;
  long long v171 = v181;
  CGContextSetBaseCTM(a1, (long long *)value, v149, v150, v151, v152, v153, v154);
LABEL_121:
  if (*(_DWORD *)(a1 + 16) == 1129601108)
  {
    *(_OWORD *)(a1 + 120) = v166;
    *(_OWORD *)(a1 + 136) = v167;
    *(_OWORD *)(a1 + 152) = v168;
  }
  else
  {
    handle_invalid_context((char)"CGContextSetTextMatrix", a1, v40, v41, v42, v43, v44, v45);
  }
  if (*((unsigned char *)v38 + 624))
  {
    CGContextSetRGBFillColor((CGContextRef)a1, 1.0, 0.43, 0.71, 0.25);
    v185.origin.CGFloat x = pdf_page_get_box_rect(v37, 1);
    CGContextFillRect((CGContextRef)a1, v185);
    CGContextRestoreGState((CGContextRef)a1);
  }
  *(unsigned char *)(v8 + 280) = 1;
  if (!v32) {
    CGPDFPagePurgeResources(v8);
  }
}

void CGContextSetBaseCTM(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      uint64_t v8 = *(void *)(a1 + 112);
      long long v9 = *a2;
      long long v10 = a2[1];
      *(_OWORD *)(v8 + 56) = a2[2];
      *(_OWORD *)(v8 + 40) = v10;
      *(_OWORD *)(v8 + 24) = v9;
      return;
    }
    uint64_t v11 = a1;
  }
  else
  {
    uint64_t v11 = 0;
  }
  handle_invalid_context((char)"CGContextSetBaseCTM", v11, a3, a4, a5, a6, a7, a8);
}

CGAffineTransform *__cdecl CGContextGetCTM(CGAffineTransform *__return_ptr retstr, CGAffineTransform *c)
{
  if (c && LODWORD(c->c) == 1129601108)
  {
    long long v9 = (const CGAffineTransform *)(*(void *)&c[2].a + 24);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetCTM", (uint64_t)c, v2, v3, v4, v5, v6, v7);
    long long v9 = &CGAffineTransformIdentity;
  }
  long long v10 = *(_OWORD *)&v9->c;
  *(_OWORD *)&retstr->a = *(_OWORD *)&v9->a;
  *(_OWORD *)&retstr->c = v10;
  *(_OWORD *)&retstr->tCGFloat x = *(_OWORD *)&v9->tx;
  return c;
}

uint64_t CGContextGetType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned int *)(a1 + 24);
  }
  handle_invalid_context((char)"CGContextGetType", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

__n128 CGContextGetBaseCTM@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    long long v9 = (const CGAffineTransform *)(*(void *)(a1 + 112) + 24);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetBaseCTM", a1, a2, a3, a4, a5, a6, a7);
    long long v9 = &CGAffineTransformIdentity;
  }
  long long v10 = *(_OWORD *)&v9->c;
  *(_OWORD *)a8 = *(_OWORD *)&v9->a;
  *(_OWORD *)(a8 + 16) = v10;
  __n128 result = *(__n128 *)&v9->tx;
  *(__n128 *)(a8 + 32) = result;
  return result;
}

uint64_t CGContextGetCompositeOperation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return ((__int16)*(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 120) + 4) >> 8);
  }
  handle_invalid_context((char)"CGContextGetCompositeOperation", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

char *CGPDFGStateCreate()
{
  v0 = (char *)malloc_type_malloc(0x118uLL, 0x566C45D1uLL);
  __CFSetLastAllocationEventName();
  if (v0)
  {
    *(CGAffineTransform *)v0 = CGAffineTransformIdentity;
    *((_WORD *)v0 + 24) = 0;
    *(_OWORD *)(v0 + 56) = 0u;
    *(_OWORD *)(v0 + 72) = 0u;
    *((void *)v0 + 12) = 0;
    *((void *)v0 + 13) = 0;
    *((void *)v0 + 11) = 0x4059000000000000;
    *((_DWORD *)v0 + 28) = 0;
    *((void *)v0 + 15) = 0;
    *((void *)v0 + 16) = 0;
    v0[136] = 1;
    *((void *)v0 + 18) = 0x3FF0000000000000;
    *((void *)v0 + 19) = 0;
    *((void *)v0 + 20) = 0x4024000000000000;
    *((void *)v0 + 21) = 0;
    *((_DWORD *)v0 + 44) = 2;
    v0[180] = 0;
    *((_DWORD *)v0 + 46) = 0;
    *((void *)v0 + 24) = 0;
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)(v0 + 200) = _Q0;
    *((_WORD *)v0 + 108) = 0;
    v0[218] = 0;
    *(void *)(v0 + 228) = 0;
    *(void *)(v0 + 220) = 0;
    *((_DWORD *)v0 + 61) = 0;
    *(void *)(v0 + 236) = 0;
    *((void *)v0 + 31) = 0x3FF0000000000000;
    *((void *)v0 + 32) = 0;
    *((void *)v0 + 33) = 0;
    *((void *)v0 + 34) = 0;
  }
  return v0;
}

uint64_t CGContextGetSoftMask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(*(void *)(*(void *)(a1 + 96) + 120) + 40);
  }
  handle_invalid_context((char)"CGContextGetSoftMask", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t send_analytics_event(uint64_t a1)
{
  uint64_t result = [NSString stringWithUTF8String:a1];
  if (MEMORY[0x1E4F5B1E8])
  {
    if ((send_analytics_event_sSendAnalytics & 1) == 0) {
      return AnalyticsSendEventLazy();
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::__unordered_map_hasher<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::hash<CGPDFPage *>,std::equal_to<CGPDFPage *>,true>,std::__unordered_map_equal<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::equal_to<CGPDFPage *>,std::hash<CGPDFPage *>,true>,std::allocator<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>>>::__emplace_unique_key_args<CGPDFPage *,std::piecewise_construct_t const&,std::tuple<CGPDFPage * const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v8;
  i[2] = *a3;
  i[3] = 0;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      int8x8_t prime = (int8x8_t)v18;
    }
    else {
      int8x8_t prime = (int8x8_t)v17;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v9 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v9) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (*(void *)&prime <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:fe180100]();
          }
          uint64_t v20 = operator new(8 * *(void *)&prime);
          uint64_t v21 = *(void **)a1;
          *(void *)a1 = v20;
          if (v21) {
            operator delete(v21);
          }
          uint64_t v22 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v22++) = 0;
          while (*(void *)&prime != v22);
          uint64_t v23 = (void *)*((void *)a1 + 2);
          if (v23)
          {
            unint64_t v24 = v23[1];
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v24) = a1 + 4;
            uint64_t v29 = (void *)*v23;
            if (*v23)
            {
              do
              {
                unint64_t v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }
                else
                {
                  v30 &= *(void *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v30))
                  {
                    *(void *)(*(void *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *uint64_t v23 = *v29;
                  *uint64_t v29 = **(void **)(*(void *)a1 + 8 * v30);
                  **(void **)(*(void *)a1 + 8 * v30) = v29;
                  uint64_t v29 = v23;
                }
                unint64_t v30 = v24;
LABEL_55:
                uint64_t v23 = v29;
                uint64_t v29 = (void *)*v29;
                unint64_t v24 = v30;
              }
              while (v29);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v35 = *(void **)a1;
        *(void *)a1 = 0;
        if (v35) {
          operator delete(v35);
        }
        unint64_t v9 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v31 = *(void **)a1;
  BOOL v32 = *(void **)(*(void *)a1 + 8 * v3);
  if (v32)
  {
    *uint64_t i = *v32;
LABEL_72:
    void *v32 = i;
    goto LABEL_73;
  }
  *uint64_t i = *((void *)a1 + 2);
  *((void *)a1 + 2) = i;
  v31[v3] = a1 + 4;
  if (*i)
  {
    unint64_t v33 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v33 >= v9) {
        v33 %= v9;
      }
    }
    else
    {
      v33 &= v9 - 1;
    }
    BOOL v32 = (void *)(*(void *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return i;
}

void sub_184C85148(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

double CGContextGetAlpha(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 120) + 8);
  }
  handle_invalid_context((char)"CGContextGetAlpha", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t pdf_page_get_xinfo(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (!*(void *)(a1 + 64))
  {
    BOOL v3 = 1;
    uint64_t v4 = malloc_type_calloc(1uLL, 1uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    uint64_t v9 = 0;
    uint8x8_t v10 = &v9;
    uint64_t v11 = 0x2000000000;
    char v12 = 0;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
    uint64_t v5 = *(void *)(a1 + 24);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    v8[2] = __CheckPageForSpecialBlends_block_invoke;
    v8[3] = &unk_1E52CC060;
    v8[4] = &v9;
    CGPDFResourcesIterateCategory(v5, "ExtGState", (uint64_t)v8);
    if (!*((unsigned char *)v10 + 24))
    {
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 0x40000000;
      v7[2] = __CheckPageForSpecialBlends_block_invoke_2;
      v7[3] = &unk_1E52CC0B0;
      v7[4] = &v9;
      CGPDFResourcesIterateCategory(v5, "XObject", (uint64_t)v7);
      BOOL v3 = *((unsigned char *)v10 + 24) != 0;
    }
    _Block_object_dispose(&v9, 8);
    *uint64_t v4 = v3;
    *(void *)(a1 + 64) = v4;
  }
  os_unfair_lock_unlock(v2);
  return *(void *)(a1 + 64);
}

void *std::__hash_table<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::__unordered_map_hasher<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::hash<CGPDFPage *>,std::equal_to<CGPDFPage *>,true>,std::__unordered_map_equal<CGPDFPage *,std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>,std::equal_to<CGPDFPage *>,std::hash<CGPDFPage *>,true>,std::allocator<std::__hash_value_type<CGPDFPage *,std::__list_iterator<CGPDFPage *,void *>>>>::find<CGPDFPage *>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  unint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

CGPDFScannerRef CGPDFScannerCreate(CGPDFContentStreamRef cs, CGPDFOperatorTableRef table, void *info)
{
  if (CGPDFScannerGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFScannerGetTypeID_onceToken, &__block_literal_global_21719);
  }
  uint64_t cftype = pdf_create_cftype();
  *(void *)(cftype + 16) = info;
  if (cs)
  {
    CFRetain(cs);
    uint64_t v7 = *((void *)cs + 3);
  }
  else
  {
    uint64_t v7 = 0;
  }
  *(void *)(cftype + 48) = v7;
  *(void *)(cftype + 56) = cs;
  CGPDFScannerPushTable((void *)cftype, (uint64_t)table);
  *(_DWORD *)(cftype + 112) = 0;
  *(void *)(cftype + 144) = 0;
  *(void *)(cftype + 120) = 0;
  *(void *)(cftype + 128) = 0;
  *(unsigned char *)(cftype + 136) = 0;
  *(void *)(cftype + 72) = 0x800000000;
  *(void *)(cftype + 80) = malloc_type_malloc(0x140uLL, 0x103204077D336DFuLL);
  return (CGPDFScannerRef)cftype;
}

void *CGPDFScannerPushTable(void *result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      unint64_t v3 = result;
      unint64_t v4 = malloc_type_malloc(0x248uLL, 0x566C45D1uLL);
      uint64_t result = (void *)__CFSetLastAllocationEventName();
      if (v4)
      {
        for (uint64_t i = 0; i != 73; ++i)
          v4[i] = *(void *)(a2 + 16 + i * 8);
        v4[(int)CGPDFGetOperatorForName("BI", 2uLL, 0)] = op_BI;
        v4[(int)CGPDFGetOperatorForName("BX", 2uLL, 0)] = op_BX;
        v4[(int)CGPDFGetOperatorForName("EX", 2uLL, 0)] = op_EX;
        v3[3] = v4;
        uint64_t v6 = v3[4];
        uint64_t result = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        *uint64_t result = v6;
        result[1] = v4;
        v3[4] = result;
      }
    }
  }
  return result;
}

void *CGPDFGStateCreateCopy(long long *a1)
{
  int8x8_t v2 = malloc_type_malloc(0x118uLL, 0x566C45D1uLL);
  __CFSetLastAllocationEventName();
  if (v2) {
    CGPDFGStateCopyProperties((uint64_t)v2, a1);
  }
  return v2;
}

void CGPDFDrawingContextSaveGState(uint64_t a1)
{
  if (a1)
  {
    unint64_t v2 = *(void *)(a1 + 48);
    if (*(void *)(a1 + 40) >= v2)
    {
      *(void *)(a1 + 48) = 2 * v2;
      *(void *)(a1 + 56) = malloc_type_realloc(*(void **)(a1 + 56), 16 * v2, 0x2004093837F09uLL);
      if (v2 < *(void *)(a1 + 48))
      {
        do
        {
          unint64_t v3 = CGPDFGStateCreate();
          unint64_t v4 = *(void *)(a1 + 48);
          *(void *)(*(void *)(a1 + 56) + 8 * v2++) = v3;
        }
        while (v2 < v4);
      }
    }
    CGPDFGStateCopyProperties(*(void *)(*(void *)(a1 + 56) + 8 * *(void *)(a1 + 40)), *(long long **)(a1 + 32));
    uint64_t v5 = *(void *)(a1 + 40);
    *(void *)(a1 + 32) = *(void *)(*(void *)(a1 + 56) + 8 * v5);
    *(void *)(a1 + 40) = v5 + 1;
    uint64_t v6 = *(CGContext **)(a1 + 88);
    if (v6)
    {
      CGContextSaveGState(v6);
    }
  }
}

CFTypeRef CGPDFGStateCopyProperties(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v4;
  *(_WORD *)(a1 + 48) = *((_WORD *)a2 + 24);
  uint64_t v6 = *((void *)a2 + 7);
  if (v6) {
    CFRetain(*((CFTypeRef *)a2 + 7));
  }
  *(void *)(a1 + 56) = v6;
  uint64_t v7 = *((void *)a2 + 8);
  if (v7) {
    CFRetain(*((CFTypeRef *)a2 + 8));
  }
  *(void *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 72) = *(long long *)((char *)a2 + 72);
  *(_OWORD *)(a1 + 88) = *(long long *)((char *)a2 + 88);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  uint64_t v8 = *((void *)a2 + 15);
  if (v8) {
    CFRetain(*((CFTypeRef *)a2 + 15));
  }
  *(void *)(a1 + 120) = v8;
  *(void *)(a1 + 128) = *((void *)a2 + 16);
  *(unsigned char *)(a1 + 136) = *((unsigned char *)a2 + 136);
  uint64_t v9 = *((void *)a2 + 19);
  *(void *)(a1 + 144) = *((void *)a2 + 18);
  *(void *)(a1 + 152) = v9;
  *(void *)(a1 + 160) = *((void *)a2 + 20);
  unint64_t v10 = (atomic_uint *)*((void *)a2 + 21);
  if (v10) {
    atomic_fetch_add_explicit(v10, 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 168) = v10;
  *(_DWORD *)(a1 + 176) = *((_DWORD *)a2 + 44);
  *(unsigned char *)(a1 + 180) = *((unsigned char *)a2 + 180);
  *(_DWORD *)(a1 + 184) = *((_DWORD *)a2 + 46);
  uint64_t v11 = *((void *)a2 + 24);
  if (v11) {
    CFRetain(*((CFTypeRef *)a2 + 24));
  }
  *(void *)(a1 + 192) = v11;
  *(_OWORD *)(a1 + 200) = *(long long *)((char *)a2 + 200);
  *(unsigned char *)(a1 + 216) = *((unsigned char *)a2 + 216);
  *(_WORD *)(a1 + 217) = *(_WORD *)((char *)a2 + 217);
  *(_DWORD *)(a1 + 220) = *((_DWORD *)a2 + 55);
  uint64_t v12 = *((void *)a2 + 28);
  if (v12) {
    CFRetain(*((CFTypeRef *)a2 + 28));
  }
  *(void *)(a1 + 224) = v12;
  uint64_t v13 = *((void *)a2 + 29);
  if (v13) {
    CFRetain(*((CFTypeRef *)a2 + 29));
  }
  *(void *)(a1 + 232) = v13;
  CFTypeRef result = (CFTypeRef)*((void *)a2 + 30);
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *(void *)(a1 + 240) = result;
  *(_OWORD *)(a1 + 248) = *(long long *)((char *)a2 + 248);
  float v15 = (const void *)*((void *)a2 + 33);
  if (v15) {
    CFTypeRef result = CFRetain(v15);
  }
  *(void *)(a1 + 264) = v15;
  *(void *)(a1 + 272) = 0;
  return result;
}

void CGPDFDrawingContextRelease(void *a1)
{
  if (a1)
  {
    unint64_t v2 = *(const void **)a1;
    if (v2) {
      CFRelease(v2);
    }
    unint64_t v3 = (void *)*((void *)a1 + 3);
    if (v3)
    {
      CGPDFGStateReleaseProperties(*((void **)a1 + 3));
      free(v3);
    }
    unint64_t v4 = *((void *)a1 + 5);
    if (v4)
    {
      for (unint64_t i = 0; i < v4; ++i)
      {
        uint64_t v6 = *((void *)a1 + 7);
        uint64_t v7 = *(void **)(v6 + 8 * i);
        if (v7)
        {
          CGPDFGStateReleaseProperties(*(void **)(v6 + 8 * i));
          free(v7);
          unint64_t v4 = *((void *)a1 + 5);
        }
      }
    }
    while (v4 < *((void *)a1 + 6))
      free(*(void **)(*((void *)a1 + 7) + 8 * v4++));
    free(*((void **)a1 + 7));
    uint64_t v8 = (const void *)*((void *)a1 + 8);
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = (const void *)*((void *)a1 + 9);
    if (v9) {
      CFRelease(v9);
    }
    unint64_t v10 = (const void *)*((void *)a1 + 16);
    if (v10) {
      CFRelease(v10);
    }
    free(a1);
  }
}

void CGPDFGStateReleaseProperties(void *a1)
{
  unint64_t v2 = (void *)a1[34];
  if (v2)
  {
    unint64_t v3 = (const void *)v2[6];
    if (v3) {
      CFRelease(v3);
    }
    unint64_t v4 = (void *)v2[21];
    if (v4)
    {
      text_layout_reset((void *)v2[21]);
      free(v4);
    }
    long long v5 = (void *)v2[22];
    if (v5)
    {
      text_layout_reset((void *)v2[22]);
      free(v5);
    }
    free(v2);
  }
  uint64_t v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[8];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[15];
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (void *)a1[21];
  if (v9 && atomic_fetch_add_explicit((atomic_uint *volatile)v9, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    free(v9);
  }
  unint64_t v10 = (const void *)a1[24];
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = (const void *)a1[28];
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = (const void *)a1[29];
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v13 = (const void *)a1[30];
  if (v13) {
    CFRelease(v13);
  }
  float v14 = (const void *)a1[33];
  if (v14)
  {
    CFRelease(v14);
  }
}

uint64_t CGPDFContentStreamCreate(uint64_t a1)
{
  uint64_t v13 = 0;
  CGPDFObjectRef value = 0;
  if (!CGPDFDictionaryGetObject(*(CGPDFDictionaryRef *)(a1 + 16), "Contents", &value) || value == 0) {
    goto LABEL_6;
  }
  int v4 = *((_DWORD *)value + 2);
  if (v4 != 7)
  {
    if (v4 == 9)
    {
      uint64_t v13 = (void *)*((void *)value + 4);
      uint64_t v3 = pdf_content_stream_create(1);
      CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 24), v13);
      goto LABEL_10;
    }
    return 0;
  }
  unint64_t v10 = (CGPDFArray *)*((void *)value + 4);
  if (!v10)
  {
LABEL_6:
    uint64_t v3 = pdf_content_stream_create(0);
LABEL_10:
    PropertCGFloat y = *(const void **)(a1 + 72);
    if (Property) {
      PropertCGFloat y = CGPropertiesGetProperty((uint64_t)Property, @"kCGPDFPageShouldRenderExtraContentStream");
    }
    if (Property != (const void *)*MEMORY[0x1E4F1CFC8])
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      uint64_t v6 = *(void **)(a1 + 40);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      uint64_t v13 = v6;
      if (v6) {
        CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 24), v6);
      }
    }
    *(void *)(v3 + 16) = a1;
    uint64_t v7 = (os_unfair_lock_s *)(a1 + 32);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
    uint64_t v8 = *(const void **)(a1 + 24);
    os_unfair_lock_unlock(v7);
    if (v8) {
      CFRetain(v8);
    }
    *(void *)(v3 + 32) = v8;
    set_default_color_spaces((CGColorSpace *)v3);
    return v3;
  }
  CFIndex v11 = *((void *)v10 + 2);
  uint64_t v3 = pdf_content_stream_create(v11);
  if (!v11) {
    goto LABEL_10;
  }
  size_t v12 = 0;
  while (CGPDFArrayGetStream(v10, v12, (CGPDFStreamRef *)&v13))
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 24), v13);
    if (v11 == ++v12) {
      goto LABEL_10;
    }
  }
  if (v3)
  {
    CFRelease((CFTypeRef)v3);
    return 0;
  }
  return v3;
}

uint64_t pdf_content_stream_create(CFIndex a1)
{
  if (CGPDFContentStreamGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFContentStreamGetTypeID_onceToken, &__block_literal_global_18284);
  }
  uint64_t cftype = pdf_create_cftype();
  if (cftype) {
    *(void *)(cftype + 24) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0);
  }
  return cftype;
}

void CGContextRestoreToGStateMark(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      if (!a2 || (unint64_t v10 = *(void **)(a1 + 104), v10 == (void *)a2))
      {
        CGPostError((uint64_t)"%s: invalid gstate mark.", a2, a3, a4, a5, a6, a7, a8, (char)"CGContextRestoreToGStateMark");
      }
      else
      {
        if (v10)
        {
          CGGStackReset(*(uint64_t **)(a1 + 104));
          free(v10);
        }
        *(void *)(a1 + 104) = a2;
        uint64_t v11 = *(void *)(a2 + 8);
        if (v11 == a2)
        {
          size_t v12 = CGGStateCreate();
          uint64_t v13 = *(char ***)(a2 + 8);
          *(void *)(a2 + 8) = v12;
          *(void *)size_t v12 = a2;
          *uint64_t v13 = v12;
          *((void *)v12 + 1) = v13;
          uint64_t v11 = *(void *)(a2 + 8);
        }
        *(void *)(a1 + 96) = v11;
      }
      return;
    }
    uint64_t v14 = a1;
  }
  else
  {
    uint64_t v14 = 0;
  }

  handle_invalid_context((char)"CGContextRestoreToGStateMark", v14, a3, a4, a5, a6, a7, a8);
}

uint64_t CGContextGetStyle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(*(void *)(*(void *)(a1 + 96) + 120) + 16);
  }
  handle_invalid_context((char)"CGContextGetStyle", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetGStateMark(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v15 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextGetGStateMark", v15, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v15 = a1;
    goto LABEL_8;
  }
  uint64_t v9 = *(void *)(a1 + 104);
  unint64_t v10 = CGGStackCreateWithGState(*(void *)(a1 + 96));
  *(void *)(a1 + 104) = v10;
  uint64_t v11 = (void *)v10[1];
  if (v11 == v10)
  {
    size_t v12 = v10;
    uint64_t v13 = CGGStateCreate();
    uint64_t v14 = (char **)v12[1];
    v12[1] = v13;
    *(void *)uint64_t v13 = v12;
    *uint64_t v14 = v13;
    *((void *)v13 + 1) = v14;
    uint64_t v11 = (void *)v12[1];
  }
  *(void *)(a1 + 96) = v11;
  return v9;
}

void std::list<CGPDFPage *>::erase(uint64_t *a1, uint64_t *__p)
{
  if (__p == a1)
  {
    __break(1u);
  }
  else
  {
    uint64_t v2 = *__p;
    *(void *)(v2 + 8) = __p[1];
    *(void *)__p[1] = v2;
    --a1[2];
    operator delete(__p);
  }
}

uint64_t CGFontGetVariationAxes(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 408))(*(void *)(result + 112));
  }
  return result;
}

uint64_t CGContextDelegateEndLayer(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(uint64_t (**)(void))(a1 + 200)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t CGContextDelegateBeginLayer(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(uint64_t (**)(void))(a1 + 192)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

void clip<std::vector<std::vector<ClipperLib::IntPoint>>>(_OWORD *a1, int a2, CGPathRef path, int a4, const CGPath *a5, int a6, int a7, CGPathRandomAccess *a8, uint64_t a9)
{
  BoundingBoCGFloat x = CGPathGetBoundingBox(path);
  CGFloat x = BoundingBox.origin.x;
  CGFloat y = BoundingBox.origin.y;
  CGFloat width = BoundingBox.size.width;
  CGFloat height = BoundingBox.size.height;
  if (a5)
  {
    CGRect v55 = CGPathGetBoundingBox(a5);
    v52.origin.CGFloat x = x;
    v52.origin.CGFloat y = y;
    v52.size.CGFloat width = width;
    v52.size.CGFloat height = height;
    CGRect v53 = CGRectUnion(v52, v55);
    CGFloat x = v53.origin.x;
    CGFloat y = v53.origin.y;
    CGFloat width = v53.size.width;
    CGFloat height = v53.size.height;
  }
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  v54.origin.CGFloat x = x;
  v54.origin.CGFloat y = y;
  v54.size.CGFloat width = width;
  v54.size.CGFloat height = height;
  transform_for_bounds(v54, (uint64_t)a1);
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v47 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  uint8x8_t v25 = &unk_1ED094568;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long __p = 0u;
  uint64_t v30 = 0;
  v31[0] = v31;
  v31[1] = v31;
  v31[2] = 0;
  char v32 = 0;
  char v39 = 0;
  char v33 = 0;
  char v34 = 0;
  __int16 v43 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = &unk_1ED0945B0;
  if (a7)
  {
    uint64_t v35 = interpolate_intersection_metadata;
    LOBYTE(v43) = 1;
  }
  char v34 = 0;
  long long v18 = a1[1];
  *(_OWORD *)&v24.a = *a1;
  *(_OWORD *)&v24.c = v18;
  *(_OWORD *)&v24.tCGFloat x = a1[2];
  CGPathRandomAccess::add_path(a8, path, &v24, 1);
  CFIndex v20 = v19;
  long long v21 = a1[1];
  *(_OWORD *)&v23.a = *a1;
  *(_OWORD *)&v23.c = v21;
  *(_OWORD *)&v23.tCGFloat x = a1[2];
  v50.location = v22;
  v50.length = v20;
  CGPathRandomAccess::clipper_paths_for_subpath_range(a8, v50, &v23);
}

void sub_184C86758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  __cxa_free_exception(v39);
  ClipperLib::Clipper::~Clipper((ClipperLib::Clipper *)&a39);
  _Unwind_Resume(a1);
}

void CGContextClipToMask(CGContextRef c, CGRect rect, CGImageRef mask)
{
  if (!c)
  {
    CGContextRef v21 = 0;
LABEL_25:
    handle_invalid_context((char)"CGContextClipToMask", (uint64_t)v21, v3, v4, v5, v6, v7, v8);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v21 = c;
    goto LABEL_25;
  }
  CGFloat height = rect.size.height;
  CGFloat width = rect.size.width;
  CGFloat y = rect.origin.y;
  CGFloat x = rect.origin.x;
  if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
  {
    CGImageRef v19 = mask;
    if (!mask) {
      goto LABEL_33;
    }
    if ((*((unsigned char *)mask + 39) & 2) != 0)
    {
      mask_from_image = 0;
    }
    else
    {
      mask_from_image = create_mask_from_image(mask, (uint64_t)mask, v3, v4, v5, v6, v7, v8);
      CGImageRef v19 = mask_from_image;
      if (!mask_from_image)
      {
LABEL_33:
        long long v27 = (const void *)*((void *)c + 21);
        if (v27)
        {
          CFRelease(v27);
          *((void *)c + 21) = 0;
        }
        return;
      }
    }
    uint64_t v22 = *((void *)c + 12);
    CGAffineTransform v23 = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
    *(_DWORD *)CGAffineTransform v23 = 1;
    long long v24 = *(_OWORD *)(v22 + 56);
    long long v25 = *(_OWORD *)(v22 + 40);
    *(_OWORD *)(v23 + 8) = *(_OWORD *)(v22 + 24);
    *(_OWORD *)(v23 + 24) = v25;
    *(_OWORD *)(v23 + 40) = v24;
    CFRetain(v19);
    *((void *)v23 + 7) = v19;
    *((CGFloat *)v23 + 8) = x;
    *((CGFloat *)v23 + 9) = y;
    *((CGFloat *)v23 + 10) = width;
    *((CGFloat *)v23 + 11) = height;
    long long v26 = (char *)CGClipCreateWithMask((atomic_uint *)v23, HIBYTE(*(_DWORD *)(*(void *)(v22 + 120) + 4)) & 1);
    CGClipMaskRelease(v23);
    if (v26)
    {
      maybeCopyClipState(v22);
      CGClipStackAddClip(*(void *)(v22 + 112), (uint64_t)v26);
      CGClipRelease(v26);
    }
    if (mask_from_image) {
      CFRelease(mask_from_image);
    }
    goto LABEL_33;
  }
}

void CGClipMaskRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = (const void *)a1[7];
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

void CGPDFDrawingContextDrawPath(uint64_t a1, unsigned int a2, int a3)
{
  if (a3) {
    CGContextClosePath(*(CGContextRef *)(a1 + 88));
  }
  unsigned __int8 v33 = 0;
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(CGContext **)(a1 + 88);
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    CGContextSetAlpha(*(CGContextRef *)(a1 + 88), 1.0);
    v35.double width = 0.0;
    v35.double height = 0.0;
    CGContextSetPatternPhase(v6, v35);
    if (a2 < 2)
    {
      FillColor = (CGColor *)CGPDFGStateGetFillColor(v5);
      CGContextSetFillColorWithColor(v6, FillColor);
    }
    else
    {
      if (a2 - 3 < 2)
      {
        uint64_t v8 = (CGColor *)CGPDFGStateGetFillColor(v5);
        CGContextSetFillColorWithColor(v6, v8);
LABEL_12:
        StrokeColor = (CGColor *)CGPDFGStateGetStrokeColor(v5);
        CGContextSetStrokeColorWithColor(v6, StrokeColor);
        CGPDFGStateSynchronizeStroke(v5, v6);
        goto LABEL_13;
      }
      if (a2 == 2) {
        goto LABEL_12;
      }
    }
LABEL_13:
    CGPDFGStateSynchronizeColorRendering(v5, v6);
    CGPDFGStateSynchronizeRendering(v5, (uint64_t)v6, v11, v12, v13, v14, v15, v16);
  }
  unint64_t v17 = copy_clip_path(a1, &v33);
  if (a2 == 2)
  {
    long long v18 = *(CGContext **)(a1 + 88);
    CGPathDrawingMode v19 = kCGPathStroke;
    goto LABEL_26;
  }
  memset(&rect, 0, sizeof(rect));
  if (CGPathIsRect(*(CGPathRef *)(*(void *)(a1 + 88) + 168), &rect))
  {
    double width = rect.size.width;
    double height = rect.size.height;
LABEL_20:
    if (height * width / (*(double *)(a1 + 152) * *(double *)(a1 + 160)) >= 0.98)
    {
      uint64_t v24 = CGPDFGStateGetFillColor(*(void *)(a1 + 32));
      if (v24)
      {
        long long v25 = (const void *)v24;
        long long v26 = *(const void **)(a1 + 128);
        if (v26) {
          CFRelease(v26);
        }
        CFRetain(v25);
        *(void *)(a1 + 128) = v25;
      }
    }
    goto LABEL_25;
  }
  if (*(void *)(a1 + 168) == 4)
  {
    *(CGRect *)(&width - 2) = CGPathGetBoundingBox((CGPathRef)*(void *)(*(void *)(a1 + 88) + 168));
    rect.origin.CGFloat x = v22;
    rect.origin.CGFloat y = v23;
    rect.size.double width = width;
    rect.size.double height = height;
    goto LABEL_20;
  }
LABEL_25:
  long long v18 = *(CGContext **)(a1 + 88);
  CGPathDrawingMode v19 = a2;
LABEL_26:
  CGContextDrawPath(v18, v19);
  *(void *)(a1 + 168) = 0;
  if (v17)
  {
    CGContextAddPath(*(CGContextRef *)(a1 + 88), v17);
    clip(*(void *)(a1 + 88), v33, v27, v28, v29, v30, v31, v32);
    CFRelease(v17);
  }
}

void CGContextSetAlpha(CGContextRef c, CGFloat alpha)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    double v8 = 1.0;
    if (alpha <= 1.0) {
      double v8 = alpha;
    }
    if (alpha >= 0.0) {
      double v9 = v8;
    }
    else {
      double v9 = 0.0;
    }
    uint64_t v10 = *((void *)c + 12);
    if (*(double *)(*(void *)(v10 + 120) + 8) != v9)
    {
      maybeCopyRenderingState(*((void *)c + 12));
      *(double *)(*(void *)(v10 + 120) + 8) = v9;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetAlpha", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

void CGContextSetShadowWithColor(CGContextRef c, CGSize offset, CGFloat blur, CGColorRef color)
{
  v29[0] = 0;
  v29[1] = 0x4046800000000000;
  v29[3] = 0x3FE5555555555555;
  v29[6] = 0x3FF0000000000000;
  if (color
    && ((height = offset.height, CGFloat width = offset.width, ((unint64_t)color & 0x8000000000000000) == 0)
      ? (double Alpha = *((double *)color + *((void *)color + 7) + 7))
      : (double Alpha = CGTaggedColorGetAlpha((unint64_t)color, (uint64_t)color, v4, v5, v6, v7, v8, v9)),
        Alpha != 0.0))
  {
    if (fabs(width) != INFINITY && fabs(height) != INFINITY)
    {
      *(double *)&void v29[2] = atan2(height, width) * 180.0 / 3.14159265 + 180.0;
      v29[4] = sqrt(height * height + width * width);
      *(CGFloat *)&v29[5] = blur;
      ShadowWithColor = (const void *)CGStyleCreateShadowWithColor((uint64_t)v29, (unint64_t)color, v16, v17, v18, v19, v20, v21);
      CGContextSetStyle((uint64_t)c, ShadowWithColor, v23, v24, v25, v26, v27, v28);
      if (ShadowWithColor) {
        CFRelease(ShadowWithColor);
      }
    }
  }
  else
  {
    CGContextSetStyle((uint64_t)c, 0, v4, v5, v6, v7, v8, v9);
  }
}

void CGContextSetStyle(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetStyle(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetStyle", v8, a3, a4, a5, a6, a7, a8);
}

uint64_t CGPDFGStateGetFillColor(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeRef result = *(void *)(result + 56);
    if (!result)
    {
      DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
      *(void *)(v1 + 56) = CGColorSpaceCopyDefaultColor((uint64_t)DeviceGray);
      CGColorSpaceRelease(DeviceGray);
      return *(void *)(v1 + 56);
    }
  }
  return result;
}

double CGClipGetBounds(uint64_t a1)
{
  double v1 = -8.98846567e307;
  double result = -8.98846567e307;
  switch(*(unsigned char *)(a1 + 8))
  {
    case 0:
      double result = *(double *)(a1 + 24);
      break;
    case 1:
      return result;
    case 2:
      *(void *)&double result = (unint64_t)CGPathGetBoundingBox((CGPathRef)*(void *)(a1 + 24));
      break;
    case 3:
      double result = CGClipMaskGetBounds(*(void *)(a1 + 24));
      break;
    case 4:
      double v1 = INFINITY;
      if (*(void *)(a1 + 24)) {
        double v1 = -8.98846567e307;
      }
      goto LABEL_7;
    default:
LABEL_7:
      double result = v1;
      break;
  }
  return result;
}

CGRect CGPathGetBoundingBox(CGPathRef path)
{
  double v8 = 0.0;
  if (path && (CGPathDisableTypeValidation || (CFTypeID v10 = CFGetTypeID(path), v10 == CGPathGetTypeID())))
  {
    double v11 = CG::Path::bounding_box((CGPathRef)((char *)path + 16), v1, v2, v3, v4, v5, v6, v7);
    double v8 = v14;
  }
  else
  {
    double v12 = INFINITY;
    double v11 = INFINITY;
    double v13 = 0.0;
  }
  double v15 = v8;
  result.size.CGFloat height = v13;
  result.size.CGFloat width = v15;
  result.origin.CGFloat y = v12;
  result.origin.CGFloat x = v11;
  return result;
}

double CG::Path::bounding_box(CG::Path *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double result = INFINITY;
  switch(*(_DWORD *)this)
  {
    case 0:
      return result;
    case 1:
      long long v9 = *(_OWORD *)((char *)this + 24);
      v50[0] = *(_OWORD *)((char *)this + 8);
      v50[1] = v9;
      v50[2] = *(_OWORD *)((char *)this + 40);
      CFTypeID v10 = (CGAffineTransform *)v50;
      goto LABEL_6;
    case 2:
      long long v11 = *(_OWORD *)((char *)this + 24);
      v48[0] = *(_OWORD *)((char *)this + 8);
      v48[1] = v11;
      v48[2] = *(_OWORD *)((char *)this + 40);
      CFTypeID v10 = (CGAffineTransform *)v48;
      goto LABEL_6;
    case 3:
      long long v12 = *(_OWORD *)((char *)this + 24);
      v47[0] = *(_OWORD *)((char *)this + 8);
      v47[1] = v12;
      v47[2] = *(_OWORD *)((char *)this + 40);
      CFTypeID v10 = (CGAffineTransform *)v47;
      goto LABEL_6;
    case 4:
      long long v13 = *(_OWORD *)((char *)this + 24);
      *(_OWORD *)&v49.a = *(_OWORD *)((char *)this + 8);
      *(_OWORD *)&v49.c = v13;
      *(_OWORD *)&v49.tCGFloat x = *(_OWORD *)((char *)this + 40);
      CFTypeID v10 = &v49;
LABEL_6:
      double result = transform_unit_rect(v10);
      break;
    case 5:
      double v14 = *((double *)this + 3);
      double v15 = *((double *)this + 1);
      if (v14 >= v15) {
        double result = *((double *)this + 1);
      }
      else {
        double result = *((double *)this + 3);
      }
      break;
    case 6:
      double v16 = *((double *)this + 1);
      double v17 = *((double *)this + 2);
      double v19 = *((double *)this + 3);
      double v18 = *((double *)this + 4);
      double v20 = *((double *)this + 7);
      double v21 = *((double *)this + 8);
      double v22 = *((double *)this + 9);
      if (v20 >= 1.57079633)
      {
        double v33 = *((double *)this + 2);
        double v25 = *((double *)this + 1);
        double v34 = v33;
        double v35 = v25;
        do
        {
          double v23 = v19;
          double v36 = v18;
          double v24 = v22;
          double v37 = v35 + v19 * 0.55228475;
          if (v25 <= v37) {
            double v38 = v25;
          }
          else {
            double v38 = v35 + v19 * 0.55228475;
          }
          if (v16 < v37) {
            double v16 = v35 + v19 * 0.55228475;
          }
          double v39 = v34 + v36 * 0.55228475;
          if (v33 > v39) {
            double v33 = v34 + v36 * 0.55228475;
          }
          if (v17 < v39) {
            double v17 = v34 + v36 * 0.55228475;
          }
          double v40 = v19 + v35 * 0.55228475;
          if (v38 > v40) {
            double v38 = v19 + v35 * 0.55228475;
          }
          if (v16 < v40) {
            double v16 = v19 + v35 * 0.55228475;
          }
          double v41 = v36 + v34 * 0.55228475;
          if (v33 > v41) {
            double v33 = v36 + v34 * 0.55228475;
          }
          if (v17 < v41) {
            double v17 = v36 + v34 * 0.55228475;
          }
          if (v38 <= v19) {
            double v25 = v38;
          }
          else {
            double v25 = v19;
          }
          if (v16 < v19) {
            double v16 = v19;
          }
          if (v33 > v36) {
            double v33 = v36;
          }
          if (v17 < v36) {
            double v17 = v36;
          }
          double v19 = -v35;
          double v18 = -v34;
          double v22 = -v21;
          double v20 = v20 + -1.57079633;
          double v21 = v24;
          double v34 = v36;
          double v35 = v23;
        }
        while (v20 >= 1.57079633);
      }
      else
      {
        double v23 = *((double *)this + 1);
        double v24 = *((double *)this + 8);
        double v25 = v23;
      }
      if (v20 > 0.00000001)
      {
        double v42 = *((double *)this + 10);
        double v43 = v24 + v42 * v22;
        double v44 = v22 - v42 * v24;
        double v45 = v23 + v42 * v19;
        if (v25 > v45) {
          double v25 = v23 + v42 * v19;
        }
        if (v25 > v19 * v44 + v43 * v23) {
          double v25 = v19 * v44 + v43 * v23;
        }
        double v46 = v19 * v22 + v24 * v23;
        if (v25 > v46) {
          double v25 = v46;
        }
      }
      double result = v25 + *((double *)this + 5);
      break;
    case 7:
      double result = CGRegionGetBoundingBox(*((void *)this + 1));
      break;
    case 8:
      uint64_t v26 = *((unsigned __int16 *)this + 4);
      if (*((_WORD *)this + 4))
      {
        uint64_t v27 = (double *)((char *)this + 24);
        double v28 = INFINITY;
        double v29 = -INFINITY;
        double v30 = -INFINITY;
        double result = INFINITY;
        do
        {
          double v31 = *(v27 - 1);
          double v32 = *v27;
          if (v31 < result) {
            double result = *(v27 - 1);
          }
          if (v32 < v28) {
            double v28 = *v27;
          }
          if (v30 < v31) {
            double v30 = *(v27 - 1);
          }
          if (v29 < v32) {
            double v29 = *v27;
          }
          v27 += 2;
          --v26;
        }
        while (v26);
      }
      else
      {
        double result = INFINITY;
      }
      break;
    case 9:
      double result = *((double *)this + 5);
      break;
    default:
      _CGHandleAssert("bounding_box", 1633, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Paths/path.cc", "false", "unhandled path type %d", a6, a7, a8, *(_DWORD *)this);
  }
  return result;
}

void clip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      long long v9 = *(const CGPath **)(a1 + 168);
      if (v9 && (int v10 = a2, !CGPathIsEmpty(v9)))
      {
        CGGStateClipToOwnedPath(*(uint64_t **)(a1 + 96), *(CGPathRef *)(a1 + 168), v10);
        *(void *)(a1 + 168) = 0;
      }
      else
      {
        CGPostError((uint64_t)"%s: empty path.", a2, a3, a4, a5, a6, a7, a8, (char)"clip");
      }
      return;
    }
    uint64_t v11 = a1;
  }
  else
  {
    uint64_t v11 = 0;
  }

  handle_invalid_context((char)"clip", v11, a3, a4, a5, a6, a7, a8);
}

void CGGStateClipToOwnedPath(uint64_t *a1, CGPathRef path, int a3)
{
  if (!path) {
    return;
  }
  __int16 v3 = a3;
  if (a3 == 2)
  {
    uint64_t v6 = CGClipStrokeCreateWithGState((uint64_t)a1);
    if (v6)
    {
      uint64_t v7 = v6;
      char v8 = v6[67];
      long long v9 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
      if (v9)
      {
        int v10 = v9;
        *(_DWORD *)long long v9 = 1;
        *((_DWORD *)v9 + 1) = atomic_fetch_add_explicit(CGClipCreate_identifier, 1u, memory_order_relaxed) + 1;
        *((_WORD *)v9 + 4) = 514;
        v9[10] = v8;
        *((void *)v9 + 4) = *((void *)v7 + 11);
        *((void *)v9 + 2) = v7;
        *((void *)v9 + 3) = path;
LABEL_12:
        maybeCopyClipState((uint64_t)a1);
        CGClipStackAddClip(a1[14], (uint64_t)v10);
        CGClipRelease(v10);
        return;
      }
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a1[18] + 8);
    int v12 = *(_DWORD *)(a1[15] + 4);
    memset(&v14, 0, sizeof(v14));
    if (CGPathIsRect(path, &v14))
    {
      CFRelease(path);
      int v10 = (char *)CGClipCreateWithRect(0, HIBYTE(v12) & 1, v14.origin.x, v14.origin.y, v14.size.width, v14.size.height);
      if (v10) {
        goto LABEL_12;
      }
    }
    else
    {
      long long v13 = (char *)CGClipCreate(v3, HIBYTE(v12) & 1);
      if (v13)
      {
        int v10 = v13;
        *((void *)v13 + 4) = v11;
        *((void *)v13 + 3) = path;
        goto LABEL_12;
      }
    }
  }

  CFRelease(path);
}

uint64_t CG::Path::is_rect(CG::Path *this, CGRect *a2, CGAffineTransform *a3)
{
  if (*(_DWORD *)this == 8)
  {
    int v6 = *((_DWORD *)this + 3);
    if (v6 == 135752 || v6 == 16968)
    {
      uint64_t v8 = *((unsigned __int16 *)this + 4);
      if (!*((_WORD *)this + 4))
      {
        double v13 = -INFINITY;
        double v14 = INFINITY;
        double v10 = INFINITY;
        double v11 = -INFINITY;
LABEL_53:
        if (a2)
        {
          a2->origin.CGFloat x = v14;
          a2->origin.CGFloat y = v10;
          a2->size.CGFloat width = v13 - v14;
          a2->size.CGFloat height = v11 - v10;
        }
        if (a3) {
          *a3 = CGAffineTransformIdentity;
        }
        return 1;
      }
      long long v9 = (double *)((char *)this + 24);
      double v10 = INFINITY;
      double v11 = -INFINITY;
      uint64_t v12 = *((unsigned __int16 *)this + 4);
      double v13 = -INFINITY;
      double v14 = INFINITY;
      do
      {
        double v15 = *(v9 - 1);
        double v16 = *v9;
        if (v15 < v14) {
          double v14 = *(v9 - 1);
        }
        if (v16 < v10) {
          double v10 = *v9;
        }
        if (v13 < v15) {
          double v13 = *(v9 - 1);
        }
        if (v11 < v16) {
          double v11 = *v9;
        }
        v9 += 2;
        --v12;
      }
      while (v12);
      double v17 = (double *)((char *)this + 24);
      uint64_t v18 = *((unsigned __int16 *)this + 4);
      while (1)
      {
        double v19 = *(v17 - 1);
        if (v19 != v14 && v19 != v13) {
          break;
        }
        if (*v17 != v10 && *v17 != v11) {
          break;
        }
        v17 += 2;
        if (!--v18)
        {
          if (v8 >= 2)
          {
            uint64_t v22 = 0;
            BOOL v23 = 0;
            BOOL v24 = 0;
            double v25 = *((double *)this + 2);
            double v26 = *((double *)this + 3);
            uint64_t v27 = 16 * v8 - 16;
            while (1)
            {
              double v28 = *(double *)((char *)this + v22 + 32);
              double v29 = *(double *)((char *)this + v22 + 40);
              if (v22 == 64)
              {
                if (v28 != v25 || v29 != v26) {
                  return 0;
                }
              }
              else
              {
                uint64_t v31 = 0;
                if ((v28 != v25) == (v29 != v26) || v24 && v28 != v25 || v23 && v29 != v26) {
                  return v31;
                }
                BOOL v24 = v28 != v25;
                BOOL v23 = v29 != v26;
              }
              v22 += 16;
              double v26 = v29;
              double v25 = v28;
              if (v27 == v22) {
                goto LABEL_53;
              }
            }
          }
          goto LABEL_53;
        }
      }
    }
  }
  else if (*(_DWORD *)this == 1)
  {
    if (a3)
    {
      if (a2) {
        *a2 = unit_rect;
      }
      long long v4 = *(_OWORD *)((char *)this + 8);
      long long v5 = *(_OWORD *)((char *)this + 40);
      *(_OWORD *)&a3->c = *(_OWORD *)((char *)this + 24);
      *(_OWORD *)&a3->tCGFloat x = v5;
      *(_OWORD *)&a3->a = v4;
      return 1;
    }
    double v32 = *((double *)this + 1);
    double v33 = *((double *)this + 2);
    double v34 = *((double *)this + 3);
    if (v33 == 0.0 && v34 == 0.0)
    {
      double v35 = *((double *)this + 4);
    }
    else
    {
      if (v32 != 0.0) {
        return 0;
      }
      double v35 = *((double *)this + 4);
      if (v35 != 0.0) {
        return 0;
      }
    }
    if (v32 * v35 - v33 * v34 >= 0.0)
    {
      if (a2)
      {
        long long v36 = *(_OWORD *)((char *)this + 24);
        *(_OWORD *)&v41.a = *(_OWORD *)((char *)this + 8);
        *(_OWORD *)&v41.c = v36;
        *(_OWORD *)&v41.tCGFloat x = *(_OWORD *)((char *)this + 40);
        a2->origin.CGFloat x = transform_unit_rect(&v41);
        a2->origin.CGFloat y = v37;
        a2->size.CGFloat width = v38;
        a2->size.CGFloat height = v39;
      }
      return 1;
    }
  }
  return 0;
}

BOOL CGPathIsRect(CGPathRef path, CGRect *rect)
{
  if (!path) {
    return 0;
  }
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v4 = CFGetTypeID(path);
    if (v4 != CGPathGetTypeID()) {
      return 0;
    }
  }

  return CG::Path::is_rect((CGPathRef)((char *)path + 16), rect, 0);
}

void CGClipStackAddClip(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    return;
  }
  if (*(unsigned char *)(a2 + 8))
  {
    uint64_t v5 = *(void *)(a1 + 112);
    uint64_t v4 = *(void *)(a1 + 120);
    if (v4 != v5)
    {
LABEL_16:
      atomic_fetch_add_explicit((atomic_uint *volatile)a2, 1u, memory_order_relaxed);
      if (v5 == 3) {
        uint64_t v14 = a1 + 128;
      }
      else {
        uint64_t v14 = *(void *)(a1 + 128);
      }
      uint64_t v15 = *(void *)(a1 + 120);
      *(void *)(a1 + 120) = v15 + 1;
      *(void *)(v14 + 8 * v15) = a2;
      if (*(unsigned char *)(a2 + 8) == 3) {
        *(_DWORD *)(a1 + 8) |= 1u;
      }
      *(_DWORD *)(a1 + 4) = atomic_fetch_add_explicit(&identifier_22701, 1u, memory_order_relaxed) + 1;
      return;
    }
    uint64_t v5 = 2 * v4 + 3;
    if (v4 == 3)
    {
      int v6 = malloc_type_realloc(0, 8 * v5, 0x7492344AuLL);
      uint64_t v7 = *(void *)(a1 + 120);
      if (v7)
      {
        for (uint64_t i = 0; i != v7; ++i)
          v6[i] = *(void *)(a1 + 128 + 8 * i);
LABEL_15:
        *(void *)(a1 + 128) = v6;
        *(void *)(a1 + 112) = v5;
        goto LABEL_16;
      }
    }
    else
    {
      int v6 = malloc_type_realloc(*(void **)(a1 + 128), 8 * v5, 0x7492344AuLL);
    }
    if (!v6) {
      return;
    }
    goto LABEL_15;
  }
  CGFloat v9 = *(double *)(a2 + 24);
  CGFloat v10 = *(double *)(a2 + 32);
  CGFloat v11 = *(double *)(a2 + 40);
  CGFloat v12 = *(double *)(a2 + 48);
  int v13 = *(unsigned __int8 *)(a2 + 10);

  CGClipStackAddRect(a1, v13, v9, v10, v11, v12);
}

double transform_unit_rect(CGAffineTransform *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  double a = a1->a;
  double b = a1->b;
  double c = a1->c;
  double d = a1->d;
  if (b == 0.0 && c == 0.0)
  {
    double v5 = fmin(a, 0.0);
  }
  else
  {
    double v6 = a + c;
    uint64_t v18 = 0;
    double v19 = a;
    double v20 = c;
    double v21 = a + c;
    double v7 = 0.0;
    uint64_t v8 = 8;
    CGFloat v9 = (double *)&v18;
    do
    {
      if (*(double *)((char *)&v18 + v8) < v7)
      {
        double v7 = *(double *)((char *)&v18 + v8);
        CGFloat v9 = (double *)((char *)&v18 + v8);
      }
      v8 += 8;
    }
    while (v8 != 32);
    double v10 = b + d;
    double v5 = *v9;
    uint64_t v18 = 0;
    double v19 = b;
    double v20 = d;
    double v21 = b + d;
    double v11 = 0.0;
    for (uint64_t i = 8; i != 32; i += 8)
    {
      if (*(double *)((char *)&v18 + i) < v11) {
        double v11 = *(double *)((char *)&v18 + i);
      }
    }
    uint64_t v18 = 0;
    double v19 = a;
    double v20 = c;
    double v13 = 0.0;
    uint64_t v14 = 8;
    double v21 = v6;
    do
    {
      if (v13 < *(double *)((char *)&v18 + v14)) {
        double v13 = *(double *)((char *)&v18 + v14);
      }
      v14 += 8;
    }
    while (v14 != 32);
    uint64_t v18 = 0;
    double v19 = b;
    double v20 = d;
    double v15 = 0.0;
    uint64_t v16 = 8;
    double v21 = v10;
    do
    {
      if (v15 < *(double *)((char *)&v18 + v16)) {
        double v15 = *(double *)((char *)&v18 + v16);
      }
      v16 += 8;
    }
    while (v16 != 32);
  }
  return v5 + a1->tx;
}

_DWORD *CGClipCreate(__int16 a1, char a2)
{
  double result = malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
  if (result)
  {
    *double result = 1;
    result[1] = atomic_fetch_add_explicit(CGClipCreate_identifier, 1u, memory_order_relaxed) + 1;
    *((_WORD *)result + 4) = (a1 << 8) | 2;
    *((void *)result + 2) = 0;
    *((unsigned char *)result + 10) = a2;
  }
  return result;
}

uint64_t CGStyleCreateShadowWithColor(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  components[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t style_with_type = 0;
  if (fabs(*(double *)(a1 + 8)) != INFINITY)
  {
    uint64_t style_with_type = 0;
    if (fabs(*(double *)(a1 + 16)) != INFINITY)
    {
      uint64_t style_with_type = 0;
      if (fabs(*(double *)(a1 + 24)) != INFINITY)
      {
        uint64_t style_with_type = 0;
        if (fabs(*(double *)(a1 + 32)) != INFINITY)
        {
          uint64_t style_with_type = 0;
          if (fabs(*(double *)(a1 + 40)) != INFINITY)
          {
            uint64_t style_with_type = 0;
            if (fabs(*(double *)(a1 + 48)) != INFINITY)
            {
              uint64_t style_with_type = create_style_with_type(1, a2, a3, a4, a5, a6, a7, a8);
              *(_DWORD *)(style_with_type + 32) = 0;
              float64x2_t v11 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
              *(float64x2_t *)(style_with_type + 40) = vmaxnmq_f64(vminnmq_f64(*(float64x2_t *)(a1 + 8), v11), (float64x2_t)vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL));
              float64x2_t v12 = vmaxnmq_f64(vminnmq_f64(*(float64x2_t *)(a1 + 24), (float64x2_t)xmmword_1850CDE90), (float64x2_t)0);
              *(float64x2_t *)(style_with_type + 56) = v12;
              *(float64x2_t *)(style_with_type + 72) = vmaxnmq_f64(vminnmq_f64(*(float64x2_t *)(a1 + 40), v11), (float64x2_t)0);
              if (a2)
              {
                CFRetain((CFTypeRef)a2);
                *(void *)(style_with_type + 24) = a2;
                if ((a2 & 0x8000000000000000) != 0) {
                  double Alpha = CGTaggedColorGetAlpha(a2, v13, v14, v15, v16, v17, v18, v19);
                }
                else {
                  double Alpha = *(double *)(a2 + 8 * *(void *)(a2 + 56) + 56);
                }
                *(double *)(style_with_type + 56) = 1.0 - Alpha;
              }
              else
              {
                memset(components, 0, 24);
                components[3] = 1.0 - v12.f64[0];
                DeviceRGB = CGColorSpaceCreateDeviceRGB();
                *(void *)(style_with_type + 24) = CGColorCreate(DeviceRGB, components);
                CGColorSpaceRelease(DeviceRGB);
              }
            }
          }
        }
      }
    }
  }
  return style_with_type;
}

uint64_t create_style_with_type(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 - 1) > 3) {
    uint64_t v9 = 184;
  }
  else {
    uint64_t v9 = qword_185222468[a1 - 1];
  }
  if (kCGContextStyleContentEnd_block_invoke_once != -1) {
    dispatch_once(&kCGContextStyleContentEnd_block_invoke_once, &__block_literal_global_25_15979);
  }
  uint64_t result = CGTypeCreateInstance(CGStyleGetTypeID_style_type_id, v9, a3, a4, a5, a6, a7, a8);
  *(_DWORD *)(result + 16) = atomic_fetch_add_explicit(identifier_15980, 1u, memory_order_relaxed) + 1;
  *(_DWORD *)(result + 20) = a1;
  return result;
}

void CGPDFGStateSynchronizeRendering(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 184);
    if (v10 <= 0xF) {
      CGContextSetCompositeOperation(a2, dword_18520D68C[v10], a3, a4, a5, a6, a7, a8);
    }
    CGContextSetAlphaIsShape(a2, *(unsigned __int8 *)(a1 + 216), a3, a4, a5, a6, a7, a8);
    CGContextSetSoftMask(a2, *(const void **)(a1 + 192), v11, v12, v13, v14, v15, v16);
    CGContextSetSmoothness(a2, *(double *)(a1 + 256), v17, v18, v19, v20, v21, v22, v23);
    double v30 = *(const void **)(a1 + 264);
  }
  else
  {
    CGContextSetCompositeOperation(a2, 2, a3, a4, a5, a6, a7, a8);
    CGContextSetAlphaIsShape(a2, 0, v31, v32, v33, v34, v35, v36);
    CGContextSetSoftMask(a2, 0, v37, v38, v39, v40, v41, v42);
    CGContextSetSmoothness(a2, 0.0, v43, v44, v45, v46, v47, v48, v49);
    double v30 = 0;
  }

  CGContextSetStyle(a2, v30, v24, v25, v26, v27, v28, v29);
}

void CGGStateSetSoftMask(uint64_t a1, const void *a2)
{
  if (*(const void **)(*(void *)(a1 + 120) + 40) != a2)
  {
    maybeCopyRenderingState(a1);
    uint64_t v4 = *(const void **)(*(void *)(a1 + 120) + 40);
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(*(void *)(a1 + 120) + 40) = a2;
  }
}

void CGContextSetSoftMask(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetSoftMask(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetSoftMask", v8, a3, a4, a5, a6, a7, a8);
}

void CGPDFGStateSynchronizeColorRendering(uint64_t a1, CGContextRef c)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((*(_DWORD *)(a1 + 176) - 1) >= 4) {
      CGColorRenderingIntent v4 = kCGRenderingIntentRelativeColorimetric;
    }
    else {
      CGColorRenderingIntent v4 = *(_DWORD *)(a1 + 176);
    }
    CGContextSetRenderingIntent(c, v4);
    CGContextSetImageRenderingIntent((uint64_t)c, v4, v5, v6, v7, v8, v9, v10);
    CGContextSetFillOverprint((uint64_t)c, *(unsigned __int8 *)(a1 + 217), v11, v12, v13, v14, v15, v16);
    CGContextSetStrokeOverprint((uint64_t)c, *(unsigned __int8 *)(a1 + 218), v17, v18, v19, v20, v21, v22);
    CGContextSetOverprintMode((uint64_t)c, *(_DWORD *)(a1 + 220), v23, v24, v25, v26, v27, v28);
    CGContextSetBlackGeneration((uint64_t)c, *(const void **)(a1 + 224), v29, v30, v31, v32, v33, v34);
    CGContextSetUndercolorRemoval((uint64_t)c, *(const void **)(a1 + 232), v35, v36, v37, v38, v39, v40);
    CFArrayRef v41 = *(const __CFArray **)(a1 + 240);
    if (v41)
    {
      memset(v89, 0, sizeof(v89));
      v92.location = 0;
      v92.length = 4;
      CFArrayGetValues(v41, v92, (const void **)v89);
      uint64_t v49 = 0;
      CFRange v50 = (const double *)MEMORY[0x1E4F1D260];
      int64x2_t v51 = (int64x2_t)vld1q_dup_f64(v50);
      do
      {
        int32x2_t v52 = vmovn_s64(vceqq_s64((int64x2_t)v89[v49], v51));
        if (v52.i8[0]) {
          *(void *)&v89[v49] = 0;
        }
        if (v52.i8[4]) {
          *((void *)&v89[v49] + 1) = 0;
        }
        ++v49;
      }
      while (v49 != 2);
      CGContextSetTransferFunctions((uint64_t)c, v42, v43, v44, v45, v46, v47, v48);
    }
  }
  else
  {
    CGContextSetRenderingIntent(c, kCGRenderingIntentRelativeColorimetric);
    CGContextSetImageRenderingIntent((uint64_t)c, 2, v53, v54, v55, v56, v57, v58);
    CGContextSetFillOverprint((uint64_t)c, 0, v59, v60, v61, v62, v63, v64);
    CGContextSetStrokeOverprint((uint64_t)c, 0, v65, v66, v67, v68, v69, v70);
    CGContextSetOverprintMode((uint64_t)c, 0, v71, v72, v73, v74, v75, v76);
    CGContextSetBlackGeneration((uint64_t)c, 0, v77, v78, v79, v80, v81, v82);
    CGContextSetUndercolorRemoval((uint64_t)c, 0, v83, v84, v85, v86, v87, v88);
  }
}

void CGContextSetUndercolorRemoval(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetUndercolorRemoval(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetUndercolorRemoval", v8, a3, a4, a5, a6, a7, a8);
}

void CGContextSetStrokeOverprint(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      uint64_t v8 = *(void *)(a1 + 96);
      int v9 = a2 != 0;
      if (*(unsigned __int8 *)(*(void *)(v8 + 144) + 25) != v9)
      {
        maybe_copy_device_state(v8);
        *(unsigned char *)(*(void *)(v8 + 144) + 25) = v9;
      }
      return;
    }
    uint64_t v10 = a1;
  }
  else
  {
    uint64_t v10 = 0;
  }

  handle_invalid_context((char)"CGContextSetStrokeOverprint", v10, a3, a4, a5, a6, a7, a8);
}

void CGContextSetSmoothness(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v10 = *(void *)(a1 + 96);
    if (*(double *)(*(void *)(v10 + 144) + 16) != a2)
    {
      maybe_copy_device_state(*(void *)(a1 + 96));
      *(double *)(*(void *)(v10 + 144) + 16) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetSmoothness", a1, a4, a5, a6, a7, a8, a9);
  }
}

void CGContextSetRenderingIntent(CGContextRef c, CGColorRenderingIntent intent)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetRenderingIntent(*((void *)c + 12), intent);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetRenderingIntent", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

void CGContextSetPatternPhase(CGContextRef c, CGSize phase)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    CGFloat height = phase.height;
    CGFloat width = phase.width;
    uint64_t v10 = *((void *)c + 12);
    uint64_t v11 = *(void *)(v10 + 120);
    if (*(double *)(v11 + 24) != phase.width || *(double *)(v11 + 32) != phase.height)
    {
      maybeCopyRenderingState(*((void *)c + 12));
      uint64_t v13 = *(void *)(v10 + 120);
      *(CGFloat *)(v13 + 24) = width;
      *(CGFloat *)(v13 + 32) = height;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetPatternPhase", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

void CGContextSetOverprintMode(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v9 = *(void *)(a1 + 96);
    if (*(_DWORD *)(*(void *)(v9 + 144) + 28) != a2)
    {
      maybe_copy_device_state(*(void *)(a1 + 96));
      *(_DWORD *)(*(void *)(v9 + 144) + 28) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetOverprintMode", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGContextSetImageRenderingIntent(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetImageRenderingIntent(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetImageRenderingIntent", v8, a3, a4, a5, a6, a7, a8);
}

void CGContextSetFillOverprint(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      uint64_t v8 = *(void *)(a1 + 96);
      int v9 = a2 != 0;
      if (*(unsigned __int8 *)(*(void *)(v8 + 144) + 24) != v9)
      {
        maybe_copy_device_state(v8);
        *(unsigned char *)(*(void *)(v8 + 144) + 24) = v9;
      }
      return;
    }
    uint64_t v10 = a1;
  }
  else
  {
    uint64_t v10 = 0;
  }

  handle_invalid_context((char)"CGContextSetFillOverprint", v10, a3, a4, a5, a6, a7, a8);
}

void CGContextSetBlackGeneration(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetBlackGeneration(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetBlackGeneration", v8, a3, a4, a5, a6, a7, a8);
}

void CGContextSetAlphaIsShape(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetAlphaIsShape(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetAlphaIsShape", v8, a3, a4, a5, a6, a7, a8);
}

__CFData *create_mask_from_image(_DWORD *image, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (image)
  {
    unsigned int v9 = image[9];
    if ((v9 & 0x2000000) != 0) {
      _CGHandleAssert("create_mask_from_image", 625, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Context/CGContextPath.c", "CGImageIsMask(image) == false", "image is not a mask", a6, a7, a8, v22);
    }
    unint64_t v10 = *((void *)image + 7);
    int v11 = (v9 >> 26) & 1;
    int v12 = (v9 >> 27) & 1;
  }
  else
  {
    int v11 = 0;
    unint64_t v10 = 0;
    int v12 = 0;
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)image);
  if (ColorSpace && (*(_DWORD *)(*((void *)ColorSpace + 3) + 28) ? (int v14 = 1) : (int v14 = v11), ((v14 | v12) & 1) == 0))
  {
    long long v23 = xmmword_185293280;
    if (image)
    {
      unint64_t v17 = *((void *)image + 5);
      unint64_t v18 = *((void *)image + 6);
      unint64_t v19 = *((void *)image + 8);
      unint64_t v20 = *((void *)image + 9);
    }
    else
    {
      unint64_t v19 = 0;
      unint64_t v17 = 0;
      unint64_t v18 = 0;
      unint64_t v20 = 0;
    }
    DataProviderInternal = CGImageGetDataProviderInternal((char *)image, 0);
    return mask_create(v17, v18, v10, v19, v20, (CGDataProviderRef)DataProviderInternal, (double *)&v23, 1, 4);
  }
  else
  {
    if (get_masking_options_predicate != -1) {
      dispatch_once(&get_masking_options_predicate, &__block_literal_global_14380);
    }
    CFDictionaryRef v15 = (const __CFDictionary *)get_masking_options_options;
    return (__CFData *)CGColorTransformConvertImage(image, 0, v15);
  }
}

atomic_uint *CGClipCreateWithMask(atomic_uint *result, char a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (atomic_uint *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
    if (result)
    {
      *uint64_t result = 1;
      result[1] = atomic_fetch_add_explicit(CGClipCreate_identifier, 1u, memory_order_relaxed) + 1;
      *((_WORD *)result + 4) = 3;
      *((void *)result + 2) = 0;
      *((unsigned char *)result + 10) = a2;
      atomic_fetch_add_explicit(v3, 1u, memory_order_relaxed);
      *((void *)result + 3) = v3;
    }
  }
  return result;
}

void CGPathRandomAccess::clipper_paths_for_subpath_range(CGPathRandomAccess *this, CFRange a2, CGAffineTransform *a3)
{
}

void sub_184C88E8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

uint64_t subdivide_bezier_with_flatness(uint64_t a1, uint64_t a2, double a3, __n128 a4)
{
  float64x2_t v7 = *(float64x2_t *)a1;
  float64x2_t v6 = *(float64x2_t *)(a1 + 16);
  float64x2_t v8 = vsubq_f64(v6, *(float64x2_t *)a1);
  float64x2_t v10 = *(float64x2_t *)(a1 + 32);
  __n128 v9 = *(__n128 *)(a1 + 48);
  float64x2_t v11 = vsubq_f64(v10, v6);
  float64x2_t v12 = vsubq_f64((float64x2_t)v9, v10);
  float64x2_t v13 = vsubq_f64(v11, v8);
  float64x2_t v14 = vsubq_f64(v12, v11);
  float64x2_t v15 = (float64x2_t)vzip2q_s64((int64x2_t)v13, (int64x2_t)v14);
  float64x2_t v16 = (float64x2_t)vzip1q_s64((int64x2_t)v13, (int64x2_t)v14);
  __n128 v17 = (__n128)vmlaq_f64(vmulq_f64(v15, v15), v16, v16);
  if (v17.n128_f64[0] <= v17.n128_f64[1]) {
    v17.n128_f64[0] = v17.n128_f64[1];
  }
  double v18 = a3 * a3;
  double v19 = v17.n128_f64[0] * 9.0 * 0.0625;
  if (v19 > v18)
  {
    float64x2_t v21 = vaddq_f64(v8, v13);
    float64x2_t v22 = vsubq_f64(v14, v13);
    __asm
    {
      FMOV            V5.2D, #3.0
      FMOV            V6.2D, #6.0
    }
    float64x2_t v29 = vmulq_f64(v22, _Q6);
    float64x2_t v30 = vmlaq_f64(v22, _Q5, v21);
    float64x2_t v31 = vmulq_f64(vaddq_f64(v13, v22), _Q6);
    unint64_t v32 = 1;
    __asm
    {
      FMOV            V0.2D, #0.125
      FMOV            V3.2D, #0.25
      FMOV            V4.2D, #0.5
    }
    do
    {
      float64x2_t v29 = vmulq_f64(v29, _Q0);
      float64x2_t v31 = vsubq_f64(vmulq_f64(v31, _Q3), v29);
      float64x2_t v30 = vsubq_f64(vmulq_f64(v30, _Q4), vmulq_f64(v31, _Q4));
      uint64_t v36 = 2 * v32;
      double v19 = v19 * 0.0625;
      if (v19 <= v18) {
        break;
      }
      BOOL v37 = v32 > 0x8000;
      v32 *= 2;
    }
    while (!v37);
    unint64_t v38 = 1;
    float64x2_t v41 = v29;
    do
    {
      float64x2_t v43 = vaddq_f64(v31, v30);
      float64x2_t v44 = vaddq_f64(v30, v7);
      float64x2_t v42 = vaddq_f64(v29, v31);
      (*(void (**)(uint64_t, float64_t, float64_t, double))(a2 + 16))(a2, v44.f64[0], v44.f64[1], 1.0 / (double)(unint64_t)v36 * (double)v38);
      float64x2_t v31 = v42;
      float64x2_t v30 = v43;
      float64x2_t v29 = v41;
      float64x2_t v7 = v44;
      ++v38;
    }
    while (v36 != v38);
    __n128 v9 = *(__n128 *)(a1 + 48);
  }
  uint64_t v39 = *(uint64_t (**)(uint64_t, __n128, __n128, __n128))(a2 + 16);
  a4.n128_u64[0] = v9.n128_u64[1];
  v17.n128_u64[0] = 1.0;

  return v39(a2, v9, a4, v17);
}

void ___ZNK25CGPathRandomAccessSubpath12clipper_pathEm17CGAffineTransformbRNSt3__16vectorIN10ClipperLib8IntPointENS1_9allocatorIS4_EEEE_block_invoke(uint64_t a1, double a2, double a3, double a4)
{
  *(double *)(*(void *)(*(void *)(a1 + 32) + 8) + 48) = (double)*(unint64_t *)(a1 + 40) + a4;
  uint64_t v4 = *(void ***)(a1 + 96);
  int64x2_t v5 = vcvtq_s64_f64(vaddq_f64(*(float64x2_t *)(a1 + 80), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 64), a3), *(float64x2_t *)(a1 + 48), a2)));
  float64x2_t v6 = (int64x2_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  float64x2_t v8 = (int64x2_t *)v4[1];
  unint64_t v7 = (unint64_t)v4[2];
  if ((unint64_t)v8 >= v7)
  {
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (unsigned char *)*v4) >> 4);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0x555555555555555) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)*v4) >> 4);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v15 = 0x555555555555555;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      int64x2_t v25 = v5;
      unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<ClipperLib::IntPoint>>(v15);
      int64x2_t v5 = v25;
    }
    else
    {
      uint64_t v16 = 0;
    }
    __n128 v17 = (int64x2_t *)(v15 + 48 * v12);
    unint64_t v18 = v15 + 48 * v16;
    int64x2_t v20 = *v6;
    int64x2_t v19 = v6[1];
    *__n128 v17 = v5;
    v17[1] = v20;
    v17[2] = v19;
    float64x2_t v11 = v17 + 3;
    float64x2_t v22 = (int64x2_t *)*v4;
    float64x2_t v21 = (int64x2_t *)v4[1];
    if (v21 != *v4)
    {
      do
      {
        int64x2_t v23 = v21[-3];
        int64x2_t v24 = v21[-1];
        v17[-2] = v21[-2];
        v17[-1] = v24;
        v17[-3] = v23;
        v17 -= 3;
        v21 -= 3;
      }
      while (v21 != v22);
      float64x2_t v21 = (int64x2_t *)*v4;
    }
    *uint64_t v4 = v17;
    v4[1] = v11;
    v4[2] = (void *)v18;
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    int64x2_t v10 = *v6;
    int64x2_t v9 = *(int64x2_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 56);
    *float64x2_t v8 = v5;
    v8[1] = v10;
    v8[2] = v9;
    float64x2_t v11 = v8 + 3;
  }
  v4[1] = v11;
}

void *std::vector<std::vector<ClipperLib::IntPoint>>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  uint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    *uint64_t v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  float64x2_t v6 = (void *)*result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<ClipperLib::IntPoint>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void CGPathRandomAccess::add_path(CGPathRandomAccess *this, CGPathRef path, CGAffineTransform *a3, int a4)
{
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x4002000000;
  v20[3] = __Block_byref_object_copy__18;
  v20[4] = __Block_byref_object_dispose__19;
  float64x2_t v21 = 0;
  float64x2_t v22 = 0;
  uint64_t v23 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN18CGPathRandomAccess8add_pathEPK6CGPath17CGAffineTransformb_block_invoke;
  block[3] = &unk_1E529FD70;
  block[4] = v20;
  CGPathApplyWithBlock(path, block);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 3);
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x3802000000;
  v18[3] = __Block_byref_object_copy__21;
  v18[5] = 0;
  v18[6] = 0;
  v18[4] = __Block_byref_object_dispose__22;
  v17[0] = 0;
  v17[1] = v17;
  v17[2] = 0x2000000000;
  v17[3] = 0;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  v12[2] = ___ZN18CGPathRandomAccess8add_pathEPK6CGPath17CGAffineTransformb_block_invoke_23;
  _OWORD v12[3] = &unk_1E529FD98;
  v12[7] = this;
  v12[8] = v8;
  char v16 = a4;
  v12[4] = v17;
  v12[5] = v20;
  v12[6] = v18;
  long long v9 = *(_OWORD *)&a3->a;
  long long v10 = *(_OWORD *)&a3->c;
  long long v15 = *(_OWORD *)&a3->tx;
  long long v14 = v10;
  long long v13 = v9;
  CGPathApplyWithBlock(path, v12);
  uint64_t v11 = *((void *)this + 1);
  if (0x6DB6DB6DB6DB6DB7 * ((v11 - *(void *)this) >> 3) > v8 && a4)
  {
    if (*(void *)this == v11)
    {
      __break(1u);
      return;
    }
    CGPathRandomAccessSubpath::close_if_needed((CGPathRandomAccessSubpath *)(v11 - 56));
  }
  _Block_object_dispose(v17, 8);
  _Block_object_dispose(v18, 8);
  _Block_object_dispose(v20, 8);
  if (v21)
  {
    float64x2_t v22 = v21;
    operator delete(v21);
  }
}

void sub_184C894F4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  uint64_t v3 = *(void **)(v1 - 104);
  if (v3)
  {
    *(void *)(v1 - 96) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(a1);
}

void CGPathRandomAccessSubpath::close_if_needed(CGPathRandomAccessSubpath *this)
{
  uint64_t v1 = *(void *)this;
  unint64_t v2 = *((void *)this + 1);
  uint64_t v3 = v2 - *(void *)this;
  if ((unint64_t)v3 >= 0x20)
  {
    if (v1 == v2) {
      goto LABEL_24;
    }
    long long v5 = (double *)*((void *)this + 3);
    float64x2_t v6 = (double *)*((void *)this + 4);
    uint64_t v7 = (((char *)v6 - (char *)v5) >> 4) - 1;
    if (*(void *)(v2 - 16) == v7) {
      return;
    }
    if (v5 == v6)
    {
LABEL_24:
      __break(1u);
      goto LABEL_25;
    }
    if (*(v6 - 2) != *v5 || *(v6 - 1) != v5[1])
    {
      unint64_t v9 = *((void *)this + 2);
      if (v2 < v9)
      {
        *(void *)unint64_t v2 = v7;
        *(unsigned char *)(v2 + 8) = 0;
        long long v10 = (char *)(v2 + 16);
LABEL_22:
        *((void *)this + 1) = v10;
        return;
      }
      uint64_t v11 = v3 >> 4;
      unint64_t v12 = (v3 >> 4) + 1;
      if (!(v12 >> 60))
      {
        uint64_t v13 = v9 - v1;
        if (v13 >> 3 > v12) {
          unint64_t v12 = v13 >> 3;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        long long v15 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v14);
        char v16 = &v15[16 * v11];
        unint64_t v18 = &v15[16 * v17];
        *(void *)char v16 = v7;
        v16[8] = 0;
        long long v10 = v16 + 16;
        int64x2_t v20 = *(unsigned char **)this;
        int64x2_t v19 = (unsigned char *)*((void *)this + 1);
        if (v19 != *(unsigned char **)this)
        {
          do
          {
            uint64_t v21 = *((void *)v19 - 2);
            v19 -= 16;
            char v22 = v19[8];
            *((void *)v16 - 2) = v21;
            v16 -= 16;
            v16[8] = v22;
          }
          while (v19 != v20);
          int64x2_t v19 = *(unsigned char **)this;
        }
        *(void *)this = v16;
        *((void *)this + 1) = v10;
        *((void *)this + 2) = v18;
        if (v19) {
          operator delete(v19);
        }
        goto LABEL_22;
      }
LABEL_25:
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
  }
}

uint64_t ClipperLib::ClipperBase::AddPaths(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, v4 + v9, a3, a4);
      ++v10;
      uint64_t v4 = *a2;
      v9 += 24;
    }
    while (v10 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
  return result;
}

void std::vector<ClipperLib::IntPoint>::reserve(void **a1, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) < a2)
  {
    uint64_t v3 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 48;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<ClipperLib::IntPoint>>(a2);
    long long v5 = &v4[48 * v3];
    uint64_t v7 = &v4[48 * v6];
    uint64_t v9 = (char *)*a1;
    uint64_t v8 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        long long v11 = *((_OWORD *)v8 - 3);
        long long v12 = *((_OWORD *)v8 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v8 - 2);
        *((_OWORD *)v10 - 1) = v12;
        *((_OWORD *)v10 - 3) = v11;
        v10 -= 48;
        v8 -= 48;
      }
      while (v8 != v9);
      uint64_t v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void ClipperLib::ClipperBase::~ClipperBase(ClipperLib::ClipperBase *this)
{
  *(void *)this = &unk_1ED094500;
  ClipperLib::ClipperBase::Clear(this);
  unint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    *((void *)this + 15) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 10);
  if (v3)
  {
    *((void *)this + 11) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 6);
  if (v4)
  {
    *((void *)this + 7) = v4;
    operator delete(v4);
  }
  long long v5 = (void *)*((void *)this + 2);
  if (v5)
  {
    *((void *)this + 3) = v5;
    operator delete(v5);
  }
}

{
  uint64_t vars8;

  ClipperLib::ClipperBase::~ClipperBase(this);

  JUMPOUT(0x18532A2A0);
}

void *ClipperLib::ClipperBase::Clear(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[2];
  this[3] = v2;
  this[1] = v2;
  uint64_t v4 = this[6];
  uint64_t v3 = this[7];
  if (v3 == v4)
  {
    uint64_t v4 = this[7];
  }
  else
  {
    unint64_t v5 = 0;
    do
    {
      this = *(void **)(v4 + 8 * v5);
      if (this)
      {
        this = (void *)MEMORY[0x18532A280](this, 0x1020C80638A78CFLL);
        uint64_t v4 = v1[6];
        uint64_t v3 = v1[7];
      }
      ++v5;
    }
    while (v5 < (v3 - v4) >> 3);
  }
  v1[7] = v4;
  *((unsigned char *)v1 + 40) = 0;
  *((unsigned char *)v1 + 73) = 0;
  return this;
}

uint64_t ClipperLib::ClipperBase::DisposeAllOutRecs(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 80);
  uint64_t v3 = *(void *)(this + 88);
  if (v3 == v2)
  {
    uint64_t v2 = *(void *)(this + 88);
LABEL_10:
    *(void *)(v1 + 88) = v2;
  }
  else
  {
    unint64_t v4 = 0;
    while (v4 < (v3 - v2) >> 3)
    {
      uint64_t v5 = *(void *)(v2 + 8 * v4);
      if (*(void *)(v5 + 24)) {
        ClipperLib::DisposeOutPts((void *)(v5 + 24));
      }
      this = MEMORY[0x18532A2A0](v5, 0x1020C401FC46325);
      uint64_t v6 = *(void *)(v1 + 80);
      if (v4 >= (*(void *)(v1 + 88) - v6) >> 3) {
        break;
      }
      *(void *)(v6 + 8 * v4++) = 0;
      uint64_t v2 = *(void *)(v1 + 80);
      uint64_t v3 = *(void *)(v1 + 88);
      if (v4 >= (v3 - v2) >> 3) {
        goto LABEL_10;
      }
    }
    __break(1u);
  }
  return this;
}

void *ClipperLib::DisposeOutPts(void *result)
{
  if (*result)
  {
    uint64_t v1 = (void **)result;
    *(void *)(*(void *)(*result + 64) + 56) = 0;
    while (1)
    {
      uint64_t result = *v1;
      if (!*v1) {
        break;
      }
      *uint64_t v1 = (void *)result[7];
      MEMORY[0x18532A2A0]();
    }
  }
  return result;
}

double transform_for_bounds(CGRect a1, uint64_t a2)
{
  CGRect v14 = CGRectIntegral(a1);
  CGFloat x = v14.origin.x;
  double y = v14.origin.y;
  CGFloat width = v14.size.width;
  double height = v14.size.height;
  if (v14.size.width < 0.0 || v14.size.height < 0.0)
  {
    CGRect v15 = CGRectStandardize(v14);
    double v9 = v15.size.width;
    v15.origin.CGFloat x = x;
    v15.origin.double y = y;
    v15.size.CGFloat width = width;
    v15.size.double height = height;
    CGRect v16 = CGRectStandardize(v15);
    double v10 = v16.size.height;
    v16.origin.CGFloat x = x;
    v16.origin.double y = y;
    v16.size.CGFloat width = width;
    v16.size.double height = height;
    CGRect v17 = CGRectStandardize(v16);
    double v8 = v17.origin.x;
    double v7 = v17.size.width;
    v17.origin.CGFloat x = x;
    v17.origin.double y = y;
    v17.size.CGFloat width = width;
    v17.size.double height = height;
    CGRect v18 = CGRectStandardize(v17);
    double y = v18.origin.y;
    double height = v18.size.height;
  }
  else
  {
    double v7 = v14.size.width;
    double v8 = v14.origin.x;
    double v9 = v14.size.width;
    double v10 = v14.size.height;
  }
  double v11 = fabs(v10);
  double v12 = fabs(v9);
  if (v12 <= v11) {
    double v12 = v11;
  }
  *(double *)a2 = 1063256060.0 / v12;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  double result = -(1063256060.0 / v12 * (y + height * 0.5));
  *(double *)(a2 + 24) = 1063256060.0 / v12;
  *(double *)(a2 + 32) = -(1063256060.0 / v12 * (v8 + v7 * 0.5));
  *(double *)(a2 + 40) = result;
  return result;
}

double CGClipMaskGetBounds(uint64_t a1)
{
  if (!a1) {
    return INFINITY;
  }
  CGRect v4 = *(CGRect *)(a1 + 64);
  long long v1 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&v3.double a = *(_OWORD *)(a1 + 8);
  *(_OWORD *)&v3.double c = v1;
  *(_OWORD *)&v3.tCGFloat x = *(_OWORD *)(a1 + 40);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v4, &v3);
  return result;
}

void CGContextSetFillColor(CGContextRef c, const CGFloat *components)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    if (components)
    {
      set_fill_color_with_components((uint64_t *)c, 0, components, v2, v3, v4, v5, v6, v8);
    }
    else
    {
      CGPostError((uint64_t)"%s: components may not be NULL.", (uint64_t)c, 0, v2, v3, v4, v5, v6, (char)"CGContextSetFillColor");
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFillColor", (uint64_t)c, (uint64_t)components, v2, v3, v4, v5, v6);
  }
}

void style_finalize(uint64_t a1)
{
  long long v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void CGContextShowGlyphsAtPositions(CGContextRef c, const CGGlyph *glyphs, const CGPoint *Lpositions, size_t count)
{
  if (!c)
  {
    CGContextRef v14 = 0;
LABEL_13:
    handle_invalid_context((char)"CGContextShowGlyphsAtPositions", (uint64_t)v14, (uint64_t)Lpositions, count, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v14 = c;
    goto LABEL_13;
  }
  if (glyphs)
  {
    if (Lpositions)
    {
      if (count)
      {
        uint64_t v12 = *(void *)(*((void *)c + 12) + 136);
        if (*(void *)(v12 + 8))
        {
          if (*(double *)(v12 + 16) != 0.0)
          {
            unsigned int v13 = *(char *)(v12 + 1);
            if (v13 < 4)
            {
              draw_glyphs_18654((uint64_t)c, (uint64_t)glyphs, (uint64_t)Lpositions, count);
            }
            else
            {
              if (v13 - 4 >= 3)
              {
                if (v13 != 7) {
                  return;
                }
              }
              else
              {
                draw_glyphs_18654((uint64_t)c, (uint64_t)glyphs, (uint64_t)Lpositions, count);
              }
              clip_to_glyphs((uint64_t)c, (__int16 *)glyphs, (long long *)Lpositions, count);
            }
          }
        }
      }
    }
  }
}

os_unfair_lock_s *CGFontNameTableCreate(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x58uLL, 0x1070040B6466AE1uLL);
  *uint64_t v2 = a1;
  v2[5] = 0;
  *((_DWORD *)v2 + 12) = 0;
  uint64_t v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  v2[7] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((_DWORD *)v2 + 16) = 0;
  v2[9] = CFDictionaryCreateMutable(0, 0, 0, v3);
  *((_DWORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 8) = (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 216))(*(void *)(a1 + 112));
  v2[2] = 0;
  int64x2_t v51 = (os_unfair_lock_s *)v2;
  int32x2_t v52 = v2 + 2;
  v2[3] = 0;
  if (*v2)
  {
    theunint64_t Data = (const __CFData *)(*(uint64_t (**)(void, uint64_t))(*(void *)(*v2 + 16) + 424))(*(void *)(*v2 + 112), 1851878757);
    if (theData)
    {
      BytePtr = CFDataGetBytePtr(theData);
      unint64_t Length = CFDataGetLength(theData);
      uint64_t v6 = 2 * (Length > 1);
      unint64_t v7 = (v6 + 2);
      if (Length >= v7)
      {
        unsigned int v8 = BytePtr[v6 | 1] | (BytePtr[v6] << 8);
        unint64_t v7 = v6 | 4;
        int v9 = v6 | 4;
        LODWORD(v6) = v6 + 2;
      }
      else
      {
        unsigned int v8 = 0;
        int v9 = v6 + 2;
      }
      if (Length >= v7)
      {
        uint64_t v10 = bswap32(*(unsigned __int16 *)&BytePtr[v6]) >> 16;
        LODWORD(v6) = v9;
      }
      else
      {
        uint64_t v10 = 0;
        unint64_t v7 = v6;
      }
      if (v7 + 12 * v8 == v10)
      {
        for (; v8; --v8)
        {
          unint64_t v11 = (v6 + 2);
          int v12 = v6 + 2;
          if (Length >= v11)
          {
            __int16 v55 = BytePtr[(v6 + 1)] | (BytePtr[v6] << 8);
            unint64_t v11 = (v6 + 4);
            LODWORD(v6) = v6 + 2;
            int v12 = v11;
          }
          else
          {
            __int16 v55 = 0;
          }
          if (v11 <= Length)
          {
            __int16 v54 = BytePtr[(v6 + 1)] | (BytePtr[v6] << 8);
            unint64_t v11 = (v12 + 2);
            LODWORD(v6) = v12;
            v12 += 2;
          }
          else
          {
            __int16 v54 = 0;
          }
          if (v11 <= Length)
          {
            __int16 v53 = BytePtr[(v6 + 1)] | (BytePtr[v6] << 8);
            unint64_t v11 = (v12 + 2);
            LODWORD(v6) = v12;
            v12 += 2;
          }
          else
          {
            __int16 v53 = 0;
          }
          if (v11 <= Length)
          {
            __int16 v13 = BytePtr[(v6 + 1)] | (BytePtr[v6] << 8);
            unint64_t v11 = (v12 + 2);
            LODWORD(v6) = v12;
            v12 += 2;
          }
          else
          {
            __int16 v13 = 0;
          }
          if (v11 <= Length)
          {
            unsigned __int16 v14 = BytePtr[(v6 + 1)] | (BytePtr[v6] << 8);
            unint64_t v11 = (v12 + 2);
            LODWORD(v6) = v12;
            v12 += 2;
          }
          else
          {
            unsigned __int16 v14 = 0;
          }
          if (v11 <= Length)
          {
            int v15 = BytePtr[(v6 + 1)] | (BytePtr[v6] << 8);
            LODWORD(v6) = v12;
          }
          else
          {
            int v15 = 0;
          }
          unint64_t v16 = (v15 + v10);
          if (Length > v16)
          {
            unsigned __int16 v17 = Length >= v16 + v14 ? v14 : Length - (v15 + v10);
            uint64_t v18 = v10;
            int64x2_t v19 = malloc_type_malloc(v17 + 13, 0x51E4B2E6uLL);
            uint64_t v10 = v18;
            if (v19)
            {
              int64x2_t v20 = v19;
              __CFSetLastAllocationEventName();
              *int64x2_t v20 = v55;
              v20[1] = v54;
              v20[2] = v53;
              v20[3] = v13;
              void v20[5] = v17;
              memcpy(v20 + 6, &BytePtr[v16], v17);
              *((unsigned char *)v20 + v17 + 12) = 0;
              uint64_t v21 = (void *)*v52;
              char v22 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
              if (v22)
              {
                *char v22 = v20;
                v22[1] = v21;
                uint64_t v21 = v22;
              }
              uint64_t v10 = v18;
              void *v52 = v21;
            }
          }
        }
        uint64_t v23 = (void *)*v52;
        if (*v52)
        {
          int64x2_t v24 = 0;
          do
          {
            int64x2_t v25 = v23;
            uint64_t v23 = (void *)v23[1];
            v25[1] = v24;
            int64x2_t v24 = v25;
          }
          while (v23);
        }
        else
        {
          int64x2_t v25 = 0;
        }
        void *v52 = v25;
        CFRelease(theData);
      }
    }
  }
  uint64_t v26 = v51;
  *(void *)&v51[6]._os_unfair_lock_opaque = 0;
  add_localized_names(v51, 1, 0xFFFF);
  add_localized_names(v51, 1, 0);
  add_localized_names(v51, 0, 0xFFFF);
  add_localized_names(v51, 3, 0xFFFF);
  add_localized_names(v51, 3, 9);
  add_localized_names(v51, 3, 1033);
  CFLocaleRef System = CFLocaleGetSystem();
  CFDictionaryRef dictionary_for_locale = (const __CFDictionary *)get_dictionary_for_locale((uint64_t)v51, System);
  CFTypeRef cf = 0;
  add_root_name((uint64_t)v51, dictionary_for_locale, (const __CFDictionary **)&cf, @"kCGFontNameKeyFullName", (void *)4, 1);
  add_root_name((uint64_t)v51, dictionary_for_locale, (const __CFDictionary **)&cf, @"kCGFontNameKeyFontFamily", (void *)1, 1);
  add_root_name((uint64_t)v51, dictionary_for_locale, (const __CFDictionary **)&cf, @"kCGFontNameKeyCopyright", 0, 0);
  add_root_name((uint64_t)v51, dictionary_for_locale, (const __CFDictionary **)&cf, @"kCGFontNameKeyFontSubfamily", (void *)2, 0);
  add_root_name((uint64_t)v51, dictionary_for_locale, (const __CFDictionary **)&cf, @"kCGFontNameKeyUniqueID", (void *)3, 0);
  add_root_name((uint64_t)v51, dictionary_for_locale, (const __CFDictionary **)&cf, @"kCGFontNameKeyVersion", (void *)5, 0);
  add_root_name((uint64_t)v51, dictionary_for_locale, (const __CFDictionary **)&cf, @"kCGFontNameKeyTrademark", (void *)7, 0);
  if (cf) {
    CFRelease(cf);
  }
  CFLocaleRef v29 = CFLocaleGetSystem();
  float64x2_t v30 = (__CFDictionary *)get_dictionary_for_locale((uint64_t)v51, v29);
  if (!v30) {
    goto LABEL_77;
  }
  float64x2_t v31 = v30;
  unint64_t v32 = (const char *)(*(uint64_t (**)(void))(*(void *)(*(void *)&v51->_os_unfair_lock_opaque + 16)
                                                        + 144))(*(void *)(*(void *)&v51->_os_unfair_lock_opaque
                                                                            + 112));
  if (!v32 || (CFStringRef v33 = CFStringCreateWithCString(0, v32, 0x600u)) == 0)
  {
    uint64_t v34 = *(uint64_t **)&v51[6]._os_unfair_lock_opaque;
    if (!v34) {
      goto LABEL_56;
    }
    while (1)
    {
      if (*(_WORD *)(*v34 + 6) == 6)
      {
        CFStringRef localized_name = create_localized_name(*v34);
        if (localized_name) {
          break;
        }
      }
      uint64_t v34 = (uint64_t *)v34[1];
      if (!v34) {
        goto LABEL_56;
      }
    }
    CFStringRef v33 = localized_name;
  }
  CFDictionarySetValue(v31, (const void *)6, v33);
  CFRelease(v33);
LABEL_56:
  CFLocaleRef v36 = CFLocaleGetSystem();
  CFStringRef v37 = (const __CFString *)copy_localized_value(v51, v36, 6u);
  if (v37)
  {
    CFStringRef v38 = v37;
    CFIndex v39 = CFStringGetLength(v37);
    CFIndex v40 = CFStringGetMaximumSizeForEncoding(v39, 0x600u) + 1;
    float64x2_t v41 = (unsigned __int8 *)malloc_type_malloc(v40, 0xC5FD30C8uLL);
    if (CFStringGetCString(v38, (char *)v41, v40, 0x600u))
    {
      CFRelease(v38);
      unsigned __int8 v42 = *v41;
      if (*v41)
      {
        float64x2_t v43 = v41 + 1;
        do
        {
          unsigned int v44 = (char)v42 - 37;
          if (v44 <= 0x38 && ((1 << v44) & 0x140000002800419) != 0
            || v42 == 123
            || v42 == 125
            || (v42 - 127) <= 0xA1u)
          {
            *(v43 - 1) = 95;
          }
          int v45 = *v43++;
          unsigned __int8 v42 = v45;
        }
        while (v45);
        *(void *)&v51[2]._os_unfair_lock_opaque = v41;
        if (!v41) {
          goto LABEL_77;
        }
        goto LABEL_75;
      }
      free(v41);
    }
    else
    {
      free(v41);
      CFRelease(v38);
    }
  }
  uint64_t v46 = (char *)malloc_type_malloc(0x40uLL, 0x7729603BuLL);
  *(void *)&v51[2]._os_unfair_lock_opaque = v46;
  if (!v46) {
    goto LABEL_77;
  }
  snprintf_l(v46, 0x40uLL, 0, "--unknown-%d--", atomic_fetch_add_explicit(&fixup_ps_name_identifier, 1u, memory_order_relaxed) + 1);
  float64x2_t v41 = *(unsigned __int8 **)&v51[2]._os_unfair_lock_opaque;
  if (!v41) {
    goto LABEL_77;
  }
LABEL_75:
  CFStringRef v47 = CFStringCreateWithCString(0, (const char *)v41, 0x600u);
  if (!v47)
  {
LABEL_77:
    CGFontNameTableRelease((uint64_t)v51);
    return 0;
  }
  CFStringRef v48 = v47;
  CFDictionarySetValue(v31, (const void *)6, v47);
  CFRelease(v48);
  return v26;
}

uint64_t copy_table(uint64_t a1)
{
  return MEMORY[0x1F4119C08](*(void *)(a1 + 8));
}

void add_root_name(uint64_t a1, CFDictionaryRef theDict, const __CFDictionary **a3, void *key, void *a5, char a6)
{
  if (theDict)
  {
    unsigned int v6 = a5;
    if ((a6 & 1) != 0 || !CFDictionaryGetValue(theDict, (const void *)a5))
    {
      CFDictionaryRef v11 = *a3;
      if (*a3
        || (CFDictionaryRef v11 = (const __CFDictionary *)(*(uint64_t (**)(void))(*(void *)(*(void *)a1 + 16) + 184))(*(void *)(*(void *)a1 + 112)),
            (*a3 = v11) != 0))
      {
        CFNumberRef Value = CFDictionaryGetValue(v11, key);
        if (Value)
        {
          CFDictionarySetValue(theDict, (const void *)v6, Value);
        }
      }
    }
  }
}

void *add_localized_names(void *result, int a2, int a3)
{
  uint64_t v3 = result;
  uint64_t v4 = (unsigned __int16 *)result[2];
  if (!v4) {
    goto LABEL_15;
  }
  unint64_t v7 = 0;
  do
  {
    uint64_t v8 = *(void *)v4;
    if (**(unsigned __int16 **)v4 == a2 && (a3 == 0xFFFF || *(unsigned __int16 *)(v8 + 4) == a3))
    {
      double result = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
      if (result)
      {
        *double result = v8;
        result[1] = v7;
        unint64_t v7 = result;
      }
    }
    uint64_t v4 = (unsigned __int16 *)*((void *)v4 + 1);
  }
  while (v4);
  if (v7)
  {
    int v9 = 0;
    do
    {
      uint64_t v10 = v7;
      unint64_t v7 = (void *)v7[1];
      v10[1] = v9;
      int v9 = v10;
    }
    while (v7);
    uint64_t v13 = v3[3];
    int v12 = v3 + 3;
    uint64_t v11 = v13;
    unsigned __int16 v17 = v10;
    do
    {
      unsigned __int16 v14 = v10;
      uint64_t v10 = (void *)v10[1];
    }
    while (v10);
    int v15 = v14 + 1;
  }
  else
  {
LABEL_15:
    uint64_t v16 = v3[3];
    int v12 = v3 + 3;
    uint64_t v11 = v16;
    unsigned __int16 v17 = 0;
    int v15 = &v17;
  }
  *int v15 = v11;
  *int v12 = v17;
  return result;
}

CFTypeRef CGFontNameTableCopyNameForLocaleIdentifier(os_unfair_lock_s *a1, const __CFString *a2, unsigned int a3)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  CFLocaleRef v5 = CFLocaleCreate(0, a2);
  if (!v5) {
    return 0;
  }
  CFLocaleRef v6 = v5;
  CFTypeRef v7 = copy_localized_value(a1, v5, a3);
  CFRelease(v6);
  return v7;
}

CFTypeRef copy_localized_value(os_unfair_lock_s *a1, const void *a2, unsigned int a3)
{
  CFLocaleRef v6 = a1 + 20;
  os_unfair_lock_lock(a1 + 20);
  CFDictionaryRef dictionary_for_locale = (const __CFDictionary *)get_dictionary_for_locale((uint64_t)a1, a2);
  if (!dictionary_for_locale)
  {
    os_unfair_lock_unlock(v6);
    return 0;
  }
  CFDictionaryRef v8 = dictionary_for_locale;
  CFNumberRef Value = CFDictionaryGetValue(dictionary_for_locale, (const void *)a3);
  if (!Value)
  {
    add_sorted_names_with_name_id((uint64_t)a1, a3);
    uint64_t v10 = CFDictionaryGetValue(v8, (const void *)a3);
    os_unfair_lock_unlock(v6);
    if (v10) {
      goto LABEL_6;
    }
    return 0;
  }
  uint64_t v10 = Value;
  os_unfair_lock_unlock(v6);
LABEL_6:

  return CFRetain(v10);
}

void add_sorted_names_with_name_id(uint64_t a1, int a2)
{
  if (a2 != 17)
  {
    if (a2 == 6) {
      return;
    }
    if (a2 != 2) {
      goto LABEL_40;
    }
  }
  int v4 = *(_DWORD *)(a1 + 32);
  if (!v4)
  {
LABEL_40:
    uint64_t v23 = *(uint64_t **)(a1 + 24);
    if (!v23) {
      return;
    }
    while (1)
    {
      int64x2_t v24 = (unsigned __int16 *)*v23;
      if (*(unsigned __int16 *)(*v23 + 6) != a2) {
        goto LABEL_52;
      }
      CFStringRef localized_name = create_localized_name(*v23);
      if (!localized_name) {
        goto LABEL_52;
      }
      CFStringRef v26 = localized_name;
      uint64_t v27 = (const void *)v24[3];
      CFTypeRef locale = create_locale(a1, *v24, v24[2]);
      CFDictionaryRef dictionary_for_locale = (__CFDictionary *)get_dictionary_for_locale(a1, locale);
      if (dictionary_for_locale)
      {
        float64x2_t v30 = dictionary_for_locale;
        do
        {
          CFDictionarySetValue(v30, v27, v26);
          CFTypeRef v31 = CGCreateContainingLocaleForLocale(locale);
          float64x2_t v30 = (__CFDictionary *)get_dictionary_for_locale(a1, v31);
          if (locale) {
            CFRelease(locale);
          }
          if (!v30) {
            break;
          }
          CFTypeRef locale = v31;
        }
        while (!CFDictionaryGetValue(v30, v27));
        if (!v31) {
          goto LABEL_51;
        }
      }
      else
      {
        CFTypeRef v31 = locale;
        if (!locale) {
          goto LABEL_51;
        }
      }
      CFRelease(v31);
LABEL_51:
      CFRelease(v26);
LABEL_52:
      uint64_t v23 = (uint64_t *)v23[1];
      if (!v23) {
        return;
      }
    }
  }
  *(_DWORD *)(a1 + 32) = 0;
  add_sorted_names_with_name_id(a1, (unsigned __int16)v4);
  *(_DWORD *)(a1 + 32) = v4;
  for (uint64_t i = *(uint64_t **)(a1 + 24); i; uint64_t i = (uint64_t *)i[1])
  {
    CFLocaleRef v6 = (unsigned __int16 *)*i;
    int v7 = *(unsigned __int16 *)(*i + 6);
    if (v7 == 17 || v7 == 2)
    {
      CFStringRef v9 = create_localized_name(*i);
      if (v9)
      {
        CFStringRef v10 = v9;
        uint64_t v11 = (const void *)v6[3];
        CFTypeRef v12 = create_locale(a1, *v6, v6[2]);
        CFDictionaryRef v13 = (const __CFDictionary *)get_dictionary_for_locale(a1, v12);
        if (v13)
        {
          CFDictionaryRef v14 = v13;
          while (1)
          {
            if (CFDictionaryGetValue(v14, v11)) {
              goto LABEL_34;
            }
            int v15 = (const void *)*(unsigned int *)(a1 + 32);
            CFTypeRef v16 = CFRetain(v12);
            CFDictionaryRef v17 = (const __CFDictionary *)get_dictionary_for_locale(a1, v16);
            if (v17) {
              break;
            }
LABEL_21:
            if (v16) {
              goto LABEL_22;
            }
LABEL_23:
            if (v17) {
              CFDictionaryRef v20 = v17;
            }
            else {
              CFDictionaryRef v20 = (const __CFDictionary *)v10;
            }
            CFTypeRef v21 = CFRetain(v20);
            CFDictionarySetValue(v14, v11, v21);
            if (v21) {
              CFRelease(v21);
            }
            CFTypeRef v22 = CGCreateContainingLocaleForLocale(v12);
            CFDictionaryRef v14 = (const __CFDictionary *)get_dictionary_for_locale(a1, v22);
            if (v12) {
              CFRelease(v12);
            }
            CFTypeRef v12 = v22;
            if (!v14) {
              goto LABEL_35;
            }
          }
          while (1)
          {
            CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v17, v15);
            if (Value) {
              break;
            }
            CFTypeRef v19 = CGCreateContainingLocaleForLocale(v16);
            CFDictionaryRef v17 = (const __CFDictionary *)get_dictionary_for_locale(a1, v19);
            if (v16) {
              CFRelease(v16);
            }
            CFTypeRef v16 = v19;
            if (!v17)
            {
              CFTypeRef v16 = v19;
              goto LABEL_21;
            }
          }
          CFDictionaryRef v17 = Value;
          if (!v16) {
            goto LABEL_23;
          }
LABEL_22:
          CFRelease(v16);
          goto LABEL_23;
        }
LABEL_34:
        CFTypeRef v22 = v12;
LABEL_35:
        if (v22) {
          CFRelease(v22);
        }
        CFRelease(v10);
      }
    }
  }
}

CFStringRef create_localized_name(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFIndex v1 = *(unsigned __int16 *)(a1 + 10);
  if (!*(_WORD *)(a1 + 10)) {
    return 0;
  }
  if (*(_WORD *)a1 != 1)
  {
    uint64_t v2 = (const UInt8 *)(a1 + 12);
    int v4 = *(unsigned __int8 *)(a1 + 12);
    if (v1 != 1)
    {
      if (*(unsigned char *)(a1 + 12)) {
        goto LABEL_10;
      }
      int v4 = *(unsigned __int8 *)(a1 + 13);
    }
    if (!v4) {
      return 0;
    }
LABEL_10:
    CFStringEncoding v3 = 268435712;
    return CFStringCreateWithBytes(0, v2, v1, v3, 0);
  }
  uint64_t v2 = (const UInt8 *)(a1 + 12);
  if (*(unsigned char *)(a1 + 12))
  {
    CFStringEncoding v3 = *(unsigned __int16 *)(a1 + 2);
    return CFStringCreateWithBytes(0, v2, v1, v3, 0);
  }
  return 0;
}

uint64_t get_variation_name_id(uint64_t a1)
{
  return MEMORY[0x1F4119D00](*(void *)(a1 + 8));
}

uint64_t copy_root_names(uint64_t a1)
{
  return MEMORY[0x1F4119BE0](*(void *)(a1 + 8));
}

void *CGFontGetHMetrics(void *result)
{
  if (result)
  {
    CFIndex v1 = result;
    double result = (void *)atomic_load_explicit(result + 6, memory_order_acquire);
    if (!result)
    {
      double result = get_font_info(v1);
      if (result)
      {
        uint64_t v2 = result;
        double result = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
        uint64_t v4 = 0;
        *double result = *(void *)((char *)v2 + 12);
        int v3 = *((_DWORD *)v2 + 8);
        *((_DWORD *)result + 2) = *((_DWORD *)v2 + 5);
        *((_DWORD *)result + 3) = v3;
        atomic_compare_exchange_strong(v1 + 6, (unint64_t *)&v4, (unint64_t)result);
        if (v4)
        {
          free(result);
          return (void *)v4;
        }
      }
    }
  }
  return result;
}

uint64_t CGGlyphLockGetQuantizationLevel(uint64_t a1, void *a2)
{
  *a2 = *(void *)(*(void *)a1 + 80);
  return 1;
}

CGImageRef CGImageCreateCopy(CGImageRef image)
{
  if (!image) {
    return 0;
  }
  unsigned int v6 = *((_DWORD *)image + 9);
  if ((v6 & 0x2000000) != 0)
  {
    CFStringRef v9 = mask_create(*((void *)image + 5), *((void *)image + 6), *((void *)image + 7), *((void *)image + 8), *((void *)image + 9), *((CGDataProviderRef *)image + 19), *((double **)image + 20), HIBYTE(v6) & 1, 4);
    if (!v9) {
      return v9;
    }
    goto LABEL_35;
  }
  uint64_t v7 = *((void *)image + 26);
  if (v7)
  {
    uint64_t v8 = CGImageCreateWithImageProvider(v7, *((double **)image + 20), HIBYTE(v6) & 1, ((__int16)v6 >> 8), v1, v2, v3, v4);
    CFStringRef v9 = (__CFData *)v8;
    if (!v8) {
      return v9;
    }
    CFStringRef v10 = *(CGColorSpace **)(v8 + 144);
    if (v10 != *((CGColorSpace **)image + 18))
    {
      CGColorSpaceRelease(v10);
      uint64_t v11 = *((void *)image + 18);
      if (v11) {
        CFRetain(*((CFTypeRef *)image + 18));
      }
      *((void *)v9 + 18) = v11;
    }
  }
  else
  {
    CFStringRef v9 = CGImageCreate(*((void *)image + 5), *((void *)image + 6), *((void *)image + 7), *((void *)image + 8), *((void *)image + 9), *((CGColorSpaceRef *)image + 18), *((_DWORD *)image + 8), *((CGDataProviderRef *)image + 19), *((const CGFloat **)image + 20), v6 & 0x1000000, (CGColorRenderingIntent)((__int16)v6 >> 8));
    if (!v9) {
      return v9;
    }
  }
  if (*((void *)image + 21))
  {
    uint64_t v12 = *((void *)v9 + 18);
    if (v12) {
      uint64_t v13 = *(void *)(*(void *)(v12 + 24) + 48);
    }
    else {
      uint64_t v13 = 0;
    }
    CFDictionaryRef v14 = malloc_type_malloc(16 * v13, 0x705560E0uLL);
    *((void *)v9 + 21) = v14;
    if (!v14)
    {
LABEL_38:
      CFRelease(v9);
      return 0;
    }
    uint64_t v15 = 2 * v13;
    if (2 * v13)
    {
      CFTypeRef v16 = (uint64_t *)*((void *)image + 21);
      do
      {
        uint64_t v17 = *v16++;
        *v14++ = v17;
        --v15;
      }
      while (v15);
    }
  }
  *((_DWORD *)v9 + 9) = *((_DWORD *)v9 + 9) & 0xF7FFFFFF | (((*((_DWORD *)image + 9) >> 27) & 1) << 27);
  uint64_t v18 = *((void *)image + 22);
  if (v18) {
    CFRetain(*((CFTypeRef *)image + 22));
  }
  *((void *)v9 + 22) = v18;
  if (!*((void *)image + 23)) {
    goto LABEL_30;
  }
  uint64_t v19 = *((void *)v9 + 18);
  if (v19) {
    uint64_t v20 = *(void *)(*(void *)(v19 + 24) + 48);
  }
  else {
    uint64_t v20 = 0;
  }
  CFTypeRef v21 = malloc_type_malloc(8 * v20, 0x705560E0uLL);
  *((void *)v9 + 23) = v21;
  if (!v21) {
    goto LABEL_38;
  }
  if (v20)
  {
    CFTypeRef v22 = (uint64_t *)*((void *)image + 23);
    do
    {
      uint64_t v23 = *v22++;
      *v21++ = v23;
      --v20;
    }
    while (v20);
  }
LABEL_30:
  uint64_t v24 = *((void *)image + 24);
  if (v24) {
    CFRetain(*((CFTypeRef *)image + 24));
  }
  *((void *)v9 + 24) = v24;
  uint64_t v25 = *((void *)image + 25);
  if (v25) {
    CFRetain(*((CFTypeRef *)image + 25));
  }
  *((void *)v9 + 25) = v25;
LABEL_35:
  uint64_t v26 = *((void *)image + 30);
  if (v26) {
    CFRetain(*((CFTypeRef *)image + 30));
  }
  *((void *)v9 + 30) = v26;
  *(_OWORD *)((char *)v9 + 248) = *(_OWORD *)((char *)image + 248);
  CGPropertiesRelease(*((CFTypeRef **)v9 + 27));
  *((void *)v9 + 27) = CGPropertiesCreateCopy(*((void *)image + 27));
  CGPropertiesRelease(*((CFTypeRef **)v9 + 28));
  *((void *)v9 + 28) = CGPropertiesCreateCopy(*((void *)image + 28));
  return v9;
}

CFTypeRef *CGPropertiesCreateCopy(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = (CFTypeRef *)CGPropertiesCreate();
  uint64_t v3 = v2;
  if (v2)
  {
    CFRelease(v2[1]);
    v3[1] = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)(a1 + 8));
  }
  return v3;
}

CGColorSpace *create_colorspace_with_ColorSync_profile(const void *a1, const __CFDictionary *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (create_colorspace_with_ColorSync_profile_cglibrarypredicate != -1) {
    dispatch_once(&create_colorspace_with_ColorSync_profile_cglibrarypredicate, &__block_literal_global_226_7562);
  }
  if (v4 == create_colorspace_with_ColorSync_profile_f())
  {
    CFLocaleRef v5 = (void *)CFRetain(a1);
    if (!a2) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  CFLocaleRef v5 = 0;
  if (a2) {
LABEL_9:
  }
    LODWORD(a2) = CFDictionaryGetValue(a2, @"kCGColorSpaceExtendedRange") == (const void *)*MEMORY[0x1E4F1CFD0];
LABEL_10:
  if (create_colorspace_with_ColorSync_profile_cglibrarypredicate_229 != -1) {
    dispatch_once(&create_colorspace_with_ColorSync_profile_cglibrarypredicate_229, &__block_literal_global_232_7563);
  }
  unsigned int v6 = 0;
  if (create_colorspace_with_ColorSync_profile_f_228(v5, 0, 0))
  {
    if (create_colorspace_with_ColorSync_profile_cglibrarypredicate_234 != -1) {
      dispatch_once(&create_colorspace_with_ColorSync_profile_cglibrarypredicate_234, &__block_literal_global_237);
    }
    uint64_t colorspace_with_ColorSync_profile_f_233 = create_colorspace_with_ColorSync_profile_f_233(v5, 0);
    if (colorspace_with_ColorSync_profile_f_233)
    {
      CFDataRef v8 = (const __CFData *)colorspace_with_ColorSync_profile_f_233;
      CFStringRef v9 = (CGColorSpace *)colorspace_with_name_from_icc_data(colorspace_with_ColorSync_profile_f_233, (uint64_t)v5);
      unsigned int v6 = v9;
      if (v9) {
        int v15 = (int)a2;
      }
      else {
        int v15 = 0;
      }
      if (v15 == 1)
      {
        CFTypeRef v16 = (unsigned char *)*((void *)v9 + 3);
        if (!v16[15] || v16[16] || v16[17])
        {
          CGColorSpaceRelease(v9);
          unsigned int v6 = 0;
        }
        else
        {
          colorspace_using_colorspace_state = create_colorspace_using_colorspace_state(v5, v8, 1, v10, v11, v12, v13, v14);
          CGColorSpaceRelease(v6);
          unsigned int v6 = colorspace_using_colorspace_state;
        }
      }
      else if (!v9)
      {
        unsigned int v6 = create_colorspace_using_colorspace_state(v5, v8, (int)a2, v10, v11, v12, v13, v14);
      }
      CFRelease(v8);
    }
    else
    {
      unsigned int v6 = 0;
    }
  }
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

CGColorSpace *create_colorspace_using_colorspace_state(void *a1, const __CFData *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __src[37] = *MEMORY[0x1E4F143B8];
  memset(__src, 0, 296);
  LODWORD(__src[0]) = -1;
  CGCMSUtilsGetICCProfileInfo(a1, (uint64_t)__src, a3, a4, a5, a6, a7, a8);
  memcpy(__dst, __src, sizeof(__dst));
  icdouble c = (atomic_uint *)color_space_state_create_icc(a1, a2, __dst);
  uint64_t v18 = (CGColorSpace *)CGColorSpaceCreateWithState(icc, v11, v12, v13, v14, v15, v16, v17);
  if (icc && atomic_fetch_add_explicit(icc, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    color_space_state_dealloc((uint64_t)icc);
  }
  uint64_t MatchingSingleton = CGColorSpaceFindMatchingSingleton((uint64_t)v18);
  if (MatchingSingleton)
  {
    uint64_t v20 = MatchingSingleton;
    CGColorSpaceRelease(v18);
    return (CGColorSpace *)v20;
  }
  else
  {
    if (create_colorspace_using_colorspace_state_cglibrarypredicate != -1) {
      dispatch_once(&create_colorspace_using_colorspace_state_cglibrarypredicate, &__block_literal_global_240_7564);
    }
    if ((create_colorspace_using_colorspace_state_f(a1, @"hdgm") & 1) == 0 && v18) {
      *((void *)v18 + 3) = color_space_state_register(*((unsigned char **)v18 + 3));
    }
  }
  return v18;
}

uint64_t __CGColorSpaceCreateGenericXYZ_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_generic_xyz);
  CGColorSpaceCreateGenericXYZ_space = result;
  return result;
}

uint64_t __CGColorSpaceCoreMedia709_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_core_media_709);
  CGColorSpaceCoreMedia709_space = result;
  return result;
}

uint64_t __CGColorSpaceCreateROMMRGB_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_romm_rgb);
  CGColorSpaceCreateROMMRGB_space = result;
  return result;
}

uint64_t __CGColorSpaceCreateAdobeRGB1998_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_adobe_rgb_1998);
  CGColorSpaceCreateAdobeRGB1998_space = result;
  return result;
}

uint64_t __CGColorSpaceCreateGenericRGBLinear_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_generic_rgb_linear);
  CGColorSpaceCreateGenericRGBLinear_space = result;
  return result;
}

uint64_t __CGColorSpaceCreateLinearDisplayP3_block_invoke()
{
  CGColorSpaceCreateLinearDisplayP3_space = create_singleton((uint64_t (*)(void))color_space_state_create_linear_display_p3);
  CGColorSpaceSetProperty(CGColorSpaceCreateLinearDisplayP3_space, @"kCGColorSpaceStandardRangeOriginal", (const void *)CGColorSpaceCreateLinearDisplayP3_space);
  CGColorSpaceSetProperty(CGColorSpaceCreateLinearDisplayP3_space, @"kCGColorSpaceLinearDerivative", (const void *)CGColorSpaceCreateLinearDisplayP3_space);
  CGColorSpaceSetProperty(CGColorSpaceCreateLinearDisplayP3_space, @"kCGColorSpaceExtendedDerivative", @"kCGColorSpaceExtendedLinearDisplayP3");
  uint64_t v0 = CGColorSpaceCreateLinearDisplayP3_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearDisplayP3");
}

uint64_t __CGColorSpaceCreateGenericRGB_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_generic_rgb);
  CGColorSpaceCreateGenericRGB_space = result;
  return result;
}

uint64_t __CGColorSpaceLinearGray_block_invoke()
{
  CGColorSpaceLinearGray_space = create_singleton((uint64_t (*)(void))color_space_state_create_linear_gray);
  CGColorSpaceSetProperty(CGColorSpaceLinearGray_space, @"kCGColorSpaceStandardRangeOriginal", (const void *)CGColorSpaceLinearGray_space);
  CGColorSpaceSetProperty(CGColorSpaceLinearGray_space, @"kCGColorSpaceLinearDerivative", (const void *)CGColorSpaceLinearGray_space);
  CGColorSpaceSetProperty(CGColorSpaceLinearGray_space, @"kCGColorSpaceExtendedDerivative", @"kCGColorSpaceExtendedLinearGray");
  uint64_t v0 = CGColorSpaceLinearGray_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearGray");
}

uint64_t __CGColorSpaceCreateDeviceCMYK_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_device_cmyk);
  CGColorSpaceCreateDeviceCMYK_space = result;
  return result;
}

uint64_t __CGColorSpaceCreateGenericCMYK_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_generic_cmyk);
  CGColorSpaceCreateGenericCMYK_space = result;
  return result;
}

uint64_t __CGColorSpaceCreateDeviceGray_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_device_gray);
  CGColorSpaceCreateDeviceGray_space = result;
  return result;
}

uint64_t __CGColorSpaceCreateDeviceRGB_block_invoke()
{
  uint64_t result = create_singleton((uint64_t (*)(void))color_space_state_create_device_rgb);
  CGColorSpaceCreateDeviceRGB_space = result;
  return result;
}

CGDataProviderRef CGDataProviderCreateWithURL(CGDataProviderRef url)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (url)
  {
    CFURLRef v1 = url;
    int v2 = CGCFURLGetType(url);
    if ((v2 - 1) >= 2)
    {
      if (!v2 && CFURLGetFileSystemRepresentation(v1, 1u, buffer, 1025)) {
        return CGDataProviderCreateWithFilename((const char *)buffer);
      }
      return 0;
    }
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFURLGetTypeID())
    {
      int v4 = CGCFURLGetType(v1);
      if (v4 == 2)
      {
        url = CFHTTPMessageCreateRequest(0, @"GET", v1, (CFStringRef)*MEMORY[0x1E4F18F88]);
        if (!url) {
          return url;
        }
        CGDataProviderRef v5 = url;
        CFDataRef v8 = http_message_send_request(url);
        if (v8)
        {
          CFStringRef v9 = v8;
          CFDataRef i = CFHTTPMessageCopyBody(v8);
          CFRelease(v9);
          CFRelease(v5);
          if (i)
          {
LABEL_22:
            uint64_t v11 = CGDataProviderCreateWithCFData(i);
            CFRelease(i);
            return v11;
          }
          return 0;
        }
        goto LABEL_18;
      }
      if (v4 == 1)
      {
        url = CFReadStreamCreateWithFTPURL(0, v1);
        if (!url) {
          return url;
        }
        CGDataProviderRef v5 = url;
        if (CFReadStreamOpen(url))
        {
          for (CFDataRef i = CFDataCreateMutable(0, 0); ; CFDataAppendBytes(i, buffer, v7))
          {
            uint64_t v7 = CFReadStreamRead(v5, buffer, 1024);
            if (v7 < 1) {
              break;
            }
          }
          CFReadStreamClose(v5);
          CFRelease(v5);
          if (!i) {
            return 0;
          }
          if (CFDataGetLength(i)) {
            goto LABEL_22;
          }
          CFDataRef v10 = i;
          goto LABEL_19;
        }
LABEL_18:
        CFDataRef v10 = v5;
LABEL_19:
        CFRelease(v10);
      }
    }
    return 0;
  }
  return url;
}

CGDataProviderRef CGDataProviderCreateWithFilename(const char *filename)
{
  if (!filename) {
    return 0;
  }
  __int16 v56 = 45;
  __int16 v55 = 78;
  CFArrayRef v2 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains();
  if (v2)
  {
    CFArrayRef v3 = v2;
    CFIndex Count = CFArrayGetCount(v2);
    if (Count < 1)
    {
      LOBYTE(v7) = 45;
    }
    else
    {
      CFIndex v5 = Count;
      unint64_t v6 = 0;
      int v7 = 45;
      do
      {
        ValueAtIndeCGFloat x = (const __CFURL *)CFArrayGetValueAtIndex(v3, v6);
        CFURLRef v9 = CFURLCopyAbsoluteURL(ValueAtIndex);
        if (v9)
        {
          CFURLRef v10 = v9;
          CFStringRef v11 = CFURLCopyPath(v9);
          if (v11)
          {
            CFStringRef v12 = v11;
            CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
            if (CStringPtr)
            {
              uint64_t v14 = CStringPtr;
              size_t v15 = strlen(CStringPtr);
              int v16 = strncasecmp(v14, filename, v15);
              unsigned int v17 = 0x554C53u >> (8 * v6);
              if (v6 > 2) {
                unsigned int v17 = v7;
              }
              if (!v16) {
                int v7 = v17;
              }
            }
            CFRelease(v12);
          }
          CFRelease(v10);
        }
        ++v6;
      }
      while (v5 != v6);
    }
    LOBYTE(v56) = v7;
    CFRelease(v3);
  }
  CFURLRef v18 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
  if (v18)
  {
    CFURLRef v19 = v18;
    CFURLRef v20 = CFURLCopyAbsoluteURL(v18);
    if (v20)
    {
      CFURLRef v21 = v20;
      CFStringRef v22 = CFURLCopyPath(v20);
      if (v22)
      {
        CFStringRef v23 = v22;
        uint64_t v24 = CFStringGetCStringPtr(v22, 0x8000100u);
        if (v24)
        {
          uint64_t v25 = v24;
          size_t v26 = strlen(v24);
          if (!strncasecmp(v25, filename, v26)) {
            LOBYTE(v55) = 89;
          }
        }
        CFRelease(v23);
      }
      CFRelease(v21);
    }
    CFRelease(v19);
  }
  int v27 = open(filename, 0, 0);
  if (v27 < 0) {
    return 0;
  }
  unsigned int v28 = v27;
  memset(&v54, 0, sizeof(v54));
  if (fstat(v27, &v54) < 0 || (v54.st_mode & 0xF000) != 0x8000 || !v54.st_size)
  {
    close(v28);
    return 0;
  }
  CFLocaleRef v29 = mmap(0, v54.st_size, 1, 16386, v28, 0);
  if (v29 != (void *)-1)
  {
    uint64_t v30 = (uint64_t)v29;
    ERROR_CGDataProvider_BufferIsNotReadable();
    ERROR_CGDataProvider_BufferIsNotBigEnough();
    if (v30)
    {
      st_CGSize size = v54.st_size;
      int v32 = fstat(v28, &v54);
      off_t v33 = v54.st_size;
      close(v28);
      DiCGRect rect = 0;
      if (v32 < 0 || st_size != v33) {
        return Direct;
      }
      uint64_t v35 = (__CFString *)CFStringCreateWithFormat(0, 0, @"mapped file: Library domain: [%s] home: [%s] original data pointer passed to provider: %p", &v56, &v55, v30);
      DiCGRect rect = CGDataProviderCreateWithDataInternal(0, v30, v54.st_size, (uint64_t)unmap_file, v35);
      if (v35)
      {
        CFLocaleRef v36 = v35;
LABEL_51:
        CFRelease(v36);
        goto LABEL_52;
      }
      goto LABEL_52;
    }
  }
  unint64_t v38 = v54.st_size;
  if (v54.st_size > 10485760)
  {
LABEL_46:
    DiCGRect rect = CGDataProviderCreateDirect((void *)v28, v38, &file_callbacks);
    goto LABEL_52;
  }
  CFIndex v39 = malloc_type_malloc(v54.st_size, 0x705560E0uLL);
  if (!v39)
  {
    unint64_t v38 = v54.st_size;
    goto LABEL_46;
  }
  uint64_t v40 = (uint64_t)v39;
  unint64_t v41 = read(v28, v39, v38);
  if (v41 == -1)
  {
    unint64_t v49 = 0;
    goto LABEL_48;
  }
  unint64_t v49 = v41;
  if (v41 < v38)
  {
LABEL_48:
    CGPostError((uint64_t)"%s: warning: failed to read entire file.", v42, v43, v44, v45, v46, v47, v48, (char)"read_file");
    bzero((void *)(v40 + v49), v38 - v49);
  }
  close(v28);
  CFRange v50 = (__CFString *)CFStringCreateWithFormat(0, 0, @"data read from file: Library domain: [%s] home: [%s] original data pointer passed to provider: %p", &v56, &v55, v40);
  DiCGRect rect = CGDataProviderCreateWithDataInternal(0, v40, v54.st_size, (uint64_t)free_data_10126, v50);
  if (v50)
  {
    CFLocaleRef v36 = v50;
    goto LABEL_51;
  }
LABEL_52:
  if (Direct)
  {
    int valuePtr = rootless_trusted_by_self_token();
    CFNumberRef v51 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    if (v51)
    {
      CFNumberRef v52 = v51;
      CGDataProviderSetProperty((uint64_t)Direct, @"CGDataProviderTrustToken", v51);
      CFRelease(v52);
    }
  }
  return Direct;
}

CGDataProviderRef CGDataProviderCreateWithDataInternal(uint64_t a1, uint64_t a2, off_t a3, uint64_t a4, __CFString *a5)
{
  if (!a2) {
    return 0;
  }
  CFURLRef v10 = malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
  *CFURLRef v10 = a1;
  v10[1] = a3;
  _OWORD v10[2] = a2;
  _OWORD v10[3] = a4;
  *(void *)&callbacks.version = 0;
  callbacks.getBytePointer = (CGDataProviderGetBytePointerCallback)data_get_byte_pointer;
  callbacks.releaseBytePointer = 0;
  callbacks.getBytesAtPosition = (CGDataProviderGetBytesAtPositionCallback)data_get_bytes_at_position;
  callbacks.CGFunctionReleaseInfoCallback releaseInfo = (CGDataProviderReleaseInfoCallback)data_release_info;
  CGDataProviderRef v11 = CGDataProviderCreateDirect(v10, a3, &callbacks);
  CGDataProviderRef v12 = v11;
  if (a5 && v11) {
    *((void *)v11 + 35) = CGDataProviderCreateDebugString((uint64_t)v11, a5);
  }
  return v12;
}

void CGDataProviderSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  if (a1 && a2 && a3)
  {
    if (!*(void *)(a1 + 272))
    {
      unint64_t v6 = (CFTypeRef *)CGPropertiesCreate();
      uint64_t v7 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 272), (unint64_t *)&v7, (unint64_t)v6, memory_order_relaxed, memory_order_relaxed);
      if (v7) {
        CGPropertiesRelease(v6);
      }
    }
    uint64_t v8 = *(void *)(a1 + 272);
    CGPropertiesSetProperty(v8, a2, a3);
  }
}

uint64_t CGCFURLGetType(const __CFURL *a1)
{
  CFStringRef v1 = CFURLCopyScheme(a1);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  CFStringRef v2 = v1;
  CFComparisonResult v3 = CFStringCompare(v1, @"file", 1uLL);
  CFComparisonResult v4 = CFStringCompare(v2, @"ftp", 1uLL);
  if (CFStringCompare(v2, @"http", 1uLL) == kCFCompareEqualTo
    || (v3 == kCFCompareEqualTo ? (unsigned int v5 = 0) : (unsigned int v5 = -1),
        v4 == kCFCompareEqualTo ? (uint64_t v6 = 1) : (uint64_t v6 = v5),
        CFStringCompare(v2, @"https", 1uLL) == kCFCompareEqualTo))
  {
    uint64_t v6 = 2;
  }
  CFRelease(v2);
  return v6;
}

uint64_t __CGColorSpaceExtendedLinearSRGB_block_invoke()
{
  CGColorSpaceExtendedLinearSRGB_space = create_singleton((uint64_t (*)(void))color_space_state_create_extended_linear_srgb);
  CGColorSpaceSetProperty(CGColorSpaceExtendedLinearSRGB_space, @"kCGColorSpaceStandardRangeOriginal", @"kCGColorSpaceLinearSRGB");
  CGColorSpaceSetProperty(CGColorSpaceExtendedLinearSRGB_space, @"kCGColorSpaceLinearDerivative", (const void *)CGColorSpaceExtendedLinearSRGB_space);
  CGColorSpaceSetProperty(CGColorSpaceExtendedLinearSRGB_space, @"kCGColorSpaceExtendedDerivative", (const void *)CGColorSpaceExtendedLinearSRGB_space);
  uint64_t v0 = CGColorSpaceExtendedLinearSRGB_space;
  CFStringRef v1 = (const void *)CGColorSpaceExtendedLinearSRGB_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", v1);
}

uint64_t __CGColorSpaceCreateDisplayP3_block_invoke()
{
  CGColorSpaceCreateDisplayP3_space = create_singleton((uint64_t (*)(void))color_space_state_create_display_p3);
  CGColorSpaceSetProperty(CGColorSpaceCreateDisplayP3_space, @"kCGColorSpaceStandardRangeOriginal", (const void *)CGColorSpaceCreateDisplayP3_space);
  CGColorSpaceSetProperty(CGColorSpaceCreateDisplayP3_space, @"kCGColorSpaceLinearDerivative", @"kCGColorSpaceLinearDisplayP3");
  CGColorSpaceSetProperty(CGColorSpaceCreateDisplayP3_space, @"kCGColorSpaceExtendedDerivative", @"kCGColorSpaceExtendedDisplayP3");
  uint64_t v0 = CGColorSpaceCreateDisplayP3_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearDisplayP3");
}

uint64_t __CGColorSpaceLinearSRGB_block_invoke()
{
  CGColorSpaceLinearSRGB_space = create_singleton((uint64_t (*)(void))color_space_state_create_linear_srgb);
  CGColorSpaceSetProperty(CGColorSpaceLinearSRGB_space, @"kCGColorSpaceStandardRangeOriginal", (const void *)CGColorSpaceLinearSRGB_space);
  CGColorSpaceSetProperty(CGColorSpaceLinearSRGB_space, @"kCGColorSpaceLinearDerivative", (const void *)CGColorSpaceLinearSRGB_space);
  CGColorSpaceSetProperty(CGColorSpaceLinearSRGB_space, @"kCGColorSpaceExtendedDerivative", @"kCGColorSpaceExtendedLinearSRGB");
  uint64_t v0 = CGColorSpaceLinearSRGB_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearSRGB");
}

uint64_t __CGColorSpaceExtendedGray_block_invoke()
{
  CGColorSpaceExtendedGray_space = create_singleton((uint64_t (*)(void))color_space_state_create_extended_gray);
  CGColorSpaceSetProperty(CGColorSpaceExtendedGray_space, @"kCGColorSpaceStandardRangeOriginal", @"kCGColorSpaceGenericGrayGamma2_2");
  CGColorSpaceSetProperty(CGColorSpaceExtendedGray_space, @"kCGColorSpaceLinearDerivative", @"kCGColorSpaceExtendedLinearGray");
  CGColorSpaceSetProperty(CGColorSpaceExtendedGray_space, @"kCGColorSpaceExtendedDerivative", (const void *)CGColorSpaceExtendedGray_space);
  uint64_t v0 = CGColorSpaceExtendedGray_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearGray");
}

uint64_t __CGColorSpaceCreateGenericGrayGamma22_block_invoke()
{
  CGColorSpaceCreateGenericGrayGamma22_space = create_singleton((uint64_t (*)(void))color_space_state_create_generic_gray_gamma_22);
  CGColorSpaceSetProperty(CGColorSpaceCreateGenericGrayGamma22_space, @"kCGColorSpaceStandardRangeOriginal", (const void *)CGColorSpaceCreateGenericGrayGamma22_space);
  CGColorSpaceSetProperty(CGColorSpaceCreateGenericGrayGamma22_space, @"kCGColorSpaceLinearDerivative", @"kCGColorSpaceLinearGray");
  CGColorSpaceSetProperty(CGColorSpaceCreateGenericGrayGamma22_space, @"kCGColorSpaceExtendedDerivative", @"kCGColorSpaceExtendedGray");
  uint64_t v0 = CGColorSpaceCreateGenericGrayGamma22_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearGray");
}

uint64_t __CGColorSpaceCreateSRGB_block_invoke()
{
  CGColorSpaceCreateSRGB_space = create_singleton((uint64_t (*)(void))color_space_state_create_sRGB);
  CGColorSpaceSetProperty(CGColorSpaceCreateSRGB_space, @"kCGColorSpaceStandardRangeOriginal", (const void *)CGColorSpaceCreateSRGB_space);
  CGColorSpaceSetProperty(CGColorSpaceCreateSRGB_space, @"kCGColorSpaceLinearDerivative", @"kCGColorSpaceLinearSRGB");
  CGColorSpaceSetProperty(CGColorSpaceCreateSRGB_space, @"kCGColorSpaceExtendedDerivative", @"kCGColorSpaceExtendedSRGB");
  uint64_t v0 = CGColorSpaceCreateSRGB_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearSRGB");
}

uint64_t __CGColorSpaceExtendedSRGB_block_invoke()
{
  CGColorSpaceExtendedSRGB_space = create_singleton((uint64_t (*)(void))color_space_state_create_extended_srgb);
  CGColorSpaceSetProperty(CGColorSpaceExtendedSRGB_space, @"kCGColorSpaceStandardRangeOriginal", @"kCGColorSpaceSRGB");
  CGColorSpaceSetProperty(CGColorSpaceExtendedSRGB_space, @"kCGColorSpaceLinearDerivative", @"kCGColorSpaceExtendedLinearSRGB");
  CGColorSpaceSetProperty(CGColorSpaceExtendedSRGB_space, @"kCGColorSpaceExtendedDerivative", (const void *)CGColorSpaceExtendedSRGB_space);
  uint64_t v0 = CGColorSpaceExtendedSRGB_space;

  return CGColorSpaceSetProperty(v0, @"kCGColorSpaceExtendedLinearDerivative", @"kCGColorSpaceExtendedLinearSRGB");
}

uint64_t CGColorSpaceSetProperty(uint64_t result, const void *a2, const void *a3)
{
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = (pthread_mutex_t *)(result + 32);
    pthread_mutex_lock((pthread_mutex_t *)(result + 32));
    uint64_t v7 = *(_DWORD **)(*(void *)(v5 + 24) + 88);
    if (!v7)
    {
      uint64_t v7 = CGPropertiesCreate();
      *(void *)(*(void *)(v5 + 24) + 88) = v7;
    }
    CGPropertiesSetProperty((uint64_t)v7, a2, a3);
    return pthread_mutex_unlock(v6);
  }
  return result;
}

void CGPropertiesSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), a2, a3);

  os_unfair_lock_unlock(v6);
}

uint64_t create_singleton(uint64_t (*a1)(void))
{
  uint64_t v1 = a1();
  if (!v1) {
    return 0;
  }
  CFURLRef v9 = (atomic_uint *)v1;
  *(unsigned char *)(v1 + 8) = 1;
  uint64_t v10 = CGColorSpaceCreateWithState((atomic_uint *)v1, v2, v3, v4, v5, v6, v7, v8);
  if (atomic_fetch_add_explicit(v9, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    color_space_state_dealloc((uint64_t)v9);
  }
  return v10;
}

uint64_t CGColorSpaceCreateWithState(atomic_uint *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  uint64_t Instance = CGTypeCreateInstance(CGColorSpaceGetTypeID_type_id, 80, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = Instance;
  if (Instance)
  {
    pthread_mutex_init((pthread_mutex_t *)(Instance + 32), 0);
    atomic_fetch_add_explicit(a1, 1u, memory_order_relaxed);
    *(void *)(v10 + 24) = a1;
    *(_DWORD *)(v10 + 16) = 1;
  }
  return v10;
}

void *color_space_state_create_extended_srgb()
{
  if (color_space_state_create_extended_srgb_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_extended_srgb_cglibrarypredicate, &__block_literal_global_262_1839);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_extended_srgb_f;
  if (color_space_state_create_extended_srgb_cglibrarypredicate_263 != -1) {
    dispatch_once(&color_space_state_create_extended_srgb_cglibrarypredicate_263, &__block_literal_global_266_1840);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_extended_srgb_s);
  uint64_t v2 = create_from_profile(v1, 1);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceExtendedSRGB";
    *((_DWORD *)v2 + 5) = 16;
    *(void *)(v2[12] + 48) = @"sRGB IEC61966-2.1";
  }
  return v2;
}

void *color_space_state_create_sRGB()
{
  if (color_space_state_create_sRGB_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_sRGB_cglibrarypredicate, &__block_literal_global_114);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_sRGB_f;
  if (color_space_state_create_sRGB_cglibrarypredicate_115 != -1) {
    dispatch_once(&color_space_state_create_sRGB_cglibrarypredicate_115, &__block_literal_global_118);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_sRGB_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceSRGB";
    *((_DWORD *)v2 + 5) = 15;
    *(void *)(v2[12] + 48) = @"sRGB IEC61966-2.1";
  }
  return v2;
}

void *create_from_profile(void *a1, int a2)
{
  icdouble c = a1;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (create_from_profile_cglibrarypredicate != -1) {
      dispatch_once(&create_from_profile_cglibrarypredicate, &__block_literal_global_304);
    }
    uint64_t v4 = create_from_profile_f(icc, 0);
    if (v4)
    {
      CFDataRef v5 = (const __CFData *)v4;
      memcpy(__dst, &CGICCProfileInfoInitializer, sizeof(__dst));
      CGCMSUtilsGetICCProfileInfo(icc, (uint64_t)__dst, a2, v6, v7, v8, v9, v10);
      memcpy(v12, __dst, sizeof(v12));
      icdouble c = color_space_state_create_icc(icc, v5, v12);
      CFRelease(v5);
    }
    else
    {
      return 0;
    }
  }
  return icc;
}

void CGCMSUtilsGetICCProfileInfo(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v42 = "profile != NULL";
    uint64_t v43 = "profile missing";
    goto LABEL_113;
  }
  if (!a2)
  {
    uint64_t v42 = "info != NULL";
    uint64_t v43 = "profile info missing";
LABEL_113:
    _CGHandleAssert("CGCMSUtilsGetICCProfileInfo", 75, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSUtils.c", v42, v43, a6, a7, a8, v44);
  }
  if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate != -1) {
    dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate, &__block_literal_global_1539);
  }
  *(void *)(a2 + 4) = CGCMSUtilsGetICCProfileInfo_f(a1);
  *(void *)(a2 + 12) = v11;
  if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_8 != -1) {
    dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_8, &__block_literal_global_11);
  }
  CFDataRef ICCProfileInfo_f_7 = (const __CFData *)CGCMSUtilsGetICCProfileInfo_f_7(a1);
  if (ICCProfileInfo_f_7)
  {
    CFDataRef v13 = ICCProfileInfo_f_7;
    *(unsigned char *)(a2 + 282) = 0;
    BytePtr = CFDataGetBytePtr(ICCProfileInfo_f_7);
    CFURLRef v18 = BytePtr;
    int v19 = *((_DWORD *)BytePtr + 4);
    if (v19 > 1213421087)
    {
      if (v19 <= 1296255028)
      {
        if (v19 == 1213421088)
        {
LABEL_36:
          char v20 = 0;
          int v21 = 0;
          int v22 = 4;
LABEL_37:
          uint64_t v23 = 3;
          goto LABEL_48;
        }
        if (v19 == 1281450528)
        {
          char v20 = 0;
          int v21 = 0;
          int v22 = 3;
          goto LABEL_37;
        }
        int v24 = 1282766368;
        goto LABEL_35;
      }
      if (v19 <= 1380401695)
      {
        switch(v19)
        {
          case 1296255029:
            goto LABEL_18;
          case 1296255030:
            goto LABEL_38;
          case 1296255031:
            goto LABEL_39;
          case 1296255032:
            goto LABEL_40;
          default:
            goto LABEL_47;
        }
      }
      switch(v19)
      {
        case 1501067552:
          goto LABEL_36;
        case 1482250784:
          char v20 = 1;
          int v22 = 7;
          break;
        case 1380401696:
          char v20 = 0;
          int v22 = 1;
          break;
        default:
          goto LABEL_47;
      }
      uint64_t v23 = 3;
    }
    else
    {
      if (v19 <= 943934545)
      {
        if (v19 > 893602897)
        {
          switch(v19)
          {
            case 893602898:
LABEL_18:
              char v20 = 0;
              int v21 = 0;
              int v22 = 4;
              uint64_t v23 = 5;
              goto LABEL_48;
            case 910380114:
LABEL_38:
              char v20 = 0;
              int v21 = 0;
              int v22 = 4;
              uint64_t v23 = 6;
              goto LABEL_48;
            case 927157330:
LABEL_39:
              char v20 = 0;
              int v21 = 0;
              int v22 = 4;
              uint64_t v23 = 7;
              goto LABEL_48;
          }
          goto LABEL_47;
        }
        if (v19 != 860048466)
        {
          if (v19 == 876825682)
          {
            char v20 = 0;
            int v21 = 0;
            uint64_t v23 = 4;
            int v22 = 4;
            goto LABEL_48;
          }
          goto LABEL_47;
        }
        goto LABEL_36;
      }
      if (v19 <= 1129142602)
      {
        if (v19 == 943934546)
        {
LABEL_40:
          char v20 = 0;
          int v21 = 0;
          int v22 = 4;
          uint64_t v23 = 8;
          goto LABEL_48;
        }
        int v24 = 1129142560;
LABEL_35:
        if (v19 == v24) {
          goto LABEL_36;
        }
LABEL_47:
        uint64_t v23 = 0;
        char v20 = 0;
        int v21 = 0;
        int v22 = 4;
LABEL_48:
        *(_DWORD *)a2 = v22;
        *(void *)(a2 + 288) = v23;
        int v25 = *((_DWORD *)BytePtr + 3);
        if (v25 > 1886549105)
        {
          if (v25 == 1886549106 || v25 == 1936744803) {
            goto LABEL_63;
          }
        }
        else
        {
          if (v25 == 1818848875)
          {
            *(unsigned char *)(a2 + 280) = 0;
            if ((v20 & 1) == 0) {
              goto LABEL_73;
            }
            goto LABEL_71;
          }
          if (v25 == 1835955314)
          {
            if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_14 != -1) {
              dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_14, &__block_literal_global_17);
            }
            *(unsigned char *)(a2 + 283) = CGCMSUtilsGetICCProfileInfo_f_13(a1);
            if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_20 != -1) {
              dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_20, &__block_literal_global_23);
            }
            int ICCProfileInfo_f_19 = CGCMSUtilsGetICCProfileInfo_f_19(a1);
            *(unsigned char *)(a2 + 284) = ICCProfileInfo_f_19;
            if (*(unsigned char *)(a2 + 283)) {
              int v21 = 0;
            }
            else {
              int v21 = ICCProfileInfo_f_19 ^ 1;
            }
            if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_26 != -1) {
              dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_26, &__block_literal_global_29);
            }
            *(unsigned char *)(a2 + 286) = CGCMSUtilsGetICCProfileInfo_f_25(a1);
LABEL_63:
            *(unsigned char *)(a2 + 280) = 1;
            if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_32 != -1) {
              dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_32, &__block_literal_global_35);
            }
            if (CGCMSUtilsGetICCProfileInfo_f_31(a1))
            {
              char ICCProfileInfo_f_37 = 1;
            }
            else
            {
              if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_38 != -1) {
                dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_38, &__block_literal_global_41);
              }
              char ICCProfileInfo_f_37 = CGCMSUtilsGetICCProfileInfo_f_37(a1, @"aapy");
            }
            *(unsigned char *)(a2 + 282) = ICCProfileInfo_f_37;
            if (v20) {
              goto LABEL_71;
            }
LABEL_73:
            if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_50 != -1) {
              dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_50, &__block_literal_global_53);
            }
            char ICCProfileInfo_f_49 = CGCMSUtilsGetICCProfileInfo_f_49(a1);
            goto LABEL_76;
          }
        }
        if (CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_45 != -1) {
          dispatch_once(&CGCMSUtilsGetICCProfileInfo_cglibrarypredicate_45, &__block_literal_global_48);
        }
        if (!CGCMSUtilsGetICCProfileInfo_f_44(a1))
        {
          if (profile_can_be_used_as_destination_cglibrarypredicate != -1) {
            dispatch_once(&profile_can_be_used_as_destination_cglibrarypredicate, &__block_literal_global_478);
          }
          uint64_t v34 = (uint64_t (*)(uint64_t))profile_can_be_used_as_destination_f;
          if (profile_can_be_used_as_destination_cglibrarypredicate_479 != -1) {
            dispatch_once(&profile_can_be_used_as_destination_cglibrarypredicate_479, &__block_literal_global_482);
          }
          uint64_t v35 = (void *)v34(profile_can_be_used_as_destination_s);
          if (v35)
          {
            CFLocaleRef v36 = v35;
            *(_OWORD *)keys = xmmword_1E52A0FE0;
            CFRange v50 = @"ColorSyncTransformTag";
            values[0] = v35;
            values[1] = @"ColorSyncRenderingIntentPerceptual";
            values[2] = @"ColorSyncTransformDeviceToPCS";
            v47[0] = a1;
            v47[1] = @"ColorSyncRenderingIntentPerceptual";
            v47[2] = @"ColorSyncTransformPCSToDevice";
            CFStringRef v37 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
            CFDictionaryRef v38 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFRelease(v36);
            CFDictionaryRef v39 = CFDictionaryCreate(0, (const void **)keys, (const void **)v47, 3, MEMORY[0x1E4F1D530], v37);
            v46[0] = v38;
            v46[1] = v39;
            v46[2] = 0;
            CFArrayRef v40 = CFArrayCreate(0, (const void **)v46, 2, MEMORY[0x1E4F1D510]);
            Retainedouble d = CGColorSyncTransformCacheGetRetained(v40, 0);
            if (v38) {
              CFRelease(v38);
            }
            if (v39) {
              CFRelease(v39);
            }
            if (v40) {
              CFRelease(v40);
            }
            BOOL v41 = Retained != 0;
            CGColorSyncTransformCacheRelease(Retained);
          }
          else
          {
            BOOL v41 = 0;
          }
          *(unsigned char *)(a2 + 280) = v41;
          if (v20) {
            goto LABEL_71;
          }
          goto LABEL_73;
        }
        *(unsigned char *)(a2 + 280) = 1;
        if ((v20 & 1) == 0) {
          goto LABEL_73;
        }
LABEL_71:
        char ICCProfileInfo_f_49 = 1;
LABEL_76:
        *(unsigned char *)(a2 + 281) = ICCProfileInfo_f_49;
        int v29 = a3 & v21;
        *(unsigned char *)(a2 + 285) = a3 & v21;
        uint64_t v30 = *(void *)(a2 + 288);
        if (v30)
        {
          unint64_t v31 = 0;
          int v32 = *((_DWORD *)v18 + 4);
          uint64_t v33 = a2 + 24;
          do
          {
            if (v32 == 1281450528)
            {
              if (v31 >= 3) {
                _CGHandleAssert("CGCMSUtilsGetICCProfileInfo", 186, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSUtils.c", "k < 3", "component %zu too large", v15, v16, v17, v31);
              }
              *(float64x2_t *)(v33 + 16 * v31) = vcvtq_f64_f32(CGCMSUtilsGetICCProfileInfo_range[v31 + 2]);
            }
            else if (v29)
            {
              *(_OWORD *)(v33 + 16 * v31) = xmmword_1850CD900;
            }
            else
            {
              *(_OWORD *)(v33 + 16 * v31) = xmmword_1850CD8C0;
            }
            ++v31;
          }
          while (v30 != v31);
        }
        if ((v29 & 1) != 0 && *(_DWORD *)a2 == 1) {
          *(unsigned char *)(a2 + 282) = 1;
        }
        CFRelease(v13);
        return;
      }
      if (v19 == 1129142603)
      {
        char v20 = 0;
        int v21 = 0;
        int v22 = 2;
        uint64_t v23 = 4;
        goto LABEL_48;
      }
      if (v19 != 1196573017)
      {
        int v24 = 1212961568;
        goto LABEL_35;
      }
      int v22 = 0;
      char v20 = 0;
      uint64_t v23 = 1;
    }
    int v21 = 1;
    goto LABEL_48;
  }
}

double color_space_state_create_device_rgb()
{
  uint64_t v0 = malloc_type_calloc(0x78uLL, 1uLL, 0x70A95D2DuLL);
  if (v0)
  {
    *(_DWORD *)uint64_t v0 = 1;
    v0[12] = 1;
    *((_DWORD *)v0 + 2) = 0x10000;
    *((_WORD *)v0 + 7) = 256;
    *((void *)v0 + 14) = &device_rgb_vtable;
    *((void *)v0 + 3) = 0x100000001;
    *((_DWORD *)v0 + 8) = 1;
    *((void *)v0 + 11) = 0;
    *((void *)v0 + 12) = 0;
    *((void *)v0 + 10) = @"kCGColorSpaceDeviceRGB";
    *((void *)v0 + 5) = &device_rgb_get_default_color_components_default_rgb;
    *((void *)v0 + 6) = 3;
    double result = 2.51837737e257;
    *((_OWORD *)v0 + 4) = xmmword_1850CDB20;
  }
  return result;
}

void *color_space_state_create_generic_gray_gamma_22()
{
  if (color_space_state_create_generic_gray_gamma_22_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_generic_gray_gamma_22_cglibrarypredicate, &__block_literal_global_92);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_generic_gray_gamma_22_f;
  if (color_space_state_create_generic_gray_gamma_22_cglibrarypredicate_93 != -1) {
    dispatch_once(&color_space_state_create_generic_gray_gamma_22_cglibrarypredicate_93, &__block_literal_global_96);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_generic_gray_gamma_22_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceGenericGrayGamma2_2";
    *((_DWORD *)v2 + 5) = 1;
    *(void *)(v2[12] + 48) = @"Generic Gray Gamma 2.2 Profile";
  }
  return v2;
}

double color_space_state_create_device_gray()
{
  uint64_t v0 = malloc_type_calloc(0x78uLL, 1uLL, 0x4F16AE18uLL);
  if (v0)
  {
    *(_DWORD *)uint64_t v0 = 1;
    v0[12] = 1;
    *((_DWORD *)v0 + 2) = 0x10000;
    *((_WORD *)v0 + 7) = 256;
    *((void *)v0 + 14) = &device_gray_vtable;
    *((void *)v0 + 3) = 0;
    *((_DWORD *)v0 + 8) = 0;
    *((void *)v0 + 11) = 0;
    *((void *)v0 + 12) = 0;
    *((void *)v0 + 10) = @"kCGColorSpaceDeviceGray";
    *((void *)v0 + 5) = &xmmword_1852108F0;
    *((void *)v0 + 6) = 1;
    double result = 3.05765335e180;
    *((_OWORD *)v0 + 4) = xmmword_1850CDB10;
  }
  return result;
}

void *color_space_state_create_generic_cmyk()
{
  if (color_space_state_create_generic_cmyk_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_generic_cmyk_cglibrarypredicate, &__block_literal_global_21);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_generic_cmyk_f;
  if (color_space_state_create_generic_cmyk_cglibrarypredicate_22 != -1) {
    dispatch_once(&color_space_state_create_generic_cmyk_cglibrarypredicate_22, &__block_literal_global_25_1761);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_generic_cmyk_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceGenericCMYK";
    *(void *)(v2[12] + 48) = @"Generic CMYK Profile";
  }
  return v2;
}

void *color_space_state_create_extended_gray()
{
  if (color_space_state_create_extended_gray_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_extended_gray_cglibrarypredicate, &__block_literal_global_272);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_extended_gray_f;
  if (color_space_state_create_extended_gray_cglibrarypredicate_273 != -1) {
    dispatch_once(&color_space_state_create_extended_gray_cglibrarypredicate_273, &__block_literal_global_276);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_extended_gray_s);
  uint64_t v2 = create_from_profile(v1, 1);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceExtendedGray";
    *((_DWORD *)v2 + 5) = 2;
    *(void *)(v2[12] + 48) = @"Generic Gray Gamma 2.2 Profile";
  }
  return v2;
}

double color_space_state_create_device_cmyk()
{
  uint64_t v0 = malloc_type_calloc(0x78uLL, 1uLL, 0x8A9AA748uLL);
  if (v0)
  {
    *(_DWORD *)uint64_t v0 = 1;
    v0[12] = 1;
    *((_DWORD *)v0 + 2) = 0x10000;
    *((_WORD *)v0 + 7) = 0;
    *((void *)v0 + 14) = &device_cmyk_vtable;
    *((void *)v0 + 3) = 0x200000002;
    *((_DWORD *)v0 + 8) = 2;
    *((void *)v0 + 11) = 0;
    *((void *)v0 + 12) = 0;
    *((void *)v0 + 10) = @"kCGColorSpaceDeviceCMYK";
    *((void *)v0 + 5) = &device_cmyk_get_default_color_components_default_cmyk;
    *((void *)v0 + 6) = 4;
    double result = -2.24810663e216;
    *((_OWORD *)v0 + 4) = xmmword_1850CDB30;
  }
  return result;
}

void *color_space_state_create_linear_srgb()
{
  LinearSRGBProfile = CGCMSUtilsCreateLinearSRGBProfile();
  uint64_t v1 = create_from_profile(LinearSRGBProfile, 0);
  if (LinearSRGBProfile) {
    CFRelease(LinearSRGBProfile);
  }
  if (v1)
  {
    v1[10] = @"kCGColorSpaceLinearSRGB";
    *((_DWORD *)v1 + 5) = 17;
    *(void *)(v1[12] + 48) = @"sRGB IEC61966-2.1 Linear";
  }
  return v1;
}

CFTypeRef CGCMSUtilsCreateLinearSRGBProfile()
{
  if (CGCMSUtilsCreateLinearSRGBProfile_once != -1) {
    dispatch_once(&CGCMSUtilsCreateLinearSRGBProfile_once, &__block_literal_global_167);
  }
  CFTypeRef result = (CFTypeRef)CGCMSUtilsCreateLinearSRGBProfile_linear_profile;
  if (CGCMSUtilsCreateLinearSRGBProfile_linear_profile)
  {
    return CFRetain(result);
  }
  return result;
}

void *color_space_state_create_display_p3()
{
  if (color_space_state_create_display_p3_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_display_p3_cglibrarypredicate, &__block_literal_global_32);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_display_p3_f;
  if (color_space_state_create_display_p3_cglibrarypredicate_33 != -1) {
    dispatch_once(&color_space_state_create_display_p3_cglibrarypredicate_33, &__block_literal_global_36);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_display_p3_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceDisplayP3";
    *((_DWORD *)v2 + 5) = 7;
    *(void *)(v2[12] + 48) = @"Display P3";
  }
  return v2;
}

void *color_space_state_create_extended_linear_srgb()
{
  LinearSRGBProfile = CGCMSUtilsCreateLinearSRGBProfile();
  uint64_t v1 = create_from_profile(LinearSRGBProfile, 1);
  if (LinearSRGBProfile) {
    CFRelease(LinearSRGBProfile);
  }
  if (v1)
  {
    v1[10] = @"kCGColorSpaceExtendedLinearSRGB";
    *((_DWORD *)v1 + 5) = 18;
    *(void *)(v1[12] + 48) = @"sRGB IEC61966-2.1 Linear";
  }
  return v1;
}

void *color_space_state_create_generic_rgb()
{
  if (color_space_state_create_generic_rgb_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_generic_rgb_cglibrarypredicate, &__block_literal_global_10_1754);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_generic_rgb_f;
  if (color_space_state_create_generic_rgb_cglibrarypredicate_11 != -1) {
    dispatch_once(&color_space_state_create_generic_rgb_cglibrarypredicate_11, &__block_literal_global_14);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_generic_rgb_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceGenericRGB";
    *(void *)(v2[12] + 48) = @"Generic RGB Profile";
  }
  return v2;
}

void *color_space_state_create_itur_709()
{
  if (color_space_state_create_itur_709_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_itur_709_cglibrarypredicate, &__block_literal_global_147);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_itur_709_f;
  if (color_space_state_create_itur_709_cglibrarypredicate_148 != -1) {
    dispatch_once(&color_space_state_create_itur_709_cglibrarypredicate_148, &__block_literal_global_151);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_itur_709_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceITUR_709";
    *((_DWORD *)v2 + 5) = 20;
    *(void *)(v2[12] + 48) = @"Rec. ITU-R BT.709-5";
  }
  return v2;
}

void *color_space_state_create_itur_2020()
{
  if (color_space_state_create_itur_2020_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_itur_2020_cglibrarypredicate, &__block_literal_global_180);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_itur_2020_f;
  if (color_space_state_create_itur_2020_cglibrarypredicate_181 != -1) {
    dispatch_once(&color_space_state_create_itur_2020_cglibrarypredicate_181, &__block_literal_global_184);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_itur_2020_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceITUR_2020";
    *((_DWORD *)v2 + 5) = 23;
    *(void *)(v2[12] + 48) = @"Rec. ITU-R BT.2020-1";
  }
  return v2;
}

void *color_space_state_create_romm_rgb()
{
  if (color_space_state_create_romm_rgb_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_romm_rgb_cglibrarypredicate, &__block_literal_global_240);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_romm_rgb_f;
  if (color_space_state_create_romm_rgb_cglibrarypredicate_241 != -1) {
    dispatch_once(&color_space_state_create_romm_rgb_cglibrarypredicate_241, &__block_literal_global_244);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_romm_rgb_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceROMMRGB";
    *((_DWORD *)v2 + 5) = 30;
    *(void *)(v2[12] + 48) = @"ROMM RGB: ISO 22028-2:2013";
  }
  return v2;
}

void *color_space_state_create_p3_PQ()
{
  if (color_space_state_create_p3_PQ_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_p3_PQ_cglibrarypredicate, &__block_literal_global_59);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_p3_PQ_f;
  if (color_space_state_create_p3_PQ_cglibrarypredicate_60 != -1) {
    dispatch_once(&color_space_state_create_p3_PQ_cglibrarypredicate_60, &__block_literal_global_63_1781);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_p3_PQ_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceDisplayP3_PQ";
    *((_DWORD *)v2 + 5) = 11;
    *(void *)(v2[12] + 48) = @"Display P3; SMPTE ST 2084 PQ EOTF";
    *((unsigned char *)v2 + 16) = 1;
    if (should_allow_as_output_space_predicate != -1) {
      dispatch_once(&should_allow_as_output_space_predicate, &__block_literal_global_308_1782);
    }
    if (!should_allow_as_output_space_should_allow) {
      *((unsigned char *)v2 + 10) = 0;
    }
  }
  return v2;
}

void *color_space_state_create_p3_HLG()
{
  if (color_space_state_create_p3_HLG_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_p3_HLG_cglibrarypredicate, &__block_literal_global_70);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_p3_HLG_f;
  if (color_space_state_create_p3_HLG_cglibrarypredicate_71 != -1) {
    dispatch_once(&color_space_state_create_p3_HLG_cglibrarypredicate_71, &__block_literal_global_74);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_p3_HLG_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceDisplayP3_HLG";
    *((_DWORD *)v2 + 5) = 12;
    *(void *)(v2[12] + 48) = @"Display P3; ARIB STD-B67 HLG";
    *((unsigned char *)v2 + 17) = 1;
    if (should_allow_as_output_space_predicate != -1) {
      dispatch_once(&should_allow_as_output_space_predicate, &__block_literal_global_308_1782);
    }
    if (!should_allow_as_output_space_should_allow) {
      *((unsigned char *)v2 + 10) = 0;
    }
  }
  return v2;
}

void *color_space_state_create_linear_gray()
{
  LinearGrayProfile = CGCMSUtilsCreateLinearGrayProfile();
  uint64_t v1 = create_from_profile(LinearGrayProfile, 0);
  if (LinearGrayProfile) {
    CFRelease(LinearGrayProfile);
  }
  if (v1)
  {
    v1[10] = @"kCGColorSpaceLinearGray";
    *((_DWORD *)v1 + 5) = 3;
    *(void *)(v1[12] + 48) = @"Linear Gray";
  }
  return v1;
}

void *color_space_state_create_itur_2100_PQ()
{
  if (color_space_state_create_itur_2100_PQ_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_itur_2100_PQ_cglibrarypredicate, &__block_literal_global_218);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_itur_2100_PQ_f;
  if (color_space_state_create_itur_2100_PQ_cglibrarypredicate_219 != -1) {
    dispatch_once(&color_space_state_create_itur_2100_PQ_cglibrarypredicate_219, &__block_literal_global_222);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_itur_2100_PQ_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceITUR_2100_PQ";
    *((_DWORD *)v2 + 5) = 28;
    *(void *)(v2[12] + 48) = @"Rec. ITU-R BT.2100 PQ";
    if (should_allow_as_output_space_predicate != -1) {
      dispatch_once(&should_allow_as_output_space_predicate, &__block_literal_global_308_1782);
    }
    if (!should_allow_as_output_space_should_allow) {
      *((unsigned char *)v2 + 10) = 0;
    }
  }
  return v2;
}

void *color_space_state_create_itur_2100_HLG()
{
  if (color_space_state_create_itur_2100_HLG_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_itur_2100_HLG_cglibrarypredicate, &__block_literal_global_229);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_itur_2100_HLG_f;
  if (color_space_state_create_itur_2100_HLG_cglibrarypredicate_230 != -1) {
    dispatch_once(&color_space_state_create_itur_2100_HLG_cglibrarypredicate_230, &__block_literal_global_233);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_itur_2100_HLG_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceITUR_2100_HLG";
    *((_DWORD *)v2 + 5) = 29;
    *(void *)(v2[12] + 48) = @"Rec. ITU-R BT.2020 HLG";
    if (should_allow_as_output_space_predicate != -1) {
      dispatch_once(&should_allow_as_output_space_predicate, &__block_literal_global_308_1782);
    }
    if (!should_allow_as_output_space_should_allow) {
      *((unsigned char *)v2 + 10) = 0;
    }
  }
  return v2;
}

void *color_space_state_create_itur_2020_sRGB_gamma()
{
  if (color_space_state_create_itur_2020_sRGB_gamma_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_itur_2020_sRGB_gamma_cglibrarypredicate, &__block_literal_global_191);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_itur_2020_sRGB_gamma_f;
  if (color_space_state_create_itur_2020_sRGB_gamma_cglibrarypredicate_192 != -1) {
    dispatch_once(&color_space_state_create_itur_2020_sRGB_gamma_cglibrarypredicate_192, &__block_literal_global_195);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_itur_2020_sRGB_gamma_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceITUR_2020_sRGBGamma";
    *((_DWORD *)v2 + 5) = 27;
    *(void *)(v2[12] + 48) = @"Rec. ITU-R BT.2020-1; sRGB Gamma";
  }
  return v2;
}

void *color_space_state_create_generic_rgb_linear()
{
  if (CGCMSUtilsCreateDataForGenericHDR_once != -1) {
    dispatch_once(&CGCMSUtilsCreateDataForGenericHDR_once, &__block_literal_global_67);
  }
  if (CGCMSUtilsCreateDataForGenericHDR_cglibrarypredicate != -1) {
    dispatch_once(&CGCMSUtilsCreateDataForGenericHDR_cglibrarypredicate, &__block_literal_global_106);
  }
  DataForGenericHDR_f = (const void *)CGCMSUtilsCreateDataForGenericHDR_f(CGCMSUtilsCreateDataForGenericHDR_profileSpec);
  if (CGCMSUtilsCreateDataForGenericHDR_cglibrarypredicate_109 != -1) {
    dispatch_once(&CGCMSUtilsCreateDataForGenericHDR_cglibrarypredicate_109, &__block_literal_global_112);
  }
  CFDataRef DataForGenericHDR_f_108 = (const __CFData *)CGCMSUtilsCreateDataForGenericHDR_f_108(DataForGenericHDR_f, 0);
  if (DataForGenericHDR_f) {
    CFRelease(DataForGenericHDR_f);
  }
  if (!DataForGenericHDR_f_108) {
    return 0;
  }
  icc_with_datdouble a = color_space_state_create_icc_with_data(DataForGenericHDR_f_108);
  uint64_t v3 = icc_with_data;
  if (icc_with_data)
  {
    icc_with_data[10] = @"kCGColorSpaceGenericRGBLinear";
    *(void *)(icc_with_data[12] + 48) = @"Generic HDR Profile";
  }
  CFRelease(DataForGenericHDR_f_108);
  return v3;
}

void *color_space_state_create_adobe_rgb_1998()
{
  if (color_space_state_create_adobe_rgb_1998_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_adobe_rgb_1998_cglibrarypredicate, &__block_literal_global_103);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_adobe_rgb_1998_f;
  if (color_space_state_create_adobe_rgb_1998_cglibrarypredicate_104 != -1) {
    dispatch_once(&color_space_state_create_adobe_rgb_1998_cglibrarypredicate_104, &__block_literal_global_107_1796);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_adobe_rgb_1998_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceAdobeRGB1998";
    *((_DWORD *)v2 + 5) = 14;
    *(void *)(v2[12] + 48) = @"Adobe RGB (1998)";
  }
  return v2;
}

CFTypeRef CGCMSUtilsCreateLinearGrayProfile()
{
  if (CGCMSUtilsCreateLinearGrayProfile_once != -1) {
    dispatch_once(&CGCMSUtilsCreateLinearGrayProfile_once, &__block_literal_global_246);
  }
  CFTypeRef result = (CFTypeRef)CGCMSUtilsCreateLinearGrayProfile_linear_profile;
  if (CGCMSUtilsCreateLinearGrayProfile_linear_profile)
  {
    return CFRetain(result);
  }
  return result;
}

void *color_space_state_create_linear_display_p3()
{
  LinearDisplayP3Profile = CGCMSUtilsCreateLinearDisplayP3Profile();
  uint64_t v1 = create_from_profile(LinearDisplayP3Profile, 0);
  if (LinearDisplayP3Profile) {
    CFRelease(LinearDisplayP3Profile);
  }
  if (v1)
  {
    v1[10] = @"kCGColorSpaceLinearDisplayP3";
    *((_DWORD *)v1 + 5) = 9;
    *(void *)(v1[12] + 48) = @"Display P3 Linear";
  }
  return v1;
}

void *color_space_state_create_generic_xyz()
{
  if (color_space_state_create_generic_xyz_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_generic_xyz_cglibrarypredicate, &__block_literal_global_125_1803);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_generic_xyz_f;
  if (color_space_state_create_generic_xyz_cglibrarypredicate_126 != -1) {
    dispatch_once(&color_space_state_create_generic_xyz_cglibrarypredicate_126, &__block_literal_global_129_1804);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_generic_xyz_s);
  uint64_t v2 = create_from_profile(v1, 1);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceGenericXYZ";
    *((_DWORD *)v2 + 5) = 6;
    *((_DWORD *)v2 + 7) = 7;
    *(void *)(v2[12] + 48) = @"Generic XYZ Profile";
  }
  return v2;
}

void *color_space_state_create_core_media_709()
{
  if (color_space_state_create_core_media_709_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_core_media_709_cglibrarypredicate, &__block_literal_global_293);
  }
  uint64_t v0 = (uint64_t (*)(uint64_t))color_space_state_create_core_media_709_f;
  if (color_space_state_create_core_media_709_cglibrarypredicate_294 != -1) {
    dispatch_once(&color_space_state_create_core_media_709_cglibrarypredicate_294, &__block_literal_global_297_1845);
  }
  uint64_t v1 = (void *)v0(color_space_state_create_core_media_709_s);
  uint64_t v2 = create_from_profile(v1, 0);
  if (v1) {
    CFRelease(v1);
  }
  if (v2)
  {
    v2[10] = @"kCGColorSpaceCoreMedia709";
    *((_DWORD *)v2 + 5) = 32;
    *(void *)(v2[12] + 48) = @"HGTV";
  }
  return v2;
}

CFTypeRef CGCMSUtilsCreateLinearDisplayP3Profile()
{
  if (CGCMSUtilsCreateLinearDisplayP3Profile_once != -1) {
    dispatch_once(&CGCMSUtilsCreateLinearDisplayP3Profile_once, &__block_literal_global_259);
  }
  CFTypeRef result = (CFTypeRef)CGCMSUtilsCreateLinearDisplayP3Profile_linear_profile;
  if (CGCMSUtilsCreateLinearDisplayP3Profile_linear_profile)
  {
    return CFRetain(result);
  }
  return result;
}

void CGImageProviderSetProperty(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  if (!a1 || !cf1 || !a3) {
    return;
  }
  if (CFEqual(cf1, @"kCGImageProviderAlphaIsOne") == 1)
  {
    if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFD0]))
    {
      char v6 = 1;
    }
    else
    {
      if (!CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFC8])) {
        goto LABEL_11;
      }
      char v6 = 0;
    }
    *(unsigned char *)(a1 + 130) = v6;
  }
LABEL_11:
  if (!*(void *)(a1 + 120))
  {
    uint64_t v7 = (CFTypeRef *)CGPropertiesCreate();
    uint64_t v8 = 0;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 120), (unint64_t *)&v8, (unint64_t)v7, memory_order_relaxed, memory_order_relaxed);
    if (v8) {
      CGPropertiesRelease(v7);
    }
  }
  uint64_t v9 = *(void *)(a1 + 120);

  CGPropertiesSetProperty(v9, cf1, a3);
}

void CGImageSetProperty(uint64_t a1, CFStringRef theString1, const void *a3)
{
  if (a1 && theString1 && a3)
  {
    if (CFStringCompare(theString1, @"com.apple.ImageIO.orientation", 0))
    {
      if (!*(void *)(a1 + 216))
      {
        char v6 = (CFTypeRef *)CGPropertiesCreate();
        uint64_t v7 = 0;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 216), (unint64_t *)&v7, (unint64_t)v6, memory_order_relaxed, memory_order_relaxed);
        if (v7) {
          CGPropertiesRelease(v6);
        }
      }
      uint64_t v8 = *(void *)(a1 + 216);
      CGPropertiesSetProperty(v8, theString1, a3);
    }
    else
    {
      int valuePtr = 0;
      CFTypeID v9 = CFGetTypeID(a3);
      if (v9 == CFNumberGetTypeID()
        && CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, &valuePtr)
        && valuePtr >= 1
        && valuePtr <= 8)
      {
        *(unsigned char *)(a1 + 38) = valuePtr;
      }
      else
      {
        CGLog(1, (uint64_t)"%s %s", v10, v11, v12, v13, v14, v15, (char)"CGImageSetProperty");
      }
    }
  }
}

_DWORD *CGPropertiesCreate()
{
  uint64_t v0 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
  v0[1] = 0;
  _DWORD *v0 = 1;
  *((void *)v0 + 1) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  return v0;
}

BOOL CGFontGetGlyphAdvances(CGFontRef font, const CGGlyph *glyphs, size_t count, int *advances)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  ((void (*)(CGFontRef))MEMORY[0x1F4188790])(font);
  uint64_t v10 = (double *)((char *)&v18[-1] - v8 - 7);
  if (v9 <= 0xFFFFFFFFFFFFFFELL) {
    uint64_t v11 = (double *)((char *)&v18[-1] - v8 - 7);
  }
  else {
    uint64_t v11 = 0;
  }
  if (v9 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000042) {
    uint64_t v11 = (double *)malloc_type_malloc(16 * count, 0xC28E7C8AuLL);
  }
  if (!v11) {
    return 0;
  }
  if (font
    && ((font_info = get_font_info(font)) == 0 ? (BOOL v13 = 1) : (BOOL v13 = font_info[104] == 0),
        (*(unsigned int (**)(void, void, BOOL, const CGGlyph *, size_t, double *))(*((void *)font + 2)
                                                                                                  + 304))(*((void *)font + 14), 0, v13, glyphs, count, v11)))
  {
    if (count)
    {
      uint64_t v15 = v11;
      do
      {
        double v16 = *v15;
        v15 += 2;
        *advances++ = (int)v16;
        --count;
      }
      while (count);
    }
    BOOL v17 = 1;
    BOOL result = 1;
  }
  else
  {
    BOOL v17 = 0;
    BOOL result = 0;
  }
  if (v11 != v10)
  {
    free(v11);
    return v17;
  }
  return result;
}

uint64_t get_glyph_advances(void *a1, float64x2_t *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __n128 a7)
{
  uint64_t result = 0;
  if (a1)
  {
    unint64_t v9 = (float64x2_t *)a6;
    if (a6)
    {
      unint64_t v10 = a5;
      uint64_t v11 = a4;
      if (a4 || !a5)
      {
        if (a5)
        {
          if (a3)
          {
            get_glyph_ideal_advances(a1, a4, a5, a6, a7);
            if (a2)
            {
              float64x2_t v17 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)FPFontGetUnitsPerEm()), 0);
              float64x2_t v18 = vdivq_f64(*a2, v17);
              float64x2_t v19 = vdivq_f64(a2[1], v17);
              char v20 = (double *)v9;
              unint64_t v21 = v10;
              do
              {
                *(float64x2_t *)char v20 = vmlaq_n_f64(vmulq_n_f64(v19, v20[1]), v18, *v20);
                v20 += 2;
                --v21;
              }
              while (v21);
            }
            if ((a3 & 4) == 0)
            {
              if (v10 <= 1) {
                uint64_t v22 = 1;
              }
              else {
                uint64_t v22 = v10;
              }
              do
              {
                *unint64_t v9 = vrndaq_f64(*v9);
                ++v9;
                --v22;
              }
              while (v22);
            }
          }
          else
          {
            uint64_t v14 = (void *)(a6 + 8);
            do
            {
              v11 += 2;
              FPFontGetGlyphDeviceAdvance();
              *(v14 - 1) = v15;
              *uint64_t v14 = v16;
              v14 += 2;
              --v10;
            }
            while (v10);
          }
        }
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void get_glyph_ideal_advances(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, __n128 a5)
{
  v33[64] = *MEMORY[0x1E4F143B8];
  v29[1] = a1[1];
  uint64_t v7 = a1 + 2;
  explicit = (unsigned __int16 *)atomic_load_explicit(a1 + 2, memory_order_acquire);
  uint64_t v31 = a4;
  if (!explicit)
  {
    a1 = malloc_type_calloc(1uLL, 0x208uLL, 0x1080040036EC52CuLL);
    explicit = (unsigned __int16 *)a1;
    unint64_t v9 = 0;
    *(_WORD *)a1 = 0x7FFF;
    atomic_compare_exchange_strong(v7, (unint64_t *)&v9, (unint64_t)a1);
    if (v9)
    {
      CGFontIndexMapRelease((char *)a1);
      explicit = v9;
    }
    a4 = v31;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  size_t v30 = 10 * a3;
  uint64_t v12 = (double *)(a4 + 8);
  BOOL v13 = &v32;
  uint64_t v14 = v33;
  do
  {
    unint64_t v15 = *(unsigned __int16 *)(a2 + 2 * v10);
    if (v15 == 0xFFFF)
    {
      int v16 = 0;
      goto LABEL_20;
    }
    int v16 = *(unsigned __int16 *)(a2 + 2 * v10);
    if (explicit != (unsigned __int16 *)-1)
    {
      if (!explicit)
      {
        int v16 = -1;
LABEL_20:
        a5.n128_f64[0] = (double)v16;
        *(v12 - 1) = (double)v16;
        *uint64_t v12 = 0.0;
        goto LABEL_21;
      }
      unint64_t v17 = atomic_load((unint64_t *)((char *)explicit + ((v15 >> 7) & 0x1F8) + 8));
      if (v17) {
        int v16 = *(unsigned __int16 *)(v17 + 2 * (v15 & 0x3FF));
      }
      else {
        int v16 = *explicit;
      }
    }
    if (v16 != 0x7FFF)
    {
      int v16 = (__int16)v16;
      goto LABEL_20;
    }
    if (a3 >= 0x41 && !v11)
    {
      a1 = malloc_type_malloc(v30, 0x2855D78CuLL);
      uint64_t v14 = a1;
      BOOL v13 = &a1[a3];
    }
    v14[v11] = v10;
    *((_WORD *)v13 + v11++) = v15;
LABEL_21:
    ++v10;
    v12 += 2;
  }
  while (a3 != v10);
  if (v11)
  {
    size_t v30 = (size_t)v29;
    MEMORY[0x1F4188790](a1, a5);
    char v20 = (char *)v29 - v19;
    if (v18 <= 0x1FFFFFFFFFFFFFFELL) {
      unint64_t v21 = (char *)v29 - v19;
    }
    else {
      unint64_t v21 = 0;
    }
    if (v18 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000042) {
      unint64_t v21 = (char *)malloc_type_malloc(8 * v11, 0xC135E911uLL);
    }
    FPFontGetGlyphIdealAdvanceWidths();
    uint64_t v22 = 0;
    uint64_t v23 = v31;
    do
    {
      uint64_t v24 = v14[v22];
      double v25 = *(double *)&v21[8 * v22];
      if (v25 != 32767.0 && v25 >= -32768.0 && v25 <= 32767.0)
      {
        double v27 = (double)(int)v25;
        if (v25 == v27)
        {
          CGFontIndexMapAddIndex(explicit, *(unsigned __int16 *)(a2 + 2 * v24), (int)v25);
          uint64_t v23 = v31;
          double v25 = v27;
        }
      }
      uint64_t v28 = v23 + 16 * v24;
      *(double *)uint64_t v28 = v25;
      *(void *)(v28 + 8) = 0;
      ++v22;
    }
    while (v11 != v22);
    if (v21 != v20) {
      free(v21);
    }
    if (v14 != v33) {
      free(v14);
    }
  }
}

unsigned __int16 *CGFontIndexMapAddIndex(unsigned __int16 *result, unsigned int a2, unsigned __int16 a3)
{
  if ((unint64_t)result + 1 >= 2)
  {
    __int16 v4 = a2;
    CFDataRef v5 = result;
    char v6 = (atomic_ullong *)&result[4 * (a2 >> 10) + 4];
    uint64_t result = (unsigned __int16 *)atomic_load_explicit(v6, memory_order_acquire);
    if (!result)
    {
      uint64_t result = (unsigned __int16 *)malloc_type_malloc(0x800uLL, 0x1000040BDFB0063uLL);
      for (uint64_t i = 0; i != 1024; ++i)
        atomic_store(*v5, &result[i]);
      uint64_t v8 = 0;
      atomic_compare_exchange_strong(v6, (unint64_t *)&v8, (unint64_t)result);
      if (v8)
      {
        free(result);
        uint64_t result = v8;
      }
    }
    result[v4 & 0x3FF] = a3;
  }
  return result;
}

uint64_t CGContextDelegateGetOwnerIdentity(uint64_t a1)
{
  return *(unsigned int *)(a1 + 280);
}

void CGCIDInfoRelease(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void **)(a1 + 72);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = *(const void **)(a1 + 80);
    if (v3) {
      CFRelease(v3);
    }
    CGFontIndexMapRelease(*(char **)(a1 + 96));
    CGFontIndexMapRelease(*(char **)(a1 + 104));
    pthread_mutex_destroy((pthread_mutex_t *)a1);
    free((void *)a1);
  }
}

void CGGStateSetLineDash(uint64_t a1, atomic_uint *a2)
{
  if (!CGDashEqualToDash(*(void *)(*(void *)(a1 + 128) + 32), (uint64_t)a2))
  {
    maybe_copy_stroke_state(a1);
    __int16 v4 = *(void **)(*(void *)(a1 + 128) + 32);
    if (v4 && atomic_fetch_add_explicit((atomic_uint *volatile)v4, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(v4);
    }
    if (a2) {
      atomic_fetch_add_explicit(a2, 1u, memory_order_relaxed);
    }
    *(void *)(*(void *)(a1 + 128) + 32) = a2;
  }
}

BOOL CGDashEqualToDash(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*(double *)(a1 + 8) == *(double *)(a2 + 8) && (uint64_t v3 = *(void *)(a1 + 16), v3 == *(void *)(a2 + 16))) {
      return memcmp((const void *)(a1 + 24), (const void *)(a2 + 24), 8 * v3) == 0;
    }
    else {
      return 0;
    }
  }
  return v2;
}

uint64_t CGImageProviderGetCallbackVersion(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 64);
  }
  return result;
}

void function_finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 96);
  if (v2) {
    CFRelease(v2);
  }
  CGPropertiesRelease(*(CFTypeRef **)(a1 + 104));
  uint64_t v3 = *(void (**)(void))(a1 + 80);
  if (v3) {
    v3(*(void *)(a1 + 24));
  }
  __int16 v4 = *(void **)(a1 + 40);
  if (v4) {
    free(v4);
  }
  CFDataRef v5 = *(void **)(a1 + 56);
  if (v5)
  {
    free(v5);
  }
}

void gradient_release_info(CFTypeRef *a1)
{
  CFRelease(*a1);

  free(a1);
}

size_t CGBitmapContextGetBitsPerPixel(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(void *)(*((void *)context + 4) + 72);
  }
  handle_invalid_context((char)"CGBitmapContextGetBitsPerPixel", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

size_t CGBitmapContextGetBitsPerComponent(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(void *)(*((void *)context + 4) + 80);
  }
  handle_invalid_context((char)"CGBitmapContextGetBitsPerComponent", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

uint64_t __get_session_key_block_invoke()
{
  return pthread_key_create((pthread_key_t *)&get_session_key_session_key, 0);
}

void colorsync_transform_data_value_release(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void colorsync_transform_data_key_release(void *a1)
{
  if (a1) {
    free(a1);
  }
}

double CGFontGetUnderlineThickness(void *a1)
{
  font_info = (double *)get_font_info(a1);
  if (font_info) {
    return font_info[9];
  }
  else {
    return 0.0;
  }
}

double CGFontGetUnderlinePosition(void *a1)
{
  font_info = (double *)get_font_info(a1);
  if (font_info) {
    return font_info[8];
  }
  else {
    return 0.0;
  }
}

os_unfair_lock_s *CGFontNameTableCopyRootName(os_unfair_lock_s *result, unsigned int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFLocaleRef System = CFLocaleGetSystem();
    return (os_unfair_lock_s *)copy_localized_value(v3, System, a2);
  }
  return result;
}

uint64_t CGImageTextureDataGetOffsetWithBlock(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
  {
    if (a5)
    {
      uint64_t v6 = result;
      uint64_t v7 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(result + 40);
      if (v7)
      {
        char v8 = a2;
        double v9 = *(double *)(result + 72);
        double v10 = *(double *)(result + 80);
        unint64_t v11 = *(void *)(result + 88);
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        uint64_t v15 = 0;
        uint64_t v12 = v7(*(void *)(result + 24), a2, a3, &v17, &v16, &v15, a4);
        if (v12)
        {
          uint64_t v13 = v12;
          ERROR_CGDataProvider_BufferIsNotReadable();
          if (v15)
          {
            ERROR_CGDataProvider_BufferIsNotBigEnough();
            uint64_t v14 = v15;
          }
          else
          {
            uint64_t v14 = 0;
          }
          (*(void (**)(uint64_t, unint64_t, unint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 16))(a5, (unint64_t)v9 >> v8, (unint64_t)v10 >> v8, v11 >> v8, v13, v17, v16, v14);
        }
        return (*(uint64_t (**)(void))(v6 + 48))(*(void *)(v6 + 24));
      }
    }
  }
  return result;
}

CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef path, const CGAffineTransform *transform, CGFloat lineWidth, CGLineCap lineCap, CGLineJoin lineJoin, CGFloat miterLimit)
{
  if (!path) {
    return 0;
  }
  uint64_t v11 = *(void *)&lineJoin;
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v16 = CFGetTypeID(path);
    if (v16 != CGPathGetTypeID()) {
      return 0;
    }
  }
  CFTypeID TypeID = CGPathGetTypeID();
  uint64_t Instance = CGTypeCreateInstance(TypeID, 128, v18, v19, v20, v21, v22, v23);
  uint64_t v28 = (const CGPath *)Instance;
  if (Instance)
  {
    int v29 = CG::Path::Path((CG::Path *)(Instance + 16), (CGPathRef)((char *)path + 16), lineWidth, lineCap, v11, miterLimit, 0.0, 0, v25, v26, v27);
    if (transform) {
      CG::Path::apply_transform(v29, transform, v30, v31, v32, v33, v34, v35);
    }
  }
  return v28;
}

uint64_t ClipperLib::ClipperBase::AddPath(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 == 1 && (a4 & 1) == 0)
  {
    exception = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
    ClipperLib::clipperException::clipperException(exception, "AddPath: Open paths must be subject.");
  }
  uint64_t v4 = *(void **)a2;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  LODWORD(v6) = v5 - 1;
  if (a4 && (int)v5 >= 2)
  {
    LODWORD(v6) = -1431655765 * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
    while (1)
    {
      unint64_t v6 = (v6 - 1);
      if (v5 <= v6) {
        break;
      }
      uint64_t v7 = &v4[6 * v6];
      uint64_t v9 = *v7;
      uint64_t v8 = v7[1];
      if (v9 != *v4 || v8 != v4[1]) {
        goto LABEL_14;
      }
      if ((int)v6 <= 1)
      {
        LODWORD(v6) = 0;
        goto LABEL_14;
      }
    }
LABEL_24:
    __break(1u);
  }
  else
  {
LABEL_14:
    int v11 = v6 & ((int)v6 >> 31);
    while (1)
    {
      unint64_t v12 = (v6 - 1);
      if ((int)v6 < 1) {
        break;
      }
      if (v5 <= v6 || v5 <= v12) {
        goto LABEL_24;
      }
      int32x2_t v13 = vmovn_s64(vceqq_s64(*(int64x2_t *)&v4[6 * v6], *(int64x2_t *)&v4[6 * v12]));
      LODWORD(v6) = v6 - 1;
      if ((v13.i32[0] & v13.i32[1] & 1) == 0)
      {
        int v11 = v12 + 1;
        break;
      }
    }
    if (v11 > a4)
    {
      is_mul_ok(v11 + 1, 0xE8uLL);
      operator new[]();
    }
    return 0;
  }
  return result;
}

void sub_184C8FEA8(_Unwind_Exception *a1)
{
}

void sub_184C8FEB4(void *a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x184C8FEBCLL);
  }
  __clang_call_terminate(a1);
}

BOOL ClipperLib::SlopesEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a7)
  {
    ClipperLib::Int128Mul(v14, a2 - a4, a3 - a5);
    ClipperLib::Int128Mul(v13, a1 - a3, a4 - a6);
    return v14[1] == v13[1] && v14[0] == v13[0];
  }
  else
  {
    return (a3 - a5) * (a2 - a4) == (a4 - a6) * (a1 - a3);
  }
}

uint64_t ClipperLib::RangeTest(uint64_t result, uint64_t a2, unsigned char *a3)
{
  if (!*a3)
  {
    if (result <= 0x3FFFFFFF && result >= -1073741823 && (unint64_t)(a2 - 0x40000000) >= 0xFFFFFFFF80000001) {
      return result;
    }
    *a3 = 1;
  }
  if (result > 0x3FFFFFFFFFFFFFFFLL
    || result < (uint64_t)0xC000000000000001
    || (unint64_t)(a2 - 0x4000000000000000) <= 0x8000000000000000)
  {
    exception = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
    ClipperLib::clipperException::clipperException(exception, "Coordinate outside allowed range");
  }
  return result;
}

void sub_184C9001C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t ClipperLib::Pt2IsBetweenPt1AndPt3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a1 == a5 && a2 == a6 || a1 == a3 && a2 == a4 || a5 == a3 && a6 == a4) {
    return 0;
  }
  if (a1 == a5) {
    return (a4 <= a2) ^ (a4 < a6);
  }
  return (a3 <= a1) ^ (a3 < a5);
}

uint64_t ClipperLib::ClipperBase::ProcessBound(void *a1, uint64_t *a2, int a3, __n128 a4)
{
  if (*((_DWORD *)a2 + 43) == -2)
  {
    unint64_t v5 = (double *)a2;
    if (a3)
    {
      do
      {
        unint64_t v6 = v5;
        uint64_t v7 = *((void *)v5 + 13);
        unint64_t v5 = (double *)*((void *)v5 + 22);
      }
      while (v7 == *((void *)v5 + 1));
      if (v6 == (double *)a2) {
        goto LABEL_27;
      }
      a4.n128_u64[0] = 0xC83D6329F1C35CA5;
      while (v6[18] == -1.0e40)
      {
        unint64_t v6 = (double *)*((void *)v6 + 23);
        if (v6 == (double *)a2) {
          goto LABEL_27;
        }
      }
    }
    else
    {
      do
      {
        unint64_t v6 = v5;
        uint64_t v8 = *((void *)v5 + 13);
        unint64_t v5 = (double *)*((void *)v5 + 23);
      }
      while (v8 == *((void *)v5 + 1));
      if (v6 == (double *)a2) {
        goto LABEL_27;
      }
      a4.n128_u64[0] = 0xC83D6329F1C35CA5;
      while (v6[18] == -1.0e40)
      {
        unint64_t v6 = (double *)*((void *)v6 + 22);
        if (v6 == (double *)a2) {
          goto LABEL_27;
        }
      }
    }
    if (v6 != (double *)a2)
    {
      uint64_t v13 = 23;
      if (a3) {
        uint64_t v13 = 22;
      }
      uint64_t v14 = a2[v13];
      uint64_t v15 = *(void *)(v14 + 8);
      *(_DWORD *)(v14 + 160) = 0;
      uint64_t v16 = ClipperLib::ClipperBase::ProcessBound(a1, v14, a4);
      uint64_t v18 = (void *)a1[3];
      unint64_t v17 = a1[4];
      if ((unint64_t)v18 >= v17)
      {
        uint64_t v53 = a1[2];
        unint64_t v54 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - v53) >> 3);
        unint64_t v55 = v54 + 1;
        if (v54 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - v53) >> 3);
        if (2 * v56 > v55) {
          unint64_t v55 = 2 * v56;
        }
        if (v56 >= 0x555555555555555) {
          unint64_t v57 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v57 = v55;
        }
        if (v57) {
          unint64_t v57 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v57);
        }
        else {
          uint64_t v58 = 0;
        }
        uint64_t v59 = (void *)(v57 + 24 * v54);
        unint64_t v60 = v57 + 24 * v58;
        *uint64_t v59 = v15;
        v59[1] = 0;
        v59[2] = v14;
        uint64_t v19 = v59 + 3;
        uint64_t v62 = (char *)a1[2];
        uint64_t v61 = (char *)a1[3];
        if (v61 != v62)
        {
          do
          {
            long long v63 = *(_OWORD *)(v61 - 24);
            *(v59 - 1) = *((void *)v61 - 1);
            *(_OWORD *)(v59 - 3) = v63;
            v59 -= 3;
            v61 -= 24;
          }
          while (v61 != v62);
          uint64_t v61 = (char *)a1[2];
        }
        a1[2] = v59;
        a1[3] = v19;
        a1[4] = v60;
        if (v61) {
          operator delete(v61);
        }
      }
      else
      {
        *uint64_t v18 = v15;
        v18[1] = 0;
        uint64_t v19 = v18 + 3;
        void v18[2] = v14;
      }
      a1[3] = v19;
      return v16;
    }
LABEL_27:
    if (a3) {
      return a2[22];
    }
    else {
      return a2[23];
    }
  }
  if (*((double *)a2 + 18) == -1.0e40)
  {
    uint64_t v9 = 22;
    if (a3) {
      uint64_t v9 = 23;
    }
    double v10 = (double *)a2[v9];
    double v11 = *v10;
    double v12 = *(double *)a2;
    if (v10[18] == -1.0e40)
    {
      if (*(void *)&v11 == *(void *)&v12 || *((void *)v10 + 12) == *(void *)&v12) {
        goto LABEL_32;
      }
      goto LABEL_31;
    }
    if (*(void *)&v11 != *(void *)&v12)
    {
LABEL_31:
      uint64_t v20 = a2[12];
      *((double *)a2 + 12) = v12;
      *a2 = v20;
      long long v22 = *((_OWORD *)a2 + 7);
      long long v21 = *((_OWORD *)a2 + 8);
      long long v23 = *((_OWORD *)a2 + 2);
      *((_OWORD *)a2 + 7) = *((_OWORD *)a2 + 1);
      *((_OWORD *)a2 + 8) = v23;
      *((_OWORD *)a2 + 1) = v22;
      *((_OWORD *)a2 + 2) = v21;
    }
  }
LABEL_32:
  uint64_t v24 = a2;
  if (a3)
  {
    do
    {
      uint64_t v25 = v24;
      uint64_t v26 = v24[13];
      uint64_t v24 = (uint64_t *)v24[22];
    }
    while (v26 == v24[1] && *((_DWORD *)v24 + 43) != -2);
    if (*((double *)v25 + 18) == -1.0e40 && *((_DWORD *)v24 + 43) != -2)
    {
      uint64_t v27 = (double *)v25;
      do
        uint64_t v27 = (double *)*((void *)v27 + 23);
      while (v27[18] == -1.0e40);
      if (*((void *)v27 + 12) > v24[12]) {
        uint64_t v25 = (uint64_t *)v27;
      }
    }
    if (v25 != a2)
    {
      uint64_t v28 = a2;
      do
      {
        int v29 = (uint64_t *)v28[22];
        v28[24] = (uint64_t)v29;
        if (v28 != a2 && *((double *)v28 + 18) == -1.0e40 && *v28 != *(void *)(v28[23] + 96))
        {
          uint64_t v30 = v28[12];
          v28[12] = *v28;
          *uint64_t v28 = v30;
          long long v32 = *((_OWORD *)v28 + 7);
          long long v31 = *((_OWORD *)v28 + 8);
          long long v33 = *((_OWORD *)v28 + 2);
          *((_OWORD *)v28 + 7) = *((_OWORD *)v28 + 1);
          *((_OWORD *)v28 + 8) = v33;
          *((_OWORD *)v28 + 1) = v32;
          *((_OWORD *)v28 + 2) = v31;
        }
        uint64_t v28 = v29;
      }
      while (v29 != v25);
      if (*((double *)v25 + 18) == -1.0e40 && *v25 != *(void *)(v25[23] + 96))
      {
        uint64_t v34 = v25[12];
        v25[12] = *v25;
        uint64_t *v25 = v34;
        long long v36 = *((_OWORD *)v25 + 7);
        long long v35 = *((_OWORD *)v25 + 8);
        long long v37 = *((_OWORD *)v25 + 2);
        *((_OWORD *)v25 + 7) = *((_OWORD *)v25 + 1);
        *((_OWORD *)v25 + 8) = v37;
        *((_OWORD *)v25 + 1) = v36;
        *((_OWORD *)v25 + 2) = v35;
      }
    }
    CFDictionaryRef v38 = v25 + 22;
  }
  else
  {
    do
    {
      CFDictionaryRef v39 = v24;
      uint64_t v40 = v24[13];
      uint64_t v24 = (uint64_t *)v24[23];
    }
    while (v40 == v24[1] && *((_DWORD *)v24 + 43) != -2);
    if (*((double *)v39 + 18) == -1.0e40 && *((_DWORD *)v24 + 43) != -2)
    {
      BOOL v41 = (double *)v39;
      do
        BOOL v41 = (double *)*((void *)v41 + 22);
      while (v41[18] == -1.0e40);
      if (*((void *)v41 + 12) >= v24[12]) {
        CFDictionaryRef v39 = (uint64_t *)v41;
      }
    }
    if (v39 != a2)
    {
      uint64_t v42 = a2;
      do
      {
        uint64_t v43 = (uint64_t *)v42[23];
        v42[24] = (uint64_t)v43;
        if (v42 != a2 && *((double *)v42 + 18) == -1.0e40 && *v42 != *(void *)(v42[22] + 96))
        {
          uint64_t v44 = v42[12];
          v42[12] = *v42;
          *uint64_t v42 = v44;
          long long v46 = *((_OWORD *)v42 + 7);
          long long v45 = *((_OWORD *)v42 + 8);
          long long v47 = *((_OWORD *)v42 + 2);
          *((_OWORD *)v42 + 7) = *((_OWORD *)v42 + 1);
          *((_OWORD *)v42 + 8) = v47;
          *((_OWORD *)v42 + 1) = v46;
          *((_OWORD *)v42 + 2) = v45;
        }
        uint64_t v42 = v43;
      }
      while (v43 != v39);
      if (*((double *)v39 + 18) == -1.0e40 && *v39 != *(void *)(v39[22] + 96))
      {
        uint64_t v48 = v39[12];
        v39[12] = *v39;
        *CFDictionaryRef v39 = v48;
        long long v50 = *((_OWORD *)v39 + 7);
        long long v49 = *((_OWORD *)v39 + 8);
        long long v51 = *((_OWORD *)v39 + 2);
        *((_OWORD *)v39 + 7) = *((_OWORD *)v39 + 1);
        *((_OWORD *)v39 + 8) = v51;
        *((_OWORD *)v39 + 1) = v50;
        *((_OWORD *)v39 + 2) = v49;
      }
    }
    CFDictionaryRef v38 = v39 + 23;
  }
  return *v38;
}

uint64_t CGPathCreateDashedPath(char *cf, _anonymous_namespace_ *this, const double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  if (!cf) {
    return 0;
  }
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 != CGPathGetTypeID()) {
      return 0;
    }
  }
  CFTypeID TypeID = CGPathGetTypeID();
  uint64_t Instance = CGTypeCreateInstance(TypeID, 128, v16, v17, v18, v19, v20, v21);
  uint64_t v26 = Instance;
  if (Instance) {
    CG::Path::Path((CG::Path *)(Instance + 16), (const CG::Path *)(cf + 16), a9, a3, a4, (const CGAffineTransform *)this, v23, v24, v25);
  }
  return v26;
}

uint64_t CGPathCreateStrokedPath(char *cf, _anonymous_namespace_ *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11)
{
  if (!cf) {
    return 0;
  }
  CGLineCap v14 = (int)a3;
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v18 = CFGetTypeID(cf);
    if (v18 != CGPathGetTypeID()) {
      return 0;
    }
  }
    return 0;
  CFTypeID TypeID = CGPathGetTypeID();
  uint64_t Instance = CGTypeCreateInstance(TypeID, 128, v20, v21, v22, v23, v24, v25);
  uint64_t v30 = Instance;
  if (Instance) {
    CG::Path::Path((CG::Path *)(Instance + 16), (const CG::Path *)(cf + 16), a9, v14, a4, a10, a11, (const CGAffineTransform *)this, v27, v28, v29);
  }
  return v30;
}

CG::Path *CG::Path::Path(CG::Path *this, const CG::Path *a2, double a3, const double *a4, uint64_t a5, const CGAffineTransform *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_DWORD *)this = 8;
  if (a5 && a4 && (*(_DWORD *)a2 - 10) > 0xFFFFFFF6) {
    operator new();
  }
  CG::Path::append(this, a2, a6, a5, (uint64_t)a6, a7, a8, a9);
  return this;
}

CG::Path *CG::Path::Path(CG::Path *this, const CG::Path *a2, double a3, CGLineCap a4, uint64_t a5, double a6, double a7, const CGAffineTransform *a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  *(_DWORD *)this = 8;
  if ((*(_DWORD *)a2 - 10) > 0xFFFFFFF6) {
    operator new();
  }
  CG::Path::append(this, a2, a8, a5, (uint64_t)a8, a9, a10, a11);
  return this;
}

void ripr_stroke_acquire(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(_OWORD **)(a1 + 72);
  if (v3)
  {
    uint64_t v3 = (_OWORD *)(a2 + 24);
    float v4 = *(float *)(a1 + 52);
    if (v4 == 1.0)
    {
      *uint64_t v3 = *(_OWORD *)(a1 + 80);
      float64x2_t v6 = *(float64x2_t *)(a1 + 96);
    }
    else
    {
      double v5 = 1.0 / v4;
      *uint64_t v3 = vmulq_n_f64(*(float64x2_t *)(a1 + 80), v5);
      float64x2_t v6 = vmulq_n_f64(*(float64x2_t *)(a1 + 96), v5);
    }
    *(float64x2_t *)(a2 + 40) = v6;
  }
  *(void *)(a2 + 16) = v3;
  uint64_t v7 = *(void *)(a1 + 32);
  if (!v7) {
    goto LABEL_9;
  }
  float v8 = *(double *)(a3 + 48);
  if (v8 < 0.0)
  {
    BOOL v9 = 1;
    float v10 = 1.0;
    goto LABEL_36;
  }
  float v11 = *(double *)a3;
  float v13 = *(double *)(a3 + 16);
  float v14 = *(double *)(a3 + 24);
  float v15 = *(float *)(a1 + 52);
  BOOL v16 = v15 == 1.0;
  float v17 = v15 * v13;
  float v18 = v15 * v14;
  if (v15 == 1.0)
  {
    float v19 = *(double *)(a3 + 8);
  }
  else
  {
    float v11 = v15 * v11;
    float v12 = *(double *)(a3 + 8);
    float v19 = v15 * v12;
  }
  if (v16) {
    float v20 = *(double *)(a3 + 16);
  }
  else {
    float v20 = v17;
  }
  if (v16) {
    float v21 = *(double *)(a3 + 24);
  }
  else {
    float v21 = v18;
  }
  if (v19 == 0.0 && v20 == 0.0)
  {
    float v22 = fabsf(v11);
    float v23 = fabsf(v21);
  }
  else
  {
    if (v11 != 0.0 || v21 != 0.0)
    {
      float v24 = (float)(v19 * v19) + (float)(v11 * v11);
      float v25 = (float)(v21 * v21) + (float)(v20 * v20);
      float v26 = (float)((float)(v19 * v21) + (float)(v11 * v20)) * (float)((float)(v19 * v21) + (float)(v11 * v20));
      if (v24 < (float)(v25 * 1.002) && v26 < (float)((float)(v24 * v25) * 0.0001))
      {
        BOOL v9 = v24 > (float)(v25 * 0.998);
        float v28 = sqrtf(v24);
        if (v24 <= (float)(v25 * 0.998)) {
          float v29 = 1.0;
        }
        else {
          float v29 = v28;
        }
        float v10 = v29 * v8;
LABEL_36:
        int v30 = v10 <= 1.0 && v9;
        *(unsigned char *)(a1 + 112) = v30;
        if (v30 == 1)
        {
          int v31 = *(_DWORD *)(a3 + 56);
          *(float *)(v7 + 236) = v10;
          *(unsigned char *)(v7 + 240) = 0;
          if (v31 == 1) {
            int v32 = 2;
          }
          else {
            int v32 = v31 == 2;
          }
          *(_DWORD *)(v7 + 244) = v32;
          operator new();
        }
LABEL_41:
        operator new();
      }
LABEL_9:
      *(unsigned char *)(a1 + 112) = 0;
      goto LABEL_41;
    }
    float v22 = fabsf(v19);
    float v23 = fabsf(v20);
  }
  if (v22 == v23)
  {
    float v10 = v22 * v8;
    BOOL v9 = 1;
    goto LABEL_36;
  }
  goto LABEL_9;
}

void path_iterator_stroker_create()
{
}

uint64_t anonymous namespace'::release_data(uint64_t this, void *a2)
{
  if (this)
  {
    uint64_t v2 = this;
    uint64_t v3 = *(void *)(this + 72);
    if (v3) {
      path_iterator::release(v3);
    }
    float v4 = *(void **)(v2 + 216);
    if (v4)
    {
      *(void *)(v2 + 224) = v4;
      operator delete(v4);
    }
    JUMPOUT(0x18532A2A0);
  }
  return this;
}

uint64_t path_iterator::release(uint64_t this)
{
  if (atomic_fetch_add_explicit((atomic_uint *volatile)this, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void (**)(void))(this + 40);
    if (v2) {
      v2(*(void *)(this + 8));
    }
    uint64_t v3 = *(path_iterator **)(v1 + 48);
    if (v3) {
      path_iterator::release(v3);
    }
    JUMPOUT(0x18532A2A0);
  }
  return this;
}

uint64_t path_iterator_dasher_create(double *a1)
{
  if (!a1 || *a1 * a1[3] - a1[1] * a1[2] != 0.0) {
    operator new();
  }
  return 0;
}

void sub_184C91308(_Unwind_Exception *a1)
{
  if (v2) {
    operator delete(v2);
  }
  double v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 16) = v5;
    operator delete(v5);
  }
  MEMORY[0x18532A2A0](v1, 0x10A0C40535AADACLL);
  _Unwind_Resume(a1);
}

void CGPatternRelease(CGPatternRef pattern)
{
  if (pattern) {
    CFRelease(pattern);
  }
}

char *CGRenderingStateCreateCopy(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    uint64_t v2 = (char *)malloc_type_malloc(0x58uLL, 0x2062DE7BuLL);
    *(_DWORD *)uint64_t v2 = 1;
    if (v2 != (char *)v1)
    {
      *(_OWORD *)(v2 + 8) = *(_OWORD *)(v1 + 8);
      long long v3 = *(_OWORD *)(v1 + 24);
      long long v4 = *(_OWORD *)(v1 + 40);
      *(_OWORD *)(v2 + 56) = *(_OWORD *)(v1 + 56);
      *(_OWORD *)(v2 + 40) = v4;
      *(_OWORD *)(v2 + 24) = v3;
      *((void *)v2 + 9) = *(void *)(v1 + 72);
      *((_DWORD *)v2 + 1) = *(_DWORD *)(v1 + 4);
      *((_DWORD *)v2 + 20) = *(_DWORD *)(v1 + 80);
      *((_WORD *)v2 + 42) = *(_WORD *)(v1 + 84);
      v2[86] = *(unsigned char *)(v1 + 86);
      return v2;
    }
  }
  return (char *)v1;
}

uint64_t CGColorGetIdentifier(uint64_t result)
{
  if ((result & 0x8000000000000000) == 0) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t CGPatternIsColored(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 185);
}

double CGPatternGetStep(uint64_t a1)
{
  return *(double *)(a1 + 136);
}

const void *__should_allow_as_output_space_block_invoke()
{
  BOOL v1 = 0;
  uint64_t result = get_BOOLean_property("ShouldAllowHDROutputSpaces", (const void *(*)(const char *))copy_local_domain_value, &v1);
  if (result) {
    should_allow_as_output_space_should_allow = v1;
  }
  return result;
}

const void *___Z18CGPreferencesCheckI31CGResamplingAllowTemplateMethodENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGResamplingAllowTemplateMethod", copy_preference_value, (BOOL *)&CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::result);
  if ((result & 1) == 0) {
    CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::uint64_t result = 1;
  }
  return result;
}

const void *___Z15CGDefaultsCheckI38CGPDFDocumentPageResourcesCacheLoggingENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGPDFDocumentPageResourcesCacheLogging", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::result);
  if ((result & 1) == 0) {
    CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::uint64_t result = 0;
  }
  return result;
}

uint64_t ___Z15CGDefaultsCheckI35CGPDFDocumentPageResourcesCacheSizeENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_integer_property("CGPDFDocumentPageResourcesCacheSize", (const void *(*)(const char *))copy_local_domain_value, &CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result);
  if ((result & 1) == 0) {
    CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::uint64_t result = 16;
  }
  return result;
}

const void *__useDebugBitmap_block_invoke()
{
  BOOL v1 = 0;
  uint64_t result = get_BOOLean_property("AUTOUSEBITMAP", (const void *(*)(const char *))copy_local_domain_value, &v1);
  if (result) {
    useDebugBitmap_use_bitmap = v1;
  }
  return result;
}

const void *__log_buffer_check_in_crash_reporter_block_invoke()
{
  uint64_t result = get_BOOLean_property("LOG_DATA_PROVIDER_BUFFER_CHECK", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&log_buffer_check_in_crash_reporter_status);
  log_buffer_check_in_crash_reporter_status = (char)result;
  return result;
}

const void *__RIPShouldCacheImages_block_invoke()
{
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  RIPShouldCacheImages_should_cache = *(unsigned char *)(RIPGetCacheState_cache_state + 34);
  BOOL v1 = 1;
  uint64_t result = get_BOOLean_property("RIPIMAGECACHE", (const void *(*)(const char *))copy_local_domain_value, &v1);
  if (result) {
    RIPShouldCacheImages_should_cache = v1;
  }
  return result;
}

const void *__should_highlight_2x_scaled_images_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGContextHighlight2xScaledImages", copy_preference_value, (BOOL *)&should_highlight_2x_scaled_images_highlight_2x_scaled_images);
  if ((result & 1) == 0) {
    should_highlight_2x_scaled_images_highlight_2x_scaled_images = 0;
  }
  return result;
}

const void *__should_track_image_drawing_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGContextTrackImageDrawing", copy_preference_value, (BOOL *)&should_track_image_drawing_should_track);
  if ((result & 1) == 0) {
    should_track_image_drawing_should_track = 0;
  }
  return result;
}

const void *___Z18CGPreferencesCheckI37CGImageMarkAllowTemplateMethodIntegerENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGImageMarkAllowTemplateMethodInteger", copy_preference_value, (BOOL *)&CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result);
  if ((result & 1) == 0) {
    CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::uint64_t result = 1;
  }
  return result;
}

const void *defaults_setup(void *a1)
{
  get_BOOLean_property("CGFontUseLocalCache", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&cache_glyph_bitmaps);

  return get_BOOLean_property("CGFontPrintBitmapStats", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&print_statistics);
}

void __CGFontGetVTable_block_invoke()
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFStringRef string = 0;
  if (copy_string_property("CGFontLibrary", (const void *(*)(const char *))copy_local_domain_value, &string))BOOL v0 = string == 0; {
  else
  }
    BOOL v0 = 1;
  if (!v0)
  {
    verbose = 1;
    if (CFStringGetFileSystemRepresentation(string, buffer, 1025))
    {
      librardouble y = load_library((uint64_t)buffer);
      CFRelease(string);
      if (library) {
        goto LABEL_10;
      }
    }
    else
    {
      CFRelease(string);
    }
  }
  librardouble y = load_library((uint64_t)"CGXType");
  if (library)
  {
LABEL_10:
    CGFontGetVTable_vtable = ((uint64_t (*)(void))library)();
    if (CGFontGetVTable_vtable) {
      return;
    }
  }
  CGPostError((uint64_t)"No available font implementation.", v2, v3, v4, v5, v6, v7, v8, v9);
}

char *load_library(uint64_t a1)
{
  CGFunctionRef Function = CGLibraryLoadFunction(a1, "cg_font_library_link_symbol");
  if (Function && verbose == 1) {
  return Function;
  }
}

uint64_t (**cg_font_library_link_symbol())()
{
  BOOL v0 = malloc_type_calloc(1uLL, 0x38uLL, 0x1080040BF00B4C8uLL);
  *(_DWORD *)BOOL v0 = 1;
  v0[1] = 0;
  long long v1 = *(_OWORD *)algn_1ED097828;
  *((_OWORD *)v0 + 1) = cg_font_library_link_symbol_font_finder_callbacks;
  *((_OWORD *)v0 + 2) = v1;
  v0[6] = qword_1ED097838;
  font_finder = (uint64_t)v0;
  return xt_vtable;
}

uint64_t copy_string_property(const char *a1, const void *(*a2)(const char *), const __CFString **a3)
{
  uint64_t result = (uint64_t)a2(a1);
  if (result)
  {
    CFStringRef v5 = (const __CFString *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFStringGetTypeID())
    {
      if (a3) {
        *a3 = v5;
      }
      return 1;
    }
    else
    {
      CFRelease(v5);
      return 0;
    }
  }
  return result;
}

char *CGLibraryLoadFunction(uint64_t a1, char *__s1)
{
  uint64_t result = 0;
  if (a1 && __s1)
  {
    uint64_t v5 = 0;
    for (uint64_t i = (const char **)&links; strcmp(__s1, *i); i += 2)
    {
      if (++v5 == 7) {
        return 0;
      }
    }
    return (&links)[2 * v5 + 1];
  }
  return result;
}

const void *get_defaults()
{
  if (!_CFExecutableLinkedOnOrAfter()) {
    should_enable_lcd_styles = 0;
  }
  BOOL v1 = 0;
  if (get_BOOLean_property("CGRIPShouldEnableLCDStyles", (const void *(*)(const char *))copy_local_domain_value, &v1))should_enable_lcd_styles = v1; {
  uint64_t result = get_BOOLean_property("CGRIPShouldUseGlyphBitmaps", (const void *(*)(const char *))copy_local_domain_value, &v1);
  }
  if (result) {
    should_use_glyph_bitmaps = v1;
  }
  return result;
}

const void *__RIPGetCacheState_block_invoke()
{
  BOOL v3 = 0;
  BOOL v0 = malloc_type_calloc(1uLL, 0x28uLL, 0x10200400855E00DuLL);
  *(_DWORD *)BOOL v0 = 0;
  v0[1] = xmmword_1850CDD10;
  BOOL v1 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
  *BOOL v1 = v1;
  v1[1] = v1;
  *((void *)v0 + 1) = v1;
  *((unsigned char *)v0 + 32) = 1;
  if (get_BOOLean_property("RIP_ENABLE_FUNCTION_CACHE", (const void *(*)(const char *))copy_local_domain_value, &v3))*((unsigned char *)v0 + 32) = v3; {
  *((unsigned char *)v0 + 33) = 1;
  }
  if (get_BOOLean_property("RIP_ENABLE_PATTERN_CACHE", (const void *(*)(const char *))copy_local_domain_value, &v3))*((unsigned char *)v0 + 33) = v3; {
  *((unsigned char *)v0 + 34) = 1;
  }
  uint64_t result = get_BOOLean_property("RIP_ENABLE_IMAGE_CACHE", (const void *(*)(const char *))copy_local_domain_value, &v3);
  if (result) {
    *((unsigned char *)v0 + 34) = v3;
  }
  RIPGetCacheState_cache_state = (uint64_t)v0;
  return result;
}

void setup()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  get_BOOLean_property("CGFontCacheShouldEnable", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&enable_caching);
  get_integer_property("CGFontCacheMaxSize", (const void *(*)(const char *))copy_local_domain_value, &cache_max_size);
  get_BOOLean_property("CGFontCacheShouldReportSize", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&report_cache_size);
  get_integer_property("CGFontCacheReportingFrequency", (const void *(*)(const char *))copy_local_domain_value, &reporting_frequency);
  if (report_cache_size && reporting_frequency >= 1)
  {
    memset(&v3, 0, sizeof(v3));
    pthread_t v2 = 0;
    BOOL v0 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
    void *v0 = print_cache_size;
    v0[1] = 0;
    pthread_attr_init(&v3);
    pthread_attr_setscope(&v3, 1);
    pthread_attr_setdetachstate(&v3, 2);
    pthread_create(&v2, &v3, (void *(__cdecl *)(void *))thread_fun, v0);
    pthread_attr_destroy(&v3);
  }
  setup_source = (uint64_t)dispatch_source_create(MEMORY[0x1E4F14468], 0, 2uLL, MEMORY[0x1E4F14428]);
  dispatch_source_set_event_handler((dispatch_source_t)setup_source, &__block_literal_global_11_6533);
  BOOL v1 = setup_source;

  dispatch_resume(v1);
}

const void *get_font_rendering_defaults()
{
  int v19 = 0;
  if (!get_integer_property("CGFontAntialiasingStyle", (const void *(*)(const char *))copy_local_domain_value, &v19))goto LABEL_17; {
  if (v19 > 127)
  }
  {
    if (v19 <= 383)
    {
      if (v19 == 128)
      {
LABEL_15:
        uint64_t v7 = &create_profile_from_set_cglibrarypredicate;
        int v8 = 128;
        goto LABEL_16;
      }
      if (v19 == 256)
      {
LABEL_12:
        uint64_t v7 = &create_profile_from_set_cglibrarypredicate;
        int v8 = 256;
        goto LABEL_16;
      }
    }
    else
    {
      switch(v19)
      {
        case 384:
LABEL_13:
          uint64_t v7 = &create_profile_from_set_cglibrarypredicate;
          int v8 = 384;
          goto LABEL_16;
        case 1024:
LABEL_14:
          uint64_t v7 = &create_profile_from_set_cglibrarypredicate;
          int v8 = 1024;
          goto LABEL_16;
        case 1152:
LABEL_9:
          uint64_t v7 = &create_profile_from_set_cglibrarypredicate;
          int v8 = 1152;
LABEL_16:
          *((_DWORD *)v7 + 365) = v8;
          goto LABEL_17;
      }
    }
LABEL_32:
    CGPostError((uint64_t)"unrecognized font antialiasing style: %d.", v0, v1, v2, v3, v4, v5, v6, v19);
    goto LABEL_17;
  }
  switch(v19)
  {
    case 0:
      default_antialiasing_style = 0;
      break;
    case 1:
      goto LABEL_15;
    case 2:
      goto LABEL_12;
    case 3:
      goto LABEL_13;
    case 4:
      goto LABEL_9;
    case 5:
      goto LABEL_14;
    default:
      goto LABEL_32;
  }
LABEL_17:
  int v20 = 0;
  if (!get_integer_property("CGFontSmoothingStyle", (const void *(*)(const char *))copy_local_domain_value, &v20))goto LABEL_31; {
  if (v20 > 31)
  }
  {
    if (v20 > 63)
    {
      if (v20 == 64)
      {
LABEL_29:
        allows_font_smoothing = 1;
        BOOL v16 = &unk_1E8F97000;
        int v17 = 64;
        goto LABEL_30;
      }
      if (v20 == 112)
      {
LABEL_27:
        allows_font_smoothing = 1;
        BOOL v16 = (_DWORD *)&unk_1E8F97000;
        int v17 = 112;
        goto LABEL_30;
      }
    }
    else
    {
      if (v20 == 32)
      {
LABEL_28:
        allows_font_smoothing = 1;
        BOOL v16 = (_DWORD *)&unk_1E8F97000;
        int v17 = 32;
        goto LABEL_30;
      }
      if (v20 == 48)
      {
LABEL_24:
        allows_font_smoothing = 1;
        BOOL v16 = (_DWORD *)&unk_1E8F97000;
        int v17 = 48;
LABEL_30:
        v16[666] = v17;
        goto LABEL_31;
      }
    }
LABEL_34:
    CGPostError((uint64_t)"unrecognized font smoothing style: %d.", v9, v10, v11, v12, v13, v14, v15, v20);
    goto LABEL_31;
  }
  switch(v20)
  {
    case 0:
      allows_font_smoothing = 0;
      break;
    case 1:
    case 16:
      allows_font_smoothing = 1;
      BOOL v16 = (_DWORD *)&unk_1E8F97000;
      int v17 = 16;
      goto LABEL_30;
    case 2:
      goto LABEL_28;
    case 3:
      goto LABEL_24;
    case 4:
      goto LABEL_29;
    case 5:
      goto LABEL_27;
    default:
      goto LABEL_34;
  }
LABEL_31:
  get_BOOLean_property("CGFontDebugGlyphBitmaps", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&default_glyph_bitmap_debugging);
  return get_BOOLean_property("CGFontDebugGlyphs", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&default_glyph_debugging);
}

uint64_t get_integer_property(const char *a1, const void *(*a2)(const char *), int *a3)
{
  CFNumberRef v4 = (const __CFNumber *)a2(a1);
  if (v4)
  {
    CFNumberRef v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFNumberGetTypeID())
    {
      SInt32 valuePtr = 0;
      if (CFNumberGetValue(v5, kCFNumberIntType, &valuePtr))
      {
        if (a3)
        {
          IntCFDictionaryRef Value = valuePtr;
LABEL_10:
          *a3 = IntValue;
          goto LABEL_11;
        }
        goto LABEL_11;
      }
    }
    else if (v6 == CFStringGetTypeID())
    {
      if (a3)
      {
        IntCFDictionaryRef Value = CFStringGetIntValue((CFStringRef)v5);
        goto LABEL_10;
      }
LABEL_11:
      uint64_t v8 = 1;
LABEL_13:
      CFRelease(v5);
      return v8;
    }
    uint64_t v8 = 0;
    goto LABEL_13;
  }
  return 0;
}

const void *get_BOOLean_property(const char *a1, const void *(*a2)(const char *), BOOL *a3)
{
  uint64_t result = a2(a1);
  if (result)
  {
    CFNumberRef v5 = result;
    uint64_t v6 = get_BOOL((uint64_t)result, a3);
    CFRelease(v5);
    return (const void *)v6;
  }
  return result;
}

CFStringRef copy_local_domain_value(const char *a1)
{
  if (copy_local_domain_value(char const*)::once != -1) {
    dispatch_once_f(&copy_local_domain_value(char const*)::once, 0, (dispatch_function_t)load_allow_debugging_defaults);
  }
  if (!allow_debugging_defaults) {
    return 0;
  }
  uint64_t v2 = getenv(a1);
  if (!v2)
  {
    if (a1)
    {
      CFStringRef v4 = CFStringCreateWithCString(0, a1, 0x600u);
      if (v4)
      {
        CFStringRef v5 = v4;
        CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
        CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D3C8];
        CFPropertyListRef v8 = CFPreferencesCopyValue(v4, (CFStringRef)*MEMORY[0x1E4F1D3D8], (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
        if (!v8)
        {
          CFPropertyListRef v8 = CFPreferencesCopyValue(v5, (CFStringRef)*MEMORY[0x1E4F1D3B8], v6, v7);
          if (!v8) {
            CFPropertyListRef v8 = CFPreferencesCopyValue(v5, @"com.apple.CoreGraphics", v6, v7);
          }
        }
        CFRelease(v5);
        return (CFStringRef)v8;
      }
    }
    return 0;
  }

  return CFStringCreateWithCString(0, v2, 0x600u);
}

CFPropertyListRef copy_preference_value(const char *cStr)
{
  if (!cStr) {
    return 0;
  }
  CFStringRef v1 = CFStringCreateWithCString(0, cStr, 0x600u);
  if (!v1) {
    return 0;
  }
  CFStringRef v2 = v1;
  CFStringRef v3 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
  CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F1D3C8];
  CFPropertyListRef v5 = CFPreferencesCopyValue(v1, (CFStringRef)*MEMORY[0x1E4F1D3D8], (CFStringRef)*MEMORY[0x1E4F1D3D0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (!v5)
  {
    CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
    CFPropertyListRef v5 = CFPreferencesCopyValue(v2, v3, (CFStringRef)*MEMORY[0x1E4F1D3F0], v4);
    if (!v5)
    {
      CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D3B8];
      CFPropertyListRef v5 = CFPreferencesCopyValue(v2, (CFStringRef)*MEMORY[0x1E4F1D3B8], v6, (CFStringRef)*MEMORY[0x1E4F1D3E0]);
      if (!v5) {
        CFPropertyListRef v5 = CFPreferencesCopyValue(v2, v7, v6, v4);
      }
    }
  }
  CFRelease(v2);
  return v5;
}

void CGContextSetStrokeColor(CGContextRef c, const CGFloat *components)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    if (components)
    {
      set_stroke_color_with_components((uint64_t *)c, 0, components, v2, v3, v4, v5, v6, v8);
    }
    else
    {
      CGPostError((uint64_t)"%s: components may not be NULL.", (uint64_t)c, 0, v2, v3, v4, v5, v6, (char)"CGContextSetStrokeColor");
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetStrokeColor", (uint64_t)c, (uint64_t)components, v2, v3, v4, v5, v6);
  }
}

CGRect CGPDFPageGetBoxRect(CGPDFPageRef page, CGPDFBox box)
{
  double v2 = 0.0;
  double v3 = INFINITY;
  box_CGRect rect = INFINITY;
  double v5 = 0.0;
  if (page && box <= kCGPDFArtBox)
  {
    uint64_t v6 = (double *)((char *)page + 32 * box);
    box_CGRect rect = v6[7];
    double v3 = v6[8];
    CFStringRef v7 = (char *)(v6 + 7);
    if (box_rect == INFINITY || v3 == INFINITY)
    {
      box_CGRect rect = pdf_page_get_box_rect(*((void *)page + 5), box);
    }
    else
    {
      double v2 = *((double *)v7 + 2);
      double v5 = *((double *)v7 + 3);
    }
  }
  result.size.double height = v5;
  result.size.CGFloat width = v2;
  result.origin.double y = v3;
  result.origin.CGFloat x = box_rect;
  return result;
}

uint64_t CGPDFResourcesIterateCategory(uint64_t result, char *key, uint64_t a3)
{
  if (result)
  {
    if (key)
    {
      for (uint64_t i = *(uint64_t ***)(result + 16); i; uint64_t i = (uint64_t **)*i)
      {
        CGPDFDictionaryRef value = 0;
        CGRect result = CGPDFDictionaryGetDictionary((CGPDFDictionaryRef)i[1], key, &value);
        if (result)
        {
          CGRect result = (*(uint64_t (**)(uint64_t, CGPDFDictionaryRef))(a3 + 16))(a3, value);
          if (!result) {
            break;
          }
        }
      }
    }
  }
  return result;
}

uint64_t CGPDFPageCreate2(CFTypeRef *a1, unint64_t a2, int a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (CGPDFPageGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFPageGetTypeID_onceToken, &__block_literal_global_170);
  }
  uint64_t cftype = pdf_create_cftype();
  if (cftype)
  {
    if (a1)
    {
      CFTypeRef v7 = a1[2];
      if (v7) {
        CFRetain(a1[2]);
      }
    }
    else
    {
      CFTypeRef v7 = 0;
    }
    *(void *)(cftype + 32) = v7;
    char v8 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    *((_DWORD *)v8 + 22) = 0;
    *(void *)char v8 = v7;
    *((void *)v8 + 1) = a2;
    uint64_t v9 = (uint64_t *)*((void *)v7 + 2);
    BOOL v10 = a2 != 1 || *(void *)(*v9 + 24) == 0;
    int v11 = v10;
    if (v10) {
      page_dictionardouble y = (uint64_t)pdf_document_get_page_dictionary((uint64_t)v9, a2);
    }
    else {
      page_dictionardouble y = pdf_reader_get_linearized_page_dict(v9, 1uLL);
    }
    *((void *)v8 + 2) = page_dictionary;
    if (!page_dictionary || (uint64_t v13 = CGPDFResourcesCreateWithPage((uint64_t)v8, v11), (*((void *)v8 + 3) = v13) == 0))
    {
      pdf_page_release((uint64_t)v8);
      *(void *)(cftype + 40) = 0;
      CFRelease((CFTypeRef)cftype);
      return 0;
    }
    *((_DWORD *)v8 + 8) = 0;
    v8[48] = v11;
    CGPDFObjectRef v20 = 0;
    __s1.__sig = 0;
    CGPDFDictionaryRef value = 0;
    *(_WORD *)float v18 = 0;
    if (!CGPDFDictionaryGetDictionary(*((CGPDFDictionaryRef *)v8 + 2), "Group", &value)) {
      goto LABEL_25;
    }
    if (!CGPDFDictionaryGetName(value, "S", (const char **)&__s1))
    {
      goto LABEL_25;
    }
    if (strcmp((const char *)__s1.__sig, "Transparency"))
    {
      goto LABEL_25;
    }
    v8[50] = 0;
    if (CGPDFDictionaryGetBoolean(value, "I", &v18[1])) {
      v8[50] = v18[1] != 0;
    }
    v8[49] = 0;
    if (CGPDFDictionaryGetBoolean(value, "K", v18)) {
      v8[49] = v18[0] != 0;
    }
    *((void *)v8 + 7) = 0;
    if (!CGPDFDictionaryGetObject(value, "CS", &v20)) {
      goto LABEL_25;
    }
    CGColorSpaceRef colorspace = cg_create_colorspace((uint64_t)v20);
    int Type = CGColorSpaceGetType(colorspace);
    if ((Type - 7) < 3) {
      goto LABEL_44;
    }
    if (Type == 6)
    {
      if (!colorspace || *(_DWORD *)(*((void *)colorspace + 3) + 28) > 2u) {
        goto LABEL_44;
      }
    }
    else if (Type == 5)
    {
LABEL_44:
      pdf_error("invalid group attributes color space.");
      CGColorSpaceRelease(colorspace);
LABEL_25:
      *(void *)(v8 + 100) = 0;
      *(void *)(v8 + 92) = 0;
      *((_DWORD *)v8 + 27) = 0;
      *(void *)(cftype + 40) = v8;
      if (a1 && a3)
      {
        CFRetain(a1);
        char v8 = *(char **)(cftype + 40);
      }
      *(void *)(cftype + 16) = a1;
      *(unsigned char *)(cftype + 24) = a3;
      *(_DWORD *)(cftype + 48) = pdf_page_get_rotation_angle((uint64_t)v8);
      for (uint64_t i = 56; i != 216; i += 32)
        *(CGRect *)(cftype + i) = CGRectNull;
      __s1.__sig = 0;
      *(void *)__s1.__opaque = 0;
      pthread_mutexattr_init(&__s1);
      pthread_mutexattr_settype(&__s1, 2);
      pthread_mutex_init((pthread_mutex_t *)(cftype + 216), &__s1);
      pthread_mutexattr_destroy(&__s1);
      *(unsigned char *)(cftype + 280) = 0;
      *(void *)(cftype + 284) = 0;
      *(void *)(cftype + 296) = 0;
      *(_DWORD *)(cftype + 304) = 0;
      *(void *)(cftype + 312) = 0;
      *(_DWORD *)(cftype + 320) = 0;
      *(void *)(cftype + 328) = 0;
      *(_DWORD *)(cftype + 336) = 0;
      *(void *)(cftype + 352) = 0;
      *(void *)(cftype + 360) = 0;
      *(void *)(cftype + 344) = 0;
      return cftype;
    }
    *((void *)v8 + 7) = colorspace;
    goto LABEL_25;
  }
  return cftype;
}

os_unfair_lock_s *CGPDFResourcesCreateWithPage(uint64_t a1, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)CGPDFResourcesCreate();
  double v5 = v4;
  if (v4)
  {
    CGPDFDictionaryRef v22 = 0;
    os_unfair_lock_lock(v4 + 20);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    uint64_t v6 = *(void *)(a1 + 40);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    if (v6 && CGPDFDictionaryGetDictionary(*(CGPDFDictionaryRef *)(v6 + 48), "Resources", &v22))
    {
      uint64_t v7 = *(void *)&v5[4]._os_unfair_lock_opaque;
      CGPDFDictionaryRef v8 = v22;
      uint64_t v9 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v9 = v7;
      v9[1] = v8;
      *(void *)&v5[4]._os_unfair_lock_opaque = v9;
    }
    BOOL v10 = *(CGPDFDictionary **)(a1 + 16);
    CGPDFDictionaryRef value = v10;
    if (CGPDFDictionaryGetDictionary(v10, "Resources", &v22))
    {
      CGPDFDictionaryRef v11 = v22;
    }
    else
    {
      CGPDFDictionaryRef v11 = 0;
      CGPDFDictionaryRef v22 = 0;
    }
    uint64_t v12 = *(void *)&v5[4]._os_unfair_lock_opaque;
    uint64_t v13 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
    *uint64_t v13 = v12;
    v13[1] = v11;
    *(void *)&v5[4]._os_unfair_lock_opaque = v13;
    if (a2)
    {
      Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
      while (CGPDFDictionaryGetDictionary(v10, "Parent", &value) && !CFSetContainsValue(Mutable, value))
      {
        if (CGPDFDictionaryGetDictionary(value, "Resources", &v22))
        {
          CGPDFDictionaryRef v15 = v22;
        }
        else
        {
          CGPDFDictionaryRef v15 = 0;
          CGPDFDictionaryRef v22 = 0;
        }
        uint64_t v16 = *(void *)&v5[4]._os_unfair_lock_opaque;
        int v17 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        *int v17 = v16;
        v17[1] = v15;
        *(void *)&v5[4]._os_unfair_lock_opaque = v17;
        CFSetAddValue(Mutable, value);
        BOOL v10 = value;
      }
      float v18 = *(void **)&v5[4]._os_unfair_lock_opaque;
      if (v18)
      {
        int v19 = 0;
        do
        {
          CGPDFObjectRef v20 = v18;
          float v18 = (void *)*v18;
          *CGPDFObjectRef v20 = v19;
          int v19 = v20;
        }
        while (v18);
      }
      else
      {
        CGPDFObjectRef v20 = 0;
      }
      *(void *)&v5[4]._os_unfair_lock_opaque = v20;
      CFRelease(Mutable);
    }
    os_unfair_lock_unlock(v5 + 20);
  }
  return v5;
}

const void *pdf_document_get_page_dictionary(uint64_t a1, unint64_t a2)
{
  if (!*(void *)(*(void *)a1 + 24))
  {
LABEL_18:
    CFArrayRef v10 = *(const __CFArray **)(a1 + 8);
    if (v10)
    {
LABEL_32:
      if (a2 && CFArrayGetCount(v10) >= a2) {
        return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), a2 - 1);
      }
      return 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    if (*(void *)(a1 + 8))
    {
LABEL_31:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
      CFArrayRef v10 = *(const __CFArray **)(a1 + 8);
      if (!v10)
      {
        pdf_error("Failed to create pages array\n");
        return 0;
      }
      goto LABEL_32;
    }
    pages_dictionardouble y = get_pages_dictionary(*(void *)a1);
    if (pages_dictionary)
    {
      CGPDFDictionaryRef v12 = pages_dictionary;
      CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
      if (Mutable)
      {
        CGPDFDictionaryRef v15 = Mutable;
        CFSetRef v16 = CFSetCreateMutable(v13, 0, 0);
        if (v16)
        {
          CFSetRef v17 = v16;
          int v18 = add_pages(v15, v12, v16);
          CFRelease(v17);
          newValues = (void *)pdf_reader_get_linearized_page_dict((uint64_t *)a1, 1uLL);
          if (newValues)
          {
            v22.location = 0;
            v22.length = 1;
            CFArrayReplaceValues(v15, v22, (const void **)&newValues, 1);
          }
          if (v18) {
            int v19 = v15;
          }
          else {
            int v19 = 0;
          }
          goto LABEL_30;
        }
        CFRelease(v15);
      }
    }
    int v19 = 0;
LABEL_30:
    *(void *)(a1 + 8) = v19;
    goto LABEL_31;
  }
  CFArrayRef v4 = *(const __CFArray **)(a1 + 8);
  if (!v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    if (!*(void *)(a1 + 8))
    {
      number_of_pages = pdf_reader_get_number_of_pages((uint64_t *)a1);
      *(void *)(a1 + 8) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFIndex)number_of_pages, 0);
      if (number_of_pages)
      {
        uint64_t v6 = (const void *)*MEMORY[0x1E4F1D260];
        do
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 8), v6);
          number_of_pages = (CGPDFDictionary *)((char *)number_of_pages - 1);
        }
        while (number_of_pages);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
    CFArrayRef v4 = *(const __CFArray **)(a1 + 8);
  }
  uint64_t v7 = 0;
  if (a2 && v4)
  {
    if (CFArrayGetCount(v4) < a2) {
      return 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
    ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), a2 - 1);
    if (ValueAtIndex == (const void *)*MEMORY[0x1E4F1D260])
    {
      linearized_page_dict = (const void *)pdf_reader_get_linearized_page_dict((uint64_t *)a1, a2);
      if (!linearized_page_dict)
      {
LABEL_17:
        pdf_error("Failed to get linearized page dict for page: %zu\n", a2);
        CFRelease(*(CFTypeRef *)(a1 + 8));
        *(void *)(a1 + 8) = 0;
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
        goto LABEL_18;
      }
      uint64_t v7 = linearized_page_dict;
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 8), a2 - 1, linearized_page_dict);
    }
    else
    {
      uint64_t v7 = ValueAtIndex;
      if (!ValueAtIndex) {
        goto LABEL_17;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  }
  return v7;
}

uint64_t add_pages(__CFArray *a1, void *a2, const __CFSet *a3)
{
  if (!is_page_tree_node((BOOL)a2))
  {
    if (a2
      && (CGPDFObjectRef value = 0, CGPDFDictionaryGetObject((CGPDFDictionaryRef)a2, "Parent", &value))
      && value
      && *((_DWORD *)value + 2) == 8)
    {
      CFArrayAppendValue(a1, a2);
    }
    else
    {
      pdf_error("invalid page tree entry.");
    }
    return 1;
  }
  if (CFSetContainsValue(a3, a2))
  {
    pdf_error("invalid page tree: in fact, this isn't a tree at all!");
    return 0;
  }
  CGPDFDictionaryRef v9 = 0;
  CGPDFObjectRef value = 0;
  CFSetAddValue(a3, a2);
  if (!CGPDFDictionaryGetArray((CGPDFDictionaryRef)a2, "Kids", &value))
  {
    return 0;
  }
  if (!value) {
    return 1;
  }
  uint64_t v7 = *((void *)value + 2);
  if (!v7) {
    return 1;
  }
  for (size_t i = 0; i != v7; ++i)
  {
    if (CGPDFArrayGetDictionary(value, i, &v9))
    {
      uint64_t result = add_pages(a1, v9, a3);
      if (!result) {
        return result;
      }
    }
    else
    {
    }
    uint64_t result = 1;
  }
  return result;
}

double pdf_page_get_drawing_transform(double *a1, uint64_t a2, int a3, int a4, int a5, int a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10, CGFloat a11, CGFloat a12, double a13, double a14)
{
  box_CGRect rect = pdf_page_get_box_rect(a2, a3);
  CGFloat y = v25;
  CGFloat width = v27;
  CGFloat height = v29;
  if (a3)
  {
    v107.origin.double x = pdf_page_get_box_rect(a2, 0);
    v107.origin.CGFloat y = v31;
    v107.size.CGFloat width = v32;
    v107.size.CGFloat height = v33;
    v94.origin.double x = box_rect;
    v94.origin.CGFloat y = y;
    v94.size.CGFloat width = width;
    v94.size.CGFloat height = height;
    CGRect v95 = CGRectIntersection(v94, v107);
    box_CGRect rect = v95.origin.x;
    CGFloat y = v95.origin.y;
    CGFloat width = v95.size.width;
    CGFloat height = v95.size.height;
  }
  v96.origin.double x = box_rect;
  v96.origin.CGFloat y = y;
  v96.size.CGFloat width = width;
  v96.size.CGFloat height = height;
  v108.origin.double x = a7;
  v108.origin.CGFloat y = a8;
  v108.size.CGFloat width = a9;
  v108.size.CGFloat height = a10;
  CGRect v97 = CGRectIntersection(v96, v108);
  double x = v97.origin.x;
  CGFloat v35 = v97.origin.y;
  CGFloat v36 = v97.size.width;
  CGFloat v37 = v97.size.height;
  if (v97.size.width < 0.0 || v97.size.height < 0.0)
  {
    unint64_t v92 = (unint64_t)CGRectStandardize(v97);
    v98.origin.double x = x;
    v98.origin.CGFloat y = v35;
    v98.size.CGFloat width = v36;
    v98.size.CGFloat height = v37;
    CGRect v99 = CGRectStandardize(v98);
    double v41 = v99.origin.y;
    v99.origin.double x = x;
    v99.origin.CGFloat y = v35;
    v99.size.CGFloat width = v36;
    v99.size.CGFloat height = v37;
    CGRect v100 = CGRectStandardize(v99);
    double v38 = v100.origin.x + v100.size.width;
    v100.origin.double x = x;
    v100.origin.CGFloat y = v35;
    v100.size.CGFloat width = v36;
    v100.size.CGFloat height = v37;
    CGRect v101 = CGRectStandardize(v100);
    double v39 = v101.origin.y + v101.size.height;
    v101.origin.double x = x;
    v101.origin.CGFloat y = v35;
    v101.size.CGFloat width = v36;
    v101.size.CGFloat height = v37;
    CGRect v102 = CGRectStandardize(v101);
    CGFloat v40 = v102.size.width;
    v102.origin.double x = x;
    double x = *(double *)&v92;
    v102.origin.CGFloat y = v35;
    v102.size.CGFloat width = v36;
    v102.size.CGFloat height = v37;
    CGRect v103 = CGRectStandardize(v102);
    CGFloat v37 = v103.size.height;
  }
  else
  {
    double v38 = v97.origin.x + v97.size.width;
    double v39 = v97.origin.y + v97.size.height;
    CGFloat v40 = v97.size.width;
    double v41 = v97.origin.y;
  }
  int v42 = (int)(pdf_page_get_rotation_angle(a2) + a4) % 360;
  int v43 = v42 + (v42 < 0 ? 0x168 : 0);
  if (v43 == 90)
  {
    double v47 = -v41;
    double v48 = 0.0;
    double v49 = -1.0;
    double v85 = v38;
    double v50 = v40;
    double v93 = v37;
    double v44 = 1.0;
    double v45 = a14;
    double v46 = a13;
  }
  else
  {
    double v93 = v40;
    double v44 = 0.0;
    double v45 = a14;
    double v46 = a13;
    if (v43 == 180)
    {
      double v85 = v39;
      double v48 = -1.0;
      double v49 = 0.0;
      double v47 = v38;
      double v50 = v37;
    }
    else if (v43 == 270)
    {
      double v47 = v39;
      double v48 = 0.0;
      double v49 = 1.0;
      double v44 = -1.0;
      double v85 = -x;
      double v50 = v93;
      double v93 = v37;
    }
    else
    {
      double v47 = -x;
      double v85 = -v41;
      double v48 = 1.0;
      double v50 = v37;
      double v49 = 0.0;
    }
  }
  if (v46 < 0.0 || v45 < 0.0)
  {
    CGFloat v54 = a11;
    CGFloat v55 = a12;
    double v56 = v46;
    CGFloat v57 = v45;
    rectdouble a = v47;
    double v88 = v49;
    double v84 = v44;
    unint64_t v83 = (unint64_t)CGRectStandardize(*(CGRect *)(&v45 - 3));
    v104.origin.double x = a11;
    v104.origin.CGFloat y = a12;
    v104.size.CGFloat width = v46;
    v104.size.CGFloat height = v57;
    CGRect v105 = CGRectStandardize(v104);
    double v53 = v105.origin.y;
    v105.origin.double x = a11;
    v105.origin.CGFloat y = a12;
    v105.size.CGFloat width = v46;
    v105.size.CGFloat height = v57;
    CGRect v106 = CGRectStandardize(v105);
    double v51 = v106.size.width;
    v106.origin.double x = a11;
    v106.origin.CGFloat y = a12;
    v106.size.CGFloat width = v46;
    v106.size.CGFloat height = v57;
    *(CGRect *)(&v45 - 3) = CGRectStandardize(v106);
    double v52 = *(double *)&v83;
    double v44 = v84;
    double v49 = v88;
    double v47 = recta;
  }
  else
  {
    double v51 = v46;
    double v52 = a11;
    double v53 = a12;
  }
  double v58 = v85 + v47 * 0.0 + v50 * -0.5;
  double v59 = v93 * -0.5 + v47 + v85 * 0.0;
  double v60 = v48 + v44 * 0.0;
  double v61 = v44 + v48 * 0.0;
  double v62 = v49 + v48 * 0.0;
  double v63 = v48 + v49 * 0.0;
  double v64 = v51 / v93;
  double v65 = v45 / v50;
  double v66 = fmin(v51 / v93, 1.0);
  double v67 = fmin(v45 / v50, 1.0);
  if (a6)
  {
    double v64 = v66;
    double v65 = v67;
  }
  double v68 = fmin(v64, v65);
  if (a5)
  {
    double v64 = v68;
    double v65 = v68;
  }
  double v69 = v62 * 0.0 + v63 * v64;
  double v70 = v62 * v65 + v63 * 0.0;
  double v71 = v60 * 0.0 + v61 * v64;
  double v72 = v60 * v65 + v61 * 0.0;
  double v73 = v58 * 0.0 + v59 * v64 + 0.0;
  double v74 = v65 * v58 + v59 * 0.0 + 0.0;
  double v75 = v45 * 0.5;
  double v76 = v69 + v70 * 0.0;
  double v77 = v70 + v69 * 0.0;
  double v78 = v71 + v72 * 0.0;
  double v79 = v72 + v71 * 0.0;
  double v80 = v51 * 0.5 + v73 + v74 * 0.0;
  double v81 = v74 + v73 * 0.0 + v75;
  *a1 = v76 + v77 * 0.0;
  a1[1] = v77 + v76 * 0.0;
  a1[2] = v78 + v79 * 0.0;
  a1[3] = v79 + v78 * 0.0;
  double result = v81 + v80 * 0.0 + v53;
  a1[4] = v52 + v80 + v81 * 0.0;
  a1[5] = result;
  return result;
}

double pdf_page_get_box_rect(uint64_t a1, int a2)
{
  memset(v7, 0, sizeof(v7));
  switch(a2)
  {
    case 0:
      if (get_page_box(a1, "MediaBox", 1, (double *)v7)) {
        goto LABEL_10;
      }
      return 0.0;
    case 1:
      if (get_page_box(a1, "CropBox", 1, (double *)v7)) {
        goto LABEL_10;
      }
      uint64_t v4 = a1;
      uint64_t v5 = 0;
      goto LABEL_12;
    case 2:
      uint64_t v6 = "BleedBox";
      goto LABEL_9;
    case 3:
      uint64_t v6 = "TrimBox";
      goto LABEL_9;
    case 4:
      uint64_t v6 = "ArtBox";
LABEL_9:
      if (get_page_box(a1, v6, 0, (double *)v7))
      {
LABEL_10:
        double result = *(double *)v7;
      }
      else
      {
        uint64_t v4 = a1;
        uint64_t v5 = 1;
LABEL_12:
        pdf_page_get_box_rect(v4, v5);
      }
      break;
    default:
      double result = INFINITY;
      break;
  }
  return result;
}

uint64_t pdf_page_get_rotation_angle(uint64_t a1)
{
  CGPDFInteger value = 0;
  CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  CGPDFDictionaryRef dict = *(CGPDFDictionaryRef *)(a1 + 16);
  while (!CGPDFDictionaryGetInteger(dict, "Rotate", &value))
  {
    if (*(unsigned char *)(a1 + 48))
    {
      CFSetAddValue(Mutable, dict);
      if (CGPDFDictionaryGetDictionary(dict, "Parent", &dict) && !CFSetContainsValue(Mutable, dict)) {
        continue;
      }
    }
    goto LABEL_9;
  }
  if (value != (int)value) {
    CGPDFInteger value = 0;
  }
LABEL_9:
  CFRelease(Mutable);
  return value;
}

CGColorSpace *set_default_color_spaces(CGColorSpace *a1)
{
  *((void *)a1 + 6) = get_default_space(a1, "DefaultGray", 1);
  *((void *)a1 + 7) = get_default_space(a1, "DefaultRGB", 3);
  double result = get_default_space(a1, "DefaultCMYK", 4);
  *((void *)a1 + 8) = result;
  return result;
}

CGColorSpace *get_default_space(CGColorSpace *result, const char *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    while (1)
    {
      double result = CGPDFResourcesGetColorSpace(*((void *)v5 + 4), a2);
      if (result) {
        break;
      }
      uint64_t v5 = (CGColorSpace *)*((void *)v5 + 5);
      if (!v5) {
        return 0;
      }
    }
    uint64_t v6 = *((void *)result + 3);
    if (*(void *)(v6 + 48) != a3) {
      return 0;
    }
    unsigned int v7 = *(_DWORD *)(v6 + 28);
    BOOL v8 = v7 > 6;
    int v9 = (1 << v7) & 0x68;
    if (!v8 && v9 != 0) {
      return 0;
    }
  }
  return result;
}

CGColorSpace *CGPDFResourcesGetColorSpace(uint64_t a1, const char *a2)
{
  CFDictionaryRef Value = 0;
  if (a1 && a2)
  {
    uint64_t v5 = (os_unfair_lock_s *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 80));
    uint64_t v6 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x600u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 24);
    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8 || (CFDictionaryRef Value = (CGColorSpace *)CFDictionaryGetValue(v7, v6)) == 0)
    {
      if (!strcmp(a2, "DeviceGray"))
      {
        DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
      }
      else if (!strcmp(a2, "DeviceRGB"))
      {
        DeviceGraCGFloat y = CGColorSpaceCreateDeviceRGB();
      }
      else if (!strcmp(a2, "DeviceCMYK"))
      {
        DeviceGraCGFloat y = CGColorSpaceCreateDeviceCMYK();
      }
      else if (!strcmp(a2, "Pattern"))
      {
        DeviceGraCGFloat y = CGColorSpaceCreatePattern(0);
      }
      else
      {
        CGPDFObjectRef resource = get_resource(a1, "ColorSpace", a2);
        DeviceGraCGFloat y = cg_create_colorspace((uint64_t)resource);
      }
      if (DeviceGray)
      {
        CFDictionaryRef Value = (CGColorSpace *)table_set_value((__CFDictionary **)(a1 + 24), v6, DeviceGray);
        CGColorSpaceRelease(Value);
      }
      else
      {
        CFDictionaryRef Value = 0;
      }
    }
    CFRelease(v6);
    os_unfair_lock_unlock(v5);
  }
  return Value;
}

CGColorSpaceRef cg_create_colorspace(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 == 7)
  {
    uint64_t v6 = *(CGPDFArray **)(a1 + 32);
    uint64_t v4 = (uint64_t)CGPDFObjectCopyAssociation(a1, "ColorSpace");
    if (v4) {
      return (CGColorSpaceRef)v4;
    }
    if (!v6 || !*((void *)v6 + 2))
    {
      pdf_error("invalid color space: no entries in color space array.");
      return 0;
    }
    CGPDFInteger value = 0;
    if (!CGPDFArrayGetName(v6, 0, (const char **)&value))
    {
      pdf_error("invalid color space: first color space array entry must be a name.");
      return 0;
    }
    if (cg_create_colorspace_pred != -1) {
      dispatch_once(&cg_create_colorspace_pred, &__block_literal_global_15644);
    }
    CFArrayRef v7 = (const __CFArray *)pthread_getspecific(cg_colorspaces_key);
    if (v7)
    {
      CFArrayRef Mutable = v7;
      CFIndex Count = CFArrayGetCount(v7);
      if (Count >= 1)
      {
        CFIndex v10 = Count;
        CFIndex v11 = 0;
        while (v6 != CFArrayGetValueAtIndex(Mutable, v11))
        {
          if (v10 == ++v11) {
            goto LABEL_26;
          }
        }
        pdf_error("invalid color space: color space cannot have a circular reference.");
        return 0;
      }
    }
    else
    {
      CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 100, 0);
    }
LABEL_26:
    CFArrayAppendValue(Mutable, v6);
    pthread_setspecific(cg_colorspaces_key, Mutable);
    CGColorSpaceRef device_space = create_device_space(value);
    if (!device_space)
    {
      CFAllocatorRef v13 = value;
      if (!strcmp(value, "CalGray"))
      {
        CalGraCGFloat y = (uint64_t)create_CalGray(v6);
      }
      else if (!strcmp(v13, "CalRGB"))
      {
        CalGraCGFloat y = (uint64_t)create_CalRGB(v6);
      }
      else if (!strcmp(v13, "Lab"))
      {
        CalGraCGFloat y = (uint64_t)create_Lab(v6);
      }
      else if (!strcmp(v13, "ICCBased"))
      {
        CalGraCGFloat y = (uint64_t)create_ICCBased(v6);
      }
      else if (!strcmp(v13, "Separation"))
      {
        CalGraCGFloat y = create_Separation(v6);
      }
      else if (!strcmp(v13, "DeviceN"))
      {
        CalGraCGFloat y = create_DeviceN(v6);
      }
      else if (!strcmp(v13, "Indexed"))
      {
        CalGraCGFloat y = (uint64_t)create_Indexed(v6);
      }
      else
      {
        if (strcmp(v13, "Pattern"))
        {
LABEL_48:
          uint64_t v4 = 0;
          goto LABEL_47;
        }
        CalGraCGFloat y = (uint64_t)create_Pattern(v6);
      }
      CGColorSpaceRef device_space = (CGColorSpaceRef)CalGray;
      if (!CalGray) {
        goto LABEL_48;
      }
    }
    uint64_t v4 = CGPDFObjectSetAssociation(a1, device_space, "ColorSpace");
LABEL_47:
    v18.length = CFArrayGetCount(Mutable);
    v18.location = 0;
    FirstIndexOfCFDictionaryRef Value = CFArrayGetFirstIndexOfValue(Mutable, v18, v6);
    CFArrayRemoveValueAtIndex(Mutable, FirstIndexOfValue);
    pthread_setspecific(cg_colorspaces_key, Mutable);
    return (CGColorSpaceRef)v4;
  }
  if (v2 != 5) {
    return 0;
  }
  double v3 = *(const char **)(a1 + 32);
  uint64_t v4 = (uint64_t)create_device_space(v3);
  if (v4) {
    return (CGColorSpaceRef)v4;
  }
  if (strcmp(v3, "Pattern")) {
    return 0;
  }

  return CGColorSpaceCreatePattern(0);
}

CGPDFObjectRef get_resource(uint64_t a1, char *key, const char *a3)
{
  if (!key) {
    return 0;
  }
  double v3 = *(uint64_t ***)(a1 + 16);
  if (!v3) {
    return 0;
  }
  CGPDFDictionaryRef dict = 0;
  CGPDFObjectRef value = 0;
  while (!CGPDFDictionaryGetDictionary((CGPDFDictionaryRef)v3[1], key, &dict)
       || !CGPDFDictionaryGetObject(dict, a3, &value))
  {
    double v3 = (uint64_t **)*v3;
    if (!v3) {
      return 0;
    }
  }
  return value;
}

CGPDFDictionary *pdf_reader_get_number_of_pages(uint64_t *a1)
{
  CGPDFInteger value = 0;
  if (CGPDFDictionaryGetInteger(*(CGPDFDictionaryRef *)(*a1 + 24), "N", &value)) {
    return (CGPDFDictionary *)(value & ~(value >> 63));
  }
  double result = get_pages_dictionary(*a1);
  if (result)
  {
    if (CGPDFDictionaryGetInteger(result, "Count", &value))
    {
      double result = (CGPDFDictionary *)(value & ~(value >> 63));
      if (*a1)
      {
        if ((unint64_t)result >= *(void *)(*a1 + 160)) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL CGPDFDictionaryGetInteger(CGPDFDictionaryRef dict, const char *key, CGPDFInteger *value)
{
  valuedouble a = 0;
  BOOL Object = CGPDFDictionaryGetObject(dict, key, &valuea);
  if (Object)
  {
    if (valuea && ((int v5 = *((_DWORD *)valuea + 2), v5 != 12) ? (v6 = v5 == 3) : (v6 = 1), v6))
    {
      if (value) {
        *CGPDFInteger value = *((void *)valuea + 4);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL get_page_box(uint64_t a1, const char *a2, int a3, double *a4)
{
  CFArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  CGPDFInteger value = *(void **)(a1 + 16);
  while (1)
  {
    BOOL Rect = CGPDFDictionaryGetRect((CGPDFDictionary *)value, a2, a4);
    if (Rect | a3 ^ 1u) {
      break;
    }
    if (*(unsigned char *)(a1 + 48))
    {
      CFSetAddValue(Mutable, value);
      if (CGPDFDictionaryGetDictionary((CGPDFDictionaryRef)value, "Parent", (CGPDFDictionaryRef *)&value)
        && !CFSetContainsValue(Mutable, value))
      {
        continue;
      }
    }
    BOOL v10 = 0;
    goto LABEL_8;
  }
  BOOL v10 = Rect;
LABEL_8:
  CFRelease(Mutable);
  return v10;
}

BOOL CGPDFDictionaryGetRect(CGPDFDictionary *a1, const char *a2, double *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  BOOL result = CGPDFDictionaryGetNumbers(a1, a2, (uint64_t)&v12, (CGPDFArray *)4);
  if (a3 && result)
  {
    double v5 = v12;
    double v6 = v13;
    if (v12 < v14)
    {
      double v7 = v14 - v12;
    }
    else
    {
      double v5 = v14;
      double v7 = v12 - v14;
    }
    double v8 = v15 - v13;
    double v9 = v13 - v15;
    BOOL v10 = v13 < v15;
    if (v13 >= v15) {
      double v6 = v15;
    }
    *a3 = v5;
    a3[1] = v6;
    if (v10) {
      double v11 = v8;
    }
    else {
      double v11 = v9;
    }
    a3[2] = v7;
    a3[3] = v11;
  }
  return result;
}

BOOL CGPDFDictionaryGetNumbers(CGPDFDictionary *a1, const char *a2, uint64_t a3, CGPDFArray *a4)
{
  arraCGFloat y = 0;
  CGPDFReal value = 0.0;
  BOOL result = CGPDFDictionaryGetArray(a1, a2, &array);
  if (result)
  {
    CGPDFArrayRef v7 = array;
    if (array) {
      CGPDFArrayRef v7 = (CGPDFArrayRef)*((void *)array + 2);
    }
    if (v7 == a4)
    {
      if (a4)
      {
        size_t v8 = 0;
        do
        {
          BOOL result = CGPDFArrayGetNumber(array, v8, &value);
          if (!result) {
            break;
          }
          *(CGPDFReal *)(a3 + 8 * v8++) = value;
        }
        while (a4 != (CGPDFArray *)v8);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL CGPDFArrayGetNumber(CGPDFArrayRef array, size_t index, CGPDFReal *value)
{
  valuedouble a = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea)
    {
      int v5 = *((_DWORD *)valuea + 2);
      switch(v5)
      {
        case 12:
          goto LABEL_6;
        case 4:
          double v6 = *((double *)valuea + 4);
          if (!value) {
            goto LABEL_8;
          }
          goto LABEL_7;
        case 3:
LABEL_6:
          double v6 = (double)*((uint64_t *)valuea + 4);
          if (!value)
          {
LABEL_8:
            LOBYTE(Object) = 1;
            return Object;
          }
LABEL_7:
          *CGPDFReal value = v6;
          goto LABEL_8;
      }
    }
    LOBYTE(Object) = 0;
  }
  return Object;
}

BOOL CGPDFArrayGetObject(CGPDFArrayRef array, size_t index, CGPDFObjectRef *value)
{
  if (array)
  {
    CGPDFArrayRef v3 = array;
    if (*((void *)array + 2) <= index)
    {
      LOBYTE(array) = 0;
    }
    else
    {
      arraCGFloat y = (CGPDFArrayRef)*((void *)array + 3);
      if (index && array)
      {
        size_t v5 = 1;
        do
        {
          arraCGFloat y = *(CGPDFArrayRef *)array;
          if (v5 >= index) {
            break;
          }
          ++v5;
        }
        while (array);
      }
      if (array && *((_DWORD *)array + 2) == 10) {
        arraCGFloat y = (CGPDFArrayRef)pdf_xref_resolve(*((void *)v3 + 4), *((void *)array + 2), *((void *)array + 3));
      }
      if (value) {
        *CGPDFReal value = array;
      }
      LOBYTE(array) = array != 0;
    }
  }
  return (char)array;
}

BOOL CGPDFDictionaryGetArray(CGPDFDictionaryRef dict, const char *key, CGPDFArrayRef *value)
{
  if (value) {
    *CGPDFReal value = 0;
  }
  valuedouble a = 0;
  BOOL Object = CGPDFDictionaryGetObject(dict, key, &valuea);
  if (Object)
  {
    if (valuea)
    {
      int v5 = *((_DWORD *)valuea + 2);
      LOBYTE(Object) = v5 == 7;
      if (v5 == 7 && value != 0)
      {
        *CGPDFReal value = (CGPDFArrayRef)*((void *)valuea + 4);
        LOBYTE(Object) = 1;
      }
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFDictionaryGetDictionary(CGPDFDictionaryRef dict, const char *key, CGPDFDictionaryRef *value)
{
  if (value) {
    *CGPDFReal value = 0;
  }
  valuedouble a = 0;
  BOOL Object = CGPDFDictionaryGetObject(dict, key, &valuea);
  if (Object)
  {
    if (valuea)
    {
      int v5 = *((_DWORD *)valuea + 2);
      LOBYTE(Object) = v5 == 8;
      if (v5 == 8 && value != 0)
      {
        *CGPDFReal value = (CGPDFDictionaryRef)*((void *)valuea + 4);
        LOBYTE(Object) = 1;
      }
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFDictionaryGetObject(CGPDFDictionaryRef dict, const char *key, CGPDFObjectRef *value)
{
  if (value) {
    *CGPDFReal value = 0;
  }
  if (dict)
  {
    UnresolvedBOOL Object = CGPDFDictionaryGetUnresolvedObject((uint64_t)dict, (void *)key);
    if (UnresolvedObject)
    {
      if (*((_DWORD *)UnresolvedObject + 2) == 10) {
        UnresolvedBOOL Object = pdf_xref_resolve(*((void *)dict + 3), UnresolvedObject[2], UnresolvedObject[3]);
      }
      if (value) {
        *CGPDFReal value = (CGPDFObjectRef)UnresolvedObject;
      }
      LOBYTE(UnresolvedObject) = 1;
    }
  }
  else
  {
    LOBYTE(UnresolvedObject) = 0;
  }
  return (char)UnresolvedObject;
}

void *CGPDFDictionaryGetUnresolvedObject(uint64_t a1, void *__key)
{
  BOOL result = 0;
  if (a1 && __key)
  {
    BOOL result = bsearch(__key, *(const void **)(a1 + 64), *(void *)(a1 + 16), 8uLL, (int (__cdecl *)(const void *, const void *))compare_key);
    if (result) {
      return **(void ***)result;
    }
  }
  return result;
}

char *pdf_xref_resolve(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v57 = 0;
  long long v55 = 0u;
  long long v56 = 0u;
  double v6 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (a2 >= *(void *)(a1 + 160)) {
    goto LABEL_43;
  }
  if (*(unsigned char *)(a1 + 200) && a2 < *(void *)(a1 + 192))
  {
    *(unsigned char *)(a1 + 200) = 0;
    uint64_t v7 = *(void *)(a1 + 16);
    if (v7)
    {
      double v9 = (void *)(v7 + 8);
      uint64_t v8 = *(void *)(v7 + 8);
      if (v8 && (uint64_t v10 = *(void *)(v8 + 8)) != 0)
      {
        double v11 = *(CGPDFDictionary **)(v10 + 16);
        uint64_t v58 = 0;
        if (v11)
        {
          while (CGPDFDictionaryGetOffset(v11, "Prev", &v58) && v58)
          {
            CFRange v18 = (void *)(v7 + 8);
            while (1)
            {
              CFRange v18 = (void *)*v18;
              if (!v18) {
                break;
              }
              if (*(void *)(v18[1] + 8) == v58) {
                goto LABEL_18;
              }
            }
            int v19 = xref_table_create(v7, v58, v12, v13, v14, v15, v16, v17);
            if (!v19)
            {
              if (!*(unsigned char *)(a1 + 201)) {
                goto LABEL_43;
              }
              uint64_t v51 = *(void *)(a1 + 16);
              if (v51 && (uint64_t v52 = *(void *)(v51 + 8)) != 0 && (v53 = *(void *)(v52 + 8)) != 0) {
                CGFloat v54 = *(const void **)(v53 + 16);
              }
              else {
                CGFloat v54 = 0;
              }
              double v41 = (char *)CGPDFXRefTableCreateByScanningObjects((const void **)a1, v54);
              if (v41)
              {
                CGPDFXRefTableRelease(*(void *)(a1 + 16));
                *(void *)(a1 + 16) = v41;
                goto LABEL_35;
              }
              goto LABEL_40;
            }
            CGPDFObjectRef v20 = v19;
            float v21 = (void *)*v9;
            CFRange v22 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
            *CFRange v22 = v21;
            v22[1] = v20;
            *double v9 = v22;
          }
        }
      }
      else
      {
        uint64_t v58 = 0;
      }
LABEL_18:
      float v23 = (void *)*v9;
      if (*v9)
      {
        float v24 = 0;
        do
        {
          double v25 = v23;
          float v23 = (void *)*v23;
          void *v25 = v24;
          float v24 = v25;
        }
        while (v23);
      }
      else
      {
        double v25 = 0;
      }
      *double v9 = v25;
    }
    else
    {
      uint64_t v26 = *(void *)(a1 + 8);
      if (v26)
      {
        float v28 = (void *)(v26 + 8);
        uint64_t v27 = *(void *)(v26 + 8);
        if (v27)
        {
          double v29 = *(char **)(v27 + 8);
          if (v29)
          {
            while (1)
            {
              uint64_t v58 = 0;
              if (!CGPDFDictionaryGetOffset(*((CGPDFDictionary **)v29 + 1), "Prev", &v58)) {
                break;
              }
              if (!v58) {
                goto LABEL_35;
              }
              CGFloat v36 = (uint64_t **)(v26 + 8);
              while (1)
              {
                CGFloat v36 = (uint64_t **)*v36;
                if (!v36) {
                  break;
                }
                if (*v36[1] == v58) {
                  goto LABEL_35;
                }
              }
              CGFloat v37 = xref_stream_create(*(uint64_t **)(v26 + 16), v58, v30, v31, v32, v33, v34, v35);
              if (!v37) {
                goto LABEL_35;
              }
              double v29 = v37;
              double v38 = (void *)*v28;
              double v39 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
              *double v39 = v38;
              v39[1] = v29;
              *float v28 = v39;
            }
            double v48 = (void *)*v28;
            if (*v28)
            {
              double v49 = 0;
              do
              {
                double v50 = v48;
                double v48 = (void *)*v48;
                *double v50 = v49;
                double v49 = v50;
              }
              while (v48);
            }
            else
            {
              double v50 = 0;
            }
            *float v28 = v50;
          }
        }
      }
    }
  }
LABEL_35:
  uint64_t v40 = *(void *)(a1 + 168);
  double v41 = (char *)(v40 + 40 * a2);
  int v42 = v41 + 12;
  if (v41[12]) {
    goto LABEL_40;
  }
  if ((v41[12] & 2) != 0)
  {
LABEL_43:
    pthread_mutex_unlock(v6);
    return 0;
  }
  *int v42 = v41[12] | 2;
  uint64_t v43 = *(void *)(a1 + 16);
  if (!v43)
  {
    if (CGPDFXRefStreamGetObject(*(void **)(a1 + 8), a2, a3, (uint64_t)&v55)) {
      goto LABEL_39;
    }
    goto LABEL_42;
  }
  if ((CGPDFXRefTableGetObject(v43, a2, a3, (uint64_t)&v55) & 1) == 0)
  {
LABEL_42:
    *v42 &= ~2u;
    goto LABEL_43;
  }
LABEL_39:
  long long v44 = v55;
  long long v45 = v56;
  *((void *)v41 + 4) = v57;
  *(_OWORD *)double v41 = v44;
  *((_OWORD *)v41 + 1) = v45;
  *v42 |= 1u;
  uint64_t v46 = v40 + 40 * a2;
  *(void *)(v46 + 16) = a2;
  *(void *)(v46 + 24) = a3;
  CGPDFObjectSetObjectReference(v46, a2, a3);
LABEL_40:
  pthread_mutex_unlock(v6);
  return v41;
}

uint64_t pdf_object_scanner_read_indirect_object(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  memset(v55, 0, sizeof(v55));
  if (pdf_object_scanner_read_integer(a1[2], &v57, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v16 = v57;
    if (pdf_object_scanner_read_integer(a1[2], &v57, v10, v11, v12, v13, v14, v15))
    {
      unsigned __int16 v23 = v57;
      if (pdf_lexer_scan(a1[2], (uint64_t)v55, v17, v18, v19, v20, v21, v22) == 16)
      {
        uint64_t result = pdf_object_scanner_read_object(a1, a2, v24, v25, v26, v27, v28, v29);
        if (!result) {
          return result;
        }
        int v44 = pdf_lexer_scan(a1[2], (uint64_t)v55, v31, v32, v33, v34, v35, v36);
        if ((DWORD2(v55[0]) - 5) <= 4) {
          pdf_object_release_compound_value((uint64_t)v55);
        }
        if (v44 != 14) {
          goto LABEL_36;
        }
        if (a2 && *(_DWORD *)(a2 + 8) == 8)
        {
          long long v45 = *(CGPDFDictionary **)(a2 + 32);
          while (1)
          {
            int v46 = CGPDFSourceGetc(a1[1], v37, v38, v39, v40, v41, v42, v43);
            if (v46 == -1 || v46 == 10) {
              break;
            }
            if (v46 == 13)
            {
              int v48 = CGPDFSourceGetc(a1[1], v37, v38, v39, v40, v41, v42, v43);
              if (v48 != 10) {
                CGPDFSourceUngetc((void *)a1[1], v48);
              }
              break;
            }
          }
          double v49 = (void *)a1[1];
          if (v49)
          {
            uint64_t v50 = v49[11];
            if (v49[18])
            {
              uint64_t v51 = v49[24];
              v50 += v49[15];
            }
            else
            {
              uint64_t v51 = v49[16];
            }
            uint64_t v53 = v51 - v50 + v49[14];
          }
          else
          {
            uint64_t v53 = -1;
          }
          uint64_t v54 = CGPDFStreamCreate(*a1, v45, v49, v53);
          if (v54)
          {
            *(_DWORD *)(a2 + 8) = 9;
            *(void *)(a2 + 32) = v54;
LABEL_36:
            CGPDFObjectSetObjectReference(a2, v16, v23);
            return 1;
          }
        }
        else
        {
          pdf_error("missing or invalid stream dictionary for object.");
        }
        if ((*(_DWORD *)(a2 + 8) - 5) <= 4)
        {
          uint64_t v52 = (_OWORD *)a2;
          goto LABEL_27;
        }
      }
      else
      {
        pdf_error("\"obj\" not found while reading object (%lu, %hu).", v16, v23);
        if ((DWORD2(v55[0]) - 5) <= 4)
        {
          uint64_t v52 = v55;
LABEL_27:
          pdf_object_release_compound_value((uint64_t)v52);
        }
      }
    }
    else
    {
      pdf_error("missing or invalid generation number.");
    }
  }
  else
  {
    pdf_error("missing or invalid object number.");
  }
  return 0;
}

uint64_t pdf_object_scanner_read_compound_object(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  uint64_t v11 = 0;
  uint64_t v12 = (a3 + 1);
  uint64_t v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  uint64_t v13 = "missing or invalid generation number.";
  while (2)
  {
    int v14 = pdf_lexer_scan(a1[2], (uint64_t)&v41, a3, a4, a5, a6, a7, a8);
    switch(v14)
    {
      case 0:
      case 15:
        if (v11)
        {
          do
          {
            uint64_t v25 = *(void *)v11;
            if ((*(_DWORD *)(v11 + 8) - 5) <= 4) {
              pdf_object_release_compound_value(v11);
            }
            free((void *)v11);
            uint64_t v11 = v25;
          }
          while (v25);
        }
        return 0;
      case 1:
        handle_choke((uint64_t)&v41);
        if (v11)
        {
          do
          {
            uint64_t v27 = *(void *)v11;
            if ((*(_DWORD *)(v11 + 8) - 5) <= 4) {
              pdf_object_release_compound_value(v11);
            }
            free((void *)v11);
            uint64_t v11 = v27;
          }
          while (v27);
        }
        goto LABEL_42;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 8:
      case 13:
        goto LABEL_5;
      case 7:
        if (DWORD2(v41) == 5) {
          uint64_t v28 = v43;
        }
        else {
          uint64_t v28 = 0;
        }
        if (v11)
        {
          do
          {
            uint64_t v29 = *(void *)v11;
            if ((*(_DWORD *)(v11 + 8) - 5) <= 4) {
              pdf_object_release_compound_value(v11);
            }
            free((void *)v11);
            uint64_t v11 = v29;
          }
          while (v29);
        }
LABEL_42:
        if ((DWORD2(v41) - 5) <= 4) {
          pdf_object_release_compound_value((uint64_t)&v41);
        }
        return 0;
      case 9:
      case 11:
        if (v8 >= 512)
        {
          pdf_error("exceeded array or dictionary nesting limit.");
          return 0;
        }
        if ((pdf_object_scanner_read_compound_object(a1, &v41, v12) & 1) == 0)
        {
          if (v11)
          {
            do
            {
              uint64_t v26 = *(void *)v11;
              if ((*(_DWORD *)(v11 + 8) - 5) <= 4) {
                pdf_object_release_compound_value(v11);
              }
              free((void *)v11);
              uint64_t v11 = v26;
            }
            while (v26);
          }
          return 0;
        }
LABEL_5:
        uint64_t v15 = malloc_type_calloc(1uLL, 0x28uLL, 0x33BCE901uLL);
        __CFSetLastAllocationEventName();
        *uint64_t v15 = 0;
        long long v17 = v41;
        long long v16 = v42;
        v15[4] = v43;
        *(_OWORD *)uint64_t v15 = v17;
        *((_OWORD *)v15 + 1) = v16;
        *uint64_t v15 = v11;
        uint64_t v11 = (uint64_t)v15;
        continue;
      case 10:
        if (v11)
        {
          uint64_t v30 = 0;
          do
          {
            uint64_t v31 = v11;
            uint64_t v11 = *(void *)v11;
            *(void *)uint64_t v31 = v30;
            uint64_t v30 = v31;
          }
          while (v11);
        }
        else
        {
          uint64_t v31 = 0;
        }
        uint64_t v37 = (pthread_mutex_t *)CGPDFDictionaryCreateWithObjects(*a1, (void **)v31);
        if (v37)
        {
          int v38 = 8;
          goto LABEL_70;
        }
        if (!v31) {
          return 0;
        }
        do
        {
          uint64_t v39 = *(void **)v31;
          if ((*(_DWORD *)(v31 + 8) - 5) <= 4) {
            pdf_object_release_compound_value(v31);
          }
          free((void *)v31);
          uint64_t result = 0;
          uint64_t v31 = (uint64_t)v39;
        }
        while (v39);
        return result;
      case 12:
        if (v11)
        {
          uint64_t v32 = 0;
          do
          {
            uint64_t v33 = v11;
            uint64_t v11 = *(void *)v11;
            *(void *)uint64_t v33 = v32;
            uint64_t v32 = v33;
          }
          while (v11);
        }
        else
        {
          uint64_t v33 = 0;
        }
        uint64_t v37 = CGPDFArrayCreateWithObjects(*a1, (void *)v33);
        if (v37)
        {
          int v38 = 7;
LABEL_70:
          *(_DWORD *)(a2 + 8) = v38;
          *(unsigned char *)(a2 + 12) |= 1u;
          *(void *)(a2 + 16) = 0;
          *(void *)(a2 + 24) = 0;
          *(void *)(a2 + 32) = v37;
          return 1;
        }
        else
        {
          if (!v33) {
            return 0;
          }
          do
          {
            uint64_t v40 = *(void *)v33;
            if ((*(_DWORD *)(v33 + 8) - 5) <= 4) {
              pdf_object_release_compound_value(v33);
            }
            free((void *)v33);
            uint64_t result = 0;
            uint64_t v33 = v40;
          }
          while (v40);
        }
        return result;
      case 18:
        if (!v11) {
          goto LABEL_58;
        }
        int v18 = *(_DWORD *)(v11 + 8);
        if (v18 == 12 || v18 == 3)
        {
          uint64_t v20 = *(void *)(v11 + 32);
          uint64_t v21 = *(void *)v11;
          free((void *)v11);
          if (!v21)
          {
            uint64_t v13 = "missing or invalid object number.";
LABEL_58:
            pdf_error(v13);
            return 0;
          }
          int v22 = *(_DWORD *)(v21 + 8);
          if (v22 != 12 && v22 != 3)
          {
            uint64_t v11 = v21;
            pdf_error("missing or invalid object number.");
            goto LABEL_60;
          }
          uint64_t v24 = *(void *)(v21 + 32);
          *(_DWORD *)(v21 + 8) = 10;
          *(unsigned char *)(v21 + 12) &= ~1u;
          *(void *)(v21 + 16) = v24;
          *(_WORD *)(v21 + 24) = v20;
          *(_DWORD *)(v21 + 26) = 0;
          *(_WORD *)(v21 + 30) = 0;
          uint64_t v11 = v21;
          continue;
        }
        pdf_error("missing or invalid generation number.");
        do
        {
LABEL_60:
          uint64_t v36 = *(void *)v11;
          if ((*(_DWORD *)(v11 + 8) - 5) <= 4) {
            pdf_object_release_compound_value(v11);
          }
          free((void *)v11);
          uint64_t v11 = v36;
        }
        while (v36);
        return 0;
      default:
        pdf_error("encountered unexpected object type: %d.", v14);
        if (v11)
        {
          do
          {
            uint64_t v34 = *(void *)v11;
            if ((*(_DWORD *)(v11 + 8) - 5) <= 4) {
              pdf_object_release_compound_value(v11);
            }
            free((void *)v11);
            uint64_t v11 = v34;
          }
          while (v34);
        }
        return 0;
    }
  }
}

BOOL pdf_object_scanner_read_integer(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  int v9 = pdf_lexer_scan(a1, (uint64_t)v14, a3, a4, a5, a6, a7, a8);
  int v10 = v9;
  if (v9 == 4)
  {
    if ((DWORD2(v14[0]) == 12 || DWORD2(v14[0]) == 3) && a2 != 0) {
      *a2 = v15;
    }
  }
  else
  {
    pdf_error("encountered unexpected object type: %d.", v9);
    if ((DWORD2(v14[0]) - 5) <= 4) {
      pdf_object_release_compound_value((uint64_t)v14);
    }
  }
  return v10 == 4;
}

uint64_t CGPDFObjectSetObjectReference(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    *(void *)(result + 16) = a2;
    *(void *)(result + 24) = a3;
    switch(*(_DWORD *)(result + 8))
    {
      case 6:
        uint64_t v5 = *(void *)(result + 32);
        if (v5)
        {
          *(void *)(v5 + 32) = a2;
          *(void *)(v5 + 40) = a3;
        }
        break;
      case 7:
        double v6 = *(void **)(result + 32);
        uint64_t result = (uint64_t)CGPDFArraySetObjectReference(v6, a2, a3);
        break;
      case 8:
        uint64_t v7 = *(void **)(result + 32);
        uint64_t result = (uint64_t)CGPDFDictionarySetObjectReference(v7, a2, a3);
        break;
      case 9:
        int v8 = *(void **)(result + 32);
        if (v8)
        {
          v8[3] = a2;
          v8[4] = a3;
          uint64_t v9 = v8[6];
          if (v9)
          {
            for (size_t i = *(uint64_t **)(v9 + 56); i; size_t i = *(uint64_t **)*i)
              uint64_t result = CGPDFObjectSetOwningReference(*i, a2, a3);
          }
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

void *CGPDFDictionarySetObjectReference(void *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    result[4] = a2;
    result[5] = a3;
    for (size_t i = (uint64_t *)result[7]; i; size_t i = *(uint64_t **)*i)
      uint64_t result = (void *)CGPDFObjectSetOwningReference(*i, a2, a3);
  }
  return result;
}

uint64_t CGPDFObjectSetOwningReference(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    int v5 = *(_DWORD *)(result + 8);
    switch(v5)
    {
      case 6:
        uint64_t v7 = *(void *)(result + 32);
        if (v7)
        {
          *(void *)(v7 + 48) = a2;
          *(void *)(v7 + 56) = a3;
        }
        break;
      case 7:
        uint64_t v8 = *(void *)(result + 32);
        if (v8)
        {
          for (size_t i = *(void **)(v8 + 24); i; size_t i = (void *)*i)
            uint64_t result = CGPDFObjectSetOwningReference(i, a2, a3);
        }
        break;
      case 8:
        uint64_t v6 = *(void *)(result + 32);
        return CGPDFDictionarySetOwningReference(v6, a2, a3);
    }
  }
  return result;
}

void *CGPDFDictionaryCreateWithObjects(uint64_t a1, void **a2)
{
  int v2 = a2;
  if (a2)
  {
    unint64_t v4 = 0;
    int v5 = a2;
    do
    {
      ++v4;
      int v5 = (void *)*v5;
    }
    while (v5);
    if (v4)
    {
      pdf_error("missing key or value while building dictionary.");
    }
    else
    {
      size_t v6 = v4 >> 1;
      uint64_t v7 = a2;
      while (*((_DWORD *)v7 + 2) == 5)
      {
        uint64_t v7 = (void **)**v7;
        if (!v7) {
          goto LABEL_10;
        }
      }
      pdf_error("found non-name key while building dictionary.");
    }
    return 0;
  }
  else
  {
    size_t v6 = 0;
LABEL_10:
    if (CGPDFDictionaryGetTypeID_onceToken != -1) {
      dispatch_once(&CGPDFDictionaryGetTypeID_onceToken, &__block_literal_global_15715);
    }
    uint64_t cftype = pdf_create_cftype();
    uint64_t v9 = (void *)cftype;
    if (cftype)
    {
      pthread_mutex_init((pthread_mutex_t *)(cftype + 72), 0);
      v9[2] = v6;
      _OWORD v9[3] = a1;
      v9[6] = 0;
      v9[7] = v2;
      v9[4] = 0;
      v9[5] = 0;
      int v10 = malloc_type_calloc(v6, 8uLL, 0x33BCE901uLL);
      __CFSetLastAllocationEventName();
      v9[8] = v10;
      if (v2)
      {
        uint64_t v11 = 0;
        do
        {
          *(void *)(v9[8] + v11) = v2;
          int v2 = (void **)**v2;
          v11 += 8;
        }
        while (v2);
        int v10 = (void *)v9[8];
      }
      qsort(v10, v6, 8uLL, (int (__cdecl *)(const void *, const void *))compare_names_15717);
    }
  }
  return v9;
}

uint64_t pdf_create_cftype()
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    pdf_error("Unable to create CFRuntime object because _CFRuntimeCreateInstance(...) failed, likely due to an unknown object type ID.");
  }
  return Instance;
}

uint64_t pdf_object_scanner_read_object(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v15 = pdf_lexer_scan(a1[2], a2, a3, a4, a5, a6, a7, a8);
  uint64_t result = 0;
  switch(v15)
  {
    case 0:
    case 15:
      return result;
    case 1:
      handle_choke(a2);
      goto LABEL_9;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 8:
    case 13:
      return 1;
    case 7:
      goto LABEL_9;
    case 9:
    case 11:
      return pdf_object_scanner_read_compound_object(a1, a2, 1, v10, v11, v12, v13, v14);
    default:
      pdf_error("encountered unexpected object type: %d.");
LABEL_9:
      if ((*(_DWORD *)(a2 + 8) - 5) <= 4) {
        pdf_object_release_compound_value(a2);
      }
      uint64_t result = 0;
      *(_DWORD *)(a2 + 8) = 1;
      return result;
  }
}

uint64_t CGPDFXRefTableGetObject(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void **)(a1 + 8);
  if (!v4) {
    return 0;
  }
  while (1)
  {
    uint64_t v9 = v4[1];
    object_offset = xref_table_get_object_offset(*(void **)(v9 + 40), a2, a3);
    if (object_offset) {
      break;
    }
    long long v17 = *(uint64_t **)(v9 + 32);
    if (v17)
    {
      uint64_t v18 = *v17;
      if (CGPDFXRefStreamGetObject(v17, a2, a3, a4)) {
        return 1;
      }
      if (v18 && *(void *)(v18 + 16) != a1) {
        return 0;
      }
    }
    unint64_t v4 = (void *)*v4;
    if (!v4) {
      return 0;
    }
  }
  CGPDFSourceSetPosition(*(void *)(*(void *)(a1 + 16) + 8), (uint64_t)object_offset, v11, v12, v13, v14, v15, v16);
  uint64_t v26 = *(uint64_t **)(a1 + 16);

  return pdf_object_scanner_read_indirect_object(v26, a4, v20, v21, v22, v23, v24, v25);
}

void *xref_table_get_object_offset(void *result, unint64_t a2, unsigned __int16 a3)
{
  if (result)
  {
    while (1)
    {
      CGPDFArrayRef v3 = (void *)result[1];
      unint64_t v4 = a2 - *v3;
      if (a2 >= *v3 && a2 < v3[1] + *v3)
      {
        uint64_t v5 = v3[2];
        if (v5) {
          LODWORD(v5) = *(unsigned __int16 *)(v5 + 2 * v4);
        }
        if (v5 == a3) {
          break;
        }
      }
      uint64_t result = (void *)*result;
      if (!result) {
        return result;
      }
    }
    return (void *)v3[v4 + 3];
  }
  return result;
}

pthread_mutex_t *CGPDFArrayCreateWithObjects(uint64_t a1, void *a2)
{
  if (CGPDFArrayGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFArrayGetTypeID_onceToken, &__block_literal_global_5511);
  }
  uint64_t cftype = (pthread_mutex_t *)pdf_create_cftype();
  uint64_t v5 = cftype;
  if (cftype)
  {
    pthread_mutex_init(cftype + 1, 0);
    uint64_t v6 = 0;
    if (a2)
    {
      uint64_t v7 = a2;
      do
      {
        ++v6;
        uint64_t v7 = (void *)*v7;
      }
      while (v7);
    }
    *(void *)&v5->__opaque[8] = v6;
    *(void *)&v5->__opaque[16] = a2;
    *(void *)&v5->__opaque[24] = a1;
    *(void *)&v5->__opaque[32] = 0;
    *(void *)&v5->__opaque[40] = 0;
    *(void *)&v5->__opaque[48] = 0;
  }
  return v5;
}

CGPDFDictionaryRef get_pages_dictionary(uint64_t a1)
{
  CGPDFDictionaryRef dict = 0;
  CGPDFDictionaryRef value = 0;
  trailer = (CGPDFDictionary *)pdf_xref_get_trailer(a1);
  if (CGPDFDictionaryGetDictionary(trailer, "Root", &value)) {
    int v2 = value;
  }
  else {
    int v2 = 0;
  }
  DictionarCGFloat y = CGPDFDictionaryGetDictionary(v2, "Pages", &dict);
  CGPDFDictionaryRef result = 0;
  if (Dictionary)
  {
    BOOL v5 = is_page_tree_node((BOOL)dict);
    CGPDFDictionaryRef result = dict;
    if (!v5)
    {
      if (CGPDFDictionaryGetDictionary(dict, "Parent", &dict))
      {
        if (is_page_tree_node((BOOL)dict)) {
          return dict;
        }
        else {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t pdf_xref_get_trailer(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 8);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
        uint64_t v4 = v3 + 16;
        return *(void *)v4;
      }
    }
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (v5)
    {
      uint64_t v6 = *(void *)(v5 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 + 8);
        if (v7)
        {
          uint64_t v4 = v7 + 8;
          return *(void *)v4;
        }
      }
    }
  }
  return 0;
}

BOOL is_page_tree_node(BOOL result)
{
  if (result)
  {
    uint64_t v1 = (CGPDFDictionary *)result;
    pthread_mutexattr_t __s1 = 0;
    CGPDFDictionaryRef result = CGPDFDictionaryGetName((CGPDFDictionaryRef)result, "Type", (const char **)&__s1) && !strcmp(__s1, "Pages")
          || (CGPDFObjectRef value = 0, CGPDFDictionaryGetObject(v1, "Kids", &value))
          && value
          && *((_DWORD *)value + 2) == 7
          && CGPDFDictionaryGetInteger(v1, "Count", 0);
  }
  return result;
}

BOOL CGPDFDictionaryGetName(CGPDFDictionaryRef dict, const char *key, const char **value)
{
  if (value) {
    *CGPDFObjectRef value = (const char *)&unk_185294DFC;
  }
  valuedouble a = 0;
  BOOL Object = CGPDFDictionaryGetObject(dict, key, &valuea);
  if (Object)
  {
    if (valuea)
    {
      int v5 = *((_DWORD *)valuea + 2);
      LOBYTE(Object) = v5 == 5;
      if (v5 == 5 && value != 0)
      {
        *CGPDFObjectRef value = (const char *)*((void *)valuea + 4);
        LOBYTE(Object) = 1;
      }
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

uint64_t CGPDFDictionarySetOwningReference(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    for (size_t i = *(void ***)(result + 56); i; size_t i = (void **)**i)
      CGPDFDictionaryRef result = CGPDFObjectSetOwningReference(*i, a2, a3);
  }
  return result;
}

uint64_t read_hex_string(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = -1;
  while (2)
  {
    if (a2 <= 0xD && ((1 << a2) & 0x3601) != 0) {
      goto LABEL_4;
    }
    switch((int)a2)
    {
      case ' ':
        goto LABEL_4;
      case '!':
      case '""':
      case '#':
      case '$':
      case '&':
      case '\'':
      case '(':
      case ')':
      case '*':
      case '+':
      case ',':
      case '-':
      case '.':
      case '/':
      case ':':
      case ';':
      case '<':
      case '=':
      case '?':
      case '@':
        goto LABEL_22;
      case '%':
        pdf_error("illegal comment encountered in hex string.");
        skip_comment(a1, v13, v14, v15, v16, v17, v18, v19);
        uint64_t v10 = a1[2];
        uint64_t v11 = *(void *)(v10 + 120);
        if (v11) {
          goto LABEL_9;
        }
        char v22 = CGPDFSourceRefill(a1[2], v20, a3, a4, a5, a6, a7, a8);
        a2 = 0xFFFFFFFFLL;
        if (v22) {
          goto LABEL_6;
        }
        continue;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        int v23 = -48;
        goto LABEL_16;
      case '>':
        if (v9 < 0) {
          goto LABEL_28;
        }
        unint64_t v31 = a1[3];
        unint64_t v32 = a1[4];
        uint64_t v33 = (void *)a1[5];
        if (v31 < v32) {
          goto LABEL_27;
        }
        size_t v34 = 2 * v32 + 128;
        a1[4] = v34;
        uint64_t v33 = malloc_type_realloc(v33, v34, 0x33EA2F66uLL);
        a1[5] = v33;
        if (!v33) {
          goto LABEL_30;
        }
        unint64_t v31 = a1[3];
LABEL_27:
        a1[3] = v31 + 1;
        *((unsigned char *)v33 + v31) = 16 * v9;
LABEL_28:
        uint64_t v30 = 8;
        int v29 = 1;
        goto LABEL_29;
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        int v23 = -55;
        goto LABEL_16;
      default:
        if ((a2 - 97) < 6)
        {
          int v23 = -87;
LABEL_16:
          char v24 = a2 + v23;
          if (v9 < 0)
          {
            int v9 = a2 + v23;
          }
          else
          {
            unint64_t v25 = a1[3];
            unint64_t v26 = a1[4];
            uint64_t v27 = (void *)a1[5];
            if (v25 >= v26)
            {
              size_t v28 = 2 * v26 + 128;
              a1[4] = v28;
              uint64_t v27 = malloc_type_realloc(v27, v28, 0x33EA2F66uLL);
              a1[5] = v27;
              if (!v27) {
LABEL_30:
              }
                _CGHandleAssert("lex_grow_buffer", 55, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Reader/CGPDFLexer.c", "lexer->buffer != NULL", "lexer buffer missing", a6, a7, a8, v36);
              unint64_t v25 = a1[3];
            }
            a1[3] = v25 + 1;
            *((unsigned char *)v27 + v25) = v24 + 16 * v9;
            int v9 = -1;
          }
LABEL_4:
          uint64_t v10 = a1[2];
          uint64_t v11 = *(void *)(v10 + 120);
          if (v11) {
            goto LABEL_9;
          }
          int v12 = CGPDFSourceRefill(a1[2], a2, a3, a4, a5, a6, a7, a8);
          a2 = 0xFFFFFFFFLL;
          if (v12)
          {
LABEL_6:
            uint64_t v11 = *(void *)(v10 + 120);
LABEL_9:
            uint64_t v21 = *(unsigned __int8 **)(v10 + 128);
            *(void *)(v10 + 120) = v11 - 1;
            *(void *)(v10 + 128) = v21 + 1;
            a2 = *v21;
          }
          continue;
        }
LABEL_22:
        int v29 = 0;
        uint64_t v30 = 1;
LABEL_29:
        create_string_object((uint64_t)a1, v29);
        return v30;
    }
  }
}

uint64_t create_string_object(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(const void **)(a1 + 40);
  size_t v6 = *(void *)(a1 + 24);
  int v7 = *(_DWORD *)(a1 + 56);
  if (CGPDFStringGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFStringGetTypeID_onceToken, &__block_literal_global_2217);
  }
  uint64_t result = pdf_create_cftype();
  uint64_t v9 = result;
  if (result)
  {
    *(_DWORD *)(result + 16) = 0;
    *(void *)(result + 24) = v4;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(void *)(result + 72) = v6;
    if (a2) {
      char v10 = 2;
    }
    else {
      char v10 = 0;
    }
    *(unsigned char *)(result + 64) = v10 | (v7 == 2) | *(unsigned char *)(result + 64) & 0xFC;
    uint64_t result = (uint64_t)memcpy((void *)(result + 80), v5, v6);
    *(unsigned char *)(v9 + 80 + v6) = 0;
  }
  uint64_t v11 = *(void *)(a1 + 48);
  *(_DWORD *)(v11 + 8) = 6;
  *(unsigned char *)(v11 + 12) |= 1u;
  *(void *)(*(void *)(a1 + 48) + 32) = v9;
  return result;
}

uint64_t CGPDFSourceReverseSearch(void *a1, char *__s, char *a3, char *a4, void *a5)
{
  if (!__s) {
    return 0;
  }
  int64_t v8 = strlen(__s);
  size_t v12 = v8;
  if (a1)
  {
    uint64_t v13 = a1[11];
    if (a1[18])
    {
      uint64_t v14 = a1[24];
      v13 += a1[15];
    }
    else
    {
      uint64_t v14 = a1[16];
    }
    uint64_t v16 = v14 - v13;
    uint64_t v66 = a1[2];
    if (v66 == -1) {
      _CGHandleAssert("CGPDFSourceGetLength", 179, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Reader/CGPDFSource.c", "source->length != (pdf_off_t)-1", "source length would overflow", v9, v10, v11, v56);
    }
    uint64_t v15 = v16 + a1[14];
  }
  else
  {
    uint64_t v66 = 0;
    uint64_t v15 = -1;
  }
  if (v15 < v8) {
    return 0;
  }
  size_t v18 = 64;
  do
  {
    size_t v19 = v18;
    v18 *= 2;
  }
  while (v19 < v12);
  char __dst = 0;
  uint64_t v20 = (char *)malloc_type_malloc(v18, 0xF7414A9FuLL);
  uint64_t v27 = v20;
  if (v15 < 1)
  {
LABEL_42:
    uint64_t v17 = 0;
    goto LABEL_43;
  }
  uint64_t v57 = a5;
  uint64_t v58 = &v20[v12 - 1];
  double v60 = v20;
  uint64_t v63 = (uint64_t)a1;
  while (1)
  {
    if (v15 < (uint64_t)v19) {
      size_t v19 = v15;
    }
    CGPDFSourceSetPosition((uint64_t)a1, v15 - v19, v21, v22, v23, v24, v25, v26);
    if (CGPDFSourceRead((uint64_t)a1, (uint64_t)v27, v19, v28, v29, v30, v31, v32) != v19)
    {
      pdf_error("failed to read %zu bytes at offset %lld.", v19, v15 - v19);
      goto LABEL_42;
    }
    uint64_t v59 = v15 - v19;
    double v64 = &v27[v19];
    unint64_t v33 = (unint64_t)&v27[v19 - 1];
    if (v33 >= (unint64_t)v27) {
      break;
    }
LABEL_36:
    v15 -= v19;
    a1 = (void *)v63;
    if (v59 < 1) {
      goto LABEL_42;
    }
  }
  uint64_t v34 = 0;
  size_t v65 = v12 - 1 + v15;
  while (2)
  {
    if (*(unsigned __int8 *)(v33 + v34) != *__s) {
      goto LABEL_35;
    }
    uint64_t v35 = v65 + v34;
    if ((uint64_t)(v65 + v34) > v66) {
      goto LABEL_35;
    }
    if (&v58[v19 + v34] > v64)
    {
      CGPDFSourceSetPosition(v63, v15 + v34 - 1, v21, v22, v23, v24, v25, v26);
      uint64_t v27 = v60;
      if (CGPDFSourceRead(v63, v33 + v34, v12, v36, v37, v38, v39, v40) != v12)
      {
        pdf_error("failed to read %zu bytes at offset %lld.", v12, v15 + v34 - 1);
        goto LABEL_42;
      }
    }
    if (strncmp((const char *)(v33 + v34), __s, v12)) {
      goto LABEL_35;
    }
    if (!a3 || v15 + v34 - 1 < 1)
    {
LABEL_30:
      if (!a4 || v35 >= v66)
      {
LABEL_38:
        *uint64_t v57 = v15 + v34 - 1;
        uint64_t v17 = 1;
        goto LABEL_43;
      }
      CGPDFSourceSetPosition(v63, v35, v21, v22, v23, v24, v25, v26);
      if (CGPDFSourceRead(v63, (uint64_t)&__dst, 1uLL, v48, v49, v50, v51, v52) != 1)
      {
        pdf_error("failed to read %zu bytes at offset %lld.", 1uLL, v35);
        goto LABEL_42;
      }
      int v53 = __dst;
      uint64_t v54 = strchr(a4, __dst);
      if (!v53 || v54) {
        goto LABEL_38;
      }
      goto LABEL_35;
    }
    CGPDFSourceSetPosition(v63, v15 + v34 - 2, v21, v22, v23, v24, v25, v26);
    if (CGPDFSourceRead(v63, (uint64_t)&__dst, 1uLL, v41, v42, v43, v44, v45) == 1)
    {
      int v46 = __dst;
      double v47 = strchr(a3, __dst);
      uint64_t v27 = v60;
      if (!v46 || v47) {
        goto LABEL_30;
      }
LABEL_35:
      --v34;
      if (v33 + v34 < (unint64_t)v27) {
        goto LABEL_36;
      }
      continue;
    }
    break;
  }
  pdf_error("failed to read %zu bytes at offset %lld.", 1uLL, v15 + v34 - 2);
  uint64_t v17 = 0;
  uint64_t v27 = v60;
LABEL_43:
  free(v27);
  return v17;
}

void CGPDFSourceSetPosition(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v8 = a2;
    uint64_t v10 = *(void **)(a1 + 144);
    if (v10)
    {
      if (*(unsigned char *)(a1 + 152)) {
        free(v10);
      }
      *(void *)(a1 + 144) = 0;
    }
    *(unsigned char *)(a1 + 208) = 0;
    if (v8 < 0)
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v11 = *(void *)(a1 + 16);
      if (v11 < v8 && v11 != -1) {
        uint64_t v8 = *(void *)(a1 + 16);
      }
    }
    uint64_t v13 = *(void *)(a1 + 112);
    uint64_t v14 = v8 - v13;
    if (v8 >= v13)
    {
      uint64_t v15 = *(void *)(a1 + 104) + v13;
      BOOL v16 = v15 <= v8;
      uint64_t v17 = v15 - v8;
      if (!v16)
      {
LABEL_18:
        uint64_t v18 = *(void *)(a1 + 88) + v14;
LABEL_21:
        *(void *)(a1 + 120) = v17;
        *(void *)(a1 + 128) = v18;
        return;
      }
      if (!*(void *)(a1 + 40)) {
        goto LABEL_23;
      }
    }
    else if (!*(void *)(a1 + 40))
    {
      CGPDFSourceRewind(a1, a2, a3, a4, a5, a6, a7, a8);
LABEL_23:
      while (1)
      {
        uint64_t v19 = *(void *)(a1 + 112);
        uint64_t v14 = v8 - v19;
        if (v8 >= v19)
        {
          uint64_t v20 = *(void *)(a1 + 104) + v19;
          BOOL v16 = v20 <= v8;
          uint64_t v17 = v20 - v8;
          if (!v16) {
            break;
          }
        }
        if ((CGPDFSourceRefill(a1, a2, a3, a4, a5, a6, a7, a8) & 1) == 0) {
          return;
        }
      }
      goto LABEL_18;
    }
    uint64_t v17 = 0;
    *(void *)(a1 + 32) = v8;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = v8;
    uint64_t v18 = *(void *)(a1 + 88);
    goto LABEL_21;
  }
}

uint64_t CGPDFSourceRead(uint64_t a1, uint64_t __dst, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  if (a1 && __n)
  {
    uint64_t v11 = (char *)__dst;
    size_t v12 = __n;
    while (1)
    {
      size_t v13 = *(void *)(a1 + 120);
      if (v12 <= v13) {
        break;
      }
      if (v11)
      {
        memmove(v11, *(const void **)(a1 + 128), v13);
        size_t v13 = *(void *)(a1 + 120);
        v11 += v13;
      }
      v12 -= v13;
      size_t v14 = *(void *)(a1 + 128) + v13;
      *(void *)(a1 + 120) = 0;
      *(void *)(a1 + 128) = v14;
      if ((CGPDFSourceRefill(a1, __dst, v13, a4, a5, a6, a7, a8) & 1) == 0) {
        return __n - v12;
      }
    }
    if (v11)
    {
      memcpy(v11, *(const void **)(a1 + 128), v12);
      size_t v13 = *(void *)(a1 + 120);
    }
    size_t v15 = *(void *)(a1 + 128) + v12;
    *(void *)(a1 + 120) = v13 - v12;
    *(void *)(a1 + 128) = v15;
    return __n;
  }
  return result;
}

uint64_t pdf_reader_get_linearized_page_dict(uint64_t *a1, unint64_t a2)
{
  uint64_t result = *a1;
  uint64_t v3 = *(void *)(result + 32);
  if (!v3) {
    return 0;
  }
  if (*(void *)(v3 + 16) < a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "page_number is out of range");
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4E8] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E529EE80, MEMORY[0x1E4FBA1E8]);
  }
  uint64_t v4 = *(void *)(*(void *)(v3 + 64) + 48);
  if (a2 - 1 < (*(void *)(*(void *)(v3 + 64) + 56) - v4) >> 6)
  {
    unint64_t v5 = *(void *)(v4 + ((a2 - 1) << 6) + 56);
    if (v5)
    {
      size_t v6 = pdf_xref_resolve(result, v5, 0);
      if (v6)
      {
        if (*((_DWORD *)v6 + 2) == 8)
        {
          int v7 = (CGPDFDictionary *)*((void *)v6 + 4);
          CGPDFObjectRef value = 0;
          if (CGPDFDictionaryGetName(v7, "Type", (const char **)&value) && !strcmp(value, "Page")) {
            return (uint64_t)v7;
          }
        }
      }
    }
    return 0;
  }
  __break(1u);
  return result;
}

void sub_184C95CA4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    (*(void (**)(void *))(*(void *)v11 + 16))(v11);
    pdf_error("%s caught exception: %s");
  }
  else
  {
    pdf_error("%s caught an unknown exception");
  }
  __cxa_end_catch();
  JUMPOUT(0x184C95C30);
}

uint64_t CGPDFResourcesCreate()
{
  if (CGPDFResourcesGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFResourcesGetTypeID_onceToken, &__block_literal_global_17_8141);
  }
  uint64_t result = pdf_create_cftype();
  if (result) {
    *(_DWORD *)(result + 80) = 0;
  }
  return result;
}

BOOL CGPDFArrayGetDictionary(CGPDFArrayRef array, size_t index, CGPDFDictionaryRef *value)
{
  valuedouble a = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 8)
    {
      if (value) {
        *CGPDFObjectRef value = (CGPDFDictionaryRef)*((void *)valuea + 4);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

CGColorSpaceRef create_device_space(const char *a1)
{
  if (!strcmp(a1, "DeviceGray"))
  {
    return CGColorSpaceCreateDeviceGray();
  }
  else if (!strcmp(a1, "DeviceRGB"))
  {
    return CGColorSpaceCreateDeviceRGB();
  }
  else if (!strcmp(a1, "DeviceCMYK"))
  {
    return CGColorSpaceCreateDeviceCMYK();
  }
  else
  {
    return 0;
  }
}

uint64_t CGPDFSourceGetc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9) {
    goto LABEL_4;
  }
  if (CGPDFSourceRefill(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v9 = *(void *)(a1 + 120);
LABEL_4:
    uint64_t v10 = *(unsigned __int8 **)(a1 + 128);
    *(void *)(a1 + 120) = v9 - 1;
    *(void *)(a1 + 128) = v10 + 1;
    return *v10;
  }
  return 0xFFFFFFFFLL;
}

void *table_set_value(__CFDictionary **a1, void *key, void *value)
{
  uint64_t result = 0;
  if (key && value)
  {
    CFArrayRef Mutable = *a1;
    if (!*a1)
    {
      CFArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
      *a1 = Mutable;
    }
    CFDictionarySetValue(Mutable, key, value);
    return value;
  }
  return result;
}

CGColorSpaceRef create_ICCBased(CGPDFArray *a1)
{
  if (!a1 || *((void *)a1 + 2) != 2)
  {
    return 0;
  }
  CGPDFObjectRef v15 = 0;
  CGPDFInteger value = 0;
  CGPDFStreamRef stream = 0;
  if (!CGPDFArrayGetStream(a1, 1uLL, &stream))
  {
    return 0;
  }
  if (stream) {
    uint64_t v1 = (CGPDFDictionary *)*((void *)stream + 6);
  }
  else {
    uint64_t v1 = 0;
  }
  if (!CGPDFDictionaryGetInteger(v1, "N", &value) || value <= 0)
  {
    return 0;
  }
  if ((unint64_t)value > 4 || ((1 << value) & 0x1A) == 0)
  {
    return 0;
  }
  if (!CGPDFDictionaryGetObject(v1, "Alternate", &v15)
    || (CGColorSpaceRef colorspace = (CGColorSpace *)cg_create_colorspace(v15)) == 0)
  {
    switch(value)
    {
      case 4:
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
        goto LABEL_25;
      case 3:
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceRGB();
        goto LABEL_25;
      case 1:
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceGray();
LABEL_25:
        CGColorSpaceRef colorspace = DeviceCMYK;
        goto LABEL_27;
    }
    CGColorSpaceRef colorspace = 0;
  }
LABEL_27:
  size_t v6 = (CGFloat *)malloc_type_malloc(16 * value, 0x100004000313F17uLL);
  if (v6)
  {
    uint64_t v8 = v6;
    if ((get_array(v1, "Range", v6, (CGPDFArray *)(2 * value), 0, v7) & 1) == 0)
    {
      CGPDFInteger v9 = value;
      if (value >= 1)
      {
        uint64_t v10 = v8;
        do
        {
          *(_OWORD *)uint64_t v10 = xmmword_1850CD8C0;
          v10 += 2;
          --v9;
        }
        while (v9);
      }
    }
    CGPDFDataFormat format = CGPDFDataFormatRaw;
    CFDataRef v11 = CGPDFStreamCopyData(stream, &format);
    if (v11)
    {
      CFDataRef v12 = v11;
      if (format)
      {
        CFRelease(v11);
      }
      else
      {
        size_t v13 = CGDataProviderCreateWithCFData(v11);
        CFRelease(v12);
        if (v13)
        {
          ICCBasedouble d = CGColorSpaceCreateICCBased(value, v8, v13, colorspace);
          CGColorSpaceRelease(colorspace);
          CGDataProviderRelease(v13);
          free(v8);
          return ICCBased;
        }
      }
    }
    CGColorSpaceRelease(colorspace);
    free(v8);
  }
  else
  {
    CGColorSpaceRelease(colorspace);
  }
  return 0;
}

uint64_t get_array(CGPDFDictionary *a1, const char *a2, void *a3, CGPDFArray *a4, uint64_t *a5, __n128 a6)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1, a6);
  size_t v13 = (char *)v20 - v12;
  if (v11 <= 0x1FFFFFFFFFFFFFFELL) {
    size_t v14 = (char *)v20 - v12;
  }
  else {
    size_t v14 = 0;
  }
  if (v11 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000082) {
    size_t v14 = (char *)malloc_type_malloc(8 * (void)a4, 0xA1830990uLL);
  }
  if (CGPDFDictionaryGetNumbers(a1, a2, (uint64_t)v14, a4))
  {
    if (a4)
    {
      CGPDFObjectRef v15 = (uint64_t *)v14;
      do
      {
        uint64_t v16 = *v15++;
        *a3++ = v16;
        a4 = (CGPDFArray *)((char *)a4 - 1);
      }
      while (a4);
    }
LABEL_14:
    uint64_t v18 = 1;
    goto LABEL_15;
  }
  if (a5)
  {
    for (; a4; a4 = (CGPDFArray *)((char *)a4 - 1))
    {
      uint64_t v17 = *a5++;
      *a3++ = v17;
    }
    goto LABEL_14;
  }
  uint64_t v18 = 0;
LABEL_15:
  if (v14 != v13) {
    free(v14);
  }
  return v18;
}

BOOL CGPDFArrayGetStream(CGPDFArrayRef array, size_t index, CGPDFStreamRef *value)
{
  valuedouble a = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 9)
    {
      if (value) {
        *CGPDFInteger value = (CGPDFStreamRef)*((void *)valuea + 4);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetName(CGPDFArrayRef array, size_t index, const char **value)
{
  valuedouble a = 0;
  BOOL Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 5)
    {
      if (value) {
        *CGPDFInteger value = (const char *)*((void *)valuea + 4);
      }
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

uint64_t __CGPatternGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGPatternGetTypeID_class);
  CGPatternGetTypeID_pattern_type_idouble d = result;
  return result;
}

uint64_t __CGImageTextureDataGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGImageTextureDataGetTypeID_class);
  CGImageTextureDataGetTypeID_texture_data_type_idouble d = result;
  return result;
}

uint64_t __CGSoftMaskGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGSoftMaskGetTypeID_runtime_class);
  CGSoftMaskGetTypeID_soft_mask_type_idouble d = result;
  return result;
}

uint64_t __CGLayerGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGLayerGetTypeID_class);
  CGLayerGetTypeID_layer_type_idouble d = result;
  return result;
}

uint64_t __CGStyleGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGStyleGetTypeID_class);
  CGStyleGetTypeID_style_type_idouble d = result;
  return result;
}

uint64_t __CGShadingGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGShadingGetTypeID_class);
  CGShadingGetTypeID_shading_type_idouble d = result;
  return result;
}

uint64_t __RIPDataGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(kRIPDataClass);
  RIPDataGetTypeID_data_type_idouble d = result;
  return result;
}

uint64_t __CGFunctionGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGFunctionGetTypeID_runtime_class);
  CGFunctionGetTypeID_function_type_idouble d = result;
  return result;
}

uint64_t __CGGradientGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGGradientGetTypeID_runtime_class);
  CGGradientGetTypeID_gradient_type_idouble d = result;
  return result;
}

uint64_t __CGNotificationCenterGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGNotificationCenterGetTypeID_runtime_class);
  CGNotificationCenterGetTypeID_notification_center_type_idouble d = result;
  return result;
}

uint64_t __CGColorTransformBaseGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGColorTransformBaseGetTypeID_class);
  CGColorTransformBaseGetTypeID_type_idouble d = result;
  return result;
}

uint64_t __CGPathGetTypeID_block_invoke_3()
{
  uint64_t result = __CGTypeRegisterInternal(CGPathGetTypeID::path_class);
  CGPathGetTypeID::path_type_idouble d = result;
  return result;
}

uint64_t __converter_initialize_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(kCGCMSConverterClass);
  kCGCMSConverterID = result;
  return result;
}

uint64_t __CGColorTransformCacheGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGColorTransformCacheGetTypeID_class);
  CGColorTransformCacheGetTypeID_type_idouble d = result;
  return result;
}

uint64_t __CGImageGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGImageGetTypeID_class);
  CGImageGetTypeID_image_type_idouble d = result;
  return result;
}

uint64_t __CGDisplayListGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGDisplayListGetTypeID::dl2_class);
  CGDisplayListGetTypeID::display_list2_type_idouble d = result;
  return result;
}

uint64_t __CGColorTransformGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGColorTransformGetTypeID_class);
  CGColorTransformGetTypeID_type_idouble d = result;
  return result;
}

uint64_t __CGImageProviderGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGImageProviderGetTypeID_class);
  CGImageProviderGetTypeID_image_provider_type_idouble d = result;
  return result;
}

uint64_t __CGContextDelegateGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGContextDelegateGetTypeID_class);
  CGContextDelegateGetTypeID_context_delegate_idouble d = result;
  return result;
}

uint64_t __CGColorGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGColorGetTypeID_class);
  CGColorGetTypeID_color_type_idouble d = result;
  return result;
}

uint64_t __CGFontGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGFontGetTypeID_class);
  CGFontGetTypeID_font_type_idouble d = result;
  return result;
}

uint64_t __CGContextGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGContextGetTypeID_class);
  CGContextGetTypeID_type_idouble d = result;
  return result;
}

uint64_t __CGColorSpaceGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGColorSpaceGetTypeID_class);
  CGColorSpaceGetTypeID_type_idouble d = result;
  return result;
}

uint64_t __CGDataProviderGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGDataProviderGetTypeID_runtime_class);
  CGDataProviderGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGTypeRegisterInternal(unsigned int *a1)
{
  uint64_t v2 = (char *)malloc_type_malloc(0x60uLL, 0x10D00408820D60FuLL);
  uint64_t v3 = *a1;
  *(void *)uint64_t v2 = v3;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 2);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 6);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 10);
  v4.i64[0] = (uint64_t)copy_description;
  v4.i64[1] = (uint64_t)copy_debug_description_22775;
  *(int8x16_t *)(v2 + 56) = vbslq_s8((int8x16_t)vceqzq_s64(*(int64x2_t *)(a1 + 14)), v4, *(int8x16_t *)(a1 + 14));
  if ((v3 & 4) != 0) {
    uint64_t v5 = *((void *)a1 + 9);
  }
  else {
    uint64_t v5 = 0;
  }
  *((void *)v2 + 9) = v5;
  if ((v3 & 8) != 0) {
    uint64_t v6 = *((void *)a1 + 10);
  }
  else {
    uint64_t v6 = 0;
  }
  *((void *)v2 + 10) = v6;
  if ((v3 & 0x10) != 0) {
    uint64_t v7 = *((void *)a1 + 11);
  }
  else {
    uint64_t v7 = 0;
  }
  *((void *)v2 + 11) = v7;

  return _CFRuntimeRegisterClass();
}

CGColorSpaceRef CGColorSpaceCreateFromCICP(__int16 a1)
{
  if ((a1 & 0xF7) != 1 && a1 != 12) {
    return 0;
  }
  if (a1 == 12)
  {
    if (HIBYTE(a1) > 0xFu)
    {
      if (HIBYTE(a1) == 16)
      {
        uint64_t v2 = (CFStringRef *)&kCGColorSpaceDisplayP3_PQ;
        return CGColorSpaceCreateWithName(*v2);
      }
      if (HIBYTE(a1) == 18)
      {
        uint64_t v2 = (CFStringRef *)&kCGColorSpaceDisplayP3_HLG;
        return CGColorSpaceCreateWithName(*v2);
      }
    }
    else
    {
      if (HIBYTE(a1) == 8)
      {
        uint64_t v2 = (CFStringRef *)&kCGColorSpaceLinearDisplayP3;
        return CGColorSpaceCreateWithName(*v2);
      }
      if (HIBYTE(a1) == 13)
      {
        uint64_t v2 = (CFStringRef *)&kCGColorSpaceDisplayP3;
        return CGColorSpaceCreateWithName(*v2);
      }
    }
    return 0;
  }
  if (a1 == 9)
  {
    if (HIBYTE(a1) - 8) < 0xBu && ((0x5E1u >> (HIBYTE(a1) - 8)))
    {
      uint64_t v2 = (CFStringRef *)off_1E52B5000[(HIBYTE(a1) - 8)];
      return CGColorSpaceCreateWithName(*v2);
    }
    return 0;
  }
  if (a1 != 1) {
    return 0;
  }
  if (HIBYTE(a1) <= 0xCu)
  {
    if (HIBYTE(a1) == 1)
    {
      uint64_t v2 = (CFStringRef *)&kCGColorSpaceITUR_709;
      return CGColorSpaceCreateWithName(*v2);
    }
    if (HIBYTE(a1) == 8)
    {
      uint64_t v2 = (CFStringRef *)&kCGColorSpaceLinearSRGB;
      return CGColorSpaceCreateWithName(*v2);
    }
    return 0;
  }
  if (HIBYTE(a1) == 13)
  {
    uint64_t v2 = (CFStringRef *)&kCGColorSpaceSRGB;
    return CGColorSpaceCreateWithName(*v2);
  }
  if (HIBYTE(a1) == 16)
  {
    uint64_t v2 = (CFStringRef *)&kCGColorSpaceITUR_709_PQ;
    return CGColorSpaceCreateWithName(*v2);
  }
  if (HIBYTE(a1) != 18) {
    return 0;
  }
  uint64_t v2 = (CFStringRef *)&kCGColorSpaceITUR_709_HLG;
  return CGColorSpaceCreateWithName(*v2);
}

int8x8_t *cf_color_space_state_hash(int8x8_t *result)
{
  if (result)
  {
    int8x8_t v1 = veor_s8(result[8], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)result[8].i8, *(int8x16_t *)result[8].i8, 8uLL));
    return (int8x8_t *)(v1.i32[0] ^ v1.i32[1]);
  }
  return result;
}

CGColorSpaceRef CGBitmapContextGetColorSpace(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(CGColorSpaceRef *)(*((void *)context + 4) + 32);
  }
  handle_invalid_context((char)"CGBitmapContextGetColorSpace", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

CGColorSpaceRef CGColorSpaceGetBaseColorSpace(CGColorSpaceRef space)
{
  if (space)
  {
    uint64_t v1 = *((void *)space + 3);
    if ((*(_DWORD *)(v1 + 28) - 5) > 1) {
      return 0;
    }
    else {
      return **(CGColorSpaceRef **)(v1 + 96);
    }
  }
  return space;
}

const void *__data_provider_debug_info_enabled_block_invoke()
{
  return get_BOOLean_property("CGDataProviderEnableDebugInfo", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&data_provider_debug_info_enabled_enabled);
}

uint64_t CGImageBlockSetGetColorSpace(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

uint64_t copy_character_set(uint64_t a1)
{
  return MEMORY[0x1F4119BA8](*(void *)(a1 + 8));
}

const void *__initialize_deep_mask_block_invoke()
{
  return get_BOOLean_property("FP16_DEEP_MASK_ON", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&initialize_deep_mask_fp16_deep_mask_on);
}

void *_ripdata_finalize(uint64_t a1)
{
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  uint64_t v2 = RIPGetCacheState_cache_state;
  RIPLockCacheState();
  uint64_t v3 = (void *)(a1 + 16);
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4 != (void *)(a1 + 16))
  {
    uint64_t v5 = *(void *)(v2 + 16);
    do
    {
      uint64_t v7 = v4[2];
      uint64_t v8 = (void *)v4[3];
      uint64_t v6 = v4 + 2;
      *(void *)(v7 + 8) = v8;
      *uint64_t v8 = v7;
      *uint64_t v6 = v6;
      v6[1] = v6;
      --*(void *)(v6[3] + 16);
      --v5;
      uint64_t v4 = (void *)*(v6 - 1);
    }
    while (v4 != v3);
    *(void *)(v2 + 16) = v5;
  }
  RIPUnlockCacheState();
  uint64_t result = *(void **)(a1 + 24);
  if (result != v3)
  {
    do
    {
      uint64_t v10 = (void *)result[1];
      RIPCacheEntryRelease(result);
      uint64_t result = v10;
    }
    while (v10 != v3);
  }
  return result;
}

void RIPCacheEntryRelease(void *a1)
{
  int v2 = *((_DWORD *)a1 + 12);
  if (v2 == 2 || v2 == 1)
  {
    uint64_t v3 = *((void *)a1 + 20);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
  }
  else if (!v2)
  {
    free(*((void **)a1 + 16));
    free(*((void **)a1 + 17));
  }

  free(a1);
}

__n128 CGPatternGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CGFontGetVariations(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 208))(*(void *)(result + 112));
  }
  return result;
}

void converter_initialize()
{
  if (kCGCMSConverterID_block_invoke_once != -1) {
    dispatch_once(&kCGCMSConverterID_block_invoke_once, &__block_literal_global_9_2084);
  }
}

uint64_t __CGColorConversionInfoGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  kCGColorConverterRuntimeID = result;
  return result;
}

void colorspace_from_ICC_data_data_key_release(void *a1)
{
  if (a1) {
    free(a1);
  }
}

double CGPatternGetBounds(uint64_t a1)
{
  return *(double *)(a1 + 104);
}

uint64_t CGClipStackGetCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

void CGFontDBAddFontsFromPlist(CFMutableArrayRef *a1, CFDictionaryRef theDict)
{
  if (a1)
  {
    if (theDict)
    {
      CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"Names");
      if (Value)
      {
        uint64_t v5 = Value;
        CFTypeID v6 = CFGetTypeID(Value);
        if (v6 == CFDictionaryGetTypeID())
        {
          CFArrayInsertValueAtIndex(*a1, 1, v5);
          CFDictionaryRef v7 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"Aliases");
          if (v7)
          {
            CFDictionaryRef v8 = v7;
            CFTypeID v9 = CFGetTypeID(v7);
            if (v9 == CFDictionaryGetTypeID())
            {
              uint64_t v10 = CFDictionaryGetValue(v8, @"Faces");
              if (v10)
              {
                unint64_t v11 = v10;
                CFTypeID v12 = CFGetTypeID(v10);
                if (v12 == CFDictionaryGetTypeID()) {
                  CFArrayInsertValueAtIndex(a1[2], 0, v11);
                }
              }
              size_t v13 = CFDictionaryGetValue(v8, @"Families");
              if (v13)
              {
                size_t v14 = v13;
                CFTypeID v15 = CFGetTypeID(v13);
                if (v15 == CFDictionaryGetTypeID())
                {
                  uint64_t v16 = a1[3];
                  CFArrayInsertValueAtIndex(v16, 0, v14);
                }
              }
            }
          }
        }
      }
    }
  }
}

void CGGlyphLockAccessCustomized()
{
}

CGGradientRef CGGradientCreateWithColorComponents(CGColorSpaceRef space, const CGFloat *components, const CGFloat *locations, size_t count)
{
  return (CGGradientRef)CGGradientCreateWithColorComponentsAndOptions(space, (uint64_t)components, (uint64_t)locations, count, 0, v4, v5, v6);
}

void CGPDFSourceFinalize(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 209))
  {
    long long v2 = *(void (**)(void))(a1 + 64);
    if (v2) {
      v2(*(void *)(a1 + 80));
    }
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(void **)(a1 + 144);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 152)) {
      free(v4);
    }
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v5 = *(void **)(a1 + 88);

  free(v5);
}

void fstream_release(z_streamp strm)
{
  if (strm)
  {
    if (strm->state) {
      inflateEnd(strm);
    }
    long long v2 = *(const void **)&strm[1].avail_in;
    if (v2)
    {
      uint64_t avail_in = strm->avail_in;
      if (!avail_in) {
        goto LABEL_9;
      }
      uint64_t v4 = avail_in - 1;
      do
        CGPDFSourceUngetc(*(void **)&strm[1].avail_in, strm->next_in[v4--]);
      while (v4 != -1);
      long long v2 = *(const void **)&strm[1].avail_in;
      if (v2) {
LABEL_9:
      }
        CFRelease(v2);
    }
    free((void *)strm[1].total_in);
    free(strm);
  }
}

void __CGColorCreate_block_invoke()
{
  uint64_t v0 = *MEMORY[0x1E4FBA8D8];
  if (*MEMORY[0x1E4FBA8D8]) {
    LOBYTE(v0) = _objc_getClassForTag() != 0;
  }
  CGColorCreate_supportsTaggedPointers = v0;
}

uint64_t CGPatternGetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t CGPatternGetTiling(uint64_t a1)
{
  return *(unsigned int *)(a1 + 152);
}

void *CGIOSurfaceContextCreate(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, int a7)
{
  return CGIOSurfaceContextCreateWithOptions(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t __CGOSAppleInternalBuild_block_invoke()
{
  uint64_t result = os_variant_allows_internal_security_policies();
  if (result) {
    uint64_t result = os_variant_has_internal_content();
  }
  CGOSAppleInternalBuild_is_internal = result;
  return result;
}

void __CGPDFDrawingContextGetOperatorTable_block_invoke()
{
  CGPDFDrawingContextGetOperatorTable_operator_table = (uint64_t)CGPDFOperatorTableCreate();
  if (CGPDFDrawingContextGetOperatorTable_operator_table)
  {
    for (uint64_t i = 0; i != 132; i += 2)
      CGPDFOperatorTableSetCallback((CGPDFOperatorTableRef)CGPDFDrawingContextGetOperatorTable_operator_table, (&operators)[i], (CGPDFOperatorCallback)(&operators)[i + 1]);
  }
}

void CGPDFOperatorTableSetCallback(CGPDFOperatorTableRef table, const char *name, CGPDFOperatorCallback callback)
{
  if (table && name)
  {
    size_t v6 = strlen(name);
    int v7 = CGPDFGetOperatorForName((char *)name, v6, 0);
    if (v7) {
      *((void *)table + v7 + 2) = callback;
    }
    else {
  }
    }
}

CGPDFOperatorTableRef CGPDFOperatorTableCreate(void)
{
  if (CGPDFOperatorTableGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFOperatorTableGetTypeID_onceToken, &__block_literal_global_16456);
  }

  return (CGPDFOperatorTableRef)pdf_create_cftype();
}

uint64_t rip_auto_context_end_layer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v6 = 112;
    pthread_mutex_lock((pthread_mutex_t *)0x70);
    goto LABEL_6;
  }
  uint64_t v5 = *(void *)(a1 + 288);
  uint64_t v6 = v5 + 112;
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 112));
  if (!v5)
  {
LABEL_6:
    rip_auto_context_update_content_info_from_GState(0, a3);
    goto LABEL_12;
  }
  uint64_t v7 = *(void *)(v5 + 88);
  if (v7)
  {
    rip_auto_context_update_content_info_from_GState(v5, a3);
  }
  else
  {
    uint64_t v7 = *(void *)(v5 + 80);
    rip_auto_context_update_content_info_from_GState(v5, a3);
    if (!v7) {
      goto LABEL_12;
    }
  }
  uint64_t v15 = *(void *)(v7 + 40);
  if (v15)
  {
    uint64_t v16 = *(void (**)(void))(v15 + 200);
    if (v16) {
      v16();
    }
  }
  *(unsigned char *)(v5 + 105) |= rip_auto_context_contains_transparency(v5, v8, v9, v10, v11, v12, v13, v14);
LABEL_12:
  pthread_mutex_unlock((pthread_mutex_t *)v6);
  return a1;
}

void *dlRecorder_EndLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v9 = *(void *)(a1 + 288)) == 0)
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_EndLayer");
    return 0;
  }
  uint64_t result = CG::DisplayListRecorder::currentDisplayList(*(CFArrayRef **)(a1 + 288));
  if (!result) {
    return result;
  }
  uint64_t v13 = (uint64_t)result;
  CFRetain(result);
  if (CFArrayGetCount(*(CFArrayRef *)(v9 + 8)) >= 2)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v9 + 8));
    if (Count) {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v9 + 8), Count - 1);
    }
    else {
      CGPostError((uint64_t)"%s: displayListStack underflow", v15, v16, v17, v18, v19, v20, v21, (char)"void CG::DisplayListRecorder::popDisplayListStack()");
    }
    uint64_t v26 = 0;
    goto LABEL_13;
  }
  uint64_t v26 = *(void **)(v9 + 16);
  if (!v26) {
    return 0;
  }
  CFRelease(*(CFTypeRef *)(v9 + 16));
  *(void *)(v9 + 16) = 0;
LABEL_13:
  if (*(void *)(v13 + 592) != *(void *)(v13 + 600)
    && *(double *)(v13 + 88) != INFINITY
    && *(double *)(v13 + 96) != INFINITY)
  {
    long long v28 = *(_OWORD *)(a3 + 24);
    long long v29 = *(_OWORD *)(a3 + 40);
    long long v30 = *(_OWORD *)(a3 + 56);
    *(CGAffineTransform *)(a3 + 24) = CGAffineTransformIdentity;
    if (v26) {
      CGDisplayListDelegateDrawDisplayList(v26, a2, a3, v13, v22, v23, v24, v25);
    }
    else {
      CG::DisplayListRecorder::DrawDisplayList((CFArrayRef *)v9, a2, a3, v13);
    }
    *(_OWORD *)(a3 + 24) = v28;
    *(_OWORD *)(a3 + 40) = v29;
    *(_OWORD *)(a3 + 56) = v30;
  }
  CFRelease((CFTypeRef)v13);
  if (v26) {
    return v26;
  }
  else {
    return (void *)a1;
  }
}

uint64_t CG::DisplayListRecorder::DrawDisplayList(CFArrayRef *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (double *)CG::DisplayListRecorder::currentDisplayList(a1);
  if (!v8) {
    return 1000;
  }
  uint64_t v9 = v8;
  if (v8[5] == INFINITY || v8[6] == INFINITY) {
    return 0;
  }
  uint64_t result = 0;
  if (v9[7] == 0.0 || v9[8] == 0.0) {
    return result;
  }
  if (a4)
  {
    CFDictionaryRef v12 = *(const __CFDictionary **)(a4 + 32);
    long long v13 = *(_OWORD *)(a3 + 40);
    *(_OWORD *)&v45.double a = *(_OWORD *)(a3 + 24);
    *(_OWORD *)&v45.double c = v13;
    *(_OWORD *)&v45.tCGFloat x = *(_OWORD *)(a3 + 56);
    if (!*((unsigned char *)v9 + 73)) {
      goto LABEL_29;
    }
    p_CGSize size = &CGRectNull.size;
    uint64_t v15 = (const CGRect *)(a4 + 88);
    p_CGFloat y = (CGFloat *)(a4 + 96);
    if (*(void *)(a4 + 592) == *(void *)(a4 + 600)) {
      p_CGFloat y = &CGRectNull.origin.y;
    }
    else {
      p_CGSize size = (CGSize *)(a4 + 104);
    }
    if (*(void *)(a4 + 592) == *(void *)(a4 + 600))
    {
      uint64_t v15 = &CGRectNull;
      p_CGFloat height = &CGRectNull.size.height;
    }
    else
    {
      p_CGFloat height = (CGFloat *)(a4 + 112);
    }
    CGFloat height = *p_height;
    CGFloat x = v15->origin.x;
    CGFloat y = *p_y;
    CGFloat width = p_size->width;
    if (v12 && CGCFDictionaryGetRect(v12, @"kCGContextBoundingBox", (UInt8 *)&v43))
    {
      v46.origin.CGFloat x = x;
      v46.origin.CGFloat y = y;
      v46.size.CGFloat width = width;
      v46.size.CGFloat height = height;
      CGRect v47 = CGRectIntersection(v46, v43);
      CGFloat x = v47.origin.x;
      CGFloat y = v47.origin.y;
      CGFloat width = v47.size.width;
      CGFloat height = v47.size.height;
      v44.origin.CGFloat x = v47.origin.x;
    }
  }
  else
  {
    long long v22 = *(_OWORD *)(a3 + 40);
    *(_OWORD *)&v45.double a = *(_OWORD *)(a3 + 24);
    *(_OWORD *)&v45.double c = v22;
    *(_OWORD *)&v45.tCGFloat x = *(_OWORD *)(a3 + 56);
    if (!*((unsigned char *)v9 + 73))
    {
      CFDictionaryRef v12 = 0;
      goto LABEL_29;
    }
    CFDictionaryRef v12 = 0;
    CGFloat height = 0.0;
    CGFloat y = INFINITY;
    CGFloat width = 0.0;
    CGFloat x = INFINITY;
  }
  CGAffineTransform v42 = v45;
  v48.origin.CGFloat x = x;
  v48.origin.CGFloat y = y;
  v48.size.CGFloat width = width;
  v48.size.CGFloat height = height;
  CGRect v44 = CGRectApplyAffineTransform(v48, &v42);
  CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(&v44.origin.x, a2, *(double **)(a3 + 112), *(void *)(*(void *)(a3 + 120) + 16));
  v44.origin.CGFloat x = v26;
  v44.origin.CGFloat y = v23;
  v44.size.CGFloat width = v24;
  v44.size.CGFloat height = v25;
  if (v26 == INFINITY || v23 == INFINITY) {
    return 0;
  }
  uint64_t result = 0;
  if (v24 == 0.0 || v25 == 0.0) {
    return result;
  }
LABEL_29:
  uint64_t v27 = *(void *)(a4 + 592);
  uint64_t v28 = *(void *)(a4 + 600);
  if (v27 == v28)
  {
LABEL_38:
    if (!CG::DisplayList::displayListResourceForDisplayList((int8x8_t *)v9 + 2, a4)) {
      return 1000;
    }
    EntryDrawingState = (void *)CG::DisplayList::getEntryDrawingState((uint64_t)(v9 + 2), (void *)a3, a2);
    uint64_t v32 = EntryDrawingState[1];
    if (!v32) {
      return 1000;
    }
    int v33 = *(_DWORD *)(v32 + 8);
    uint64_t v34 = EntryDrawingState[2];
    if (v34) {
      v33 |= *(_DWORD *)(v34 + 8);
    }
    int v35 = v33 & 0x1000;
    uint64_t v36 = EntryDrawingState[3];
    if (v36) {
      v35 |= *(_DWORD *)(v36 + 8) & 0x3400;
    }
    uint64_t v37 = *(void *)(a3 + 120);
    if (*(double *)(v37 + 8) >= 1.0)
    {
      if (a4) {
        int v39 = *(_DWORD *)(a4 + 80) & 0x1000;
      }
      else {
        LOWORD(v39) = 0;
      }
      __int16 v38 = v39 | v35;
    }
    else
    {
      __int16 v38 = v35 | 0x1000;
    }
    if ((v38 & 0x1000) == 0 && (((int)(*(_DWORD *)(v37 + 4) << 16) >> 24) - 3) < 0xFFFFFFFE) {
      v38 |= 0x1000u;
    }
    if ((v38 & 0x1000) == 0
      && v12
      && (CFDictionaryContainsKey(v12, @"kCGContextGroup")
       || CFDictionaryContainsKey(v12, @"kCGContextColorSpace")))
    {
      v38 |= 0x1000u;
    }
    if ((v38 & 0x3000) != 0) {
      *((_DWORD *)v9 + 20) |= v38 & 0x3000;
    }
    if (*((unsigned char *)v9 + 74))
    {
      if ((v38 & 0x400) != 0) {
        CG::DisplayList::getEntryPatternState((uint64_t)(v9 + 2), a3, a2);
      }
      operator new();
    }
    return 0;
  }
  while (1)
  {
    if (*(unsigned char *)(*(void *)v27 + 8) == 7)
    {
      uint64_t v29 = *(void *)(*(void *)v27 + 80);
      if (v29)
      {
        uint64_t v30 = *(void *)(v29 + 16);
        if (v30) {
          break;
        }
      }
    }
    v27 += 16;
LABEL_34:
    if (v27 == v28) {
      goto LABEL_38;
    }
  }
  if ((double *)v30 != v9)
  {
    uint64_t v27 = *(void *)(v30 + 592);
    uint64_t v28 = *(void *)(v30 + 600);
    goto LABEL_34;
  }
  CGImageRef Image = CG::DisplayList::createImage((CG::DisplayList *)(a4 + 16));
  if (Image)
  {
    uint64_t v41 = Image;
    CG::DisplayListRecorder::DrawImage(a1, a2, a3, Image, *(double *)(a4 + 40), *(CGFloat *)(a4 + 48), *(double *)(a4 + 56), *(double *)(a4 + 64));
    CFRelease(v41);
    return 0;
  }
  return 1000;
}

BOOL CGCFDictionaryGetRect(const __CFDictionary *a1, const void *a2, UInt8 *a3)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }
  CFDataRef v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFDataGetTypeID()) {
    return 0;
  }

  return get_value_from_data(v5, a3, 32);
}

uint64_t CG::DisplayList::displayListResourceForDisplayList(int8x8_t *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  ++*(void *)&a1[87];
  double v24 = a1 + 52;
  unint64_t v4 = XXH64_digest(*(void **)(a2 + 136));
  int8x8_t v11 = a1[53];
  if (!*(void *)&v11) {
    goto LABEL_27;
  }
  unint64_t v12 = v4;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v11);
  v13.i16[0] = vaddlv_u8(v13);
  unint64_t v14 = v13.u32[0];
  if (v13.u32[0] > 1uLL)
  {
    unint64_t v15 = v4;
    if (v4 >= *(void *)&v11) {
      unint64_t v15 = v4 % *(void *)&v11;
    }
  }
  else
  {
    unint64_t v15 = (*(void *)&v11 - 1) & v4;
  }
  uint64_t v17 = *(void **)(*(void *)v24 + 8 * v15);
  if (!v17 || (uint64_t v18 = (void *)*v17) == 0)
  {
LABEL_27:
    CG::DisplayList::createCGDisplayList(a2, 0, v5, v6, v7, v8, v9, v10);
    operator new();
  }
  while (1)
  {
    unint64_t v19 = v18[1];
    if (v19 == v12) {
      break;
    }
    if (v14 > 1)
    {
      if (v19 >= *(void *)&v11) {
        v19 %= *(void *)&v11;
      }
    }
    else
    {
      v19 &= *(void *)&v11 - 1;
    }
    if (v19 != v15) {
      goto LABEL_27;
    }
LABEL_26:
    uint64_t v18 = (void *)*v18;
    if (!v18) {
      goto LABEL_27;
    }
  }
  uint64_t v20 = v18[2];
  uint64_t v21 = (std::__shared_weak_count *)v18[3];
  if (!v21)
  {
    uint64_t v22 = *(void *)(v20 + 16);
    if (v22 == a2) {
      return v18[2];
    }
    if (!v22) {
      goto LABEL_26;
    }
LABEL_23:
    char isEqualTo = CG::DisplayList::isEqualTo((CG::DisplayList *)(v22 + 16), (const CG::DisplayList *)(a2 + 16), 0);
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:fe180100](v21);
    }
    if (isEqualTo) {
      return v18[2];
    }
    goto LABEL_26;
  }
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v22 = *(void *)(v20 + 16);
  if (v22 != a2)
  {
    if (!v22)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v21);
      goto LABEL_26;
    }
    goto LABEL_23;
  }
  std::__shared_weak_count::__release_shared[abi:fe180100](v21);
  return v18[2];
}

void sub_184C97D8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::shared_ptr<CG::DisplayListResourceDisplayList>,void *>>>::operator()[abi:fe180100](1, v12);
  applesauce::CF::ObjectRef<CGDisplayList *>::~ObjectRef(&a12);
  _Unwind_Resume(a1);
}

unint64_t XXH64_digest(void *a1)
{
  if (*a1 < 0x20uLL) {
    uint64_t v1 = a1[3] + 0x27D4EB2F165667C5;
  }
  else {
    uint64_t v1 = 0x85EBCA77C2B2AE63
  }
       - 0x61C8864E7A143579
       * ((0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * ((0x85EBCA77C2B2AE63
           - 0x61C8864E7A143579
           * ((0x85EBCA77C2B2AE63
             - 0x61C8864E7A143579
             * ((__ROR8__(a1[2], 57) + __ROR8__(a1[1], 63) + __ROR8__(a1[3], 52) + __ROR8__(a1[4], 46)) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[1], 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[2], 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[3], 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[4], 33)));
  unint64_t v2 = v1 + *a1;
  uint64_t v3 = a1 + 5;
  unint64_t v4 = *a1 & 0x1FLL;
  if (v4 >= 8)
  {
    do
    {
      uint64_t v5 = *v3++;
      unint64_t v2 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579 * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * v5, 33)) ^ v2, 37);
      v4 -= 8;
    }
    while (v4 > 7);
  }
  if (v4 >= 4)
  {
    unsigned int v6 = *(_DWORD *)v3;
    uint64_t v3 = (uint64_t *)((char *)v3 + 4);
    unint64_t v2 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * v6) ^ v2, 41);
    v4 -= 4;
  }
  for (; v4; --v4)
  {
    unsigned int v7 = *(unsigned __int8 *)v3;
    uint64_t v3 = (uint64_t *)((char *)v3 + 1);
    unint64_t v2 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v7) ^ v2, 53);
  }
  unint64_t v8 = 0x165667B19E3779F9
     * ((0xC2B2AE3D27D4EB4FLL * (v2 ^ (v2 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (v2 ^ (v2 >> 33))) >> 29));
  return v8 ^ HIDWORD(v8);
}

CFTypeRef CG::DisplayListResourcePattern::setPattern(CG::DisplayListResourcePattern *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 2);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    CFTypeRef result = CFRetain(cf);
    *((void *)this + 2) = result;
  }
  return result;
}

uint64_t CG::DisplayList::createCGDisplayList(uint64_t a1, __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_ZZZ22CGDisplayListGetTypeIDEUb_E4once != -1) {
    dispatch_once(&_ZZZ22CGDisplayListGetTypeIDEUb_E4once, &__block_literal_global_161_15385);
  }
  uint64_t Instance = CGTypeCreateInstance(CGDisplayListGetTypeID::display_list2_type_id, 824, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = &unk_1ED094828;
    *(void *)(Instance + 24) = *(void *)(a1 + 24);
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13) {
      CFRetain(*(CFTypeRef *)(a1 + 32));
    }
    BOOL v196 = (CG::DisplayList *)(v12 + 16);
    int v197 = a2;
    *(void *)(v12 + 32) = v13;
    *(_OWORD *)(v12 + 40) = *(_OWORD *)(a1 + 40);
    long long v14 = *(_OWORD *)(a1 + 56);
    long long v15 = *(_OWORD *)(a1 + 72);
    long long v16 = *(_OWORD *)(a1 + 88);
    *(_OWORD *)(v12 + 104) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(v12 + 88) = v16;
    *(_OWORD *)(v12 + 72) = v15;
    *(_OWORD *)(v12 + 56) = v14;
    *(void *)(v12 + 120) = *(void *)(a1 + 120);
    uint64_t v17 = *(void *)(a1 + 128);
    *(void *)(v12 + 128) = v17;
    if (v17) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = (__n128 *)malloc_type_malloc(0x58uLL, 0xBDE48346uLL);
    *(void *)(v12 + 136) = v18;
    uint64_t v22 = *(__n128 **)(a1 + 136);
    __n128 v23 = v22[1];
    *uint64_t v18 = *v22;
    __n128 v24 = v22[2];
    __n128 v25 = v22[3];
    __n128 v26 = v22[4];
    v18[5].n128_u64[0] = v22[5].n128_u64[0];
    v18[3] = v25;
    v18[4] = v26;
    v18[1] = v23;
    CGPDFBoolean v18[2] = v24;
    *(void *)(v12 + 152) = 0;
    *(void *)(v12 + 160) = 0;
    *(void *)(v12 + 144) = v12 + 152;
    uint64_t v27 = *(void **)(a1 + 144);
    uint64_t v200 = v12;
    if (v27 != (void *)(a1 + 152))
    {
      do
      {
        uint64_t v28 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceClip>,CG::CompareResourceClip,std::allocator<std::shared_ptr<CG::DisplayListResourceClip>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceClip>>((void *)(v12 + 144), (void *)(v12 + 152), &v203, &v202, v27 + 4);
        if (!*v28)
        {
          uint64_t v29 = v28;
          uint64_t v30 = (uint64_t *)operator new(0x30uLL);
          v30[4] = v27[4];
          uint64_t v31 = v27[5];
          v30[5] = v31;
          if (v31) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 144), v203, v29, v30);
        }
        uint64_t v32 = (void *)v27[1];
        if (v32)
        {
          do
          {
            int v33 = v32;
            uint64_t v32 = (void *)*v32;
          }
          while (v32);
        }
        else
        {
          do
          {
            int v33 = (void *)v27[2];
            BOOL v128 = *v33 == (void)v27;
            uint64_t v27 = v33;
          }
          while (!v128);
        }
        uint64_t v27 = v33;
      }
      while (v33 != (void *)(a1 + 152));
    }
    *(void *)(v12 + 176) = 0;
    *(void *)(v12 + 168) = v12 + 176;
    *(void *)(v12 + 184) = 0;
    uint64_t v34 = *(void **)(a1 + 168);
    if (v34 != (void *)(a1 + 176))
    {
      do
      {
        int v35 = std::__tree<std::shared_ptr<CG::DisplayListResourceColor>,CG::CompareResourceColor,std::allocator<std::shared_ptr<CG::DisplayListResourceColor>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceColor>>((void *)(v12 + 168), (void *)(v12 + 176), &v203, (uint64_t)&v202, (uint64_t)(v34 + 4), v19, v20, v21, v23);
        if (!*v35)
        {
          uint64_t v36 = (uint64_t **)v35;
          uint64_t v37 = (uint64_t *)operator new(0x30uLL);
          v37[4] = v34[4];
          uint64_t v38 = v34[5];
          v37[5] = v38;
          if (v38) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 168), v203, v36, v37);
        }
        int v39 = (void *)v34[1];
        if (v39)
        {
          do
          {
            uint64_t v40 = v39;
            int v39 = (void *)*v39;
          }
          while (v39);
        }
        else
        {
          do
          {
            uint64_t v40 = (void *)v34[2];
            BOOL v128 = *v40 == (void)v34;
            uint64_t v34 = v40;
          }
          while (!v128);
        }
        uint64_t v34 = v40;
      }
      while (v40 != (void *)(a1 + 176));
    }
    *(void *)(v12 + 200) = 0;
    *(void *)(v12 + 192) = v12 + 200;
    *(void *)(v12 + 208) = 0;
    uint64_t v41 = *(void **)(a1 + 192);
    if (v41 != (void *)(a1 + 200))
    {
      do
      {
        CGAffineTransform v42 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 192), (void *)(v12 + 200), &v203, &v202, v41 + 4);
        if (!*v42)
        {
          CGRect v43 = v42;
          CGRect v44 = (uint64_t *)operator new(0x30uLL);
          v44[4] = v41[4];
          uint64_t v45 = v41[5];
          v44[5] = v45;
          if (v45) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 192), v203, v43, v44);
        }
        CGRect v46 = (void *)v41[1];
        if (v46)
        {
          do
          {
            CGRect v47 = v46;
            CGRect v46 = (void *)*v46;
          }
          while (v46);
        }
        else
        {
          do
          {
            CGRect v47 = (void *)v41[2];
            BOOL v128 = *v47 == (void)v41;
            uint64_t v41 = v47;
          }
          while (!v128);
        }
        uint64_t v41 = v47;
      }
      while (v47 != (void *)(a1 + 200));
    }
    *(void *)(v12 + 224) = 0;
    *(void *)(v12 + 216) = v12 + 224;
    *(void *)(v12 + 232) = 0;
    CGRect v48 = *(void **)(a1 + 216);
    if (v48 != (void *)(a1 + 224))
    {
      do
      {
        uint64_t v49 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceDash>,CG::CompareResourceDash,std::allocator<std::shared_ptr<CG::DisplayListResourceDash>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceDash>>((void *)(v12 + 216), (void *)(v12 + 224), &v203, &v202, v48 + 4);
        if (!*v49)
        {
          uint64_t v50 = v49;
          uint64_t v51 = (uint64_t *)operator new(0x30uLL);
          v51[4] = v48[4];
          uint64_t v52 = v48[5];
          v51[5] = v52;
          if (v52) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 216), v203, v50, v51);
        }
        int v53 = (void *)v48[1];
        if (v53)
        {
          do
          {
            uint64_t v54 = v53;
            int v53 = (void *)*v53;
          }
          while (v53);
        }
        else
        {
          do
          {
            uint64_t v54 = (void *)v48[2];
            BOOL v128 = *v54 == (void)v48;
            CGRect v48 = v54;
          }
          while (!v128);
        }
        CGRect v48 = v54;
      }
      while (v54 != (void *)(a1 + 224));
    }
    *(void *)(v12 + 248) = 0;
    *(void *)(v12 + 240) = v12 + 248;
    *(void *)(v12 + 256) = 0;
    long long v55 = *(void **)(a1 + 240);
    if (v55 != (void *)(a1 + 248))
    {
      do
      {
        char v56 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 240), (void *)(v12 + 248), &v203, &v202, v55 + 4);
        if (!*v56)
        {
          uint64_t v57 = v56;
          uint64_t v58 = (uint64_t *)operator new(0x30uLL);
          v58[4] = v55[4];
          uint64_t v59 = v55[5];
          v58[5] = v59;
          if (v59) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 240), v203, v57, v58);
        }
        double v60 = (void *)v55[1];
        if (v60)
        {
          do
          {
            double v61 = v60;
            double v60 = (void *)*v60;
          }
          while (v60);
        }
        else
        {
          do
          {
            double v61 = (void *)v55[2];
            BOOL v128 = *v61 == (void)v55;
            long long v55 = v61;
          }
          while (!v128);
        }
        long long v55 = v61;
      }
      while (v61 != (void *)(a1 + 248));
    }
    *(void *)(v12 + 272) = 0;
    *(void *)(v12 + 280) = 0;
    *(void *)(v12 + 264) = v12 + 272;
    double v62 = *(void **)(a1 + 264);
    if (v62 != (void *)(a1 + 272))
    {
      do
      {
        uint64_t v63 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 264), (void *)(v12 + 272), &v203, &v202, v62 + 4);
        if (!*v63)
        {
          double v64 = v63;
          size_t v65 = (uint64_t *)operator new(0x30uLL);
          v65[4] = v62[4];
          uint64_t v66 = v62[5];
          v65[5] = v66;
          if (v66) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v66 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 264), v203, v64, v65);
        }
        double v67 = (void *)v62[1];
        if (v67)
        {
          do
          {
            double v68 = v67;
            double v67 = (void *)*v67;
          }
          while (v67);
        }
        else
        {
          do
          {
            double v68 = (void *)v62[2];
            BOOL v128 = *v68 == (void)v62;
            double v62 = v68;
          }
          while (!v128);
        }
        double v62 = v68;
      }
      while (v68 != (void *)(a1 + 272));
    }
    *(void *)(v12 + 296) = 0;
    *(void *)(v12 + 304) = 0;
    *(void *)(v12 + 288) = v12 + 296;
    double v69 = *(void **)(a1 + 288);
    if (v69 != (void *)(a1 + 296))
    {
      do
      {
        double v70 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 288), (void *)(v12 + 296), &v203, &v202, v69 + 4);
        if (!*v70)
        {
          double v71 = v70;
          double v72 = (uint64_t *)operator new(0x30uLL);
          v72[4] = v69[4];
          uint64_t v73 = v69[5];
          v72[5] = v73;
          if (v73) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v73 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 288), v203, v71, v72);
        }
        double v74 = (void *)v69[1];
        if (v74)
        {
          do
          {
            double v75 = v74;
            double v74 = (void *)*v74;
          }
          while (v74);
        }
        else
        {
          do
          {
            double v75 = (void *)v69[2];
            BOOL v128 = *v75 == (void)v69;
            double v69 = v75;
          }
          while (!v128);
        }
        double v69 = v75;
      }
      while (v75 != (void *)(a1 + 296));
    }
    *(void *)(v12 + 320) = 0;
    *(void *)(v12 + 328) = 0;
    *(void *)(v12 + 312) = v12 + 320;
    double v76 = *(void **)(a1 + 312);
    if (v76 != (void *)(a1 + 320))
    {
      do
      {
        double v77 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 312), (void *)(v12 + 320), &v203, &v202, v76 + 4);
        if (!*v77)
        {
          double v78 = v77;
          double v79 = (uint64_t *)operator new(0x30uLL);
          Point v79[4] = v76[4];
          uint64_t v80 = v76[5];
          v79[5] = v80;
          if (v80) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v80 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 312), v203, v78, v79);
        }
        double v81 = (void *)v76[1];
        if (v81)
        {
          do
          {
            uint64_t v82 = v81;
            double v81 = (void *)*v81;
          }
          while (v81);
        }
        else
        {
          do
          {
            uint64_t v82 = (void *)v76[2];
            BOOL v128 = *v82 == (void)v76;
            double v76 = v82;
          }
          while (!v128);
        }
        double v76 = v82;
      }
      while (v82 != (void *)(a1 + 320));
    }
    *(void *)(v12 + 344) = 0;
    *(void *)(v12 + 352) = 0;
    *(void *)(v12 + 336) = v12 + 344;
    unint64_t v83 = *(void **)(a1 + 336);
    if (v83 != (void *)(a1 + 344))
    {
      do
      {
        double v84 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 336), (void *)(v12 + 344), &v203, &v202, v83 + 4);
        if (!*v84)
        {
          double v85 = v84;
          uint64_t v86 = (uint64_t *)operator new(0x30uLL);
          Point v86[4] = v83[4];
          uint64_t v87 = v83[5];
          v86[5] = v87;
          if (v87) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v87 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 336), v203, v85, v86);
        }
        double v88 = (void *)v83[1];
        if (v88)
        {
          do
          {
            uint64_t v89 = v88;
            double v88 = (void *)*v88;
          }
          while (v88);
        }
        else
        {
          do
          {
            uint64_t v89 = (void *)v83[2];
            BOOL v128 = *v89 == (void)v83;
            unint64_t v83 = v89;
          }
          while (!v128);
        }
        unint64_t v83 = v89;
      }
      while (v89 != (void *)(a1 + 344));
    }
    *(void *)(v12 + 368) = 0;
    *(void *)(v12 + 376) = 0;
    *(void *)(v12 + 360) = v12 + 368;
    uint64_t v90 = *(void **)(a1 + 360);
    if (v90 != (void *)(a1 + 368))
    {
      do
      {
        uint64_t v91 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 360), (void *)(v12 + 368), &v203, &v202, v90 + 4);
        if (!*v91)
        {
          unint64_t v92 = v91;
          double v93 = (uint64_t *)operator new(0x30uLL);
          v93[4] = v90[4];
          uint64_t v94 = v90[5];
          v93[5] = v94;
          if (v94) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v94 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 360), v203, v92, v93);
        }
        CGRect v95 = (void *)v90[1];
        if (v95)
        {
          do
          {
            CGRect v96 = v95;
            CGRect v95 = (void *)*v95;
          }
          while (v95);
        }
        else
        {
          do
          {
            CGRect v96 = (void *)v90[2];
            BOOL v128 = *v96 == (void)v90;
            uint64_t v90 = v96;
          }
          while (!v128);
        }
        uint64_t v90 = v96;
      }
      while (v96 != (void *)(a1 + 368));
    }
    *(void *)(v12 + 392) = 0;
    *(void *)(v12 + 400) = 0;
    *(void *)(v12 + 384) = v12 + 392;
    CGRect v97 = *(void **)(a1 + 384);
    if (v97 != (void *)(a1 + 392))
    {
      do
      {
        CGRect v98 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 384), (void *)(v12 + 392), &v203, &v202, v97 + 4);
        if (!*v98)
        {
          CGRect v99 = v98;
          CGRect v100 = (uint64_t *)operator new(0x30uLL);
          v100[4] = v97[4];
          uint64_t v101 = v97[5];
          v100[5] = v101;
          if (v101) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v101 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 384), v203, v99, v100);
        }
        CGRect v102 = (void *)v97[1];
        if (v102)
        {
          do
          {
            CGRect v103 = v102;
            CGRect v102 = (void *)*v102;
          }
          while (v102);
        }
        else
        {
          do
          {
            CGRect v103 = (void *)v97[2];
            BOOL v128 = *v103 == (void)v97;
            CGRect v97 = v103;
          }
          while (!v128);
        }
        CGRect v97 = v103;
      }
      while (v103 != (void *)(a1 + 392));
    }
    *(void *)(v12 + 416) = 0;
    *(void *)(v12 + 424) = 0;
    *(void *)(v12 + 408) = v12 + 416;
    CGRect v104 = *(void **)(a1 + 408);
    if (v104 != (void *)(a1 + 416))
    {
      do
      {
        CGRect v105 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 408), (void *)(v12 + 416), &v203, &v202, v104 + 4);
        if (!*v105)
        {
          CGRect v106 = v105;
          CGRect v107 = (uint64_t *)operator new(0x30uLL);
          v107[4] = v104[4];
          uint64_t v108 = v104[5];
          v107[5] = v108;
          if (v108) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v108 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 408), v203, v106, v107);
        }
        uint64_t v109 = (void *)v104[1];
        if (v109)
        {
          do
          {
            uint64_t v110 = v109;
            uint64_t v109 = (void *)*v109;
          }
          while (v109);
        }
        else
        {
          do
          {
            uint64_t v110 = (void *)v104[2];
            BOOL v128 = *v110 == (void)v104;
            CGRect v104 = v110;
          }
          while (!v128);
        }
        CGRect v104 = v110;
      }
      while (v110 != (void *)(a1 + 416));
    }
    *(_OWORD *)(v12 + 432) = 0u;
    *(_OWORD *)(v12 + 448) = 0u;
    *(_DWORD *)(v12 + 464) = *(_DWORD *)(a1 + 464);
    __n128 v201 = (uint64_t *)(v12 + 432);
    std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>(v12 + 432, *(void *)(a1 + 440));
    uint64_t v199 = a1;
    uint64_t v111 = *(void **)(a1 + 448);
    if (v111)
    {
      unint64_t v198 = (void *)(v12 + 448);
      while (1)
      {
        uint64_t v112 = v111[2];
        uint64_t v113 = (std::__shared_weak_count *)v111[3];
        if (v113) {
          atomic_fetch_add_explicit(&v113->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v114 = *(void *)(v112 + 16);
        if (v114) {
          break;
        }
        unint64_t v115 = 0;
        if (v113) {
          goto LABEL_146;
        }
LABEL_147:
        unint64_t v116 = *(void *)(v12 + 440);
        if (v116)
        {
          uint8x8_t v117 = (uint8x8_t)vcnt_s8((int8x8_t)v116);
          v117.i16[0] = vaddlv_u8(v117);
          unint64_t v118 = v117.u32[0];
          if (v117.u32[0] > 1uLL)
          {
            unint64_t v8 = v115;
            if (v115 >= v116) {
              unint64_t v8 = v115 % v116;
            }
          }
          else
          {
            unint64_t v8 = (v116 - 1) & v115;
          }
          unint64_t v119 = *(void **)(*v201 + 8 * v8);
          if (v119)
          {
            uint64_t v120 = (void *)*v119;
            if (*v119)
            {
              while (1)
              {
                unint64_t v121 = v120[1];
                if (v121 == v115) {
                  break;
                }
                if (v118 > 1)
                {
                  if (v121 >= v116) {
                    v121 %= v116;
                  }
                }
                else
                {
                  v121 &= v116 - 1;
                }
                if (v121 != v8) {
                  goto LABEL_184;
                }
LABEL_180:
                uint64_t v120 = (void *)*v120;
                if (!v120) {
                  goto LABEL_184;
                }
              }
              uint64_t v122 = v120[2];
              CFNumberRef v123 = (std::__shared_weak_count *)v120[3];
              if (v123) {
                atomic_fetch_add_explicit(&v123->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v124 = v111[2];
              uint64_t v125 = (std::__shared_weak_count *)v111[3];
              if (v125) {
                atomic_fetch_add_explicit(&v125->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              uint64_t v126 = *(void *)(v122 + 16);
              uint64_t v127 = *(void *)(v124 + 16);
              if (v126 == v127)
              {
                char v129 = 1;
                if (!v125) {
                  goto LABEL_177;
                }
              }
              else
              {
                if (v126) {
                  BOOL v128 = v127 == 0;
                }
                else {
                  BOOL v128 = 1;
                }
                if (v128)
                {
                  char v129 = 0;
                  if (!v125) {
                    goto LABEL_177;
                  }
                }
                else
                {
                  char isEqualTo = CG::DisplayList::isEqualTo((CG::DisplayList *)(v126 + 16), (const CG::DisplayList *)(v127 + 16), 0);
                  char v129 = isEqualTo;
                  if (!v125)
                  {
LABEL_177:
                    if (v123) {
                      std::__shared_weak_count::__release_shared[abi:fe180100](v123);
                    }
                    if (v129) {
                      goto LABEL_209;
                    }
                    goto LABEL_180;
                  }
                }
              }
              std::__shared_weak_count::__release_shared[abi:fe180100](v125);
              goto LABEL_177;
            }
          }
LABEL_184:
          uint64_t v12 = v200;
        }
        uint64_t v131 = operator new(0x20uLL);
        *uint64_t v131 = 0;
        v131[1] = v115;
        v131[2] = v111[2];
        uint64_t v132 = v111[3];
        v131[3] = v132;
        if (v132) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v132 + 8), 1uLL, memory_order_relaxed);
        }
        float v133 = (float)(unint64_t)(*(void *)(v12 + 456) + 1);
        float v134 = *(float *)(v12 + 464);
        if (!v116 || (float)(v134 * (float)v116) < v133)
        {
          BOOL v135 = (v116 & (v116 - 1)) != 0;
          if (v116 < 3) {
            BOOL v135 = 1;
          }
          unint64_t v136 = v135 | (2 * v116);
          unint64_t v137 = vcvtps_u32_f32(v133 / v134);
          if (v136 <= v137) {
            size_t v138 = v137;
          }
          else {
            size_t v138 = v136;
          }
          std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>((uint64_t)v201, v138);
          unint64_t v116 = *(void *)(v12 + 440);
          if ((v116 & (v116 - 1)) != 0)
          {
            if (v115 >= v116) {
              unint64_t v8 = v115 % v116;
            }
            else {
              unint64_t v8 = v115;
            }
          }
          else
          {
            unint64_t v8 = (v116 - 1) & v115;
          }
        }
        uint64_t v139 = *v201;
        char v140 = *(void **)(*v201 + 8 * v8);
        if (v140)
        {
          *uint64_t v131 = *v140;
        }
        else
        {
          *uint64_t v131 = *v198;
          *unint64_t v198 = v131;
          *(void *)(v139 + 8 * v8) = v198;
          if (!*v131) {
            goto LABEL_208;
          }
          unint64_t v141 = *(void *)(*v131 + 8);
          if ((v116 & (v116 - 1)) != 0)
          {
            if (v141 >= v116) {
              v141 %= v116;
            }
          }
          else
          {
            v141 &= v116 - 1;
          }
          char v140 = (void *)(*v201 + 8 * v141);
        }
        *char v140 = v131;
LABEL_208:
        ++*(void *)(v12 + 456);
LABEL_209:
        uint64_t v111 = (void *)*v111;
        uint64_t v12 = v200;
        if (!v111) {
          goto LABEL_210;
        }
      }
      unint64_t v115 = XXH64_digest(*(void **)(v114 + 136));
      if (!v113) {
        goto LABEL_147;
      }
LABEL_146:
      std::__shared_weak_count::__release_shared[abi:fe180100](v113);
      goto LABEL_147;
    }
LABEL_210:
    *(void *)(v12 + 480) = 0;
    *(void *)(v12 + 488) = 0;
    *(void *)(v12 + 472) = v12 + 480;
    int v142 = *(void **)(v199 + 472);
    if (v142 != (void *)(v199 + 480))
    {
      do
      {
        uint64_t v143 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((void *)(v12 + 472), (void *)(v12 + 480), &v203, &v202, v142 + 4);
        if (!*v143)
        {
          uint64_t v144 = v143;
          uint64_t v145 = (uint64_t *)operator new(0x30uLL);
          v145[4] = v142[4];
          uint64_t v146 = v142[5];
          v145[5] = v146;
          if (v146) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v146 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 472), v203, v144, v145);
        }
        uint64_t v147 = (void *)v142[1];
        if (v147)
        {
          do
          {
            uint64_t v148 = v147;
            uint64_t v147 = (void *)*v147;
          }
          while (v147);
        }
        else
        {
          do
          {
            uint64_t v148 = (void *)v142[2];
            BOOL v128 = *v148 == (void)v142;
            int v142 = v148;
          }
          while (!v128);
        }
        int v142 = v148;
      }
      while (v148 != (void *)(v199 + 480));
    }
    *(void *)(v12 + 504) = 0;
    *(void *)(v12 + 512) = 0;
    *(void *)(v12 + 496) = v12 + 504;
    uint64_t v149 = *(void **)(v199 + 496);
    if (v149 != (void *)(v199 + 504))
    {
      do
      {
        uint64_t v150 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListEntryStateDrawing const>,CG::CompareEntryStateDrawing,std::allocator<std::shared_ptr<CG::DisplayListEntryStateDrawing const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateDrawing const>>((void *)(v12 + 496), (void *)(v12 + 504), &v203, &v202, v149 + 4);
        if (!*v150)
        {
          uint64_t v151 = v150;
          uint64_t v152 = (uint64_t *)operator new(0x30uLL);
          v152[4] = v149[4];
          uint64_t v153 = v149[5];
          v152[5] = v153;
          if (v153) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v153 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 496), v203, v151, v152);
        }
        uint64_t v154 = (void *)v149[1];
        if (v154)
        {
          do
          {
            int v155 = v154;
            uint64_t v154 = (void *)*v154;
          }
          while (v154);
        }
        else
        {
          do
          {
            int v155 = (void *)v149[2];
            BOOL v128 = *v155 == (void)v149;
            uint64_t v149 = v155;
          }
          while (!v128);
        }
        uint64_t v149 = v155;
      }
      while (v155 != (void *)(v199 + 504));
    }
    *(void *)(v12 + 536) = 0;
    *(void *)(v12 + 528) = 0;
    *(void *)(v12 + 520) = v12 + 528;
    long long v156 = *(void **)(v199 + 520);
    if (v156 != (void *)(v199 + 528))
    {
      do
      {
        char v157 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListEntryStateFill const>,CG::CompareEntryStateFill,std::allocator<std::shared_ptr<CG::DisplayListEntryStateFill const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateFill const>>((void *)(v12 + 520), (void *)(v12 + 528), &v203, &v202, v156 + 4);
        if (!*v157)
        {
          long long v158 = v157;
          uint64_t v159 = (uint64_t *)operator new(0x30uLL);
          v159[4] = v156[4];
          uint64_t v160 = v156[5];
          v159[5] = v160;
          if (v160) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v160 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at((uint64_t **)(v12 + 520), v203, v158, v159);
        }
        uint64_t v161 = (void *)v156[1];
        if (v161)
        {
          do
          {
            int v162 = v161;
            uint64_t v161 = (void *)*v161;
          }
          while (v161);
        }
        else
        {
          do
          {
            int v162 = (void *)v156[2];
            BOOL v128 = *v162 == (void)v156;
            long long v156 = v162;
          }
          while (!v128);
        }
        long long v156 = v162;
      }
      while (v162 != (void *)(v199 + 528));
    }
    *(void *)(v12 + 560) = 0;
    *(void *)(v12 + 552) = 0;
    *(void *)(v12 + 544) = v12 + 552;
    long long v163 = *(void **)(v199 + 544);
    if (v163 != (void *)(v199 + 552))
    {
      uint64_t v164 = (uint64_t **)(v200 + 544);
      do
      {
        BOOL v165 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListEntryStateStroke const>,CG::CompareEntryStateStroke,std::allocator<std::shared_ptr<CG::DisplayListEntryStateStroke const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateStroke const>>(v164, (void *)(v12 + 552), &v203, &v202, v163 + 4);
        if (!*v165)
        {
          long long v166 = v165;
          long long v167 = (uint64_t *)operator new(0x30uLL);
          v167[4] = v163[4];
          uint64_t v168 = v163[5];
          v167[5] = v168;
          if (v168) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v168 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at(v164, v203, v166, v167);
        }
        uint64_t v169 = (void *)v163[1];
        if (v169)
        {
          do
          {
            long long v170 = v169;
            uint64_t v169 = (void *)*v169;
          }
          while (v169);
        }
        else
        {
          do
          {
            long long v170 = (void *)v163[2];
            BOOL v128 = *v170 == (void)v163;
            long long v163 = v170;
          }
          while (!v128);
        }
        long long v163 = v170;
      }
      while (v170 != (void *)(v199 + 552));
    }
    *(void *)(v200 + 584) = 0;
    *(void *)(v200 + 576) = 0;
    *(void *)(v200 + 568) = v200 + 576;
    long long v171 = *(void **)(v199 + 568);
    if (v171 != (void *)(v199 + 576))
    {
      CGPDFObjectRef v172 = (uint64_t **)(v200 + 568);
      do
      {
        uint64_t v173 = (uint64_t **)std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStatePattern const>>(v172, (void *)(v200 + 576), &v203, &v202, v171 + 4);
        if (!*v173)
        {
          uint64_t v174 = v173;
          CGPDFDictionaryRef v175 = (uint64_t *)operator new(0x30uLL);
          v175[4] = v171[4];
          uint64_t v176 = v171[5];
          v175[5] = v176;
          if (v176) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v176 + 8), 1uLL, memory_order_relaxed);
          }
          std::__tree<unsigned long>::__insert_node_at(v172, v203, v174, v175);
        }
        CGPDFDictionaryRef v177 = (void *)v171[1];
        if (v177)
        {
          do
          {
            CGAffineTransform v178 = v177;
            CGPDFDictionaryRef v177 = (void *)*v177;
          }
          while (v177);
        }
        else
        {
          do
          {
            CGAffineTransform v178 = (void *)v171[2];
            BOOL v128 = *v178 == (void)v171;
            long long v171 = v178;
          }
          while (!v128);
        }
        long long v171 = v178;
      }
      while (v178 != (void *)(v199 + 576));
    }
    uint64_t v12 = v200;
    *(void *)(v200 + 608) = 0;
    *(_OWORD *)(v200 + 592) = 0u;
    long long v179 = *(char **)(v199 + 592);
    long long v180 = *(char **)(v199 + 600);
    uint64_t v203 = v200 + 592;
    char v204 = 0;
    uint64_t v181 = v180 - v179;
    if (v180 != v179)
    {
      if (v181 < 0) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v182 = std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v181 >> 4);
      *(void *)(v200 + 592) = v182;
      *(void *)(v200 + 600) = v182;
      *(void *)(v200 + 608) = &v182[2 * v183];
      do
      {
        void *v182 = *(void *)v179;
        uint64_t v184 = *((void *)v179 + 1);
        v182[1] = v184;
        if (v184) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v184 + 8), 1uLL, memory_order_relaxed);
        }
        v182 += 2;
        v179 += 16;
      }
      while (v179 != v180);
      *(void *)(v200 + 600) = v182;
    }
    long long v185 = *(_OWORD *)(v199 + 632);
    *(_OWORD *)(v200 + 616) = *(_OWORD *)(v199 + 616);
    *(_OWORD *)(v200 + 632) = v185;
    long long v186 = *(_OWORD *)(v199 + 648);
    long long v187 = *(_OWORD *)(v199 + 664);
    long long v188 = *(_OWORD *)(v199 + 696);
    *(_OWORD *)(v200 + 680) = *(_OWORD *)(v199 + 680);
    *(_OWORD *)(v200 + 696) = v188;
    *(_OWORD *)(v200 + 648) = v186;
    *(_OWORD *)(v200 + 664) = v187;
    long long v189 = *(_OWORD *)(v199 + 712);
    long long v190 = *(_OWORD *)(v199 + 728);
    long long v191 = *(_OWORD *)(v199 + 760);
    *(_OWORD *)(v200 + 744) = *(_OWORD *)(v199 + 744);
    *(_OWORD *)(v200 + 760) = v191;
    *(_OWORD *)(v200 + 712) = v189;
    *(_OWORD *)(v200 + 728) = v190;
    long long v192 = *(_OWORD *)(v199 + 776);
    long long v193 = *(_OWORD *)(v199 + 792);
    long long v194 = *(_OWORD *)(v199 + 824);
    *(_OWORD *)(v200 + 808) = *(_OWORD *)(v199 + 808);
    *(_OWORD *)(v200 + 824) = v194;
    *(_OWORD *)(v200 + 776) = v192;
    *(_OWORD *)(v200 + 792) = v193;
    *(void *)(v200 + 24) = v200;
    if (v197) {
      CG::DisplayList::setAuxInfo(v196, v197);
    }
  }
  return v12;
}

void sub_184C99190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, void **a15, void **a16, void **a17, void **a18, void **a19, void **a20,void **a21,void **a22,void **a23,void **a24,uint64_t a25)
{
  std::__hash_table<std::shared_ptr<CG::DisplayListResourceDisplayList>,CG::HashResourceDisplayList,CG::EqualsResourceDisplayList,std::allocator<std::shared_ptr<CG::DisplayListResourceDisplayList>>>::~__hash_table(*(void *)(v25 - 120));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a14);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a15);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a16);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a17);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a18);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a19);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a20);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a21);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a22);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a23);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a24);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a9);
  free(*(void **)(a25 + 136));
  uint64_t v27 = *(std::__shared_weak_count **)(a25 + 128);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v27);
  }
  applesauce::CF::ObjectRef<__CFDictionary const*>::~ObjectRef((const void **)(a25 + 32));
  _Unwind_Resume(a1);
}

void *std::__tree<std::shared_ptr<CG::DisplayListResourceClip>,CG::CompareResourceClip,std::allocator<std::shared_ptr<CG::DisplayListResourceClip>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceClip>>(void *a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  uint64_t v9 = a1 + 1;
  if (a1 + 1 == a2) {
    goto LABEL_15;
  }
  uint64_t v11 = *a5;
  uint64_t v12 = (std::__shared_weak_count *)a5[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = a2[4];
  uint64_t v13 = (std::__shared_weak_count *)a2[5];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *(void *)(v11 + 16);
  if (v15) {
    unsigned int v16 = *(_DWORD *)(v15 + 4);
  }
  else {
    unsigned int v16 = 0;
  }
  uint64_t v17 = *(void *)(v14 + 16);
  if (v17)
  {
    unsigned int v18 = *(_DWORD *)(v17 + 4);
    if (!v13) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  unsigned int v18 = 0;
  if (v13) {
LABEL_11:
  }
    std::__shared_weak_count::__release_shared[abi:fe180100](v13);
LABEL_12:
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  }
  if (v16 >= v18)
  {
    uint64_t v21 = a2[4];
    uint64_t v22 = (std::__shared_weak_count *)a2[5];
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v24 = *a5;
    __n128 v23 = (std::__shared_weak_count *)a5[1];
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = *(void *)(v21 + 16);
    if (v25) {
      unsigned int v26 = *(_DWORD *)(v25 + 4);
    }
    else {
      unsigned int v26 = 0;
    }
    uint64_t v37 = *(void *)(v24 + 16);
    if (v37)
    {
      unsigned int v38 = *(_DWORD *)(v37 + 4);
      if (!v23) {
        goto LABEL_52;
      }
    }
    else
    {
      unsigned int v38 = 0;
      if (!v23)
      {
LABEL_52:
        if (v22) {
          std::__shared_weak_count::__release_shared[abi:fe180100](v22);
        }
        if (v26 >= v38)
        {
          *a3 = a2;
          *a4 = a2;
          return a4;
        }
        a4 = a2 + 1;
        int v39 = (void *)a2[1];
        if (v39)
        {
          do
          {
            uint64_t v40 = v39;
            int v39 = (void *)*v39;
          }
          while (v39);
        }
        else
        {
          uint64_t v41 = a2;
          do
          {
            uint64_t v40 = (void *)v41[2];
            BOOL v28 = *v40 == (void)v41;
            uint64_t v41 = v40;
          }
          while (!v28);
        }
        if (v40 == v9) {
          goto LABEL_78;
        }
        uint64_t v42 = *a5;
        CGRect v43 = (std::__shared_weak_count *)a5[1];
        if (v43) {
          atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v45 = v40[4];
        CGRect v44 = (std::__shared_weak_count *)v40[5];
        if (v44) {
          atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v46 = *(void *)(v42 + 16);
        if (v46) {
          unsigned int v47 = *(_DWORD *)(v46 + 4);
        }
        else {
          unsigned int v47 = 0;
        }
        uint64_t v48 = *(void *)(v45 + 16);
        if (v48)
        {
          unsigned int v49 = *(_DWORD *)(v48 + 4);
          if (!v44) {
            goto LABEL_75;
          }
        }
        else
        {
          unsigned int v49 = 0;
          if (!v44)
          {
LABEL_75:
            if (v43) {
              std::__shared_weak_count::__release_shared[abi:fe180100](v43);
            }
            if (v47 >= v49) {
              goto LABEL_80;
            }
LABEL_78:
            if (*a4)
            {
              *a3 = v40;
              return v40;
            }
            else
            {
              *a3 = a2;
            }
            return a4;
          }
        }
        std::__shared_weak_count::__release_shared[abi:fe180100](v44);
        goto LABEL_75;
      }
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v23);
    goto LABEL_52;
  }
LABEL_15:
  if ((void *)*a1 == a2)
  {
    uint64_t v20 = a2;
LABEL_43:
    if (*a2)
    {
      *a3 = v20;
      return v20 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  uint64_t v19 = (void *)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v20 = v19;
      uint64_t v19 = (void *)v19[1];
    }
    while (v19);
  }
  else
  {
    uint64_t v27 = a2;
    do
    {
      uint64_t v20 = (void *)v27[2];
      BOOL v28 = *v20 == (void)v27;
      uint64_t v27 = v20;
    }
    while (v28);
  }
  uint64_t v29 = v20[4];
  uint64_t v30 = (std::__shared_weak_count *)v20[5];
  if (v30) {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v32 = *a5;
  uint64_t v31 = (std::__shared_weak_count *)a5[1];
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v33 = *(void *)(v29 + 16);
  if (v33) {
    unsigned int v34 = *(_DWORD *)(v33 + 4);
  }
  else {
    unsigned int v34 = 0;
  }
  uint64_t v35 = *(void *)(v32 + 16);
  if (v35)
  {
    unsigned int v36 = *(_DWORD *)(v35 + 4);
    if (!v31) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  unsigned int v36 = 0;
  if (v31) {
LABEL_39:
  }
    std::__shared_weak_count::__release_shared[abi:fe180100](v31);
LABEL_40:
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v30);
  }
  if (v34 < v36) {
    goto LABEL_43;
  }
LABEL_80:

  return std::__tree<std::shared_ptr<CG::DisplayListResourceClip>,CG::CompareResourceClip,std::allocator<std::shared_ptr<CG::DisplayListResourceClip>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceClip>>((uint64_t)a1, a3, a5);
}

void std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unsigned int v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  uint64_t v5 = operator new(8 * prime);
  unsigned int v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    uint64_t v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *unint64_t v8 = *v14;
          *uint64_t v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          uint64_t v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        unint64_t v8 = v14;
        uint64_t v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

id __send_analytics_event_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (_block_invoke_onceToken != -1) {
    dispatch_once(&_block_invoke_onceToken, &__block_literal_global_71_16078);
  }
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2) {
    uint64_t v3 = (void *)[v2 mutableCopy];
  }
  else {
    uint64_t v3 = objc_opt_new();
  }
  int8x8_t v4 = v3;
  if (_block_invoke_appIdentifier) {
    [v3 setObject:_block_invoke_appIdentifier forKeyedSubscript:@"bundleID"];
  }
  uint64_t v19 = 0;
  memset(array, 0, sizeof(array));
  int v5 = backtrace((void **)array, 15);
  backtrace_image_offsets((void *const *)array, image_offsets, v5);
  if (v5 < 1)
  {
    uint64_t v10 = MEMORY[0x1E4F1CC28];
    [v4 setObject:MEMORY[0x1E4F1CC28] forKeyedSubscript:@"calledFromPDFKit"];
    [v4 setObject:v10 forKeyedSubscript:@"calledFromAppKit"];
  }
  else
  {
    unsigned int v6 = &image_offsets[v5];
    uint64_t v7 = image_offsets;
    uint64_t v8 = MEMORY[0x1E4F1CC28];
    while (*(void *)v7->uuid != (void)_block_invoke_pdfKit_uuid
         || *(void *)&v7->uuid[8] != *((void *)&_block_invoke_pdfKit_uuid + 1))
    {
      if (++v7 >= v6) {
        goto LABEL_18;
      }
    }
    uint64_t v8 = MEMORY[0x1E4F1CC38];
LABEL_18:
    [v4 setObject:v8 forKeyedSubscript:@"calledFromPDFKit"];
    unint64_t v11 = image_offsets;
    uint64_t v12 = MEMORY[0x1E4F1CC28];
    while (*(void *)v11->uuid != (void)_block_invoke_appKit_uuid
         || *(void *)&v11->uuid[8] != *((void *)&_block_invoke_appKit_uuid + 1))
    {
      if (++v11 >= v6) {
        goto LABEL_26;
      }
    }
    uint64_t v12 = MEMORY[0x1E4F1CC38];
LABEL_26:
    [v4 setObject:v12 forKeyedSubscript:@"calledFromAppKit"];
    uint64_t v14 = image_offsets;
    uint64_t v10 = MEMORY[0x1E4F1CC28];
    while (*(void *)v14->uuid != (void)_block_invoke_coreUI_uuid
         || *(void *)&v14->uuid[8] != *((void *)&_block_invoke_coreUI_uuid + 1))
    {
      if (++v14 >= v6) {
        goto LABEL_34;
      }
    }
    uint64_t v10 = MEMORY[0x1E4F1CC38];
  }
LABEL_34:
  [v4 setObject:v10 forKeyedSubscript:@"calledFromCoreUI"];
  return v4;
}

CGBitmapInfo CGBitmapContextGetBitmapInfo(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(_DWORD *)(*((void *)context + 4) + 40);
  }
  handle_invalid_context((char)"CGBitmapContextGetBitmapInfo", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space)
{
  CGImageRef v2 = 0;
  if (!image || !space) {
    return v2;
  }
  if ((*((unsigned char *)image + 39) & 2) != 0) {
    return 0;
  }
  uint64_t v5 = *((void *)image + 18);
  if (v5) {
    uint64_t v5 = *(void *)(*(void *)(v5 + 24) + 48);
  }
  if (*(void *)(*((void *)space + 3) + 48) != v5) {
    return 0;
  }
  if ((valid_image_colorspace((uint64_t)space, *((_DWORD *)image + 8)) & 1) == 0)
  {
    CGPostError((uint64_t)"%s: invalid image colorspace: NULL.", v6, v7, v8, v9, v10, v11, v12, (char)"CGImageCreateCopyWithColorSpace");
    return 0;
  }
  if (CGColorSpaceEqualToColorSpace((uint64_t)space, *((void *)image + 18)))
  {
    CFRetain(image);
    return image;
  }
  else
  {
    CopCGFloat y = CGImageCreateCopy(image);
    CGImageRef v2 = Copy;
    if (Copy)
    {
      CGColorSpaceRelease(*((CGColorSpaceRef *)Copy + 18));
      CFRetain(space);
      *((void *)v2 + 18) = space;
      uint64_t v22 = *((void *)v2 + 26);
      if (v22) {
        CGImageProviderSetProperty(v22, @"kCGImageProviderColorSpaceChangedOnImageCopy", space);
      }
      if (*((void *)v2 + 28))
      {
        CGPostError((uint64_t)"%s: image headroom and conversion info not copied", v15, v16, v17, v18, v19, v20, v21, (char)"CGImageCreateCopyWithColorSpace");
        CGPropertiesRelease(*((CFTypeRef **)v2 + 28));
      }
      *((void *)v2 + 28) = 0;
    }
  }
  return v2;
}

void CGContextAddRect(CGContextRef c, CGRect rect)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
      {
        uint64_t v14 = *((void *)c + 12);
        uint64_t v15 = (CGPath *)*((void *)c + 21);
        if (v15)
        {
          CGPathAddRect(v15, (const CGAffineTransform *)(v14 + 24), rect);
        }
        else
        {
          *((void *)c + 21) = CGPathCreateWithRect(rect, (const CGAffineTransform *)(v14 + 24));
        }
      }
      return;
    }
    CGContextRef v16 = c;
  }
  else
  {
    CGContextRef v16 = 0;
  }

  handle_invalid_context((char)"CGContextAddRect", (uint64_t)v16, v2, v3, v4, v5, v6, v7);
}

char *__device_state_create_root_block_invoke()
{
  CFTypeRef result = (char *)malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
  *((_DWORD *)result + 1) = 1;
  *((void *)result + 1) = 0;
  *((void *)result + 2) = 0;
  *((_WORD *)result + 12) = 0;
  *(void *)(result + 36) = 0;
  *(void *)(result + 28) = 0;
  *((_DWORD *)result + 11) = 0;
  device_state_create_root_root = (uint64_t)result;
  *CFTypeRef result = 1;
  return result;
}

uint64_t (**rips_s_BltGlyph(uint64_t a1, _DWORD *a2, uint64_t a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10))()
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  long long v16 = *(_OWORD *)(a10 + 48);
  v27[2] = *(_OWORD *)(a10 + 32);
  long long v28 = v16;
  uint64_t v29 = *(void *)(a10 + 64);
  long long v17 = *(_OWORD *)(a10 + 16);
  v27[0] = *(_OWORD *)a10;
  v27[1] = v17;
  int v18 = *(_DWORD *)(a1 + 12);
  if ((v18 & 0x20) == 0)
  {
    if ((v18 & 0x1000) == 0)
    {
      return RIPLayerBltGlyph(a2, a3, a4, a5, a6, a7, a8, a10);
    }
    return (uint64_t (**)())1;
  }
  v26[0] = 0;
  v26[1] = 0;
  if (a4) {
    uint64_t v21 = a4;
  }
  else {
    uint64_t v21 = a5;
  }
  uint64_t v22 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)v21, 0, 0, a2[13], a6, (uint64_t)a7, a8);
  LODWORD(v27[0]) = 2;
  *(void *)&long long v28 = 0x3FF0000000000000;
  RIPLayerBltGlyph(v22, 0, a4, a5, 0, 0, 0, (uint64_t)v27);
  rips_s_BltShapeShadow(a1, (uint64_t)a2, a3, (uint64_t)v22, a6, a7, a10, v23);
  if (v22) {
    (*(void (**)(char *))(*(void *)v22 + 24))(v22);
  }
  if (a3 && !CGSBoundsIntersection((int *)(a3 + 12), v21, v26) || (*(unsigned char *)(a1 + 13) & 0x10) != 0) {
    return (uint64_t (**)())1;
  }
  if (a3) {
    uint64_t v24 = (int *)v26;
  }
  else {
    uint64_t v24 = a4;
  }
  return RIPLayerBltGlyph(a2, a3, v24, a5, a6, a7, a8, a10);
}

uint64_t rips_s_BltShape(uint64_t a1, int *a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8)
{
  int v15 = *(_DWORD *)(a1 + 12);
  if ((v15 & 0x10) != 0)
  {
    v21[0] = 0;
    v21[1] = 0;
    rips_s_BltShapeShadow(a1, (uint64_t)a2, a3, a5, a6, a7, a8, a8);
    if (!a3
      || (a4 ? (uint64_t v19 = a4) : (uint64_t v19 = (int *)(a5 + 12)), CGSBoundsIntersection((int *)(a3 + 12), v19, v21)))
    {
      if ((*(unsigned char *)(a1 + 13) & 0x10) == 0)
      {
        if (a3) {
          uint64_t v20 = (int *)v21;
        }
        else {
          uint64_t v20 = a4;
        }
        RIPLayerBltShape(a2, a3, v20, a5, a6, a7, a8, v18);
      }
    }
    return 1;
  }
  if ((v15 & 0x1000) != 0) {
    return 1;
  }

  return (uint64_t)RIPLayerBltShape(a2, a3, a4, a5, a6, a7, a8, a8);
}

uint64_t rips_s_BltShapeShadow(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = result;
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  int32x4_t v84 = 0uLL;
  v83[0] = 0;
  v83[1] = 0;
  float v15 = *(double *)(a7 + 48);
  float v16 = *(float *)(result + 112) * v15;
  if (a3)
  {
    int32x4_t v84 = vaddq_s32(*(int32x4_t *)(result + 96), *(int32x4_t *)(a4 + 12));
    CFTypeRef result = CGSBoundsIntersection((int *)(a3 + 12), v84.i32, v83);
    if (!result) {
      return result;
    }
  }
  if (v16 <= 0.0039062) {
    return result;
  }
  if (a5)
  {
    long long v17 = *(uint64_t (***)())a5;
    if (*(void *)a5)
    {
      while (v17 != RIPLayer_ripl_class)
      {
        if (*v17)
        {
          long long v17 = (uint64_t (**)())(*v17)();
          if (v17) {
            continue;
          }
        }
        goto LABEL_19;
      }
      if (*(_DWORD *)(a5 + 64))
      {
        long long v18 = *(_OWORD *)(a7 + 16);
        long long v85 = *(_OWORD *)a7;
        long long v86 = v18;
        long long v19 = *(_OWORD *)(a7 + 48);
        long long v87 = *(_OWORD *)(a7 + 32);
        long long v88 = v19;
        uint64_t v20 = *(void *)(a7 + 64);
        LODWORD(v85) = 1;
        uint64_t v89 = v20;
        *(void *)&long long v88 = 0x3FF0000000000000;
        uint64_t v21 = RIPLayerCreate(*(void *)a4, a4 + 12, 0, 0, *(unsigned int *)(a2 + 52), (uint64_t)a6, a7, a8);
        if (v21)
        {
          uint64_t v22 = (int *)v21;
          uint64_t v23 = RIPLayerConvertLayer(*(void *)a4, *(_DWORD *)(a5 + 28) & 8, a5, *(unsigned int *)(a2 + 52));
          if (v23)
          {
            uint64_t v25 = v23;
            if (RIPLayerBltShape(v22, 0, 0, a4, (uint64_t)v23, a6, (uint64_t)&v85, v24))
            {
              float v26 = *(float *)(v14 + 116);
              (*(void (**)(char *))(*(void *)v25 + 24))(v25);
              if (v26 < 0.5)
              {
                float v15 = 0.0039062;
                goto LABEL_23;
              }
              double v77 = RIPLayerGaussianBlur((uint64_t)v22, *(unsigned int *)(a2 + 52), v27, v28, v29, v30, v31, v32, *(float *)(v14 + 116));
              (*(void (**)(int *))(*(void *)v22 + 24))(v22);
              float v15 = 0.0039062;
              uint64_t v22 = (int *)v77;
              if (v77)
              {
LABEL_23:
                unsigned int v34 = v22 + 3;
                int v35 = v22[3];
                int v36 = *(_DWORD *)(v14 + 88);
                if (v35 < 0)
                {
                  if ((int)(0x80000000 - v35) > v36) {
                    return (*(uint64_t (**)(int *, int *))(*(void *)v22 + 24))(v22, v34);
                  }
                }
                else if ((v35 ^ 0x7FFFFFFF) < v36)
                {
                  return (*(uint64_t (**)(int *, int *))(*(void *)v22 + 24))(v22, v34);
                }
                int v37 = v22[4];
                int v38 = *(_DWORD *)(v14 + 92);
                if ((v37 & 0x80000000) == 0)
                {
                  if ((v37 ^ 0x7FFFFFFF) < v38) {
                    return (*(uint64_t (**)(int *, int *))(*(void *)v22 + 24))(v22, v34);
                  }
LABEL_31:
                  v22[3] = v36 + v35;
                  v22[4] = v38 + v37;
                  if (a3) {
                    int v39 = (int *)(a3 + 12);
                  }
                  else {
                    int v39 = v22 + 3;
                  }
                  if (!CGSBoundsIntersection(v39, v34, &v84)) {
                    return (*(uint64_t (**)(int *, int *))(*(void *)v22 + 24))(v22, v34);
                  }
                  uint64_t v89 = 0;
                  long long v87 = 0u;
                  long long v88 = 0u;
                  long long v85 = 0u;
                  long long v86 = 0u;
                  if (*(float *)(v14 + 120) != 0.0 || *(float *)(v14 + 124) != 1.0) {
                    RIPLayerResample((uint64_t)v22, (float *)(v14 + 120), v40, v41, v42, v43, v44, v45);
                  }
                  if (v15 >= 0.99609
                    && (*(unsigned char *)(v14 + 13) & 0x10) == 0
                    && *(int *)a7 <= 2
                    && (!a3 || !*(void *)(a3 + 56)))
                  {
                    RIPLayerMask(v22, (void *)a4, v40, v41, v42, v43, v44, v45);
                  }
                  unint64_t v46 = *(void *)(v14 + 80);
                  if (!v46)
                  {
                    if (default_shadow_color_predicate != -1) {
                      dispatch_once(&default_shadow_color_predicate, &__block_literal_global_3);
                    }
                    unint64_t v46 = default_shadow_color_shadow_color;
                  }
                  Cache = CGColorTransformGetCache(*(void **)(a7 + 16));
                  if (Cache)
                  {
                    uint64_t v49 = Cache[2];
                    if (v49)
                    {
                      unint64_t v50 = *(void *)(*(void *)(v49 + 24) + 48);
                      if (v50 >> 61)
                      {
                        unint64_t v80 = *(void *)(*(void *)(v49 + 24) + 48);
                        MEMORY[0x1F4188790](Cache, v48);
                        double v81 = (double *)&v78;
                        uint64_t v58 = 0;
LABEL_59:
                        uint64_t v62 = *(void *)(a7 + 16);
                        uint64_t v82 = &v79;
                        if (v46)
                        {
                          if ((v46 & 0x8000000000000000) != 0)
                          {
                            CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v46, v51, v52, v53, v54, v55, v56, v57);
                            double v64 = (CGColor *)v46;
                            unint64_t v46 = (unint64_t)ColorSpace;
                          }
                          else
                          {
                            double v64 = (CGColor *)v46;
                            unint64_t v46 = *(void *)(v46 + 24);
                          }
                        }
                        else
                        {
                          double v64 = 0;
                        }
                        uint64_t v65 = *(unsigned int *)(a7 + 8);
                        Components = (double *)CGColorGetComponents(v64);
                        if (CGColorTransformConvertColorComponents(v62, (void *)v46, v65, Components, v58))
                        {
                          RIPColorCreateWithColor(*(_DWORD *)(a7 + 24), v58, v80, 1.0);
                          double v74 = v73;
                        }
                        else
                        {
                          double v74 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
                          *double v74 = &ripc_class;
                          v74[1] = 0;
                          v74[2] = 0;
                          v74[3] = 0;
                          *((_DWORD *)v74 + 39) = 1065353216;
                        }
                        if (v58 != v81) {
                          free(v58);
                        }
                        long long v75 = *(_OWORD *)(a7 + 48);
                        long long v87 = *(_OWORD *)(a7 + 32);
                        long long v88 = v75;
                        uint64_t v89 = *(void *)(a7 + 64);
                        long long v76 = *(_OWORD *)(a7 + 16);
                        long long v85 = *(_OWORD *)a7;
                        long long v86 = v76;
                        *(double *)&long long v88 = v16;
                        if ((*(unsigned char *)(v14 + 13) & 0x10) != 0) {
                          RIPLayerDefine(a2, (__n128 *)&v84, v67, v68, v69, v70, v71, v72);
                        }
                        RIPLayerBltShape((int *)a2, a3, v84.i32, (uint64_t)v22, (uint64_t)v74, a6, (uint64_t)&v85, v72);
                        free(v74);
                        return (*(uint64_t (**)(int *, int *))(*(void *)v22 + 24))(v22, v34);
                      }
                      Cache = (void *)(8 * v50);
                    }
                    else
                    {
                      Cache = 0;
                    }
                  }
                  size_t v59 = MEMORY[0x1F4188790](Cache, v48);
                  unint64_t v80 = v61;
                  double v81 = (double *)((char *)&v79 - ((v60 + 15) & 0xFFFFFFFFFFFFFFF0));
                  if (v61 <= 0x1FFFFFFFFFFFFFFELL) {
                    uint64_t v58 = (double *)((char *)&v79 - ((v60 + 15) & 0xFFFFFFFFFFFFFFF0));
                  }
                  else {
                    uint64_t v58 = 0;
                  }
                  if (v61 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022) {
                    uint64_t v58 = (double *)malloc_type_malloc(v59, 0xDB697BA7uLL);
                  }
                  goto LABEL_59;
                }
                if ((int)(0x80000000 - v37) <= v38) {
                  goto LABEL_31;
                }
                return (*(uint64_t (**)(int *, int *))(*(void *)v22 + 24))(v22, v34);
              }
              goto LABEL_19;
            }
            (*(void (**)(char *))(*(void *)v25 + 24))(v25);
          }
          (*(void (**)(int *))(*(void *)v22 + 24))(v22);
        }
        float v15 = 0.0039062;
      }
    }
  }
LABEL_19:
  float v33 = *(float *)(v14 + 116);
  if (v33 >= 0.5) {
    CFTypeRef result = (uint64_t)RIPLayerGaussianBlur(a4, *(unsigned int *)(a2 + 52), a3, a4, a5, (uint64_t)a6, a7, a8, v33);
  }
  else {
    CFTypeRef result = (uint64_t)RIPLayerCreateWithLayer(*(void *)a4, (uint64_t *)(a4 + 12), (uint64_t *)a4, *(unsigned int *)(a2 + 52));
  }
  uint64_t v22 = (int *)result;
  if (result) {
    goto LABEL_23;
  }
  return result;
}

float RIPColorCreateWithColor(int a1, double *a2, uint64_t a3, double a4)
{
  uint64_t v8 = (char *)malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *(void *)uint64_t v8 = &ripc_class;
  *((_DWORD *)v8 + 6) = a1;
  if (a3)
  {
    uint64_t v9 = (float *)(v8 + 28);
    do
    {
      double v10 = *a2++;
      float v11 = v10;
      *v9++ = v11;
      --a3;
    }
    while (a3);
  }
  float result = a4;
  *((float *)v8 + 39) = result;
  return result;
}

char *RIPLayerGaussianBlur(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  signed int v10 = vcvtpd_s64_f64(fabs(a9));
  if (!*(void *)a1 || v10 > 0x7FFFFFF) {
    return 0;
  }
  uint64_t v12 = *(_DWORD **)(a1 + 32);
  int v13 = (*v12 >> 8) & 0xF;
  if (v13 != 3 && v13 != 0) {
    return 0;
  }
  int v15 = HIWORD(*v12) & 0x3F;
  if (v15 != 32 && v15 != 8) {
    return 0;
  }
  dispatch_once_t v21 = RIPGetDepthForLayerFormat(0, a2, a3, a4, a5, a6, a7, a8);
  long long v44 = *(_OWORD *)(a1 + 12);
  *(void *)&long long v44 = (v44 - v10) | ((unint64_t)(DWORD1(v44) - v10) << 32);
  *((void *)&v44 + 1) = (DWORD2(v44) + 2 * v10) | ((unint64_t)(HIDWORD(v44)
                                                                                                  + 2 * v10) << 32);
  if (v12 == (_DWORD *)v21) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = 17;
  }
  if (v12 == (_DWORD *)v21) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = *(void *)(a1 + 32);
  }
  uint64_t v24 = RIPLayerCreate(*(void *)a1, (uint64_t)&v44, v22, v23, a2, v18, v19, v20);
  if (v24)
  {
    if (v10 < 9)
    {
      if (v10 < 0)
      {
        uint64_t v27 = (double *)v45;
LABEL_36:
        if ((RIPLayerSymmetricConvolve((uint64_t)v24, a1, v27, v10) & 1) == 0)
        {
          (*(void (**)(char *))(*(void *)v24 + 24))(v24);
          uint64_t v24 = 0;
        }
        if (v27 != (double *)v45) {
          free(v27);
        }
        return v24;
      }
      uint64_t v26 = (v10 + 1);
      uint64_t v27 = (double *)v45;
    }
    else
    {
      uint64_t v26 = (v10 + 1);
      uint64_t v27 = (double *)malloc_type_malloc(8 * v26, 0x100004000313F17uLL);
    }
    uint64_t v28 = 0;
    double v29 = (double)v10 * 0.5;
    double v30 = 1.0 / (v29 * 2.50662827);
    uint64x2_t v39 = (uint64x2_t)vdupq_n_s64(v26 - 1);
    uint64x2_t v31 = (uint64x2_t)xmmword_1850CD8A0;
    uint64_t v32 = (v26 + 1) & 0x1FFFFFFFELL;
    float64x2_t v37 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v29 * (v29 + v29)), 0);
    int64x2_t v38 = vdupq_n_s64(2uLL);
    do
    {
      int32x2_t v42 = vmovn_s64((int64x2_t)vcgeq_u64(v39, v31));
      int64x2_t v43 = (int64x2_t)v31;
      v33.i32[0] = v28;
      v33.i32[1] = v28 + 1;
      int32x2_t v34 = vmul_s32(v33, v33);
      v35.i64[0] = v34.i32[0];
      v35.i64[1] = v34.i32[1];
      __CGFloat x = vdivq_f64(vnegq_f64(vcvtq_f64_s64(v35)), v37);
      long double v41 = exp(__x.f64[1]);
      v36.f64[0] = exp(__x.f64[0]);
      v36.f64[1] = v41;
      if (v42.i8[0]) {
        v27[v28] = v30 * v36.f64[0];
      }
      if (v42.i8[4]) {
        v27[v28 + 1] = vmuld_lane_f64(v30, v36, 1);
      }
      v28 += 2;
      uint64x2_t v31 = (uint64x2_t)vaddq_s64(v43, v38);
    }
    while (v32 != v28);
    goto LABEL_36;
  }
  return v24;
}

uint64_t RIPLayerSymmetricConvolve(uint64_t a1, uint64_t a2, double *a3, unsigned int a4)
{
  if (!a1) {
    return 0;
  }
  if (!*(void *)a1 || a2 == 0) {
    return 0;
  }
  if (!*(void *)a2) {
    return 0;
  }
  uint64_t v7 = *(unsigned int **)(a1 + 32);
  if (!v7 || v7 != *(unsigned int **)(a2 + 32)) {
    return 0;
  }
  int32x4_t v65 = 0uLL;
  unsigned int v10 = *v7;
  int v11 = (*v7 >> 8) & 0xF;
  if (v11 != 3 && v11 != 0) {
    return 0;
  }
  int v13 = HIWORD(v10) & 0x3F;
  if (v13 != 32 && v13 != 8) {
    return 0;
  }
  unsigned int v18 = *(_DWORD *)(a1 + 12);
  unsigned int v17 = *(_DWORD *)(a1 + 16);
  int8x16_t v19 = *(int8x16_t *)(a2 + 12);
  v66.i64[0] = __PAIR64__(v17, v18);
  int v20 = 2 * a4;
  uint64_t v60 = v19.i64[0];
  int32x4_t v56 = (int32x4_t)vextq_s8(v19, v19, 8uLL);
  v66.u64[1] = (unint64_t)vadd_s32(*(int32x2_t *)v56.i8, vdup_n_s32(2 * a4));
  if ((CGSBoundsIntersection((int *)(a1 + 12), v66.i32, &v65) & 1) == 0) {
    return 0;
  }
  uint64_t v27 = v65.i64[0];
  v28.i64[0] = v60;
  v28.i64[1] = v66.i64[1];
  int32x4_t v29 = vsubq_s32(vaddq_s32(v65, v28), v66);
  int32x4_t v30 = vaddq_s32((int32x4_t)vdupq_laneq_s64((int64x2_t)vsubq_s32(v65, v28), 1), v56);
  *(void *)&long long v31 = v29.i64[0];
  *((void *)&v31 + 1) = v30.i64[0];
  long long v64 = v31;
  *(int32x2_t *)&long long v31 = vcgtz_s32(vrev64_s32(*(int32x2_t *)v30.i8));
  if ((DWORD1(v31) & v31 & 1) == 0) {
    return 0;
  }
  uint64_t v32 = *(void *)(a1 + 56);
  if (v32)
  {
    __int32 v33 = v65.i32[3];
  }
  else
  {
    int32x4_t v57 = v29;
    int32x4_t v61 = v30;
    if (!ripl_CreateMask(a1, 1, v21, v22, v23, v24, v25, v26)) {
      return 0;
    }
    uint64_t v32 = *(void *)(a1 + 56);
    unsigned int v10 = *v7;
    unsigned int v18 = *(_DWORD *)(a1 + 12);
    unsigned int v17 = *(_DWORD *)(a1 + 16);
    uint64_t v27 = v65.i64[0];
    __int32 v33 = v65.i32[3];
    int32x4_t v29 = v57;
    int32x4_t v30 = v61;
  }
  unsigned int v34 = v30.u32[1];
  uint64_t v35 = v10 >> 25;
  int v36 = v27 - v18;
  int v37 = *(_DWORD *)(a1 + 24) + v17 - v33 - HIDWORD(v27);
  int v38 = *(_DWORD *)(a1 + 48);
  uint64_t v39 = *(void *)(a2 + 56);
  if (*(void *)(a2 + 72))
  {
    if (!v39)
    {
      int32x4_t v58 = v29;
      int32x4_t v62 = v30;
      int v54 = v37;
      uint64_t v40 = v32;
      unsigned int v41 = v30.u32[1];
      int Mask = ripl_CreateMask(a2, 0, v21, v22, v23, v24, v25, v26);
      unsigned int v34 = v41;
      uint64_t v8 = 0;
      if (!Mask) {
        return v8;
      }
      uint64_t v39 = *(void *)(a2 + 56);
      uint64_t v32 = v40;
      int v37 = v54;
      int32x4_t v29 = v58;
      int32x4_t v30 = v62;
    }
    goto LABEL_40;
  }
  if (v39 && !*(_DWORD *)(a2 + 64))
  {
LABEL_40:
    int v51 = *(_DWORD *)(a2 + 48);
    __n128 v48 = (__n128)vaddq_s32(v30, v29);
    uint64_t v46 = (char *)(v39
                 + (*(_DWORD *)(a2 + 16) + *(_DWORD *)(a2 + 24) - v48.n128_u32[1]) * v51
                 + (v29.i32[0] - (uint64_t)*(int *)(a2 + 12)) * v35);
    goto LABEL_42;
  }
  int v63 = v36;
  uint64_t v43 = (v36 + a4) * v35;
  uint64_t v44 = v32;
  uint64_t v45 = v32 + v43;
  uint64_t v46 = (char *)(v45 + v38 * (v37 + a4));
  unsigned int v47 = v20 + 3;
  if (v30.i32[1] < (v20 + 3)) {
    unsigned int v47 = v30.u32[1];
  }
  if (v30.i32[1] >= 0) {
    unsigned int v34 = v47;
  }
  int v55 = v37;
  int v59 = v34;
  CGBlt_fillBytes(v30.i32[0], v34, -1, (char *)(v45 + v38 * (v37 + a4)), v38);
  int v49 = *(_DWORD *)(a2 + 64);
  if (v49 && (unsigned int v50 = ripl_Containment(&v64, (_DWORD *)(a2 + 12), v49)) != 0)
  {
    CGSCombineMask(0, 0, v46, *(_DWORD *)(a1 + 48), SDWORD2(v64), v59, v50);
    unsigned int v34 = v59;
    int v51 = v38;
    uint64_t v32 = v44;
    int v36 = v63;
    int v37 = v55;
  }
  else
  {
    int v51 = v38;
    uint64_t v32 = v44;
    int v36 = v63;
    int v37 = v55;
    unsigned int v34 = v59;
  }
LABEL_42:
  uint64_t v52 = (void *)(v32 + (v38 * v37) + (int)v35 * (uint64_t)v36);
  unsigned int v53 = v34;
  if (!symmetric_convolve(DWORD2(v64), v34, v52, *(_DWORD *)(a1 + 48), (uint64_t)v46, v51, a3, a4, v48, v35))return 0; {
  uint64_t v8 = 1;
  }
  if (v53 != HIDWORD(v64))
  {
    CGBlt_copyBytes(v65.i32[2], (2 * a4) | 1, (char *)v52 + (*(_DWORD *)(a1 + 48) * (v20 + 2)), (char *)v52 + (*(_DWORD *)(a1 + 48) * (HIDWORD(v64) - 1)), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 48));
    CGBlt_copyBytes(v65.i32[2], HIDWORD(v64) - v53, (char *)v52 + *(_DWORD *)(a1 + 48) * ((2 * a4) | 1), (char *)v52 + *(_DWORD *)(a1 + 48) * ((2 * a4) | 1) + *(unsigned int *)(a1 + 48), 0, *(_DWORD *)(a1 + 48));
  }
  return v8;
}

uint64_t ripl_CreateMask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 56)) {
    return 1;
  }
  int v9 = a2;
  uint64_t v11 = *(void *)(a1 + 32);
  dispatch_once_t v13 = RIPGetDepthForLayerFormat(0, a2, a3, a4, a5, a6, a7, a8);
  uint64_t result = 0;
  if (v11 == v13)
  {
    int v14 = *(_DWORD *)(a1 + 20);
    int v28 = v14;
    if (v14 < 1) {
      return 0;
    }
    int v15 = *(_DWORD *)(a1 + 24);
    unsigned int v27 = v15;
    if (v15 < 1) {
      return 0;
    }
    unsigned int v16 = (v14 + 3) & 0xFFFFFFFC;
    unint64_t v17 = v15 * (unint64_t)v16;
    size_t v18 = v17 > 0x7FFFFFFB ? 0xFFFFFFFFLL : (v17 + 19) & 0xFFFFFFF0;
    if ((v18 & 0x80000000) != 0) {
      return 0;
    }
    int8x16_t v19 = *(int **)(a1 + 72);
    if (v19)
    {
      if (v19 != (int *)&the_empty_shape)
      {
        uint64_t v26 = 0;
        shape_enum_clip_alloc(0, v12, v19, 1, 1, 0, 0, 0, v14, v15);
        if (v20)
        {
          uint64_t v21 = v20;
          uint64_t v22 = malloc_type_malloc(v18, 0x6021F689uLL);
          *(void *)(a1 + 56) = v22;
          if (v22)
          {
            *(_DWORD *)(a1 + 48) = v16;
            *(_DWORD *)(a1 + 28) &= ~2u;
            while (1)
            {
              int v23 = shape_enum_clip_next((uint64_t)v21, (int *)&v26 + 1, &v26, &v28, &v27);
              if (!v23) {
                break;
              }
              CGBlt_fillBytes(v28, v27, ~v23 >> 31, (char *)(*(void *)(a1 + 56) + (int)v26 * (uint64_t)(int)v16 + SHIDWORD(v26)), v16);
            }
            free(v21);
LABEL_23:
            if (v9)
            {
              uint64_t v25 = *(void **)(a1 + 72);
              if (v25)
              {
                if (v25 != &the_empty_shape) {
                  free(v25);
                }
                *(_DWORD *)(a1 + 64) = 0;
                *(void *)(a1 + 72) = 0;
              }
              else if (*(_DWORD *)(a1 + 64))
              {
                *(_DWORD *)(a1 + 64) = 0;
              }
            }
            return 1;
          }
          free(v21);
        }
        return 0;
      }
      uint64_t result = (uint64_t)malloc_type_calloc(1uLL, v18, 0x43FD8F5FuLL);
      *(void *)(a1 + 56) = result;
      if (result)
      {
        *(_DWORD *)(a1 + 48) = v16;
        *(_DWORD *)(a1 + 28) &= ~2u;
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t result = (uint64_t)malloc_type_malloc(v18, 0x9C994440uLL);
      *(void *)(a1 + 56) = result;
      if (result)
      {
        *(_DWORD *)(a1 + 48) = v16;
        *(_DWORD *)(a1 + 28) &= ~2u;
        memset((void *)result, 255, v18);
        unsigned int v24 = *(_DWORD *)(a1 + 64);
        if (v24) {
          CGSCombineMask(0, 0, *(char **)(a1 + 56), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24), v24);
        }
        goto LABEL_23;
      }
    }
  }
  return result;
}

uint64_t CGSCombineMask(char *a1, int a2, char *__b, int a4, int a5, int a6, unsigned int a7)
{
  int v9 = a2;
  unsigned int v10 = (unsigned __int8 *)a1;
  unsigned int v11 = HIBYTE(a7);
  if (a5 == 1)
  {
    unsigned int v12 = BYTE1(a7) + v11;
    unsigned int v13 = 255;
    if (v12 <= 0xFE) {
      unsigned int v14 = 255 - v12;
    }
    else {
      unsigned int v14 = 0;
    }
    int v15 = v14 > 0xFE;
  }
  else
  {
    if (a5 < 2) {
      return 0;
    }
    unsigned int v13 = BYTE1(a7) ^ 0xFF;
    if (BYTE1(a7)) {
      int v16 = -2;
    }
    else {
      int v16 = -1;
    }
    if (v11) {
      unsigned int v14 = v11 ^ 0xFF;
    }
    else {
      unsigned int v14 = 255;
    }
    if (v11) {
      int v17 = a5;
    }
    else {
      int v17 = a5 + 1;
    }
    int v15 = v17 + v16;
  }
  if (a6 == 1)
  {
    unsigned int v18 = BYTE2(a7) + a7;
    unsigned int v19 = 255;
    if (v18 <= 0xFE) {
      unsigned int v20 = 255 - v18;
    }
    else {
      unsigned int v20 = 0;
    }
    int v21 = v20 > 0xFE;
    if (a1) {
      goto LABEL_22;
    }
LABEL_50:
    if (v20 > 0xFE) {
      goto LABEL_79;
    }
    int32x2_t v42 = __b;
    if (v14 <= 0xFE)
    {
      *__double b = (unsigned __int16)(v20 * v14 + ((v20 * v14) >> 8) + 1) >> 8;
      int32x2_t v42 = __b + 1;
    }
    if (v15 < 4)
    {
      unsigned int v43 = v15;
      if (!v15)
      {
LABEL_76:
        if (v13 <= 0xFE) {
          *int32x2_t v42 = (unsigned __int16)(v20 * v13 + ((v20 * v13) >> 8) + 1) >> 8;
        }
        __b += a4;
LABEL_79:
        if (!v21) {
          goto LABEL_92;
        }
        int32x4_t v62 = __b;
        if (v14 <= 0xFE)
        {
          if (v13 < 0xFF)
          {
            unsigned int v63 = v21 + 1;
            long long v64 = __b;
            do
            {
              *long long v64 = v14;
              v64[v15 + 1] = v13;
              v64 += a4;
              --v63;
            }
            while (v63 > 1);
LABEL_91:
            __b += v21 * (uint64_t)a4;
LABEL_92:
            if (v19 > 0xFE) {
              return 1;
            }
            if (v14 <= 0xFE) {
              *__b++ = (unsigned __int16)(v19 * v14 + ((v19 * v14) >> 8) + 1) >> 8;
            }
            if (v15 >= 4)
            {
              if (v15 >= 7) {
                int v69 = 7;
              }
              else {
                int v69 = v15;
              }
              uint64_t v70 = (v15 - v69 + 3) & 0xFFFFFFFC;
              memset(__b, v19, v70 + 4);
              int v15 = v15 - v70 - 4;
              __b += v70 + 4;
            }
            if (v15 >= 1)
            {
              memset(__b, v19, v15);
              __b += v15;
            }
            if (v13 > 0xFE) {
              return 1;
            }
            unsigned int v61 = v19 * v13;
            goto LABEL_104;
          }
          unsigned int v65 = v21 + 1;
          int32x4_t v66 = __b;
          do
          {
            char *v66 = v14;
            v66 += a4;
            --v65;
          }
          while (v65 > 1);
          int32x4_t v62 = __b + 1;
        }
        if (v13 <= 0xFE)
        {
          uint64_t v67 = &v62[v15];
          int v68 = v21 + 1;
          do
          {
            *uint64_t v67 = v13;
            v67 += a4;
            --v68;
          }
          while (v68 > 1);
        }
        goto LABEL_91;
      }
    }
    else
    {
      memset(v42, v20, (v15 & 0xFFFFFFFC) - 4 + 4);
      unsigned int v43 = v15 & 3;
      v42 += v15 & 0xFFFFFFFC;
      if ((v15 & 3) == 0) {
        goto LABEL_76;
      }
    }
    memset(v42, v20, v43);
    v42 += v43;
    goto LABEL_76;
  }
  if (a6 < 2) {
    return 0;
  }
  unsigned int v20 = BYTE2(a7) ^ 0xFF;
  unsigned int v19 = a7 ^ 0xFF;
  if ((_BYTE)a7) {
    int v40 = -2;
  }
  else {
    int v40 = -1;
  }
  int v41 = v40 + a6;
  if (BYTE2(a7)) {
    int v21 = v41;
  }
  else {
    int v21 = v41 + 1;
  }
  if (!a1) {
    goto LABEL_50;
  }
LABEL_22:
  if (a1 != __b || a2 != a4)
  {
    CGBlt_copyBytes(a5, a6, a1, __b, a2, a4);
    int v9 = a4;
    unsigned int v10 = (unsigned __int8 *)__b;
  }
  if (v20 <= 0xFE)
  {
    uint64_t v22 = v10;
    int v23 = __b;
    if (v14 <= 0xFE)
    {
      uint64_t v22 = v10 + 1;
      unsigned int v24 = ((v20 * v14 + ((v20 * v14) >> 8) + 1) >> 8) * *v10;
      *__double b = (unsigned __int16)(v24 + (v24 >> 8) + 1) >> 8;
      int v23 = __b + 1;
    }
    unsigned int v25 = v15;
    if (v15 >= 4)
    {
      do
      {
        v25 -= 4;
        unsigned int v26 = (v20 * v22[1] + ((v20 * v22[1]) >> 8) + 1) >> 8;
        *int v23 = (unsigned __int16)(v20 * *v22 + ((v20 * *v22) >> 8) + 1) >> 8;
        v23[1] = v26;
        int v27 = v22[2];
        int v28 = v22[3];
        v22 += 4;
        v23[2] = (unsigned __int16)(v20 * v27 + ((v20 * v27) >> 8) + 1) >> 8;
        v23[3] = (unsigned __int16)(v20 * v28 + ((v20 * v28) >> 8) + 1) >> 8;
        v23 += 4;
      }
      while (v25 > 3);
    }
    if (v25)
    {
      unsigned int v29 = v25 + 1;
      do
      {
        int v30 = *v22++;
        *v23++ = (unsigned __int16)(v20 * v30 + ((v20 * v30) >> 8) + 1) >> 8;
        --v29;
      }
      while (v29 > 1);
    }
    if (v13 <= 0xFE)
    {
      unsigned int v31 = (v20 * v13 + ((v20 * v13) >> 8) + 1) >> 8;
      *int v23 = (unsigned __int16)(v31 * *v22 + ((v31 * *v22) >> 8) + 1) >> 8;
    }
    __b += a4;
    v10 += v9;
  }
  if (v21 < 1) {
    goto LABEL_64;
  }
  uint64_t v32 = v10;
  __int32 v33 = __b;
  if (v14 > 0xFE) {
    goto LABEL_60;
  }
  if (v13 >= 0xFF)
  {
    unsigned int v45 = v21 + 1;
    uint64_t v46 = v10;
    unsigned int v47 = __b;
    do
    {
      int v48 = *v46;
      v46 += v9;
      *unsigned int v47 = (unsigned __int16)(v14 * v48 + ((v14 * v48) >> 8) + 1) >> 8;
      v47 += a4;
      --v45;
    }
    while (v45 > 1);
    uint64_t v32 = v10 + 1;
    __int32 v33 = __b + 1;
LABEL_60:
    if (v13 <= 0xFE)
    {
      int v49 = &v32[v15];
      int v50 = v21 + 1;
      int v51 = &v33[v15];
      do
      {
        int v52 = *v49;
        v49 += v9;
        *int v51 = (unsigned __int16)(v13 * v52 + ((v13 * v52) >> 8) + 1) >> 8;
        v51 += a4;
        --v50;
      }
      while (v50 > 1);
    }
    goto LABEL_63;
  }
  uint64_t v34 = v15 + 1;
  unsigned int v35 = v21 + 1;
  int v36 = v10;
  int v37 = __b;
  do
  {
    int v38 = *v36;
    int v39 = v36[v34];
    v36 += v9;
    *int v37 = (unsigned __int16)(v14 * v38 + ((v14 * v38) >> 8) + 1) >> 8;
    v37[v34] = (unsigned __int16)(v13 * v39 + ((v13 * v39) >> 8) + 1) >> 8;
    v37 += a4;
    --v35;
  }
  while (v35 > 1);
LABEL_63:
  v10 += v9 * (uint64_t)v21;
  __b += v21 * (uint64_t)a4;
LABEL_64:
  if (v19 > 0xFE) {
    return 1;
  }
  if (v14 <= 0xFE)
  {
    int v53 = *v10++;
    unsigned int v54 = ((v19 * v14 + ((v19 * v14) >> 8) + 1) >> 8) * v53;
    *__b++ = (unsigned __int16)(v54 + (v54 >> 8) + 1) >> 8;
  }
  if (v15 >= 4)
  {
    do
    {
      unsigned int v55 = v15;
      v15 -= 4;
      unsigned int v56 = (v19 * v10[1] + ((v19 * v10[1]) >> 8) + 1) >> 8;
      *__double b = (unsigned __int16)(v19 * *v10 + ((v19 * *v10) >> 8) + 1) >> 8;
      __b[1] = v56;
      int v57 = v10[2];
      int v58 = v10[3];
      v10 += 4;
      __b[2] = (unsigned __int16)(v19 * v57 + ((v19 * v57) >> 8) + 1) >> 8;
      __b[3] = (unsigned __int16)(v19 * v58 + ((v19 * v58) >> 8) + 1) >> 8;
      __b += 4;
    }
    while (v55 > 7);
  }
  if (v15 >= 1)
  {
    unsigned int v59 = v15 + 1;
    do
    {
      int v60 = *v10++;
      *__b++ = (unsigned __int16)(v19 * v60 + ((v19 * v60) >> 8) + 1) >> 8;
      --v59;
    }
    while (v59 > 1);
  }
  if (v13 > 0xFE) {
    return 1;
  }
  unsigned int v61 = ((v19 * v13 + ((v19 * v13) >> 8) + 1) >> 8) * *v10;
LABEL_104:
  *__double b = (unsigned __int16)(v61 + (v61 >> 8) + 1) >> 8;
  return 1;
}

uint64_t symmetric_convolve(unsigned int a1, unsigned int a2, void *a3, unsigned int a4, uint64_t a5, int a6, double *a7, unsigned int a8, __n128 a9, unsigned int a10)
{
  uint64_t v88 = a5;
  unsigned int v91 = a4;
  uint64_t v90 = a3;
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  if (a10 <= 7) {
    char v15 = 1;
  }
  else {
    char v15 = 2;
  }
  uint64_t v87 = (2 * a8) | 1;
  size_t v16 = MEMORY[0x1F4188790](v87 << v15, a9);
  unsigned int v18 = (float *)((char *)&v79 - v17);
  unsigned int v19 = (float *)((char *)&v79 - v17);
  if (v16 >= 0x201) {
    unsigned int v19 = (float *)malloc_type_malloc(v16, 0x1BD9F336uLL);
  }
  int v20 = 2 * a8;
  double v21 = *a7;
  unsigned int v92 = a8;
  int v86 = a6;
  if (a10 > 4)
  {
    float v34 = v21;
    v19[a8] = v34;
    if (a8)
    {
      unsigned int v35 = a8 + 1;
      if (a8 + 1 > 2) {
        uint64_t v36 = a8 + 1;
      }
      else {
        uint64_t v36 = 2;
      }
      uint64_t v37 = v36 - 1;
      unsigned int v38 = a8 - 1;
      int v39 = a7 + 1;
      do
      {
        double v40 = *v39++;
        float v41 = v40;
        v19[v35++] = v41;
        v19[v38--] = v41;
        --v37;
      }
      while (v37);
    }
    double v93 = 0;
    uint64_t v94 = v19;
  }
  else if (a8)
  {
    unsigned int v22 = a8 + 1;
    if (a8 + 1 > 2) {
      uint64_t v23 = a8 + 1;
    }
    else {
      uint64_t v23 = 2;
    }
    uint64_t v24 = v23 - 1;
    unsigned int v25 = a7 + 1;
    uint64_t v26 = v24;
    double v27 = v21;
    do
    {
      double v28 = *v25++;
      double v27 = v27 + v28 * 2.0;
      --v26;
    }
    while (v26);
    double v29 = 16384.0 / v27;
    *((_WORD *)v19 + a8) = (int)(v21 * v29);
    unsigned int v30 = a8 - 1;
    unsigned int v31 = a7 + 1;
    do
    {
      double v32 = *v31++;
      int v33 = (int)(v29 * v32);
      *((_WORD *)v19 + v22) = v33;
      *((_WORD *)v19 + v30--) = v33;
      ++v22;
      --v24;
    }
    while (v24);
    double v93 = (const int16_t *)v19;
    uint64_t v94 = 0;
  }
  else
  {
    double v93 = (const int16_t *)v19;
    uint64_t v94 = 0;
    *(_WORD *)unsigned int v19 = (int)(v21 * (16384.0 / v21));
  }
  unsigned int v89 = a2;
  vImagePixelCount v42 = v20 + a2;
  unsigned int v83 = 2 * a8;
  unsigned int v84 = a1;
  vImagePixelCount v43 = v20 + a1;
  vImagePixelCount v44 = (v43 + v20);
  unsigned int v45 = (char *)malloc_type_calloc(1uLL, (v44 * a10 + 15) & 0xFFFFFFF0, 0x25611276uLL);
  uint64_t v46 = (char *)malloc_type_malloc((v43 * a10 * v42 + 15) & 0xFFFFFFF0, 0x1EE74473uLL);
  unsigned int v47 = v46;
  if (v45) {
    BOOL v48 = v46 == 0;
  }
  else {
    BOOL v48 = 1;
  }
  if (v48)
  {
    if (v45) {
      free(v45);
    }
    if (v47) {
      free(v47);
    }
    return 0;
  }
  else
  {
    uint64_t v82 = v18;
    size_t v80 = v44 * a10;
    unsigned int v50 = v92;
    int v51 = v45;
    size_t v52 = a10 * v92 * v43;
    bzero(v46, v52);
    vImagePixelCount v79 = v42;
    bzero(&v47[v43 * a10 * (v42 - v50)], v52);
    long long v85 = v51;
    src.datdouble a = v51;
    src.CGFloat height = 1;
    src.CGFloat width = v44;
    src.rowuint64_t Bytes = v80;
    size_t v80 = (size_t)v47;
    dest.datdouble a = &v47[v52];
    dest.CGFloat height = 1;
    dest.CGFloat width = v43;
    dest.rowuint64_t Bytes = v43 * a10;
    unsigned int v81 = a10;
    rowuint64_t Bytes = dest.rowBytes;
    vImagePixelCount v96 = v43;
    if (a10 == 1)
    {
      uint32_t v54 = v87;
      uint64_t v53 = v88;
      int v55 = v86;
      unsigned int v56 = v93;
      if (v89)
      {
        unsigned int v57 = 0;
        int v58 = &v85[v83];
        size_t v59 = v84;
        vImagePixelCount v60 = v92;
        uint64_t v61 = v89;
        do
        {
          memcpy(v58, (const void *)(v53 + v57), v59);
          vImageConvolve_Planar8(&src, &dest, 0, v60, 0, v56, 1u, v54, 0x4000, 0, 0x14u);
          dest.datdouble a = (char *)dest.data + v96;
          v57 += v55;
          --v61;
        }
        while (v61);
      }
    }
    else
    {
      uint64_t v62 = v88;
      if (a10 == 4)
      {
        uint32_t v54 = v87;
        int v69 = v86;
        uint64_t v70 = v93;
        if (v89)
        {
          unsigned int v71 = 0;
          size_t v72 = 4 * v84;
          uint64_t v73 = &v85[8 * v92];
          vImagePixelCount v74 = v92;
          uint64_t v75 = v89;
          do
          {
            memcpy(v73, (const void *)(v62 + v71), v72);
            vImageConvolve_ARGB8888(&src, &dest, 0, v74, 0, v70, 1u, v54, 0x4000, 0, 0x14u);
            dest.datdouble a = (char *)dest.data + rowBytes;
            v71 += v69;
            --v75;
          }
          while (v75);
        }
      }
      else
      {
        uint32_t v54 = v87;
        int v63 = v86;
        if (a10 == 16 && v89)
        {
          unsigned int v64 = 0;
          size_t v65 = 16 * v84;
          int32x4_t v66 = &v85[32 * v92];
          vImagePixelCount v67 = v92;
          uint64_t v68 = v89;
          do
          {
            memcpy(v66, (const void *)(v62 + v64), v65);
            vImageConvolve_ARGBFFFF(&src, &dest, 0, v67, 0, v94, 1u, v54, 0, 0x14u);
            dest.datdouble a = (char *)dest.data + rowBytes;
            v64 += v63;
            --v68;
          }
          while (v68);
        }
      }
    }
    long long v76 = (void *)v80;
    src.datdouble a = (void *)v80;
    src.CGFloat height = v79;
    src.CGFloat width = v96;
    src.rowuint64_t Bytes = rowBytes;
    dest.datdouble a = v90;
    dest.CGFloat height = v79;
    dest.CGFloat width = v96;
    dest.rowuint64_t Bytes = v91;
    if (v81 == 1)
    {
      vImageConvolve_Planar8(&src, &dest, 0, 0, 0, v93, v54, 1u, 0x4000, 0, 4u);
      double v77 = v82;
      uint64_t v78 = v85;
    }
    else
    {
      double v77 = v82;
      uint64_t v78 = v85;
      if (v81 == 16)
      {
        vImageConvolve_ARGBFFFF(&src, &dest, 0, 0, 0, v94, v54, 1u, 0, 4u);
      }
      else if (v81 == 4)
      {
        vImageConvolve_ARGB8888(&src, &dest, 0, 0, 0, v93, v54, 1u, 0x4000, 0, 4u);
      }
    }
    free(v78);
    free(v76);
    if (v19 != v77) {
      free(v19);
    }
    return 1;
  }
}

void *RIPLayerMask(void *result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v9 = (uint64_t)result;
    if (*a2 && result != 0)
    {
      if (*result)
      {
        unsigned int v11 = (void *)result[4];
        if (v11 == (void *)a2[4])
        {
          uint64_t result = (void *)RIPGetDepthForLayerFormat(0, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
          if (v11 == result)
          {
            return (void *)ripl_Combine(v9, (uint64_t)a2, -2);
          }
        }
      }
    }
  }
  return result;
}

uint64_t CGFontDBPurgeFont(uint64_t result, const void *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (pthread_mutex_t *)(result + 32);
    pthread_mutex_lock((pthread_mutex_t *)(result + 32));
    purge_font_locked(v3, a2);
    return pthread_mutex_unlock(v4);
  }
  return result;
}

void purge_font_locked(uint64_t a1, const void *a2)
{
  v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 8));
  MEMORY[0x1F4188790](Count, v5);
  uint64_t v8 = (const void **)((char *)&v24[-2] - v6 - 7);
  if (v7 <= 0x1FFFFFFFFFFFFFFELL) {
    uint64_t v9 = (const void **)((char *)&v24[-2] - v6 - 7);
  }
  else {
    uint64_t v9 = 0;
  }
  if (v7 - 0x1FFFFFFFFFFFFFFFLL >= 0xE00000000000007ALL) {
    uint64_t v9 = (const void **)malloc_type_malloc(16 * Count, 0x281D7EBEuLL);
  }
  if (!v9) {
    return;
  }
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 8), v9, &v9[Count]);
  if (!a2)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, Count, 0, 0);
    if (Count < 1)
    {
LABEL_27:
      CFRelease(Mutable);
      goto LABEL_33;
    }
    char v15 = 0;
    size_t v16 = &v9[Count];
    while (1)
    {
      CFIndex v17 = CFGetRetainCount(v16[(void)v15]);
      if (v17 == 2) {
        break;
      }
      if (v17 == 1)
      {
        unsigned int v18 = *(__CFDictionary **)(a1 + 8);
        unsigned int v19 = v9[(void)v15];
LABEL_23:
        CFDictionaryRemoveValue(v18, v19);
      }
LABEL_24:
      char v15 = (char *)v15 + 1;
      if ((const void *)Count == v15) {
        goto LABEL_27;
      }
    }
    if (!CFDictionaryContainsKey(Mutable, v16[(void)v15]))
    {
      CFDictionarySetValue(Mutable, v16[(void)v15], v15);
      goto LABEL_24;
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 8), v9[(void)v15]);
    CFDataRef Value = CFDictionaryGetValue(Mutable, v16[(void)v15]);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 8), v9[(void)Value]);
    unsigned int v19 = v16[(void)v15];
    unsigned int v18 = Mutable;
    goto LABEL_23;
  }
  CFIndex v10 = CFGetRetainCount(a2);
  if (v10 > 2 || Count < 1) {
    goto LABEL_33;
  }
  CFIndex v11 = v10;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  while (*(&v9[Count] + v12) != a2)
  {
LABEL_14:
    if (Count == ++v12) {
      goto LABEL_29;
    }
  }
  v24[v13] = v12;
  if (v13 != 1)
  {
    uint64_t v13 = 1;
    goto LABEL_14;
  }
  uint64_t v13 = 2;
LABEL_29:
  if (v10 == v13 && v13 >= 1)
  {
    double v21 = v24;
    do
    {
      uint64_t v22 = *v21++;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 8), v9[v22]);
      --v11;
    }
    while (v11);
  }
LABEL_33:
  if (v9 != v8) {
    free(v9);
  }
}

uint64_t CGImageNotificationCenter()
{
  if (get_notification_center_onceToken != -1) {
    dispatch_once(&get_notification_center_onceToken, &__block_literal_global_368);
  }
  return get_notification_center_image_notification_center;
}

void __show_log_block_invoke()
{
  if (show_log_show_log) {
    BOOL v0 = 1;
  }
  else {
    BOOL v0 = getenv("CG_TRANSFORM_SHOW_REF_COUNT_BACKTRACE") != 0;
  }
  show_log_show_log = v0;
}

void __CGLibraryLoadColorSyncDYLD_block_invoke()
{
  CGLibraryLoadColorSyncDYLD_handle = (uint64_t)dlopen("/System/Library/PrivateFrameworks/ColorSync.framework/ColorSync", 5);
  if (!CGLibraryLoadColorSyncDYLD_handle) {
    CGPostError((uint64_t)"Failed to load %s", v0, v1, v2, v3, v4, v5, v6, (char)"/System/Library/PrivateFrameworks/ColorSync.framework/ColorSync");
  }
}

unint64_t CGSFillDRAM64(unint64_t result, int a2, unsigned int a3, int a4, uint64_t a5, int a6, int a7, int a8, int a9, int a10)
{
  if ((int)a3 >= 1 && a4 >= 1)
  {
    int v10 = a10;
    uint64_t v11 = a7 - 1;
    if (a10 < 0) {
      int v10 = a10 % a8 + a8;
    }
    if (v10 > a8) {
      v10 %= a8;
    }
    int v12 = v11 & a9;
    uint64_t v13 = (int)(a2 - a3);
    if (a3 < 0x40 || (a7 & 3) != 0)
    {
      char v94 = a7 | a3;
      unint64_t v95 = (unint64_t)a3 >> 1;
      unint64_t v96 = (unint64_t)a3 >> 4;
      if (v95 <= 1) {
        unint64_t v95 = 1;
      }
      if (v96 <= 1) {
        unint64_t v96 = 1;
      }
      do
      {
        uint64_t v97 = a5 + v10 * (uint64_t)a6;
        if ((((result | v94) | (v97 + v12)) & 3) != 0)
        {
          if (((result | v94) | (v97 + v12)))
          {
            uint64_t v102 = a3;
            int v103 = v11 & a9;
            do
            {
              char v104 = *(unsigned char *)(v97 + v103);
              int v103 = (v103 + 1) & v11;
              *(unsigned char *)result++ = v104;
              --v102;
            }
            while (v102);
          }
          else if (a3 >= 2)
          {
            unint64_t v98 = v95;
            int v99 = v11 & a9;
            do
            {
              __int16 v100 = *(_WORD *)(v97 + v99);
              int v99 = (v99 + 2) & v11;
              *(_WORD *)uint64_t result = v100;
              result += 2;
              --v98;
            }
            while (v98);
          }
        }
        else
        {
          if (a3 >= 0x10)
          {
            unint64_t v105 = v96;
            int v101 = v11 & a9;
            do
            {
              int v106 = *(_DWORD *)(v97 + v101);
              uint64_t v107 = (v101 + 4) & v11;
              int v108 = *(_DWORD *)(v97 + v107);
              uint64_t v109 = ((int)v107 + 4) & (int)v11;
              *(_DWORD *)uint64_t result = v106;
              *(_DWORD *)(result + 4) = v108;
              int v110 = *(_DWORD *)(v97 + v109);
              uint64_t v111 = ((int)v109 + 4) & (int)v11;
              int v112 = *(_DWORD *)(v97 + v111);
              int v101 = (v111 + 4) & v11;
              *(_DWORD *)(result + 8) = v110;
              *(_DWORD *)(result + 12) = v112;
              result += 16;
              --v105;
            }
            while (v105);
          }
          else
          {
            int v101 = v11 & a9;
          }
          if ((((unint64_t)a3 >> 2) & 3) != 0)
          {
            unint64_t v113 = ((unint64_t)a3 >> 2) & 3;
            do
            {
              int v114 = *(_DWORD *)(v97 + v101);
              int v101 = (v101 + 4) & v11;
              *(_DWORD *)uint64_t result = v114;
              result += 4;
              --v113;
            }
            while (v113);
          }
        }
        int v115 = v10 + 1;
        result += v13;
        if (v115 >= a8) {
          int v116 = a8;
        }
        else {
          int v116 = 0;
        }
        int v10 = v115 - v116;
        BOOL v93 = __OFSUB__(a4--, 1);
      }
      while (!((a4 < 0) ^ v93 | (a4 == 0)));
    }
    else
    {
      uint64_t v14 = a3;
      uint64_t v15 = v12;
      uint64_t v16 = (int)v11;
      uint64_t v117 = a3 + 64;
      uint64_t v118 = v15;
      do
      {
        uint64_t v17 = a5 + v10 * (uint64_t)a6;
        unint64_t v18 = (v118 - result) & v16;
        unsigned int v19 = *(_DWORD *)(v17 + (v18 & 0xFFFFFFFFFFFFFFFCLL));
        unsigned int v20 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 4) & v16));
        unsigned int v21 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 8) & v16));
        unsigned int v22 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 12) & v16));
        unsigned int v23 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 16) & v16));
        unsigned int v24 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 20) & v16));
        unsigned int v25 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 24) & v16));
        unsigned int v26 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 28) & v16));
        unsigned int v27 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 32) & v16));
        unsigned int v28 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 36) & v16));
        unsigned int v29 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 40) & v16));
        unsigned int v30 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 44) & v16));
        unsigned int v31 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 48) & v16));
        unsigned int v32 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 52) & v16));
        unsigned int v33 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 56) & v16));
        unsigned int v34 = *(_DWORD *)(v17 + (((v18 & 0xFFFFFFFFFFFFFFFCLL) + 60) & v16));
        unint64_t v35 = v18 & 3;
        switch(v35)
        {
          case 3uLL:
            HIDWORD(v54) = v31;
            LODWORD(v54) = v31;
            int v53 = v54 >> 24;
            HIDWORD(v54) = v32;
            LODWORD(v54) = v32;
            int v55 = v54 >> 24;
            HIDWORD(v54) = v33;
            LODWORD(v54) = v33;
            int v56 = v54 >> 24;
            HIDWORD(v54) = v34;
            LODWORD(v54) = v34;
            int v57 = v54 >> 24;
            HIDWORD(v54) = v19;
            LODWORD(v54) = v19;
            int v58 = v54 >> 24;
            HIDWORD(v54) = v20;
            LODWORD(v54) = v20;
            int v59 = v54 >> 24;
            HIDWORD(v54) = v21;
            LODWORD(v54) = v21;
            int v60 = v54 >> 24;
            HIDWORD(v54) = v22;
            LODWORD(v54) = v22;
            int v61 = v54 >> 24;
            HIDWORD(v54) = v23;
            LODWORD(v54) = v23;
            int v62 = v54 >> 24;
            HIDWORD(v54) = v24;
            LODWORD(v54) = v24;
            int v63 = v54 >> 24;
            HIDWORD(v54) = v25;
            LODWORD(v54) = v25;
            int v64 = v54 >> 24;
            HIDWORD(v54) = v26;
            LODWORD(v54) = v26;
            int v65 = v54 >> 24;
            HIDWORD(v54) = v27;
            LODWORD(v54) = v27;
            int v66 = v54 >> 24;
            HIDWORD(v54) = v28;
            LODWORD(v54) = v28;
            int v67 = v54 >> 24;
            HIDWORD(v54) = v29;
            LODWORD(v54) = v29;
            int v68 = v54 >> 24;
            HIDWORD(v54) = v30;
            LODWORD(v54) = v30;
            unsigned int v30 = v53 & 0xFFFFFF80 | HIBYTE(v30) & 0x7F;
            unsigned int v29 = (v54 >> 24) & 0xFFFFFF80 | v68 & 0x7F;
            unsigned int v28 = v68 & 0xFFFFFF80 | v67 & 0x7F;
            unsigned int v27 = v67 & 0xFFFFFF80 | v66 & 0x7F;
            unsigned int v26 = v66 & 0xFFFFFF80 | v65 & 0x7F;
            unsigned int v25 = v65 & 0xFFFFFF80 | v64 & 0x7F;
            unsigned int v24 = v64 & 0xFFFFFF80 | v63 & 0x7F;
            unsigned int v23 = v63 & 0xFFFFFF80 | v62 & 0x7F;
            unsigned int v22 = v62 & 0xFFFFFF80 | v61 & 0x7F;
            unsigned int v21 = v61 & 0xFFFFFF80 | v60 & 0x7F;
            unsigned int v20 = v60 & 0xFFFFFF80 | v59 & 0x7F;
            unsigned int v19 = v59 & 0xFFFFFF80 | v58 & 0x7F;
            unsigned int v34 = v58 & 0xFFFFFF80 | v57 & 0x7F;
            unsigned int v33 = v57 & 0xFFFFFF80 | v56 & 0x7F;
            unsigned int v32 = v56 & 0xFFFFFF80 | v55 & 0x7F;
            unsigned int v31 = v55 & 0xFFFFFF80 | v53 & 0x7F;
            break;
          case 2uLL:
            HIDWORD(v70) = v31;
            LODWORD(v70) = v31;
            int v69 = v70 >> 16;
            HIDWORD(v70) = v32;
            LODWORD(v70) = v32;
            int v71 = v70 >> 16;
            HIDWORD(v70) = v33;
            LODWORD(v70) = v33;
            int v72 = v70 >> 16;
            HIDWORD(v70) = v34;
            LODWORD(v70) = v34;
            int v73 = v70 >> 16;
            HIDWORD(v70) = v19;
            LODWORD(v70) = v19;
            int v74 = v70 >> 16;
            HIDWORD(v70) = v20;
            LODWORD(v70) = v20;
            int v75 = v70 >> 16;
            HIDWORD(v70) = v21;
            LODWORD(v70) = v21;
            int v76 = v70 >> 16;
            HIDWORD(v70) = v22;
            LODWORD(v70) = v22;
            int v77 = v70 >> 16;
            HIDWORD(v70) = v23;
            LODWORD(v70) = v23;
            int v78 = v70 >> 16;
            HIDWORD(v70) = v24;
            LODWORD(v70) = v24;
            int v79 = v70 >> 16;
            HIDWORD(v70) = v25;
            LODWORD(v70) = v25;
            int v80 = v70 >> 16;
            HIDWORD(v70) = v26;
            LODWORD(v70) = v26;
            int v81 = v70 >> 16;
            HIDWORD(v70) = v27;
            LODWORD(v70) = v27;
            int v82 = v70 >> 16;
            HIDWORD(v70) = v28;
            LODWORD(v70) = v28;
            int v83 = v70 >> 16;
            HIDWORD(v70) = v29;
            LODWORD(v70) = v29;
            int v84 = v70 >> 16;
            HIDWORD(v70) = v30;
            LODWORD(v70) = v30;
            unsigned int v30 = v69 & 0xFFFF8000 | HIWORD(v30) & 0x7FFF;
            unsigned int v29 = (v70 >> 16) & 0xFFFF8000 | v84 & 0x7FFF;
            unsigned int v28 = v84 & 0xFFFF8000 | v83 & 0x7FFF;
            unsigned int v27 = v83 & 0xFFFF8000 | v82 & 0x7FFF;
            unsigned int v26 = v82 & 0xFFFF8000 | v81 & 0x7FFF;
            unsigned int v25 = v81 & 0xFFFF8000 | v80 & 0x7FFF;
            unsigned int v24 = v80 & 0xFFFF8000 | v79 & 0x7FFF;
            unsigned int v23 = v79 & 0xFFFF8000 | v78 & 0x7FFF;
            unsigned int v22 = v78 & 0xFFFF8000 | v77 & 0x7FFF;
            unsigned int v21 = v77 & 0xFFFF8000 | v76 & 0x7FFF;
            unsigned int v20 = v76 & 0xFFFF8000 | v75 & 0x7FFF;
            unsigned int v19 = v75 & 0xFFFF8000 | v74 & 0x7FFF;
            unsigned int v34 = v74 & 0xFFFF8000 | v73 & 0x7FFF;
            unsigned int v33 = v73 & 0xFFFF8000 | v72 & 0x7FFF;
            unsigned int v32 = v72 & 0xFFFF8000 | v71 & 0x7FFF;
            unsigned int v31 = v71 & 0xFFFF8000 | v69 & 0x7FFF;
            break;
          case 1uLL:
            HIDWORD(v37) = v31;
            LODWORD(v37) = v31;
            int v36 = v37 >> 8;
            HIDWORD(v37) = v32;
            LODWORD(v37) = v32;
            int v38 = v37 >> 8;
            HIDWORD(v37) = v33;
            LODWORD(v37) = v33;
            int v39 = v37 >> 8;
            HIDWORD(v37) = v34;
            LODWORD(v37) = v34;
            int v40 = v37 >> 8;
            HIDWORD(v37) = v19;
            LODWORD(v37) = v19;
            int v41 = v37 >> 8;
            HIDWORD(v37) = v20;
            LODWORD(v37) = v20;
            int v42 = v37 >> 8;
            HIDWORD(v37) = v21;
            LODWORD(v37) = v21;
            int v43 = v37 >> 8;
            HIDWORD(v37) = v22;
            LODWORD(v37) = v22;
            int v44 = v37 >> 8;
            HIDWORD(v37) = v23;
            LODWORD(v37) = v23;
            int v45 = v37 >> 8;
            HIDWORD(v37) = v24;
            LODWORD(v37) = v24;
            int v46 = v37 >> 8;
            HIDWORD(v37) = v25;
            LODWORD(v37) = v25;
            int v47 = v37 >> 8;
            HIDWORD(v37) = v26;
            LODWORD(v37) = v26;
            int v48 = v37 >> 8;
            HIDWORD(v37) = v27;
            LODWORD(v37) = v27;
            int v49 = v37 >> 8;
            HIDWORD(v37) = v28;
            LODWORD(v37) = v28;
            int v50 = v37 >> 8;
            HIDWORD(v37) = v29;
            LODWORD(v37) = v29;
            int v51 = v37 >> 8;
            HIDWORD(v37) = v30;
            LODWORD(v37) = v30;
            int v52 = v37 >> 8;
            unsigned int v30 = v36 & 0xFF800000 | v52 & 0x7FFFFF;
            unsigned int v29 = v52 & 0xFF800000 | v51 & 0x7FFFFF;
            unsigned int v28 = v51 & 0xFF800000 | v50 & 0x7FFFFF;
            unsigned int v27 = v50 & 0xFF800000 | v49 & 0x7FFFFF;
            unsigned int v26 = v49 & 0xFF800000 | v48 & 0x7FFFFF;
            unsigned int v25 = v48 & 0xFF800000 | v47 & 0x7FFFFF;
            unsigned int v24 = v47 & 0xFF800000 | v46 & 0x7FFFFF;
            unsigned int v23 = v46 & 0xFF800000 | v45 & 0x7FFFFF;
            unsigned int v22 = v45 & 0xFF800000 | v44 & 0x7FFFFF;
            unsigned int v21 = v44 & 0xFF800000 | v43 & 0x7FFFFF;
            unsigned int v20 = v43 & 0xFF800000 | v42 & 0x7FFFFF;
            unsigned int v19 = v42 & 0xFF800000 | v41 & 0x7FFFFF;
            unsigned int v34 = v41 & 0xFF800000 | v40 & 0x7FFFFF;
            unsigned int v33 = v40 & 0xFF800000 | v39 & 0x7FFFFF;
            unsigned int v32 = v39 & 0xFF800000 | v38 & 0x7FFFFF;
            unsigned int v31 = v38 & 0xFF800000 | v36 & 0x7FFFFF;
            break;
        }
        long long v85 = (unsigned int *)(result & 0xFFFFFFFFFFFFFFC0);
        switch(result & 0x3F)
        {
          case 1uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 1) = BYTE2(v19);
            goto LABEL_19;
          case 2uLL:
LABEL_19:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 2) = v19;
            goto LABEL_21;
          case 3uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 3) = v19;
            goto LABEL_21;
          case 4uLL:
LABEL_21:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 4) = v20;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 8) = v21;
            goto LABEL_29;
          case 5uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 5) = BYTE2(v20);
            goto LABEL_23;
          case 6uLL:
LABEL_23:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 6) = v20;
            goto LABEL_25;
          case 7uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 7) = v20;
            goto LABEL_25;
          case 8uLL:
LABEL_25:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 8) = v21;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0xC) = v22;
            goto LABEL_33;
          case 9uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 9) = BYTE2(v21);
            goto LABEL_27;
          case 0xAuLL:
LABEL_27:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0xA) = v21;
            goto LABEL_29;
          case 0xBuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0xB) = v21;
            goto LABEL_29;
          case 0xCuLL:
LABEL_29:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0xC) = v22;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x10) = v23;
            goto LABEL_37;
          case 0xDuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0xD) = BYTE2(v22);
            goto LABEL_31;
          case 0xEuLL:
LABEL_31:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0xE) = v22;
            goto LABEL_33;
          case 0xFuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0xF) = v22;
            goto LABEL_33;
          case 0x10uLL:
LABEL_33:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x10) = v23;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x14) = v24;
            goto LABEL_45;
          case 0x11uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x11) = BYTE2(v23);
            goto LABEL_35;
          case 0x12uLL:
LABEL_35:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x12) = v23;
            goto LABEL_37;
          case 0x13uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x13) = v23;
            goto LABEL_37;
          case 0x14uLL:
LABEL_37:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x14) = v24;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x18) = v25;
            goto LABEL_38;
          case 0x15uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x15) = BYTE2(v24);
            goto LABEL_43;
          case 0x16uLL:
LABEL_43:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x16) = v24;
            goto LABEL_45;
          case 0x17uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x17) = v24;
            goto LABEL_45;
          case 0x18uLL:
LABEL_45:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x18) = v25;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x1C) = v26;
            goto LABEL_46;
          case 0x19uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x19) = BYTE2(v25);
            goto LABEL_51;
          case 0x1AuLL:
LABEL_51:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x1A) = v25;
            goto LABEL_38;
          case 0x1BuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x1B) = v25;
            goto LABEL_38;
          case 0x1CuLL:
LABEL_38:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x1C) = v26;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x20) = v27;
            goto LABEL_39;
          case 0x1DuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x1D) = BYTE2(v26);
            goto LABEL_54;
          case 0x1EuLL:
LABEL_54:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x1E) = v26;
            goto LABEL_46;
          case 0x1FuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x1F) = v26;
            goto LABEL_46;
          case 0x20uLL:
LABEL_46:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x20) = v27;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x24) = v28;
            goto LABEL_47;
          case 0x21uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x21) = BYTE2(v27);
            goto LABEL_57;
          case 0x22uLL:
LABEL_57:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x22) = v27;
            goto LABEL_39;
          case 0x23uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x23) = v27;
            goto LABEL_39;
          case 0x24uLL:
LABEL_39:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x24) = v28;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x28) = v29;
            goto LABEL_40;
          case 0x25uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x25) = BYTE2(v28);
            goto LABEL_60;
          case 0x26uLL:
LABEL_60:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x26) = v28;
            goto LABEL_47;
          case 0x27uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x27) = v28;
            goto LABEL_47;
          case 0x28uLL:
LABEL_47:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x28) = v29;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x2C) = v30;
            goto LABEL_48;
          case 0x29uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x29) = BYTE2(v29);
            goto LABEL_63;
          case 0x2AuLL:
LABEL_63:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x2A) = v29;
            goto LABEL_40;
          case 0x2BuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x2B) = v29;
            goto LABEL_40;
          case 0x2CuLL:
LABEL_40:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x2C) = v30;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x30) = v31;
            goto LABEL_41;
          case 0x2DuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x2D) = BYTE2(v30);
            goto LABEL_66;
          case 0x2EuLL:
LABEL_66:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x2E) = v30;
            goto LABEL_48;
          case 0x2FuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x2F) = v30;
            goto LABEL_48;
          case 0x30uLL:
LABEL_48:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x30) = v31;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x34) = v32;
            goto LABEL_49;
          case 0x31uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x31) = BYTE2(v31);
            goto LABEL_69;
          case 0x32uLL:
LABEL_69:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x32) = v31;
            goto LABEL_41;
          case 0x33uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x33) = v31;
            goto LABEL_41;
          case 0x34uLL:
LABEL_41:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x34) = v32;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x38) = v33;
            uint64_t v86 = v14;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3C) = v34;
            break;
          case 0x35uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x35) = BYTE2(v32);
            goto LABEL_72;
          case 0x36uLL:
LABEL_72:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x36) = v32;
LABEL_49:
            uint64_t v86 = v14;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x38) = v33;
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3C) = v34;
            break;
          case 0x37uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x37) = v32;
            goto LABEL_74;
          case 0x38uLL:
LABEL_74:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x38) = v33;
            goto LABEL_78;
          case 0x39uLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x39) = BYTE2(v33);
            goto LABEL_76;
          case 0x3AuLL:
LABEL_76:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3A) = v33;
            goto LABEL_78;
          case 0x3BuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3B) = v33;
            goto LABEL_78;
          case 0x3CuLL:
LABEL_78:
            *(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3C) = v34;
            goto LABEL_82;
          case 0x3DuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3D) = BYTE2(v34);
            goto LABEL_80;
          case 0x3EuLL:
LABEL_80:
            *(_WORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3E) = v34;
            goto LABEL_82;
          case 0x3FuLL:
            *(unsigned char *)((result & 0xFFFFFFFFFFFFFFC0) + 0x3F) = v34;
LABEL_82:
            uint64_t v86 = v14;
            break;
          default:
            v85 -= 16;
            uint64_t v86 = v117;
            break;
        }
        unint64_t v87 = v86 + (result | 0xFFFFFFFFFFFFFFC0);
        uint64_t v88 = v85 + 16;
        if (v87 >= 0x40)
        {
          unint64_t v89 = v87 >> 6;
          do
          {
            *uint64_t v88 = v19;
            v88[1] = v20;
            v88[2] = v21;
            v88[3] = v22;
            v88[4] = v23;
            v88[5] = v24;
            v88[6] = v25;
            v88[7] = v26;
            v88[8] = v27;
            v88[9] = v28;
            v88[10] = v29;
            v88[11] = v30;
            v88[12] = v31;
            v88[13] = v32;
            v88[14] = v33;
            v88[15] = v34;
            v88 += 16;
            --v89;
          }
          while (v89);
          long long v85 = v88 - 16;
        }
        unint64_t v90 = v87 & 0x3F;
        switch(v90)
        {
          case 1uLL:
            *(unsigned char *)uint64_t v88 = HIBYTE(v19);
            break;
          case 2uLL:
            goto LABEL_90;
          case 3uLL:
            *((unsigned char *)v85 + 66) = BYTE1(v19);
LABEL_90:
            *(_WORD *)uint64_t v88 = HIWORD(v19);
            break;
          case 4uLL:
            goto LABEL_94;
          case 5uLL:
            *((unsigned char *)v85 + 68) = HIBYTE(v20);
            goto LABEL_94;
          case 6uLL:
            goto LABEL_93;
          case 7uLL:
            *((unsigned char *)v85 + 70) = BYTE1(v20);
LABEL_93:
            *((_WORD *)v85 + 34) = HIWORD(v20);
LABEL_94:
            *uint64_t v88 = v19;
            break;
          case 8uLL:
            goto LABEL_98;
          case 9uLL:
            *((unsigned char *)v85 + 72) = HIBYTE(v21);
            goto LABEL_98;
          case 0xAuLL:
            goto LABEL_97;
          case 0xBuLL:
            *((unsigned char *)v85 + 74) = BYTE1(v21);
LABEL_97:
            *((_WORD *)v85 + 36) = HIWORD(v21);
LABEL_98:
            *uint64_t v88 = v19;
            v85[17] = v20;
            break;
          case 0xCuLL:
            goto LABEL_102;
          case 0xDuLL:
            *((unsigned char *)v85 + 76) = HIBYTE(v22);
            goto LABEL_102;
          case 0xEuLL:
            goto LABEL_101;
          case 0xFuLL:
            *((unsigned char *)v85 + 78) = BYTE1(v22);
LABEL_101:
            *((_WORD *)v85 + 38) = HIWORD(v22);
LABEL_102:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            break;
          case 0x10uLL:
            goto LABEL_106;
          case 0x11uLL:
            *((unsigned char *)v85 + 80) = HIBYTE(v23);
            goto LABEL_106;
          case 0x12uLL:
            goto LABEL_105;
          case 0x13uLL:
            *((unsigned char *)v85 + 82) = BYTE1(v23);
LABEL_105:
            *((_WORD *)v85 + 40) = HIWORD(v23);
LABEL_106:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            break;
          case 0x14uLL:
            goto LABEL_110;
          case 0x15uLL:
            *((unsigned char *)v85 + 84) = HIBYTE(v24);
            goto LABEL_110;
          case 0x16uLL:
            goto LABEL_109;
          case 0x17uLL:
            *((unsigned char *)v85 + 86) = BYTE1(v24);
LABEL_109:
            *((_WORD *)v85 + 42) = HIWORD(v24);
LABEL_110:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            break;
          case 0x18uLL:
            goto LABEL_114;
          case 0x19uLL:
            *((unsigned char *)v85 + 88) = HIBYTE(v25);
            goto LABEL_114;
          case 0x1AuLL:
            goto LABEL_113;
          case 0x1BuLL:
            *((unsigned char *)v85 + 90) = BYTE1(v25);
LABEL_113:
            *((_WORD *)v85 + 44) = HIWORD(v25);
LABEL_114:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            break;
          case 0x1CuLL:
            goto LABEL_118;
          case 0x1DuLL:
            *((unsigned char *)v85 + 92) = HIBYTE(v26);
            goto LABEL_118;
          case 0x1EuLL:
            goto LABEL_117;
          case 0x1FuLL:
            *((unsigned char *)v85 + 94) = BYTE1(v26);
LABEL_117:
            *((_WORD *)v85 + 46) = HIWORD(v26);
LABEL_118:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            break;
          case 0x20uLL:
            goto LABEL_122;
          case 0x21uLL:
            *((unsigned char *)v85 + 96) = HIBYTE(v27);
            goto LABEL_122;
          case 0x22uLL:
            goto LABEL_121;
          case 0x23uLL:
            *((unsigned char *)v85 + 98) = BYTE1(v27);
LABEL_121:
            *((_WORD *)v85 + 48) = HIWORD(v27);
LABEL_122:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            break;
          case 0x24uLL:
            goto LABEL_126;
          case 0x25uLL:
            *((unsigned char *)v85 + 100) = HIBYTE(v28);
            goto LABEL_126;
          case 0x26uLL:
            goto LABEL_125;
          case 0x27uLL:
            *((unsigned char *)v85 + 102) = BYTE1(v28);
LABEL_125:
            *((_WORD *)v85 + 50) = HIWORD(v28);
LABEL_126:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            v85[24] = v27;
            break;
          case 0x28uLL:
            goto LABEL_130;
          case 0x29uLL:
            *((unsigned char *)v85 + 104) = HIBYTE(v29);
            goto LABEL_130;
          case 0x2AuLL:
            goto LABEL_129;
          case 0x2BuLL:
            *((unsigned char *)v85 + 106) = BYTE1(v29);
LABEL_129:
            *((_WORD *)v85 + 52) = HIWORD(v29);
LABEL_130:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            v85[24] = v27;
            v85[25] = v28;
            break;
          case 0x2CuLL:
            goto LABEL_134;
          case 0x2DuLL:
            *((unsigned char *)v85 + 108) = HIBYTE(v30);
            goto LABEL_134;
          case 0x2EuLL:
            goto LABEL_133;
          case 0x2FuLL:
            *((unsigned char *)v85 + 110) = BYTE1(v30);
LABEL_133:
            *((_WORD *)v85 + 54) = HIWORD(v30);
LABEL_134:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            v85[24] = v27;
            v85[25] = v28;
            v85[26] = v29;
            break;
          case 0x30uLL:
            goto LABEL_138;
          case 0x31uLL:
            *((unsigned char *)v85 + 112) = HIBYTE(v31);
            goto LABEL_138;
          case 0x32uLL:
            goto LABEL_137;
          case 0x33uLL:
            *((unsigned char *)v85 + 114) = BYTE1(v31);
LABEL_137:
            *((_WORD *)v85 + 56) = HIWORD(v31);
LABEL_138:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            v85[24] = v27;
            v85[25] = v28;
            v85[26] = v29;
            v85[27] = v30;
            break;
          case 0x34uLL:
            goto LABEL_142;
          case 0x35uLL:
            *((unsigned char *)v85 + 116) = HIBYTE(v32);
            goto LABEL_142;
          case 0x36uLL:
            goto LABEL_141;
          case 0x37uLL:
            *((unsigned char *)v85 + 118) = BYTE1(v32);
LABEL_141:
            *((_WORD *)v85 + 58) = HIWORD(v32);
LABEL_142:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            v85[24] = v27;
            v85[25] = v28;
            v85[26] = v29;
            v85[27] = v30;
            v85[28] = v31;
            break;
          case 0x38uLL:
            goto LABEL_146;
          case 0x39uLL:
            *((unsigned char *)v85 + 120) = HIBYTE(v33);
            goto LABEL_146;
          case 0x3AuLL:
            goto LABEL_145;
          case 0x3BuLL:
            *((unsigned char *)v85 + 122) = BYTE1(v33);
LABEL_145:
            *((_WORD *)v85 + 60) = HIWORD(v33);
LABEL_146:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            v85[24] = v27;
            v85[25] = v28;
            v85[26] = v29;
            v85[27] = v30;
            v85[28] = v31;
            v85[29] = v32;
            break;
          case 0x3CuLL:
            goto LABEL_150;
          case 0x3DuLL:
            *((unsigned char *)v85 + 124) = HIBYTE(v34);
            goto LABEL_150;
          case 0x3EuLL:
            goto LABEL_149;
          case 0x3FuLL:
            *((unsigned char *)v85 + 126) = BYTE1(v34);
LABEL_149:
            *((_WORD *)v85 + 62) = HIWORD(v34);
LABEL_150:
            *uint64_t v88 = v19;
            v85[17] = v20;
            v85[18] = v21;
            v85[19] = v22;
            v85[20] = v23;
            v85[21] = v24;
            v85[22] = v25;
            v85[23] = v26;
            v85[24] = v27;
            v85[25] = v28;
            v85[26] = v29;
            v85[27] = v30;
            v85[28] = v31;
            v85[29] = v32;
            v85[30] = v33;
            break;
          default:
            break;
        }
        int v91 = v10 + 1;
        uint64_t result = (unint64_t)v88 + v90 + v13;
        if (v91 >= a8) {
          int v92 = a8;
        }
        else {
          int v92 = 0;
        }
        int v10 = v91 - v92;
        BOOL v93 = __OFSUB__(a4--, 1);
      }
      while (!((a4 < 0) ^ v93 | (a4 == 0)));
    }
  }
  return result;
}

void __create_default_transform_block_invoke()
{
  uint64_t v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
  create_default_transform_transform = color_transform_create(v0, 0);

  CGColorSpaceRelease(v0);
}

uint64_t __CGRegionGetTypeID_block_invoke()
{
  __kCGRegionCFTypeID TypeID = _CFRuntimeRegisterClass();
  uint64_t result = _CFRuntimeInitStaticInstance();
  qword_1EB288CA8 = (uint64_t)&the_empty_shape;
  return result;
}

void CGContextSetShouldDrawBitmapRuns(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetShouldDrawBitmapRuns(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldDrawBitmapRuns", v8, a3, a4, a5, a6, a7, a8);
}

BOOL path_equal(CGPathRef path1, const CGPath *a2)
{
  if (path1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (path1)
  {
    if (a2) {
      return CGPathEqualToPath(path1, a2);
    }
  }
  return result;
}

BOOL CGPathEqualToPath(CGPathRef path1, CGPathRef path2)
{
  if (path1 == path2) {
    return 1;
  }
  if (!path1) {
    return 0;
  }
  if (CGPathDisableTypeValidation)
  {
    if (!path2) {
      return 0;
    }
  }
  else
  {
    CFTypeID v4 = CFGetTypeID(path1);
    CFTypeID TypeID = CGPathGetTypeID();
    BOOL result = 0;
    if (!path2 || v4 != TypeID) {
      return result;
    }
    if (!CGPathDisableTypeValidation)
    {
      CFTypeID v7 = CFGetTypeID(path2);
      if (v7 != CGPathGetTypeID()) {
        return 0;
      }
    }
  }
  int v8 = *((_DWORD *)path1 + 4);
  if (v8 != *((_DWORD *)path2 + 4)) {
    return 0;
  }
  switch(v8)
  {
    case 1:
      goto LABEL_41;
    case 2:
      if (*((double *)path1 + 9) != *((double *)path2 + 9) || *((double *)path1 + 10) != *((double *)path2 + 10)) {
        return 0;
      }
      goto LABEL_41;
    case 3:
      if (*((double *)path1 + 9) != *((double *)path2 + 9) || *((double *)path1 + 10) != *((double *)path2 + 10)) {
        return 0;
      }
      BOOL result = 0;
      if (*((double *)path1 + 11) != *((double *)path2 + 11)) {
        return result;
      }
      if (*((double *)path1 + 12) != *((double *)path2 + 12)) {
        return result;
      }
      BOOL result = 0;
      if (*((double *)path1 + 13) != *((double *)path2 + 13)) {
        return result;
      }
      if (*((double *)path1 + 14) != *((double *)path2 + 14)) {
        return result;
      }
      BOOL result = 0;
      if (*((double *)path1 + 15) != *((double *)path2 + 15) || *((double *)path1 + 16) != *((double *)path2 + 16)) {
        return result;
      }
      goto LABEL_41;
    case 4:
      if (*((unsigned __int8 *)path1 + 72) != *((unsigned __int8 *)path2 + 72)
        || *((unsigned __int8 *)path1 + 73) != *((unsigned __int8 *)path2 + 73))
      {
        return 0;
      }
      goto LABEL_41;
    case 5:
      if (*((double *)path1 + 3) != *((double *)path2 + 3) || *((double *)path1 + 4) != *((double *)path2 + 4)) {
        return 0;
      }
      return *((double *)path1 + 6) == *((double *)path2 + 6) && *((double *)path1 + 5) == *((double *)path2 + 5);
    case 6:
      if (*((double *)path1 + 9) != *((double *)path2 + 9)) {
        return 0;
      }
LABEL_41:
      if (*((double *)path1 + 3) != *((double *)path2 + 3)) {
        return 0;
      }
      return vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*((float64x2_t *)path1 + 2), *((float64x2_t *)path2 + 2)), (int32x4_t)vceqq_f64(*((float64x2_t *)path1 + 3), *((float64x2_t *)path2 + 3)))), 0xFuLL))) & (*((double *)path1 + 8) == *((double *)path2 + 8));
    case 7:
      uint64_t v12 = *((void *)path1 + 3);
      uint64_t v13 = *((void *)path2 + 3);
      return CGRegionEqualToRegion(v12, v13);
    case 8:
      unint64_t v14 = *((unsigned __int16 *)path1 + 12);
      if (__PAIR64__(*((unsigned __int16 *)path1 + 13), v14) != __PAIR64__(*((unsigned __int16 *)path2 + 13), *((unsigned __int16 *)path2 + 12))|| *((_DWORD *)path1 + 7) != *((_DWORD *)path2 + 7))
      {
        return 0;
      }
      if (!*((_WORD *)path1 + 12)) {
        return 1;
      }
      BOOL result = 0;
      if (*((double *)path1 + 4) != *((double *)path2 + 4) || *((double *)path1 + 5) != *((double *)path2 + 5)) {
        return result;
      }
      unint64_t v15 = 0;
      uint64_t v16 = (double *)((char *)path2 + 56);
      uint64_t v17 = (double *)((char *)path1 + 56);
      break;
    case 9:
      size_t v23 = *((void *)path1 + 4);
      if (v23 != *((void *)path2 + 4)) {
        return 0;
      }
      uint64_t v24 = *((void *)path1 + 3);
      if (v24 != *((void *)path2 + 3)) {
        return 0;
      }
      unsigned int v25 = (char *)*((void *)path1 + 6);
      unsigned int v26 = &v25[*((void *)path1 + 5) - v23];
      unsigned int v27 = (char *)*((void *)path2 + 6);
      if (memcmp(v26, &v27[*((void *)path2 + 5) - v23], v23)) {
        return 0;
      }
      return memcmp(v25, v27, 16 * v24) == 0;
    default:
      return 1;
  }
  while (v14 - 1 != v15)
  {
    double v18 = *(v17 - 1);
    double v19 = *v17;
    double v20 = *(v16 - 1);
    double v21 = *v16;
    v16 += 2;
    v17 += 2;
    ++v15;
    if (v18 != v20 || v19 != v21) {
      return v15 >= v14;
    }
  }
  unint64_t v15 = *((unsigned __int16 *)path1 + 12);
  return v15 >= v14;
}

CGFontRef CGFontCreateWithDataProvider(CGDataProviderRef provider)
{
  return (CGFontRef)CGFontCreateWithDataProviderAndData((uint64_t)provider, 0);
}

void soft_mask_finalize(void *a1)
{
  uint64_t v2 = (const void *)a1[19];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[13];
  if (v3) {
    CFRelease(v3);
  }
  CFTypeID v4 = (const void *)a1[14];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (void (*)(uint64_t))a1[18];
  if (v5)
  {
    uint64_t v6 = a1[15];
    v5(v6);
  }
}

uint64_t pattern_notification_center_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = CGNotificationCenterCreate(a1, a2, a3, a4, a5, a6, a7, a8);
  pattern_notification_center = result;
  return result;
}

uint64_t __get_notification_center_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = CGNotificationCenterCreate(a1, a2, a3, a4, a5, a6, a7, a8);
  get_notification_center_image_notification_center = result;
  return result;
}

uint64_t CGNotificationCenterCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_block_invoke_once != -1) {
    dispatch_once(&_block_invoke_once, &__block_literal_global_9);
  }
  uint64_t Instance = CGTypeCreateInstance(CGNotificationCenterGetTypeID_notification_center_type_id, 72, a3, a4, a5, a6, a7, a8);
  *(void *)(Instance + 80) = 0;
  pthread_mutex_init((pthread_mutex_t *)(Instance + 16), 0);
  return Instance;
}

void CGContextStrokeEllipseInRect(CGContextRef c, CGRect rect)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGFloat height = rect.size.height;
      CGFloat width = rect.size.width;
      CGFloat y = rect.origin.y;
      CGFloat x = rect.origin.x;
      if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
      {
        double v19 = (const void *)*((void *)c + 21);
        if (v19)
        {
          CFRelease(v19);
          *((void *)c + 21) = 0;
        }
        v21.origin.CGFloat x = x;
        v21.origin.CGFloat y = y;
        v21.size.CGFloat width = width;
        v21.size.CGFloat height = height;
        CGContextAddEllipseInRect(c, v21);
        CGContextDrawPath(c, kCGPathStroke);
      }
      return;
    }
    CGContextRef v18 = c;
  }
  else
  {
    CGContextRef v18 = 0;
  }

  handle_invalid_context((char)"CGContextStrokeEllipseInRect", (uint64_t)v18, v2, v3, v4, v5, v6, v7);
}

void CGContextFillEllipseInRect(CGContextRef c, CGRect rect)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGFloat height = rect.size.height;
      CGFloat width = rect.size.width;
      CGFloat y = rect.origin.y;
      CGFloat x = rect.origin.x;
      if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
      {
        double v19 = (const void *)*((void *)c + 21);
        if (v19)
        {
          CFRelease(v19);
          *((void *)c + 21) = 0;
        }
        v21.origin.CGFloat x = x;
        v21.origin.CGFloat y = y;
        v21.size.CGFloat width = width;
        v21.size.CGFloat height = height;
        CGContextAddEllipseInRect(c, v21);
        CGContextDrawPath(c, kCGPathFill);
      }
      return;
    }
    CGContextRef v18 = c;
  }
  else
  {
    CGContextRef v18 = 0;
  }

  handle_invalid_context((char)"CGContextFillEllipseInRect", (uint64_t)v18, v2, v3, v4, v5, v6, v7);
}

void CGContextAddEllipseInRect(CGContextRef c, CGRect rect)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
      {
        uint64_t v14 = *((void *)c + 12);
        unint64_t v15 = (CGPath *)*((void *)c + 21);
        if (v15)
        {
          CGPathAddEllipseInRect(v15, (const CGAffineTransform *)(v14 + 24), rect);
        }
        else
        {
          *((void *)c + 21) = CGPathCreateWithEllipseInRect(rect, (const CGAffineTransform *)(v14 + 24));
        }
      }
      return;
    }
    CGContextRef v16 = c;
  }
  else
  {
    CGContextRef v16 = 0;
  }

  handle_invalid_context((char)"CGContextAddEllipseInRect", (uint64_t)v16, v2, v3, v4, v5, v6, v7);
}

uint64_t *__color_space_state_create_sRGB_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (uint64_t result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncSRGBProfile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_sRGB_s = v1;
  return result;
}

uint64_t *__color_space_state_create_extended_srgb_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (uint64_t result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncSRGBProfile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_extended_srgb_s = v1;
  return result;
}

void sub_184C9D3B8(void *a1@<X0>, uint64_t a2@<X8>)
{
  double v4 = sub_184CD2CA0(a1);
  if (!v2)
  {
    *(double *)a2 = v4;
    *(void *)(a2 + 8) = v5;
  }
}

unint64_t sub_184C9D3E4()
{
  unint64_t result = qword_1E8F8B548;
  if (!qword_1E8F8B548)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F8B548);
  }
  return result;
}

const CGFloat *CGColorRef.components.getter()
{
  unint64_t result = CGColorGetComponents(v0);
  if (result)
  {
    uint64_t v2 = result;
    size_t NumberOfComponents = CGColorGetNumberOfComponents(v0);
    return (const CGFloat *)sub_184C9D670(v2, NumberOfComponents);
  }
  return result;
}

size_t CGColorGetNumberOfComponents(size_t color)
{
  if (color)
  {
    if ((color & 0x8000000000000000) != 0) {
      return CGTaggedColorGetNumberOfComponents(color, v1, v2, v3, v4, v5, v6, v7);
    }
    else {
      return *(void *)(color + 56);
    }
  }
  return color;
}

uint64_t __swift_mutable_project_boxed_opaque_existential_1(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0)
  {
    swift_makeBoxUnique();
    return v2;
  }
  return result;
}

uint64_t __swift_destroy_boxed_opaque_existential_1(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }
  return result;
}

void *__swift_project_boxed_opaque_existential_1(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80)));
  return result;
}

void CGPathAddRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
  if (path)
  {
    CGFloat height = rect.size.height;
    CGFloat width = rect.size.width;
    CGFloat y = rect.origin.y;
    CGFloat x = rect.origin.x;
    if (CGPathDisableTypeValidation || (CFTypeID v15 = CFGetTypeID(path), v15 == CGPathGetTypeID()))
    {
      {
        v17.origin.CGFloat x = x;
        v17.origin.CGFloat y = y;
        v17.size.CGFloat width = width;
        v17.size.CGFloat height = height;
        CGRect v16 = CGRectStandardize(v17);
        CG::Path::append_rect((uint64_t)path + 16, &v16, (float64x2_t *)m);
      }
    }
  }
}

void *sub_184C9D670(const void *a1, uint64_t a2)
{
  if (!a2) {
    return (void *)MEMORY[0x1E4FBC860];
  }
  if (a2 <= 0)
  {
    size_t v4 = 8 * a2;
    uint64_t v5 = (void *)MEMORY[0x1E4FBC860];
  }
  else
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_1EB288AF0);
    size_t v4 = 8 * a2;
    uint64_t v5 = (void *)swift_allocObject();
    int64_t v6 = _swift_stdlib_malloc_size(v5);
    uint64_t v7 = v6 - 32;
    if (v6 < 32) {
      uint64_t v7 = v6 - 25;
    }
    v5[2] = a2;
    v5[3] = 2 * (v7 >> 3);
  }
  memcpy(v5 + 4, a1, v4);
  return v5;
}

uint64_t pathCreateCopyByClippingWithPath(int a1, CGPathRef path, int a3, const CGPath *a4, int a5)
{
  if (path)
  {
    if (CGPathDisableTypeValidation)
    {
      if (!a4) {
        return 0;
      }
LABEL_9:
      memset(v16, 0, sizeof(v16));
      memset(v15, 0, sizeof(v15));
      memset(v14, 0, sizeof(v14));
      clip<std::vector<std::vector<ClipperLib::IntPoint>>>(v14, a1, path, a3, a4, a5, 1, (CGPathRandomAccess *)v16, (uint64_t)v15);
    }
    CFTypeID v10 = CFGetTypeID(path);
    CFTypeID TypeID = CGPathGetTypeID();
    if (a4)
    {
      if (v10 == TypeID)
      {
        if (CGPathDisableTypeValidation) {
          goto LABEL_9;
        }
        CFTypeID v12 = CFGetTypeID(a4);
        if (v12 == CGPathGetTypeID()) {
          goto LABEL_9;
        }
      }
    }
  }
  return 0;
}

void sub_184C9D850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  a17 = (void **)&a23;
  std::vector<std::vector<ClipperLib::IntPoint>>::__destroy_vector::operator()[abi:fe180100](&a17);
  a17 = (void **)(v23 - 88);
  std::vector<CGPathRandomAccessSubpath>::__destroy_vector::operator()[abi:fe180100](&a17);
  _Unwind_Resume(a1);
}

CFTypeRef CGPathRandomAccess::new_cgpath_from_clipper(void *a1, uint64_t **a2, __n128 *a3)
{
  memset(&v18, 0, sizeof(v18));
  __n128 v6 = a3[1];
  *(__n128 *)&v17.double a = *a3;
  *(__n128 *)&v17.double c = v6;
  *(__n128 *)&v17.tCGFloat x = a3[2];
  CGAffineTransformInvert(&v18, &v17);
  CFTypeRef cf = CGPathCreateMutable();
  long long v16 = cgpoint_null;
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  while (v7 != v8)
  {
    __n128 v9 = a3[1];
    v14[0] = *a3;
    v14[1] = v9;
    _OWORD v14[2] = a3[2];
    v13[0] = *(float64x2_t *)&v18.a;
    v13[1] = *(float64x2_t *)&v18.c;
    unint64_t v13[2] = *(float64x2_t *)&v18.tx;
    CGPathRandomAccess::recreate_path_from_clipper(a1, v7, v14, v13, (CGPathOutputFiltering *)&cf, 0);
    v7 += 3;
  }
  CFTypeRef v10 = CGPathOutputFiltering::cg_path((CGPathOutputFiltering *)&cf);
  CFTypeRef v11 = v10;
  if (v10) {
    CFRetain(v10);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v11;
}

void sub_184C9D97C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void CGPathRandomAccess::recreate_path_from_clipper(void *a1, uint64_t *a2, __n128 *a3, float64x2_t *a4, CGPathOutputFiltering *a5, char a6)
{
  CFTypeRef v11 = a1;
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  unint64_t v14 = (v13 - *a2) / 48;
  if (v13 != *a2)
  {
    unint64_t v15 = 0;
    if (v14 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = (v13 - *a2) / 48;
    }
    do
    {
      char v17 = 0;
      uint64_t v18 = v12 + 48 * v15 + 16;
      do
      {
        if (*(void *)v18 != -1)
        {
          if ((v17 & 1) != 0 || *(double *)(v18 + 8) - (double)(uint64_t)*(double *)(v18 + 8) == 0.0) {
            goto LABEL_13;
          }
          char v17 = 1;
        }
        v18 += 16;
      }
      while (v18 != v12 + 48 + 48 * v15);
      ++v15;
    }
    while (v15 != v16);
  }
  unint64_t v15 = 0;
LABEL_13:
  memset((char *)v99 + 8, 0, 32);
  CGPathRandomAccess::state_at_point((uint64_t)v99, a1, v12, v13, v15, 0.0);
  *(double *)int v99 = (double)v15;
  uint64_t v19 = *a2;
  uint64_t v20 = a2[1];
  unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v20 - *a2) >> 4);
  if (v15) {
    unint64_t v21 = v15;
  }
  unint64_t v98 = 0;
  long long v96 = 0u;
  long long v97 = 0u;
  CGPathRandomAccess::state_at_point((uint64_t)&v96, v11, v19, v20, v21 - 1, 0.0);
  uint64_t v22 = *a2;
  unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4);
  char v90 = a6;
  if (*(void *)&v99[1] == -1) {
    goto LABEL_19;
  }
  if (v23 <= v15) {
    goto LABEL_91;
  }
  if (*(void *)(v22 + 48 * v15 + 16) != -1 && *(void *)(v22 + 48 * v15 + 32) != -1)
  {
LABEL_19:
    if (v23 > v15)
    {
      float64x2_t v24 = vaddq_f64(a4[2], vmlaq_n_f64(vmulq_n_f64(a4[1], (double)*(uint64_t *)(v22 + 48 * v15 + 8)), *a4, (double)*(uint64_t *)(v22 + 48 * v15)));
LABEL_28:
      float64x2_t x = v24;
      goto LABEL_29;
    }
    goto LABEL_91;
  }
  uint64_t v25 = *v11;
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v11[1] - *v11) >> 3)) <= *(void *)&v99[1]) {
    goto LABEL_91;
  }
  uint64_t v26 = *(void *)(v25 + 56 * *(void *)&v99[1]);
  unint64_t v27 = (*(void *)(v25 + 56 * *(void *)&v99[1] + 8) - v26) >> 4;
  double v28 = (double)v27;
  if (*((double *)&v99[1] + 1) < (double)v27) {
    double v28 = 0.0;
  }
  double v29 = *((double *)&v99[1] + 1) - v28;
  double v30 = v29 - (double)(uint64_t)v29;
  unint64_t v31 = (unint64_t)v29;
  if (v30 == 0.0)
  {
    if (v27 > v31)
    {
      unint64_t v32 = *(void *)(v26 + 16 * v31);
      unsigned int v34 = (uint64_t *)(v25 + 56 * *(void *)&v99[1] + 24);
      uint64_t v33 = *v34;
      if (v32 < (v34[1] - *v34) >> 4)
      {
        float64x2_t v24 = *(float64x2_t *)(v33 + 16 * v32);
        goto LABEL_28;
      }
    }
LABEL_91:
    __break(1u);
    return;
  }
  if (v27 <= v31) {
    goto LABEL_91;
  }
  uint64_t v78 = v26 + 16 * v31;
  if (*(unsigned char *)(v78 + 8))
  {
    int v80 = (uint64_t *)(v25 + 56 * *(void *)&v99[1] + 24);
    uint64_t v79 = *v80;
    if (*(void *)v78 >= (unint64_t)((v80[1] - *v80) >> 4)) {
      goto LABEL_91;
    }
    int v81 = (float64x2_t *)(v79 + 16 * *(void *)v78);
    __asm { FMOV            V4.2D, #3.0 }
    float64x2_t x = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmulq_n_f64(vmulq_n_f64(vmulq_f64(v81[1], _Q4), v30), 1.0 - v30), 1.0 - v30), vmulq_n_f64(vmulq_n_f64(*v81, 1.0 - v30), 1.0 - v30), 1.0 - v30), vmulq_n_f64(vmulq_n_f64(vmulq_f64(v81[2], _Q4), v30), v30), 1.0 - v30), vmulq_n_f64(vmulq_n_f64(v81[3], v30), v30), v30);
  }
  else
  {
    unint64_t v86 = *(void *)v78;
    uint64_t v87 = *(void *)(v25 + 56 * *(void *)&v99[1] + 24);
    unint64_t v88 = (*(void *)(v25 + 56 * *(void *)&v99[1] + 32) - v87) >> 4;
    if (v88 <= v86) {
      goto LABEL_91;
    }
    if (v86 + 1 == v88) {
      unint64_t v89 = 0;
    }
    else {
      unint64_t v89 = v86 + 1;
    }
    float64x2_t x = vmlaq_n_f64(*(float64x2_t *)(v87 + 16 * v86), vsubq_f64(*(float64x2_t *)(v87 + 16 * v89), *(float64x2_t *)(v87 + 16 * v86)), v30);
  }
LABEL_29:
  CGPathOutputFiltering::commit_pending_line_point_if_needed(a5);
  CGPathMoveToPoint(*(CGMutablePathRef *)a5, 0, x.f64[0], x.f64[1]);
  unint64_t v35 = v14 + v15;
  unint64_t v36 = v14 + v15 + 1;
  unint64_t v37 = v15 + 1;
  if (v37 < v36)
  {
    unint64_t v91 = v14;
    int v92 = v11;
    do
    {
      memset(&v95[8], 0, 32);
      CGPathRandomAccess::state_at_point((uint64_t)v95, v11, *a2, a2[1], v37, 0.0);
      *(void *)unint64_t v95 = *(void *)&v99[0];
      unint64_t v39 = v37 % v14;
      uint64_t v40 = *a2;
      if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4) <= v37 % v14) {
        goto LABEL_91;
      }
      if (v95[8] != BYTE8(v99[0])
        || v37 == v35
        || *(void *)&v95[16] == -1
        || *(void *)&v95[16] != *(void *)&v99[1]
        || (uint64_t v41 = *(void *)(v40 + 48 * v39 + 32), v41 != -1)
        && (*(void *)(v40 + 48 * v39 + 16) != v41
         || *(double *)(v40 + 48 * v39 + 24) != *(double *)(v40 + 48 * v39 + 40)))
      {
        int v42 = (uint64_t *)(v40 + 48 * v39);
        _ZF = *(double *)v99 + 1.0 == (double)v37 || *(void *)&v99[1] == -1;
        if (_ZF)
        {
          if (v37 != v35)
          {
            double v44 = (double)*v42;
            double v45 = (double)*(uint64_t *)(v40 + 48 * v39 + 8);
            double v46 = a4[2].f64[0] + a4[1].f64[0] * v45 + a4->f64[0] * v44;
            double v47 = a4[2].f64[1] + a4[1].f64[1] * v45 + a4->f64[1] * v44;
            __n128 v48 = a3[1];
            *(__n128 *)&v94.double a = *a3;
            *(__n128 *)&v94.double c = v48;
            *(__n128 *)&v94.tfloat64x2_t x = a3[2];
            CGPathOutputFiltering::add_line_to_point(a5, v46, v47, &v94);
          }
        }
        else
        {
          float64x2_t v49 = x;
          if (v37 != v35)
          {
            __n128 v38 = (__n128)vmlaq_n_f64(vmulq_n_f64(a4[1], (double)*(uint64_t *)(v40 + 48 * v39 + 8)), *a4, (double)*v42);
            float64x2_t v49 = vaddq_f64(a4[2], (float64x2_t)v38);
          }
          if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v11[1] - *v11) >> 3)) <= *(void *)&v99[1]) {
            goto LABEL_91;
          }
          v38.n128_u64[0] = v98;
          int v50 = (uint64_t *)(*v11 + 56 * *(void *)&v99[1]);
          __n128 v51 = a3[1];
          *(__n128 *)&v100.double a = *a3;
          *(__n128 *)&v100.double c = v51;
          __n128 v52 = a3[2];
          *(__n128 *)&v100.tfloat64x2_t x = v52;
          if (BYTE8(v99[0]))
          {
            v121[0] = MEMORY[0x1E4F143A8];
            v121[1] = 0x40000000;
            v121[2] = ___ZNK25CGPathRandomAccessSubpath20append_range_to_pathEddbb7CGPoint17CGAffineTransformR21CGPathOutputFiltering_block_invoke;
            v121[3] = &__block_descriptor_tmp_7;
            v121[4] = a5;
            __n128 v53 = a3[1];
            __n128 v122 = *a3;
            __n128 v123 = v53;
            __n128 v124 = a3[2];
            v54.n128_u64[1] = v124.n128_u64[1];
            v120[0] = MEMORY[0x1E4F143A8];
            v120[1] = 0x40000000;
            v120[2] = ___ZNK25CGPathRandomAccessSubpath20append_range_to_pathEddbb7CGPoint17CGAffineTransformR21CGPathOutputFiltering_block_invoke_2;
            v120[3] = &__block_descriptor_tmp_9;
            v120[4] = a5;
            v54.n128_u64[0] = *((void *)&v99[1] + 1);
            CGPathRandomAccessSubpath::append_range_to_path(v50, v37 == v35, 0, (uint64_t)v121, (uint64_t)v120, v54, v38, v49.f64[0], v49.f64[1]);
          }
          else
          {
            int v55 = a4;
            uint64_t v112 = 0;
            unint64_t v113 = &v112;
            uint64_t v114 = 0x4002000000;
            int v115 = __Block_byref_object_copy_;
            int v116 = __Block_byref_object_dispose_;
            uint64_t v118 = 0;
            uint64_t v119 = 0;
            uint64_t v117 = 0;
            uint64_t v104 = 0;
            unint64_t v105 = &v104;
            uint64_t v106 = 0x4002000000;
            uint64_t v107 = __Block_byref_object_copy__10;
            int v108 = __Block_byref_object_dispose__11;
            int v110 = 0;
            uint64_t v111 = 0;
            long long __p = 0;
            v103[0] = MEMORY[0x1E4F143A8];
            v103[1] = 0x40000000;
            v103[2] = ___ZNK25CGPathRandomAccessSubpath20append_range_to_pathEddbb7CGPoint17CGAffineTransformR21CGPathOutputFiltering_block_invoke_12;
            v103[3] = &unk_1E529FD20;
            v103[4] = &v112;
            v103[5] = &v104;
            v102[0] = MEMORY[0x1E4F143A8];
            v102[1] = 0x40000000;
            v102[2] = ___ZNK25CGPathRandomAccessSubpath20append_range_to_pathEddbb7CGPoint17CGAffineTransformR21CGPathOutputFiltering_block_invoke_2_14;
            v102[3] = &unk_1E529FD48;
            v102[4] = &v112;
            v102[5] = &v104;
            v52.n128_u64[0] = v98;
            v38.n128_u64[0] = *((void *)&v99[1] + 1);
            CGPathRandomAccessSubpath::append_range_to_path(v50, v37 == v35, (CGPoint *)1, (uint64_t)v103, (uint64_t)v102, v52, v38, v49.f64[0], v49.f64[1]);
            unint64_t v56 = v113[6];
            int v57 = v56 & 0x3F;
            if (v56 > 0x3F || (v56 & 0x3F) != 0)
            {
              int v58 = (void *)(v113[5] + 8 * (v56 >> 6));
              unint64_t v59 = ((v105[6] - v105[5]) >> 4) - 1;
              do
              {
                if (v57) {
                  uint64_t v60 = 0;
                }
                else {
                  uint64_t v60 = -1;
                }
                v58 += v60;
                if (v57) {
                  --v57;
                }
                else {
                  int v57 = 63;
                }
                if ((*v58 >> v57))
                {
                  uint64_t v61 = v105[5];
                  unint64_t v62 = (v105[6] - v61) >> 4;
                  if (v62 <= v59 - 1 || v62 <= v59 - 2 || v62 <= v59 - 3) {
                    goto LABEL_91;
                  }
                  int v63 = (double *)(v61 + 16 * (v59 - 1));
                  CGFloat v64 = *v63;
                  CGFloat v65 = v63[1];
                  int v66 = (double *)(v61 + 16 * (v59 - 2));
                  CGFloat v67 = *v66;
                  CGFloat v68 = v66[1];
                  int v69 = (double *)(v61 + 16 * (v59 - 3));
                  CGFloat v70 = *v69;
                  CGFloat v71 = v69[1];
                  CGPathOutputFiltering::commit_pending_line_point_if_needed(a5);
                  CGPathAddCurveToPoint(*(CGMutablePathRef *)a5, 0, v64, v65, v67, v68, v70, v71);
                  uint64_t v72 = -4;
                }
                else
                {
                  uint64_t v73 = v105[5];
                  if (v59 >= (v105[6] - v73) >> 4) {
                    goto LABEL_91;
                  }
                  int v74 = (double *)(v73 + 16 * v59);
                  double v75 = *v74;
                  double v76 = v74[1];
                  CGAffineTransform v101 = v100;
                  CGPathOutputFiltering::add_line_to_point(a5, v75, v76, &v101);
                  uint64_t v72 = -1;
                }
                v59 += v72;
              }
              while (v58 != (void *)v113[5] || v57 != 0);
            }
            _Block_object_dispose(&v104, 8);
            a4 = v55;
            if (__p)
            {
              int v110 = __p;
              operator delete(__p);
            }
            _Block_object_dispose(&v112, 8);
            unint64_t v14 = v91;
            CFTypeRef v11 = v92;
            if (v117) {
              operator delete(v117);
            }
          }
        }
        *(double *)unint64_t v95 = (double)v37;
        *(void *)&v99[2] = *(void *)&v95[32];
        v99[0] = *(_OWORD *)v95;
        v99[1] = *(_OWORD *)&v95[16];
      }
      long long v96 = *(_OWORD *)v95;
      long long v97 = *(_OWORD *)&v95[16];
      unint64_t v98 = *(void *)&v95[32];
      _ZF = v37++ == v35;
    }
    while (!_ZF);
  }
  if ((v90 & 1) == 0)
  {
    CGPathOutputFiltering::commit_pending_line_point_if_needed(a5);
    CGPathCloseSubpath(*(CGMutablePathRef *)a5);
  }
}

void sub_184C9E324(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x210], 8);
  uint64_t v2 = (void *)STACK[0x238];
  if (STACK[0x238])
  {
    STACK[0x240] = (unint64_t)v2;
    operator delete(v2);
  }
  _Block_object_dispose(&STACK[0x250], 8);
  if (STACK[0x278]) {
    operator delete((void *)STACK[0x278]);
  }
  _Unwind_Resume(a1);
}

double CGPathRandomAccess::state_at_point(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, double result)
{
  v47[9] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((a4 - a3) >> 4);
  uint64_t v7 = a3 + 48 * (a5 % v6);
  *(void *)(a1 + 16) = -1;
  uint64_t v8 = v7 + 16;
  uint64_t v9 = v7 + 48;
  if (v7 + 16 == v7 + 48) {
    return result;
  }
  unsigned __int8 v10 = 0;
  CFTypeRef v11 = (double *)&v45;
  uint64_t v12 = (double *)v46;
  uint64_t v13 = a3 + 48 * ((a5 + 1) % v6);
  uint64_t v14 = v13 + 16;
  uint64_t v15 = v13 + 48;
  uint64_t result = 1.0;
  do
  {
    unint64_t v16 = *(void *)v8;
    if (*(void *)v8 != -1 && v14 != v15)
    {
      double v18 = *(double *)(v8 + 8);
      for (uint64_t i = v14; i != v15; i += 16)
      {
        if (v16 == *(void *)i)
        {
          if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a2[1] - *a2) >> 3) <= v16) {
            __break(1u);
          }
          double v20 = *(double *)(i + 8);
          if (v18 == v20) {
            break;
          }
          if (vabdd_f64(v18, v20) <= 1.0)
          {
            uint64_t v24 = v10;
            uint64_t v26 = (double *)&v44[32 * v10];
            *(void *)uint64_t v26 = v16;
            *((unsigned char *)v26 + 8) = v20 > v18;
            void v26[2] = v18;
          }
          else
          {
            double v21 = (double)(unint64_t)((uint64_t)(*(void *)(*a2 + 56 * v16 + 8) - *(void *)(*a2 + 56 * v16)) >> 4);
            if (v21 - v20 <= 1.0 && v18 < 1.0)
            {
              uint64_t v24 = v10;
              unint64_t v27 = (double *)&v44[32 * v10];
              *(void *)unint64_t v27 = v16;
              *((unsigned char *)v27 + 8) = 0;
              v27[2] = v18 + v21;
            }
            else
            {
              if (v21 - v18 > 1.0 || v20 >= 1.0) {
                continue;
              }
              uint64_t v24 = v10;
              uint64_t v25 = (double *)&v44[32 * v10];
              *(void *)uint64_t v25 = v16;
              *((unsigned char *)v25 + 8) = 1;
              v25[2] = v18;
              double v20 = v20 + v21;
            }
          }
          *(double *)&v46[2 * v24] = v20;
          ++v10;
        }
      }
    }
    v8 += 16;
  }
  while (v8 != v9);
  if (v10)
  {
    double v28 = (double *)v44;
    if (v10 != 1)
    {
      double v29 = (double *)v47;
      uint64_t v30 = 32 * v10 - 32;
      unint64_t v31 = (double *)&v45;
      unint64_t v32 = (double *)v46;
      uint64_t v33 = (double *)&v45;
      unsigned int v34 = (double *)v46;
      unint64_t v35 = (double *)v46;
      unint64_t v36 = (double *)&v45;
      unint64_t v37 = (double *)v46;
      __n128 v38 = (double *)&v45;
      unint64_t v39 = (double *)v47;
      do
      {
        double v40 = *v39;
        v39 += 4;
        double v41 = vabdd_f64(*(v29 - 1), v40);
        double v42 = vabdd_f64(*v11, *v12);
        if (v41 >= v42)
        {
          CFTypeRef v11 = v31;
        }
        else
        {
          double v28 = v29 - 3;
          CFTypeRef v11 = v29 - 1;
        }
        if (v41 >= v42) {
          unint64_t v31 = v33;
        }
        else {
          unint64_t v31 = v29 - 1;
        }
        if (v41 >= v42) {
          uint64_t v33 = v36;
        }
        else {
          uint64_t v33 = v29 - 1;
        }
        if (v41 >= v42) {
          unint64_t v36 = v38;
        }
        else {
          unint64_t v36 = v29 - 1;
        }
        __n128 v38 = v28 + 2;
        if (v41 >= v42) {
          uint64_t v12 = v32;
        }
        else {
          uint64_t v12 = v29;
        }
        if (v41 >= v42) {
          unint64_t v32 = v34;
        }
        else {
          unint64_t v32 = v29;
        }
        if (v41 >= v42) {
          unsigned int v34 = v35;
        }
        else {
          unsigned int v34 = v29;
        }
        if (v41 >= v42) {
          unint64_t v35 = v37;
        }
        else {
          unint64_t v35 = v29;
        }
        unint64_t v37 = v28 + 3;
        double v29 = v39;
        v30 -= 32;
      }
      while (v30);
    }
    *(double *)(a1 + 16) = *v28;
    *(unsigned char *)(a1 + 8) = *((unsigned char *)v28 + 8);
    uint64_t result = *v11;
    double v43 = *v12;
    *(double *)(a1 + 24) = *v11;
    *(double *)(a1 + 32) = v43;
  }
  return result;
}

uint64_t *CGPathRandomAccessSubpath::append_range_to_path(uint64_t *result, int a2, CGPoint *a3, uint64_t a4, uint64_t a5, __n128 a6, __n128 a7, CGFloat a8, CGFloat a9)
{
  int v11 = (int)a3;
  uint64_t v15 = result;
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = *result;
  unint64_t v17 = (result[1] - *result) >> 4;
  if ((double)v17 <= a7.n128_f64[0]) {
    double v18 = (double)v17;
  }
  else {
    double v18 = 0.0;
  }
  double v19 = a7.n128_f64[0] - v18;
  if ((double)v17 <= a6.n128_f64[0]) {
    double v20 = (double)v17;
  }
  else {
    double v20 = 0.0;
  }
  double v21 = a6.n128_f64[0] - v20;
  unint64_t v22 = (unint64_t)v21;
  double v23 = (double)(unint64_t)v21;
  unint64_t v24 = (unint64_t)v19;
  if (v19 == v21 && v21 == v23)
  {
    return CGPathRandomAccessSubpath::append_sections_to_path(result, (unint64_t)v21, (unint64_t)v19, a2, (int)a3, a4, a5);
  }
  else if (v21 < v19 && v22 == v24)
  {
    if (v17 <= v22) {
      goto LABEL_58;
    }
    if (*(unsigned char *)(v16 + 16 * v22 + 8))
    {
      unint64_t v31 = *(void *)(v16 + 16 * v22);
      uint64_t v32 = result[3];
      if (v31 < (result[4] - v32) >> 4)
      {
        float64x2_t v33 = CGPathRandomAccessSubpath::cubic_curve_between((float64x2_t *)(v32 + 16 * v31), (float64x2_t *)v45, v21 - (double)(uint64_t)v21, v19 - v23, a3);
        uint64_t v34 = 3;
        if (v11) {
          uint64_t v34 = 0;
        }
        unint64_t v35 = &v45[v34];
        v35->float64x2_t x = a8;
        v35->CGFloat y = a9;
        return (uint64_t *)(*(uint64_t (**)(uint64_t, CGPoint *, float64x2_t))(a5 + 16))(a5, v45, v33);
      }
LABEL_58:
      __break(1u);
    }
    if ((a2 & 1) == 0)
    {
      unint64_t v36 = *(uint64_t (**)(uint64_t, __n128, __n128))(a4 + 16);
      a6.n128_f64[0] = a8;
      a7.n128_f64[0] = a9;
      return (uint64_t *)v36(a4, a6, a7);
    }
  }
  else
  {
    if (v17 <= v22) {
      goto LABEL_58;
    }
    unint64_t v27 = v16 + 16 * v22;
    if (*(unsigned char *)(v27 + 8))
    {
      unint64_t v28 = *(void *)v27;
      uint64_t v29 = result[3];
      if (v28 >= (result[4] - v29) >> 4) {
        goto LABEL_58;
      }
      float64x2_t v30 = CGPathRandomAccessSubpath::cubic_curve_between((float64x2_t *)(v29 + 16 * v28), (float64x2_t *)v45, v21 - (double)(uint64_t)v21, 1.0, a3);
      if (v11)
      {
        v45[0].float64x2_t x = a8;
        v45[0].CGFloat y = a9;
      }
      uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, CGPoint *, float64x2_t))(a5 + 16))(a5, v45, v30);
    }
    else if (a3)
    {
      if ((a2 & 1) == 0)
      {
        a6.n128_f64[0] = a8;
        a7.n128_f64[0] = a9;
        uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, __n128, __n128))(a4 + 16))(a4, a6, a7);
      }
    }
    else
    {
      unint64_t v37 = (unint64_t *)(result[3]
                               + 16 * ((*(void *)v27 + 1) % (unint64_t)((result[4] - result[3]) >> 4)));
      a6.n128_u64[0] = *v37;
      a7.n128_u64[0] = v37[1];
      uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, __n128, __n128))(a4 + 16))(a4, a6, a7);
    }
    if ((v22 + 1) % ((v15[1] - *v15) >> 4) != v24)
    {
      if (a2) {
        int v38 = (v11 & 1) == 0 && v19 == (double)v24;
      }
      else {
        int v38 = 0;
      }
      uint64_t result = CGPathRandomAccessSubpath::append_sections_to_path(v15, v22 + 1, (unint64_t)v19, v38, v11, a4, a5);
    }
    if (v19 != (double)v24)
    {
      if (v24 >= (v15[1] - *v15) >> 4) {
        goto LABEL_58;
      }
      uint64_t v39 = *v15 + 16 * v24;
      if (*(unsigned char *)(v39 + 8))
      {
        unint64_t v40 = *(void *)v39;
        uint64_t v41 = v15[3];
        if (v40 < (v15[4] - v41) >> 4)
        {
          float64x2_t v33 = CGPathRandomAccessSubpath::cubic_curve_between((float64x2_t *)(v41 + 16 * v40), (float64x2_t *)v45, 0.0, v19 - (double)(uint64_t)v19, a3);
          if ((v11 & 1) == 0)
          {
            CGFloat v46 = a8;
            CGFloat v47 = a9;
          }
          return (uint64_t *)(*(uint64_t (**)(uint64_t, CGPoint *, float64x2_t))(a5 + 16))(a5, v45, v33);
        }
        goto LABEL_58;
      }
      if (v11)
      {
        unint64_t v42 = *(void *)v39;
        uint64_t v43 = v15[3];
        if (v42 < (v15[4] - v43) >> 4)
        {
          double v44 = (unint64_t *)(v43 + 16 * v42);
          a6.n128_u64[0] = *v44;
          a7.n128_u64[0] = v44[1];
          return (uint64_t *)(*(uint64_t (**)(uint64_t, __n128, __n128))(a4 + 16))(a4, a6, a7);
        }
        goto LABEL_58;
      }
      if ((a2 & 1) == 0)
      {
        a6.n128_f64[0] = a8;
        a7.n128_f64[0] = a9;
        return (uint64_t *)(*(uint64_t (**)(uint64_t, __n128, __n128))(a4 + 16))(a4, a6, a7);
      }
    }
  }
  return result;
}

void ___ZNK25CGPathRandomAccessSubpath20append_range_to_pathEddbb7CGPoint17CGAffineTransformR21CGPathOutputFiltering_block_invoke_2(uint64_t a1, double *a2)
{
  uint64_t v2 = *(CGPathOutputFiltering **)(a1 + 32);
  CGFloat v3 = a2[2];
  CGFloat v4 = a2[3];
  CGFloat v5 = a2[4];
  CGFloat v6 = a2[5];
  CGFloat v7 = a2[6];
  CGFloat v8 = a2[7];
  CGPathOutputFiltering::commit_pending_line_point_if_needed(v2);
  uint64_t v9 = *(CGPath **)v2;

  CGPathAddCurveToPoint(v9, 0, v3, v4, v5, v6, v7, v8);
}

CGFloat CGPathOutputFiltering::commit_pending_line_point_if_needed(CGPathOutputFiltering *this)
{
  CGFloat result = *((double *)this + 1);
  double v3 = *((double *)this + 2);
  uint64_t v1 = (_OWORD *)((char *)this + 8);
  BOOL v4 = fabs(v3) == INFINITY;
  if (fabs(result) != INFINITY || !v4)
  {
    CGPathAddLineToPoint(*(CGMutablePathRef *)this, 0, result, v3);
    CGFloat result = *(double *)&cgpoint_null;
    *uint64_t v1 = cgpoint_null;
  }
  return result;
}

float64x2_t CGPathRandomAccessSubpath::cubic_curve_between(float64x2_t *this, float64x2_t *a2, double a3, double a4, CGPoint *a5)
{
  float64x2_t v5 = this[1];
  float64x2_t v6 = this[2];
  float64x2_t v7 = vmlaq_n_f64(vmulq_n_f64(v6, a3), v5, 1.0 - a3);
  *a2 = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(this[3], a3), v6, 1.0 - a3), a3), v7, 1.0 - a3), a3), vmlaq_n_f64(vmulq_n_f64(v7, a3), vmlaq_n_f64(vmulq_n_f64(v5, a3), *this, 1.0 - a3), 1.0 - a3), 1.0 - a3);
  float64x2_t v8 = this[1];
  float64x2_t v9 = this[2];
  float64x2_t v10 = vmlaq_n_f64(vmulq_n_f64(v9, a4), v8, 1.0 - a4);
  a2[1] = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(this[3], a4), v9, 1.0 - a4), a3), v10, 1.0 - a3), a3), vmlaq_n_f64(vmulq_n_f64(v10, a3), vmlaq_n_f64(vmulq_n_f64(v8, a4), *this, 1.0 - a4), 1.0 - a3), 1.0 - a3);
  float64x2_t v11 = this[1];
  float64x2_t v12 = this[2];
  float64x2_t v13 = vmlaq_n_f64(vmulq_n_f64(v12, a4), v11, 1.0 - a4);
  a2[2] = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(this[3], a4), v12, 1.0 - a4), a4), v13, 1.0 - a4), a3), vmlaq_n_f64(vmulq_n_f64(v13, a4), vmlaq_n_f64(vmulq_n_f64(v11, a4), *this, 1.0 - a4), 1.0 - a4), 1.0 - a3);
  float64x2_t v14 = this[1];
  float64x2_t v15 = this[2];
  float64x2_t v16 = vmlaq_n_f64(vmulq_n_f64(v15, a4), v14, 1.0 - a4);
  float64x2_t result = vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(vmlaq_n_f64(vmulq_n_f64(this[3], a4), v15, 1.0 - a4), a4), v16, 1.0 - a4), a4), vmlaq_n_f64(vmulq_n_f64(v16, a4), vmlaq_n_f64(vmulq_n_f64(v14, a4), *this, 1.0 - a4), 1.0 - a4), 1.0 - a4);
  a2[3] = result;
  return result;
}

CFTypeRef CGPathOutputFiltering::cg_path(CGPathOutputFiltering *this)
{
  CGPathOutputFiltering::commit_pending_line_point_if_needed(this);
  uint64_t v2 = *(const void **)this;
  if (v2) {
    CFRetain(v2);
  }

  return CFAutorelease(v2);
}

void CGPathOutputFiltering::add_line_to_point(CGPathOutputFiltering *this, double a2, double a3, CGAffineTransform *a4)
{
  BOOL v8 = fabs(*((double *)this + 2)) == INFINITY;
  if (fabs(*((double *)this + 1)) != INFINITY || !v8)
  {
    CGPoint CurrentPoint = CGPathGetCurrentPoint((CGPathRef)*(void *)this);
    CGPoint v13 = *(CGPoint *)((char *)this + 8);
    long long v9 = *(_OWORD *)&a4->c;
    *(_OWORD *)&v11.double a = *(_OWORD *)&a4->a;
    *(_OWORD *)&v11.double c = v9;
    *(_OWORD *)&v11.tfloat64x2_t x = *(_OWORD *)&a4->tx;
    double v10 = a2;
    *(double *)&long long v9 = a3;
    if (!points_are_nearly_collinear(CurrentPoint, v13, *(CGPoint *)((char *)&v9 - 8), &v11)) {
      CGPathOutputFiltering::commit_pending_line_point_if_needed(this);
    }
  }
  *((double *)this + 1) = a2;
  *((double *)this + 2) = a3;
}

CGPathRef CGPathCreateCopyByIntersectingPath(CGPathRef path, CGPathRef maskPath, BOOL evenOddFillRule)
{
  return (CGPathRef)pathCreateCopyByClippingWithPath(0, path, evenOddFillRule, maskPath, evenOddFillRule);
}

uint64_t *__color_space_state_create_generic_gray_gamma_22_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (float64x2_t result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncGenericGrayGamma22Profile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_generic_gray_gamma_22_s = v1;
  return result;
}

uint64_t (*__create_from_profile_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyData");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  create_from_profile_f = (uint64_t (*)(void, void))v1;
  return result;
}

uint64_t (*__color_space_state_create_sRGB_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_sRGB_f = v1;
  return result;
}

uint64_t (*__color_space_state_create_extended_srgb_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_extended_srgb_f = v1;
  return result;
}

void CGPDFContentStreamFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[4];
  if (v2) {
    CFRelease(v2);
  }
  double v3 = (const void *)a1[5];
  if (v3) {
    CFRelease(v3);
  }
  BOOL v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t (*__color_space_state_create_generic_gray_gamma_22_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_generic_gray_gamma_22_f = v1;
  return result;
}

uint64_t CGFontCopyCharacterSet(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 232))(*(void *)(result + 112));
  }
  return result;
}

CGAffineTransform *__cdecl CGPDFPageGetDrawingTransform(CGAffineTransform *__return_ptr retstr, CGAffineTransform *page, CGPDFBox box, CGRect rect, int rotate, BOOL preserveAspectRatio)
{
  if (page) {
    pdf_page_get_drawing_transform(&retstr->a, *(void *)&page->ty, box, rotate, preserveAspectRatio, 1, -8.98846567e307, -8.98846567e307, 1.79769313e308, 1.79769313e308, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
  }
  else {
    *retstr = CGAffineTransformIdentity;
  }
  return page;
}

uint64_t __initialize_font_database_once_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1.__sig = 0;
  *(void *)v1.__opaque = 0;
  pthread_mutexattr_init(&v1);
  pthread_mutexattr_settype(&v1, 2);
  pthread_mutex_init(&initialize_font_database_once_mutex, &v1);
  return pthread_mutexattr_destroy(&v1);
}

CGColorSpaceRef CGColorSpaceCreateWithPropertyList(CFPropertyListRef plist)
{
  Extendedouble d = (CGColorSpace *)plist;
  if (!plist) {
    return Extended;
  }
  CFTypeID v2 = CFGetTypeID(plist);
  if (v2 == CFStringGetTypeID())
  {
    if (CFEqual(Extended, @"kCGColorSpaceDeviceGray"))
    {
      CFStringRef v3 = @"kCGColorSpaceGenericGrayGamma2_2";
    }
    else if (CFEqual(Extended, @"kCGColorSpaceDeviceRGB"))
    {
      CFStringRef v3 = @"kCGColorSpaceSRGB";
    }
    else if (CFEqual(Extended, @"kCGColorSpaceDeviceCMYK"))
    {
      CFStringRef v3 = @"kCGColorSpaceGenericCMYK";
    }
    else
    {
      CFStringRef v3 = (const __CFString *)Extended;
    }
    return CGColorSpaceCreateWithName(v3);
  }
  CFTypeID v4 = CFGetTypeID(Extended);
  if (v4 != CFDataGetTypeID())
  {
    CFTypeID v6 = CFGetTypeID(Extended);
    if (v6 == CFDictionaryGetTypeID())
    {
      if (CFDictionaryContainsKey(Extended, @"kCGColorSpaceExtendedRange") == 1)
      {
        CFDataRef Value = CFDictionaryGetValue(Extended, @"kCGColorSpaceICCData");
        if (Value)
        {
          BOOL v8 = (uint64_t *)CGColorSpaceCreateWithPropertyList(Value);
          long long v9 = CFDictionaryGetValue(Extended, @"kCGColorSpaceDisplayReferredDerivative");
          double v10 = (const void *)*MEMORY[0x1E4F1CFD0];
          CGAffineTransform v11 = CFDictionaryGetValue(Extended, @"kCGColorSpaceSceneReferredDerivative");
          if (v9 == v10 || v11 == v10)
          {
            icc_derivative_with_state = color_space_state_create_icc_derivative_with_state(v8[3], v11 == v10, v9 == v10, v12, v13, v14, v15, v16);
            Extendedouble d = (CGColorSpace *)CGColorSpaceCreateWithState((atomic_uint *)icc_derivative_with_state, v30, v31, v32, v33, v34, v35, v36);
            if (icc_derivative_with_state
              && atomic_fetch_add_explicit((atomic_uint *volatile)icc_derivative_with_state, 0xFFFFFFFF, memory_order_relaxed) == 1)
            {
              color_space_state_dealloc((uint64_t)icc_derivative_with_state);
            }
            if (Extended) {
              *((void *)Extended + 3) = color_space_state_register(*((unsigned char **)Extended + 3));
            }
          }
          else
          {
            if (CFDictionaryGetValue(Extended, @"kCGColorSpaceExtendedRange") != v10) {
              return (CGColorSpaceRef)v8;
            }
            Extendedouble d = CGColorSpaceCreateExtended((CGColorSpaceRef)v8);
          }
          CGColorSpaceRelease((CGColorSpaceRef)v8);
          return Extended;
        }
      }
      else
      {
        CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(Extended, @"kCGLastIndexKey");
        if (v17)
        {
          CFNumberRef v18 = v17;
          CFTypeID v19 = CFGetTypeID(v17);
          if (v19 == CFNumberGetTypeID())
          {
            unsigned __int8 valuePtr = 0;
            if (CFNumberGetValue(v18, kCFNumberSInt8Type, &valuePtr) == 1)
            {
              double v20 = CFDictionaryGetValue(Extended, @"kCGIndexedBaseColorSpaceKey");
              if (v20)
              {
                double v21 = v20;
                CFDataRef v22 = (const __CFData *)CFDictionaryGetValue(Extended, @"kCGIndexedColorTableKey");
                if (v22)
                {
                  CFDataRef v23 = v22;
                  CFTypeID v24 = CFGetTypeID(v22);
                  if (v24 == CFDataGetTypeID())
                  {
                    unint64_t Length = CFDataGetLength(v23);
                    CGColorSpaceRef v26 = CGColorSpaceCreateWithPropertyList(v21);
                    size_t v27 = valuePtr;
                    if (!v26)
                    {
                      BytePtr = CFDataGetBytePtr(v23);
                      return CGColorSpaceCreateIndexed(0, v27, BytePtr);
                    }
                    unint64_t v28 = v26;
                    if (Length >= *(void *)(*((void *)v26 + 3) + 48)
                                 + *(void *)(*((void *)v26 + 3) + 48) * (unint64_t)valuePtr)
                    {
                      int v38 = CFDataGetBytePtr(v23);
                      Extendedouble d = CGColorSpaceCreateIndexed(v28, v27, v38);
                      CFRelease(v28);
                      return Extended;
                    }
                    CFRelease(v26);
                  }
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }

  return (CGColorSpaceRef)CGColorSpaceFromICCDataCacheGetRetained(Extended);
}

uint64_t *__color_space_state_create_generic_cmyk_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (float64x2_t result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncGenericCMYKProfile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_generic_cmyk_s = v1;
  return result;
}

uint64_t *__color_space_state_create_extended_gray_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (float64x2_t result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncGenericGrayGamma22Profile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_extended_gray_s = v1;
  return result;
}

uint64_t (*__transform_is_null_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTransformCopyProperty");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1203;
  }
  transform_is_null_f = (uint64_t (*)(void, void, void))v1;
  return result;
}

uint64_t (*__transform_get_conv_type_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTransformCopyProperty");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_2143;
  }
  transform_get_conv_type_f = (uint64_t (*)(void, void, void))v1;
  return result;
}

uint64_t (*__md5_creator_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileGetMD5");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_12379;
  }
  md5_creator_f_20 = (uint64_t (*)(void))v1;
  return result;
}

uint64_t (*__md5_creator_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileGetTypeID");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_12379;
  }
  md5_creator_f = v1;
  return result;
}

uint64_t (*__matrix_get_properties_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncMatrixGetProperties");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  matrix_get_properties_f = (uint64_t)v1;
  return result;
}

uint64_t (*__matrix_get_output_range_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncMatrixGetOutputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  matrix_get_output_range_f_100 = (uint64_t)v1;
  return result;
}

uint64_t (*__matrix_get_output_range_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncMatrixGetOutputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  matrix_get_float output_range_f = v1;
  return result;
}

uint64_t (*__matrix_get_input_range_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncMatrixGetInputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  matrix_get_input_range_f_73 = (uint64_t)v1;
  return result;
}

uint64_t (*__matrix_get_input_range_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  float64x2_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    float64x2_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncMatrixGetInputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  matrix_get_float input_range_f = v1;
  return result;
}

uint64_t __linked_on_golden_gate_or_later_block_invoke()
{
  linked_on_golden_gate_or_later_linked_on_golden_gate_or_later = dyld_program_sdk_at_least();
  linked_on_golden_gate_or_later_linked_on_azul_or_later = dyld_program_sdk_at_least();
  linked_on_golden_gate_or_later_linked_on_archer_or_later = dyld_program_sdk_at_least();
  uint64_t result = dyld_program_sdk_at_least();
  linked_on_golden_gate_or_later_linked_on_borealis_or_later = result;
  return result;
}

uint64_t (*__create_conversion_info_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTransformGetTypeID");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1203;
  }
  create_conversion_info_f = v1;
  return result;
}

uint64_t (*__color_space_state_create_generic_cmyk_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_generic_cmyk_f = v1;
  return result;
}

uint64_t (*__color_space_state_create_extended_gray_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_extended_gray_f = v1;
  return result;
}

uint64_t (*__trc_get_properties_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTRCGetProperties");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  trc_get_properties_f = (uint64_t)v1;
  return result;
}

uint64_t (*__trc_get_output_range_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTRCGetOutputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  trc_get_output_range_f_91 = (uint64_t)v1;
  return result;
}

uint64_t (*__trc_get_output_range_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTRCGetOutputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  trc_get_float output_range_f = v1;
  return result;
}

uint64_t (*__trc_get_input_range_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTRCGetInputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  trc_get_input_range_f_64 = (uint64_t)v1;
  return result;
}

uint64_t (*__trc_get_input_range_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncTRCGetInputRange");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_791;
  }
  trc_get_float input_range_f = v1;
  return result;
}

_OWORD *colorspace_from_ICC_data_data_key_retain(_OWORD *a1, void *a2)
{
  uint64_t result = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
  if (result) {
    *uint64_t result = *a1;
  }
  *a2 = result;
  return result;
}

CGColorSpaceRef __create_resolved_space_block_invoke()
{
  create_resolved_space_graCGFloat y = (uint64_t)CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
  create_resolved_space_sRGB = (uint64_t)CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
  CGColorSpaceRef result = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
  create_resolved_space_cmyk = (uint64_t)result;
  return result;
}

uint64_t CGImageGetIdentifier(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 24);
  }
  return result;
}

uint64_t __CGPathGetTypeID_block_invoke()
{
  if ((dyld_program_sdk_at_least() & 1) != 0
    || (dyld_program_sdk_at_least() & 1) != 0
    || (dyld_program_sdk_at_least() & 1) != 0
    || (dyld_program_sdk_at_least() & 1) != 0)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t result = dyld_program_sdk_at_least();
  }
  CGPathDisableTypeValidation = result;
  return result;
}

void CGContextSetLineDash(CGContextRef c, CGFloat phase, const CGFloat *lengths, size_t count)
{
  if (!c)
  {
    CGContextRef v13 = 0;
LABEL_11:
    handle_invalid_context((char)"CGContextSetLineDash", (uint64_t)v13, count, v4, v5, v6, v7, v8);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v13 = c;
    goto LABEL_11;
  }
  if (count)
  {
    uint64_t v10 = 0;
    double v11 = 0.0;
    do
    {
      double v12 = lengths[v10];
      if (v12 < 0.0)
      {
        CGPostError((uint64_t)"%s: invalid dash array: negative lengths are not allowed.", (uint64_t)lengths, count, v4, v5, v6, v7, v8, (char)"CGContextSetLineDash");
        return;
      }
      double v11 = v11 + v12;
      ++v10;
    }
    while (count != v10);
    if (v11 == 0.0)
    {
      CGPostError((uint64_t)"%s: invalid dash array: at least one element must be non-zero.", (uint64_t)lengths, count, v4, v5, v6, v7, v8, (char)"CGContextSetLineDash");
    }
    else
    {
      uint64_t v15 = CGDashCreate(lengths, count, phase);
      CGGStateSetLineDash(*((void *)c + 12), (atomic_uint *)v15);
      if (v15 && atomic_fetch_add_explicit((atomic_uint *volatile)v15, 0xFFFFFFFF, memory_order_relaxed) == 1)
      {
        free(v15);
      }
    }
  }
  else
  {
    uint64_t v14 = *((void *)c + 12);
    CGGStateSetLineDash(v14, 0);
  }
}

CFMutableDictionaryRef __CGColorGetConstantColor_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CGColorGetConstantColor_constant_colors = (uint64_t)result;
  return result;
}

char *create_local_db()
{
  CFMutableDictionaryRef result = CGFontDBCreate();
  local_ddouble b = (uint64_t)result;
  return result;
}

char *CGFontDBCreate()
{
  uint64_t v0 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0x1020040D7707FD8uLL);
  uint64_t v1 = v0;
  if (v0)
  {
    pthread_mutex_init((pthread_mutex_t *)(v0 + 32), 0);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    *(void *)uint64_t v1 = Mutable;
    if (!Mutable) {
      goto LABEL_7;
    }
    CFMutableDictionaryRef v3 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (!v3
      || (CFArrayAppendValue(*(CFMutableArrayRef *)v1, v3),
          CFMutableDictionaryRef v4 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]),
          (*((void *)v1 + 1) = v4) == 0)
      || (CFMutableArrayRef v5 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]), (*((void *)v1 + 2) = v5) == 0)
      || (CFMutableArrayRef v6 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]), (*((void *)v1 + 3) = v6) == 0))
    {
LABEL_7:
      CGFontDBRelease(v1);
      return 0;
    }
  }
  return v1;
}

CGFloat CGImageBlockSetGetSize(const CGSize *a1)
{
  uint64_t v1 = a1 + 1;
  if (!a1) {
    uint64_t v1 = &CGSizeZero;
  }
  return v1->width;
}

void *__CGFontCacheGetLocalCache_block_invoke()
{
  CFMutableDictionaryRef result = CGFontCacheCreate();
  CGFontCacheGetLocalCache_local_font_cache = (uint64_t)result;
  return result;
}

void *CGFontCacheCreate()
{
  if (CGFontCacheCreate_once != -1) {
    dispatch_once_f(&CGFontCacheCreate_once, 0, (dispatch_function_t)setup);
  }
  if (!enable_caching) {
    return 0;
  }
  uint64_t v0 = malloc_type_calloc(1uLL, 0x30uLL, 0x102004002AA219BuLL);
  void *v0 = 1;
  v0[1] = cache_max_size;
  v0[2] = 0;
  *((_DWORD *)v0 + 6) = 0;
  pthread_mutex_lock(&font_caches_mutex);
  uint64_t v1 = font_caches;
  CFTypeID v2 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
  if (v2)
  {
    *CFTypeID v2 = v0;
    v2[1] = v1;
    uint64_t v1 = (uint64_t)v2;
  }
  font_caches = v1;
  pthread_mutex_unlock(&font_caches_mutex);
  return v0;
}

float CGImageProviderGetContentHeadroom(uint64_t a1)
{
  if (!a1) {
    return 0.0;
  }
  float result = *(float *)(a1 + 132);
  if (result == 0.0)
  {
    CFTypeID v2 = *(void **)(a1 + 40);
    if (v2)
    {
      CFMutableDictionaryRef v3 = (unsigned char *)v2[3];
      if (v3[16] || v3[17])
      {
        return CGColorSpaceGetHeadroomInfo(v2, 0);
      }
      else if (!v3[13])
      {
        return 1.0;
      }
    }
    else
    {
      return 1.0;
    }
  }
  return result;
}

BOOL cf_color_space_state_equal(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
    {
      uint64_t v5 = *(void *)(a1 + 64);
      uint64_t v4 = *(void *)(a1 + 72);
      return v5 == *(void *)(a2 + 64) && v4 == *(void *)(a2 + 72);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL CGPathIsPrimitive(BOOL cf)
{
  if (cf)
  {
    uint64_t v1 = cf;
    if (CGPathDisableTypeValidation || (CFTypeID v2 = CFGetTypeID((CFTypeRef)cf), v2 == CGPathGetTypeID()))
    {
      CFTypeRef cf = 1;
      switch(*(_DWORD *)(v1 + 16))
      {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          return cf;
        case 8:
          int v3 = *(_DWORD *)(v1 + 28);
          CFTypeRef cf = v3 == 16968 || v3 == 135752;
          break;
        default:
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return cf;
}

void load_set_data(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = 0;
  uint64_t v10 = (const char **)&links;
  do
  {
    if (!strcmp("__CGBitmapContextDelegateData", *v10))
    {
      set_datdouble a = (&links)[2 * v9 + 1];
      return;
    }
    ++v9;
    v10 += 2;
  }
  while (v9 != 7);

  CGPostError((uint64_t)"Failed to load bitmap context.", v11, v12, v13, v14, v15, v16, v17, a9);
}

void load_bitmap_context_delegate_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = 0;
  uint64_t v10 = (const char **)&links;
  do
  {
    if (!strcmp("__CGBitmapContextDelegateCreate", *v10))
    {
      creator = (&links)[2 * v9 + 1];
      return;
    }
    ++v9;
    v10 += 2;
  }
  while (v9 != 7);

  CGPostError((uint64_t)"Failed to load bitmap context.", v11, v12, v13, v14, v15, v16, v17, a9);
}

void CGvImageConverterDeallocate(char *a1)
{
  CFTypeID v2 = *(vImageConverter **)a1;
  if (v2) {
    vImageConverter_Release(v2);
  }
  if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8))) {
    pthread_cond_destroy((pthread_cond_t *)(a1 + 72));
  }

  free(a1);
}

char *ClipperLib::Clipper::AddLocalMaxPoly(void *a1, uint64_t a2, uint64_t a3, long long *a4)
{
  BOOL result = ClipperLib::Clipper::AddOutPt(a1, a2, a4);
  if (!*(_DWORD *)(a3 + 160)) {
    BOOL result = ClipperLib::Clipper::AddOutPt(a1, a3, a4);
  }
  int v9 = *(_DWORD *)(a2 + 172);
  int v10 = *(_DWORD *)(a3 + 172);
  if (v9 == v10)
  {
    *(_DWORD *)(a2 + 172) = -1;
    *(_DWORD *)(a3 + 172) = -1;
  }
  else
  {
    if (v9 < v10)
    {
      uint64_t v11 = a2;
      uint64_t v12 = a3;
    }
    else
    {
      uint64_t v11 = a3;
      uint64_t v12 = a2;
    }
    return (char *)ClipperLib::Clipper::AppendPolygon(a1, v11, v12);
  }
  return result;
}

uint64_t ClipperLib::Clipper::ExecuteInternal(ClipperLib::Clipper *this)
{
  (*(void (**)(char *))(*(void *)((char *)this + *(void *)(*(void *)this - 24)) + 32))((char *)this + *(void *)(*(void *)this - 24));
  *(void *)&long long v189 = &v189;
  *((void *)&v189 + 1) = &v189;
  *(void *)&long long v190 = 0;
  std::__list_imp<long long>::clear((void *)this + 11);
  CGPDFDictionaryRef v177 = (uint64_t *)((char *)this + 88);
  if ((long long *)((char *)this + 88) == &v189)
  {
LABEL_317:
    __break(1u);
    JUMPOUT(0x184CA25E4);
  }
  uint64_t v2 = v190;
  if ((void)v190)
  {
    long long v3 = v189;
    uint64_t v4 = **((void **)&v189 + 1);
    *(void *)(v4 + 8) = *(void *)(v189 + 8);
    **(void **)(v3 + 8) = v4;
    uint64_t v5 = *((void *)this + 11);
    *(void *)(v5 + 8) = *((void *)&v3 + 1);
    **((void **)&v3 + 1) = v5;
    *((void *)this + 11) = v3;
    *(void *)(v3 + 8) = v177;
    *((void *)this + 13) += v2;
    *(void *)&long long v190 = 0;
  }
  std::__list_imp<long long>::clear(&v189);
  *((void *)this + 14) = 0;
  uint64_t v181 = 0;
  uint64_t v182 = 0;
  if (!ClipperLib::ClipperBase::PopScanbeam((ClipperLib::Clipper *)((char *)this + *(void *)(*(void *)this - 24)), &v182))return 0; {
  ClipperLib::Clipper::InsertLocalMinimaIntoAEL(this, v182);
  }
  long long v179 = (void *)((char *)this + 104);
  uint64_t v176 = (char *)this + 40;
  while (1)
  {
    if (!ClipperLib::ClipperBase::PopScanbeam((ClipperLib::Clipper *)((char *)this + *(void *)(*(void *)this - 24)), &v181))
    {
      uint64_t v6 = *(void *)this;
      uint64_t v7 = *(void *)this;
      uint64_t v8 = *(void *)(*(void *)this - 24);
      int v9 = (char *)this + v8;
      if (*(void *)((char *)this + v8 + 8) == *(void *)((char *)this + v8 + 24)) {
        break;
      }
    }
    ClipperLib::Clipper::ProcessHorizontals(this);
    ClipperLib::Clipper::ClearGhostJoins((uint64_t)this);
    uint64_t v10 = v181;
    uint64_t v11 = *(void *)((char *)v179 + *(void *)(*(void *)this - 24));
    if (!v11) {
      goto LABEL_63;
    }
    *((void *)this + 14) = v11;
    do
    {
      long long v12 = *(_OWORD *)(v11 + 200);
      *(_OWORD *)(v11 + 216) = v12;
      if (*(void *)(v11 + 104) == v10)
      {
        uint64_t v13 = *(void *)(v11 + 96);
      }
      else
      {
        double v14 = *(double *)(v11 + 144) * (double)(v10 - *(void *)(v11 + 8));
        if (v14 >= 0.0) {
          double v15 = 0.5;
        }
        else {
          double v15 = -0.5;
        }
        uint64_t v13 = *(void *)v11 + (uint64_t)(v14 + v15);
      }
      *(void *)(v11 + 48) = v13;
      uint64_t v11 = v12;
    }
    while ((void)v12);
    uint64_t v16 = (void *)*((void *)this + 14);
    uint64_t v17 = (void *)v16[27];
    if (v17)
    {
      do
      {
        if (v16[6] > v17[6]) {
          operator new();
        }
        uint64_t v16 = v17;
        uint64_t v17 = (void *)v17[27];
      }
      while (v17);
      uint64_t v18 = v16[28];
      if (v18) {
        *(void *)(v18 + 216) = 0;
      }
    }
    else
    {
      uint64_t v19 = v16[28];
      if (v19) {
        *(void *)(v19 + 216) = 0;
      }
    }
    *((void *)this + 14) = 0;
    uint64_t v20 = *((void *)this + 7);
    double v21 = (char *)*((void *)this + 8);
    unint64_t v22 = (uint64_t)&v21[-v20] >> 3;
    if (!v22) {
      goto LABEL_63;
    }
    if (v22 != 1)
    {
      uint64_t v23 = *(void *)((char *)v179 + *(void *)(*(void *)this - 24));
      *((void *)this + 14) = v23;
      if (v23)
      {
        do
        {
          long long v24 = *(_OWORD *)(v23 + 200);
          *(_OWORD *)(v23 + 216) = v24;
          uint64_t v23 = v24;
        }
        while ((void)v24);
        uint64_t v20 = *((void *)this + 7);
        double v21 = (char *)*((void *)this + 8);
        unint64_t v22 = (uint64_t)&v21[-v20] >> 3;
      }
      *(void *)&long long v189 = ClipperLib::IntersectListSort;
      unint64_t v25 = 126 - 2 * __clz(v22);
      if (v21 == (char *)v20) {
        uint64_t v26 = 0;
      }
      else {
        uint64_t v26 = v25;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(v20, v21, (uint64_t (**)(void))&v189, v26, 1);
      uint64_t v27 = *((void *)this + 7);
      uint64_t v20 = *((void *)this + 8);
      uint64_t v28 = v20 - v27;
      if (v20 == v27) {
        goto LABEL_62;
      }
      BOOL v29 = 0;
      unint64_t v30 = 0;
      unint64_t v31 = v28 >> 3;
      if ((unint64_t)(v28 >> 3) <= 1) {
        uint64_t v32 = 1;
      }
      else {
        uint64_t v32 = v28 >> 3;
      }
      unint64_t v33 = 1;
      do
      {
        if (v31 <= v33) {
          unint64_t v34 = v33;
        }
        else {
          unint64_t v34 = v31;
        }
        uint64_t v35 = *((void *)this + 7);
        unint64_t v36 = (*((void *)this + 8) - v35) >> 3;
        if (v36 <= v30) {
          goto LABEL_317;
        }
        unint64_t v37 = *(void **)(v35 + 8 * v30);
        uint64_t v38 = v37[1];
        if (*(void *)(*v37 + 216) != v38 && *(void *)(*v37 + 224) != v38)
        {
          unint64_t v39 = v33;
          unint64_t v40 = v30;
          while (1)
          {
            if (v39 >= v31)
            {
              unint64_t v40 = v34;
              goto LABEL_52;
            }
            if (v36 == v39) {
              goto LABEL_317;
            }
            uint64_t v41 = *(uint64_t **)(v35 + 8 * v39);
            uint64_t v43 = *v41;
            uint64_t v42 = v41[1];
            if (*(void *)(v43 + 216) == v42) {
              break;
            }
            ++v39;
            ++v40;
            if (*(void *)(v43 + 224) == v42) {
              goto LABEL_52;
            }
          }
          unint64_t v40 = v39;
LABEL_52:
          if (v40 == v31) {
            break;
          }
          if (v36 <= v40) {
            goto LABEL_317;
          }
          *(void *)(v35 + 8 * v30) = *(void *)(v35 + 8 * v40);
          *(void *)(v35 + 8 * v40) = v37;
          uint64_t v35 = *((void *)this + 7);
          unint64_t v36 = (*((void *)this + 8) - v35) >> 3;
        }
        if (v36 <= v30) {
          goto LABEL_317;
        }
        ClipperLib::Clipper::SwapPositionsInSEL((uint64_t)this, **(void **)(v35 + 8 * v30), *(void *)(*(void *)(v35 + 8 * v30) + 8));
        BOOL v29 = ++v30 >= v31;
        ++v33;
      }
      while (v30 != v32);
      if (!v29)
      {
        uint64_t v101 = 0;
        goto LABEL_319;
      }
      uint64_t v20 = *((void *)this + 7);
      double v21 = (char *)*((void *)this + 8);
    }
    if (v21 != (char *)v20)
    {
      unint64_t v44 = 0;
      do
      {
        uint64_t v45 = *(uint64_t **)(v20 + 8 * v44);
        ClipperLib::Clipper::IntersectEdges((char *)this, (_DWORD *)*v45, (_DWORD *)v45[1], (long long *)v45 + 1);
        ClipperLib::ClipperBase::SwapPositionsInAEL((uint64_t)this + *(void *)(*(void *)this - 24), *v45, v45[1]);
        MEMORY[0x18532A2A0](v45, 0x1020C40038FC326);
        ++v44;
        uint64_t v20 = *((void *)this + 7);
      }
      while (v44 < (*((void *)this + 8) - v20) >> 3);
    }
LABEL_62:
    *((void *)this + 8) = v20;
    *((void *)this + 14) = 0;
LABEL_63:
    for (uint64_t i = *(long long **)((char *)v179 + *(void *)(*(void *)this - 24)); ; uint64_t i = *v72)
    {
      v192[0] = i;
      if (!i) {
        break;
      }
      if (*((void *)i + 13) == v10)
      {
        uint64_t v47 = *((void *)i + 24);
        if (v47)
        {
          if (*(double *)(v47 + 144) == -1.0e40)
          {
            ClipperLib::ClipperBase::UpdateEdgeIntoAEL((uint64_t)this + *(void *)(*(void *)this - 24), (uint64_t *)v192);
            uint64_t i = v192[0];
            if ((*((_DWORD *)v192[0] + 43) & 0x80000000) == 0) {
              ClipperLib::Clipper::AddOutPt(this, (uint64_t)v192[0], v192[0]);
            }
            uint64_t v48 = *((void *)this + 14);
            *((void *)i + 28) = 0;
            if (v48) {
              *(void *)(v48 + 224) = i;
            }
            *((void *)this + 14) = i;
            *((void *)i + 27) = v48;
            goto LABEL_97;
          }
        }
        else
        {
          ClipperLib::GetMaximaPairEx(i);
          if (!v52 || *(double *)(v52 + 144) != -1.0e40)
          {
            if (*((unsigned char *)this + 134))
            {
              __n128 v53 = operator new(0x18uLL);
              uint64_t v54 = *((void *)i + 12);
              uint64_t v55 = *v177;
              v53[1] = v177;
              v53[2] = v54;
              void *v53 = v55;
              *(void *)(v55 + 8) = v53;
              *CGPDFDictionaryRef v177 = (uint64_t)v53;
              ++*v179;
            }
            uint64_t v56 = *((void *)i + 26);
            ClipperLib::GetMaximaPairEx(i);
            if (!v57)
            {
              if ((*((_DWORD *)i + 43) & 0x80000000) == 0) {
                ClipperLib::Clipper::AddOutPt(this, (uint64_t)i, i + 6);
              }
              uint64_t v73 = (char *)this + *(void *)(*(void *)this - 24);
              uint64_t v75 = *((void *)i + 25);
              uint64_t v76 = *((void *)i + 26);
              int v74 = (void *)i + 25;
              if (*(long long *)((char *)i + 200) != 0) {
                goto LABEL_148;
              }
              if (*((long long **)v73 + 13) == i) {
                goto LABEL_151;
              }
              goto LABEL_113;
            }
            uint64_t v58 = v57;
            uint64_t v60 = (void *)i + 25;
            uint64_t v59 = *((void *)i + 25);
            BOOL v61 = v59 != 0;
            if (v59 && v59 != v57)
            {
              do
              {
                ClipperLib::Clipper::IntersectEdges((char *)this, i, (_DWORD *)v59, i + 6);
                ClipperLib::ClipperBase::SwapPositionsInAEL((uint64_t)this + *(void *)(*(void *)this - 24), (uint64_t)i, v59);
                uint64_t v59 = *((void *)i + 25);
                BOOL v61 = v59 != 0;
                if (v59) {
                  BOOL v62 = v59 == v58;
                }
                else {
                  BOOL v62 = 1;
                }
              }
              while (!v62);
            }
            int v63 = *((_DWORD *)i + 43);
            if (v63 != -1)
            {
              if ((v63 & 0x80000000) == 0)
              {
                if ((*(_DWORD *)(v58 + 172) & 0x80000000) == 0)
                {
                  ClipperLib::Clipper::AddLocalMaxPoly(this, (uint64_t)i, v58, i + 6);
                  uint64_t v64 = *(void *)this;
                  CGFloat v65 = (char *)this + *(void *)(*(void *)this - 24);
                  uint64_t v67 = *((void *)i + 25);
                  uint64_t v66 = *((void *)i + 26);
                  if (*(long long *)((char *)i + 200) == 0)
                  {
                    if (*((long long **)v65 + 13) != i) {
                      goto LABEL_146;
                    }
                  }
                  else if (v66)
                  {
                    CGFloat v68 = (void *)(v66 + 200);
LABEL_139:
                    *CGFloat v68 = v67;
                    if (v67) {
                      *(void *)(v67 + 208) = v66;
                    }
LABEL_145:
                    *uint64_t v60 = 0;
                    *((void *)i + 26) = 0;
                    uint64_t v64 = *(void *)this;
LABEL_146:
                    uint64_t v81 = v64;
LABEL_147:
                    uint64_t v73 = (char *)this + *(void *)(v81 - 24);
                    uint64_t v75 = *(void *)(v58 + 200);
                    uint64_t v76 = *(void *)(v58 + 208);
                    int v74 = (void *)(v58 + 200);
                    if (*(_OWORD *)(v58 + 200) != 0)
                    {
LABEL_148:
                      if (v76)
                      {
                        unint64_t v86 = (void *)(v76 + 200);
LABEL_152:
                        *unint64_t v86 = v75;
                        if (v75) {
                          *(void *)(v75 + 208) = v76;
                        }
                        *int v74 = 0;
                        v74[1] = 0;
                        if (v56)
                        {
LABEL_114:
                          uint64_t v72 = (long long **)(v56 + 200);
                          continue;
                        }
LABEL_155:
                        uint64_t v72 = (long long **)((char *)v179 + *(void *)(*(void *)this - 24));
                        continue;
                      }
LABEL_151:
                      unint64_t v86 = v73 + 104;
                      goto LABEL_152;
                    }
                    if (*((void *)v73 + 13) == v58) {
                      goto LABEL_151;
                    }
LABEL_113:
                    if (v56) {
                      goto LABEL_114;
                    }
                    goto LABEL_155;
                  }
                  CGFloat v68 = v65 + 104;
                  goto LABEL_139;
                }
                if (*((_DWORD *)i + 40))
                {
LABEL_316:
                  exception = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
                  ClipperLib::clipperException::clipperException(exception, "DoMaxima error");
                }
                ClipperLib::Clipper::AddOutPt(this, (uint64_t)i, i + 6);
                *((_DWORD *)i + 43) = -1;
LABEL_120:
                int v77 = (char *)this + *(void *)(*(void *)this - 24);
                uint64_t v79 = *((void *)i + 25);
                uint64_t v78 = *((void *)i + 26);
                if (*(long long *)((char *)i + 200) == 0)
                {
                  if (*((long long **)v77 + 13) == i) {
                    goto LABEL_124;
                  }
                }
                else
                {
                  if (v78)
                  {
                    int v80 = (void *)(v78 + 200);
                    goto LABEL_125;
                  }
LABEL_124:
                  int v80 = v77 + 104;
LABEL_125:
                  *int v80 = v79;
                  if (v79) {
                    *(void *)(v79 + 208) = v78;
                  }
                  *uint64_t v60 = 0;
                  *((void *)i + 26) = 0;
                }
                if ((*(_DWORD *)(v58 + 172) & 0x80000000) == 0)
                {
                  ClipperLib::Clipper::AddOutPt(this, v58, i + 6);
                  *(_DWORD *)(v58 + 172) = -1;
                }
                uint64_t v81 = *(void *)this;
                goto LABEL_147;
              }
LABEL_116:
              if (*((_DWORD *)i + 40)) {
                goto LABEL_316;
              }
              goto LABEL_120;
            }
            if (*(_DWORD *)(v58 + 172) != -1) {
              goto LABEL_116;
            }
            uint64_t v64 = *(void *)this;
            int v82 = (char *)this + *(void *)(*(void *)this - 24);
            uint64_t v83 = *((void *)i + 26);
            if (v83) {
              char v84 = 1;
            }
            else {
              char v84 = v61;
            }
            if (v84)
            {
              if (v83)
              {
                long long v85 = (uint64_t *)(v83 + 200);
                goto LABEL_143;
              }
            }
            else if (*((long long **)v82 + 13) != i)
            {
              goto LABEL_146;
            }
            long long v85 = (uint64_t *)(v82 + 104);
LABEL_143:
            *long long v85 = v59;
            if (v61) {
              *(void *)(v59 + 208) = v83;
            }
            goto LABEL_145;
          }
        }
        uint64_t v51 = *((void *)i + 12);
      }
      else
      {
        double v49 = *((double *)i + 18) * (double)(v10 - *((void *)i + 1));
        if (v49 >= 0.0) {
          double v50 = 0.5;
        }
        else {
          double v50 = -0.5;
        }
        uint64_t v51 = *(void *)i + (uint64_t)(v49 + v50);
      }
      *((void *)i + 6) = v51;
      *((void *)i + 7) = v10;
LABEL_97:
      if (*((unsigned char *)this + 134))
      {
        if ((*((_DWORD *)i + 43) & 0x80000000) == 0)
        {
          if (*((_DWORD *)i + 40))
          {
            uint64_t v69 = *((void *)i + 26);
            if (v69)
            {
              if ((*(_DWORD *)(v69 + 172) & 0x80000000) == 0
                && *(void *)(v69 + 48) == *((void *)i + 6)
                && *(_DWORD *)(v69 + 160))
              {
                long long v70 = i[4];
                long long v189 = i[3];
                long long v190 = v70;
                long long v191 = i[5];
                CGFloat v71 = (void (*)(uint64_t, uint64_t, long long *, long long *, long long *))*((void *)this + 17);
                if (v71) {
                  v71(v69, v69 + 96, i, i + 6, &v189);
                }
                ClipperLib::Clipper::AddOutPt(this, v69, &v189);
                ClipperLib::Clipper::AddOutPt(this, (uint64_t)i, &v189);
                long long v186 = v189;
                long long v187 = v190;
                long long v188 = v191;
                ClipperLib::Clipper::AddJoin();
              }
            }
          }
        }
      }
      uint64_t v72 = (long long **)i + 25;
    }
    std::list<long long>::__sort<std::__less<void,void>>(*((uint64_t **)this + 12), v177, *((void *)this + 13));
    ClipperLib::Clipper::ProcessHorizontals(this);
    std::__list_imp<long long>::clear(v177);
    for (j = *(long long **)((char *)v179 + *(void *)(*(void *)this - 24)); ; j = (long long *)*((void *)j + 25))
    {
      v192[0] = j;
      if (!j) {
        break;
      }
      if (*((void *)j + 13) == v10 && *((void *)j + 24))
      {
        if ((*((_DWORD *)j + 43) & 0x80000000) != 0) {
          unint64_t v88 = 0;
        }
        else {
          unint64_t v88 = ClipperLib::Clipper::AddOutPt(this, (uint64_t)j, j + 6);
        }
        ClipperLib::ClipperBase::UpdateEdgeIntoAEL((uint64_t)this + *(void *)(*(void *)this - 24), (uint64_t *)v192);
        j = v192[0];
        uint64_t v89 = *((void *)v192[0] + 25);
        uint64_t v90 = *((void *)v192[0] + 26);
        if (v90)
        {
          uint64_t v91 = *(void *)(v90 + 48);
          if (v91 == *(void *)v192[0])
          {
            uint64_t v92 = *(void *)(v90 + 56);
            if (v92 == *((void *)v192[0] + 1) && v88 != 0 && (*(_DWORD *)(v90 + 172) & 0x80000000) == 0)
            {
              uint64_t v94 = *(void *)(v90 + 104);
              if (v92 > v94
                && ClipperLib::SlopesEqual(*((void *)v192[0] + 6), *((void *)v192[0] + 7), *((void *)v192[0] + 12), *((void *)v192[0] + 13), v91, v92, *(void *)(v90 + 96), v94, v176[*(void *)(*(void *)this - 24)])&& *((_DWORD *)j + 40)&& *(_DWORD *)(v90 + 160))
              {
                ClipperLib::Clipper::AddOutPt(this, v90, j);
                long long v95 = j[7];
                long long v189 = j[6];
                long long v190 = v95;
                long long v191 = j[8];
                goto LABEL_187;
              }
            }
          }
        }
        if (v89)
        {
          uint64_t v96 = *(void *)(v89 + 48);
          if (v96 == *(void *)j)
          {
            uint64_t v97 = *(void *)(v89 + 56);
            if (v97 == *((void *)j + 1) && v88 != 0 && (*(_DWORD *)(v89 + 172) & 0x80000000) == 0)
            {
              uint64_t v99 = *(void *)(v89 + 104);
              if (v97 > v99
                && ClipperLib::SlopesEqual(*((void *)j + 6), *((void *)j + 7), *((void *)j + 12), *((void *)j + 13), v96, v97, *(void *)(v89 + 96), v99, v176[*(void *)(*(void *)this - 24)])&& *((_DWORD *)j + 40)&& *(_DWORD *)(v89 + 160))
              {
                ClipperLib::Clipper::AddOutPt(this, v89, j);
                long long v100 = j[7];
                long long v183 = j[6];
                long long v184 = v100;
                long long v185 = j[8];
LABEL_187:
                ClipperLib::Clipper::AddJoin();
              }
            }
          }
        }
      }
    }
    ClipperLib::Clipper::InsertLocalMinimaIntoAEL(this, v10);
  }
  int v103 = v9 + 80;
  uint64_t v102 = *((void *)v9 + 10);
  if (*((void *)v103 + 1) != v102)
  {
    unint64_t v104 = 0;
    do
    {
      uint64_t v105 = *(void *)(v102 + 8 * v104);
      uint64_t v106 = *(void **)(v105 + 24);
      if (v106)
      {
        if (!*(unsigned char *)(v105 + 5))
        {
          int v107 = *((unsigned __int8 *)this + 132) ^ *(unsigned __int8 *)(v105 + 4);
          if (v107 == ClipperLib::Area(v106) > 0.0)
          {
            int v108 = v106;
            do
            {
              int8x16_t v109 = *(int8x16_t *)(v108 + 7);
              *(int8x16_t *)(v108 + 7) = vextq_s8(v109, v109, 8uLL);
              int v108 = (void *)v109.i64[0];
            }
            while ((void *)v109.i64[0] != v106);
            uint64_t v8 = *(void *)(v7 - 24);
          }
        }
      }
      ++v104;
      uint64_t v102 = *(void *)((char *)this + v8 + 80);
    }
    while (v104 < (*(void *)((char *)this + v8 + 88) - v102) >> 3);
  }
  uint64_t v110 = *((void *)this + 1);
  if (v110 != *((void *)this + 2))
  {
    unint64_t v111 = 0;
    do
    {
      uint64_t v112 = *(int ***)(v110 + 8 * v111);
      OutRedouble c = ClipperLib::Clipper::GetOutRec((int *)this, **v112);
      uint64_t v114 = ClipperLib::Clipper::GetOutRec((int *)this, *v112[1]);
      if (*((void *)OutRec + 3))
      {
        uint64_t v115 = (uint64_t)v114;
        int v116 = v114 + 6;
        if (*((void *)v114 + 3))
        {
          if (!*((unsigned char *)OutRec + 5) && !*((unsigned char *)v114 + 5))
          {
            if (OutRec == v114)
            {
              if (ClipperLib::Clipper::JoinPoints((uint64_t *)this, v112, (uint64_t)OutRec, (uint64_t)OutRec))
              {
                *((void *)OutRec + 3) = *v112;
                *((void *)OutRec + 4) = 0;
                ClipperLib::ClipperBase::CreateOutRec((ClipperLib::Clipper *)((char *)this
                                                                            + *(void *)(*(void *)this - 24)));
              }
            }
            else
            {
              uint64_t v117 = OutRec;
              do
                uint64_t v117 = (int *)*((void *)v117 + 1);
              while (v117 != v114 && v117 != 0);
              LowermostRedouble c = (uint64_t)v114;
              if (v117 != v114)
              {
                uint64_t v120 = v114;
                do
                  uint64_t v120 = (int *)*((void *)v120 + 1);
                while (v120 != OutRec && v120 != 0);
                LowermostRedouble c = (uint64_t)OutRec;
                if (v120 != OutRec) {
                  LowermostRedouble c = ClipperLib::GetLowermostRec((uint64_t)OutRec, (uint64_t)v114);
                }
              }
              if (ClipperLib::Clipper::JoinPoints((uint64_t *)this, v112, (uint64_t)OutRec, v115))
              {
                *int v116 = 0;
                v116[1] = 0;
                *(_DWORD *)uint64_t v115 = *OutRec;
                *((unsigned char *)OutRec + 4) = *(unsigned char *)(LowermostRec + 4);
                if (LowermostRec == v115) {
                  *((void *)OutRec + 1) = *(void *)(v115 + 8);
                }
                *(void *)(v115 + 8) = OutRec;
                if (*((unsigned char *)this + 133))
                {
                  uint64_t v122 = *(void *)this;
                  uint64_t v123 = *(void *)(*(void *)this - 24);
                  uint64_t v124 = *(void *)((char *)this + v123 + 80);
                  if (*(void *)((char *)this + v123 + 88) != v124)
                  {
                    unint64_t v125 = 0;
                    do
                    {
                      uint64_t v126 = *(void *)(v124 + 8 * v125);
                      if (*(void *)(v126 + 8) == v115 && *(void *)(v126 + 24) != 0)
                      {
                        *(void *)(v126 + 8) = OutRec;
                        uint64_t v123 = *(void *)(v122 - 24);
                      }
                      ++v125;
                      uint64_t v124 = *(void *)((char *)this + v123 + 80);
                    }
                    while (v125 < (*(void *)((char *)this + v123 + 88) - v124) >> 3);
                  }
                }
              }
            }
          }
        }
      }
      ++v111;
      uint64_t v110 = *((void *)this + 1);
    }
    while (v111 < (*((void *)this + 2) - v110) >> 3);
    uint64_t v6 = *(void *)this;
  }
  uint64_t v128 = *(void *)((char *)this + *(void *)(v6 - 24) + 80);
  if (*(void *)((char *)this + *(void *)(v6 - 24) + 88) != v128)
  {
    unint64_t v129 = 0;
    do
    {
      uint64_t v130 = *(void *)(v128 + 8 * v129);
      uint64_t v131 = *(void **)(v130 + 24);
      if (v131)
      {
        if (!*(unsigned char *)(v130 + 5))
        {
          *(void *)(v130 + 32) = 0;
          uint64_t v170 = v130;
          unint64_t v171 = v129;
          if (*((unsigned char *)this + *(void *)(v6 - 24) + 72)) {
            BOOL v136 = 1;
          }
          else {
            BOOL v136 = *((unsigned char *)this + 134) != 0;
          }
          BOOL v172 = v136;
          size_t v138 = v131 + 8;
          unint64_t v137 = (void *)v131[8];
          if (v137 != v131)
          {
            uint64_t v139 = 0;
            while (1)
            {
              char v140 = (void *)v131[7];
              if (v137 == v140) {
                break;
              }
              uint64_t v142 = v131[1];
              uint64_t v141 = v131[2];
              uint64_t v144 = v140[1];
              uint64_t v145 = v140[2];
              uint64_t v143 = v140 + 1;
              BOOL v146 = v142 == v144 && v141 == v145;
              char v147 = v146;
              if (v146) {
                goto LABEL_281;
              }
              uint64_t v148 = v137[1];
              uint64_t v149 = v137[2];
              if (v142 == v148 && v141 == v149) {
                goto LABEL_281;
              }
              CGPDFDictionaryRef v175 = v139;
              uint64_t v178 = v137[2];
              uint64_t v180 = v131[2];
              char v174 = v147;
              uint64_t v173 = v137[1];
              BOOL v151 = ClipperLib::SlopesEqual(v148, v149, v142, v141, v144, v145, v176[*(void *)(*(void *)this - 24)]);
              uint64_t v141 = v180;
              char v147 = v174;
              uint64_t v139 = v175;
              if (!v151) {
                goto LABEL_277;
              }
              if (!v172
                || (char IsBetweenPt1AndPt3 = ClipperLib::Pt2IsBetweenPt1AndPt3(v173, v178, v142, v180, v144, v145),
                    char v147 = v174,
                    uint64_t v141 = v180,
                    uint64_t v139 = v175,
                    (IsBetweenPt1AndPt3 & 1) == 0))
              {
LABEL_281:
                uint64_t v153 = v131[5];
                if (v153 != -1 && (v131[3] != v153 || *((double *)v131 + 4) != *((double *)v131 + 6)))
                {
                  if ((v147 & 1) != 0 || (uint64_t v143 = v137 + 1, v142 == v137[1]) && v141 == v137[2])
                  {
                    long long v154 = *(_OWORD *)(v131 + 1);
                    long long v155 = *(_OWORD *)(v131 + 5);
                    v143[1] = *(_OWORD *)(v131 + 3);
                    v143[2] = v155;
                    *uint64_t v143 = v154;
                    char v140 = (void *)v131[7];
                    unint64_t v137 = (void *)*v138;
                  }
                }
                v137[7] = v140;
                *(void *)(v131[7] + 64) = v137;
                char v140 = (void *)*v138;
                MEMORY[0x18532A2A0](v131, 0x1020C40EF4EB693);
                uint64_t v139 = 0;
              }
              else
              {
LABEL_277:
                if (v131 == v139) {
                  goto LABEL_293;
                }
                if (!v139) {
                  uint64_t v139 = v131;
                }
              }
              size_t v138 = v140 + 8;
              unint64_t v137 = (void *)v140[8];
              uint64_t v131 = v140;
              if (v137 == v140) {
                goto LABEL_292;
              }
            }
          }
          char v140 = v131;
LABEL_292:
          *(void *)&long long v189 = v140;
          ClipperLib::DisposeOutPts(&v189);
          uint64_t v139 = 0;
LABEL_293:
          unint64_t v129 = v171;
          *(void *)(v170 + 24) = v139;
          goto LABEL_294;
        }
        uint64_t v132 = (void *)v131[8];
        if (v131 == v132)
        {
          *(void *)&long long v189 = *(void *)(v130 + 24);
        }
        else
        {
          do
          {
            uint64_t v131 = (void *)v131[7];
            float v133 = (void *)v131[8];
            if (v131[1] == v133[1] && v131[2] == v133[2])
            {
              if (v131 == v132) {
                uint64_t v132 = (void *)v131[8];
              }
              v133[7] = v131[7];
              *(void *)(v131[7] + 64) = v133;
              MEMORY[0x18532A2A0](v131, 0x1020C40EF4EB693);
              uint64_t v131 = v133;
            }
          }
          while (v131 != v132);
          BOOL v135 = (void *)v131[8];
          *(void *)&long long v189 = v131;
          if (v131 != v135) {
            goto LABEL_294;
          }
        }
        ClipperLib::DisposeOutPts(&v189);
        *(void *)(v130 + 24) = 0;
      }
LABEL_294:
      ++v129;
      uint64_t v6 = *(void *)this;
      uint64_t v128 = *(void *)((char *)this + *(void *)(*(void *)this - 24) + 80);
    }
    while (v129 < (*(void *)((char *)this + *(void *)(*(void *)this - 24) + 88) - v128) >> 3);
  }
  if (*((unsigned char *)this + 134))
  {
    uint64_t v156 = *(void *)((char *)this + *(void *)(v6 - 24) + 80);
    if (*(void *)((char *)this + *(void *)(v6 - 24) + 88) != v156)
    {
      unint64_t v157 = 0;
      do
      {
        uint64_t v158 = *(void *)(v156 + 8 * v157);
        uint64_t v159 = *(void **)(v158 + 24);
        if (v159 && !*(unsigned char *)(v158 + 5))
        {
          uint64_t v160 = *(void **)(v158 + 24);
          do
          {
            if ((void *)v160[7] == v159) {
              break;
            }
            uint64_t v159 = (void *)v160[7];
            do
            {
              if (v160[1] == v159[1] && v160[2] == v159[2] && (void *)v159[7] != v160)
              {
                int v162 = (void *)v159[8];
                if (v162 != v160)
                {
                  uint64_t v163 = v160[8];
                  v160[8] = v162;
                  v162[7] = v160;
                  v159[8] = v163;
                  *(void *)(v163 + 56) = v159;
                  *(void *)(v158 + 24) = v160;
                  ClipperLib::ClipperBase::CreateOutRec((ClipperLib::Clipper *)((char *)this
                                                                              + *(void *)(*(void *)this - 24)));
                }
              }
              uint64_t v159 = (void *)v159[7];
            }
            while (v159 != *(void **)(v158 + 24));
            uint64_t v160 = (void *)v160[7];
          }
          while (v160 != v159);
          uint64_t v6 = *(void *)this;
        }
        ++v157;
        uint64_t v156 = *(void *)((char *)this + *(void *)(v6 - 24) + 80);
      }
      while (v157 < (*(void *)((char *)this + *(void *)(v6 - 24) + 88) - v156) >> 3);
    }
  }
  uint64_t v101 = 1;
LABEL_319:
  uint64_t v165 = *((void *)this + 1);
  uint64_t v166 = *((void *)this + 2);
  if (v166 != v165)
  {
    unint64_t v167 = 0;
    do
    {
      uint64_t v168 = *(void *)(v165 + 8 * v167);
      if (v168)
      {
        MEMORY[0x18532A2A0](v168, 0x1020C40038FC326);
        uint64_t v165 = *((void *)this + 1);
        uint64_t v166 = *((void *)this + 2);
      }
      ++v167;
    }
    while (v167 < (v166 - v165) >> 3);
    if (v166 != v165) {
      *((void *)this + 2) = v165;
    }
  }
  ClipperLib::Clipper::ClearGhostJoins((uint64_t)this);
  return v101;
}

void std::priority_queue<long long>::push(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void **)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = *(void **)a1;
    uint64_t v8 = ((uint64_t)v5 - *(void *)a1) >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        std::__throw_bad_array_new_length[abi:fe180100]();
      }
      long long v12 = (char *)operator new(8 * v11);
    }
    else
    {
      long long v12 = 0;
    }
    uint64_t v13 = &v12[8 * v8];
    *(void *)uint64_t v13 = a2;
    uint64_t v6 = v13 + 8;
    while (v5 != v7)
    {
      uint64_t v14 = *--v5;
      *((void *)v13 - 1) = v14;
      v13 -= 8;
    }
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v6;
    *(void *)(a1 + 16) = &v12[8 * v11];
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    *uint64_t v5 = a2;
    uint64_t v6 = v5 + 1;
  }
  *(void *)(a1 + 8) = v6;
  double v15 = *(void **)a1;
  uint64_t v16 = (uint64_t)v6 - *(void *)a1;
  if (v16 >= 9)
  {
    unint64_t v17 = (((unint64_t)v16 >> 3) - 2) >> 1;
    uint64_t v18 = &v15[v17];
    uint64_t v21 = *(v6 - 1);
    uint64_t v20 = v6 - 1;
    uint64_t v19 = v21;
    uint64_t v22 = *v18;
    if (*v18 < v21)
    {
      do
      {
        *uint64_t v20 = v22;
        uint64_t v20 = v18;
        if (!v17) {
          break;
        }
        unint64_t v17 = (v17 - 1) >> 1;
        uint64_t v18 = &v15[v17];
        uint64_t v22 = *v18;
      }
      while (*v18 < v19);
      *uint64_t v20 = v19;
    }
  }
}

void ClipperLib::Clipper::ProcessHorizontals(ClipperLib::Clipper *this)
{
  uint64_t v1 = (void *)((char *)this + 112);
  uint64_t v2 = (long long *)*((void *)this + 14);
  if (!v2) {
    return;
  }
  unint64_t v4 = (char *)this + 88;
  uint64_t v75 = (char *)this + 40;
  uint64_t v76 = (char *)this + 112;
  do
  {
    uint64_t v5 = *((void *)v2 + 27);
    uint64_t v6 = *((void *)v2 + 28);
    if (*(long long *)((char *)v2 + 216) == 0)
    {
      *uint64_t v1 = 0;
    }
    else
    {
      uint64_t v7 = (void *)(v6 + 216);
      if (!v6) {
        uint64_t v7 = v1;
      }
      *uint64_t v7 = v5;
      if (v5) {
        *(void *)(v5 + 224) = v6;
      }
    }
    *((void *)v2 + 27) = 0;
    *((void *)v2 + 28) = 0;
    v85[0] = v2;
    uint64_t v8 = *(void *)v2;
    uint64_t v9 = *((void *)v2 + 12);
    int v10 = *((_DWORD *)v2 + 40);
    BOOL v11 = *(void *)v2 < v9;
    if (*(void *)v2 >= v9) {
      uint64_t v12 = *((void *)v2 + 12);
    }
    else {
      uint64_t v12 = *(void *)v2;
    }
    if (*(void *)v2 < v9) {
      uint64_t v13 = *((void *)v2 + 12);
    }
    else {
      uint64_t v13 = *(void *)v2;
    }
    uint64_t v78 = v13;
    uint64_t v79 = v12;
    uint64_t v14 = v2;
    while (1)
    {
      uint64_t v81 = v14;
      uint64_t v14 = (long long *)*((void *)v14 + 24);
      if (!v14) {
        break;
      }
      if (*((double *)v14 + 18) != -1.0e40)
      {
        MaximaPair = 0;
        goto LABEL_20;
      }
    }
    MaximaPair = ClipperLib::GetMaximaPair(v81);
LABEL_20:
    if (!*((void *)this + 13))
    {
      double v15 = 0;
      goto LABEL_31;
    }
    double v15 = (char *)*((void *)this + 12);
    uint64_t v16 = v4;
    if (v8 >= v9)
    {
      while (v16 != v15)
      {
        uint64_t v18 = v16;
        uint64_t v16 = *(char **)v16;
        uint64_t v19 = *((void *)v16 + 2);
        if (v19 <= v8)
        {
          uint64_t v20 = 0;
          if (v19 > *((void *)v81 + 12)) {
            double v15 = v18;
          }
          goto LABEL_37;
        }
      }
LABEL_31:
      uint64_t v20 = 0;
      goto LABEL_37;
    }
    while (1)
    {
      if (v15 == v4)
      {
        double v15 = 0;
        BOOL v11 = 1;
        uint64_t v20 = v4;
        goto LABEL_37;
      }
      uint64_t v17 = *((void *)v15 + 2);
      if (v17 > v8) {
        break;
      }
      double v15 = (char *)*((void *)v15 + 1);
    }
    if (v17 >= *((void *)v81 + 12)) {
      uint64_t v20 = v4;
    }
    else {
      uint64_t v20 = v15;
    }
    BOOL v11 = 1;
    double v15 = 0;
    while (1)
    {
LABEL_37:
      uint64_t v21 = 208;
      if (v11) {
        uint64_t v21 = 200;
      }
      uint64_t v22 = *(void *)((char *)v2 + v21);
      if (v22)
      {
        int v80 = v2;
        while (1)
        {
          if (*((void *)this + 13))
          {
            if (v11)
            {
              if (v20 == v4)
              {
                uint64_t v20 = v4;
                goto LABEL_62;
              }
              while (*((void *)v20 + 2) < *(void *)(v22 + 48))
              {
                if ((*((_DWORD *)v2 + 43) & 0x80000000) == 0 && v10)
                {
                  uint64_t v23 = *((void *)v2 + 1);
                  *(void *)&long long v82 = *((void *)v20 + 2);
                  *((void *)&v82 + 1) = v23;
                  long long v83 = ClipperLib::PointInfoZero;
                  long long v84 = unk_1852101A0;
                  ClipperLib::Clipper::AddOutPt(this, (uint64_t)v2, &v82);
                }
                uint64_t v20 = (char *)*((void *)v20 + 1);
                if (v20 == v4)
                {
                  uint64_t v20 = v4;
                  break;
                }
              }
            }
            else
            {
              long long v24 = (char *)*((void *)this + 12);
              if (v15 == v24) {
                goto LABEL_59;
              }
              while (1)
              {
                unint64_t v25 = *(char **)v15;
                if (*(void *)(*(void *)v15 + 16) <= *(void *)(v22 + 48)) {
                  break;
                }
                if ((*((_DWORD *)v2 + 43) & 0x80000000) == 0 && v10)
                {
                  uint64_t v26 = *((void *)v2 + 1);
                  *(void *)&long long v82 = *(void *)(*(void *)v15 + 16);
                  *((void *)&v82 + 1) = v26;
                  long long v83 = ClipperLib::PointInfoZero;
                  long long v84 = unk_1852101A0;
                  ClipperLib::Clipper::AddOutPt(this, (uint64_t)v2, &v82);
                  unint64_t v25 = *(char **)v15;
                  long long v24 = (char *)*((void *)this + 12);
                }
                double v15 = v25;
                if (v25 == v24)
                {
                  double v15 = v24;
                  break;
                }
              }
            }
          }
          if (!v11)
          {
LABEL_59:
            uint64_t v27 = *(void *)(v22 + 48);
            if (v27 < v79) {
              goto LABEL_98;
            }
            goto LABEL_63;
          }
LABEL_62:
          uint64_t v27 = *(void *)(v22 + 48);
          if (v27 > v78) {
            goto LABEL_98;
          }
LABEL_63:
          uint64_t v28 = v85[0];
          if (v27 == *((void *)v85[0] + 12))
          {
            uint64_t v29 = *((void *)v85[0] + 24);
            if (v29)
            {
              if (*(double *)(v22 + 144) < *(double *)(v29 + 144)) {
                goto LABEL_98;
              }
            }
          }
          if ((*((_DWORD *)v85[0] + 43) & 0x80000000) == 0 && v10)
          {
            unint64_t v30 = (void (*)(long long *, long long *, uint64_t, uint64_t, uint64_t))*((void *)this + 17);
            if (v30)
            {
              v30(v85[0], v85[0] + 6, v22, v22 + 96, v22 + 48);
              uint64_t v28 = v85[0];
            }
            ClipperLib::Clipper::AddOutPt(this, (uint64_t)v28, (long long *)(v22 + 48));
            for (uint64_t i = *((void *)this + 14); i; uint64_t i = *(void *)(i + 216))
            {
              if ((*(_DWORD *)(i + 172) & 0x80000000) == 0)
              {
                uint64_t v32 = *(void *)v28;
                uint64_t v33 = *((void *)v28 + 12);
                uint64_t v34 = *(void *)i;
                uint64_t v35 = *(void *)(i + 96);
                if (*(void *)v28 >= v33) {
                  uint64_t v36 = *((void *)v28 + 12);
                }
                else {
                  uint64_t v36 = *(void *)v28;
                }
                if (*(void *)v28 <= v33) {
                  uint64_t v32 = *((void *)v28 + 12);
                }
                if (v34 >= v35) {
                  uint64_t v37 = *(void *)(i + 96);
                }
                else {
                  uint64_t v37 = *(void *)i;
                }
                if (v34 <= v35) {
                  uint64_t v34 = *(void *)(i + 96);
                }
                if (v36 < v34 && v37 < v32)
                {
                  ClipperLib::Clipper::GetLastOutPt(this, i);
                  ClipperLib::Clipper::AddJoin();
                }
              }
            }
            ClipperLib::Clipper::AddGhostJoin();
          }
          if (v80 == v81 && (void *)v22 == MaximaPair)
          {
            if ((*((_DWORD *)v85[0] + 43) & 0x80000000) == 0) {
              ClipperLib::Clipper::AddLocalMaxPoly(this, (uint64_t)v85[0], (uint64_t)MaximaPair, v85[0] + 6);
            }
            uint64_t v48 = *(void *)this;
            double v49 = (char *)this + *(void *)(*(void *)this - 24);
            uint64_t v50 = *((void *)v28 + 25);
            uint64_t v51 = *((void *)v28 + 26);
            uint64_t v1 = v76;
            if (*(long long *)((char *)v28 + 200) == 0)
            {
              if (*((long long **)v49 + 13) == v28) {
                goto LABEL_115;
              }
            }
            else
            {
              if (v51)
              {
                uint64_t v52 = (void *)(v51 + 200);
                goto LABEL_116;
              }
LABEL_115:
              uint64_t v52 = v49 + 104;
LABEL_116:
              void *v52 = v50;
              if (v50) {
                *(void *)(v50 + 208) = v51;
              }
              *((void *)v28 + 25) = 0;
              *((void *)v28 + 26) = 0;
              uint64_t v48 = *(void *)this;
            }
            __n128 v53 = (char *)this + *(void *)(v48 - 24);
            uint64_t v55 = MaximaPair[25];
            uint64_t v56 = MaximaPair[26];
            uint64_t v54 = MaximaPair + 25;
            if (*(_OWORD *)(MaximaPair + 25) == 0)
            {
              if (*((void **)v53 + 13) == MaximaPair) {
                goto LABEL_123;
              }
            }
            else
            {
LABEL_120:
              if (v56)
              {
                uint64_t v57 = (void *)(v56 + 200);
                goto LABEL_124;
              }
LABEL_123:
              uint64_t v57 = v53 + 104;
LABEL_124:
              *uint64_t v57 = v55;
              if (v55) {
                *(void *)(v55 + 208) = v56;
              }
              *uint64_t v54 = 0;
              v54[1] = 0;
            }
            goto LABEL_127;
          }
          uint64_t v39 = *((void *)v85[0] + 7);
          *(void *)&long long v82 = *(void *)(v22 + 48);
          *((void *)&v82 + 1) = v39;
          long long v83 = ClipperLib::PointInfoZero;
          long long v84 = unk_1852101A0;
          if (v11)
          {
            unint64_t v40 = v85[0];
            uint64_t v41 = (long long *)v22;
          }
          else
          {
            unint64_t v40 = (long long *)v22;
            uint64_t v41 = v85[0];
          }
          ClipperLib::Clipper::IntersectEdges((char *)this, v40, v41, &v82);
          uint64_t v42 = 208;
          if (v11) {
            uint64_t v42 = 200;
          }
          uint64_t v43 = *(void *)(v22 + v42);
          uint64_t v2 = v85[0];
          ClipperLib::ClipperBase::SwapPositionsInAEL((uint64_t)this + *(void *)(*(void *)this - 24), (uint64_t)v85[0], v22);
          uint64_t v22 = v43;
          if (!v43)
          {
LABEL_98:
            uint64_t v2 = v85[0];
            break;
          }
        }
      }
      uint64_t v44 = *((void *)v2 + 24);
      if (!v44 || *(double *)(v44 + 144) != -1.0e40) {
        break;
      }
      ClipperLib::ClipperBase::UpdateEdgeIntoAEL((uint64_t)this + *(void *)(*(void *)this - 24), (uint64_t *)v85);
      uint64_t v2 = v85[0];
      if ((*((_DWORD *)v85[0] + 43) & 0x80000000) == 0) {
        ClipperLib::Clipper::AddOutPt(this, (uint64_t)v85[0], v85[0]);
      }
      uint64_t v45 = *(void *)v2;
      uint64_t v46 = *((void *)v2 + 12);
      BOOL v11 = *(void *)v2 < v46;
      if (*(void *)v2 >= v46) {
        uint64_t v47 = *((void *)v2 + 12);
      }
      else {
        uint64_t v47 = *(void *)v2;
      }
      if (*(void *)v2 < v46) {
        uint64_t v45 = *((void *)v2 + 12);
      }
      uint64_t v78 = v45;
      uint64_t v79 = v47;
    }
    int v58 = *((_DWORD *)v2 + 43);
    if ((v58 & 0x80000000) == 0)
    {
      ClipperLib::Clipper::GetLastOutPt(this, (uint64_t)v2);
      for (uint64_t j = *((void *)this + 14); j; uint64_t j = *(void *)(j + 216))
      {
        if ((*(_DWORD *)(j + 172) & 0x80000000) == 0)
        {
          uint64_t v60 = *(void *)v2;
          uint64_t v61 = *((void *)v2 + 12);
          uint64_t v62 = *(void *)j;
          uint64_t v63 = *(void *)(j + 96);
          if (*(void *)v2 >= v61) {
            uint64_t v64 = *((void *)v2 + 12);
          }
          else {
            uint64_t v64 = *(void *)v2;
          }
          if (*(void *)v2 <= v61) {
            uint64_t v60 = *((void *)v2 + 12);
          }
          if (v62 >= v63) {
            uint64_t v65 = *(void *)(j + 96);
          }
          else {
            uint64_t v65 = *(void *)j;
          }
          if (v62 <= v63) {
            uint64_t v62 = *(void *)(j + 96);
          }
          if (v64 < v62 && v65 < v60)
          {
            ClipperLib::Clipper::GetLastOutPt(this, j);
            long long v67 = *(_OWORD *)(j + 112);
            long long v82 = *(_OWORD *)(j + 96);
            long long v83 = v67;
            long long v84 = *(_OWORD *)(j + 128);
            ClipperLib::Clipper::AddJoin();
          }
        }
      }
      ClipperLib::Clipper::AddGhostJoin();
    }
    uint64_t v1 = v76;
    if (v44)
    {
      if (v58 < 0)
      {
        ClipperLib::ClipperBase::UpdateEdgeIntoAEL((uint64_t)this + *(void *)(*(void *)this - 24), (uint64_t *)v85);
        goto LABEL_127;
      }
      ClipperLib::Clipper::AddOutPt(this, (uint64_t)v2, v2 + 6);
      ClipperLib::ClipperBase::UpdateEdgeIntoAEL((uint64_t)this + *(void *)(*(void *)this - 24), (uint64_t *)v85);
      CGFloat v68 = v85[0];
      if (!*((_DWORD *)v85[0] + 40)) {
        goto LABEL_127;
      }
      uint64_t v69 = *((void *)v85[0] + 25);
      uint64_t v70 = *((void *)v85[0] + 26);
      if (v70
        && *(void *)(v70 + 48) == *(void *)v85[0]
        && (uint64_t v71 = *(void *)(v70 + 56), v71 == *((void *)v85[0] + 1))
        && *(_DWORD *)(v70 + 160)
        && (*(_DWORD *)(v70 + 172) & 0x80000000) == 0
        && v71 > *(void *)(v70 + 104)
        && ClipperLib::SlopesEqual((void *)v85[0], *((void **)v85[0] + 26), v75[*(void *)(*(void *)this - 24)]))
      {
        uint64_t v72 = this;
        uint64_t v73 = v70;
      }
      else
      {
        if (!v69) {
          goto LABEL_127;
        }
        if (*(void *)(v69 + 48) != *(void *)v68) {
          goto LABEL_127;
        }
        uint64_t v74 = *(void *)(v69 + 56);
        if (v74 != *((void *)v68 + 1)
          || !*(_DWORD *)(v69 + 160)
          || (*(_DWORD *)(v69 + 172) & 0x80000000) != 0
          || v74 <= *(void *)(v69 + 104)
          || !ClipperLib::SlopesEqual(v68, (void *)v69, v75[*(void *)(*(void *)this - 24)]))
        {
          goto LABEL_127;
        }
        uint64_t v72 = this;
        uint64_t v73 = v69;
      }
      ClipperLib::Clipper::AddOutPt(v72, v73, v68);
      ClipperLib::Clipper::AddJoin();
    }
    if ((v58 & 0x80000000) == 0) {
      ClipperLib::Clipper::AddOutPt(this, (uint64_t)v2, v2 + 6);
    }
    __n128 v53 = (char *)this + *(void *)(*(void *)this - 24);
    uint64_t v55 = *((void *)v2 + 25);
    uint64_t v56 = *((void *)v2 + 26);
    uint64_t v54 = (void *)v2 + 25;
    if (*(long long *)((char *)v2 + 200) != 0) {
      goto LABEL_120;
    }
    if (*((long long **)v53 + 13) == v2) {
      goto LABEL_123;
    }
LABEL_127:
    uint64_t v2 = (long long *)*v1;
  }
  while (*v1);
}

void ClipperLib::ClipperBase::UpdateEdgeIntoAEL(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(*a2 + 192);
  if (!v3)
  {
    exception = (ClipperLib::clipperException *)__cxa_allocate_exception(0x20uLL);
    ClipperLib::clipperException::clipperException(exception, "UpdateEdgeIntoAEL: invalid call");
  }
  *(_DWORD *)(v3 + 172) = *(_DWORD *)(v2 + 172);
  uint64_t v6 = v2 + 200;
  uint64_t v5 = *(void *)(v2 + 200);
  uint64_t v4 = *(void *)(v6 + 8);
  uint64_t v7 = (void *)(a1 + 104);
  if (v4) {
    uint64_t v7 = (void *)(v4 + 200);
  }
  *uint64_t v7 = v3;
  if (v5) {
    *(void *)(v5 + 208) = *(void *)(*a2 + 192);
  }
  uint64_t v8 = *(_OWORD **)(*a2 + 192);
  *(_OWORD *)((char *)v8 + 156) = *(_OWORD *)(*a2 + 156);
  *a2 = (uint64_t)v8;
  long long v9 = v8[1];
  v8[3] = *v8;
  v8[4] = v9;
  void v8[5] = v8[2];
  *(void *)(*a2 + 208) = v4;
  *(void *)(*a2 + 200) = v5;
  if (*(double *)(*a2 + 144) != -1.0e40)
  {
    uint64_t v10 = *(void *)(*a2 + 104);
    uint64_t v11 = a1 + 112;
    std::priority_queue<long long>::push(v11, v10);
  }
}

void sub_184CA3184(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *std::__list_imp<long long>::clear(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    BOOL result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        BOOL result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

BOOL ClipperLib::ClipperBase::PopScanbeam(ClipperLib::ClipperBase *this, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 14);
  uint64_t v3 = (uint64_t *)*((void *)this + 15);
  if (v2 != v3)
  {
    *a2 = *v2;
    uint64_t v4 = (char *)v3 - (char *)v2;
    if ((char *)v3 - (char *)v2 >= 9)
    {
      uint64_t v5 = 0;
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = *v2;
      int64_t v8 = (unint64_t)((v4 >> 3) - 2) >> 1;
      long long v9 = v2;
      do
      {
        uint64_t v10 = &v9[v5 + 1];
        uint64_t v11 = (2 * v5) | 1;
        uint64_t v5 = 2 * v5 + 2;
        if (v5 >= v6)
        {
          uint64_t v12 = *v10;
          uint64_t v5 = v11;
        }
        else
        {
          uint64_t v12 = *v10;
          uint64_t v13 = v10[1];
          if (*v10 <= v13) {
            uint64_t v12 = v10[1];
          }
          if (*v10 >= v13) {
            uint64_t v5 = v11;
          }
          else {
            ++v10;
          }
        }
        *long long v9 = v12;
        long long v9 = v10;
      }
      while (v5 <= v8);
      uint64_t v14 = v3 - 1;
      if (v10 == v3 - 1)
      {
        *uint64_t v10 = v7;
      }
      else
      {
        *uint64_t v10 = *v14;
        *uint64_t v14 = v7;
        uint64_t v15 = (char *)v10 - (char *)v2 + 8;
        if (v15 >= 9)
        {
          unint64_t v16 = (((unint64_t)v15 >> 3) - 2) >> 1;
          uint64_t v17 = &v2[v16];
          uint64_t v18 = *v17;
          uint64_t v19 = *v10;
          if (*v17 < *v10)
          {
            do
            {
              *uint64_t v10 = v18;
              uint64_t v10 = v17;
              if (!v16) {
                break;
              }
              unint64_t v16 = (v16 - 1) >> 1;
              uint64_t v17 = &v2[v16];
              uint64_t v18 = *v17;
            }
            while (*v17 < v19);
            *uint64_t v10 = v19;
          }
        }
      }
    }
    uint64_t v20 = v3 - 1;
    if (v2 == v3 - 1)
    {
LABEL_40:
      uint64_t v21 = v2;
    }
    else
    {
      uint64_t v21 = v3;
      while (1)
      {
        uint64_t v22 = v21;
        uint64_t v21 = v20;
        uint64_t v23 = *a2;
        if (*a2 != *v2) {
          break;
        }
        uint64_t v24 = (char *)v20 - (char *)v2;
        if ((char *)v21 - (char *)v2 >= 9)
        {
          uint64_t v25 = 0;
          uint64_t v26 = v24 >> 3;
          int64_t v27 = (unint64_t)((v24 >> 3) - 2) >> 1;
          uint64_t v28 = v2;
          do
          {
            uint64_t v29 = &v28[v25 + 1];
            uint64_t v30 = (2 * v25) | 1;
            uint64_t v25 = 2 * v25 + 2;
            if (v25 >= v26)
            {
              uint64_t v31 = *v29;
              uint64_t v25 = v30;
            }
            else
            {
              uint64_t v31 = *v29;
              uint64_t v32 = v29[1];
              if (*v29 <= v32) {
                uint64_t v31 = v29[1];
              }
              if (*v29 >= v32) {
                uint64_t v25 = v30;
              }
              else {
                ++v29;
              }
            }
            *uint64_t v28 = v31;
            uint64_t v28 = v29;
          }
          while (v25 <= v27);
          uint64_t v33 = v22 - 2;
          if (v29 == v33)
          {
            *uint64_t v29 = v23;
          }
          else
          {
            *uint64_t v29 = *v33;
            *uint64_t v33 = v23;
            uint64_t v34 = (char *)v29 - (char *)v2 + 8;
            if (v34 >= 9)
            {
              unint64_t v35 = (((unint64_t)v34 >> 3) - 2) >> 1;
              uint64_t v36 = &v2[v35];
              uint64_t v37 = *v36;
              uint64_t v38 = *v29;
              if (*v36 < *v29)
              {
                do
                {
                  *uint64_t v29 = v37;
                  uint64_t v29 = v36;
                  if (!v35) {
                    break;
                  }
                  unint64_t v35 = (v35 - 1) >> 1;
                  uint64_t v36 = &v2[v35];
                  uint64_t v37 = *v36;
                }
                while (*v36 < v38);
                *uint64_t v29 = v38;
              }
            }
          }
        }
        uint64_t v20 = v21 - 1;
        if (v2 == v21 - 1) {
          goto LABEL_40;
        }
      }
    }
    *((void *)this + 15) = v21;
  }
  return v2 != v3;
}

void ClipperLib::Clipper::InsertLocalMinimaIntoAEL(ClipperLib::Clipper *this, uint64_t a2)
{
  uint64_t v2 = (char *)this + 40;
  uint64_t v3 = (char *)this + *(void *)(*(void *)this - 24);
  uint64_t v6 = (void *)*((void *)v3 + 1);
  uint64_t v4 = v3 + 8;
  uint64_t v5 = v6;
  if (v6 != (void *)v4[2])
  {
    long long v9 = (uint64_t *)((char *)this + 112);
    do
    {
      if (*v5 != a2) {
        return;
      }
      *uint64_t v4 = v5 + 3;
      uint64_t v10 = v5[1];
      uint64_t v11 = v5[2];
      if (v10)
      {
        ClipperLib::Clipper::InsertEdgeIntoAEL((uint64_t *)this, v5[1], 0);
        if (!v11)
        {
          ClipperLib::Clipper::SetWindingCount((uint64_t)this, v10);
          if (ClipperLib::Clipper::IsContributing((uint64_t)this, (_DWORD *)v10)) {
            ClipperLib::Clipper::AddOutPt(this, v10, (long long *)v10);
          }
          std::priority_queue<long long>::push((uint64_t)v9 + *(void *)(*(void *)this - 24), *(void *)(v10 + 104));
          goto LABEL_64;
        }
        ClipperLib::Clipper::InsertEdgeIntoAEL((uint64_t *)this, v11, v10);
        ClipperLib::Clipper::SetWindingCount((uint64_t)this, v10);
        *(void *)(v11 + 164) = *(void *)(v10 + 164);
        if (ClipperLib::Clipper::IsContributing((uint64_t)this, (_DWORD *)v10)) {
          uint64_t v12 = ClipperLib::Clipper::AddLocalMinPoly(this, v10, v11, v10);
        }
        else {
          uint64_t v12 = 0;
        }
        std::priority_queue<long long>::push((uint64_t)v9 + *(void *)(*(void *)this - 24), *(void *)(v10 + 104));
      }
      else
      {
        ClipperLib::Clipper::InsertEdgeIntoAEL((uint64_t *)this, v5[2], 0);
        ClipperLib::Clipper::SetWindingCount((uint64_t)this, v11);
        uint64_t v12 = 0;
        if (ClipperLib::Clipper::IsContributing((uint64_t)this, (_DWORD *)v11)) {
          uint64_t v12 = ClipperLib::Clipper::AddOutPt(this, v11, (long long *)v11);
        }
        if (!v11) {
          goto LABEL_64;
        }
      }
      uint64_t v13 = v11;
      if (*(double *)(v11 + 144) != -1.0e40) {
        goto LABEL_21;
      }
      uint64_t v14 = *v9;
      *(void *)(v11 + 224) = 0;
      if (v14) {
        *(void *)(v14 + 224) = v11;
      }
      *long long v9 = v11;
      *(void *)(v11 + 216) = v14;
      uint64_t v13 = *(void *)(v11 + 192);
      if (v13) {
LABEL_21:
      }
        std::priority_queue<long long>::push((uint64_t)v9 + *(void *)(*(void *)this - 24), *(void *)(v13 + 104));
      if (v10)
      {
        if (v12)
        {
          if (*(double *)(v11 + 144) == -1.0e40)
          {
            uint64_t v16 = *((void *)this + 4);
            uint64_t v15 = *((void *)this + 5);
            if (v15 != v16)
            {
              if (*(_DWORD *)(v11 + 160))
              {
                unint64_t v17 = 0;
                do
                {
                  uint64_t v18 = *(void **)(v16 + 8 * v17);
                  uint64_t v19 = *(void *)(*v18 + 8);
                  uint64_t v20 = v18[2];
                  uint64_t v21 = *(void *)v11;
                  uint64_t v22 = *(void *)(v11 + 96);
                  if (v19 >= v20) {
                    uint64_t v23 = v18[2];
                  }
                  else {
                    uint64_t v23 = *(void *)(*v18 + 8);
                  }
                  if (v19 <= v20) {
                    uint64_t v19 = v18[2];
                  }
                  if (v21 >= v22) {
                    uint64_t v24 = *(void *)(v11 + 96);
                  }
                  else {
                    uint64_t v24 = *(void *)v11;
                  }
                  if (v21 <= v22) {
                    uint64_t v21 = *(void *)(v11 + 96);
                  }
                  if (v23 < v21 && v24 < v19) {
                    ClipperLib::Clipper::AddJoin();
                  }
                  ++v17;
                }
                while (v17 < (v15 - v16) >> 3);
              }
            }
          }
        }
        if ((*(_DWORD *)(v10 + 172) & 0x80000000) == 0)
        {
          uint64_t v26 = *(void *)(v10 + 208);
          if (v26)
          {
            if (*(void *)(v26 + 48) == *(void *)v10
              && (*(_DWORD *)(v26 + 172) & 0x80000000) == 0
              && ClipperLib::SlopesEqual(*(void *)v26, *(void *)(v26 + 8), *(void *)(v26 + 96), *(void *)(v26 + 104), *(void *)(v10 + 48), *(void *)(v10 + 56), *(void *)(v10 + 96), *(void *)(v10 + 104), v2[*(void *)(*(void *)this - 24)])&& *(_DWORD *)(v10 + 160)&& *(_DWORD *)(v26 + 160))
            {
              ClipperLib::Clipper::AddOutPt(this, v26, (long long *)v10);
              ClipperLib::Clipper::AddJoin();
            }
          }
        }
        uint64_t v27 = *(void *)(v10 + 200);
        if (v27 != v11)
        {
          if ((*(_DWORD *)(v11 + 172) & 0x80000000) == 0)
          {
            uint64_t v28 = *(void *)(v11 + 208);
            if ((*(_DWORD *)(v28 + 172) & 0x80000000) == 0
              && ClipperLib::SlopesEqual(*(void *)(v28 + 48), *(void *)(v28 + 56), *(void *)(v28 + 96), *(void *)(v28 + 104), *(void *)(v11 + 48), *(void *)(v11 + 56), *(void *)(v11 + 96), *(void *)(v11 + 104), v2[*(void *)(*(void *)this - 24)])&& *(_DWORD *)(v11 + 160)&& *(_DWORD *)(v28 + 160))
            {
              ClipperLib::Clipper::AddOutPt(this, v28, (long long *)v11);
              ClipperLib::Clipper::AddJoin();
            }
          }
          if (v27 && v27 != v11)
          {
            uint64_t v29 = (long long *)(v10 + 48);
            do
            {
              ClipperLib::Clipper::IntersectEdges((char *)this, (_DWORD *)v11, (_DWORD *)v27, v29);
              uint64_t v27 = *(void *)(v27 + 200);
            }
            while (v27 != v11);
          }
        }
      }
LABEL_64:
      uint64_t v30 = (char *)this + *(void *)(*(void *)this - 24);
      uint64_t v31 = (void *)*((void *)v30 + 1);
      uint64_t v4 = v30 + 8;
      uint64_t v5 = v31;
    }
    while (v31 != (void *)v4[2]);
  }
}

uint64_t ClipperLib::Clipper::ClearGhostJoins(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 32);
  uint64_t v2 = *(void *)(this + 40);
  if (v2 != v1)
  {
    uint64_t v3 = this;
    unint64_t v4 = 0;
    do
    {
      this = *(void *)(v1 + 8 * v4);
      if (this)
      {
        this = MEMORY[0x18532A2A0](this, 0x1020C40038FC326);
        uint64_t v1 = *(void *)(v3 + 32);
        uint64_t v2 = *(void *)(v3 + 40);
      }
      ++v4;
    }
    while (v4 < (v2 - v1) >> 3);
    if (v2 != v1) {
      *(void *)(v3 + 40) = v1;
    }
  }
  return this;
}

uint64_t *std::list<long long>::__sort<std::__less<void,void>>(uint64_t *result, uint64_t *a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      unint64_t v4 = (uint64_t *)*a2;
      if (*(void *)(*a2 + 16) < result[2])
      {
        uint64_t v5 = *v4;
        *(void *)(v5 + 8) = v4[1];
        *(void *)v4[1] = v5;
        uint64_t v6 = *result;
        *(void *)(v6 + 8) = v4;
        *unint64_t v4 = v6;
        *BOOL result = (uint64_t)v4;
        v4[1] = (uint64_t)result;
        return v4;
      }
    }
    else
    {
      unint64_t v8 = a3 >> 1;
      unint64_t v9 = (a3 >> 1) + 1;
      uint64_t v10 = result;
      do
      {
        uint64_t v10 = (uint64_t *)v10[1];
        --v9;
      }
      while (v9 > 1);
      uint64_t v11 = (uint64_t *)std::list<long long>::__sort<std::__less<void,void>>(result, v10, a3 >> 1);
      BOOL result = (uint64_t *)std::list<long long>::__sort<std::__less<void,void>>(v10, a2, a3 - v8);
      uint64_t v12 = v11[2];
      if (result[2] >= v12)
      {
        uint64_t v14 = (uint64_t *)v11[1];
        uint64_t i = result;
        BOOL result = v11;
      }
      else
      {
        for (uint64_t i = (uint64_t *)result[1]; i != a2; uint64_t i = (uint64_t *)i[1])
        {
          if (i[2] >= v12) {
            goto LABEL_14;
          }
        }
        uint64_t i = a2;
LABEL_14:
        uint64_t v15 = *i;
        uint64_t v16 = *result;
        *(void *)(v16 + 8) = *(void *)(*i + 8);
        **(void **)(v15 + 8) = v16;
        uint64_t v17 = *v11;
        uint64_t v14 = (uint64_t *)v11[1];
        *(void *)(v17 + 8) = result;
        *BOOL result = v17;
        *uint64_t v11 = v15;
        *(void *)(v15 + 8) = v11;
      }
      if (v14 != i && i != a2)
      {
        uint64_t v18 = i;
        do
        {
          uint64_t v19 = v14[2];
          if (i[2] >= v19)
          {
            uint64_t v14 = (uint64_t *)v14[1];
          }
          else
          {
            for (uint64_t j = (uint64_t *)i[1]; j != a2; uint64_t j = (uint64_t *)j[1])
            {
              if (j[2] >= v19) {
                goto LABEL_25;
              }
            }
            uint64_t j = a2;
LABEL_25:
            uint64_t v21 = *j;
            uint64_t v22 = *i;
            *(void *)(v22 + 8) = *(void *)(*j + 8);
            **(void **)(v21 + 8) = v22;
            if (v18 == i) {
              uint64_t v18 = j;
            }
            uint64_t v24 = *v14;
            uint64_t v23 = (uint64_t *)v14[1];
            *(void *)(v24 + 8) = i;
            *uint64_t i = v24;
            *uint64_t v14 = v21;
            *(void *)(v21 + 8) = v14;
            uint64_t v14 = v23;
            uint64_t i = j;
          }
        }
        while (v14 != v18 && i != a2);
      }
    }
  }
  return result;
}

char *ClipperLib::Clipper::AddOutPt(void *a1, uint64_t a2, long long *a3)
{
  unint64_t v3 = *(unsigned int *)(a2 + 172);
  BOOL result = (char *)a1 + *(void *)(*a1 - 24);
  if ((v3 & 0x80000000) != 0) {
    ClipperLib::ClipperBase::CreateOutRec((ClipperLib::ClipperBase *)result);
  }
  uint64_t v5 = *((void *)result + 10);
  if (v3 >= (*((void *)result + 11) - v5) >> 3)
  {
    __break(1u);
  }
  else
  {
    uint64_t v6 = *(void *)(*(void *)(v5 + 8 * v3) + 24);
    if (*(_DWORD *)(a2 + 156) == 1)
    {
      if (*(void *)a3 != *(void *)(v6 + 8) || *((void *)a3 + 1) != *(void *)(v6 + 16)) {
        goto LABEL_19;
      }
      uint64_t v8 = *((void *)a3 + 4);
      if (v8 != -1 && (*((void *)a3 + 2) != v8 || *((double *)a3 + 3) != *((double *)a3 + 5)))
      {
        long long v9 = *a3;
        long long v10 = a3[2];
        *(_OWORD *)(v6 + 24) = a3[1];
        *(_OWORD *)(v6 + 40) = v10;
        *(_OWORD *)(v6 + 8) = v9;
      }
      return (char *)v6;
    }
    else
    {
      BOOL result = *(char **)(v6 + 64);
      if (*(void *)a3 != *((void *)result + 1) || *((void *)a3 + 1) != *((void *)result + 2)) {
LABEL_19:
      }
        operator new();
      uint64_t v12 = *((void *)a3 + 4);
      if (v12 != -1 && (*((void *)a3 + 2) != v12 || *((double *)a3 + 3) != *((double *)a3 + 5)))
      {
        long long v13 = *a3;
        long long v14 = a3[2];
        *(_OWORD *)(result + 24) = a3[1];
        *(_OWORD *)(result + 40) = v14;
        *(_OWORD *)(result + 8) = v13;
        return *(char **)(v6 + 64);
      }
    }
  }
  return result;
}

uint64_t *ClipperLib::Clipper::InsertEdgeIntoAEL(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  if (!*(uint64_t *)((char *)result + *(void *)(*result - 24) + 104))
  {
    *(void *)(a2 + 200) = 0;
    *(void *)(a2 + 208) = 0;
LABEL_43:
    uint64_t v16 = (uint64_t *)((char *)result + *(void *)(v3 - 24) + 104);
    goto LABEL_44;
  }
  if (!a3)
  {
    a3 = *(uint64_t *)((char *)result + *(void *)(*result - 24) + 104);
    uint64_t v18 = *(void *)(a2 + 48);
    uint64_t v19 = *(void *)(a3 + 48);
    BOOL v20 = v18 < v19;
    if (v18 == v19)
    {
      uint64_t v21 = *(void *)(a2 + 104);
      uint64_t v22 = *(void *)(a3 + 104);
      if (v21 <= v22)
      {
        if (v21 == v22)
        {
          uint64_t v25 = *(void *)(a2 + 96);
        }
        else
        {
          double v26 = *(double *)(a2 + 144) * (double)(v22 - *(void *)(a2 + 8));
          double v27 = 0.5;
          if (v26 < 0.0) {
            double v27 = -0.5;
          }
          uint64_t v25 = *(void *)a2 + (uint64_t)(v26 + v27);
        }
        if (*(void *)(a3 + 96) <= v25) {
          goto LABEL_3;
        }
LABEL_42:
        *(void *)(a2 + 208) = 0;
        *(void *)(a2 + 200) = *(uint64_t *)((char *)result + *(void *)(v3 - 24) + 104);
        *(void *)(*(uint64_t *)((char *)result + *(void *)(v3 - 24) + 104) + 208) = a2;
        goto LABEL_43;
      }
      double v23 = *(double *)(a3 + 144) * (double)(v21 - *(void *)(a3 + 8));
      double v24 = 0.5;
      if (v23 < 0.0) {
        double v24 = -0.5;
      }
      BOOL v20 = *(void *)(a2 + 96) < *(void *)a3 + (uint64_t)(v23 + v24);
    }
    if (!v20) {
      goto LABEL_3;
    }
    goto LABEL_42;
  }
LABEL_3:
  uint64_t v4 = *(void *)(a3 + 200);
  if (v4)
  {
    uint64_t v5 = *(void *)(a2 + 48);
    uint64_t v6 = a3;
    while (1)
    {
      a3 = v6;
      uint64_t v6 = v4;
      uint64_t v7 = *(void *)(v4 + 48);
      BOOL v8 = v5 < v7;
      if (v5 == v7)
      {
        uint64_t v9 = *(void *)(a2 + 104);
        uint64_t v10 = *(void *)(v6 + 104);
        if (v9 <= v10)
        {
          if (v9 == v10)
          {
            uint64_t v13 = *(void *)(a2 + 96);
          }
          else
          {
            double v14 = *(double *)(a2 + 144) * (double)(v10 - *(void *)(a2 + 8));
            if (v14 >= 0.0) {
              double v15 = 0.5;
            }
            else {
              double v15 = -0.5;
            }
            uint64_t v13 = *(void *)a2 + (uint64_t)(v14 + v15);
          }
          if (*(void *)(v6 + 96) > v13) {
            goto LABEL_24;
          }
          goto LABEL_21;
        }
        double v11 = *(double *)(v6 + 144) * (double)(v9 - *(void *)(v6 + 8));
        if (v11 >= 0.0) {
          double v12 = 0.5;
        }
        else {
          double v12 = -0.5;
        }
        BOOL v8 = *(void *)(a2 + 96) < *(void *)v6 + (uint64_t)(v11 + v12);
      }
      if (v8) {
        goto LABEL_24;
      }
LABEL_21:
      uint64_t v4 = *(void *)(v6 + 200);
      if (!v4)
      {
        a3 = v6;
        break;
      }
    }
  }
  uint64_t v6 = 0;
LABEL_24:
  *(void *)(a2 + 200) = v6;
  uint64_t v16 = (void *)(a3 + 200);
  uint64_t v17 = *(void *)(a3 + 200);
  if (v17) {
    *(void *)(v17 + 208) = a2;
  }
  *(void *)(a2 + 208) = a3;
LABEL_44:
  *uint64_t v16 = a2;
  return result;
}

void *ClipperLib::GetMaximaPair(void *a1)
{
  BOOL result = (void *)a1[22];
  uint64_t v4 = a1[12];
  uint64_t v3 = a1[13];
  BOOL v5 = result[12] == v4 && result[13] == v3;
  if (!v5 || result[24])
  {
    BOOL result = (void *)a1[23];
    BOOL v6 = result[12] == v4 && result[13] == v3;
    if (!v6 || result[24]) {
      return 0;
    }
  }
  return result;
}

uint64_t ClipperLib::Clipper::IsContributing(uint64_t a1, _DWORD *a2)
{
  int v2 = a2[38];
  uint64_t v3 = 124;
  if (v2) {
    uint64_t v4 = 124;
  }
  else {
    uint64_t v4 = 128;
  }
  if (v2) {
    uint64_t v3 = 128;
  }
  unsigned int v5 = *(_DWORD *)(a1 + v3);
  int v6 = *(_DWORD *)(a1 + v4);
  switch(v6)
  {
    case 2:
LABEL_10:
      int v7 = a2[41];
      goto LABEL_13;
    case 1:
      int v7 = a2[41];
      if (v7 < 0) {
        int v7 = -v7;
      }
LABEL_13:
      if (v7 == 1) {
        goto LABEL_14;
      }
      return 0;
    case 0:
      if (a2[40]) {
        goto LABEL_14;
      }
      goto LABEL_10;
  }
  if (a2[41] != -1) {
    return 0;
  }
LABEL_14:
  switch(*(_DWORD *)(a1 + 80))
  {
    case 0:
      BOOL v8 = v5 == 2;
      if (v5 >= 2) {
        goto LABEL_21;
      }
      return a2[42] != 0;
    case 1:
      goto LABEL_26;
    case 2:
      BOOL v8 = v5 == 2;
      if (v2)
      {
        if (v5 < 2) {
          return a2[42] != 0;
        }
LABEL_21:
        if (v8) {
          return a2[42] > 0;
        }
        unsigned int v10 = a2[42];
      }
      else
      {
        if (v5 < 2) {
          return a2[42] == 0;
        }
LABEL_29:
        if (v8) {
          return a2[42] < 1;
        }
        unsigned int v10 = ~a2[42];
      }
      uint64_t result = v10 >> 31;
      break;
    case 3:
      if (a2[40]) {
        return 1;
      }
LABEL_26:
      BOOL v8 = v5 == 2;
      if (v5 < 2) {
        return a2[42] == 0;
      }
      goto LABEL_29;
    default:
      return 1;
  }
  return result;
}

uint64_t ClipperLib::Clipper::SwapPositionsInSEL(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 216);
  if (!v3 && !*(void *)(a2 + 224)) {
    return result;
  }
  uint64_t v4 = *(void *)(a3 + 216);
  if (!v4)
  {
    int v6 = (void *)(a3 + 224);
    uint64_t v7 = *(void *)(a3 + 224);
    if (!v7) {
      return result;
    }
    if (v3 != a3)
    {
      uint64_t v5 = *(void *)(a2 + 224);
      *(void *)(a2 + 216) = 0;
      *(void *)(a2 + 224) = v7;
LABEL_11:
      *(void *)(v7 + 216) = a2;
      goto LABEL_12;
    }
LABEL_17:
    uint64_t v8 = *(void *)(a2 + 224);
    if (v8) {
      *(void *)(v8 + 216) = a3;
    }
    *(void *)(a3 + 216) = a2;
    *(void *)(a3 + 224) = v8;
    *(void *)(a2 + 216) = v4;
    *(void *)(a2 + 224) = a3;
    goto LABEL_25;
  }
  if (v3 == a3)
  {
    *(void *)(v4 + 224) = a2;
    goto LABEL_17;
  }
  if (v4 == a2)
  {
    if (v3) {
      *(void *)(v3 + 224) = a3;
    }
    uint64_t v9 = *(void *)(a3 + 224);
    if (v9) {
      *(void *)(v9 + 216) = a2;
    }
    *(void *)(a2 + 216) = a3;
    *(void *)(a2 + 224) = v9;
    *(void *)(a3 + 216) = v3;
    *(void *)(a3 + 224) = a2;
    goto LABEL_25;
  }
  uint64_t v5 = *(void *)(a2 + 224);
  *(void *)(v4 + 224) = a2;
  int v6 = (void *)(a3 + 224);
  uint64_t v7 = *(void *)(a3 + 224);
  *(void *)(a2 + 216) = v4;
  *(void *)(a2 + 224) = v7;
  if (v7) {
    goto LABEL_11;
  }
LABEL_12:
  *(void *)(a3 + 216) = v3;
  if (v3) {
    *(void *)(v3 + 224) = a3;
  }
  *int v6 = v5;
  if (v5) {
    *(void *)(v5 + 216) = a3;
  }
LABEL_25:
  if (!*(void *)(a2 + 224) || (a2 = a3, !*(void *)(a3 + 224))) {
    *(void *)(result + 112) = a2;
  }
  return result;
}

uint64_t ClipperLib::Clipper::SetWindingCount(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 208);
  int v3 = *(_DWORD *)(a2 + 152);
  if (v2)
  {
    while (1)
    {
      if (*(_DWORD *)(v2 + 152) == v3)
      {
        int v4 = *(_DWORD *)(v2 + 160);
        if (v4) {
          break;
        }
      }
      uint64_t v2 = *(void *)(v2 + 208);
      if (!v2) {
        goto LABEL_5;
      }
    }
    unsigned int v9 = *(_DWORD *)(a2 + 160);
    if (v9)
    {
      uint64_t v10 = 124;
      if (!v3) {
        uint64_t v10 = 128;
      }
      if (!*(_DWORD *)(result + v10)) {
        goto LABEL_45;
      }
      int v11 = *(_DWORD *)(v2 + 164);
      if (((v11 * v4) & 0x80000000) == 0)
      {
        if (((v9 * v4) & 0x80000000) == 0) {
          int v12 = *(_DWORD *)(a2 + 160);
        }
        else {
          int v12 = 0;
        }
        unsigned int v9 = v11 + v12;
        goto LABEL_45;
      }
LABEL_28:
      if (v11 >= 0) {
        unsigned int v14 = v11;
      }
      else {
        unsigned int v14 = -v11;
      }
      if (v9 <= 1) {
        int v15 = 1;
      }
      else {
        int v15 = *(_DWORD *)(a2 + 160);
      }
      if (((v9 * v4) & 0x80000000) == 0) {
        int v16 = *(_DWORD *)(a2 + 160);
      }
      else {
        int v16 = 0;
      }
      unsigned int v17 = v11 + v16;
      if (v14 >= 2) {
        unsigned int v9 = v17;
      }
      else {
        unsigned int v9 = v15;
      }
      goto LABEL_45;
    }
    if (*(_DWORD *)(result + 80) == 1)
    {
      uint64_t v13 = 124;
      if (!v3) {
        uint64_t v13 = 128;
      }
      if (!*(_DWORD *)(result + v13))
      {
        uint64_t v18 = *(void *)(v2 + 208);
        for (i = 1; v18; uint64_t v18 = *(void *)(v18 + 208))
        {
          if (*(_DWORD *)(v18 + 152) == v3) {
            i ^= *(_DWORD *)(v18 + 160) != 0;
          }
        }
        unsigned int v9 = (i & 1) == 0;
        goto LABEL_45;
      }
      int v11 = *(_DWORD *)(v2 + 164);
      if (v11 * v4 < 0) {
        goto LABEL_28;
      }
      unsigned int v9 = ((v11 >> 31) | 1) + v11;
    }
    else
    {
      unsigned int v9 = 1;
    }
LABEL_45:
    int v7 = *(_DWORD *)(v2 + 168);
    *(_DWORD *)(a2 + 164) = v9;
    *(_DWORD *)(a2 + 168) = v7;
    uint64_t v8 = (uint64_t *)(v2 + 200);
    goto LABEL_46;
  }
LABEL_5:
  int v5 = *(_DWORD *)(a2 + 160);
  if (!v5)
  {
    uint64_t v6 = 124;
    if (!v3) {
      uint64_t v6 = 128;
    }
    if (*(_DWORD *)(result + v6) == 3) {
      int v5 = -1;
    }
    else {
      int v5 = 1;
    }
  }
  int v7 = 0;
  *(_DWORD *)(a2 + 164) = v5;
  *(_DWORD *)(a2 + 168) = 0;
  uint64_t v8 = (uint64_t *)(result + *(void *)(*(void *)result - 24) + 104);
LABEL_46:
  uint64_t v20 = *v8;
  BOOL v21 = v3 == 0;
  uint64_t v22 = 128;
  if (v21) {
    uint64_t v22 = 124;
  }
  if (*(_DWORD *)(result + v22))
  {
    if (v20 != a2)
    {
      do
      {
        v7 += *(_DWORD *)(v20 + 160);
        uint64_t v20 = *(void *)(v20 + 200);
      }
      while (v20 != a2);
      *(_DWORD *)(a2 + 168) = v7;
    }
  }
  else
  {
    while (v20 != a2)
    {
      if (*(_DWORD *)(v20 + 160))
      {
        int v7 = v7 == 0;
        *(_DWORD *)(a2 + 168) = v7;
      }
      uint64_t v20 = *(void *)(v20 + 200);
    }
  }
  return result;
}

char *ClipperLib::Clipper::IntersectEdges(char *result, _DWORD *a2, _DWORD *a3, long long *a4)
{
  int v7 = result;
  int v8 = a2[43];
  int v9 = a3[43];
  uint64_t v10 = (uint64_t (*)(_DWORD *, _DWORD *, _DWORD *, _DWORD *, long long *))*((void *)result + 17);
  if (v10) {
    uint64_t result = (char *)v10(a2, a2 + 24, a3, a3 + 24, a4);
  }
  int v11 = a2[40];
  int v12 = a3[40];
  if (!v11)
  {
    if (!v12) {
      return result;
    }
    if (a2[38] == a3[38])
    {
      if (*((_DWORD *)v7 + 20) != 1 || v9 < 0) {
        return result;
      }
    }
    else
    {
      int v26 = a3[41];
      if (v26 < 0) {
        int v26 = -v26;
      }
      if (v26 != 1 || *((_DWORD *)v7 + 20) == 1 && a3[42]) {
        return result;
      }
    }
    uint64_t result = ClipperLib::Clipper::AddOutPt(v7, (uint64_t)a2, a4);
    if ((v8 & 0x80000000) == 0) {
      a2[43] = -1;
    }
    return result;
  }
  int v13 = a2[38];
  int v14 = a3[38];
  if (!v12)
  {
    if (v13 == v14)
    {
      if (*((_DWORD *)v7 + 20) != 1 || v8 < 0) {
        return result;
      }
    }
    else
    {
      int v27 = a2[41];
      if (v27 < 0) {
        int v27 = -v27;
      }
      if (v27 != 1 || *((_DWORD *)v7 + 20) == 1 && a2[42]) {
        return result;
      }
    }
    uint64_t result = ClipperLib::Clipper::AddOutPt(v7, (uint64_t)a3, a4);
    if (v9 < 0) {
      return result;
    }
    int v28 = -1;
    goto LABEL_100;
  }
  int v15 = (int *)(v7 + 128);
  if (v13 == v14)
  {
    if (v13) {
      int v16 = (int *)(v7 + 124);
    }
    else {
      int v16 = (int *)(v7 + 128);
    }
    int v17 = *v16;
    int v18 = a2[41];
    if (v17)
    {
      int v19 = v18 + v12;
      if (!v19) {
        int v19 = -v18;
      }
      a2[41] = v19;
      int v20 = a3[41] - v11;
      if (v20) {
        a3[41] = v20;
      }
      else {
        a3[41] = -v11;
      }
      goto LABEL_59;
    }
    a2[41] = a3[41];
    a3[41] = v18;
LABEL_49:
    BOOL v29 = v13 == 0;
    if (v13) {
      uint64_t v30 = (int *)(v7 + 128);
    }
    else {
      uint64_t v30 = (int *)(v7 + 124);
    }
    int v31 = *v30;
    if (v14) {
      uint64_t v32 = (int *)(v7 + 124);
    }
    else {
      uint64_t v32 = (int *)(v7 + 128);
    }
    if (!v14) {
      int v15 = (int *)(v7 + 124);
    }
    int v33 = *v15;
    int v34 = *v32;
    goto LABEL_70;
  }
  if (v14) {
    BOOL v21 = v7 + 124;
  }
  else {
    BOOL v21 = v7 + 128;
  }
  int v22 = a2[42];
  int v23 = v22 + v12;
  if (!*v21) {
    int v23 = v22 == 0;
  }
  a2[42] = v23;
  if (v13) {
    double v24 = (int *)(v7 + 124);
  }
  else {
    double v24 = (int *)(v7 + 128);
  }
  int v17 = *v24;
  int v25 = a3[42];
  if (!v17)
  {
    a3[42] = v25 == 0;
    goto LABEL_49;
  }
  a3[42] = v25 - v11;
LABEL_59:
  BOOL v29 = v13 == 0;
  if (v13) {
    unint64_t v35 = (int *)(v7 + 128);
  }
  else {
    unint64_t v35 = (int *)(v7 + 124);
  }
  int v31 = *v35;
  if (v14) {
    uint64_t v36 = (int *)(v7 + 124);
  }
  else {
    uint64_t v36 = (int *)(v7 + 128);
  }
  if (!v14) {
    int v15 = (int *)(v7 + 124);
  }
  int v33 = *v15;
  int v34 = *v36;
  if (v17 == 3)
  {
    unint64_t v37 = -(uint64_t)(int)a2[41];
    goto LABEL_74;
  }
  if (v17 == 2)
  {
    unint64_t v37 = (int)a2[41];
    goto LABEL_74;
  }
LABEL_70:
  LODWORD(v37) = a2[41];
  if ((v37 & 0x80000000) == 0) {
    unint64_t v37 = v37;
  }
  else {
    unint64_t v37 = -(int)v37;
  }
LABEL_74:
  if (v34 == 3)
  {
    unint64_t v38 = -(uint64_t)(int)a3[41];
    if (v8 < 0) {
      goto LABEL_90;
    }
  }
  else if (v34 == 2)
  {
    unint64_t v38 = (int)a3[41];
    if (v8 < 0) {
      goto LABEL_90;
    }
  }
  else
  {
    LODWORD(v38) = a3[41];
    if ((v38 & 0x80000000) == 0) {
      unint64_t v38 = v38;
    }
    else {
      unint64_t v38 = -(int)v38;
    }
    if (v8 < 0) {
      goto LABEL_90;
    }
  }
  if (v9 < 0)
  {
LABEL_90:
    if ((v8 & 0x80000000) == 0)
    {
      if (v38 > 1) {
        return result;
      }
      uint64_t v39 = v7;
      uint64_t v40 = (uint64_t)a2;
      goto LABEL_99;
    }
    if ((v9 & 0x80000000) == 0)
    {
      if (v37 > 1) {
        return result;
      }
      goto LABEL_98;
    }
    if (v37 <= 1 && v38 <= 1)
    {
      if (v31 == 3)
      {
        uint64_t v42 = -(uint64_t)(int)a2[42];
      }
      else if (v31 == 2)
      {
        uint64_t v42 = (int)a2[42];
      }
      else
      {
        LODWORD(v42) = a2[42];
        if ((int)v42 >= 0) {
          uint64_t v42 = v42;
        }
        else {
          uint64_t v42 = -(int)v42;
        }
      }
      if (v33 == 3)
      {
        uint64_t v43 = -(uint64_t)(int)a3[42];
      }
      else if (v33 == 2)
      {
        uint64_t v43 = (int)a3[42];
      }
      else
      {
        LODWORD(v43) = a3[42];
        if ((int)v43 >= 0) {
          uint64_t v43 = v43;
        }
        else {
          uint64_t v43 = -(int)v43;
        }
      }
      if (v13 == v14)
      {
        if (v37 == 1 && v38 == 1)
        {
          switch(*((_DWORD *)v7 + 20))
          {
            case 0:
              if (v42 >= 1 && v43 >= 1) {
                goto LABEL_136;
              }
              return result;
            case 1:
              if (v42 > 0) {
                return result;
              }
              goto LABEL_135;
            case 2:
              if (v13 == 1 && v42 >= 1 && v43 > 0) {
                goto LABEL_136;
              }
              if (v42 >= 1 || !v29) {
                return result;
              }
LABEL_135:
              if (v43 <= 0) {
                goto LABEL_136;
              }
              return result;
            case 3:
              goto LABEL_136;
            default:
              return result;
          }
        }
        int v44 = a2[39];
        a2[39] = a3[39];
        a3[39] = v44;
      }
      else
      {
LABEL_136:
        return ClipperLib::Clipper::AddLocalMinPoly(v7, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
      }
    }
    return result;
  }
  if (v37 <= 1 && v38 <= 1 && (v13 == v14 || *((_DWORD *)v7 + 20) == 3))
  {
    ClipperLib::Clipper::AddOutPt(v7, (uint64_t)a2, a4);
LABEL_98:
    uint64_t v39 = v7;
    uint64_t v40 = (uint64_t)a3;
LABEL_99:
    uint64_t result = ClipperLib::Clipper::AddOutPt(v39, v40, a4);
    int v41 = a2[39];
    a2[39] = a3[39];
    a3[39] = v41;
    int v28 = a2[43];
    a2[43] = a3[43];
LABEL_100:
    a3[43] = v28;
    return result;
  }

  return ClipperLib::Clipper::AddLocalMaxPoly(v7, (uint64_t)a2, (uint64_t)a3, a4);
}

double ClipperLib::GetMaximaPairEx(void *a1)
{
  MaximaPair = (double *)ClipperLib::GetMaximaPair(a1);
  if (MaximaPair && *((_DWORD *)MaximaPair + 43) != -2 && *((void *)MaximaPair + 25) == *((void *)MaximaPair + 26)) {
    return MaximaPair[18];
  }
  return result;
}

uint64_t ClipperLib::ClipperBase::SwapPositionsInAEL(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 200);
  uint64_t v3 = *(void *)(a2 + 208);
  if (v4 != v3)
  {
    uint64_t v6 = *(void *)(a3 + 200);
    uint64_t v5 = *(void *)(a3 + 208);
    if (v6 != v5)
    {
      if (v4 == a3)
      {
        if (v6)
        {
          *(void *)(v6 + 208) = a2;
          uint64_t v3 = *(void *)(a2 + 208);
        }
        if (v3) {
          *(void *)(v3 + 200) = a3;
        }
        *(void *)(a3 + 200) = a2;
        *(void *)(a3 + 208) = v3;
        *(void *)(a2 + 200) = v6;
        *(void *)(a2 + 208) = a3;
        uint64_t v3 = *(void *)(a3 + 208);
      }
      else
      {
        if (v6 == a2)
        {
          if (v4)
          {
            *(void *)(v4 + 208) = a3;
            uint64_t v5 = *(void *)(a3 + 208);
          }
          if (v5) {
            *(void *)(v5 + 200) = a2;
          }
          *(void *)(a2 + 200) = a3;
          *(void *)(a2 + 208) = v5;
          uint64_t v3 = a2;
          *(void *)(a3 + 200) = v4;
          *(void *)(a3 + 208) = a2;
        }
        else
        {
          *(void *)(a2 + 200) = v6;
          if (v6)
          {
            *(void *)(v6 + 208) = a2;
            uint64_t v5 = *(void *)(a3 + 208);
          }
          *(void *)(a2 + 208) = v5;
          if (v5) {
            *(void *)(v5 + 200) = a2;
          }
          *(void *)(a3 + 200) = v4;
          if (v4) {
            *(void *)(v4 + 208) = a3;
          }
          *(void *)(a3 + 208) = v3;
          if (v3) {
            *(void *)(v3 + 200) = a3;
          }
        }
        if (!*(void *)(a2 + 208)) {
          goto LABEL_26;
        }
      }
      a2 = a3;
      if (v3) {
        return result;
      }
LABEL_26:
      *(void *)(result + 104) = a2;
    }
  }
  return result;
}

void interpolate_intersection_metadata(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  unsigned int v9 = 0;
  uint64_t v10 = a1 + 2;
  int v11 = a1 + 6;
  uint64_t v12 = a5[1];
  uint64_t v29 = *a5;
  int v13 = a5 + 2;
  do
  {
    uint64_t v14 = *v10;
    if (*v10 != -1)
    {
      uint64_t v15 = 0;
      double v16 = *((double *)v10 + 1);
      while (1)
      {
        if (v14 == a2[v15 + 2])
        {
          double v17 = *(double *)&a2[v15 + 3];
          if (vabdd_f64(v16, v17) <= 1.0 || v17 == 0.0 || v16 == 0.0) {
            break;
          }
        }
        v15 += 2;
        if (v15 == 4) {
          goto LABEL_12;
        }
      }
      if (v9 >= 2) {
        __assert_rtn("interpolate_intersection_metadata", "CGPathClipping.cc", 66, "intersectionCount < 2");
      }
      int v18 = &v13[2 * v9];
      *int v18 = v14;
      float v19 = v16;
      float v20 = v17;
      *((double *)v18 + 1) = interpolate_values_for_point(*a1, a1[1], *a2, a2[1], v29, v12, v19, v20);
      ++v9;
    }
LABEL_12:
    v10 += 2;
  }
  while (v10 != v11);
  BOOL v21 = a3 + 2;
  do
  {
    uint64_t v22 = *v21;
    if (*v21 != -1)
    {
      uint64_t v23 = 0;
      double v24 = *((double *)v21 + 1);
      while (1)
      {
        if (v22 == a4[v23 + 2])
        {
          double v25 = *(double *)&a4[v23 + 3];
          if (vabdd_f64(v24, v25) <= 1.0 || v25 == 0.0 || v24 == 0.0) {
            break;
          }
        }
        v23 += 2;
        if (v23 == 4) {
          goto LABEL_24;
        }
      }
      if (v9 >= 2) {
        __assert_rtn("interpolate_intersection_metadata", "CGPathClipping.cc", 81, "intersectionCount < 2");
      }
      int v26 = &v13[2 * v9];
      *int v26 = v22;
      float v27 = v24;
      float v28 = v25;
      *((double *)v26 + 1) = interpolate_values_for_point(*a3, a3[1], *a4, a4[1], v29, v12, v27, v28);
      ++v9;
    }
LABEL_24:
    v21 += 2;
  }
  while (v21 != a3 + 6);
}

float interpolate_values_for_point(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7, float a8)
{
  float v8 = vabds_f32(a7, a8);
  float v9 = (float)((unint64_t)a7 + 1);
  if (a8 != 0.0) {
    float v9 = a8;
  }
  float v10 = (float)((unint64_t)a8 + 1);
  if (a7 == 0.0) {
    float v9 = a8;
  }
  else {
    float v10 = a7;
  }
  if (v8 > 1.0)
  {
    a8 = v9;
    a7 = v10;
  }
  double v11 = (double)((a5 - a1) * (a3 - a1) + (a6 - a2) * (a4 - a2))
      / (double)((a3 - a1) * (a3 - a1) + (a4 - a2) * (a4 - a2));
  return v11 * a8 + a7 * (1.0 - v11);
}

char *ClipperLib::Clipper::AddLocalMinPoly(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a2;
  double v8 = *(double *)(a3 + 144);
  if (v8 != -1.0e40 && *(double *)(a2 + 144) <= v8)
  {
    float v9 = ClipperLib::Clipper::AddOutPt(a1, a3, (long long *)a4);
    *(_DWORD *)(v6 + 172) = *(_DWORD *)(a3 + 172);
    *(_DWORD *)(v6 + 156) = 2;
    *(_DWORD *)(a3 + 156) = 1;
    uint64_t v10 = *(void *)(a3 + 208);
    uint64_t v11 = v6;
    BOOL v22 = v10 == v6;
    uint64_t v6 = a3;
    if (!v22) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  float v9 = ClipperLib::Clipper::AddOutPt(a1, a2, (long long *)a4);
  *(_DWORD *)(a3 + 172) = *(_DWORD *)(v6 + 172);
  *(_DWORD *)(v6 + 156) = 1;
  *(_DWORD *)(a3 + 156) = 2;
  uint64_t v10 = *(void *)(v6 + 208);
  uint64_t v11 = a3;
  if (v10 == a3) {
LABEL_4:
  }
    uint64_t v10 = *(void *)(v11 + 208);
LABEL_5:
  if (v10 && (*(_DWORD *)(v10 + 172) & 0x80000000) == 0)
  {
    uint64_t v12 = *(void *)(a4 + 8);
    uint64_t v13 = *(void *)(v10 + 104);
    if (v13 == v12)
    {
      uint64_t v14 = *(void *)(v10 + 96);
    }
    else
    {
      double v15 = *(double *)(v10 + 144) * (double)(v12 - *(void *)(v10 + 8));
      double v16 = 0.5;
      if (v15 < 0.0) {
        double v16 = -0.5;
      }
      uint64_t v14 = *(void *)v10 + (uint64_t)(v15 + v16);
    }
    uint64_t v17 = *(void *)(v6 + 104);
    if (v17 == v12)
    {
      uint64_t v18 = *(void *)(v6 + 96);
    }
    else
    {
      double v19 = *(double *)(v6 + 144) * (double)(v12 - *(void *)(v6 + 8));
      double v20 = 0.5;
      if (v19 < 0.0) {
        double v20 = -0.5;
      }
      uint64_t v18 = *(void *)v6 + (uint64_t)(v19 + v20);
    }
    if (v14 == v18
      && *(_DWORD *)(v6 + 160)
      && *(_DWORD *)(v10 + 160)
      && ClipperLib::SlopesEqual(v14, v12, *(void *)(v10 + 96), v13, v14, v12, *(void *)(v6 + 96), v17, *((unsigned char *)a1 + *(void *)(*a1 - 24) + 40)))
    {
      ClipperLib::Clipper::AddOutPt(a1, v10, (long long *)a4);
      ClipperLib::Clipper::AddJoin();
    }
  }
  return v9;
}

double ClipperLib::Area(void *a1)
{
  double result = 0.0;
  if (a1)
  {
    uint64_t v2 = a1;
    do
    {
      double result = result
             + (double)(uint64_t)(v2[1] + *(void *)(v2[8] + 8))
             * (double)(uint64_t)(*(void *)(v2[8] + 16) - v2[2]);
      uint64_t v2 = (void *)v2[7];
    }
    while (v2 != a1);
    return result * 0.5;
  }
  return result;
}

void ClipperLib::ClipperBase::CreateOutRec(ClipperLib::ClipperBase *this)
{
}

CGImageRef CGImageCreateWithPNGDataProvider(CGDataProviderRef source, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  unsigned __int8 v4 = intent;
  BOOL v5 = shouldInterpolate;
  if (CGImageCreateWithPNGDataProvider_predicate != -1) {
    dispatch_once(&CGImageCreateWithPNGDataProvider_predicate, &__block_literal_global_13483);
  }
  uint64_t v8 = CGImageCreateWithPNGDataProvider_f(source, 0);
  if (!v8) {
    return 0;
  }
  float v9 = (const void *)v8;
  if (CGImageCreateWithPNGDataProvider_predicate_3 != -1) {
    dispatch_once(&CGImageCreateWithPNGDataProvider_predicate_3, &__block_literal_global_6_13484);
  }
  uint64_t v10 = (const void *)CGImageCreateWithPNGDataProvider_f_2(v9);
  if (!v10 || !CFEqual(v10, @"public.png"))
  {
    CFRelease(v9);
    return 0;
  }
  if (CGImageCreateWithPNGDataProvider_predicate_10 != -1) {
    dispatch_once(&CGImageCreateWithPNGDataProvider_predicate_10, &__block_literal_global_13_13486);
  }
  uint64_t v11 = CGImageCreateWithPNGDataProvider_f_9(v9, 0, 0);
  CFRelease(v9);
  if (v11)
  {
    int v12 = v5 ? 0x1000000 : 0;
    *(_DWORD *)(v11 + 36) = v12 & 0xFFFF00FF | (v4 << 8) | *(_DWORD *)(v11 + 36) & 0xFEFF00FF;
    if (decode)
    {
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)v11);
      if (ColorSpace) {
        uint64_t v14 = *(void *)(*((void *)ColorSpace + 3) + 48);
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v16 = v14 + (((unint64_t)*(unsigned int *)(v11 + 36) >> 26) & 1);
      uint64_t v17 = 2 * v16;
      uint64_t v18 = malloc_type_malloc(16 * v16, 0x705560E0uLL);
      for (*(void *)(v11 + 160) = v18; v17; --v17)
      {
        uint64_t v19 = *(void *)decode++;
        *v18++ = v19;
      }
    }
  }
  return (CGImageRef)v11;
}

double __text_state_create_root_block_invoke()
{
  uint64_t v0 = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
  char v1 = *(_WORD *)v0;
  *((_DWORD *)v0 + 1) = 1;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_WORD *)uint64_t v0 = v1 & 0xFC | 2;
  if (once != -1) {
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  }
  *((_DWORD *)v0 + 12) = default_antialiasing_style;
  *((_DWORD *)v0 + 13) = default_smoothing_style;
  *((_DWORD *)v0 + 14) = 0;
  __int16 v2 = *(_WORD *)v0 & 0xFF02 | 0x3D;
  *((void *)v0 + 5) = 0x4000000000000000;
  double result = 0.0;
  *((_OWORD *)v0 + 4) = 0u;
  *((_OWORD *)v0 + 5) = 0u;
  text_state_create_root_root = (uint64_t)v0;
  *(_WORD *)uint64_t v0 = v2;
  return result;
}

void CGSoftMaskDelegateDrawSoftMask(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4)
  {
    if (*(void *)(a4 + 136))
    {
      uint64_t v9 = CGContextCreateWithDelegateAndInfo(a1, 12, a2, a3, 0, 0, a7, a8);
      if (v9)
      {
        uint64_t v10 = (const void *)v9;
        (*(void (**)(void, uint64_t))(a4 + 136))(*(void *)(a4 + 120), v9);
        CFRelease(v10);
      }
    }
  }
}

uint64_t dlRecorder_DrawLayer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  if (!a1 || (int v12 = *(CFArrayRef **)(a1 + 288)) == 0)
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"dlRecorder_DrawLayer");
    return 1000;
  }
  uint64_t v18 = (double *)CG::DisplayListRecorder::currentDisplayList(v12);
  if (!v18) {
    return 1000;
  }
  uint64_t v19 = (uint64_t)v18;
  double v20 = v18[7];
  BOOL v22 = v18[5] == -8.98846567e307 && v18[6] == -8.98846567e307 && v20 == 1.79769313e308;
  if ((!v22 || v18[8] != 1.79769313e308)
    && *((void *)v18 + 74) != *((void *)v18 + 75)
    && v18[11] != INFINITY
    && v18[12] != INFINITY)
  {
    double v24 = v18[8];
    double v41 = v18[5];
    double v42 = v18[6];
    CopCGFloat y = CGGStateCreateCopy(a3);
    uint64_t v26 = (uint64_t)Copy;
    float64x2_t v27 = *(float64x2_t *)(Copy + 24);
    float64x2_t v28 = *(float64x2_t *)(Copy + 40);
    float64x2_t v29 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(Copy + 56), v27, a9), v28, a10);
    float64x2_t v30 = vmulq_n_f64(v27, a11 / v20);
    float64x2_t v31 = vmulq_n_f64(v28, a12 / v24);
    *(float64x2_t *)(Copy + 24) = v30;
    *(float64x2_t *)(Copy + 40) = v31;
    *(float64x2_t *)(Copy + 56) = vmlsq_lane_f64(vmlsq_lane_f64(v29, v30, v41, 0), v31, v42, 0);
    uint64_t v32 = &CGRectNull;
    p_CGFloat y = &CGRectNull.origin.y;
    p_CGSize size = (CGSize *)(v19 + 104);
    p_CGFloat height = (CGFloat *)(v19 + 112);
    if (*(void *)(v19 + 592) == *(void *)(v19 + 600)) {
      p_CGSize size = &CGRectNull.size;
    }
    else {
      p_CGFloat y = (CGFloat *)(v19 + 96);
    }
    if (*(void *)(v19 + 592) == *(void *)(v19 + 600)) {
      p_CGFloat height = &CGRectNull.size.height;
    }
    else {
      uint64_t v32 = (const CGRect *)(v19 + 88);
    }
    CGGStateClipToRect((uint64_t)Copy, v32->origin.x, *p_y, p_size->width, *p_height);
    CGDisplayListDelegateDrawDisplayList(a4, a2, v26, v19, v36, v37, v38, v39);
    CGGStateRelease(v26);
  }
  return 0;
}

void CGContextDrawLayerAtPoint(CGContextRef context, CGPoint point, CGLayerRef layer)
{
  if (!context)
  {
    CGContextRef v12 = 0;
LABEL_9:
    handle_invalid_context((char)"CGContextDrawLayerAtPoint", (uint64_t)v12, v3, v4, v5, v6, v7, v8);
    return;
  }
  if (*((_DWORD *)context + 4) != 1129601108)
  {
    CGContextRef v12 = context;
    goto LABEL_9;
  }
  if (layer)
  {
    uint64_t v9 = *((void *)layer + 2);
    if (v9)
    {
      uint64_t v10 = *(void *)(v9 + 40);
      if (v10)
      {
        uint64_t v11 = *(void (**)(__n128, __n128, double, double))(v10 + 216);
        if (v11) {
          v11((__n128)point, *(__n128 *)&point.y, *((double *)layer + 3), *((double *)layer + 4));
        }
      }
    }
  }
}

uint64_t (*__copy_icc_profile_description_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  double result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    double result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyDescriptionString");
  }
  if (result) {
    char v1 = result;
  }
  else {
    char v1 = colorsync_smart_null_7440;
  }
  copy_icc_profile_description_f = (uint64_t (*)(void))v1;
  return result;
}

void __CGColorIsWideGamut_block_invoke()
{
  uint64_t v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedSRGB");
  CGColorIsWideGamut_transform = color_transform_create(v0, 0);

  CGColorSpaceRelease(v0);
}

void icc_converter_info(size_t size@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  *(void *)(a9 + 80) = 0;
  *(_OWORD *)(a9 + 48) = 0u;
  *(_OWORD *)(a9 + 64) = 0u;
  *(_OWORD *)(a9 + 16) = 0u;
  *(_OWORD *)(a9 + 32) = 0u;
  *(_OWORD *)a9 = 0u;
  if (!a2 || !a3 || (uint64_t v12 = *(void *)(a2 + 8), v12 != a3[1]) || (v13 = *(void *)(a2 + 16), v13 != a3[2]))
  {
    CGPostError((uint64_t)"%s : Unable to complete color conversion", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"icc_converter_info");
    return;
  }
  if (*(unsigned char *)(size + 224))
  {
    unint64_t v15 = *(void *)(a2 + 56);
    if (a3[7] > v15) {
      unint64_t v15 = a3[7];
    }
    size_t v16 = 4 * (v12 + v12 * v15) * v13;
    uint64_t v17 = malloc_type_calloc(1uLL, v16, 0xCA58733BuLL);
    *(void *)(a9 + 72) = v17;
    uint64_t v18 = malloc_type_calloc(1uLL, v16, 0xE1D0514CuLL);
    *(void *)(a9 + 80) = v18;
    CGColorSpaceRef v19 = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
    *(_DWORD *)srcFormat = *(void *)(a2 + 48);
    memcpy(__dst, (const void *)(a2 + 40), 0x130uLL);
    *(_DWORD *)&srcFormat[4] = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v20, v21, v22, v23, v24, v25, v26);
    *(void *)&srcFormat[8] = v19;
    memcpy(__dst, (const void *)(a2 + 40), 0x130uLL);
    *(_DWORD *)&srcFormat[16] = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__dst);
    memset(&srcFormat[20], 0, 20);
    int v27 = *(_DWORD *)(a2 + 64);
    if ((v27 & 0xFFFFFFFE) == 8)
    {
      *(void *)&__dst[32] = 0;
      *(_DWORD *)char __dst = 32;
    }
    else
    {
      *(void *)&__dst[32] = 0;
      *(_DWORD *)char __dst = 32;
      if (!v27)
      {
        *(_DWORD *)&__dst[4] = 96;
        int v30 = 8448;
LABEL_20:
        *(void *)&__dst[8] = v19;
        *(_DWORD *)&__dst[16] = v30;
        *(void *)&__dst[28] = 0;
        *(void *)&__dst[20] = 0;
        float64x2_t v31 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)srcFormat, (const vImage_CGImageFormat *)__dst, 0, 0x100u, 0);
        *(void *)(a9 + 40) = v31;
        if (v31)
        {
          vImagePixelCount v40 = *(void *)(a2 + 8);
          vImagePixelCount v39 = *(void *)(a2 + 16);
          srcs.datdouble a = v17;
          srcs.CGFloat height = v39;
          srcs.CGFloat width = v40;
          srcs.rowuint64_t Bytes = (v40 * *(unsigned int *)&srcFormat[4]) >> 3;
          dests.datdouble a = v17;
          dests.CGFloat height = v39;
          dests.CGFloat width = v40;
          dests.rowuint64_t Bytes = (v40 * *(unsigned int *)&__dst[4]) >> 3;
          vImage_Error v41 = vImageConvert_AnyToAny(v31, &srcs, &dests, 0, 0x80u);
          if (v41 < 0) {
            CGPostError((uint64_t)"%s vImage_buffer_CGSize size = %ld\n", v42, v43, v44, v45, v46, v47, v48, (char)"create_src_data_to_float_converter");
          }
          else {
            *(void *)(a9 + 56) = malloc_type_malloc(v41, 0xB41A9B30uLL);
          }
        }
        unsigned int v49 = *(_DWORD *)(a2 + 64);
        if (v49 - 8 >= 2)
        {
          if (v49 >= 7)
          {
            CGPostError((uint64_t)"%s : Unable to complete color conversion", v32, v33, v34, v35, v36, v37, v38, (char)"colorsync_alpha_info_from_conversion_format");
            BOOL v50 = 1;
            goto LABEL_29;
          }
        }
        else
        {
          unsigned int v49 = 3;
        }
        BOOL v50 = v49 == 0;
LABEL_29:
        CGColorSpaceRef v51 = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
        *(void *)&srcFormat[32] = 0;
        *(_DWORD *)srcFormat = a3[6];
        memcpy(__dst, a3 + 5, 0x130uLL);
        *(_DWORD *)&srcFormat[4] = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v52, v53, v54, v55, v56, v57, v58);
        *(void *)&srcFormat[8] = v51;
        memcpy(__dst, a3 + 5, 0x130uLL);
        *(_DWORD *)&srcFormat[16] = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__dst);
        *(_OWORD *)&srcFormat[20] = 0uLL;
        *(void *)&__dst[32] = 0;
        if (v50) {
          int v59 = 96;
        }
        else {
          int v59 = 128;
        }
        if (v50) {
          int v60 = 8448;
        }
        else {
          int v60 = 8451;
        }
        *(_DWORD *)char __dst = 32;
        *(_DWORD *)&__dst[4] = v59;
        *(void *)&__dst[8] = v51;
        *(_DWORD *)&__dst[16] = v60;
        *(void *)&__dst[20] = 0;
        *(void *)&__dst[28] = 0;
        uint64_t v61 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)__dst, (const vImage_CGImageFormat *)srcFormat, 0, 0x100u, 0);
        *(void *)(a9 + 48) = v61;
        if (v61)
        {
          vImagePixelCount v63 = a3[1];
          vImagePixelCount v62 = a3[2];
          srcs.datdouble a = v18;
          srcs.CGFloat height = v62;
          srcs.CGFloat width = v63;
          srcs.rowuint64_t Bytes = (v63 * *(unsigned int *)&srcFormat[4]) >> 3;
          dests.datdouble a = v18;
          dests.CGFloat height = v62;
          dests.CGFloat width = v63;
          dests.rowuint64_t Bytes = srcs.rowBytes;
          vImage_Error v64 = vImageConvert_AnyToAny(v61, &srcs, &dests, 0, 0x80u);
          if (v64 < 0) {
            CGPostError((uint64_t)"%s vImage_buffer_CGSize size = %ld\n", v65, v66, v67, v68, v69, v70, v71, (char)"create_dst_float_to_src_converter");
          }
          else {
            *(void *)(a9 + 64) = malloc_type_malloc(v64, 0x77660621uLL);
          }
        }
        return;
      }
    }
    *(_DWORD *)&__dst[4] = 128;
    int v30 = 8451;
    goto LABEL_20;
  }
  if (*(_DWORD *)(size + 16) != 3 && !CFEqual(*(CFTypeRef *)(size + 32), *(CFTypeRef *)(size + 24))
    || !conversion_formats_are_equal(a2, (uint64_t)a3))
  {
    CachedCGvImageConverter = (vImage_Error *)CGCMSConverterCreateCachedCGvImageConverter((void *)size, (const void *)a2, a3);
    *(void *)a9 = CachedCGvImageConverter;
    if (CachedCGvImageConverter)
    {
      float64x2_t v29 = CachedCGvImageConverter;
      memcpy(__dst, (const void *)a2, sizeof(__dst));
      memcpy(srcFormat, a3, sizeof(srcFormat));
      *(void *)(a9 + 16) = CGvImageConverterGetBufferSize(v29, (uint64_t)__dst, (uint64_t)srcFormat);
    }
  }
}

uint64_t CGvImageConverterGetBufferSize(vImage_Error *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void **)a2;
  size_t v7 = *(void *)(a2 + 24);
  memcpy(__dst, (const void *)(a2 + 32), sizeof(__dst));
  srcs.datdouble a = v6;
  int8x16_t v8 = *(int8x16_t *)(a2 + 8);
  *(int8x16_t *)&srcs.CGFloat height = vextq_s8(v8, v8, 8uLL);
  if (!v7)
  {
    uint64_t v27 = v8.i64[0];
    memcpy(v32, &__dst[8], sizeof(v32));
    size_t v7 = ((unint64_t)CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v32, v9, v10, v11, v12, v13, v14, v15) >> 3) * v27;
  }
  srcs.rowuint64_t Bytes = v7;
  size_t v16 = *(void *)(a3 + 24);
  memcpy(__dst, (const void *)(a3 + 32), sizeof(__dst));
  int8x16_t v17 = *(int8x16_t *)(a3 + 8);
  *(int8x16_t *)&dests.CGFloat height = vextq_s8(v17, v17, 8uLL);
  if (!v16)
  {
    uint64_t v28 = v17.i64[0];
    memcpy(v32, &__dst[8], sizeof(v32));
    size_t v16 = ((unint64_t)CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v32, v18, v19, v20, v21, v22, v23, v24) >> 3)
        * v28;
  }
  __dst[0] = 0;
  srcs.datdouble a = __dst;
  dests.rowuint64_t Bytes = v16;
  dests.datdouble a = __dst;
  vImage_Error v25 = *a1;
  if (*a1) {
    vImage_Error v25 = vImageConvert_AnyToAny((const vImageConverterRef)v25, &srcs, &dests, 0, 0x80u);
  }
  return v25 & ~(v25 >> 63);
}

uint64_t CGNotificationCenterAddCallback(uint64_t result, uint64_t a2, uint64_t a3, __CFString *a4, __CFString *a5)
{
  if (a2)
  {
    uint64_t v9 = result;
    uint64_t v10 = malloc_type_malloc(0x28uLL, 0x2062DE7BuLL);
    *(_DWORD *)uint64_t v10 = 1;
    v10[1] = a3;
    if (a4) {
      uint64_t v11 = a4;
    }
    else {
      uint64_t v11 = @"kCGNotificationAnyName";
    }
    CFTypeRef v12 = CFRetain(v11);
    uint64_t v13 = @"kCGNotificationAnyObject";
    if (a5) {
      uint64_t v13 = a5;
    }
    _OWORD v10[2] = v12;
    _OWORD v10[3] = v13;
    void v10[4] = a2;
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 16));
    uint64_t v14 = *(void **)(v9 + 80);
    uint64_t v15 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
    if (v15)
    {
      *uint64_t v15 = v10;
      v15[1] = v14;
      uint64_t v14 = v15;
    }
    *(void *)(v9 + 80) = v14;
    return pthread_mutex_unlock((pthread_mutex_t *)(v9 + 16));
  }
  return result;
}

uint64_t CGPDFStreamCreate(uint64_t a1, CGPDFDictionaryRef dict, void *a3, uint64_t a4)
{
  CGPDFInteger value = 0;
  if (!CGPDFDictionaryGetInteger(dict, "Length", &value))
  {
    pdf_error("missing or invalid stream length.");
    CGPDFInteger v14 = 0;
    CGPDFInteger value = 0;
    if (a3) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v17 = -1;
    goto LABEL_9;
  }
  CGPDFInteger v14 = value;
  if (!a3) {
    goto LABEL_6;
  }
LABEL_3:
  uint64_t v15 = a3[11];
  if (a3[18])
  {
    uint64_t v16 = a3[24];
    v15 += a3[15];
  }
  else
  {
    uint64_t v16 = a3[16];
  }
  uint64_t v17 = v16 - v15 + a3[14];
LABEL_9:
  CGPDFSourceSetPosition((uint64_t)a3, v14 + a4, v8, v9, v10, v11, v12, v13);
  CGPDFSourceSkipWhitespace(a3, v18, v19, v20, v21, v22, v23, v24);
  if (!CGPDFSourceMatch((uint64_t)a3, (uint64_t)"endstream", v25, v26, v27, v28, v29, v30))
  {
    uint64_t v41 = 0;
    CGPDFSourceSetPosition((uint64_t)a3, a4, v31, v32, v33, v34, v35, v36);
    if (CGPDFSourceForwardSearch(a3, "endstream", "\n\r", &v41))
    {
      CGPDFInteger v37 = v41 - a4;
      pdf_error("invalid stream length %lld; should be %lld.", v14, v41 - a4);
      CGPDFInteger v14 = v37;
    }
    else
    {
    }
  }
  CGPDFSourceSetPosition((uint64_t)a3, v17, v31, v32, v33, v34, v35, v36);
  CGPDFSourcePreflightLargeRead((uint64_t)a3, v17, v14);
  if (CGPDFStreamGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFStreamGetTypeID_onceToken, &__block_literal_global_21818);
  }
  uint64_t cftype = pdf_create_cftype();
  uint64_t v39 = cftype;
  if (cftype)
  {
    *(void *)(cftype + 24) = 0;
    *(void *)(cftype + 32) = 0;
    *(void *)(cftype + 16) = a1;
    *(unsigned char *)(cftype + 40) = 0;
    *(void *)(cftype + 48) = dict;
    *(void *)(cftype + 56) = a4;
    *(void *)(cftype + 64) = v14;
    if (a3) {
      CFRetain(a3);
    }
    *(void *)(v39 + 72) = a3;
    *(_DWORD *)(v39 + 80) = 0;
  }
  return v39;
}

void **pdf_xref_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CopCGFloat y = (void *)a1;
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  uint64_t v159 = 0;
  v171.__sig = 0;
  *(void *)v171.__opaque = 0;
  CGPDFSourceSetPosition(a1, 0, a3, a4, a5, a6, a7, a8);
  if ((CGPDFSourceForwardSearch(Copy, "%PDF-", 0, &v159) & 1) == 0)
  {
    CGPDFSourceSetPosition((uint64_t)Copy, 0, v9, v10, v11, v12, v13, v14);
    if ((CGPDFSourceForwardSearch(Copy, "%!PS-Adobe-", 0, &v159) & 1) == 0)
    {
      return 0;
    }
  }
  uint64_t v15 = (void **)malloc_type_calloc(1uLL, 0xD0uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *((unsigned char *)v15 + 176) = 0;
  *(_OWORD *)(v15 + 23) = xmmword_1850CDC10;
  if (!Copy)
  {
    uint64_t v20 = v159;
    if (!v159)
    {
      uint64_t v19 = 0;
      CopCGFloat y = 0;
      goto LABEL_10;
    }
    uint64_t v19 = 0;
    goto LABEL_9;
  }
  uint64_t v19 = Copy[2];
  if (v19 == -1) {
    goto LABEL_61;
  }
  uint64_t v20 = v159;
  if (v159)
  {
LABEL_9:
    CopCGFloat y = CGPDFSourceCreateCopy((uint64_t)Copy, v20, v19 - v20);
    goto LABEL_10;
  }
  CFRetain(Copy);
LABEL_10:
  *uint64_t v15 = Copy;
  *((_DWORD *)v15 + 16) = 1;
  pthread_mutexattr_init(&v171);
  pthread_mutexattr_settype(&v171, 2);
  pthread_mutex_init((pthread_mutex_t *)(v15 + 12), &v171);
  pthread_mutexattr_destroy(&v171);
  uint64_t v25 = *v15;
  if (*v15)
  {
    uint64_t v26 = v25[2];
    if (v26 == -1) {
LABEL_61:
    }
      _CGHandleAssert("CGPDFSourceGetLength", 179, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Reader/CGPDFSource.c", "source->length != (pdf_off_t)-1", "source length would overflow", v16, v17, v18, v157);
  }
  else
  {
    uint64_t v26 = 0;
  }
  linearization_dictionarCGFloat y = xref_read_linearization_dictionary(v25, v21, v22, v23, v24, v16, v17, v18);
  void v15[3] = linearization_dictionary;
  if (!linearization_dictionary) {
    goto LABEL_58;
  }
  CGPDFSourceSkipWhitespace(*v15, v28, v29, v30, v31, v16, v17, v18);
  uint64_t v38 = *v15;
  if (*v15)
  {
    uint64_t v39 = v38[11];
    if (v38[18])
    {
      uint64_t v40 = v38[24];
      v39 += v38[15];
    }
    else
    {
      uint64_t v40 = v38[16];
    }
    uint64_t v41 = v40 - v39 + v38[14];
  }
  else
  {
    uint64_t v41 = -1;
  }
  if (CGPDFSourceMatch((uint64_t)v38, (uint64_t)"xref", v32, v33, v34, v35, v36, v37))
  {
    uint64_t v42 = CGPDFXRefTableCreate((const void **)v15, v41, 0);
    v15[2] = v42;
    if (!v42) {
      goto LABEL_72;
    }
    uint64_t v43 = 10000001;
    uint64_t v44 = v42[1];
    if (v44)
    {
      uint64_t v45 = *(void *)(v44 + 8);
      if (v45)
      {
        uint64_t v46 = *(void **)(v45 + 40);
        while (v46)
        {
          uint64_t v47 = v46;
          uint64_t v46 = (void *)*v46;
          uint64_t v48 = *(void *)v47[1];
          if (v48 < v43) {
            uint64_t v43 = v48;
          }
        }
      }
    }
  }
  else
  {
    unsigned int v49 = CGPDFXRefStreamCreate((const void **)v15, v41, 0);
    v15[1] = v49;
    if (!v49) {
      goto LABEL_72;
    }
    uint64_t v43 = 10000001;
    for (char i = (void *)v49[1]; i; char i = (void *)*i)
    {
      CGColorSpaceRef v51 = *(void **)(i[1] + 16);
      while (v51)
      {
        uint64_t v52 = v51;
        CGColorSpaceRef v51 = (void *)*v51;
        uint64_t v53 = *(void *)v52[1];
        if (v53 < v43) {
          uint64_t v43 = v53;
        }
      }
    }
  }
  v15[24] = (void *)v43;
  uint64_t v54 = v15[2];
  if (!v54 && !v15[1])
  {
LABEL_58:
    if (v26 == 0x7FFFFFFFFFFFFFFFLL && !v15[3]) {
      goto LABEL_72;
    }
    __s1[0] = 0;
    vImage_Error v64 = *v15;
    if (*v15)
    {
      uint64_t v65 = v64[2];
      if (v65 == -1) {
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v65 = 0;
    }
    CGPDFSourceSetPosition((uint64_t)v64, v65, v29, v30, v31, v16, v17, v18);
    if (CGPDFSourceReverseSearch(*v15, "startxref", "\n\r", " \n\r", __s1))
    {
      CGPDFSourceSetPosition((uint64_t)*v15, (uint64_t)(__s1[0] + 9), v66, v67, v68, v69, v70, v71);
      uint64_t v72 = *v15;
      CGPDFInteger value = 0;
      int integer = read_integer(v72, (unint64_t *)&value, v73, v74, v75, v76, v77, v78);
      unint64_t v86 = "missing or invalid value for cross-reference offset.";
      if (integer)
      {
        CGPDFInteger v87 = value;
        if ((value & 0x8000000000000000) == 0)
        {
          v15[23] = (void *)value;
          CGPDFSourceSetPosition((uint64_t)*v15, v87, v79, v80, v81, v82, v83, v84);
          CGPDFSourceSkipWhitespace(*v15, v88, v89, v90, v91, v92, v93, v94);
          uint64_t v101 = *v15;
          if (*v15)
          {
            uint64_t v102 = v101[11];
            if (v101[18])
            {
              uint64_t v103 = v101[24];
              v102 += v101[15];
            }
            else
            {
              uint64_t v103 = v101[16];
            }
            uint64_t v118 = v103 - v102 + v101[14];
          }
          else
          {
            uint64_t v118 = -1;
          }
          if (CGPDFSourceMatch((uint64_t)v101, (uint64_t)"xref", v95, v96, v97, v98, v99, v100))
          {
            uint64_t v54 = CGPDFXRefTableCreate((const void **)v15, v118, 1);
            v15[2] = v54;
            if (v54) {
              goto LABEL_75;
            }
          }
          else
          {
            uint64_t v119 = CGPDFXRefStreamCreate((const void **)v15, v118, 1);
            v15[1] = v119;
            if (v119)
            {
              uint64_t v54 = v15[2];
              if (!v54) {
                goto LABEL_41;
              }
              goto LABEL_75;
            }
          }
LABEL_72:
          if (v19 == 0x7FFFFFFFFFFFFFFFLL && !v15[3]) {
            goto LABEL_174;
          }
          uint64_t v54 = CGPDFXRefTableCreateByScanningObjects((const void **)v15, 0);
          v15[2] = v54;
          if (!v54) {
            goto LABEL_174;
          }
          goto LABEL_75;
        }
      }
    }
    else
    {
      unint64_t v86 = "failed to find start of cross-reference table.";
    }
    pdf_error(v86);
    goto LABEL_72;
  }
  v15[23] = (void *)v41;
  *((unsigned char *)v15 + 200) = 1;
  if (!v54)
  {
LABEL_41:
    uint64_t v55 = v15[1];
    if (v55)
    {
      uint64_t v56 = (void *)v55[1];
      if (v56)
      {
        unint64_t v57 = 0;
        do
        {
          uint64_t v58 = v56[1];
          if (v58 && (int v59 = *(void **)(v58 + 16)) != 0)
          {
            unint64_t v60 = 0;
            do
            {
              uint64_t v61 = v59;
              int v59 = (void *)*v59;
              int64_t v62 = *(void *)(v61[1] + 8) + *(void *)v61[1];
              if ((uint64_t)v60 <= v62) {
                unint64_t v60 = v62;
              }
            }
            while (v59);
          }
          else
          {
            unint64_t v60 = 0;
          }
          if (v57 <= v60) {
            unint64_t v57 = v60;
          }
          uint64_t v56 = (void *)*v56;
        }
        while (v56);
        if (v57 > 0x989681)
        {
          vImagePixelCount v63 = "xref stream size too large.";
LABEL_93:
          unint64_t v57 = 10000001;
          pdf_error(v63);
          goto LABEL_95;
        }
        goto LABEL_95;
      }
    }
LABEL_94:
    unint64_t v57 = 0;
    goto LABEL_95;
  }
LABEL_75:
  unint64_t v104 = (void *)v54[1];
  if (!v104) {
    goto LABEL_94;
  }
  unint64_t v57 = 0;
  do
  {
    uint64_t v105 = v104[1];
    unint64_t v106 = *(void *)v105;
    if (!*(void *)v105)
    {
      CGPDFInteger value = 0;
      BOOL v107 = CGPDFDictionaryGetInteger(*(CGPDFDictionaryRef *)(v105 + 16), "Size", &value);
      unint64_t v106 = 0;
      if (v107)
      {
        int v108 = *(void **)(v105 + 40);
        if (v108)
        {
          CGPDFInteger v109 = 0;
          do
          {
            uint64_t v110 = v108;
            int v108 = (void *)*v108;
            CGPDFInteger v111 = *(void *)(v110[1] + 8) + *(void *)v110[1];
            if (v109 <= v111) {
              CGPDFInteger v109 = v111;
            }
          }
          while (v108);
        }
        else
        {
          CGPDFInteger v109 = 0;
        }
        unint64_t v106 = value;
        if (value <= v109) {
          unint64_t v106 = v109;
        }
      }
    }
    if (v57 <= v106) {
      unint64_t v57 = v106;
    }
    unint64_t v104 = (void *)*v104;
  }
  while (v104);
  if (v57 > 0x989681)
  {
    vImagePixelCount v63 = "xref table size too large.";
    goto LABEL_93;
  }
LABEL_95:
  unsigned char v15[20] = (void *)v57;
  uint64_t v112 = malloc_type_calloc(1uLL, 40 * v57, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  v15[21] = v112;
  trailer = (CGPDFDictionary *)pdf_xref_get_trailer((uint64_t)v15);
  uint64_t v114 = (CGPDFArrayRef *)(v15 + 6);
  if (CGPDFDictionaryGetArray(trailer, "ID", (CGPDFArrayRef *)v15 + 6)) {
    CGPDFArraySetObjectReference(*v114, 0, 0);
  }
  uint64_t v115 = (CGPDFDictionary *)pdf_xref_get_trailer((uint64_t)v15);
  if (!v115) {
    goto LABEL_129;
  }
  uint64_t v169 = 0;
  CGPDFInteger value = 0;
  __s1[0] = 0;
  CGPDFDictionaryRef v167 = 0;
  CGPDFInteger v168 = 0;
  CGPDFDictionaryRef v166 = 0;
  int v116 = 0;
  if (!CGPDFDictionaryGetDictionary(v115, "Encrypt", &v167)) {
    goto LABEL_130;
  }
  CGPDFDictionarySetObjectReference(v167, 0, 0);
  if (!CGPDFDictionaryGetName(v167, "Filter", (const char **)__s1))
  {
LABEL_129:
    int v116 = 0;
    goto LABEL_130;
  }
  if (!CGPDFDictionaryGetName(v167, "SubFilter", (const char **)&v169)) {
    uint64_t v169 = 0;
  }
  if (!CGPDFDictionaryGetInteger(v167, "V", &value))
  {
    goto LABEL_129;
  }
  if ((unint64_t)value > 5 || ((1 << value) & 0x36) == 0)
  {
    goto LABEL_129;
  }
  if ((value & 0xFFFFFFFFFFFFFFFELL) == 4)
  {
    if (CGPDFDictionaryGetDictionary(v167, "CF", &v166)) {
      CGPDFDictionaryRef v117 = v166;
    }
    else {
      CGPDFDictionaryRef v117 = 0;
    }
  }
  else
  {
    CGPDFDictionaryRef v117 = 0;
  }
  if (strcmp(__s1[0], "Standard"))
  {
    goto LABEL_129;
  }
  int v116 = (CGPDFArrayRef *)malloc_type_calloc(1uLL, 0x38uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v116)
  {
    CGPDFDictionaryRef v120 = v167;
    *int v116 = *v114;
    v116[1] = v120;
    v116[3] = v117;
    unint64_t v121 = (CGPDFArray *)CGPDFSecurityHandlerCreate(v116);
    v116[2] = v121;
    CGPDFInteger v122 = value;
    v116[6] = (CGPDFArrayRef)value;
    if (!v121) {
      goto LABEL_192;
    }
    if ((v122 & 0xFFFFFFFFFFFFFFFELL) == 4)
    {
      if (CGPDFDictionaryGetName(v167, "StmF", (const char **)&v168))
      {
        uint64_t v123 = (char *)v168;
      }
      else
      {
        uint64_t v123 = "Identity";
        CGPDFInteger v168 = (CGPDFInteger)"Identity";
      }
      CryptFilter = CGPDFSecurityManagerCreateCryptFilter((uint64_t)v116, v123);
    }
    else
    {
      CryptFilter = CGPDFCryptFilterCreateStandard((uint64_t)v116);
    }
    v116[4] = (CGPDFArrayRef)CryptFilter;
    if (!CryptFilter
      || ((value & 0xFFFFFFFFFFFFFFFELL) != 4
        ? (Standardouble d = (CGPDFArray *)CGPDFCryptFilterCreateStandard((uint64_t)v116))
        : (!CGPDFDictionaryGetName(v167, "StrF", (const char **)&v168)
         ? (char *)(long long v155 = "Identity", v168 = (CGPDFInteger)"Identity")
         : (long long v155 = (char *)v168),
           Standardouble d = (CGPDFArray *)CGPDFSecurityManagerCreateCryptFilter((uint64_t)v116, v155)),
          (v116[5] = Standard) == 0))
    {
LABEL_192:
      CGPDFSecurityManagerRelease((uint64_t)v116);
      goto LABEL_129;
    }
  }
LABEL_130:
  v15[5] = v116;
  uint64_t v124 = (CGPDFDictionary *)v15[3];
  if (!v124)
  {
LABEL_179:
    *((unsigned char *)v15 + 201) = 1;
    return v15;
  }
  if (v116)
  {
    CGPDFSecurityManagerUnlock((uint64_t)v116, "", 0);
    uint64_t v124 = (CGPDFDictionary *)v15[3];
  }
  uint64_t v165 = 0;
  *(_OWORD *)pthread_mutexattr_t __s1 = 0u;
  long long v164 = 0u;
  arraCGFloat y = 0;
  CGPDFDictionaryGetArray(v124, "H", &array);
  if (!array
    || *((void *)array + 2) != 2
    || (CGPDFInteger v160 = 0, valuePtr = 0, !CGPDFArrayGetInteger(array, 0, &valuePtr))
    || !CGPDFArrayGetInteger(array, 1uLL, &v160))
  {
    uint64_t v132 = 0;
LABEL_163:
    pdf_object_scanner_release(v132);
    v15[4] = 0;
    goto LABEL_173;
  }
  unint64_t v125 = pdf_object_scanner_create_with_xref((const void **)v15, 0);
  uint64_t v132 = v125;
  if (!v125) {
    goto LABEL_163;
  }
  CGPDFSourceSetPosition(v125[1], valuePtr, v126, v127, v128, v129, v130, v131);
  if (!pdf_object_scanner_read_indirect_object(v132, (uint64_t)__s1, v133, v134, v135, v136, v137, v138)) {
    goto LABEL_163;
  }
  if (LODWORD(__s1[1]) != 9)
  {
    if ((LODWORD(__s1[1]) - 5) <= 4) {
      pdf_object_release_compound_value((uint64_t)__s1);
    }
    goto LABEL_163;
  }
  uint64_t v158 = v132;
  uint64_t v139 = v165;
  CFAllocatorRef v140 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 11, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  uint64_t v142 = 0;
  CFAllocatorRef v143 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  do
  {
    if (v139) {
      uint64_t v144 = (CGPDFDictionary *)*((void *)v139 + 6);
    }
    else {
      uint64_t v144 = 0;
    }
    uint64_t v145 = off_1E52B5090[v142];
    if (CGPDFDictionaryGetInteger(v144, v145, &valuePtr))
    {
      CFStringRef v146 = CFStringCreateWithCStringNoCopy(v140, v145, 0x8000100u, v143);
      CFNumberRef v147 = CFNumberCreate(v140, kCFNumberLongType, &valuePtr);
      CFNumberRef v148 = v147;
      if (v146) {
        BOOL v149 = v147 == 0;
      }
      else {
        BOOL v149 = 1;
      }
      if (!v149)
      {
        CFDictionaryAddValue(Mutable, v146, v147);
LABEL_155:
        CFRelease(v146);
        if (!v148) {
          goto LABEL_157;
        }
LABEL_156:
        CFRelease(v148);
        goto LABEL_157;
      }
      if (v146) {
        goto LABEL_155;
      }
      if (v147) {
        goto LABEL_156;
      }
    }
    else if (*v145 == 83)
    {
      goto LABEL_164;
    }
LABEL_157:
    ++v142;
  }
  while (v142 != 11);
  CFDataRef v150 = CGPDFStreamCopyData(v139, 0);
  if (v150)
  {
    CFDataRef v151 = v150;
    if (CFDataGetLength(v150)) {
      operator new();
    }
    if (v139) {
      CFRelease(v139);
    }
    uint64_t v139 = v151;
    goto LABEL_169;
  }
LABEL_164:
  if (!v139) {
    goto LABEL_170;
  }
LABEL_169:
  CFRelease(v139);
LABEL_170:
  if (Mutable) {
    CFRelease(Mutable);
  }
  pdf_object_scanner_release(v158);
  v15[4] = 0;
LABEL_173:
  if (v19 != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v152 = v15[3];
    if (v152) {
      CFRelease(v152);
    }
    void v15[3] = 0;
    goto LABEL_179;
  }
LABEL_174:
  pdf_xref_release((uint64_t)v15);
  return 0;
}

void sub_184CA7DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  if (a2)
  {
    __cxa_free_exception(v28);
    uint64_t v31 = a28[11];
    a28[11] = 0;
    if (v31) {
      MEMORY[0x18532A2A0](v31, 0x1000C40451B5BE8);
    }
    uint64_t v32 = a28[10];
    a28[10] = 0;
    if (v32) {
      MEMORY[0x18532A2A0](v32, 0x1000C40451B5BE8);
    }
    uint64_t v33 = a28[9];
    a28[9] = 0;
    if (v33) {
      std::default_delete<CGSharedObjectHintTable>::operator()[abi:fe180100](v33);
    }
    std::unique_ptr<CGPageOffsetHintTable>::reset[abi:fe180100](a21, 0);
    MEMORY[0x18532A2A0](a28, 0x10A1C40AA68228DLL);
    uint64_t v34 = __cxa_begin_catch(exception_object);
    if (a2 == 2)
    {
      (*(void (**)(void *))(*(void *)v34 + 16))(v34);
      pdf_error("CGHintTableSet constructor failed with exception: %s");
    }
    else
    {
      pdf_error("CGHintTableSet constructor failed with an unknown exception:");
    }
    __cxa_end_catch();
    JUMPOUT(0x184CA793CLL);
  }
  _Unwind_Resume(exception_object);
}

void *CGPDFArraySetObjectReference(void *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    result[5] = a2;
    result[6] = a3;
    for (char i = (void *)result[3]; i; char i = (void *)*i)
      double result = (void *)CGPDFObjectSetOwningReference((uint64_t)i, a2, a3);
  }
  return result;
}

void *xref_table_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10) {
    uint64_t v11 = *(void **)(v10 + 8);
  }
  else {
    uint64_t v11 = 0;
  }
  CGPDFSourceSetPosition((uint64_t)v11, a2, a3, a4, a5, a6, a7, a8);
  if (!CGPDFSourceMatch((uint64_t)v11, (uint64_t)"xref", v12, v13, v14, v15, v16, v17))
  {
    pdf_error("failed to find start of cross-reference section.");
    return 0;
  }
  uint64_t v18 = malloc_type_calloc(1uLL, 0x30uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v18)
  {
    uint64_t v25 = 0;
    uint64_t v94 = 0;
    *uint64_t v18 = 0;
    v18[1] = a2;
    while (1)
    {
      unint64_t v96 = 0;
      if (!read_integer(v11, &v96, v19, v20, v21, v22, v23, v24)
        || (unint64_t v32 = v96, (v96 & 0x8000000000000000) != 0))
      {
        if (!v25) {
          goto LABEL_74;
        }
        uint64_t v79 = 0;
        do
        {
          uint64_t v80 = v25;
          uint64_t v81 = v79;
          uint64_t v25 = (void *)*v25;
          *uint64_t v80 = v79;
          uint64_t v79 = v80;
        }
        while (v25);
        if (!v81)
        {
          uint64_t v92 = (void *)v80[1];
          if ((uint64_t)v92[1] >= 1 && *v92 && !v92[3])
          {
            pdf_error("invalid first entry in cross-reference table.");
            uint64_t v90 = v80;
            goto LABEL_73;
          }
        }
        v18[5] = v80;
        if (!CGPDFSourceMatch((uint64_t)v11, (uint64_t)"trailer", v26, v27, v28, v29, v30, v31))
        {
          pdf_error("invalid cross-reference section: missing trailer.");
          goto LABEL_75;
        }
        if (v11)
        {
          uint64_t v88 = v11[11];
          if (v11[18])
          {
            uint64_t v89 = v11[24];
            v88 += v11[15];
          }
          else
          {
            uint64_t v89 = v11[16];
          }
          uint64_t v93 = v89 - v88 + v11[14] - 7;
        }
        else
        {
          uint64_t v93 = -8;
        }
        v18[3] = v93;
        if ((read_dictionary(*(uint64_t **)(a1 + 16), v18 + 2, v82, v83, v84, v85, v86, v87) & 1) == 0)
        {
          pdf_error("missing or invalid cross-reference trailer.");
          goto LABEL_75;
        }
        if (CGPDFDictionaryGetOffset((CGPDFDictionary *)v18[2], "XRefStm", &v94)) {
          v18[4] = CGPDFXRefStreamCreate(*(const void ***)a1, v94, 0);
        }
        return v18;
      }
      if (v96 > 0x989680)
      {
        pdf_error("invalid cross-reference starting object.");
        goto LABEL_72;
      }
      unint64_t v96 = 0;
      if (!read_integer(v11, &v96, v26, v27, v28, v29, v30, v31)
        || (unint64_t v33 = v96, (v96 & 0x8000000000000000) != 0))
      {
        pdf_error("missing or invalid cross-reference count.");
        goto LABEL_72;
      }
      if (v96 > 0x989680 || v96 && (uint64_t)(v32 + v96) > 10000001)
      {
        pdf_error("invalid cross-reference count.");
        goto LABEL_72;
      }
      uint64_t v34 = malloc_type_calloc(1uLL, 8 * v96 + 24, 0x33BCE901uLL);
      __CFSetLastAllocationEventName();
      if (!v34) {
        goto LABEL_72;
      }
      *uint64_t v34 = v32;
      v34[1] = v33;
      if (v11)
      {
        uint64_t v35 = v11[11];
        if (v11[18])
        {
          uint64_t v36 = v11[24];
          v35 += v11[15];
        }
        else
        {
          uint64_t v36 = v11[16];
        }
        uint64_t v37 = v36 - v35 + v11[14];
      }
      else
      {
        uint64_t v37 = -1;
      }
      CGPDFSourcePreflightLargeRead((uint64_t)v11, v37, 20 * v33);
      if ((uint64_t)v34[1] >= 1) {
        break;
      }
LABEL_51:
      uint64_t v78 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v78 = v25;
      v78[1] = v34;
      uint64_t v25 = v78;
    }
    uint64_t v45 = 0;
    while (1)
    {
      uint64_t v46 = v11[15];
      if (v46) {
        goto LABEL_27;
      }
      if (CGPDFSourceRefill((uint64_t)v11, v38, v39, v40, v41, v42, v43, v44)) {
        break;
      }
      unsigned int v48 = -1;
LABEL_28:
      unint64_t v96 = 0;
      unsigned int v95 = v48;
      skip_whitespace((uint64_t)v11, &v95, v39, v40, v41, v42, v43, v44);
      if (!read_integer_16236((uint64_t)v11, &v96, &v95, v49, v50, v51, v52, v53))
      {
        pdf_error("missing or invalid cross-reference offset.");
        goto LABEL_61;
      }
      unint64_t v60 = "missing or invalid cross-reference offset.";
      if ((v96 & 0x8000000000000000) != 0) {
        goto LABEL_60;
      }
      uint64_t v61 = &v34[v45];
      _OWORD v61[3] = v96;
      if (!skip_whitespace((uint64_t)v11, &v95, v54, v55, v56, v57, v58, v59))
      {
LABEL_53:
        pdf_error("invalid cross-reference entry: missing separator.");
        goto LABEL_61;
      }
      if (!read_integer_16236((uint64_t)v11, &v96, &v95, v62, v63, v64, v65, v66))
      {
        pdf_error("missing or invalid cross-reference generation number.");
        goto LABEL_61;
      }
      unint64_t v73 = v96;
      if (!skip_whitespace((uint64_t)v11, &v95, v67, v68, v69, v70, v71, v72)) {
        goto LABEL_53;
      }
      if (v95 == 110)
      {
        if (v73 >> 16)
        {
          unint64_t v60 = "Object entry has invalid cross-reference generation number.";
LABEL_60:
          pdf_error(v60);
LABEL_61:
          free(v34);
LABEL_72:
          uint64_t v90 = v25;
LABEL_73:
          xref_section_list_release(v90);
LABEL_74:
          v18[5] = 0;
LABEL_75:
          xref_table_release((uint64_t)v18);
          return 0;
        }
        LODWORD(v73) = (unsigned __int16)v73;
      }
      else
      {
        if (v95 != 102)
        {
          goto LABEL_61;
        }
        LODWORD(v73) = 0;
        _OWORD v61[3] = 0;
      }
      uint64_t v74 = v11[15];
      if (!v74)
      {
        if (!CGPDFSourceRefill((uint64_t)v11, v38, v39, v40, v41, v42, v43, v44)) {
          goto LABEL_57;
        }
        uint64_t v74 = v11[15];
      }
      uint64_t v75 = (unsigned __int8 *)v11[16];
      v11[15] = v74 - 1;
      v11[16] = v75 + 1;
      unsigned int v76 = *v75;
      if (v76 > 0x20)
      {
LABEL_57:
        pdf_error("invalid cross-reference entry: missing terminator.");
        goto LABEL_61;
      }
      unint64_t v60 = "invalid cross-reference entry: missing terminator.";
      if (((1 << v76) & 0x100002400) == 0) {
        goto LABEL_60;
      }
      if (v73)
      {
        uint64_t v77 = (_WORD *)v34[2];
        if (!v77)
        {
          uint64_t v77 = malloc_type_calloc(1uLL, 2 * v34[1], 0x33BCE901uLL);
          __CFSetLastAllocationEventName();
          if (!v77) {
            goto LABEL_61;
          }
          v34[2] = v77;
        }
        v77[v45] = v73;
      }
      if (++v45 >= v34[1]) {
        goto LABEL_51;
      }
    }
    uint64_t v46 = v11[15];
LABEL_27:
    uint64_t v47 = (unsigned __int8 *)v11[16];
    v11[15] = v46 - 1;
    v11[16] = v47 + 1;
    unsigned int v48 = *v47;
    goto LABEL_28;
  }
  return v18;
}

uint64_t skip_whitespace(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10 = 0;
  unsigned int v11 = *a2;
  while (v11 <= 0x20 && ((1 << v11) & 0x100003601) != 0)
  {
    uint64_t v12 = *(void *)(a1 + 120);
    if (v12) {
      goto LABEL_7;
    }
    int v13 = CGPDFSourceRefill(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    char v10 = 1;
    unsigned int v11 = -1;
    if (v13)
    {
      uint64_t v12 = *(void *)(a1 + 120);
LABEL_7:
      uint64_t v14 = *(unsigned __int8 **)(a1 + 128);
      *(void *)(a1 + 120) = v12 - 1;
      *(void *)(a1 + 128) = v14 + 1;
      unsigned int v11 = *v14;
      char v10 = 1;
    }
  }
  *a2 = v11;
  return v10 & 1;
}

uint64_t read_integer(void *a1, unint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGPDFSourceSkipWhitespace(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = a1[15];
  if (!v17)
  {
    if (!CGPDFSourceRefill((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16))
    {
      uint64_t v22 = 0;
      LODWORD(v21) = -1;
      goto LABEL_29;
    }
    uint64_t v17 = a1[15];
  }
  uint64_t v18 = v17 - 1;
  uint64_t v19 = (unsigned __int8 *)a1[16];
  uint64_t v20 = v19 + 1;
  a1[15] = v18;
  a1[16] = v19 + 1;
  uint64_t v21 = *v19;
  if ((v21 - 58) < 0xFFFFFFF6)
  {
LABEL_5:
    uint64_t v22 = 0;
    goto LABEL_29;
  }
  while (v21 == 48)
  {
    if (!v18)
    {
      if (!CGPDFSourceRefill((uint64_t)a1, v21, v11, v12, v13, v14, v15, v16))
      {
        unint64_t v24 = 0;
        LODWORD(v21) = -1;
        goto LABEL_23;
      }
      uint64_t v18 = a1[15];
      uint64_t v20 = (unsigned __int8 *)a1[16];
    }
    uint64_t v23 = v20;
    --v18;
    ++v20;
    a1[15] = v18;
    a1[16] = v20;
    uint64_t v21 = *v23;
  }
  if ((v21 - 48) > 9)
  {
    unint64_t v24 = 0;
    goto LABEL_23;
  }
  unint64_t v24 = 0;
  char v25 = 0;
  while (1)
  {
    v25 |= v24 > 0x1999999999999998;
    unint64_t v24 = 10 * v24 + v21 - 48;
    if (!v18) {
      break;
    }
LABEL_16:
    a1[15] = --v18;
    a1[16] = v20 + 1;
    uint64_t v21 = *v20++;
    if ((v21 - 48) >= 0xA)
    {
      if (v25) {
        goto LABEL_5;
      }
      goto LABEL_23;
    }
  }
  if (CGPDFSourceRefill((uint64_t)a1, v21, v11, v12, v13, v14, v15, v16))
  {
    uint64_t v18 = a1[15];
    uint64_t v20 = (unsigned __int8 *)a1[16];
    goto LABEL_16;
  }
  LODWORD(v21) = -1;
  if (v25) {
    goto LABEL_5;
  }
LABEL_23:
  if (a2) {
    *a2 = v24;
  }
  uint64_t v22 = 1;
  if ((v21 + 1) <= 0x3F && ((1 << (v21 + 1)) & 0xA001064200006C03) != 0
    || (uint64_t result = 0, (v21 - 91) <= 0x22) && ((1 << (v21 - 91)) & 0x500000005) != 0)
  {
LABEL_29:
    CGPDFSourceUngetc(a1, v21);
    return v22;
  }
  return result;
}

void *CGPDFSourceSkipWhitespace(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[15];
  while (v9)
  {
LABEL_5:
    --v9;
    uint64_t v10 = (unsigned __int8 *)a1[16];
    a1[15] = v9;
    a1[16] = v10 + 1;
    a2 = *v10;
    if (a2 > 0x20 || ((1 << a2) & 0x100003601) == 0) {
      goto LABEL_12;
    }
  }
  if (CGPDFSourceRefill((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v9 = a1[15];
    goto LABEL_5;
  }
  LODWORD(a2) = -1;
LABEL_12:

  return CGPDFSourceUngetc(a1, a2);
}

BOOL CGPDFSourceMatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned char *)a2;
  do
  {
    int v10 = *v8;
    if (!*v8) {
      break;
    }
    uint64_t v11 = *(void *)(a1 + 120);
    if (!v11)
    {
      if (!CGPDFSourceRefill(a1, a2, a3, a4, a5, a6, a7, a8)) {
        return v10 == 0;
      }
      uint64_t v11 = *(void *)(a1 + 120);
    }
    ++v8;
    uint64_t v12 = *(unsigned __int8 **)(a1 + 128);
    *(void *)(a1 + 120) = v11 - 1;
    *(void *)(a1 + 128) = v12 + 1;
  }
  while (*v12 == v10);
  return v10 == 0;
}

void CGPDFSourcePreflightLargeRead(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (v4)
    {
      size_t v5 = a3;
      if (a3 > 2 * *(void *)(a1 + 96))
      {
        uint64_t v6 = *(void *)(v4 + 272);
        if (v6)
        {
          if (CGPropertiesGetProperty(v6, @"kCGDataProviderHasHighLatency"))
          {
            if (v5 >= 0x1000000) {
              size_t v5 = 0x1000000;
            }
            uint64_t v8 = (char *)malloc_type_malloc(v5, 0xC6C9CD0AuLL);
            CGDataProviderGetBytesAtPosition(*(void *)(a1 + 40), v8, a2, v5);
            free(v8);
          }
        }
      }
    }
  }
}

void *xref_read_linearization_dictionary(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v9 = a1[11];
    if (a1[18])
    {
      uint64_t v10 = a1[24];
      v9 += a1[15];
    }
    else
    {
      uint64_t v10 = a1[16];
    }
    uint64_t v11 = v10 - v9 + a1[14];
  }
  else
  {
    uint64_t v11 = -1;
  }
  CGPDFReal value = 0.0;
  CGPDFInteger v74 = 0;
  CGPDFArrayRef v72 = 0;
  CGPDFSourceSetPosition((uint64_t)a1, 1024, a3, a4, a5, a6, a7, a8);
  int v12 = CGPDFSourceReverseSearch(a1, "/Linearized", 0, 0, &v71);
  CGPDFSourceSetPosition((uint64_t)a1, v11, v13, v14, v15, v16, v17, v18);
  uint64_t v19 = 0;
  if (!v12) {
    return v19;
  }
  uint64_t v20 = malloc_type_malloc(0x20uLL, 0x566C45D1uLL);
  __CFSetLastAllocationEventName();
  if (!v20) {
    return 0;
  }
  *uint64_t v20 = 0;
  v20[1] = a1;
  void v20[2] = pdf_lexer_create(0, a1, 0);
  *((unsigned char *)v20 + 24) = 0;
  CGPDFSourceSetPosition(v20[1], 0, v21, v22, v23, v24, v25, v26);
  unsigned int v76 = 0;
  memset(v75, 0, sizeof(v75));
  if (pdf_lexer_scan(v20[2], (uint64_t)v75, v27, v28, v29, v30, v31, v32) != 4
    || pdf_lexer_scan(v20[2], (uint64_t)v75, v33, v34, v35, v36, v37, v38) != 4
    || pdf_lexer_scan(v20[2], (uint64_t)v75, v39, v40, v41, v42, v43, v44) != 16)
  {
    int v57 = DWORD2(v75[0]);
    goto LABEL_18;
  }
  if (!pdf_object_scanner_read_object(v20, (uint64_t)v75, v45, v46, v47, v48, v49, v50))
  {
LABEL_20:
    uint64_t v19 = 0;
    goto LABEL_21;
  }
  int v57 = DWORD2(v75[0]);
  if (DWORD2(v75[0]) != 8)
  {
LABEL_18:
    if ((v57 - 5) <= 4) {
      pdf_object_release_compound_value((uint64_t)v75);
    }
    goto LABEL_20;
  }
  uint64_t v19 = v76;
  if (pdf_lexer_scan(v20[2], (uint64_t)v75, v51, v52, v53, v54, v55, v56) != 17 && v19)
  {
    CFRelease(v19);
    goto LABEL_20;
  }
LABEL_21:
  pdf_lexer_release(v20[2]);
  free(v20);
  if (v19)
  {
    if (!CGPDFDictionaryGetNumber((CGPDFDictionaryRef)v19, "Linearized", &value))
    {
LABEL_45:
      CFRelease(v19);
      return 0;
    }
    if (value != 1.0)
    {
      pdf_log("unsupported linearization version.", value);
      goto LABEL_45;
    }
    if (!CGPDFDictionaryGetInteger((CGPDFDictionaryRef)v19, "L", &v74))
    {
      pdf_log("missing or invalid linearization length.", v65);
      goto LABEL_45;
    }
    uint64_t Length = CGPDFSourceGetLength((uint64_t)a1, v58, v59, v60, v61, v62, v63, v64);
    if (Length == 0x7FFFFFFFFFFFFFFFLL && a1)
    {
      uint64_t v67 = a1[5];
      if (v67)
      {
        size_t BytesAtPosition = CGDataProviderGetBytesAtPosition(v67, (char *)v75, v74 - 1023, 0x400uLL);
        uint64_t Length = 0x7FFFFFFFFFFFFFFFLL;
        if (BytesAtPosition == 1023)
        {
          uint64_t Length = v74;
          if (a1[2] == 0x7FFFFFFFFFFFFFFFLL) {
            a1[2] = v74;
          }
        }
      }
      else
      {
        uint64_t Length = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    if (v74 != Length)
    {
      pdf_log("linearization length mismatch.");
      goto LABEL_45;
    }
    if (!CGPDFDictionaryGetArray((CGPDFDictionaryRef)v19, "H", &v72)) {
      goto LABEL_42;
    }
    if (!v72 || *((void *)v72 + 2) != 2)
    {
      pdf_log("invalid hints array (CGSize size = %zu)", v69);
      goto LABEL_45;
    }
    if (!CGPDFDictionaryGetInteger((CGPDFDictionaryRef)v19, "O", &v74)
      || !CGPDFDictionaryGetInteger((CGPDFDictionaryRef)v19, "E", &v74)
      || !CGPDFDictionaryGetInteger((CGPDFDictionaryRef)v19, "N", &v74)
      || !CGPDFDictionaryGetInteger((CGPDFDictionaryRef)v19, "T", &v74))
    {
LABEL_42:
      pdf_log("missing a required parameter (%s) in Linearization dictionary.", v69);
      goto LABEL_45;
    }
  }
  return v19;
}

uint64_t read_dictionary(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t result = pdf_object_scanner_read_object(a1, (uint64_t)v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if (DWORD2(v10[0]) == 8)
    {
      if (a2) {
        *a2 = v11;
      }
      return 1;
    }
    else
    {
      if ((DWORD2(v10[0]) - 5) <= 4) {
        pdf_object_release_compound_value((uint64_t)v10);
      }
      return 0;
    }
  }
  return result;
}

void *CGPDFXRefTableCreate(const void **a1, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v23 = a2;
  uint64_t v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v6)
  {
    *uint64_t v6 = a1;
    size_t v7 = pdf_object_scanner_create_with_xref(a1, 0);
    _OWORD v6[2] = v7;
    if (v7)
    {
      uint64_t v14 = v6 + 1;
      while (1)
      {
        uint64_t v15 = xref_table_create((uint64_t)v6, v4, v8, v9, v10, v11, v12, v13);
        if (!v15) {
          break;
        }
        uint64_t v16 = v15;
        uint64_t v17 = (void *)*v14;
        uint64_t v18 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        *uint64_t v18 = v17;
        v18[1] = v16;
        *uint64_t v14 = v18;
        if (!a3) {
          goto LABEL_14;
        }
        if (!CGPDFDictionaryGetOffset((CGPDFDictionary *)v16[2], "Prev", &v23))
        {
          uint64_t v18 = (void *)*v14;
LABEL_14:
          uint64_t v21 = 0;
          do
          {
            uint64_t v22 = v18;
            uint64_t v18 = (void *)*v18;
            *uint64_t v22 = v21;
            uint64_t v21 = v22;
          }
          while (v18);
          *uint64_t v14 = v22;
          if (!CGPDFDictionaryGetObject(*(CGPDFDictionaryRef *)(v22[1] + 16), "Root", 0)) {
            break;
          }
          return v6;
        }
        uint64_t v4 = v23;
        if (!v23) {
          break;
        }
        uint64_t v19 = v6 + 1;
        while (1)
        {
          uint64_t v19 = (void *)*v19;
          if (!v19) {
            break;
          }
          if (*(void *)(v19[1] + 8) == v23) {
            goto LABEL_11;
          }
        }
      }
    }
LABEL_11:
    CGPDFXRefTableRelease((uint64_t)v6);
    return 0;
  }
  return v6;
}

BOOL CGPDFDictionaryGetOffset(CGPDFDictionary *a1, const char *a2, void *a3)
{
  CGPDFObjectRef value = 0;
  BOOL result = CGPDFDictionaryGetObject(a1, a2, &value);
  if (result)
  {
    if (value && ((int v5 = *((_DWORD *)value + 2), v5 != 12) ? (v6 = v5 == 3) : (v6 = 1), v6))
    {
      if (a3) {
        *a3 = *((void *)value + 4);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *pdf_object_scanner_create_with_xref(const void **a1, int a2)
{
  uint64_t v4 = malloc_type_malloc(0x20uLL, 0x566C45D1uLL);
  __CFSetLastAllocationEventName();
  if (v4)
  {
    int v5 = *a1;
    *uint64_t v4 = a1;
    v4[1] = v5;
    if (a2) {
      int v6 = 2;
    }
    else {
      int v6 = 0;
    }
    v4[2] = pdf_lexer_create((uint64_t)a1, v5, v6);
    *((unsigned char *)v4 + 24) = a2;
  }
  return v4;
}

void *pdf_lexer_create(uint64_t a1, const void *a2, int a3)
{
  int v6 = malloc_type_malloc(0x50uLL, 0x566C45D1uLL);
  __CFSetLastAllocationEventName();
  if (v6)
  {
    *(_DWORD *)int v6 = 1;
    v6[1] = a1;
    if (a2) {
      CFRetain(a2);
    }
    _OWORD v6[2] = a2;
    v6[3] = 0;
    v6[4] = 0;
    void v6[5] = 0;
    *((_DWORD *)v6 + 14) = a3;
  }
  return v6;
}

uint64_t CGPDFSourceForwardSearch(void *a1, char *__s, char *a3, uint64_t *a4)
{
  if (!__s) {
    return 0;
  }
  size_t v7 = strlen(__s);
  size_t v11 = v7;
  if (a1)
  {
    uint64_t v12 = a1[11];
    if (a1[18])
    {
      uint64_t v13 = a1[24];
      v12 += a1[15];
    }
    else
    {
      uint64_t v13 = a1[16];
    }
    uint64_t v16 = v13 - v12;
    uint64_t v14 = a1[2];
    if (v14 == -1) {
      _CGHandleAssert("CGPDFSourceGetLength", 179, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Reader/CGPDFSource.c", "source->length != (pdf_off_t)-1", "source length would overflow", v8, v9, v10, v50);
    }
    uint64_t v15 = v16 + a1[14];
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = -1;
  }
  if (v14 < (uint64_t)(v15 + v7)) {
    return 0;
  }
  uint64_t v51 = a4;
  size_t v18 = 64;
  do
  {
    int64_t v19 = v18;
    v18 *= 2;
  }
  while (v19 < v11);
  LOBYTE(__c) = 0;
  uint64_t v20 = (char *)malloc_type_malloc(v18, 0x611A2241uLL);
  uint64_t v27 = v20;
  uint64_t v17 = 0;
  if (v15 >= v14) {
    goto LABEL_42;
  }
  uint64_t v52 = v20;
  while (1)
  {
    if (v19 + v15 > v14) {
      int64_t v19 = v14 - v15;
    }
    CGPDFSourceSetPosition((uint64_t)a1, v15, v21, v22, v23, v24, v25, v26);
    if (CGPDFSourceRead((uint64_t)a1, (uint64_t)v27, v19, v28, v29, v30, v31, v32) != v19)
    {
      pdf_error("failed to read %zu bytes at offset %lld.", v19, v15);
LABEL_41:
      uint64_t v17 = 0;
      goto LABEL_42;
    }
    uint64_t v33 = &v27[v19];
    uint64_t v34 = v15;
    if (v19 >= 1) {
      break;
    }
LABEL_34:
    v15 += v19;
    uint64_t v27 = v52;
    if (v15 >= v14) {
      goto LABEL_41;
    }
  }
  while (1)
  {
    int64_t v35 = v11 + v34;
    if (*v27 == *__s && v35 <= v14)
    {
      if (&v27[v11] > v33)
      {
        CGPDFSourceSetPosition((uint64_t)a1, v34, v21, v22, v23, v24, v25, v26);
        if (CGPDFSourceRead((uint64_t)a1, (uint64_t)v27, v11, v37, v38, v39, v40, v41) != v11)
        {
          pdf_error("failed to read %zu bytes at offset %lld.", v11, v34);
          goto LABEL_39;
        }
      }
      if (!strncmp(v27, __s, v11)) {
        break;
      }
    }
LABEL_23:
    ++v27;
    ++v34;
    if (v27 >= v33) {
      goto LABEL_34;
    }
  }
  if (!a3 || v35 >= v14)
  {
LABEL_36:
    uint64_t v27 = v52;
    *uint64_t v51 = v34;
    uint64_t v17 = 1;
    goto LABEL_42;
  }
  CGPDFSourceSetPosition((uint64_t)a1, v11 + v34, v21, v22, v23, v24, v25, v26);
  if (CGPDFSourceRead((uint64_t)a1, (uint64_t)&__c, 1uLL, v42, v43, v44, v45, v46) == 1)
  {
    int v47 = (char)__c;
    uint64_t v48 = strchr(a3, (char)__c);
    if (!v47 || v48) {
      goto LABEL_36;
    }
    goto LABEL_23;
  }
  pdf_error("failed to read %zu bytes at offset %lld.", 1uLL, v11 + v34);
LABEL_39:
  uint64_t v17 = 0;
  uint64_t v27 = v52;
LABEL_42:
  free(v27);
  return v17;
}

unsigned char *CGFontIsFixedPitch(void *a1)
{
  BOOL result = get_font_info(a1);
  if (result) {
    return (unsigned char *)(result[48] != 0);
  }
  return result;
}

CGFloat CGFontGetItalicAngle(CGFontRef font)
{
  font_info = (double *)get_font_info(font);
  if (font_info) {
    return font_info[7];
  }
  else {
    return 0.0;
  }
}

uint64_t rgba32_shade(uint64_t a1, __n128 a2)
{
  __int16 v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x3000000)
  {
    if (*(void *)(v5 + 16))
    {
      uint64_t v14 = rgba32_shade_radial_RGB;
    }
    else if (*(void *)(v5 + 24))
    {
      uint64_t v14 = rgba32_shade_conic_RGB;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      uint64_t v14 = rgba32_shade_axial_RGB;
    }
    else
    {
      uint64_t v14 = rgba32_shade_custom_RGB;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 3, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 480)
    {
      uint64_t v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 2, 3, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    uint64_t v16 = malloc_type_malloc(8 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  rgba32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

uint64_t A8_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  BOOL v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v16, (uint64_t)v28) < 1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v12 = *(unsigned char *)(v5 + 3) & 0xF;
  if (v12 <= 4 && ((1 << v12) & 0x1A) != 0)
  {
    if (*(void *)(v5 + 16))
    {
      __n128 v13 = A8_shade_radial_A;
    }
    else if (*(void *)(v5 + 24))
    {
      __n128 v13 = A8_shade_conic_A;
    }
    else if (v22 < 2)
    {
      __n128 v13 = A8_shade_axial_A;
    }
    else
    {
      __n128 v13 = A8_shade_custom_A;
    }
    uint64_t v16 = v13;
    if (v26)
    {
      long long v25 = v31;
      _blt_shade_samples_16((uint64_t)v31, 2, 0, v26, v27, 1uLL);
    }
    unint64_t v14 = v22 * v21;
    if (v22 * v21 <= 1920)
    {
      unint64_t v15 = v29;
      long long v23 = v29;
LABEL_28:
      _blt_shade_samples_16((uint64_t)v15, 2, 0, v19, v20, v14);
      if (*(unsigned char *)(v5 + 1)) {
        long long v24 = &_blt_shade_samples_noise;
      }
      goto LABEL_30;
    }
    unint64_t v15 = malloc_type_malloc(2 * v14 + 32, 0xAC797572uLL);
    if (v15)
    {
      long long v23 = v15;
      unint64_t v14 = v22 * v21;
      goto LABEL_28;
    }
    return 0xFFFFFFFFLL;
  }
  if (!v16) {
    return 0xFFFFFFFFLL;
  }
LABEL_30:
  int v17 = *v7;
  int v18 = v17;
  A8_image_mark(v6, (uint64_t)&v16, v9, v11);
  if (v23 && (v23 < v29 || &v30 < v23)) {
    free(v23);
  }
  return 1;
}

uint64_t argb32_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x3000000)
  {
    if (*(void *)(v5 + 16))
    {
      unint64_t v14 = argb32_shade_radial_RGB;
    }
    else if (*(void *)(v5 + 24))
    {
      unint64_t v14 = argb32_shade_conic_RGB;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      unint64_t v14 = argb32_shade_axial_RGB;
    }
    else
    {
      unint64_t v14 = argb32_shade_custom_RGB;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 3, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 480)
    {
      uint64_t v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 2, 3, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    uint64_t v16 = malloc_type_malloc(8 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  argb32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

uint64_t RGBA32_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if (v11 >= 24 && *(_DWORD *)v8 == 134755208) {
    v11 += 4;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x3000000)
  {
    if (*(void *)(v5 + 16))
    {
      unint64_t v14 = RGBA32_shade_radial_RGB;
    }
    else if (*(void *)(v5 + 24))
    {
      unint64_t v14 = RGBA32_shade_conic_RGB;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      unint64_t v14 = RGBA32_shade_axial_RGB;
    }
    else
    {
      unint64_t v14 = RGBA32_shade_custom_RGB;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 3, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 480)
    {
      uint64_t v16 = v44;
      v38[1] = v44;
LABEL_30:
      _blt_shade_samples_16((uint64_t)v16, 2, 3, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_32;
    }
    uint64_t v16 = malloc_type_malloc(8 * v15 + 32, 0xE83E6668uLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_30;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_32:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  argb32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

uint64_t _blt_shade_initialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(float **)(a2 + 40);
  double v5 = *v4;
  double v6 = v4[1];
  double v7 = v4[2];
  double v8 = v4[3];
  double v9 = v5 * v8 - v6 * v7;
  if (v9 == 0.0) {
    return 0xFFFFFFFFLL;
  }
  double v11 = v4[5];
  double v12 = v4[4];
  double v13 = 1.0 / v9;
  *(void *)(a3 + 272) = &_blt_shade_constants;
  double v14 = v13 * v5;
  double v15 = v13 * v6;
  double v20 = v13 * v7;
  double v16 = v13 * v8;
  double v17 = v20 * v11 - v16 * v12;
  double v18 = v15 * v12 - v14 * v11;
  *(float *)&double v12 = v16;
  *(_DWORD *)(a3 + 280) = LODWORD(v12);
  float v19 = v15;
  *(float *)(a3 + 284) = -v19;
  *(float *)&double v20 = v20;
  *(float *)(a3 + 288) = -*(float *)&v20;
  float v21 = v14;
  *(float *)(a3 + 292) = v21;
  float v22 = v17;
  *(float *)(a3 + 296) = v22;
  float v23 = v18;
  *(float *)(a3 + 300) = v23;
  uint64_t v10 = 0xFFFFFFFFLL;
  if (fabsf(*(float *)&v12) == INFINITY
    || fabsf(v19) == INFINITY
    || fabsf(*(float *)&v20) == INFINITY
    || fabsf(v21) == INFINITY
    || fabsf(v22) == INFINITY
    || fabsf(v23) == INFINITY)
  {
    return v10;
  }
  uint64_t v24 = *(void *)(a2 + 32);
  if (v24)
  {
    float v25 = *(float *)v24;
    *(_DWORD *)(a3 + 304) = *(_DWORD *)v24;
    float v26 = *(float *)(v24 + 4);
    *(float *)(a3 + 308) = v26;
    *(_DWORD *)(a3 + 312) = *(_DWORD *)(v24 + 8);
    float v27 = *(float *)(v24 + 12);
  }
  else
  {
    *(_DWORD *)(a3 + 312) = 0;
    *(void *)(a3 + 304) = 0x3F80000000000000;
    float v25 = 0.0;
    float v26 = 1.0;
    float v27 = 1.0;
  }
  *(float *)(a3 + 316) = v27;
  *(void *)(a3 + 360) = 0;
  unsigned int v28 = *(_DWORD *)(a2 + 48);
  double v29 = (double)v28;
  LODWORD(v20) = *(_DWORD *)(a2 + 52);
  double v30 = (double)*(unint64_t *)&v20;
  long long v31 = *(float **)(a2 + 56);
  if (v31)
  {
    float v32 = (v29 + -0.00390625) / (float)(v31[1] - *v31);
    *(float *)(a3 + 344) = v32;
    float v33 = *v31;
    *(float *)(a3 + 336) = *v31;
    *(float *)(a3 + 340) = v31[1];
    float v34 = (v30 + -0.00390625) / (float)(v31[3] - v31[2]);
    *(float *)(a3 + 356) = v34;
    *(float *)(a3 + 348) = v31[2];
    float v35 = v31[3];
  }
  else
  {
    *(_DWORD *)(a3 + 348) = 0;
    float v32 = v29 + -0.00390625;
    *(float *)(a3 + 344) = v32;
    *(void *)(a3 + 336) = 0x3F80000000000000;
    float v36 = v30 + -0.00390625;
    *(float *)(a3 + 356) = v36;
    float v35 = 1.0;
    float v33 = 0.0;
  }
  *(float *)(a3 + 352) = v35;
  *(void *)(a3 + 328) = -1;
  if ((*(unsigned char *)(a2 + 3) & 0x10) == 0)
  {
    int v37 = -1;
LABEL_20:
    *(_DWORD *)(a3 + 320) = v37;
    goto LABEL_22;
  }
  unsigned int v38 = vcvtms_s32_f32(v32 * (float)(v25 - v33));
  *(_DWORD *)(a3 + 320) = v38;
  if ((v38 & 0x80000000) == 0)
  {
    if (v28 > v38) {
      goto LABEL_22;
    }
    int v37 = v28 - 1;
    goto LABEL_20;
  }
  *(_DWORD *)(a3 + 320) = 0;
LABEL_22:
  if ((*(unsigned char *)(a2 + 3) & 0x20) == 0)
  {
    int v39 = -1;
LABEL_27:
    *(_DWORD *)(a3 + 324) = v39;
    goto LABEL_29;
  }
  unsigned int v40 = vcvtps_s32_f32(v32 * (float)(v26 - v33));
  *(_DWORD *)(a3 + 324) = v40;
  if ((v40 & 0x80000000) != 0)
  {
    *(_DWORD *)(a3 + 324) = 0;
    goto LABEL_29;
  }
  if (v28 <= v40)
  {
    int v39 = v28 - 1;
    goto LABEL_27;
  }
LABEL_29:
  *(_OWORD *)(a3 + 384) = *(_OWORD *)(a2 + 64);
  *(void *)(a3 + 376) = 0;
  uint64_t v41 = *(float **)(a2 + 16);
  if (!v41)
  {
    a4 = 0;
LABEL_55:
    *(void *)(a3 + 360) = 0;
    *(void *)(a3 + 368) = 0;
    *(_WORD *)(a3 + 22) = 2056;
    int8x16_t v53 = (int8x16_t)vdupq_n_s64(0x80uLL);
    *(int8x16_t *)(a3 + 96) = vorrq_s8((int8x16_t)vshll_n_s32(*(int32x2_t *)(a1 + 56), 8uLL), v53);
    *(_OWORD *)(a3 + 208) = xmmword_1850CDB40;
    *(_OWORD *)(a3 + 224) = xmmword_1850CDB50;
    *(void *)(a3 + 120) = 0;
    *(void *)(a3 + 128) = 0;
    *(_OWORD *)(a3 + 192) = xmmword_1850CDB60;
    int64x2_t v54 = vaddq_s64(vshll_n_s32(*(int32x2_t *)(a1 + 64), 8uLL), vdupq_n_s64(0xFFFFFFFFFFFFFF80));
    *(void *)(a3 + 400) = a4;
    *(void *)(a3 + 136) = 256;
    *(void *)(a3 + 112) = 256;
    *(int8x16_t *)(a3 + 64) = v53;
    *(int64x2_t *)(a3 + 80) = v54;
    if (*(unsigned __int8 *)(a2 + 2) << 16) {
      int v55 = 0;
    }
    else {
      int v55 = 0x3FFFFFFF;
    }
    *(_DWORD *)(a3 + 188) = v55;
    *(_DWORD *)(a3 + 20) = 134742016;
    uint64_t v56 = *(void *)(a2 + 48);
    *(void *)&long long v57 = v56;
    *((void *)&v57 + 1) = HIDWORD(v56);
    *(void *)(a3 + 24) = *(void *)(a1 + 76);
    *(_OWORD *)(a3 + 32) = *(_OWORD *)(a1 + 88);
    *(_OWORD *)(a3 + 48) = v57;
    float v58 = *(float *)(a2 + 4);
    *(float *)(a3 + 184) = v58;
    float v59 = 0.0;
    if (v58 < 0.0 || (float v59 = 1.0, v58 > 1.0)) {
      *(float *)(a3 + 184) = v59;
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 16) = 0;
    *(_OWORD *)(a3 + 144) = 0u;
    *(_OWORD *)(a3 + 160) = 0u;
    *(void *)(a3 + 176) = 0;
    uint64_t v10 = 1;
    *(void *)(a3 + 240) = 0;
    *(void *)(a3 + 248) = 0;
    return v10;
  }
  float v42 = *v41;
  double v43 = *v41;
  *(float *)a4 = *v41;
  float v44 = *(float *)(*(void *)(a2 + 16) + 8);
  *(float *)(a4 + 4) = v44;
  float v45 = *(float *)(*(void *)(a2 + 16) + 4);
  *(float *)(a4 + 8) = v45;
  double v46 = v44 - v43;
  double v47 = v45 * v45 - v46 * v46;
  float v48 = v47;
  float v49 = v43 * -2.0 * v46;
  *(float *)(a4 + 20) = v48;
  *(float *)(a4 + 24) = v49;
  *(float *)(a4 + 28) = v42 * v42;
  if (v47 == 0.0) {
    float v50 = 0.0;
  }
  else {
    float v50 = 1.0 / (v47 + v47);
  }
  *(float *)(a4 + 32) = v50;
  if (!(*(_DWORD *)a2 >> 28))
  {
    *(void *)(a4 + 12) = 0x3F80000000000000;
    goto LABEL_55;
  }
  if (v42 >= v44)
  {
    if (v42 <= v44) {
      float v52 = 3.4028e38;
    }
    else {
      float v52 = 1.0 - v44 / v46;
    }
    float v51 = -3.4028e38;
  }
  else
  {
    float v51 = -v43 / v46;
    float v52 = 3.4028e38;
  }
  if ((*(_DWORD *)a2 & 0x10000000) == 0) {
    float v51 = 0.0;
  }
  *(float *)(a4 + 12) = v51;
  if ((*(_DWORD *)a2 & 0x20000000) == 0) {
    float v52 = 1.0;
  }
  *(float *)(a4 + 16) = v52;
  uint64_t v10 = 0xFFFFFFFFLL;
  if (fabsf(v50) != INFINITY
    && fabsf(v48) != INFINITY
    && fabsf(v42) != INFINITY
    && fabsf(v44) != INFINITY
    && fabsf(v45) != INFINITY
    && fabsf(v51) != INFINITY
    && fabsf(v52) != INFINITY
    && fabsf(v49) != INFINITY
    && fabsf(v42 * v42) != INFINITY)
  {
    goto LABEL_55;
  }
  return v10;
}

uint64_t _blt_shade_samples_16(uint64_t result, int a2, int a3, float *a4, float *a5, unint64_t a6)
{
  float v6 = 65535.0;
  if (a2 == 2) {
    float v6 = 65280.0;
  }
  if (a2 == 1) {
    float v6 = 7936.0;
  }
  switch(a3)
  {
    case 1:
      if (!a6) {
        return result;
      }
      uint64_t v19 = 0;
      for (char i = (_WORD *)(result + 2); ; i += 2)
      {
        float v21 = a4[v19];
        if (!a5) {
          goto LABEL_36;
        }
        float v22 = *a5++;
        float v23 = v22;
        if (v22 >= 0.0) {
          break;
        }
        *(_DWORD *)(i - 1) = 0;
LABEL_42:
        if (a6 <= ++v19) {
          return result;
        }
      }
      if (v23 <= 1.0) {
        float v24 = v6 * v23;
      }
      else {
LABEL_36:
      }
        float v24 = v6;
      float v25 = 1.0;
      if (v21 <= 1.0)
      {
        float v25 = a4[v19];
        if (v21 < 0.0) {
          float v25 = 0.0;
        }
      }
      *(i - 1) = (int)(float)((float)(v25 * v24) + 0.5);
      *char i = (int)(float)(v24 + 0.5);
      goto LABEL_42;
    case 4:
      if (!a6) {
        return result;
      }
      float v26 = (_WORD *)(result + 4);
      unsigned int v27 = 1;
      while (1)
      {
        float v29 = *a4;
        float v28 = a4[1];
        float v31 = a4[2];
        float v30 = a4[3];
        if (!a5) {
          break;
        }
        float v32 = *a5++;
        float v33 = v32;
        if (v32 >= 0.0)
        {
          BOOL v14 = v33 <= 1.0;
          float v34 = v6 * v33;
          if (!v14) {
            float v34 = v6;
          }
          goto LABEL_52;
        }
        *(void *)(v26 - 2) = 0;
LABEL_70:
        unint64_t v40 = v27++;
        v26 += 5;
        a4 += 4;
        if (v40 >= a6) {
          return result;
        }
      }
      float v34 = v6;
LABEL_52:
      if (v29 < 0.0) {
        float v35 = 0.0;
      }
      else {
        float v35 = *a4;
      }
      if (v29 <= 1.0) {
        float v36 = v35;
      }
      else {
        float v36 = 1.0;
      }
      if (v28 < 0.0) {
        float v37 = 0.0;
      }
      else {
        float v37 = a4[1];
      }
      if (v28 > 1.0) {
        float v37 = 1.0;
      }
      float v38 = 1.0;
      float v39 = 1.0;
      if (v31 <= 1.0)
      {
        float v39 = a4[2];
        if (v31 < 0.0) {
          float v39 = 0.0;
        }
      }
      if (v30 <= 1.0)
      {
        float v38 = a4[3];
        if (v30 < 0.0) {
          float v38 = 0.0;
        }
      }
      *(v26 - 2) = (int)(float)((float)(v36 * v34) + 0.5);
      *(v26 - 1) = (int)(float)((float)(v37 * v34) + 0.5);
      *float v26 = (int)(float)((float)(v39 * v34) + 0.5);
      v26[1] = (int)(float)((float)(v38 * v34) + 0.5);
      void v26[2] = (int)(float)(v34 + 0.5);
      goto LABEL_70;
    case 3:
      if (a6)
      {
        unsigned int v7 = 1;
        while (1)
        {
          float v9 = *a4;
          float v8 = a4[1];
          float v10 = a4[2];
          if (!a5) {
            break;
          }
          float v11 = *a5++;
          float v12 = v11;
          if (v11 >= 0.0)
          {
            BOOL v14 = v12 <= 1.0;
            float v13 = v6 * v12;
            if (!v14) {
              float v13 = v6;
            }
            goto LABEL_16;
          }
          *(void *)BOOL result = 0;
LABEL_28:
          result += 8;
          unint64_t v18 = v7++;
          a4 += 3;
          if (v18 >= a6) {
            return result;
          }
        }
        float v13 = v6;
LABEL_16:
        if (v9 < 0.0) {
          float v15 = 0.0;
        }
        else {
          float v15 = *a4;
        }
        if (v9 > 1.0) {
          float v15 = 1.0;
        }
        float v16 = 1.0;
        float v17 = 1.0;
        if (v8 <= 1.0)
        {
          float v17 = a4[1];
          if (v8 < 0.0) {
            float v17 = 0.0;
          }
        }
        if (v10 <= 1.0)
        {
          float v16 = a4[2];
          if (v10 < 0.0) {
            float v16 = 0.0;
          }
        }
        *(_WORD *)BOOL result = (int)(float)((float)(v15 * v13) + 0.5);
        *(_WORD *)(result + 2) = (int)(float)((float)(v17 * v13) + 0.5);
        *(_WORD *)(result + 4) = (int)(float)((float)(v16 * v13) + 0.5);
        *(_WORD *)(result + 6) = (int)(float)(v13 + 0.5);
        goto LABEL_28;
      }
      break;
    default:
      if (a5)
      {
        if (a6)
        {
          uint64_t v41 = 0;
          do
          {
            float v42 = a5[v41];
            if (v42 >= 0.0)
            {
              int v43 = (int)v6;
              if (v42 <= 1.0) {
                int v43 = (int)(float)((float)(v42 * v6) + 0.5);
              }
            }
            else
            {
              LOWORD(v43) = 0;
            }
            *(_WORD *)(result + 2 * v41++) = v43;
          }
          while (a6 > v41);
        }
      }
      else if (a6)
      {
        uint64_t v44 = 0;
        do
          *(_WORD *)(result + 2 * v44++) = (int)v6;
        while (a6 > v44);
      }
      break;
  }
  return result;
}

void rgba32_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v297 = a3;
  uint64_t v303 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  float v8 = *(float *)(a2 + 184);
  float v9 = *(int **)(a1 + 136);
  uint64_t v300 = *(void *)(a2 + 96);
  uint64_t v289 = *(void *)(a2 + 104);
  uint64_t v11 = *(int *)(a1 + 24);
  unint64_t v10 = *(int *)(a1 + 28);
  uint64_t v12 = *(int *)(a1 + 20);
  uint64_t v301 = *(int *)(a1 + 16);
  uint64_t v302 = v6;
  int v299 = *(_DWORD *)(a1 + 8);
  uint64_t v292 = a1;
  uint64_t v298 = (void *)*(int *)(a1 + 12);
  unint64_t v296 = (void *)a2;
  uint64_t v13 = *(int *)(a2 + 16);
  uint64_t v14 = (v13 + 6) * v5;
  if (v14 > 65439)
  {
    float v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x3023562EuLL);
    float v16 = v17;
    double v20 = v17;
    float v21 = v296;
    uint64_t v22 = v292;
    if (!v17) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    float v16 = (char *)&v285 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    double v20 = 0;
    float v21 = v296;
    uint64_t v22 = v292;
  }
  __int16 v287 = v20;
  v19.n128_f32[0] = (float)(v8 * 255.0) + 0.5;
  int v23 = (int)v19.n128_f32[0];
  uint64_t v286 = v7 + (v11 - 1) * v10 + 4 * v12;
  unint64_t v24 = v10 >> 2;
  unint64_t v25 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v26 = v25 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v13) {
    uint64_t v27 = 4 * v5;
  }
  else {
    uint64_t v27 = 0;
  }
  unint64_t v28 = v26 + v27;
  v21[18] = v25;
  v21[19] = v26 + v27;
  v21[20] = v26;
  float v29 = (unsigned int *)(v7 + 4 * ((void)v298 + v24 * v301));
  uint64_t v288 = (int)v4;
  unint64_t v285 = v24;
  unint64_t v295 = v24 - (int)v4;
  uint64_t v30 = *(int *)(v22 + 104);
  int v31 = *(_DWORD *)(v22 + 108);
  int v32 = *(unsigned __int8 *)(v22 + 2);
  if (v32 == 6 || v32 == 1)
  {
    uint64_t v33 = v300;
    if (!v9) {
      goto LABEL_609;
    }
    float v34 = 0;
    int v35 = 0;
    uint64_t v36 = *(int *)(v22 + 124);
    float v37 = (unsigned __int8 *)v9 + v30 + (int)v36 * (uint64_t)v31;
    uint64_t v38 = v288;
    uint64_t v294 = v36 - v288;
    float v39 = v296;
    goto LABEL_25;
  }
  if (!v9)
  {
    float v37 = 0;
    float v34 = 0;
    uint64_t v294 = 0;
    int v35 = 0;
    float v39 = v296;
    uint64_t v38 = v288;
    uint64_t v33 = v300;
LABEL_25:
    uint64_t v42 = v289;
    goto LABEL_26;
  }
  v19.n128_f64[0] = shape_enum_clip_alloc((uint64_t)v17, v18, v9, 1, 1, 1, v30, v31, v4, v299);
  if (!v40) {
    goto LABEL_609;
  }
  int v35 = 0;
  uint64_t v41 = (int)((v13 * v5 + 15) & 0xFFFFFFF0);
  if (!v13) {
    uint64_t v41 = 4 * v5;
  }
  uint64_t v42 = v289;
  uint64_t v294 = -v288;
  float v37 = (unsigned __int8 *)(v28 + v41 + 16);
  float v39 = v296;
  uint64_t v33 = v300;
  float v34 = v40;
  while (1)
  {
    while (1)
    {
      int v43 = *((_DWORD *)v37 - 4);
      int v44 = v43 - v35;
      if (v43 > v35) {
        break;
      }
      if (v35 < *((_DWORD *)v37 - 3) + v43)
      {
        uint64_t v38 = v288;
LABEL_26:
        uint64_t v290 = -v38;
        uint64_t v291 = (v4 - 1) + 1;
        unint64_t v293 = v286 - 4;
        float v45 = v34;
LABEL_27:
        uint64_t v298 = v45;
        double v46 = (void (*)(void *, uint64_t, uint64_t, uint64_t, __n128))*v39;
        uint64_t v300 = v33;
        v46(v39, v33, v42, v4, v19);
        double v47 = (unsigned int *)v39[20];
        float v48 = (unsigned char *)v39[18];
        unsigned int v50 = *((_DWORD *)v39 + 2);
        int v49 = *((_DWORD *)v39 + 3);
        LODWORD(v301) = v35;
        if (v50 == v49)
        {
          if (v23 != 255)
          {
            int v51 = v4;
            float v52 = v48;
            do
            {
              if (*v52) {
                *double v47 = PDM_21362(*v47, v23);
              }
              ++v52;
              ++v47;
              --v51;
            }
            while (v51);
            v47 += v290;
            v48 += v291 + v290;
            goto LABEL_34;
          }
          int v53 = v297;
        }
        else
        {
          uint64_t v59 = v39[19];
          int v60 = HIWORD(v50) & 0x3F;
          if (v60 == 16)
          {
            if (v49 == 134755144)
            {
              if (v23 == 255)
              {
                uint64_t v95 = 0;
                int v53 = v297;
                do
                {
                  if (v48[v95]) {
                    v47[v95] = *(_DWORD *)(v59 + 8 * v95) & 0xFF00 | HIBYTE(*(void *)(v59 + 8 * v95)) | (*(void *)(v59 + 8 * v95) >> 16) & 0xFF000000 | (BYTE3(*(void *)(v59 + 8 * v95)) << 16);
                  }
                  ++v95;
                }
                while (v4 != v95);
                goto LABEL_35;
              }
              uint64_t v71 = 0;
              do
              {
                if (v48[v71]) {
                  v47[v71] = PDM_21362(*(_DWORD *)(v59 + 8 * v71) & 0xFF00 | HIBYTE(*(void *)(v59 + 8 * v71)) | (*(void *)(v59 + 8 * v71) >> 16) & 0xFF000000 | (BYTE3(*(void *)(v59 + 8 * v71)) << 16), v23);
                }
                ++v71;
              }
              while (v4 != v71);
            }
            else
            {
              if (v23 == 255)
              {
                uint64_t v107 = 0;
                int v53 = v297;
                do
                {
                  if (v48[v107]) {
                    v47[v107] = HIBYTE(*(void *)(v59 + 8 * v107)) | (BYTE1(*(void *)(v59 + 8 * v107)) << 24) | (BYTE3(*(void *)(v59 + 8 * v107)) << 16) | HIDWORD(*(void *)(v59 + 8 * v107)) & 0xFF00;
                  }
                  ++v107;
                }
                while (v4 != v107);
                goto LABEL_35;
              }
              uint64_t v83 = 0;
              do
              {
                if (v48[v83]) {
                  v47[v83] = PDM_21362(HIBYTE(*(void *)(v59 + 8 * v83)) | (BYTE1(*(void *)(v59 + 8 * v83)) << 24) | (BYTE3(*(void *)(v59 + 8 * v83)) << 16) | HIDWORD(*(void *)(v59 + 8 * v83)) & 0xFF00, v23);
                }
                ++v83;
              }
              while (v4 != v83);
            }
            goto LABEL_34;
          }
          if (v60 != 32)
          {
            if (v49 == 134755144)
            {
              if (v23 == 255)
              {
                uint64_t v96 = 0;
                int v53 = v297;
                do
                {
                  if (v48[v96]) {
                    v47[v96] = *(_DWORD *)(v59 + 4 * v96) & 0xFF00FF | (HIBYTE(*(_DWORD *)(v59 + 4 * v96)) << 8) & 0xFFFFFF | (BYTE1(*(_DWORD *)(v59 + 4 * v96)) << 24);
                  }
                  ++v96;
                }
                while (v4 != v96);
                goto LABEL_35;
              }
              uint64_t v72 = 0;
              do
              {
                if (v48[v72]) {
                  v47[v72] = PDM_21362(*(_DWORD *)(v59 + 4 * v72) & 0xFF00FF | (HIBYTE(*(_DWORD *)(v59 + 4 * v72)) << 8) & 0xFFFFFF | (BYTE1(*(_DWORD *)(v59 + 4 * v72)) << 24), v23);
                }
                ++v72;
              }
              while (v4 != v72);
            }
            else
            {
              if (v23 == 255)
              {
                uint64_t v108 = 0;
                int v53 = v297;
                do
                {
                  if (v48[v108]) {
                    v47[v108] = *(_DWORD *)(v59 + 4 * v108);
                  }
                  ++v108;
                }
                while (v4 != v108);
                goto LABEL_35;
              }
              uint64_t v84 = 0;
              do
              {
                if (v48[v84]) {
                  v47[v84] = PDM_21362(*(_DWORD *)(v59 + 4 * v84), v23);
                }
                ++v84;
              }
              while (v4 != v84);
            }
LABEL_34:
            int v53 = v297;
LABEL_35:
            int v35 = v301;
            goto LABEL_36;
          }
          if (v49 == 134755144)
          {
            if (v23 != 255)
            {
              uint64_t v61 = 0;
              uint64_t v62 = v59 + 8;
              do
              {
                if (v48[v61])
                {
                  v19.n128_u32[0] = *(_DWORD *)(v62 + 4);
                  if (v19.n128_f32[0] <= 0.0)
                  {
                    unsigned int v70 = 0;
                  }
                  else
                  {
                    float v63 = *(float *)(v62 - 8);
                    float v64 = *(float *)(v62 - 4);
                    float v65 = *(float *)v62;
                    int v66 = (int)(float)((float)(v19.n128_f32[0] * 255.0) + 0.5);
                    if (v19.n128_f32[0] > 1.0)
                    {
                      int v66 = 255;
                      v19.n128_f32[0] = 1.0;
                    }
                    int v67 = (int)(float)((float)(v63 * 255.0) + 0.5);
                    if (v63 < 0.0) {
                      int v67 = 0;
                    }
                    if (v63 > v19.n128_f32[0]) {
                      int v67 = v66;
                    }
                    int v68 = (int)(float)((float)(v64 * 255.0) + 0.5);
                    if (v64 < 0.0) {
                      int v68 = 0;
                    }
                    if (v64 > v19.n128_f32[0]) {
                      int v68 = v66;
                    }
                    int v69 = (int)(float)((float)(v65 * 255.0) + 0.5);
                    if (v65 < 0.0) {
                      int v69 = 0;
                    }
                    if (v65 > v19.n128_f32[0]) {
                      int v69 = v66;
                    }
                    unsigned int v70 = PDM_21362((v67 << 8) | (v68 << 16) | (v69 << 24) | v66, v23);
                  }
                  v47[v61] = v70;
                }
                ++v61;
                v62 += 16;
              }
              while (v4 != v61);
              goto LABEL_34;
            }
            uint64_t v85 = 0;
            uint64_t v86 = v59 + 8;
            int v53 = v297;
            int v35 = v301;
            do
            {
              if (v48[v85])
              {
                v19.n128_u32[0] = *(_DWORD *)(v86 + 4);
                if (v19.n128_f32[0] <= 0.0)
                {
                  int v94 = 0;
                }
                else
                {
                  float v87 = *(float *)(v86 - 8);
                  float v88 = *(float *)(v86 - 4);
                  float v89 = *(float *)v86;
                  int v90 = (int)(float)((float)(v19.n128_f32[0] * 255.0) + 0.5);
                  if (v19.n128_f32[0] > 1.0)
                  {
                    int v90 = 255;
                    v19.n128_f32[0] = 1.0;
                  }
                  int v91 = (int)(float)((float)(v87 * 255.0) + 0.5);
                  if (v87 < 0.0) {
                    int v91 = 0;
                  }
                  if (v87 > v19.n128_f32[0]) {
                    int v91 = v90;
                  }
                  int v92 = (int)(float)((float)(v88 * 255.0) + 0.5);
                  if (v88 < 0.0) {
                    int v92 = 0;
                  }
                  if (v88 > v19.n128_f32[0]) {
                    int v92 = v90;
                  }
                  int v93 = (int)(float)((float)(v89 * 255.0) + 0.5);
                  if (v89 < 0.0) {
                    int v93 = 0;
                  }
                  if (v89 > v19.n128_f32[0]) {
                    int v93 = v90;
                  }
                  int v94 = (v91 << 8) | (v92 << 16) | (v93 << 24) | v90;
                }
                v47[v85] = v94;
              }
              ++v85;
              v86 += 16;
            }
            while (v4 != v85);
          }
          else
          {
            if (v23 != 255)
            {
              uint64_t v73 = 0;
              uint64_t v74 = v59 + 8;
              do
              {
                if (v48[v73])
                {
                  v19.n128_u32[0] = *(_DWORD *)(v74 + 4);
                  if (v19.n128_f32[0] <= 0.0)
                  {
                    unsigned int v82 = 0;
                  }
                  else
                  {
                    float v75 = *(float *)(v74 - 8);
                    float v76 = *(float *)(v74 - 4);
                    float v77 = *(float *)v74;
                    int v78 = (int)(float)((float)(v19.n128_f32[0] * 255.0) + 0.5);
                    if (v19.n128_f32[0] > 1.0)
                    {
                      int v78 = 255;
                      v19.n128_f32[0] = 1.0;
                    }
                    int v79 = (int)(float)((float)(v75 * 255.0) + 0.5);
                    if (v75 < 0.0) {
                      int v79 = 0;
                    }
                    if (v75 > v19.n128_f32[0]) {
                      int v79 = v78;
                    }
                    int v80 = (int)(float)((float)(v76 * 255.0) + 0.5);
                    if (v76 < 0.0) {
                      int v80 = 0;
                    }
                    if (v76 > v19.n128_f32[0]) {
                      int v80 = v78;
                    }
                    int v81 = (int)(float)((float)(v77 * 255.0) + 0.5);
                    if (v77 < 0.0) {
                      int v81 = 0;
                    }
                    if (v77 > v19.n128_f32[0]) {
                      int v81 = v78;
                    }
                    unsigned int v82 = PDM_21362((v79 << 24) | (v80 << 16) | (v81 << 8) | v78, v23);
                  }
                  v47[v73] = v82;
                }
                ++v73;
                v74 += 16;
              }
              while (v4 != v73);
              goto LABEL_34;
            }
            uint64_t v97 = 0;
            uint64_t v98 = v59 + 8;
            int v53 = v297;
            int v35 = v301;
            do
            {
              if (v48[v97])
              {
                v19.n128_u32[0] = *(_DWORD *)(v98 + 4);
                if (v19.n128_f32[0] <= 0.0)
                {
                  int v106 = 0;
                }
                else
                {
                  float v99 = *(float *)(v98 - 8);
                  float v100 = *(float *)(v98 - 4);
                  float v101 = *(float *)v98;
                  int v102 = (int)(float)((float)(v19.n128_f32[0] * 255.0) + 0.5);
                  if (v19.n128_f32[0] > 1.0)
                  {
                    v19.n128_f32[0] = 1.0;
                    int v102 = 255;
                  }
                  int v103 = (int)(float)((float)(v99 * 255.0) + 0.5);
                  if (v99 < 0.0) {
                    int v103 = 0;
                  }
                  if (v99 > v19.n128_f32[0]) {
                    int v103 = v102;
                  }
                  int v104 = (int)(float)((float)(v100 * 255.0) + 0.5);
                  if (v100 < 0.0) {
                    int v104 = 0;
                  }
                  if (v100 > v19.n128_f32[0]) {
                    int v104 = v102;
                  }
                  int v105 = (int)(float)((float)(v101 * 255.0) + 0.5);
                  if (v101 < 0.0) {
                    int v105 = 0;
                  }
                  if (v101 > v19.n128_f32[0]) {
                    int v105 = v102;
                  }
                  int v106 = (v103 << 24) | (v104 << 16) | (v105 << 8) | v102;
                }
                v47[v97] = v106;
              }
              ++v97;
              v98 += 16;
            }
            while (v4 != v97);
          }
        }
LABEL_36:
        switch(v53)
        {
          case 0:
            int v54 = v4;
            int v55 = v37;
            do
            {
              unsigned int v56 = *v48;
              if (*v48)
              {
                if (v37) {
                  unsigned int v56 = (*v55 * v56 + ((*v55 * v56) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v56)
                {
                  if (v56 == 255) {
                    unsigned int v57 = 0;
                  }
                  else {
                    unsigned int v57 = PDM_21362(*v29, ~(_BYTE)v56);
                  }
                  *float v29 = v57;
                }
              }
              ++v48;
              v55 += v37 != 0;
              ++v29;
              --v54;
            }
            while (v54);
            float v37 = &v55[v294];
            unint64_t v58 = v295;
            goto LABEL_577;
          case 1:
            unsigned __int8 v110 = *v48;
            CGPDFInteger v111 = v48 + 1;
            int v112 = v4;
            if (v37)
            {
              do
              {
                if (v110)
                {
                  unsigned int v113 = *v37 * v110 + ((*v37 * v110) >> 8) + 1;
                  uint64_t v114 = (unsigned int *)v293;
                  if (v293 >= (unint64_t)v29) {
                    uint64_t v114 = v29;
                  }
                  if ((unint64_t)v114 >= *(void *)(v292 + 40)) {
                    uint64_t v115 = v114;
                  }
                  else {
                    uint64_t v115 = *(unsigned int **)(v292 + 40);
                  }
                  if (BYTE1(v113))
                  {
                    if (BYTE1(v113) == 255) {
                      *uint64_t v115 = *v47;
                    }
                    else {
                      DMplusDM_21363(v115, *v47, BYTE1(v113), *v115, ~(v113 >> 8));
                    }
                  }
                }
                else
                {
                  uint64_t v115 = v29;
                }
                unsigned __int8 v116 = *v111++;
                unsigned __int8 v110 = v116;
                ++v47;
                ++v37;
                float v29 = v115 + 1;
                --v112;
              }
              while (v112);
              v37 += v294;
            }
            else
            {
              uint64_t v277 = v292;
              do
              {
                uint64_t v278 = (unsigned int *)v293;
                if (v293 >= (unint64_t)v29) {
                  uint64_t v278 = v29;
                }
                if ((unint64_t)v278 >= *(void *)(v277 + 40)) {
                  uint64_t v115 = v278;
                }
                else {
                  uint64_t v115 = *(unsigned int **)(v277 + 40);
                }
                if (v110)
                {
                  if (v110 == 255) {
                    *uint64_t v115 = *v47;
                  }
                  else {
                    DMplusDM_21363(v115, *v47, v110, *v115, ~v110);
                  }
                }
                unsigned __int8 v279 = *v111++;
                unsigned __int8 v110 = v279;
                ++v47;
                float v29 = v115 + 1;
                --v112;
              }
              while (v112);
              float v37 = 0;
            }
            goto LABEL_606;
          case 2:
            unsigned __int8 v117 = *v48;
            if (v37)
            {
              uint64_t v118 = v48 + 1;
              int v119 = v4;
              while (1)
              {
                uint64_t v115 = v29;
                if (!v117) {
                  goto LABEL_214;
                }
                unsigned int v120 = *v37 * v117 + ((*v37 * v117) >> 8) + 1;
                if (!BYTE1(v120)) {
                  goto LABEL_214;
                }
                if (BYTE1(v120) == 255)
                {
                  unsigned int v121 = *v47;
                  if (*v47)
                  {
                    if (*v47 != 255) {
                      goto LABEL_213;
                    }
                    *float v29 = v121;
                  }
                }
                else
                {
                  unsigned int v122 = PDM_21362(*v47, BYTE1(v120));
                  if ((_BYTE)v122)
                  {
                    unsigned int v121 = v122;
LABEL_213:
                    DplusDM_21364(v29, v121, *v29, ~(_BYTE)v121);
                  }
                }
LABEL_214:
                unsigned __int8 v123 = *v118++;
                unsigned __int8 v117 = v123;
                ++v47;
                ++v37;
                ++v29;
                if (!--v119)
                {
                  v37 += v294;
                  float v39 = v296;
                  goto LABEL_606;
                }
              }
            }
            uint64_t v280 = v48 + 1;
            int v281 = v4;
            do
            {
              if (!v117) {
                goto LABEL_604;
              }
              if (v117 == 255)
              {
                unsigned int v282 = *v47;
                if (!*v47) {
                  goto LABEL_604;
                }
                if (*v47 == 255)
                {
                  *float v29 = v282;
                  goto LABEL_604;
                }
              }
              else
              {
                unsigned int v283 = PDM_21362(*v47, v117);
                if (!(_BYTE)v283) {
                  goto LABEL_604;
                }
                unsigned int v282 = v283;
              }
              DplusDM_21364(v29, v282, *v29, ~(_BYTE)v282);
LABEL_604:
              unsigned __int8 v284 = *v280++;
              unsigned __int8 v117 = v284;
              ++v47;
              ++v29;
              --v281;
            }
            while (v281);
            float v37 = 0;
            uint64_t v115 = v29 - 1;
LABEL_606:
            float v29 = &v115[v295 + 1];
LABEL_578:
            uint64_t v109 = v300;
LABEL_579:
            float v34 = v298;
            int v35 = v301;
LABEL_580:
            if (v299 == 1) {
              goto LABEL_607;
            }
            --v299;
            float v45 = 0;
            ++v35;
            uint64_t v33 = v39[16] + v109;
            v42 += v39[17];
            if (v34) {
              continue;
            }
            goto LABEL_27;
          case 3:
            int v124 = v4;
            unint64_t v125 = v37;
            do
            {
              unsigned int v126 = *v48;
              if (*v48)
              {
                if (v37) {
                  unsigned int v126 = (*v125 * v126 + ((*v125 * v126) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v126)
                {
                  if (v126 == 255)
                  {
                    *float v29 = PDM_21362(*v47, *(unsigned __int8 *)v29);
                  }
                  else
                  {
                    unsigned int v127 = *v29 * v126 + 128;
                    DMplusDM_21363(v29, *v47, (unsigned __int16)(v127 + (v127 >> 8)) >> 8, *v29, ~(_BYTE)v126);
                  }
                }
              }
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              --v124;
            }
            while (v124);
            goto LABEL_575;
          case 4:
            int v128 = v4;
            unint64_t v125 = v37;
            do
            {
              unsigned int v129 = *v48;
              if (*v48)
              {
                if (v37) {
                  unsigned int v129 = (*v125 * v129 + ((*v125 * v129) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v129)
                {
                  if (v129 == 255)
                  {
                    *float v29 = PDM_21362(*v47, *(unsigned __int8 *)v29 ^ 0xFFu);
                  }
                  else
                  {
                    unsigned int v130 = ~*(unsigned char *)v29 * v129 + 128;
                    DMplusDM_21363(v29, *v47, (unsigned __int16)(v130 + (v130 >> 8)) >> 8, *v29, ~(_BYTE)v129);
                  }
                }
              }
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              --v128;
            }
            while (v128);
            goto LABEL_575;
          case 5:
            int v131 = v4;
            unint64_t v125 = v37;
            while (1)
            {
              unsigned int v132 = *v48;
              if (*v48)
              {
                if (!v37) {
                  goto LABEL_241;
                }
                unsigned int v133 = *v125 * v132 + ((*v125 * v132) >> 8) + 1;
                if (BYTE1(v133)) {
                  break;
                }
              }
LABEL_242:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v131) {
                goto LABEL_575;
              }
            }
            unsigned int v132 = v133 >> 8;
LABEL_241:
            unsigned int v134 = PDM_21362(*v47, v132);
            DMplusDM_21363(v29, v134, *v29, *v29, ~(_BYTE)v134);
            goto LABEL_242;
          case 6:
            int v135 = v4;
            unint64_t v125 = v37;
            while (1)
            {
              unsigned int v136 = *v48;
              if (*v48)
              {
                if (!v37) {
                  goto LABEL_249;
                }
                unsigned int v137 = *v125 * v136 + ((*v125 * v136) >> 8) + 1;
                if (BYTE1(v137)) {
                  break;
                }
              }
LABEL_253:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v135) {
                goto LABEL_575;
              }
            }
            unsigned int v136 = v137 >> 8;
LABEL_249:
            if (*(unsigned char *)v29 != 0xFF)
            {
              if (~*(unsigned char *)v29 == 255) {
                *float v29 = PDM_21362(*v47, v136);
              }
              else {
                DplusDM_21364(v29, *v29, *v47, (unsigned __int16)(~*(unsigned char *)v29 * v136+ 128+ ((~*(unsigned char *)v29 * v136 + 128) >> 8)) >> 8);
              }
            }
            goto LABEL_253;
          case 7:
            int v138 = v4;
            unint64_t v125 = v37;
            do
            {
              unsigned int v139 = *v48;
              if (*v48)
              {
                if (v37) {
                  unsigned int v139 = (*v125 * v139 + ((*v125 * v139) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v139)
                {
                  if (v139 == 255)
                  {
                    *float v29 = PDM_21362(*v29, *(unsigned __int8 *)v47);
                  }
                  else
                  {
                    unsigned int v140 = *(unsigned __int8 *)v47 * v139 + 128;
                    DMplusDM_21363(v29, *v29, (unsigned __int16)(v140 + (v140 >> 8)) >> 8, *v29, ~(_BYTE)v139);
                  }
                }
              }
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              --v138;
            }
            while (v138);
            goto LABEL_575;
          case 8:
            int v141 = v4;
            unint64_t v125 = v37;
            do
            {
              unsigned int v142 = *v48;
              if (*v48)
              {
                if (v37) {
                  unsigned int v142 = (*v125 * v142 + ((*v125 * v142) >> 8) + 1) >> 8;
                }
                if ((_BYTE)v142)
                {
                  if (v142 == 255)
                  {
                    *float v29 = PDM_21362(*v29, *(unsigned __int8 *)v47 ^ 0xFFu);
                  }
                  else
                  {
                    unsigned int v143 = (*(unsigned __int8 *)v47 ^ 0xFF) * v142 + 128;
                    DMplusDM_21363(v29, *v29, (unsigned __int16)(v143 + (v143 >> 8)) >> 8, *v29, ~(_BYTE)v142);
                  }
                }
              }
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              --v141;
            }
            while (v141);
            goto LABEL_575;
          case 9:
            uint64_t v289 = v42;
            int v144 = v4;
            uint64_t v145 = v37;
            while (1)
            {
              unsigned int v146 = *v48;
              if (*v48)
              {
                if (!v37) {
                  goto LABEL_280;
                }
                unsigned int v147 = *v145 * v146 + ((*v145 * v146) >> 8) + 1;
                if (BYTE1(v147)) {
                  break;
                }
              }
LABEL_281:
              ++v48;
              ++v47;
              v145 += v37 != 0;
              ++v29;
              if (!--v144)
              {
                float v37 = &v145[v294];
                float v39 = v296;
                v29 += v295;
                uint64_t v109 = v300;
                uint64_t v42 = v289;
                goto LABEL_579;
              }
            }
            unsigned int v146 = v147 >> 8;
LABEL_280:
            unsigned int v148 = PDM_21362(*v47, v146);
            DMplusDM_21363(v29, v148, ~*(unsigned char *)v29, *v29, (v148 + ~(_BYTE)v146));
            goto LABEL_281;
          case 10:
            int v149 = v4;
            unint64_t v125 = v37;
            while (1)
            {
              unsigned int v150 = *v48;
              if (*v48)
              {
                if (!v37) {
                  goto LABEL_288;
                }
                unsigned int v151 = *v125 * v150 + ((*v125 * v150) >> 8) + 1;
                if (BYTE1(v151)) {
                  break;
                }
              }
LABEL_289:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v149) {
                goto LABEL_575;
              }
            }
            unsigned int v150 = v151 >> 8;
LABEL_288:
            unsigned int v152 = PDM_21362(*v47, v150);
            DMplusDM_21363(v29, v152, ~*(unsigned char *)v29, *v29, ~(_BYTE)v152);
            goto LABEL_289;
          case 11:
            int v153 = v4;
            unint64_t v125 = v37;
            while (1)
            {
              unsigned int v154 = *v48;
              if (*v48)
              {
                if (!v37) {
                  goto LABEL_296;
                }
                unsigned int v155 = *v125 * v154 + ((*v125 * v154) >> 8) + 1;
                if (BYTE1(v155)) {
                  break;
                }
              }
LABEL_300:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v153) {
                goto LABEL_575;
              }
            }
            unsigned int v154 = v155 >> 8;
LABEL_296:
            int v156 = PDM_21362(*v47, v154);
            if (v302) {
              unsigned __int8 v158 = *v29;
            }
            else {
              unsigned __int8 v158 = -1;
            }
            v19.n128_u64[0] = (unint64_t)DAplusdDA_21365(v29, *v29, v158, v156, v156, v157);
            goto LABEL_300;
          case 12:
            int v159 = v4;
            unint64_t v125 = v37;
            while (1)
            {
              unsigned int v160 = *v48;
              if (*v48)
              {
                if (!v37) {
                  goto LABEL_307;
                }
                unsigned int v161 = *v125 * v160 + ((*v125 * v160) >> 8) + 1;
                if (BYTE1(v161)) {
                  break;
                }
              }
LABEL_308:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v159) {
                goto LABEL_575;
              }
            }
            unsigned int v160 = v161 >> 8;
LABEL_307:
            unsigned int v162 = PDM_21362(*v47, v160);
            int v163 = ((*v29 >> 8) & 0xFF00FF) + ((v162 >> 8) & 0xFF00FF);
            *float v29 = (v163 << 8) & 0xFF00FF00 | ((*v29 & 0xFF00FF) + (v162 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                                  * (v163 & 0x1000100 | (((*v29 & 0xFF00FF) + (v162 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v163 & 0x1000100 | (((*v29 & 0xFF00FF) + (v162 & 0xFF00FF)) >> 8) & 0x10001));
            goto LABEL_308;
          case 13:
            int v164 = v4;
            uint64_t v165 = v37;
            while (1)
            {
              unsigned int v166 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v167 = *v165 * v166 + ((*v165 * v166) >> 8) + 1;
                  if (!BYTE1(v167)) {
                    goto LABEL_322;
                  }
                  unsigned int v166 = v167 >> 8;
                }
                unsigned int v168 = PDM_21362(*v47, v166);
                if ((_BYTE)v168)
                {
                  unsigned int v169 = v168;
                  if (v302)
                  {
                    unsigned int v170 = *v29;
                    if (!*v29) {
                      goto LABEL_321;
                    }
                  }
                  else
                  {
                    LOBYTE(v170) = -1;
                  }
                  unsigned int v169 = PDAmultiplyPDA_21366(*v29, v170, v168, v168);
LABEL_321:
                  *float v29 = v169;
                }
              }
LABEL_322:
              ++v48;
              ++v47;
              v165 += v37 != 0;
              ++v29;
              if (!--v164) {
                goto LABEL_393;
              }
            }
          case 14:
            int v171 = v4;
            uint64_t v165 = v37;
            while (1)
            {
              unsigned int v172 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v173 = *v165 * v172 + ((*v165 * v172) >> 8) + 1;
                  if (!BYTE1(v173)) {
                    goto LABEL_336;
                  }
                  unsigned int v172 = v173 >> 8;
                }
                unsigned int v174 = PDM_21362(*v47, v172);
                if ((_BYTE)v174)
                {
                  unsigned int v175 = v174;
                  if (v302)
                  {
                    unsigned int v176 = *v29;
                    if (!*v29) {
                      goto LABEL_335;
                    }
                  }
                  else
                  {
                    LOBYTE(v176) = -1;
                  }
                  unsigned int v175 = PDAscreenPDA_21367(*v29, v176, v174, v174);
LABEL_335:
                  *float v29 = v175;
                }
              }
LABEL_336:
              ++v48;
              ++v47;
              v165 += v37 != 0;
              ++v29;
              if (!--v171) {
                goto LABEL_393;
              }
            }
          case 15:
            int v177 = v4;
            uint64_t v165 = v37;
            while (1)
            {
              unsigned int v178 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v179 = *v165 * v178 + ((*v165 * v178) >> 8) + 1;
                  if (!BYTE1(v179)) {
                    goto LABEL_350;
                  }
                  unsigned int v178 = v179 >> 8;
                }
                unsigned int v180 = PDM_21362(*v47, v178);
                if ((_BYTE)v180)
                {
                  unsigned int v181 = v180;
                  if (v302)
                  {
                    unsigned int v182 = *v29;
                    if (!*v29) {
                      goto LABEL_349;
                    }
                  }
                  else
                  {
                    LOBYTE(v182) = -1;
                  }
                  unsigned int v181 = PDAoverlayPDA_21368(*v29, v182, v180, v180);
LABEL_349:
                  *float v29 = v181;
                }
              }
LABEL_350:
              ++v48;
              ++v47;
              v165 += v37 != 0;
              ++v29;
              if (!--v177) {
                goto LABEL_393;
              }
            }
          case 16:
            int v183 = v4;
            uint64_t v165 = v37;
            while (1)
            {
              unsigned int v184 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v185 = *v165 * v184 + ((*v165 * v184) >> 8) + 1;
                  if (!BYTE1(v185)) {
                    goto LABEL_364;
                  }
                  unsigned int v184 = v185 >> 8;
                }
                unsigned int v186 = PDM_21362(*v47, v184);
                if ((_BYTE)v186)
                {
                  unsigned int v187 = v186;
                  if (v302)
                  {
                    unsigned int v188 = *v29;
                    if (!*v29) {
                      goto LABEL_363;
                    }
                  }
                  else
                  {
                    LOBYTE(v188) = -1;
                  }
                  unsigned int v187 = PDAdarkenPDA_21370(*v29, v188, v186, v186);
LABEL_363:
                  *float v29 = v187;
                }
              }
LABEL_364:
              ++v48;
              ++v47;
              v165 += v37 != 0;
              ++v29;
              if (!--v183) {
                goto LABEL_393;
              }
            }
          case 17:
            int v189 = v4;
            uint64_t v165 = v37;
            while (1)
            {
              unsigned int v190 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v191 = *v165 * v190 + ((*v165 * v190) >> 8) + 1;
                  if (!BYTE1(v191)) {
                    goto LABEL_378;
                  }
                  unsigned int v190 = v191 >> 8;
                }
                unsigned int v192 = PDM_21362(*v47, v190);
                if ((_BYTE)v192)
                {
                  unsigned int v193 = v192;
                  if (v302)
                  {
                    unsigned int v194 = *v29;
                    if (!*v29) {
                      goto LABEL_377;
                    }
                  }
                  else
                  {
                    LOBYTE(v194) = -1;
                  }
                  unsigned int v193 = PDAlightenPDA_21369(*v29, v194, v192, v192);
LABEL_377:
                  *float v29 = v193;
                }
              }
LABEL_378:
              ++v48;
              ++v47;
              v165 += v37 != 0;
              ++v29;
              if (!--v189) {
                goto LABEL_393;
              }
            }
          case 18:
            int v195 = v4;
            uint64_t v165 = v37;
            while (1)
            {
              unsigned int v196 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v197 = *v165 * v196 + ((*v165 * v196) >> 8) + 1;
                  if (!BYTE1(v197)) {
                    goto LABEL_392;
                  }
                  unsigned int v196 = v197 >> 8;
                }
                unsigned int v198 = PDM_21362(*v47, v196);
                if ((_BYTE)v198)
                {
                  unsigned int v199 = v198;
                  if (v302)
                  {
                    unsigned int v200 = *v29;
                    if (!*v29) {
                      goto LABEL_391;
                    }
                  }
                  else
                  {
                    LOBYTE(v200) = -1;
                  }
                  unsigned int v199 = PDAcolordodgePDA_21371(*v29, v200, v198, v198);
LABEL_391:
                  *float v29 = v199;
                }
              }
LABEL_392:
              ++v48;
              ++v47;
              v165 += v37 != 0;
              ++v29;
              if (!--v195)
              {
LABEL_393:
                float v37 = &v165[v294];
                goto LABEL_576;
              }
            }
          case 19:
            unint64_t v125 = v37;
            int v201 = v4;
            while (1)
            {
              unsigned int v202 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v203 = *v125 * v202 + ((*v125 * v202) >> 8) + 1;
                  if (!BYTE1(v203)) {
                    goto LABEL_406;
                  }
                  unsigned int v202 = v203 >> 8;
                }
                unsigned int v204 = PDM_21362(*v47, v202);
                if ((_BYTE)v204)
                {
                  unsigned int v205 = v204;
                  if (v302)
                  {
                    unsigned int v206 = *v29;
                    if (!*v29) {
                      goto LABEL_405;
                    }
                  }
                  else
                  {
                    LOBYTE(v206) = -1;
                  }
                  unsigned int v205 = PDAcolorburnPDA_21372(*v29, v206, v204, v204);
LABEL_405:
                  *float v29 = v205;
                }
              }
LABEL_406:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v201) {
                goto LABEL_575;
              }
            }
          case 20:
            unint64_t v125 = v37;
            int v207 = v4;
            while (1)
            {
              unsigned int v208 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v209 = *v125 * v208 + ((*v125 * v208) >> 8) + 1;
                  if (!BYTE1(v209)) {
                    goto LABEL_420;
                  }
                  unsigned int v208 = v209 >> 8;
                }
                unsigned int v210 = PDM_21362(*v47, v208);
                if ((_BYTE)v210)
                {
                  unsigned int v211 = v210;
                  if (v302)
                  {
                    unsigned int v212 = *v29;
                    if (!*v29) {
                      goto LABEL_419;
                    }
                  }
                  else
                  {
                    LOBYTE(v212) = -1;
                  }
                  unsigned int v211 = PDAsoftlightPDA_21374(*v29, v212, v210, v210);
LABEL_419:
                  *float v29 = v211;
                }
              }
LABEL_420:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v207) {
                goto LABEL_575;
              }
            }
          case 21:
            unint64_t v125 = v37;
            int v213 = v4;
            while (1)
            {
              unsigned int v214 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v215 = *v125 * v214 + ((*v125 * v214) >> 8) + 1;
                  if (!BYTE1(v215)) {
                    goto LABEL_434;
                  }
                  unsigned int v214 = v215 >> 8;
                }
                unsigned int v216 = PDM_21362(*v47, v214);
                if ((_BYTE)v216)
                {
                  unsigned int v217 = v216;
                  if (v302)
                  {
                    unsigned int v218 = *v29;
                    if (!*v29) {
                      goto LABEL_433;
                    }
                  }
                  else
                  {
                    LOBYTE(v218) = -1;
                  }
                  unsigned int v217 = PDAhardlightPDA_21373(*v29, v218, v216, v216);
LABEL_433:
                  *float v29 = v217;
                }
              }
LABEL_434:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v213) {
                goto LABEL_575;
              }
            }
          case 22:
            unint64_t v125 = v37;
            int v219 = v4;
            while (1)
            {
              unsigned int v220 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v221 = *v125 * v220 + ((*v125 * v220) >> 8) + 1;
                  if (!BYTE1(v221)) {
                    goto LABEL_448;
                  }
                  unsigned int v220 = v221 >> 8;
                }
                unsigned int v222 = PDM_21362(*v47, v220);
                if ((_BYTE)v222)
                {
                  unsigned int v223 = v222;
                  if (v302)
                  {
                    unsigned int v224 = *v29;
                    if (!*v29) {
                      goto LABEL_447;
                    }
                  }
                  else
                  {
                    LOBYTE(v224) = -1;
                  }
                  unsigned int v223 = PDAdifferencePDA_21375(*v29, v224, v222, v222);
LABEL_447:
                  *float v29 = v223;
                }
              }
LABEL_448:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v219) {
                goto LABEL_575;
              }
            }
          case 23:
            unint64_t v125 = v37;
            int v225 = v4;
            while (1)
            {
              unsigned int v226 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v227 = *v125 * v226 + ((*v125 * v226) >> 8) + 1;
                  if (!BYTE1(v227)) {
                    goto LABEL_462;
                  }
                  unsigned int v226 = v227 >> 8;
                }
                unsigned int v228 = PDM_21362(*v47, v226);
                if ((_BYTE)v228)
                {
                  unsigned int v229 = v228;
                  if (v302)
                  {
                    unsigned int v230 = *v29;
                    if (!*v29) {
                      goto LABEL_461;
                    }
                  }
                  else
                  {
                    LOBYTE(v230) = -1;
                  }
                  unsigned int v229 = PDAexclusionPDA_21376(*v29, v230, v228, v228);
LABEL_461:
                  *float v29 = v229;
                }
              }
LABEL_462:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v225) {
                goto LABEL_575;
              }
            }
          case 24:
            unint64_t v125 = v37;
            int v231 = v4;
            while (1)
            {
              unsigned int v232 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v233 = *v125 * v232 + ((*v125 * v232) >> 8) + 1;
                  if (!BYTE1(v233)) {
                    goto LABEL_476;
                  }
                  unsigned int v232 = v233 >> 8;
                }
                unsigned int v234 = PDM_21362(*v47, v232);
                if ((_BYTE)v234)
                {
                  unsigned int v235 = v234;
                  if (v302)
                  {
                    unsigned int v236 = *v29;
                    if (!*v29) {
                      goto LABEL_475;
                    }
                  }
                  else
                  {
                    LOBYTE(v236) = -1;
                  }
                  unsigned int v235 = PDAhuePDA_21377(*v29, v236, v234, v234);
LABEL_475:
                  *float v29 = v235;
                }
              }
LABEL_476:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v231) {
                goto LABEL_575;
              }
            }
          case 25:
            unint64_t v125 = v37;
            int v237 = v4;
            while (1)
            {
              unsigned int v238 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v239 = *v125 * v238 + ((*v125 * v238) >> 8) + 1;
                  if (!BYTE1(v239)) {
                    goto LABEL_490;
                  }
                  unsigned int v238 = v239 >> 8;
                }
                unsigned int v240 = PDM_21362(*v47, v238);
                if ((_BYTE)v240)
                {
                  unsigned int v241 = v240;
                  if (v302)
                  {
                    unsigned int v242 = *v29;
                    if (!*v29) {
                      goto LABEL_489;
                    }
                  }
                  else
                  {
                    LOBYTE(v242) = -1;
                  }
                  unsigned int v241 = PDAsaturationPDA_21378(*v29, v242, v240, v240);
LABEL_489:
                  *float v29 = v241;
                }
              }
LABEL_490:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v237) {
                goto LABEL_575;
              }
            }
          case 26:
            unint64_t v125 = v37;
            int v243 = v4;
            while (1)
            {
              unsigned int v244 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v245 = *v125 * v244 + ((*v125 * v244) >> 8) + 1;
                  if (!BYTE1(v245)) {
                    goto LABEL_504;
                  }
                  unsigned int v244 = v245 >> 8;
                }
                unsigned int v246 = PDM_21362(*v47, v244);
                if ((_BYTE)v246)
                {
                  if (v302)
                  {
                    unsigned int v247 = *v29;
                    if (!*v29) {
                      goto LABEL_503;
                    }
                  }
                  else
                  {
                    LOBYTE(v247) = -1;
                  }
                  unsigned int v246 = PDAluminosityPDA_21379(v246, v246, *v29, v247);
LABEL_503:
                  *float v29 = v246;
                }
              }
LABEL_504:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v243) {
                goto LABEL_575;
              }
            }
          case 27:
            unint64_t v125 = v37;
            int v248 = v4;
            while (1)
            {
              unsigned int v249 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v250 = *v125 * v249 + ((*v125 * v249) >> 8) + 1;
                  if (!BYTE1(v250)) {
                    goto LABEL_518;
                  }
                  unsigned int v249 = v250 >> 8;
                }
                unsigned int v251 = PDM_21362(*v47, v249);
                if ((_BYTE)v251)
                {
                  unsigned int v252 = v251;
                  if (v302)
                  {
                    unsigned int v253 = *v29;
                    if (!*v29) {
                      goto LABEL_517;
                    }
                  }
                  else
                  {
                    LOBYTE(v253) = -1;
                  }
                  unsigned int v252 = PDAluminosityPDA_21379(*v29, v253, v251, v251);
LABEL_517:
                  *float v29 = v252;
                }
              }
LABEL_518:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v248) {
                goto LABEL_575;
              }
            }
          case 28:
            unint64_t v125 = v37;
            int v254 = v4;
            while (1)
            {
              unsigned int v255 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v256 = *v125 * v255 + ((*v125 * v255) >> 8) + 1;
                  if (!BYTE1(v256)) {
                    goto LABEL_532;
                  }
                  unsigned int v255 = v256 >> 8;
                }
                unsigned int v257 = PDM_21362(*v47, v255);
                if ((_BYTE)v257)
                {
                  unsigned int v258 = v257;
                  if (v302)
                  {
                    unsigned int v259 = *v29;
                    if (!*v29) {
                      goto LABEL_531;
                    }
                  }
                  else
                  {
                    LOBYTE(v259) = -1;
                  }
                  unsigned int v258 = PDAtranspose_huePDA_21380(*v29, v259, v257, v257);
LABEL_531:
                  *float v29 = v258;
                }
              }
LABEL_532:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v254) {
                goto LABEL_575;
              }
            }
          case 29:
            unint64_t v125 = v37;
            int v260 = v4;
            while (1)
            {
              unsigned int v261 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v262 = *v125 * v261 + ((*v125 * v261) >> 8) + 1;
                  if (!BYTE1(v262)) {
                    goto LABEL_546;
                  }
                  unsigned int v261 = v262 >> 8;
                }
                unsigned int v263 = PDM_21362(*v47, v261);
                if ((_BYTE)v263)
                {
                  unsigned int v264 = v263;
                  if (v302)
                  {
                    unsigned int v265 = *v29;
                    if (!*v29) {
                      goto LABEL_545;
                    }
                  }
                  else
                  {
                    LOBYTE(v265) = -1;
                  }
                  unsigned int v264 = PDAtranspose_saturationPDA_21381(*v29, v265, v263, v263);
LABEL_545:
                  *float v29 = v264;
                }
              }
LABEL_546:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v260) {
                goto LABEL_575;
              }
            }
          case 30:
            unint64_t v125 = v37;
            int v266 = v4;
            while (1)
            {
              unsigned int v267 = *v48;
              if (*v48)
              {
                if (v37)
                {
                  unsigned int v268 = *v125 * v267 + ((*v125 * v267) >> 8) + 1;
                  if (!BYTE1(v268)) {
                    goto LABEL_560;
                  }
                  unsigned int v267 = v268 >> 8;
                }
                unsigned int v269 = PDM_21362(*v47, v267);
                if ((_BYTE)v269)
                {
                  if (v302)
                  {
                    unsigned int v270 = *v29;
                    if (!*v29) {
                      goto LABEL_559;
                    }
                  }
                  else
                  {
                    LOBYTE(v270) = -1;
                  }
                  unsigned int v269 = PDAtranspose_luminosityPDA_21382(v269, v269, *v29, v270);
LABEL_559:
                  *float v29 = v269;
                }
              }
LABEL_560:
              ++v48;
              ++v47;
              v125 += v37 != 0;
              ++v29;
              if (!--v266) {
                goto LABEL_575;
              }
            }
          case 31:
            unint64_t v125 = v37;
            int v271 = v4;
            break;
          default:
            uint64_t v109 = v300;
            float v34 = v298;
            goto LABEL_580;
        }
        while (1)
        {
          unsigned int v272 = *v48;
          if (*v48)
          {
            if (v37)
            {
              unsigned int v273 = *v125 * v272 + ((*v125 * v272) >> 8) + 1;
              if (!BYTE1(v273)) {
                goto LABEL_574;
              }
              unsigned int v272 = v273 >> 8;
            }
            unsigned int v274 = PDM_21362(*v47, v272);
            if ((_BYTE)v274)
            {
              unsigned int v275 = v274;
              if (v302)
              {
                unsigned int v276 = *v29;
                if (!*v29) {
                  goto LABEL_573;
                }
              }
              else
              {
                LOBYTE(v276) = -1;
              }
              unsigned int v275 = PDAtranspose_luminosityPDA_21382(*v29, v276, v274, v274);
LABEL_573:
              *float v29 = v275;
            }
          }
LABEL_574:
          ++v48;
          ++v47;
          v125 += v37 != 0;
          ++v29;
          if (!--v271)
          {
LABEL_575:
            float v37 = &v125[v294];
LABEL_576:
            unint64_t v58 = v295;
            float v39 = v296;
LABEL_577:
            v29 += v58;
            goto LABEL_578;
          }
        }
      }
      if (!shape_enum_clip_scan((uint64_t)v34, (_DWORD *)v37 - 4)) {
        goto LABEL_607;
      }
    }
    v299 -= v44;
    if (v299 < 1) {
      break;
    }
    v33 += v39[16] * v44;
    v42 += v39[17] * v44;
    v29 += v285 * v44;
    int v35 = v43;
  }
LABEL_607:
  if (v34) {
    free(v34);
  }
LABEL_609:
  if (v287) {
    free(v287);
  }
}

void rgba32_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12)
{
  float v12 = *(float *)(a1 + 280);
  float v13 = *(float *)(a1 + 296)
      + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
              + (float)(v12 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  uint64_t v14 = a1 + 368;
  uint64_t v15 = *(void *)(a1 + 368);
  uint64_t v16 = ((unint64_t)a3 >> 4) & 0xF0;
  uint64_t v17 = v15 + v16;
  if (v15) {
    uint64_t v18 = v15 + v16;
  }
  else {
    uint64_t v18 = a1 + 368;
  }
  if (v15) {
    char v19 = 15;
  }
  else {
    char v19 = 0;
  }
  float v21 = *(float *)(a1 + 336);
  float v22 = *(float *)(a1 + 344);
  float v23 = *(float *)(a1 + 304);
  float v24 = *(float *)(a1 + 308);
  int v25 = *(_DWORD *)(a1 + 320);
  int v26 = *(_DWORD *)(a1 + 324);
  uint64_t v29 = a1 + 144;
  uint64_t v27 = *(_DWORD **)(a1 + 144);
  uint64_t v28 = *(void *)(v29 + 8);
  uint64_t v30 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v31 = *(void *)(a1 + 360);
  if (v12 != 0.0)
  {
    if (v15) {
      unsigned int v37 = (a2 >> 8) & 0xF;
    }
    else {
      LOBYTE(v37) = 0;
    }
    while (1)
    {
      int v38 = v25;
      if (v13 >= v23)
      {
        int v38 = v26;
        if (v13 <= v24) {
          int v38 = (int)(float)(v22 * (float)(v13 - v21));
        }
      }
      if (v38 < 0)
      {
        if (!v30)
        {
          char v49 = 0;
          goto LABEL_40;
        }
        int v48 = *(unsigned __int8 *)(v18 + v37);
        int v44 = v48 + *v30;
        __int16 v45 = v48 + v30[1];
        int v46 = v48 + v30[2];
        __int16 v47 = v48 + v30[3];
      }
      else
      {
        float v39 = (unsigned __int16 *)(v31 + 8 * v38);
        unsigned __int16 v40 = v39[1];
        int v41 = *(unsigned __int8 *)(v18 + v37);
        int v42 = v39[2];
        unsigned __int16 v43 = v39[3];
        int v44 = v41 + *v39;
        __int16 v45 = v41 + v40;
        int v46 = v41 + v42;
        __int16 v47 = v41 + v43;
      }
      *(_DWORD *)uint64_t v28 = (v46 | (v44 << 16)) & 0xFF00FF00 | (HIBYTE(v45) << 16) | HIBYTE(v47);
      char v49 = -1;
LABEL_40:
      LOBYTE(v37) = (v37 + 1) & v19;
      float v13 = v12 + v13;
      v28 += 4;
      *(unsigned char *)uint64_t v27 = v49;
      uint64_t v27 = (_DWORD *)((char *)v27 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v15) {
    uint64_t v32 = v17;
  }
  else {
    uint64_t v32 = v14;
  }
  if (v15) {
    LODWORD(v33) = ((a2 >> 8) + 1) & 0xF;
  }
  else {
    LODWORD(v33) = 0;
  }
  if (v15) {
    LODWORD(v34) = (a2 >> 8) & 0xF;
  }
  else {
    LODWORD(v34) = 0;
  }
  if (v15) {
    int v35 = 15;
  }
  else {
    int v35 = 0;
  }
  if (v13 >= v23)
  {
    int v25 = v26;
    if (v13 <= v24) {
      int v25 = (int)(float)(v22 * (float)(v13 - v21));
    }
  }
  if ((v25 & 0x80000000) == 0 || v30)
  {
    unsigned int v50 = (unsigned __int16 *)(v31 + 8 * v25);
    if (v25 < 0) {
      int v51 = v30;
    }
    else {
      int v51 = v50;
    }
    unsigned int v52 = *v51;
    unsigned int v53 = v51[3];
    unsigned int v54 = v51[2];
    unsigned int v55 = v51[1];
    if (v15)
    {
      int32x2_t v56 = vdup_n_s32(v52);
      int32x2_t v57 = vdup_n_s32(v55);
      int v58 = a4 + 4;
      int32x2_t v59 = vdup_n_s32(v54);
      int32x2_t v60 = vdup_n_s32(v53);
      do
      {
        uint64_t v61 = (__int8 *)(v32 + v34);
        uint64_t v34 = (v34 + 1) & v35;
        a12.i8[0] = *v61;
        a12.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v62 = (int32x2_t)vand_s8(a12, (int8x8_t)0xFF000000FFLL);
        int8x8_t v63 = vorr_s8(vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v56, v62), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), vand_s8((int8x8_t)vadd_s32(v59, v62), (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v57, v62), 8uLL), (int8x8_t)0xFF000000FF0000), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v60, v62), 8uLL) & 0xFFFFFEFFFFFFFEFFLL)));
        *(int8x8_t *)uint64_t v28 = v63;
        uint64_t v33 = (v33 + 1) & v35;
        v63.i8[0] = *(unsigned char *)(v32 + v34);
        v63.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v64 = (int32x2_t)vand_s8(v63, (int8x8_t)0xFF000000FFLL);
        a12 = vorr_s8(vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v56, v64), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), vand_s8((int8x8_t)vadd_s32(v59, v64), (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v57, v64), 8uLL), (int8x8_t)0xFF000000FF0000), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v60, v64), 8uLL) & 0xFFFFFEFFFFFFFEFFLL)));
        *(double *)(v28 + 8) = *(double *)&a12;
        *v27++ = -1;
        v58 -= 4;
        v28 += 16;
      }
      while (v58 > 4);
    }
    else
    {
      int32x4_t v65 = vdupq_n_s32((v52 << 16) & 0xFF000000 | (v53 >> 8) & 0xFF00FFFF | v54 & 0xFF00 | (BYTE1(v55) << 16));
      int v66 = a4 + 4;
      do
      {
        *(int32x4_t *)uint64_t v28 = v65;
        v28 += 16;
        *v27++ = -1;
        v66 -= 4;
      }
      while (v66 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v36 = 4;
    }
    else {
      int v36 = a4;
    }
    bzero(v27, ((a4 - v36 + 3) & 0xFFFFFFFC) + 4);
  }
}

void load_allow_debugging_defaults(void *a1)
{
  char v1 = getenv("CGAllowDebuggingDefaults");
  if (v1)
  {
    int v3 = 0;
    allow_debugging_defaults = sscanf(v1, "%i", &v3) > 0;
  }
  else
  {
    CFPropertyListRef v2 = CFPreferencesCopyValue(@"CGAllowDebuggingDefaults", (CFStringRef)*MEMORY[0x1E4F1D3B8], (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
    if ((get_BOOL((uint64_t)v2, (BOOL *)&allow_debugging_defaults) & 1) == 0) {
      allow_debugging_defaults = 0;
    }
    if (v2)
    {
      CFRelease(v2);
    }
  }
}

uint64_t get_BOOL(uint64_t result, BOOL *a2)
{
  if (result)
  {
    CFBooleanRef v3 = (const __CFBoolean *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFBooleanGetTypeID())
    {
      if (a2)
      {
        BOOL v5 = CFBooleanGetValue(v3) == 0;
LABEL_5:
        LOBYTE(result) = !v5;
        goto LABEL_24;
      }
      return 1;
    }
    if (v4 != CFStringGetTypeID())
    {
LABEL_15:
      if (v4 != CFNumberGetTypeID()) {
        return 0;
      }
      int valuePtr = 0;
      BOOL result = CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      if (!result) {
        return result;
      }
      if (!a2) {
        return 1;
      }
      BOOL v5 = valuePtr == 0;
      goto LABEL_5;
    }
    if (CFStringCompare((CFStringRef)v3, @"Yes", 1uLL)
      && CFStringCompare((CFStringRef)v3, @"True", 1uLL)
      && CFStringCompare((CFStringRef)v3, @"1", 1uLL))
    {
      if (CFStringCompare((CFStringRef)v3, @"No", 1uLL)
        && CFStringCompare((CFStringRef)v3, @"False", 1uLL)
        && CFStringCompare((CFStringRef)v3, @"0", 1uLL))
      {
        goto LABEL_15;
      }
      if (!a2) {
        return 1;
      }
      LOBYTE(result) = 0;
LABEL_24:
      *a2 = result;
      return 1;
    }
    BOOL result = 1;
    if (a2) {
      goto LABEL_24;
    }
  }
  return result;
}

uint64_t CGSoftMaskCreate(uint64_t a1, long long *a2, const void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  if (!a5 || a4 && (a4[6] != 1 || a4[4] != 1)) {
    return 0;
  }
  if (_block_invoke_once_16928 != -1) {
    dispatch_once(&_block_invoke_once_16928, &__block_literal_global_5_16929);
  }
  uint64_t Instance = CGTypeCreateInstance(CGSoftMaskGetTypeID_soft_mask_type_id, 144, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  uint64_t v22 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = atomic_fetch_add_explicit(&identifier_16930, 1u, memory_order_relaxed) + 1;
    long long v23 = *a2;
    long long v24 = a2[1];
    *(_OWORD *)(Instance + 56) = a2[2];
    *(_OWORD *)(Instance + 40) = v24;
    *(_OWORD *)(Instance + 24) = v23;
    *(double *)(Instance + 72) = a9;
    *(double *)(Instance + 80) = a10;
    *(double *)(Instance + 88) = a11;
    *(double *)(Instance + 96) = a12;
    if (a3) {
      CFRetain(a3);
    }
    *(void *)(v22 + 104) = a3;
    if (a4) {
      CFRetain(a4);
    }
    *(void *)(v22 + 112) = a4;
    *(void *)(v22 + 120) = a1;
    uint64_t v25 = *(void *)(a5 + 16);
    *(_OWORD *)(v22 + 128) = *(_OWORD *)a5;
    *(void *)(v22 + 144) = v25;
    *(void *)(v22 + 152) = 0;
  }
  return v22;
}

CGFloat CGClipStackGetRect(uint64_t a1)
{
  char v1 = &CGRectInfinite;
  if (a1) {
    char v1 = (const CGRect *)(a1 + 16);
  }
  return v1->origin.x;
}

float *rips_s_Create(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  size_t v6 = (*(uint64_t (**)(void))(a1 + 8))();
  uint64_t v7 = (float *)malloc_type_calloc(1uLL, v6, 0x774F7A69uLL);
  float v8 = v7;
  if (v7)
  {
    *(void *)uint64_t v7 = a1;
    *((void *)v7 + 1) = 1;
    if (a2) {
      float v9 = (double *)(a2 + 32);
    }
    else {
      float v9 = 0;
    }
    if (a2)
    {
      uint64_t v10 = *(void *)(a2 + 24);
      if (v10)
      {
        if (v10 < 1 || !*(void *)(v10 + 32))
        {
          CFRetain((CFTypeRef)v10);
          *((void *)v8 + 10) = v10;
        }
      }
    }
    double v11 = v9[3];
    double v12 = 1.0;
    float v13 = 1.0 - v11;
    v8[28] = v13;
    v8[30] = 0.0;
    float v14 = v9[6];
    v8[31] = v14;
    if (a3) {
      double v12 = sqrt(fabs(a3->f64[0] * a3[1].f64[1] - a3->f64[1] * a3[1].f64[0]));
    }
    else {
      a3 = (float64x2_t *)&CGAffineTransformIdentity;
    }
    float v15 = v12 * v9[5];
    if (v15 <= 4194300.0) {
      float v16 = v15;
    }
    else {
      float v16 = 4194300.0;
    }
    v8[29] = v16;
    if (v11 <= 0.99609375)
    {
      double v17 = v9[2] * 3.14159265 / 180.0;
      double v18 = v9[1] * 3.14159265 / 180.0;
      double v19 = 0.0;
      if (v18 <= 1.569051)
      {
        if (v18 >= 0.00174532925)
        {
          double v20 = v9[4];
          double v19 = v20 / tan(v18);
        }
        else
        {
          double v19 = 1.79769313e308;
        }
      }
      __double2 v21 = __sincos_stret(v17);
      *((_DWORD *)v8 + 3) = 1777;
      float64x2_t v22 = vmlaq_n_f64(vmulq_n_f64(a3[1], -(v19 * v21.__sinval)), *a3, -(v19 * v21.__cosval));
      float64x2_t v23 = (float64x2_t)vdupq_n_s64(0xC1CFFFFFFF800000);
      float64x2_t v24 = (float64x2_t)vdupq_n_s64(0x41CFFFFFFF800000uLL);
      *(int32x2_t *)&v22.f64[0] = vmovn_s64(vcvtq_s64_f64(vrndaq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v23, v22), (int8x16_t)v23, vbslq_s8((int8x16_t)vcgtq_f64(v22, v24), (int8x16_t)v24, (int8x16_t)v22)))));
      *((void *)v8 + 11) = *(void *)&v22.f64[0];
      *(int32x2_t *)&v22.f64[0] = vadd_s32(vdup_n_s32(vcvtms_s32_f32(v16 + 0.5) + 1), vabs_s32(*(int32x2_t *)&v22.f64[0]));
      *((int32x2_t *)v8 + 12) = vneg_s32(*(int32x2_t *)&v22.f64[0]);
      *((int32x2_t *)v8 + 13) = vadd_s32(*(int32x2_t *)&v22.f64[0], *(int32x2_t *)&v22.f64[0]);
    }
  }
  return v8;
}

uint64_t rips_s_size()
{
  return 128;
}

uint64_t (*__object_md5_creator_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  BOOL result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    BOOL result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileGetTypeID");
  }
  if (result) {
    char v1 = result;
  }
  else {
    char v1 = colorsync_smart_null;
  }
  object_md5_creator_f = v1;
  return result;
}

uint64_t CGGradientCreateWithColorsAndOptions(void *a1, CFArrayRef theArray, uint64_t a3, const __CFDictionary *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  if (!theArray)
  {
    float v15 = "CGGradientCreateWithColors: non-NULL CFArrayRef with colors is required";
LABEL_49:
    CGPostError((uint64_t)v15, (uint64_t)theArray, a3, (uint64_t)a4, a5, a6, a7, a8, v102[0]);
    return 0;
  }
  double v11 = a1;
  if (a1)
  {
    unsigned int v12 = *(_DWORD *)(a1[3] + 28) - 3;
    if (v12 > 3)
    {
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count)
      {
        size_t v14 = Count;
        CFRetain(v11);
        goto LABEL_10;
      }
      goto LABEL_48;
    }
    CGPostError((uint64_t)off_1E52CC038[v12], (uint64_t)theArray, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"CGGradientCreateWithColors");
    return 0;
  }
  CFIndex v16 = CFArrayGetCount(theArray);
  if (!v16)
  {
LABEL_48:
    float v15 = "CGGradientCreateWithColors: CFArrayRef with colors cannot be empty";
    goto LABEL_49;
  }
  size_t v14 = v16;
  CGColorSpaceRef v17 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericRGB");
  if (!v17) {
    return 0;
  }
  double v11 = v17;
LABEL_10:
  if (kCGColorComponents_block_invoke_once != -1) {
    dispatch_once(&kCGColorComponents_block_invoke_once, &__block_literal_global_31);
  }
  char v18 = 0;
  CFIndex v19 = 0;
  uint64_t v20 = CGColorGetTypeID_color_type_id;
  do
  {
    while (1)
    {
      ValueAtIndefloat64x2_t x = CFArrayGetValueAtIndex(theArray, v19);
      if (!ValueAtIndex) {
        goto LABEL_54;
      }
      unint64_t v22 = (unint64_t)ValueAtIndex;
      if (CFGetTypeID(ValueAtIndex) != v20) {
        goto LABEL_54;
      }
      CGColorSpaceRef v30 = (v22 & 0x8000000000000000) != 0
          ? CGTaggedColorGetColorSpace(v22, v23, v24, v25, v26, v27, v28, v29)
          : *(CGColorSpaceRef *)(v22 + 24);
      uint64_t v31 = CFEqual(v30, v11);
      v18 |= v31 == 0;
      if ((v18 & 1) == 0) {
        break;
      }
      if (!v11 || !*(unsigned char *)(v11[3] + 10))
      {
        CGColorSpaceGetType(v11);
        unsigned int Type = CGColorSpaceGetType(v30);
        if (Type > 0xB) {
          uint64_t v73 = "Unknown";
        }
        else {
          uint64_t v73 = off_1E52CEBC8[Type];
        }
        CGPostError((uint64_t)"CGGradientCreateWithColors: unsupported color conversion from %s type to %s type", v66, v67, v68, v69, v70, v71, v72, (char)v73);
LABEL_54:
        CGColorSpaceRelease((CGColorSpaceRef)v11);
        return 0;
      }
      if (++v19 == v14) {
        goto LABEL_25;
      }
    }
    ++v19;
  }
  while (v19 != v14);
  if (v11) {
LABEL_25:
  }
    uint64_t v33 = *(void *)(v11[3] + 48);
  else {
    uint64_t v33 = 0;
  }
  uint64_t v34 = v33 + 1;
  MEMORY[0x1F4188790](v31, v32);
  int v38 = (char *)v102 - v37;
  if (v36 <= 0x1FFFFFFFFFFFFFFELL) {
    float v39 = (double *)((char *)v102 - v37);
  }
  else {
    float v39 = 0;
  }
  if (v36 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000012) {
    float v39 = (double *)malloc_type_malloc(8 * v35, 0xA53AE156uLL);
  }
  int v103 = v39;
  if (v18)
  {
    CFTypeRef v105 = (CFTypeRef)color_transform_create((CGColorSpaceRef)v11, 0);
    if (v105)
    {
      v102[0] = v38;
      v102[1] = v102;
      CFIndex v40 = 0;
      uint64_t v41 = v33;
      uint64_t v104 = 8 * v33 + 8;
      int v42 = v103;
      while (1)
      {
        unint64_t v43 = (unint64_t)CFArrayGetValueAtIndex(theArray, v40);
        unint64_t v51 = v43;
        if (v43) {
          CGColorSpaceRef v52 = (v43 & 0x8000000000000000) != 0
        }
              ? CGTaggedColorGetColorSpace(v43, v44, v45, v46, v47, v48, v49, v50)
              : *(CGColorSpaceRef *)(v43 + 24);
        else {
          CGColorSpaceRef v52 = 0;
        }
        Components = (double *)CGColorGetComponents((CGColorRef)v51);
        if ((CGColorTransformConvertColorComponents((uint64_t)v105, v52, 0, Components, v42) & 1) == 0) {
          break;
        }
        if (v51)
        {
          if ((v51 & 0x8000000000000000) != 0) {
            double Alpha = CGTaggedColorGetAlpha(v51, v54, v55, v56, v57, v58, v59, v60);
          }
          else {
            double Alpha = *(double *)(v51 + 8 * *(void *)(v51 + 56) + 56);
          }
        }
        else
        {
          double Alpha = 0.0;
        }
        v42[v41] = Alpha;
        ++v40;
        int v42 = (double *)((char *)v42 + v104);
        if (v14 == v40)
        {
          CFRelease(v105);
          int v38 = (char *)v102[0];
          goto LABEL_59;
        }
      }
      CGColorSpaceGetType(v11);
      int v91 = (double *)v102[0];
      unsigned int v93 = CGColorSpaceGetType(v52);
      if (v93 > 0xB) {
        float v101 = "Unknown";
      }
      else {
        float v101 = off_1E52CEBC8[v93];
      }
      CGPostError((uint64_t)"CGGradientCreateWithColors: failed to convert color from %s type to %s type", v94, v95, v96, v97, v98, v99, v100, (char)v101);
      CFRelease(v105);
      int v92 = v103;
      if (v103 == v91) {
        goto LABEL_68;
      }
    }
    else
    {
      unsigned int v82 = CGColorSpaceGetType(v11);
      if (v82 > 0xB) {
        int v90 = "Unknown";
      }
      else {
        int v90 = off_1E52CEBC8[v82];
      }
      CGPostError((uint64_t)"CGGradientCreateWithColors: failed to create color transform for color space type %s", v83, v84, v85, v86, v87, v88, v89, (char)v90);
      int v92 = v103;
      if (v103 == (double *)v38) {
        goto LABEL_68;
      }
    }
    free(v92);
LABEL_68:
    CGColorSpaceRelease((CGColorSpaceRef)v11);
    return 0;
  }
  CFIndex v76 = 0;
  size_t v77 = 8 * v34;
  int v78 = v39;
  do
  {
    int v79 = (CGColor *)CFArrayGetValueAtIndex(theArray, v76);
    int v80 = CGColorGetComponents(v79);
    memmove(v78, v80, v77);
    ++v76;
    int v78 = (double *)((char *)v78 + v77);
  }
  while (v14 != v76);
LABEL_59:
  int v81 = v103;
  uint64_t v74 = CGGradientCreateWithColorComponentsAndOptions(v11, (uint64_t)v103, a3, v14, a4, v62, v63, v64);
  CGColorSpaceRelease((CGColorSpaceRef)v11);
  if (v81 != (double *)v38) {
    free(v81);
  }
  return v74;
}

uint64_t CGGradientCreateWithColorComponentsAndOptions(void *a1, uint64_t a2, uint64_t a3, size_t a4, const __CFDictionary *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance = 0;
  if (!a1) {
    return Instance;
  }
  uint64_t v9 = a2;
  if (!a2 || !a4) {
    return Instance;
  }
  uint64_t v12 = a1[3];
  unsigned int v13 = *(_DWORD *)(v12 + 28) - 3;
  if (v13 <= 3)
  {
    CGPostError((uint64_t)off_1E52CC038[v13], a2, a3, a4, (uint64_t)a5, a6, a7, a8, (char)"CGGradientCreateWithColorComponents");
    return 0;
  }
  if (a3)
  {
    char v16 = 0;
    char v17 = 0;
    char v18 = 1;
    double v19 = -INFINITY;
    uint64_t v20 = (double *)a3;
    size_t v21 = a4;
    do
    {
      double v22 = v19;
      double v19 = *v20;
      if (*v20 == 0.0)
      {
        char v17 = 1;
      }
      else if (v19 == 1.0)
      {
        char v16 = 1;
      }
      else if (v19 < 0.0 || v19 > 1.0)
      {
        return 0;
      }
      if (v22 > v19) {
        char v18 = 0;
      }
      ++v20;
      --v21;
    }
    while (v21);
    char v24 = v17;
    if (v17) {
      size_t v25 = a4;
    }
    else {
      size_t v25 = a4 + 1;
    }
    char v26 = v16;
    if (v16) {
      size_t v27 = v25;
    }
    else {
      size_t v27 = v25 + 1;
    }
    goto LABEL_30;
  }
  if (a4 == 1) {
    return 0;
  }
  char v24 = 1;
  size_t v27 = a4;
  char v26 = 1;
  char v18 = 1;
LABEL_30:
  char v54 = v18;
  uint64_t v29 = *(void *)(v12 + 48);
  if (kCGGradientInterpolatesPremultiplied_block_invoke_once != -1) {
    dispatch_once(&kCGGradientInterpolatesPremultiplied_block_invoke_once, &__block_literal_global_20_13777);
  }
  uint64_t v55 = v29 + 2;
  uint64_t Instance = CGTypeCreateInstance(CGGradientGetTypeID_gradient_type_id, 40, a3, a4, (uint64_t)a5, a6, a7, a8);
  *(_DWORD *)(Instance + 16) = atomic_fetch_add_explicit(CGGradientCreateWithColorComponentsAndOptions_identifier, 1u, memory_order_relaxed)+ 1;
  CFRetain(a1);
  *(void *)(Instance + 24) = a1;
  *(void *)(Instance + 48) = v27;
  if (a5) {
    *(unsigned char *)(Instance + 20) = CFDictionaryGetValue(a5, @"kCGGradientInterpolatesPremultiplied") == (const void *)*MEMORY[0x1E4F1CFD0];
  }
  CFMutableArrayRef Mutable = CFDataCreateMutable(0, 8 * v27 * v55);
  *(void *)(Instance + 40) = Mutable;
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v37 = MutableBytePtr;
  if (a3)
  {
    char v52 = v24;
    char v53 = v26;
    uint64_t v38 = 0;
    uint64_t v39 = v29 + 1;
    uint64_t v49 = &MutableBytePtr[8 * v55];
    if (v24) {
      CFIndex v40 = MutableBytePtr;
    }
    else {
      CFIndex v40 = &MutableBytePtr[8 * v55];
    }
    uint64_t v41 = 8 * v29;
    uint64_t v42 = 8 * v29 + 16;
    unint64_t v50 = v41 ^ 0xFFFFFFFFFFFFFFF8;
    uint64_t v51 = v39;
    uint64_t v43 = v41 + 8;
    do
    {
      *(void *)CFIndex v40 = *(void *)(a3 + 8 * v38);
      CGColorSpaceAdjustColor((uint64_t)a1, v9, (double *)v40 + 1, v32, v33, v34, v35, v36);
      ++v38;
      v40 += v42;
      v9 += v43;
    }
    while (a4 != v38);
    if ((v54 & 1) == 0)
    {
      if (v52) {
        uint64_t v44 = 0;
      }
      else {
        uint64_t v44 = v55;
      }
      mergesort(&v37[8 * v44], a4, 8 * v55, (int (__cdecl *)(const void *, const void *))is_smaller_stop);
    }
    if ((v52 & 1) == 0)
    {
      memcpy(v37 + 8, v49 + 8, 8 * v51);
      *(void *)uint64_t v37 = 0;
    }
    if ((v53 & 1) == 0)
    {
      memcpy(v40 + 8, &v40[v50], 8 * v51);
      *(void *)CFIndex v40 = 0x3FF0000000000000;
    }
  }
  else
  {
    unint64_t v45 = 0;
    uint64_t v46 = (double *)(MutableBytePtr + 8);
    uint64_t v47 = 8 * v29 + 16;
    uint64_t v48 = 8 * v29 + 8;
    do
    {
      *(v46 - 1) = (double)v45 / (double)(a4 - 1);
      CGColorSpaceAdjustColor((uint64_t)a1, v9, v46, v32, v33, v34, v35, v36);
      ++v45;
      uint64_t v46 = (double *)((char *)v46 + v47);
      v9 += v48;
    }
    while (a4 != v45);
  }
  return Instance;
}

void *CGPDFScannerFinalize(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 72);
  if ((v2 & 0x80000000) != 0)
  {
    pdf_error("Fatal: Attempted to remove more than args stack count. Argument stack is inconsistent.");
  }
  else if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(a1 + 80) + v3;
      if ((*(_DWORD *)(v4 + 8) - 5) <= 4) {
        pdf_object_release_compound_value(v4);
      }
      v3 += 40;
    }
    while (40 * v2 != v3);
  }
  *(_DWORD *)(a1 + 72) -= v2;
  free(*(void **)(a1 + 80));
  BOOL v5 = *(const void **)(a1 + 56);
  if (v5) {
    CFRelease(v5);
  }
  size_t v6 = *(uint64_t ***)(a1 + 32);
  if (v6)
  {
    do
    {
      free(v6[1]);
      size_t v6 = (uint64_t **)*v6;
    }
    while (v6);
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7)
    {
      do
      {
        float v8 = (void *)*v7;
        free(v7);
        uint64_t v7 = v8;
      }
      while (v8);
    }
  }
  uint64_t v9 = *(void **)(a1 + 96);
  if (v9)
  {
    do
    {
      uint64_t v10 = (void *)*v9;
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
  }
  uint64_t v11 = *(void *)(a1 + 64);
  if (v11) {
    pdf_lexer_release(v11);
  }
  BOOL result = *(void **)(a1 + 144);
  if (result)
  {
    do
    {
      unsigned int v13 = (void *)*result;
      free(result);
      BOOL result = v13;
    }
    while (v13);
  }
  return result;
}

uint64_t *__CGCMSUtilsCreateLinearSRGBProfile_block_invoke_3()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  BOOL result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (BOOL result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncSRGBProfile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  _block_invoke_2_s = v1;
  return result;
}

uint64_t __CGPDFStreamGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFStreamGetTypeID_class);
  CGPDFStreamGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFContentStreamGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFContentStreamGetTypeID_class);
  CGPDFContentStreamGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFOperatorTableGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFOperatorTableGetTypeID_class);
  CGPDFOperatorTableGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFScannerGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFScannerGetTypeID_class);
  CGPDFScannerGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFDictionaryGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFDictionaryGetTypeID_class);
  CGPDFDictionaryGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFDocumentGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFDocumentGetTypeID::runtime_class);
  CGPDFDocumentGetTypeID::idouble d = result;
  return result;
}

uint64_t __CGPDFArrayGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFArrayGetTypeID_class);
  CGPDFArrayGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFSourceGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFSourceGetTypeID_class);
  CGPDFSourceGetTypeID_idouble d = result;
  return result;
}

uint64_t __pdf_document_get_type_id_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&pdf_document_get_type_id_class);
  pdf_document_get_type_id_idouble d = result;
  return result;
}

uint64_t __CGPDFPageGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFPageGetTypeID_class);
  CGPDFPageGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFStringGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFStringGetTypeID_class);
  CGPDFStringGetTypeID_idouble d = result;
  return result;
}

uint64_t __CGPDFResourcesGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFResourcesGetTypeID_class);
  CGPDFResourcesGetTypeID_idouble d = result;
  return result;
}

uint64_t pdf_register_cftype(uint64_t a1)
{
  uint64_t v2 = _CFRuntimeRegisterClass();
  if (!v2) {
    pdf_error("Failed to register CFRuntimeClass \"%s\".", *(const char **)(a1 + 8));
  }
  return v2;
}

uint64_t *__color_space_state_create_display_p3_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (uint64_t result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncDisplayP3Profile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_display_p3_s = v1;
  return result;
}

CFMutableSetRef __get_states_cache_block_invoke()
{
  CFMutableSetRef result = CFSetCreateMutable(0, 0, &get_states_cache_callbacks);
  get_states_cache_states = (uint64_t)result;
  return result;
}

void CGContextResetClip(CGContextRef c)
{
  if (c && *((_DWORD *)c + 4) == 1129601108) {
    CGGStateResetClip(*((void *)c + 12));
  }
  else {
    handle_invalid_context((char)"CGContextResetClip", (uint64_t)c, v1, v2, v3, v4, v5, v6);
  }
}

uint64_t (*__color_space_state_create_display_p3_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFMutableSetRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CFMutableSetRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_display_p3_f = v1;
  return result;
}

void *std::__tree<std::shared_ptr<CG::DisplayListEntryStateStroke const>,CG::CompareEntryStateStroke,std::allocator<std::shared_ptr<CG::DisplayListEntryStateStroke const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateStroke const>>(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    while (1)
    {
      uint64_t v7 = (void *)v4;
      uint64_t v8 = *a3;
      uint64_t v9 = (std::__shared_weak_count *)a3[1];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v10 = *(void *)(v4 + 32);
      uint64_t v11 = *(std::__shared_weak_count **)(v4 + 40);
      if (!v11) {
        break;
      }
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v12 = CG::CompareEntryStateStroke::operator()(v8, v10);
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      if (v9) {
        goto LABEL_6;
      }
LABEL_7:
      if (v12)
      {
        uint64_t v4 = *v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_23;
        }
      }
      else
      {
        uint64_t v13 = v7[4];
        size_t v14 = (std::__shared_weak_count *)v7[5];
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v15 = *a3;
        char v16 = (std::__shared_weak_count *)a3[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v17 = CG::CompareEntryStateStroke::operator()(v13, v15);
          std::__shared_weak_count::__release_shared[abi:fe180100](v16);
          if (!v14) {
            goto LABEL_15;
          }
LABEL_14:
          std::__shared_weak_count::__release_shared[abi:fe180100](v14);
          goto LABEL_15;
        }
        BOOL v17 = CG::CompareEntryStateStroke::operator()(v13, v15);
        if (v14) {
          goto LABEL_14;
        }
LABEL_15:
        if (!v17) {
          goto LABEL_23;
        }
        uint64_t v5 = v7 + 1;
        uint64_t v4 = v7[1];
        if (!v4) {
          goto LABEL_23;
        }
      }
    }
    BOOL v12 = CG::CompareEntryStateStroke::operator()(v8, v10);
    if (!v9) {
      goto LABEL_7;
    }
LABEL_6:
    std::__shared_weak_count::__release_shared[abi:fe180100](v9);
    goto LABEL_7;
  }
  uint64_t v7 = (void *)(a1 + 8);
LABEL_23:
  *a2 = v7;
  return v5;
}

BOOL CG::CompareEntryStateStroke::operator()(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a2 + 8);
  if (v2 < v3) {
    return 1;
  }
  if (v2 > v3) {
    return 0;
  }
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a2 + 40);
  if (v4 < v5) {
    return 1;
  }
  if (v4 > v5) {
    return 0;
  }
  double v6 = *(double *)(a1 + 16);
  double v7 = *(double *)(a2 + 16);
  if (v6 < v7) {
    return 1;
  }
  if (v6 > v7) {
    return 0;
  }
  double v8 = *(double *)(a1 + 24);
  double v9 = *(double *)(a2 + 24);
  if (v8 < v9) {
    return 1;
  }
  if (v8 > v9) {
    return 0;
  }
  double v10 = *(double *)(a1 + 32);
  double v11 = *(double *)(a2 + 32);
  if (v10 < v11) {
    return 1;
  }
  if (v10 > v11) {
    return 0;
  }
  __int16 v12 = *(_WORD *)(a1 + 48);
  __int16 v13 = *(_WORD *)(a2 + 48);
  if ((char)v12 < (char)v13) {
    return 1;
  }
  if ((char)v12 > (char)v13) {
    return 0;
  }
  int v14 = v12 >> 8;
  if (v14 < v13 >> 8) {
    return 1;
  }
  if (v14 > v13 >> 8) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 50)) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = *(unsigned char *)(a2 + 50) == 0;
  }
  return !v16;
}

void CGContextEOClip(CGContextRef c)
{
  clip((uint64_t)c, 1, v1, v2, v3, v4, v5, v6);
}

CGColorSpaceRef CGColorSpaceCreateWithPlatformColorSpace(const void *ref)
{
  return create_colorspace_with_ColorSync_profile(ref, 0);
}

BOOL CGColorSpaceGetCICPInfo(BOOL result, _DWORD *a2)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = (void *)result;
  CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  if (v4 != CGColorSpaceGetTypeID_type_id) {
    return 0;
  }
  if (CGColorSpaceGetType(v3) == 6)
  {
    uint64_t v5 = (uint64_t *)(*(void *)(v3[3] + 96) + 16);
  }
  else
  {
    if (CGColorSpaceGetType(v3) != 11)
    {
      uint64_t v6 = 0;
      goto LABEL_12;
    }
    uint64_t v5 = *(uint64_t **)(v3[3] + 96);
  }
  uint64_t v6 = *v5;
LABEL_12:
  if (CGColorSpaceGetCICPInfo_cglibrarypredicate != -1) {
    dispatch_once(&CGColorSpaceGetCICPInfo_cglibrarypredicate, &__block_literal_global_60_7572);
  }
  CICPInfo_f = (_DWORD *)CGColorSpaceGetCICPInfo_f(v6);
  CFMutableSetRef result = CICPInfo_f != 0;
  if (a2)
  {
    if (CICPInfo_f)
    {
      *a2 = *CICPInfo_f;
      return 1;
    }
  }
  return result;
}

const void *CGPDFObjectCopyAssociation(uint64_t a1, const char *a2)
{
  if (!a1) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 8);
  if (v3 == 9)
  {
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 48);
  }
  else
  {
    if (v3 != 8)
    {
      if (v3 == 7)
      {
        uint64_t v4 = *(void *)(a1 + 32);
        if (v4)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v4 + 64));
          BOOL Object = (const void *)CGPDFAssociationGetObject(*(void *)(v4 + 56), a2);
          uint64_t v6 = Object;
          if (Object) {
            CFRetain(Object);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v4 + 64));
          return v6;
        }
      }
      return 0;
    }
    uint64_t v8 = *(void *)(a1 + 32);
  }

  return CGPDFDictionaryCopyAssociation(v8, a2);
}

uint64_t CGPDFObjectSetAssociation(uint64_t a1, const void *a2, const char *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  switch(v5)
  {
    case 9:
      uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 48);
      break;
    case 8:
      uint64_t v11 = *(void *)(a1 + 32);
      break;
    case 7:
      uint64_t v6 = *(void *)(a1 + 32);
      if (!v6) {
        return 0;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 64));
      double v7 = *(const void ***)(v6 + 56);
      if (v7)
      {
        *(void *)(v6 + 56) = 0;
        CGPDFAssociationRelease(v7);
      }
      uint64_t v8 = CGPDFAssociationCreate(a2, (uint64_t)a3);
      *(void *)(v6 + 56) = v8;
      uint64_t Object = CGPDFAssociationGetObject((uint64_t)v8, a3);
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 64));
      return Object;
    default:
      return 0;
  }

  return CGPDFDictionarySetAssociation(v11, a2, a3);
}

uint64_t CGPDFAssociationGetObject(uint64_t result, const char *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (!a2) {
      return *(void *)v2;
    }
    int v3 = *(const char **)(result + 8);
    if (v3 == a2 || !strcmp(v3, a2)) {
      return *(void *)v2;
    }
    else {
      return 0;
    }
  }
  return result;
}

void *CGPDFAssociationCreate(const void *a1, uint64_t a2)
{
  uint64_t v4 = malloc_type_malloc(0x10uLL, 0x566C45D1uLL);
  __CFSetLastAllocationEventName();
  if (v4)
  {
    if (a1) {
      CFTypeRef v5 = CFRetain(a1);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *uint64_t v4 = v5;
    v4[1] = a2;
  }
  return v4;
}

uint64_t *__color_space_state_create_generic_rgb_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFMutableSetRef result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (CFMutableSetRef result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncGenericRGBProfile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_generic_rgb_s = v1;
  return result;
}

uint64_t (*__color_space_state_create_generic_rgb_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFMutableSetRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CFMutableSetRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_generic_rgb_f = v1;
  return result;
}

uint64_t CGImageTextureDataCreate(uint64_t a1, const void *a2, uint64_t a3, _OWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  if (a2 && a4)
  {
    if (_block_invoke_once_8946 != -1) {
      dispatch_once(&_block_invoke_once_8946, &__block_literal_global_33);
    }
    uint64_t Instance = CGTypeCreateInstance(CGImageTextureDataGetTypeID_texture_data_type_id, 128, a3, (uint64_t)a4, a5, a6, a7, a8);
    uint64_t v8 = Instance;
    if (Instance)
    {
      *(void *)(Instance + 24) = a3;
      *(void *)(Instance + 16) = CFRetain(a2);
      long long v13 = a4[1];
      *(_OWORD *)(v8 + 32) = *a4;
      *(_OWORD *)(v8 + 48) = v13;
      uint64_t v26 = 0;
      uint64_t valuePtr = 0;
      *(_OWORD *)(v8 + 72) = 0u;
      *(_OWORD *)(v8 + 88) = 0u;
      *(_OWORD *)(v8 + 104) = 0u;
      *(_OWORD *)(v8 + 120) = 0u;
      *(_WORD *)(v8 + 136) = 0;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"width");
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberLongType, &valuePtr);
        *(double *)(v8 + 72) = (double)valuePtr;
      }
      CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"height");
      if (v15)
      {
        CFNumberGetValue(v15, kCFNumberLongType, &valuePtr);
        *(double *)(v8 + 80) = (double)valuePtr;
      }
      CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"rowBytes");
      if (v16)
      {
        CFNumberGetValue(v16, kCFNumberLongType, &valuePtr);
        *(void *)(v8 + 88) = valuePtr;
      }
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"mipmapLevelCount");
      if (v17)
      {
        CFNumberGetValue(v17, kCFNumberLongType, &valuePtr);
        *(void *)(v8 + 120) = valuePtr;
      }
      CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"faceCount");
      if (v18)
      {
        CFNumberGetValue(v18, kCFNumberLongType, &valuePtr);
        *(void *)(v8 + 128) = valuePtr;
      }
      double v19 = CFDictionaryGetValue((CFDictionaryRef)a2, @"colorSpace");
      if (v19) {
        *(void *)(v8 + 96) = CFRetain(v19);
      }
      CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"pixelFormatMetal");
      if (v20)
      {
        CFNumberGetValue(v20, kCFNumberSInt64Type, &v26);
        *(void *)(v8 + 104) = v26;
      }
      CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"pixelFormatGL");
      if (v21)
      {
        CFNumberGetValue(v21, kCFNumberSInt64Type, &v26);
        *(void *)(v8 + 112) = v26;
      }
      double v22 = CFDictionaryGetValue((CFDictionaryRef)a2, @"isCompressed");
      uint64_t v23 = (const void **)MEMORY[0x1E4F1CFD0];
      if (v22) {
        *(unsigned char *)(v8 + 136) = v22 == (const void *)*MEMORY[0x1E4F1CFD0];
      }
      char v24 = CFDictionaryGetValue((CFDictionaryRef)a2, @"supportsTiledLayout");
      if (v24) {
        *(unsigned char *)(v8 + 137) = v24 == *v23;
      }
    }
  }
  return v8;
}

uint64_t CGContextGetShouldDrawBitmapRuns(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return (**(unsigned __int16 **)(*(void *)(a1 + 96) + 136) >> 7) & 1;
  }
  handle_invalid_context((char)"CGContextGetShouldDrawBitmapRuns", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  __double2 v6 = __sincos_stret(angle);
  float64x2_t v7 = *(float64x2_t *)&t->a;
  float64x2_t v8 = *(float64x2_t *)&t->c;
  float64x2_t v9 = *(float64x2_t *)&t->tx;
  float64x2_t v10 = vmlsq_lane_f64(vmulq_n_f64(v8, v6.__cosval), *(float64x2_t *)&t->a, v6.__sinval, 0);
  *(float64x2_t *)&retstr->double a = vmlaq_n_f64(vmulq_n_f64(v8, v6.__sinval), *(float64x2_t *)&t->a, v6.__cosval);
  *(float64x2_t *)&retstr->double c = v10;
  *(float64x2_t *)&retstr->tfloat64x2_t x = vaddq_f64(v9, vmlaq_f64(vmulq_f64(v8, (float64x2_t)0), (float64x2_t)0, v7));
  return result;
}

void CGContextSetOwnerIdentity(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v9 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextSetOwnerIdentity", v9, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v9 = a1;
    goto LABEL_7;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8) {
    *(_DWORD *)(v8 + 280) = a2;
  }
}

uint64_t __get_cache_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  get_cache_image_cache = (uint64_t)malloc_type_calloc(1uLL, 0x48uLL, 0x1020040C6685353uLL);
  if (!get_cache_image_cache) {
    _CGHandleAssert("get_cache_block_invoke", 159, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPImageCache.c", "image_cache != NULL", "NULL image cache", v0, v1, v2, v7.version);
  }
  v8.__sig = 0;
  *(void *)v8.__opaque = 0;
  pthread_mutexattr_init(&v8);
  pthread_mutexattr_settype(&v8, 2);
  pthread_mutex_init((pthread_mutex_t *)get_cache_image_cache, &v8);
  pthread_mutexattr_destroy(&v8);
  cache_attributes_t v7 = *(cache_attributes_t *)byte_1ED09A5A0;
  if (cache_create("com.apple.CoreGraphics.image_handle_cache", &v7, (cache_t **)(get_cache_image_cache + 64))) {
    _CGHandleAssert("get_cache_block_invoke", 180, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPImageCache.c", "cache_create(\"com.apple.CoreGraphics.image_handle_cache\", &attrs, &image_cache->cache) == 0", "cache creation failed", v3, v4, v5, v7.version);
  }
  return cache_set_count_hint();
}

uint64_t CGGradientGetColorSpace(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

void CGFontRelease(CGFontRef font)
{
  if (font) {
    CFRelease(font);
  }
}

CGInterpolationQuality CGContextGetInterpolationQuality(CGContextRef c)
{
  if (c && *((_DWORD *)c + 4) == 1129601108) {
    return *(char *)(*(void *)(*((void *)c + 12) + 120) + 4);
  }
  handle_invalid_context((char)"CGContextGetInterpolationQuality", (uint64_t)c, v1, v2, v3, v4, v5, v6);
  return 0;
}

uint64_t img_blocks_extent(void *a1, int *a2)
{
  if (a1[23]) {
    return 0;
  }
  uint64_t v5 = (int *)a1[19];
  v9[0] = 0;
  v9[1] = 0;
  if (v5)
  {
    if (a2)
    {
      int v6 = CGSBoundsIntersection(a2, v5, v9);
      a2 = (int *)v9;
      if (!v6) {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      a2 = v5;
    }
  }
  cache_attributes_t v7 = img_blocks_create(a1[18], 0, a2, 0);
  if (v7)
  {
    pthread_mutexattr_t v8 = v7;
    uint64_t result = 0;
    a1[23] = v8;
    a1[11] = 0;
    return result;
  }
  return 0xFFFFFFFFLL;
}

void *img_blocks_create(uint64_t a1, CGFloat *a2, int *a3, uint64_t a4)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = a4;
  cache_attributes_t v7 = a2 + 1;
  pthread_mutexattr_t v8 = (CGFloat *)(a1 + 16);
  if (a2) {
    pthread_mutexattr_t v8 = a2;
  }
  else {
    cache_attributes_t v7 = (CGFloat *)(a1 + 24);
  }
  double v9 = *v7;
  double v10 = *v8;
  if (!a3)
  {
    if (!a4) {
      goto LABEL_13;
    }
LABEL_9:
    if (img_blocks_options_predicate != -1) {
      dispatch_once(&img_blocks_options_predicate, &__block_literal_global_64_11897);
    }
    if (img_blocks_options_options_singleton)
    {
      uint64_t v11 = CGImageProviderCopyImageBlockSetWithOptions(a1, img_blocks_options_options_singleton);
      if (v11) {
        goto LABEL_14;
      }
    }
    goto LABEL_13;
  }
  v49.origin.float64x2_t x = (double)*a3;
  v49.origin.CGFloat y = (double)a3[1];
  v49.size.CGFloat width = (double)a3[2];
  v49.size.CGFloat height = (double)a3[3];
  v47.origin.float64x2_t x = 0.0;
  v47.origin.CGFloat y = 0.0;
  v47.size.CGFloat width = *v8;
  v47.size.CGFloat height = *v7;
  CGRectIntersection(v47, v49);
  if (v4) {
    goto LABEL_9;
  }
LABEL_13:
  uint64_t v11 = CGImageProviderCopyImageBlockSetWithOptions(a1, 0);
  uint64_t v4 = 0;
  __int16 v12 = 0;
  if (!v11) {
    return v12;
  }
LABEL_14:
  uint64_t v13 = *(void *)(v11 + 120);
  if (!v13)
  {
    CGImageBlockSetRelease(v11);
    uint64_t v43 = "%s: Assertion failed - empty image block set ";
LABEL_47:
    CGPostError((uint64_t)v43, v36, v37, v38, v39, v40, v41, v42, (char)"img_blocks_create");
    return 0;
  }
  int v14 = malloc_type_malloc(32 * v13 + 96, 0x8C10942CuLL);
  if (!v14)
  {
    CGImageBlockSetRelease(v11);
    uint64_t v43 = "%s: Cannot allocate memory";
    goto LABEL_47;
  }
  __int16 v12 = v14;
  *int v14 = v11;
  v14[1] = v4;
  v14[4] = *(void *)(v11 + 72);
  if (a2)
  {
    double v9 = *(double *)(v11 + 24);
    double v10 = *(double *)(v11 + 16);
  }
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  _OWORD v14[2] = (int)vcvtpd_s64_f64(v10);
  __n128 v14[3] = (int)vcvtpd_s64_f64(v9);
  unint64_t v45 = v14 + 7;
  uint64_t v21 = (uint64_t)&v14[2 * v13 + 12];
  v14[8] = 0;
  v14[9] = v14 + 12;
  v14[10] = v21;
  v14[11] = v21 + 8 * v13;
  unsigned int v46 = vcvtpd_s64_f64(*(double *)(v11 + 48));
  do
  {
    if (*(void *)(v11 + 120) <= v18 || (uint64_t v22 = *(void *)(v11 + 8 * v18 + 128)) == 0)
    {
      uint64_t v29 = a1;
      uint64_t v30 = v11;
      uint64_t v31 = v18;
      uint64_t v32 = 0;
      uint64_t v33 = "Null block";
      goto LABEL_27;
    }
    uint64_t v23 = *(void *)v22;
    *(void *)(v12[10] + 8 * v19) = *(void *)v22;
    if (!v23)
    {
      uint64_t v29 = a1;
      uint64_t v30 = v11;
      uint64_t v31 = v18;
      uint64_t v32 = v22;
      uint64_t v33 = "Null data pointer";
      goto LABEL_27;
    }
    char v24 = (unint64_t *)(v12[9] + 16 * v19);
    CGRect v48 = CGRectIntegral(*(CGRect *)(v22 + 8));
    *char v24 = (int)v48.origin.x | ((unint64_t)(int)v48.origin.y << 32);
    v24[1] = (int)v48.size.width | ((unint64_t)(int)v48.size.height << 32);
    size_t v25 = (_OWORD *)v12[9];
    uint64_t v26 = &v25[v19];
    uint64_t v27 = *((int *)v26 + 2);
    if ((v27 & 0x80000000) != 0 || (*((_DWORD *)v26 + 3) & 0x80000000) != 0)
    {
      uint64_t v29 = a1;
      uint64_t v30 = v11;
      uint64_t v31 = v18;
      uint64_t v32 = v22;
      uint64_t v33 = "Invalid size";
      goto LABEL_27;
    }
    unint64_t v28 = *(void *)(v22 + 40);
    *(void *)(v12[11] + 8 * v19) = v28;
    if (v28 < v12[4] * v27)
    {
      uint64_t v29 = a1;
      uint64_t v30 = v11;
      uint64_t v31 = v18;
      uint64_t v32 = v22;
      uint64_t v33 = "Invalid bytes-per-row";
LABEL_27:
      img_blocks_error(v29, v30, v31, v32, (uint64_t)v33, v15, v16, v17);
      goto LABEL_28;
    }
    if ((int)v27 >= 0 && v27 >= v46) {
      ++v20;
    }
    if (v19)
    {
      v12[7] = CGSBoundsUnion(v12[7], v12[8], *(void *)&v25[v19], *((void *)&v25[v19] + 1));
      v12[8] = v35;
    }
    else
    {
      *unint64_t v45 = *v25;
    }
    ++v19;
LABEL_28:
    ++v18;
  }
  while (v13 != v18);
  v12[5] = v19;
  v12[6] = v20;
  if (!v19 || *((int *)v12 + 16) < 1 || *((int *)v12 + 17) <= 0)
  {
    CGImageBlockSetRelease(v11);
    free(v12);
    uint64_t v43 = "%s: Assertion failed - image block set contains no usable blocks";
    goto LABEL_47;
  }
  return v12;
}

uint64_t (*__colorspace_with_name_from_icc_data_block_invoke_4())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncVerifyDisplayP3");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  colorspace_with_name_from_icc_data_f_89 = (uint64_t (*)(void))v1;
  return result;
}

uint64_t (*__colorspace_with_name_from_icc_data_block_invoke_3())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncVerifyGenericGrayGamma2_2");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  colorspace_with_name_from_icc_data_f_83 = (uint64_t (*)(void))v1;
  return result;
}

uint64_t (*__colorspace_with_name_from_icc_data_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileContainsTag");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  colorspace_with_name_from_icc_data_f_78 = (uint64_t (*)(void, void))v1;
  return result;
}

uint64_t (*__colorspace_with_name_from_icc_data_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreate");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  colorspace_with_name_from_icc_data_f = (uint64_t (*)(void, void))v1;
  return result;
}

CGPatternRef CGPatternCreateWithImage2(unint64_t *cf, _OWORD *a2, CGPatternTiling a3)
{
  if (cf)
  {
    double v6 = (double)cf[5];
    double v7 = (double)cf[6];
    BOOL v8 = (*((_DWORD *)cf + 9) & 0x2000000) == 0;
    CFRetain(cf);
  }
  else
  {
    double v6 = 0.0;
    BOOL v8 = 1;
    double v7 = 0.0;
  }
  long long v9 = a2[1];
  *(_OWORD *)&v15.double a = *a2;
  *(_OWORD *)&v15.double c = v9;
  *(_OWORD *)&v15.tfloat64x2_t x = a2[2];
  uint64_t v10 = 0;
  *(void *)&long long v9 = 0;
  double v11 = v6;
  double v12 = v7;
  CGPatternRef result = CGPatternCreate(cf, *(CGRect *)((char *)&v9 - 8), &v15, v6, v7, a3, v8, &image_callbacks_18117);
  if (cf) {
    BOOL v14 = (*((unsigned char *)cf + 39) & 0xE) == 0;
  }
  else {
    BOOL v14 = 0;
  }
  *((unsigned char *)result + 186) = v14;
  *((unsigned char *)result + 184) = 1;
  return result;
}

CGPatternRef CGPatternCreate(void *info, CGRect bounds, CGAffineTransform *matrix, CGFloat xStep, CGFloat yStep, CGPatternTiling tiling, BOOL isColored, const CGPatternCallbacks *callbacks)
{
  if (!callbacks) {
    return 0;
  }
  CGFloat height = bounds.size.height;
  CGFloat width = bounds.size.width;
  CGFloat y = bounds.origin.y;
  CGFloat x = bounds.origin.x;
  if (kCGPatternWillDeallocate_block_invoke_once != -1) {
    dispatch_once(&kCGPatternWillDeallocate_block_invoke_once, &__block_literal_global_6_18100);
  }
  uint64_t Instance = CGTypeCreateInstance(CGPatternGetTypeID_pattern_type_id, 176, *(uint64_t *)&tiling, isColored, (uint64_t)callbacks, v8, v9, v10);
  uint64_t v23 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = atomic_fetch_add_explicit(identifier_18101, 1u, memory_order_relaxed) + 1;
    long long v24 = *(_OWORD *)&matrix->a;
    long long v25 = *(_OWORD *)&matrix->c;
    *(_OWORD *)(Instance + 56) = *(_OWORD *)&matrix->tx;
    *(_OWORD *)(Instance + 40) = v25;
    *(_OWORD *)(Instance + 24) = v24;
    *(unsigned char *)(Instance + 72) = 1;
    *(unsigned char *)(Instance + 184) = 0;
    *(void *)(Instance + 80) = info;
    *(CGFloat *)&long long v24 = x;
    *(CGFloat *)&long long v25 = y;
    CGFloat v26 = width;
    CGFloat v27 = height;
    *(CGRect *)(Instance + 104) = CGRectStandardize(*(CGRect *)&v24);
    *(double *)(v23 + 136) = fabs(xStep);
    *(double *)(v23 + 144) = fabs(yStep);
    *(_DWORD *)(v23 + 152) = tiling;
    *(unsigned char *)(v23 + 185) = isColored;
    *(unsigned char *)(v23 + 186) = 0;
    CGPatternReleaseInfoCallback releaseInfo = callbacks->releaseInfo;
    *(_OWORD *)(v23 + 160) = *(_OWORD *)&callbacks->version;
    *(void *)(v23 + 176) = releaseInfo;
    *(void *)(v23 + 88) = 0;
    *(void *)(v23 + 96) = 0;
  }
  return (CGPatternRef)v23;
}

void __CGColorSyncTransformCacheGetRetained_block_invoke()
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = getenv("CGCOLORCONVERSIONINFO_PLIST_PATH");
  if (!v0
    || (CFStringRef v1 = CFStringCreateWithCString(0, v0, 0x8000100u),
        (CFURLRef v2 = CFURLCreateWithFileSystemPath(0, v1, kCFURLPOSIXPathStyle, 0)) == 0))
  {
    MainBundleIfLooksLikeBundle = (__CFBundle *)_CFBundleGetMainBundleIfLooksLikeBundle();
    if (MainBundleIfLooksLikeBundle
      && (CFURLRef v4 = CFBundleCopyBundleURL(MainBundleIfLooksLikeBundle)) != 0
      && (CFURLRef v5 = CFURLCreateWithString(0, @"Contents/Resources/CGColorConversionInfoOptions.plist", v4)) != 0)
    {
      CFURLRef v6 = v5;
      CFURLRef v2 = CFURLCopyAbsoluteURL(v5);
      CFRelease(v6);
    }
    else
    {
      CFURLRef v2 = 0;
    }
  }
  bzero(buffer, 0x401uLL);
  if (!CFURLGetFileSystemRepresentation(v2, 0, buffer, 1025)
    || (int v7 = open((const char *)buffer, 0, 0), v7 == -1)
    || (int v8 = v7, memset(&v20, 0, sizeof(v20)), v9 = fstat(v7, &v20), close(v8), v9 == -1))
  {
    if (!v2) {
      return;
    }
    goto LABEL_19;
  }
  if (v2)
  {
    uint64_t v10 = CFReadStreamCreateWithFile(0, v2);
    if (v10)
    {
      CFURLRef v2 = v10;
      CFReadStreamOpen(v10);
      *(void *)&v20.st_dev = 0;
      CFPropertyListRef v11 = CFPropertyListCreateWithStream(0, v2, 0, 0, 0, (CFErrorRef *)&v20);
      if (*(void *)&v20.st_dev)
      {
        CFStringRef v12 = CFCopyDescription(*(CFTypeRef *)&v20.st_dev);
        CGLog(2, (uint64_t)"Reading %s failed: %@", v13, v14, v15, v16, v17, v18, (char)buffer);
        if (v12) {
          CFRelease(v12);
        }
        CFRelease(*(CFTypeRef *)&v20.st_dev);
        if (!v11) {
          goto LABEL_25;
        }
      }
      else
      {
        if (!v11)
        {
LABEL_25:
          CFReadStreamClose(v2);
LABEL_19:
          CFRelease(v2);
          return;
        }
        CFTypeID v19 = CFGetTypeID(v11);
        if (v19 == CFDictionaryGetTypeID()) {
          CGColorSyncTransformCacheGetRetained_bundle_options = (uint64_t)CFRetain(v11);
        }
      }
      CFRelease(v11);
      goto LABEL_25;
    }
  }
}

CGColorRef CGColorCreateWithPattern(CGColorSpaceRef space, CGPatternRef pattern, const CGFloat *components)
{
  color = 0;
  if (pattern && space && components)
  {
    if (CGColorSpaceGetType(space) == 9)
    {
      uint64_t v14 = *(void *)(*((void *)space + 3) + 48);
      if (*((unsigned char *)pattern + 185) && v14)
      {
        CGPostError((uint64_t)"Invalid color: colored pattern specified with uncolored pattern color space.", v7, v8, v9, v10, v11, v12, v13, v23);
        CGColorSpaceRef v15 = CGColorSpaceCreatePattern(0);
        color = create_color(v15, components);
        uint64_t v16 = v15;
      }
      else
      {
        if (*((unsigned char *)pattern + 185) || v14)
        {
          color = create_color(space, components);
          if (!color) {
            return (CGColorRef)color;
          }
          goto LABEL_19;
        }
        CGPostError((uint64_t)"Invalid color: uncolored pattern specified with colored pattern color space.", v7, v8, v9, v10, v11, v12, v13, v23);
        DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
        uint64_t v18 = DeviceGray;
        if (DeviceGray && (uint64_t v19 = *((void *)DeviceGray + 3)) != 0) {
          stat v20 = *(const void **)(v19 + 40);
        }
        else {
          stat v20 = 0;
        }
        CGColorSpaceRef v21 = CGColorSpaceCreatePattern(DeviceGray);
        color = create_color(v21, v20);
        CGColorSpaceRelease(v21);
        uint64_t v16 = v18;
      }
      CGColorSpaceRelease(v16);
      if (color)
      {
LABEL_19:
        CFRetain(pattern);
        *((void *)color + 4) = pattern;
      }
    }
    else
    {
      return 0;
    }
  }
  return (CGColorRef)color;
}

uint64_t (*__colorspace_with_name_from_icc_data_block_invoke_5())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CGPatternRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CGPatternRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncVerifySRGB");
  }
  if (result) {
    CFStringRef v1 = result;
  }
  else {
    CFStringRef v1 = colorsync_smart_null_7440;
  }
  colorspace_with_name_from_icc_data_f_95 = (uint64_t (*)(void))v1;
  return result;
}

uint64_t CGColorTRCPureGammaOriginal(uint64_t a1)
{
  if (CGColorTRCPureGammaOriginal_cglibrarypredicate != -1) {
    dispatch_once(&CGColorTRCPureGammaOriginal_cglibrarypredicate, &__block_literal_global_12);
  }
  CFURLRef v2 = (uint64_t (*)(uint64_t))CGColorTRCPureGammaOriginal_f;

  return v2(a1);
}

const void *___ZL27use_vImage_fp16_compositingv_block_invoke()
{
  return get_BOOLean_property("USE_VIMAGE_FP16_COMPOSITING", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&use_vImage_fp16_compositing(void)::status);
}

uint64_t W8_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v555 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(char **)(v3 + 96);
  uint64_t v8 = *(void *)(v3 + 48);
  int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                 + 16 * *(_DWORD *)v3
                 + 8 * (v7 == 0)
                 + 4 * (v8 == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v3;
  unint64_t v12 = *(unsigned int *)(v3 + 4);
  uint64_t v13 = (v12 - 1);
  if ((int)v12 < 1) {
    return 0;
  }
  int v14 = *(_DWORD *)(v3 + 8);
  uint64_t v15 = (v14 - 1);
  if (v14 < 1) {
    return 0;
  }
  uint64_t v16 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v16)
  {
    int v18 = *(_DWORD *)v3 & 0xFF00;
    uint64_t v512 = v3;
    int v513 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                     + 16 * *(_DWORD *)v3
                     + 8 * (v7 == 0)
                     + 4 * (v8 == 0));
    if (v18 == 1024)
    {
      v554[0] = *(_DWORD *)(v3 + 4);
      v544[0] = v14;
      uint64_t v19 = *(int *)(v3 + 28);
      if (v7) {
        unsigned int v20 = *v7;
      }
      else {
        unsigned int v20 = 255;
      }
      unsigned int v32 = **(unsigned __int8 **)(v3 + 88);
      uint64_t v34 = *(int *)(v3 + 12);
      int v33 = *(_DWORD *)(v3 + 16);
      if (v8)
      {
        uint64_t v539 = *(int *)(v3 + 32);
        int v537 = (char *)(v8 + v34 + (int)v539 * (uint64_t)v33);
        unsigned int v529 = 1;
      }
      else
      {
        int v537 = 0;
        uint64_t v539 = 0;
        unsigned int v529 = 0;
      }
      unsigned int v525 = v20 << 24;
      unsigned __int8 v527 = ~(_BYTE)v20;
      uint64_t v40 = (char *)(*(void *)(v3 + 40) + v34 + v33 * (uint64_t)(int)v19);
      *(void *)int v531 = *(int *)(v3 + 28);
      int v535 = v40;
      if (!v16)
      {
        unint64_t v541 = 0;
        if (v8) {
          unint64_t v44 = v12;
        }
        else {
          unint64_t v44 = 0;
        }
        uint64_t v42 = v537;
        uint64_t v43 = v539 - v44;
        unint64_t v45 = v12;
        goto LABEL_906;
      }
      shape_enum_clip_alloc(v2, v3, (int *)v16, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
      uint64_t v42 = v537;
      uint64_t v43 = v539;
      if (!v41) {
        return 1;
      }
      while (1)
      {
        unint64_t v541 = (void *)v41;
        if (!shape_enum_clip_next(v41, (int *)&v543 + 1, &v543, v554, v544)) {
          break;
        }
        v40 += (int)v543 * (uint64_t)(int)v19 + SHIDWORD(v543);
        unint64_t v45 = v554[0];
        if (v8)
        {
          uint64_t v42 = &v537[(int)v539 * (uint64_t)(int)v543 + SHIDWORD(v543)];
          uint64_t v43 = v539 - v554[0];
        }
        LODWORD(v12) = v554[0];
LABEL_906:
        v19 -= v45;
        switch(v9)
        {
          case 0:
            uint64_t v385 = v19 + (int)v12;
            int v386 = v544[0];
            uint64_t v387 = v544[0] - 1;
            if (v385 >= 0) {
              LODWORD(v388) = v385;
            }
            else {
              uint64_t v388 = -v385;
            }
            CGBlt_fillBytes(v12, v544[0], 0, &v40[(v385 * v387) & (v385 >> 63)], v388);
            if (!v8) {
              goto LABEL_1157;
            }
            uint64_t v389 = v43 + (int)v12;
            v42 += (v389 * v387) & (v389 >> 63);
            if (v389 >= 0) {
              v43 += (int)v12;
            }
            else {
              uint64_t v43 = -v389;
            }
            int v390 = v12;
            unsigned int v391 = v386;
            int v392 = 0;
            goto LABEL_926;
          case 1:
            uint64_t v393 = v19 + (int)v12;
            if (v393 < 0)
            {
              v40 += v393 * (v544[0] - 1);
              uint64_t v393 = -v393;
            }
            int v394 = 0;
            float64x2_t v395 = *(int **)(v512 + 88);
            if (v395) {
              int v394 = *v395;
            }
            int v396 = v544[0];
            CGBlt_fillBytes(v12, v544[0], v394, v40, v393);
            if (v8)
            {
              unsigned int v391 = v396;
              uint64_t v397 = *(int **)(v512 + 96);
              if (!v397) {
                uint64_t v397 = (int *)&PIXELALPHAPLANARCONSTANT_17534;
              }
              v42 += ((v43 + (int)v12) * (v396 - 1)) & ((v43 + (int)v12) >> 63);
              if (v43 + (int)v12 >= 0) {
                v43 += (int)v12;
              }
              else {
                uint64_t v43 = -(v43 + (int)v12);
              }
              int v392 = *v397;
              int v390 = v12;
LABEL_926:
              CGBlt_fillBytes(v390, v391, v392, v42, v43);
            }
            goto LABEL_1157;
          case 2:
            if (v8)
            {
              int v398 = v525 | v32;
              do
              {
                int v399 = v554[0];
                if (v554[0] >= 4)
                {
                  unsigned int v400 = (v554[0] >> 2) + 1;
                  do
                  {
                    unsigned int v401 = (*v40 | (*v42 << 16)) * v527;
                    unsigned int v402 = ((v401 + 65537 + ((v401 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v401 + 1 + BYTE1(v401)) >> 8))
                         + v398;
                    *uint64_t v40 = v402;
                    *uint64_t v42 = HIBYTE(v402);
                    unsigned int v403 = (v40[1] | (v42[1] << 16)) * v527;
                    unsigned int v404 = ((v403 + 65537 + ((v403 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v403 + 1 + BYTE1(v403)) >> 8))
                         + v398;
                    v40[1] = v404;
                    v42[1] = HIBYTE(v404);
                    unsigned int v405 = (v40[2] | (v42[2] << 16)) * v527;
                    unsigned int v406 = ((v405 + 65537 + ((v405 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v405 + 1 + BYTE1(v405)) >> 8))
                         + v398;
                    v40[2] = v406;
                    _OWORD v42[2] = HIBYTE(v406);
                    unsigned int v407 = (v40[3] | (v42[3] << 16)) * v527;
                    v40[3] = ((unsigned __int16)(v407 + 1 + BYTE1(v407)) >> 8) + v398;
                    v42[3] = (((v407 + 65537 + ((v407 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v407 + 1 + BYTE1(v407)) >> 8))
                            + v398) >> 24;
                    v40 += 4;
                    v42 += 4 * v529;
                    --v400;
                  }
                  while (v400 > 1);
                  int v399 = v554[0] & 3;
                }
                if (v399 >= 1)
                {
                  unsigned int v408 = v399 + 1;
                  do
                  {
                    unsigned int v409 = (*v40 | (*v42 << 16)) * v527;
                    *v40++ = ((unsigned __int16)(v409 + 1 + BYTE1(v409)) >> 8) + v398;
                    *uint64_t v42 = (((v409 + 65537 + ((v409 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v409 + 1 + BYTE1(v409)) >> 8))
                          + v398) >> 24;
                    v42 += v529;
                    --v408;
                  }
                  while (v408 > 1);
                }
                v40 += v19;
                v42 += v43;
                --v544[0];
              }
              while (v544[0]);
            }
            else
            {
              uint16x4_t v484 = (uint16x4_t)vdup_n_s16(v32);
              uint16x4_t v485 = (uint16x4_t)vdup_n_s16(v527);
              do
              {
                int v486 = v554[0];
                if (v554[0] >= 4)
                {
                  unsigned int v487 = (v554[0] >> 2) + 1;
                  do
                  {
                    v5.i32[0] = *(_DWORD *)v40;
                    uint32x4_t v488 = vmull_u16(v485, (uint16x4_t)*(_OWORD *)&vmovl_u8(v5));
                    *(uint16x4_t *)v6.i8 = vsra_n_u16(v484, (uint16x4_t)vadd_s16(vmovn_s32((int32x4_t)vsraq_n_u32(v488, v488, 8uLL)), (int16x4_t)0x1000100010001), 8uLL);
                    uint8x8_t v5 = (uint8x8_t)vmovn_s16(v6);
                    *(_DWORD *)uint64_t v40 = v5.i32[0];
                    v40 += 4;
                    v42 += 4 * v529;
                    --v487;
                  }
                  while (v487 > 1);
                  int v486 = v554[0] & 3;
                }
                if (v486 >= 1)
                {
                  unsigned int v489 = v486 + 1;
                  do
                  {
                    *uint64_t v40 = v32
                         + ((unsigned __int16)(*v40 * v527
                                             + ((*v40 * v527) >> 8)
                                             + 1) >> 8);
                    ++v40;
                    --v489;
                  }
                  while (v489 > 1);
                  v42 += v486 * v529;
                }
                v40 += v19;
                v42 += v43;
                --v544[0];
              }
              while (v544[0]);
            }
            goto LABEL_1157;
          case 3:
            int v410 = v525 | v32;
            do
            {
              int v411 = v554[0];
              do
              {
                unsigned int v412 = *v42;
                if (v412 == 255)
                {
                  *uint64_t v40 = v32;
                  LOBYTE(v412) = v20;
                }
                else if (*v42)
                {
                  unsigned int v413 = (v32 | (v20 << 16)) * (v412 ^ 0xFF)
                       + 65537
                       + ((((v32 | (v20 << 16)) * (v412 ^ 0xFF)) >> 8) & 0xFF00FF);
                  *uint64_t v40 = v410 - BYTE1(v413);
                  unsigned int v412 = (v410 - (v413 & 0xFF000000 | BYTE1(v413))) >> 24;
                }
                else
                {
                  *uint64_t v40 = 0;
                }
                *uint64_t v42 = v412;
                ++v40;
                v42 += v529;
                --v411;
              }
              while (v411);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_1157;
          case 4:
            int v414 = v525 | v32;
            do
            {
              int v415 = v554[0];
              do
              {
                int v416 = *v42;
                if ((v416 ^ 0xFF) == 0xFF)
                {
                  *uint64_t v40 = v32;
                  LOBYTE(v417) = v20;
                }
                else if (v416 != 0xFF)
                {
                  unsigned int v418 = (v32 | (v20 << 16)) * v416 + 65537 + ((((v32 | (v20 << 16)) * v416) >> 8) & 0xFF00FF);
                  *uint64_t v40 = v414 - BYTE1(v418);
                  unsigned int v417 = (v414 - (v418 & 0xFF000000 | BYTE1(v418))) >> 24;
                }
                else
                {
                  LOBYTE(v417) = 0;
                  *uint64_t v40 = 0;
                }
                *uint64_t v42 = v417;
                ++v40;
                v42 += v529;
                --v415;
              }
              while (v415);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_1157;
          case 5:
            do
            {
              int v419 = v554[0];
              do
              {
                unsigned int v420 = (v32 | (v20 << 16)) * *v42
                     + (*v40 | (*v42 << 16)) * v527;
                int v421 = v420 + 65537 + ((v420 >> 8) & 0xFF00FF);
                *v40++ = BYTE1(v421);
                *uint64_t v42 = HIBYTE(v421);
                v42 += v529;
                --v419;
              }
              while (v419);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_1157;
          case 6:
            do
            {
              int v422 = v554[0];
              do
              {
                int v423 = *v42;
                if ((_BYTE)v423 != 0xFF)
                {
                  if (~(_BYTE)v423 == 255)
                  {
                    *uint64_t v40 = v32;
                    LOBYTE(v424) = v20;
                  }
                  else
                  {
                    unsigned int v425 = (v32 | (v20 << 16)) * ~(_BYTE)v423
                         + 65537
                         + ((((v32 | (v20 << 16)) * ~(_BYTE)v423) >> 8) & 0xFF00FF);
                    unsigned int v426 = (*v40 | (v423 << 24)) + (v425 & 0xFF000000 | BYTE1(v425));
                    *uint64_t v40 = v426;
                    unsigned int v424 = HIBYTE(v426);
                  }
                  *uint64_t v42 = v424;
                }
                ++v40;
                v42 += v529;
                --v422;
              }
              while (v422);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_1157;
          case 7:
            if (v8)
            {
              do
              {
                int v427 = v554[0];
                do
                {
                  int v428 = *v40;
                  int v429 = *v42;
                  unsigned int v430 = (v428 | (v429 << 16)) * v527
                       + 65537
                       + ((((v428 | (v429 << 16)) * v527) >> 8) & 0xFF00FF);
                  unsigned int v431 = (v428 | (v429 << 24)) - (v430 & 0xFF000000 | BYTE1(v430));
                  *v40++ = v431;
                  *uint64_t v42 = HIBYTE(v431);
                  v42 += v529;
                  --v427;
                }
                while (v427);
                v40 += v19;
                v42 += v43;
                --v544[0];
              }
              while (v544[0]);
            }
            else
            {
              do
              {
                int v432 = v554[0];
                unsigned int v433 = v554[0] - 1;
                do
                {
                  *v40 -= (unsigned __int16)(*v40 * v527
                                           + ((*v40 * v527) >> 8)
                                           + 1) >> 8;
                  ++v40;
                  --v432;
                }
                while (v432);
                v40 += v19;
                v42 += v43 + v529 + v529 * (unint64_t)v433;
                --v544[0];
              }
              while (v544[0]);
            }
            goto LABEL_1157;
          case 8:
            if (v8)
            {
              do
              {
                int v434 = v554[0];
                do
                {
                  int v435 = *v40;
                  int v436 = *v42;
                  unsigned int v437 = (v435 | (v436 << 16)) * v20 + 65537 + ((((v435 | (v436 << 16)) * v20) >> 8) & 0xFF00FF);
                  unsigned int v438 = (v435 | (v436 << 24)) - (v437 & 0xFF000000 | BYTE1(v437));
                  *v40++ = v438;
                  *uint64_t v42 = HIBYTE(v438);
                  v42 += v529;
                  --v434;
                }
                while (v434);
                v40 += v19;
                v42 += v43;
                --v544[0];
              }
              while (v544[0]);
            }
            else
            {
              do
              {
                int v439 = v554[0];
                unsigned int v440 = v554[0] - 1;
                do
                {
                  *v40 -= (unsigned __int16)(*v40 * (_WORD)v20
                                           + ((*v40 * v20) >> 8)
                                           + 1) >> 8;
                  ++v40;
                  --v439;
                }
                while (v439);
                v40 += v19;
                v42 += v43 + v529 + v529 * (unint64_t)v440;
                --v544[0];
              }
              while (v544[0]);
            }
            goto LABEL_1157;
          case 9:
            do
            {
              int v441 = v554[0];
              do
              {
                unsigned int v442 = (v32 | (v20 << 16)) * (*v42 ^ 0xFF)
                     + (*v40 | (*v42 << 16)) * v20;
                int v443 = v442 + 65537 + ((v442 >> 8) & 0xFF00FF);
                *v40++ = BYTE1(v443);
                *uint64_t v42 = HIBYTE(v443);
                v42 += v529;
                --v441;
              }
              while (v441);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_1157;
          case 10:
            do
            {
              int v444 = v554[0];
              do
              {
                unsigned int v445 = (v32 | (v20 << 16)) * (*v42 ^ 0xFF)
                     + (*v40 | (*v42 << 16)) * v527;
                int v446 = v445 + 65537 + ((v445 >> 8) & 0xFF00FF);
                *v40++ = BYTE1(v446);
                *uint64_t v42 = HIBYTE(v446);
                v42 += v529;
                --v444;
              }
              while (v444);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_1157;
          case 11:
            __int16 v447 = v20 - v32;
            if (v8)
            {
              do
              {
                int v448 = v554[0];
                do
                {
                  unsigned int v449 = ((v20 - v32) | (v20 << 16))
                       + (*v42 - *v40)
                       + (*v42 << 16);
                  int v450 = (255 * ((v449 >> 8) & 0x10001)) | v449;
                  *v40++ = BYTE2(v450) - v450;
                  *uint64_t v42 = BYTE2(v450);
                  v42 += v529;
                  --v448;
                }
                while (v448);
                v40 += v19;
                v42 += v43;
                --v544[0];
              }
              while (v544[0]);
            }
            else
            {
              do
              {
                int v490 = v554[0];
                unsigned int v491 = v554[0] - 1;
                do
                {
                  char v492 = ((unsigned __int16)(v447 + (*v40 ^ 0xFF)) >> 8) | (2
                                                                                           * ((unsigned __int16)(v447 + (*v40 ^ 0xFF)) >> 8)) | (4 * (((unsigned __int16)(v447 + (*v40 ^ 0xFF)) >> 8) | (2 * ((unsigned __int16)(v447 + (*v40 ^ 0xFF)) >> 8))));
                  *uint64_t v40 = ~((v447 + ~*v40) | (16 * v492) | v492);
                  ++v40;
                  --v490;
                }
                while (v490);
                v40 += v19;
                v42 += v43 + v529 + v529 * (unint64_t)v491;
                --v544[0];
              }
              while (v544[0]);
            }
            goto LABEL_1157;
          case 12:
            if (v8)
            {
              do
              {
                int v451 = v554[0];
                do
                {
                  unsigned int v452 = (v32 | (v20 << 16)) + (*v40 | (*v42 << 16));
                  int v453 = (255 * ((v452 >> 8) & 0x10001)) | v452;
                  *v40++ = v453;
                  *uint64_t v42 = BYTE2(v453);
                  v42 += v529;
                  --v451;
                }
                while (v451);
                v40 += v19;
                v42 += v43;
                --v544[0];
              }
              while (v544[0]);
            }
            else
            {
              do
              {
                int v493 = v554[0];
                unsigned int v494 = v554[0] - 1;
                do
                {
                  *uint64_t v40 = -((*v40 + v32) >> 8) | (*v40 + v32);
                  ++v40;
                  --v493;
                }
                while (v493);
                v40 += v19;
                v42 += v43 + v529 + v529 * (unint64_t)v494;
                --v544[0];
              }
              while (v544[0]);
            }
            goto LABEL_1157;
          case 13:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v454 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v455 = PDAmultiplyPDA_17518(*v40, *v42, v32, v20);
                    *uint64_t v40 = v455;
                    *uint64_t v42 = HIBYTE(v455);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAmultiplyPDA_17518(*v40, 255, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v454;
              }
              while (v454);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 14:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v456 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v457 = PDAscreenPDA_17519(*v40, *v42, v32, v20);
                    *uint64_t v40 = v457;
                    *uint64_t v42 = HIBYTE(v457);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAscreenPDA_17519(*v40, 255, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v456;
              }
              while (v456);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 15:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v458 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v459 = PDAoverlayPDA_17520(*v40, *v42, v32, v20);
                    *uint64_t v40 = v459;
                    *uint64_t v42 = HIBYTE(v459);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAoverlayPDA_17520(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v458;
              }
              while (v458);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 16:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v460 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v461 = PDAdarkenPDA_17522(*v40, *v42, v32, v20);
                    *uint64_t v40 = v461;
                    *uint64_t v42 = HIBYTE(v461);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAdarkenPDA_17522(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v460;
              }
              while (v460);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 17:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v462 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v463 = PDAlightenPDA_17521(*v40, *v42, v32, v20);
                    *uint64_t v40 = v463;
                    *uint64_t v42 = HIBYTE(v463);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAlightenPDA_17521(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v462;
              }
              while (v462);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 18:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v464 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v465 = PDAcolordodgePDA_17523(*v40, *v42, v32, v20);
                    *uint64_t v40 = v465;
                    *uint64_t v42 = HIBYTE(v465);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAcolordodgePDA_17523(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v464;
              }
              while (v464);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 19:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v466 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v467 = PDAcolorburnPDA_17524(*v40, *v42, v32, v20);
                    *uint64_t v40 = v467;
                    *uint64_t v42 = HIBYTE(v467);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAcolorburnPDA_17524(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v466;
              }
              while (v466);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 20:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v468 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v469 = PDAsoftlightPDA_17526(*v40, *v42, v32, v20);
                    *uint64_t v40 = v469;
                    *uint64_t v42 = HIBYTE(v469);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAsoftlightPDA_17526(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v468;
              }
              while (v468);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 21:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v470 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v471 = PDAhardlightPDA_17525(*v40, *v42, v32, v20);
                    *uint64_t v40 = v471;
                    *uint64_t v42 = HIBYTE(v471);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAhardlightPDA_17525(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v470;
              }
              while (v470);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 22:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v472 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v473 = PDAdifferencePDA_17527(*v40, *v42, v32, v20);
                    *uint64_t v40 = v473;
                    *uint64_t v42 = HIBYTE(v473);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAdifferencePDA_17527(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v472;
              }
              while (v472);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 23:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v474 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v475 = PDAexclusionPDA_17528(*v40, *v42, v32, v20);
                    *uint64_t v40 = v475;
                    *uint64_t v42 = HIBYTE(v475);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAexclusionPDA_17528(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v474;
              }
              while (v474);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 24:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v476 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v477 = PDAhuePDA_17529(*v40, *v42, v32, v20);
                    *uint64_t v40 = v477;
                    *uint64_t v42 = HIBYTE(v477);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAhuePDA_17529(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v476;
              }
              while (v476);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 25:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v478 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v479 = PDAhuePDA_17529(*v40, *v42, v32, v20);
                    *uint64_t v40 = v479;
                    *uint64_t v42 = HIBYTE(v479);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAhuePDA_17529(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v478;
              }
              while (v478);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 26:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v480 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v481 = PDAluminosityPDA_17531(v32, v20, *v40, *v42);
                    *uint64_t v40 = v481;
                    *uint64_t v42 = HIBYTE(v481);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAluminosityPDA_17531(v32, v20, *v40, 0xFFu);
                }
                ++v40;
                v42 += v529;
                --v480;
              }
              while (v480);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          case 27:
            if (!v20) {
              goto LABEL_1157;
            }
            do
            {
              int v482 = v554[0];
              do
              {
                if (v8)
                {
                  if (*v42)
                  {
                    int v483 = PDAluminosityPDA_17531(*v40, *v42, v32, v20);
                    *uint64_t v40 = v483;
                    *uint64_t v42 = HIBYTE(v483);
                  }
                  else
                  {
                    *uint64_t v40 = v32;
                    *uint64_t v42 = v20;
                  }
                }
                else
                {
                  *uint64_t v40 = PDAluminosityPDA_17531(*v40, 0xFFu, v32, v20);
                }
                ++v40;
                v42 += v529;
                --v482;
              }
              while (v482);
              v40 += v19;
              v42 += v43;
              --v544[0];
            }
            while (v544[0]);
            break;
          default:
            goto LABEL_1158;
        }
        int v9 = v513;
LABEL_1157:
        uint64_t v19 = *(void *)v531;
LABEL_1158:
        uint64_t v40 = v535;
        uint64_t v41 = (uint64_t)v541;
        if (!v541) {
          return 1;
        }
        uint64_t v543 = 0;
      }
      uint64_t v51 = v541;
      goto LABEL_1165;
    }
    v554[0] = *(_DWORD *)(v3 + 4);
    v544[0] = v14;
    uint64_t v21 = *(int *)(v3 + 28);
    unint64_t v22 = *(void *)(v3 + 88);
    uint64_t v24 = *(int *)(v3 + 12);
    int v23 = *(_DWORD *)(v3 + 16);
    if (v8)
    {
      uint64_t v517 = *(int *)(v3 + 32);
      int v518 = (char *)(v8 + v24 + (int)v517 * (uint64_t)v23);
      uint64_t v25 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v517 = 0;
      int v518 = 0;
      uint64_t v25 = 0;
    }
    unint64_t v516 = *(void *)(v3 + 40) + v24 + v23 * (uint64_t)(int)v21;
    int v36 = *(_DWORD *)(v3 + 56);
    int v35 = *(_DWORD *)(v3 + 60);
    uint64_t v37 = *(int *)(v3 + 76);
    if (v18 != 256)
    {
      int v522 = *(_DWORD *)(v3 + 64);
      int v520 = *(_DWORD *)(v3 + 68);
      if (v7)
      {
        uint64_t v38 = *(int *)(v3 + 80);
        int v39 = 1;
      }
      else
      {
        uint64_t v38 = 0;
        int v39 = 0;
      }
      unint64_t v526 = v22 + *(int *)(v3 + 68) * (uint64_t)(int)v37;
      v25 &= 1u;
      if (v16)
      {
        int v495 = *(_DWORD *)(v3 + 56);
        int v496 = *(_DWORD *)(v3 + 60);
        int v540 = v39;
        int v542 = (void *)v25;
        uint64_t v536 = *(int *)(v3 + 76);
        int v54 = 1;
        int v528 = *(unsigned char **)(v3 + 88);
        char v52 = v528;
        goto LABEL_54;
      }
      uint64_t v538 = v517 - (v25 * v12);
      if (v22)
      {
        int v60 = v35 % v520;
        int v61 = v36 % v522;
        uint64_t v536 = *(int *)(v3 + 76);
        uint64_t v515 = *(void *)(v3 + 88);
        unint64_t v62 = v22 + (int)v37 * (uint64_t)v60;
        char v52 = (unsigned char *)(v62 + v61);
        unint64_t v22 = v62 + v522;
        int v495 = v61;
        int v496 = v60;
        if (v7)
        {
          uint64_t v521 = 0;
          uint64_t v514 = (uint64_t)v7;
          v7 += (int)v38 * (uint64_t)v60 + v61;
          int v519 = 1;
          int v39 = 1;
          uint64_t v63 = (unsigned char *)v516;
          uint64_t v58 = v518;
          int v528 = (unsigned char *)(v62 + v61);
          int v530 = v7;
        }
        else
        {
          uint64_t v514 = 0;
          uint64_t v521 = 0;
          int v528 = (unsigned char *)(v62 + v61);
          int v530 = 0;
          int v519 = 1;
          uint64_t v63 = (unsigned char *)v516;
          uint64_t v58 = v518;
        }
        unint64_t v59 = v12;
        goto LABEL_66;
      }
      int v495 = *(_DWORD *)(v3 + 56);
      int v496 = *(_DWORD *)(v3 + 60);
      char v52 = 0;
      int v519 = 1;
      unint64_t v59 = v12;
LABEL_62:
      unint64_t v526 = 0;
      int v528 = 0;
      uint64_t v521 = 0;
      uint64_t v536 = v37 - v59;
      v38 -= v39 * (int)v12;
      uint64_t v514 = (uint64_t)v7;
      uint64_t v515 = (uint64_t)v52;
      uint64_t v63 = (unsigned char *)v516;
      uint64_t v58 = v518;
      int v530 = v7;
      goto LABEL_66;
    }
    if (v7)
    {
      uint64_t v38 = *(int *)(v3 + 80);
      v7 += v36 + (int)v38 * (uint64_t)v35;
      int v39 = -1;
    }
    else
    {
      uint64_t v38 = 0;
      int v39 = 0;
    }
    char v52 = (unsigned char *)(v22 + v36 + v35 * (uint64_t)(int)v37);
    if (v37 == v21 && (uint64_t)(v516 - (void)v52) >= 1)
    {
      if (v516 - (unint64_t)v52 <= v12)
      {
        v516 += v13;
        v52 += v13;
        v518 += v25 & v13;
        v7 += v39 & v13;
        int v54 = -1;
        goto LABEL_49;
      }
      char v53 = &v52[v37 * v15];
      if (v516 <= (unint64_t)&v53[v13])
      {
        v516 += v21 * v15;
        uint64_t v21 = -v21;
        uint64_t v37 = -v37;
        uint64_t v64 = &v518[v517 * v15];
        uint64_t v517 = -v517;
        int v518 = v64;
        v25 &= 1u;
        v7 += v38 * v15;
        uint64_t v38 = -v38;
        v39 &= 1u;
        int v54 = 1;
        char v52 = v53;
        goto LABEL_49;
      }
    }
    v25 &= 1u;
    v39 &= 1u;
    int v54 = 1;
LABEL_49:
    int v495 = *(_DWORD *)(v3 + 56);
    int v496 = *(_DWORD *)(v3 + 60);
    if (v16)
    {
      int v540 = v39;
      int v542 = (void *)v25;
      unint64_t v526 = 0;
      int v528 = 0;
      unint64_t v22 = -1;
      uint64_t v536 = v37;
      int v522 = v37;
      int v520 = v38;
LABEL_54:
      int v519 = v54;
      uint64_t v523 = v21;
      shape_enum_clip_alloc(v2, v3, (int *)v16, v54, v21, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
      uint64_t v56 = v55;
      uint64_t v514 = (uint64_t)v7;
      uint64_t v515 = (uint64_t)v52;
      uint64_t v57 = v7;
      uint64_t v58 = v518;
      uint64_t v538 = v517;
      if (!v55) {
        return 1;
      }
      while (2)
      {
        int v530 = v57;
        if (!shape_enum_clip_next(v56, (int *)&v543 + 1, &v543, v554, v544))
        {
          uint64_t v51 = (void *)v56;
LABEL_1165:
          free(v51);
          return 1;
        }
        uint64_t v521 = v56;
        if (v526)
        {
          uint64_t v21 = v523;
          uint64_t v63 = (unsigned char *)(v516 + v523 * (int)v543 + SHIDWORD(v543));
          int v375 = ((int)v543 + *(_DWORD *)(v11 + 60)) % v520;
          unint64_t v59 = v554[0];
          int v376 = (HIDWORD(v543) + *(_DWORD *)(v11 + 56)) % v522;
          uint64_t v377 = v515 + v536 * v375;
          char v52 = (unsigned char *)(v377 + v376);
          unint64_t v22 = v377 + v522;
          uint64_t v25 = (uint64_t)v542;
          if (v542) {
            uint64_t v58 = &v518[v517 * (int)v543 + SHIDWORD(v543)];
          }
          uint64_t v378 = v538;
          if (v542) {
            uint64_t v378 = v517 - v554[0];
          }
          uint64_t v538 = v378;
          if (v540) {
            int v39 = v540;
          }
          else {
            int v39 = 0;
          }
          if (v540) {
            uint64_t v7 = (char *)(v514 + v38 * v375 + v376);
          }
          uint64_t v379 = (uint64_t)v530;
          if (v540) {
            uint64_t v379 = v514 + v38 * v375 + v376;
          }
          int v528 = v52;
          int v530 = (char *)v379;
          LODWORD(v12) = v554[0];
          int v495 = (HIDWORD(v543) + *(_DWORD *)(v11 + 56)) % v522;
          int v496 = ((int)v543 + *(_DWORD *)(v11 + 60)) % v520;
        }
        else
        {
          LODWORD(v12) = v554[0];
          uint64_t v21 = v523;
          uint64_t v63 = (unsigned char *)(v516 + v523 * (int)v543 + SHIDWORD(v543) * (uint64_t)v519);
          unint64_t v59 = v554[0] * v519;
          char v52 = (unsigned char *)(v515 + (int)v543 * (uint64_t)v522 + SHIDWORD(v543) * (uint64_t)v519);
          uint64_t v536 = v522 - v554[0] * v519;
          uint64_t v25 = (uint64_t)v542;
          if (v542) {
            uint64_t v58 = &v518[v517 * (int)v543 + SHIDWORD(v543) * (uint64_t)v519];
          }
          uint64_t v380 = v538;
          if (v542) {
            uint64_t v380 = v517 - v554[0] * v519;
          }
          uint64_t v538 = v380;
          if (v540) {
            int v39 = v540;
          }
          else {
            int v39 = 0;
          }
          unint64_t v526 = 0;
          if (v540)
          {
            uint64_t v7 = (char *)(v514 + (int)v543 * (uint64_t)v520 + SHIDWORD(v543) * (uint64_t)v519);
            uint64_t v38 = v520 - (int)v59;
          }
        }
LABEL_66:
        int v540 = v39;
        int v542 = (void *)v25;
        uint64_t v523 = v21;
        *(void *)uint64_t v532 = v21 - v59;
        uint64_t v524 = v38;
        switch(v9)
        {
          case 0:
            uint64_t v65 = *(void *)v532 - (int)v12;
            uint64_t v66 = &v63[-(int)v12 + 1];
            if (v519 >= 0)
            {
              uint64_t v66 = v63;
              uint64_t v65 = *(void *)v532 + (int)v12;
            }
            unsigned int v67 = v544[0];
            uint64_t v68 = v544[0] - 1;
            if (v65 >= 0) {
              LODWORD(v69) = v65;
            }
            else {
              uint64_t v69 = -v65;
            }
            int v70 = v25;
            CGBlt_fillBytes(v12, v544[0], 0, &v66[(v65 * v68) & (v65 >> 63)], v69);
            if (v70)
            {
              uint64_t v71 = v538 - (int)v12;
              uint64_t v72 = &v58[-(int)v12 + 1];
              if (v519 >= 0)
              {
                uint64_t v72 = v58;
                uint64_t v71 = v538 + (int)v12;
              }
              uint64_t v73 = (v71 * v68) & (v71 >> 63);
              uint64_t v58 = &v72[v73];
              if (v71 >= 0) {
                uint64_t v74 = v71;
              }
              else {
                uint64_t v74 = -v71;
              }
              uint64_t v538 = v74;
              CGBlt_fillBytes(v12, v67, 0, &v72[v73], v74);
            }
            int v9 = v513;
            goto LABEL_669;
          case 1:
            int v75 = *(unsigned __int8 *)(v11 + 1);
            if (v75 == 2)
            {
              if ((int)v12 >= 32 && v522 <= 0x40)
              {
                v4.i32[0] = v522;
                uint8x8_t v351 = (uint8x8_t)vcnt_s8(v4);
                v351.i16[0] = vaddlv_u8(v351);
                if (v351.i32[0] <= 1u)
                {
                  int v352 = v12 + v532[0];
                  int v533 = v544[0];
                  CGSFillDRAM64((unint64_t)v63, v352, v12, v544[0], v515, v536, v522, v520, v495, v496);
                  if (!v542) {
                    goto LABEL_669;
                  }
                  uint64_t v56 = v521;
                  if (v540) {
                    CGSFillDRAM64((unint64_t)v58, v12 + v538, v12, v533, v514, v38, v522, v520, v495, v496);
                  }
                  else {
                    CGBlt_fillBytes(v12, v533, -1, v58, v12 + v538);
                  }
                  goto LABEL_670;
                }
              }
            }
            else if (v75 == 1)
            {
              if (v519 < 0)
              {
                uint64_t v76 = v536 - (int)v12;
                v52 += -(int)v12 + 1;
                uint64_t v77 = *(void *)v532 - (int)v12;
                v63 += -(int)v12 + 1;
              }
              else
              {
                uint64_t v76 = v536 + (int)v12;
                uint64_t v77 = *(void *)v532 + (int)v12;
              }
              uint64_t v361 = v544[0] - 1;
              if (v76 >= 0) {
                uint64_t v362 = v76;
              }
              else {
                uint64_t v362 = -v76;
              }
              if (v77 >= 0) {
                LODWORD(v363) = v77;
              }
              else {
                uint64_t v363 = -v77;
              }
              int v534 = v544[0];
              uint64_t v536 = v362;
              CGBlt_copyBytes(v12, v544[0], &v52[(v76 * v361) & (v76 >> 63)], &v63[(v77 * v361) & (v77 >> 63)], v362, v363);
              if (!v542)
              {
                int v9 = v513;
                goto LABEL_669;
              }
              uint64_t v56 = v521;
              if (v540)
              {
                uint64_t v364 = v38 - (int)v12;
                uint64_t v365 = &v7[-(int)v12 + 1];
                uint64_t v366 = v538 - (int)v12;
                unint64_t v367 = &v58[-(int)v12 + 1];
                if (v519 >= 0)
                {
                  unint64_t v367 = v58;
                  uint64_t v365 = v7;
                  uint64_t v364 = v38 + (int)v12;
                  uint64_t v366 = v538 + (int)v12;
                }
                uint64_t v368 = (v364 * v361) & (v364 >> 63);
                uint64_t v7 = &v365[v368];
                if (v364 >= 0) {
                  uint64_t v38 = v364;
                }
                else {
                  uint64_t v38 = -v364;
                }
                uint64_t v369 = (v366 * v361) & (v366 >> 63);
                uint64_t v58 = &v367[v369];
                if (v366 >= 0) {
                  uint64_t v370 = v366;
                }
                else {
                  uint64_t v370 = -v366;
                }
                uint64_t v538 = v370;
                CGBlt_copyBytes(v12, v534, &v365[v368], &v367[v369], v38, v370);
              }
              else
              {
                uint64_t v381 = v538 - (int)v12;
                long long v382 = &v58[-(int)v12 + 1];
                if (v519 >= 0)
                {
                  long long v382 = v58;
                  uint64_t v381 = v538 + (int)v12;
                }
                uint64_t v383 = (v381 * v361) & (v381 >> 63);
                uint64_t v58 = &v382[v383];
                if (v381 >= 0) {
                  uint64_t v384 = v381;
                }
                else {
                  uint64_t v384 = -v381;
                }
                uint64_t v538 = v384;
                CGBlt_fillBytes(v12, v534, -1, &v382[v383], v384);
              }
              int v9 = v513;
              goto LABEL_670;
            }
            if (!v25)
            {
              uint64_t v315 = v528;
              uint64_t v57 = v530;
              do
              {
                int v357 = v554[0];
                do
                {
                  unsigned char *v63 = *v52;
                  v63 += v519;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v358 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v358 = 0;
                  }
                  v52 += v519 + v358;
                  v7 += v39 + v358;
                  --v357;
                }
                while (v357);
                if (v526)
                {
                  if ((unint64_t)&v315[v536] >= v526) {
                    uint64_t v359 = -(v536 * v520);
                  }
                  else {
                    uint64_t v359 = 0;
                  }
                  char v52 = &v315[v536 + v359];
                  if ((unint64_t)&v315[v536] >= v526) {
                    uint64_t v360 = -(v38 * v520);
                  }
                  else {
                    uint64_t v360 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v360];
                  v22 += v536 + v359;
                  v315 += v536 + v359;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
              goto LABEL_835;
            }
            if (v39)
            {
              uint64_t v332 = v528;
              uint64_t v57 = v530;
              do
              {
                int v353 = v554[0];
                do
                {
                  unsigned char *v63 = *v52;
                  *uint64_t v58 = *v7;
                  v63 += v519;
                  v58 += (int)v25;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v354 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v354 = 0;
                  }
                  v52 += v519 + v354;
                  v7 += v39 + v354;
                  --v353;
                }
                while (v353);
                if (v526)
                {
                  if ((unint64_t)&v332[v536] >= v526) {
                    uint64_t v355 = -(v536 * v520);
                  }
                  else {
                    uint64_t v355 = 0;
                  }
                  char v52 = &v332[v536 + v355];
                  if ((unint64_t)&v332[v536] >= v526) {
                    uint64_t v356 = -(v38 * v520);
                  }
                  else {
                    uint64_t v356 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v356];
                  v22 += v536 + v355;
                  v332 += v536 + v355;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
            }
            else
            {
              uint64_t v332 = v528;
              uint64_t v57 = v530;
              do
              {
                int v371 = v554[0];
                do
                {
                  unsigned char *v63 = *v52;
                  *uint64_t v58 = -1;
                  v63 += v519;
                  v58 += (int)v25;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v372 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v372 = 0;
                  }
                  v52 += v519 + v372;
                  v7 += v372;
                  --v371;
                }
                while (v371);
                if (v526)
                {
                  if ((unint64_t)&v332[v536] >= v526) {
                    uint64_t v373 = -(v536 * v520);
                  }
                  else {
                    uint64_t v373 = 0;
                  }
                  char v52 = &v332[v536 + v373];
                  if ((unint64_t)&v332[v536] >= v526) {
                    uint64_t v374 = -(v38 * v520);
                  }
                  else {
                    uint64_t v374 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v374];
                  v22 += v536 + v373;
                  v332 += v536 + v373;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
            }
LABEL_871:
            int v528 = v332;
            goto LABEL_872;
          case 2:
            if (v25)
            {
              uint64_t v78 = (int)v25;
              int v79 = v528;
              uint64_t v57 = v530;
              do
              {
                int v80 = v554[0];
                do
                {
                  int v81 = *v7;
                  if (*v7)
                  {
                    if (v81 == 255)
                    {
                      unsigned char *v63 = *v52;
                      LOBYTE(v82) = *v7;
                    }
                    else
                    {
                      unsigned int v83 = (*v63 | (*v58 << 16)) * (v81 ^ 0xFF);
                      unsigned int v84 = ((v83 + 65537 + ((v83 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v83 + 1 + BYTE1(v83)) >> 8))
                          + (*v52 | (v81 << 24));
                      unsigned char *v63 = v84;
                      unsigned int v82 = HIBYTE(v84);
                    }
                    *uint64_t v58 = v82;
                  }
                  v63 += v519;
                  v58 += v78;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v85 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v85 = 0;
                  }
                  v52 += v519 + v85;
                  v7 += v39 + v85;
                  --v80;
                }
                while (v80);
                if (v526)
                {
                  if ((unint64_t)&v79[v536] >= v526) {
                    uint64_t v86 = -(v536 * v520);
                  }
                  else {
                    uint64_t v86 = 0;
                  }
                  char v52 = &v79[v536 + v86];
                  if ((unint64_t)&v79[v536] >= v526) {
                    uint64_t v87 = -(v38 * v520);
                  }
                  else {
                    uint64_t v87 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v87];
                  v22 += v536 + v86;
                  v79 += v536 + v86;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
              goto LABEL_264;
            }
            uint64_t v315 = v528;
            uint64_t v57 = v530;
            do
            {
              int v316 = v554[0];
              do
              {
                int v317 = *v7;
                if (*v7)
                {
                  if (v317 == 255) {
                    LOBYTE(v318) = *v52;
                  }
                  else {
                    unsigned int v318 = *v52
                  }
                         + ((*v63 * (v317 ^ 0xFF) + ((*v63 * (v317 ^ 0xFFu)) >> 8) + 1) >> 8);
                  unsigned char *v63 = v318;
                }
                v63 += v519;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v319 = -(uint64_t)v522;
                }
                else {
                  uint64_t v319 = 0;
                }
                v52 += v519 + v319;
                v7 += v39 + v319;
                --v316;
              }
              while (v316);
              if (v526)
              {
                if ((unint64_t)&v315[v536] >= v526) {
                  uint64_t v320 = -(v536 * v520);
                }
                else {
                  uint64_t v320 = 0;
                }
                char v52 = &v315[v536 + v320];
                if ((unint64_t)&v315[v536] >= v526) {
                  uint64_t v321 = -(v38 * v520);
                }
                else {
                  uint64_t v321 = 0;
                }
                uint64_t v7 = &v57[v38 + v321];
                v22 += v536 + v320;
                v315 += v536 + v320;
                uint64_t v57 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_835;
          case 3:
            uint64_t v88 = (int)v25;
            if (v39)
            {
              int v79 = v528;
              uint64_t v57 = v530;
              do
              {
                int v89 = v554[0];
                do
                {
                  unsigned int v90 = *v58;
                  if (v90 == 255)
                  {
                    unsigned char *v63 = *v52;
                    LOBYTE(v90) = *v7;
                  }
                  else if (*v58)
                  {
                    int v91 = *v52;
                    int v92 = *v7;
                    unsigned int v93 = (v91 | (v92 << 16)) * (v90 ^ 0xFF)
                        + 65537
                        + ((((v91 | (v92 << 16)) * (v90 ^ 0xFF)) >> 8) & 0xFF00FF);
                    int v94 = v91 | (v92 << 24);
                    unsigned char *v63 = v94 - BYTE1(v93);
                    unsigned int v90 = (v94 - (v93 & 0xFF000000 | BYTE1(v93))) >> 24;
                  }
                  else
                  {
                    unsigned char *v63 = 0;
                  }
                  *uint64_t v58 = v90;
                  v63 += v519;
                  v58 += v88;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v95 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v95 = 0;
                  }
                  v52 += v519 + v95;
                  v7 += v39 + v95;
                  --v89;
                }
                while (v89);
                if (v526)
                {
                  if ((unint64_t)&v79[v536] >= v526) {
                    uint64_t v96 = -(v536 * v520);
                  }
                  else {
                    uint64_t v96 = 0;
                  }
                  char v52 = &v79[v536 + v96];
                  if ((unint64_t)&v79[v536] >= v526) {
                    uint64_t v97 = -(v38 * v520);
                  }
                  else {
                    uint64_t v97 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v97];
                  v22 += v536 + v96;
                  v79 += v536 + v96;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
              goto LABEL_264;
            }
            uint64_t v315 = v528;
            uint64_t v57 = v530;
            do
            {
              int v322 = v554[0];
              do
              {
                unsigned int v323 = *v58;
                if (*v58)
                {
                  if (v323 == 255) {
                    LOBYTE(v323) = *v52;
                  }
                  else {
                    unsigned int v323 = *v52
                  }
                         - ((*v52 * (v323 ^ 0xFF) + ((*v52 * (v323 ^ 0xFF)) >> 8) + 1) >> 8);
                }
                unsigned char *v63 = v323;
                v63 += v519;
                v58 += v88;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v324 = -(uint64_t)v522;
                }
                else {
                  uint64_t v324 = 0;
                }
                v52 += v519 + v324;
                v7 += v324;
                --v322;
              }
              while (v322);
              if (v526)
              {
                if ((unint64_t)&v315[v536] >= v526) {
                  uint64_t v325 = -(v536 * v520);
                }
                else {
                  uint64_t v325 = 0;
                }
                char v52 = &v315[v536 + v325];
                if ((unint64_t)&v315[v536] >= v526) {
                  uint64_t v326 = -(v38 * v520);
                }
                else {
                  uint64_t v326 = 0;
                }
                uint64_t v7 = &v57[v38 + v326];
                v22 += v536 + v325;
                v315 += v536 + v325;
                uint64_t v57 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_835;
          case 4:
            uint64_t v98 = (int)v25;
            do
            {
              int v99 = v554[0];
              do
              {
                int v100 = *v58;
                if ((v100 ^ 0xFF) == 0xFF)
                {
                  if (v39) {
                    LOBYTE(v101) = *v7;
                  }
                  else {
                    LOBYTE(v101) = -1;
                  }
                }
                else if (v100 != 0xFF)
                {
                  if (v39) {
                    int v102 = *v7;
                  }
                  else {
                    int v102 = 255;
                  }
                  int v103 = *v52;
                  unsigned int v104 = (v103 | (v102 << 16)) * v100
                       + 65537
                       + ((((v103 | (v102 << 16)) * v100) >> 8) & 0xFF00FF);
                  int v105 = v103 | (v102 << 24);
                  unsigned char *v63 = v105 - BYTE1(v104);
                  unsigned int v101 = (v105 - (v104 & 0xFF000000 | BYTE1(v104))) >> 24;
                }
                else
                {
                  LOBYTE(v101) = 0;
                  unsigned char *v63 = 0;
                }
                *uint64_t v58 = v101;
                v63 += v519;
                v58 += v98;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v106 = -(uint64_t)v522;
                }
                else {
                  uint64_t v106 = 0;
                }
                v52 += v519 + v106;
                v7 += v39 + v106;
                --v99;
              }
              while (v99);
              if (v526)
              {
                if ((unint64_t)&v528[v536] >= v526) {
                  uint64_t v107 = -(v536 * v520);
                }
                else {
                  uint64_t v107 = 0;
                }
                char v52 = &v528[v536 + v107];
                if ((unint64_t)&v528[v536] >= v526) {
                  uint64_t v108 = -(v38 * v520);
                }
                else {
                  uint64_t v108 = 0;
                }
                uint64_t v7 = &v530[v38 + v108];
                v22 += v536 + v107;
                v528 += v536 + v107;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_669;
          case 5:
            uint64_t v109 = (int)v25;
            unsigned __int8 v110 = v528;
            uint64_t v57 = v530;
            do
            {
              int v111 = v554[0];
              do
              {
                unsigned int v112 = (*v52 | (*v7 << 16)) * *v58
                     + (*v63 | (*v58 << 16)) * (*v7 ^ 0xFF);
                int v113 = v112 + 65537 + ((v112 >> 8) & 0xFF00FF);
                unsigned char *v63 = BYTE1(v113);
                *uint64_t v58 = HIBYTE(v113);
                v63 += v519;
                v58 += v109;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v114 = -(uint64_t)v522;
                }
                else {
                  uint64_t v114 = 0;
                }
                v52 += v519 + v114;
                v7 += v39 + v114;
                --v111;
              }
              while (v111);
              if (v526)
              {
                if ((unint64_t)&v110[v536] >= v526) {
                  uint64_t v115 = -(v536 * v520);
                }
                else {
                  uint64_t v115 = 0;
                }
                char v52 = &v110[v536 + v115];
                if ((unint64_t)&v110[v536] >= v526) {
                  uint64_t v116 = -(v38 * v520);
                }
                else {
                  uint64_t v116 = 0;
                }
                uint64_t v7 = &v57[v38 + v116];
                v22 += v536 + v115;
                v110 += v536 + v115;
                uint64_t v57 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_281;
          case 6:
            uint64_t v117 = (int)v25;
            do
            {
              int v118 = v554[0];
              do
              {
                int v119 = *v58;
                if ((_BYTE)v119 != 0xFF)
                {
                  if (~(_BYTE)v119 == 255)
                  {
                    if (v39) {
                      LOBYTE(v120) = *v7;
                    }
                    else {
                      LOBYTE(v120) = -1;
                    }
                    unsigned char *v63 = *v52;
                  }
                  else
                  {
                    if (v39) {
                      int v121 = *v7;
                    }
                    else {
                      int v121 = 255;
                    }
                    unsigned int v122 = (*v52 | (v121 << 16)) * ~(_BYTE)v119;
                    unsigned int v123 = ((v122 + 65537 + ((v122 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v122 + 1 + BYTE1(v122)) >> 8))
                         + (*v63 | (v119 << 24));
                    unsigned char *v63 = v123;
                    unsigned int v120 = HIBYTE(v123);
                  }
                  *uint64_t v58 = v120;
                }
                v63 += v519;
                v58 += v117;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v124 = -(uint64_t)v522;
                }
                else {
                  uint64_t v124 = 0;
                }
                v52 += v519 + v124;
                v7 += v39 + v124;
                --v118;
              }
              while (v118);
              if (v526)
              {
                if ((unint64_t)&v528[v536] >= v526) {
                  uint64_t v125 = -(v536 * v520);
                }
                else {
                  uint64_t v125 = 0;
                }
                char v52 = &v528[v536 + v125];
                if ((unint64_t)&v528[v536] >= v526) {
                  uint64_t v126 = -(v38 * v520);
                }
                else {
                  uint64_t v126 = 0;
                }
                uint64_t v7 = &v530[v38 + v126];
                v22 += v536 + v125;
                v528 += v536 + v125;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_669;
          case 7:
            if (v25)
            {
              uint64_t v127 = (int)v25;
              int v79 = v528;
              uint64_t v57 = v530;
              do
              {
                int v128 = v554[0];
                do
                {
                  unsigned int v129 = *v7;
                  if (v129 != 255)
                  {
                    if (*v7)
                    {
                      int v130 = *v63;
                      int v131 = *v58;
                      unsigned int v132 = (v130 | (v131 << 16)) * (v129 ^ 0xFF)
                           + 65537
                           + ((((v130 | (v131 << 16)) * (v129 ^ 0xFF)) >> 8) & 0xFF00FF);
                      int v133 = v130 | (v131 << 24);
                      unsigned char *v63 = v133 - BYTE1(v132);
                      unsigned int v129 = (v133 - (v132 & 0xFF000000 | BYTE1(v132))) >> 24;
                    }
                    else
                    {
                      unsigned char *v63 = 0;
                    }
                    *uint64_t v58 = v129;
                  }
                  v63 += v519;
                  v58 += v127;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v134 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v134 = 0;
                  }
                  v52 += v519 + v134;
                  v7 += v39 + v134;
                  --v128;
                }
                while (v128);
                if (v526)
                {
                  if ((unint64_t)&v79[v536] >= v526) {
                    uint64_t v135 = -(v536 * v520);
                  }
                  else {
                    uint64_t v135 = 0;
                  }
                  char v52 = &v79[v536 + v135];
                  if ((unint64_t)&v79[v536] >= v526) {
                    uint64_t v136 = -(v38 * v520);
                  }
                  else {
                    uint64_t v136 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v136];
                  v22 += v536 + v135;
                  v79 += v536 + v135;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
              goto LABEL_264;
            }
            uint64_t v315 = v528;
            uint64_t v57 = v530;
LABEL_716:
            int v327 = v554[0];
            while (1)
            {
              unsigned int v328 = *v7;
              if (!*v7) {
                goto LABEL_720;
              }
              if (v328 != 255) {
                break;
              }
LABEL_721:
              v63 += v519;
              if ((unint64_t)&v52[v519] >= v22) {
                uint64_t v329 = -(uint64_t)v522;
              }
              else {
                uint64_t v329 = 0;
              }
              v52 += v519 + v329;
              v7 += v39 + v329;
              if (!--v327)
              {
                if (v526)
                {
                  if ((unint64_t)&v315[v536] >= v526) {
                    uint64_t v330 = -(v536 * v520);
                  }
                  else {
                    uint64_t v330 = 0;
                  }
                  char v52 = &v315[v536 + v330];
                  if ((unint64_t)&v315[v536] >= v526) {
                    uint64_t v331 = -(v38 * v520);
                  }
                  else {
                    uint64_t v331 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v331];
                  v22 += v536 + v330;
                  v315 += v536 + v330;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                if (!--v544[0]) {
                  goto LABEL_835;
                }
                goto LABEL_716;
              }
            }
            unsigned int v328 = *v63
                 - ((*v63 * (v328 ^ 0xFF) + ((*v63 * (v328 ^ 0xFF)) >> 8) + 1) >> 8);
LABEL_720:
            unsigned char *v63 = v328;
            goto LABEL_721;
          case 8:
            if (!v25)
            {
              uint64_t v332 = v528;
              uint64_t v57 = v530;
              while (1)
              {
                int v333 = v554[0];
                do
                {
                  int v334 = *v7;
                  if ((_BYTE)v334 == 0xFF)
                  {
                    LOBYTE(v335) = 0;
                  }
                  else
                  {
                    if (~(_BYTE)v334 == 255) {
                      goto LABEL_743;
                    }
                    unsigned int v335 = *v63
                         - ((*v63 * v334 + ((*v63 * v334) >> 8) + 1) >> 8);
                  }
                  unsigned char *v63 = v335;
LABEL_743:
                  v63 += v519;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v336 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v336 = 0;
                  }
                  v52 += v519 + v336;
                  v7 += v39 + v336;
                  --v333;
                }
                while (v333);
                if (v526)
                {
                  if ((unint64_t)&v332[v536] >= v526) {
                    uint64_t v337 = -(v536 * v520);
                  }
                  else {
                    uint64_t v337 = 0;
                  }
                  char v52 = &v332[v536 + v337];
                  if ((unint64_t)&v332[v536] >= v526) {
                    uint64_t v338 = -(v38 * v520);
                  }
                  else {
                    uint64_t v338 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v338];
                  v22 += v536 + v337;
                  v332 += v536 + v337;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                if (!--v544[0]) {
                  goto LABEL_871;
                }
              }
            }
            uint64_t v137 = (int)v25;
            int v79 = v528;
            uint64_t v57 = v530;
            do
            {
              int v138 = v554[0];
              do
              {
                int v139 = *v7;
                if ((v139 ^ 0xFF) != 0xFF)
                {
                  if (v139 != 0xFF)
                  {
                    int v141 = *v63;
                    int v142 = *v58;
                    unsigned int v143 = (v141 | (v142 << 16)) * v139
                         + 65537
                         + ((((v141 | (v142 << 16)) * v139) >> 8) & 0xFF00FF);
                    int v144 = v141 | (v142 << 24);
                    unsigned char *v63 = v144 - BYTE1(v143);
                    unsigned int v140 = (v144 - (v143 & 0xFF000000 | BYTE1(v143))) >> 24;
                  }
                  else
                  {
                    LOBYTE(v140) = 0;
                    unsigned char *v63 = 0;
                  }
                  *uint64_t v58 = v140;
                }
                v63 += v519;
                v58 += v137;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v145 = -(uint64_t)v522;
                }
                else {
                  uint64_t v145 = 0;
                }
                v52 += v519 + v145;
                v7 += v39 + v145;
                --v138;
              }
              while (v138);
              if (v526)
              {
                if ((unint64_t)&v79[v536] >= v526) {
                  uint64_t v146 = -(v536 * v520);
                }
                else {
                  uint64_t v146 = 0;
                }
                char v52 = &v79[v536 + v146];
                if ((unint64_t)&v79[v536] >= v526) {
                  uint64_t v147 = -(v38 * v520);
                }
                else {
                  uint64_t v147 = 0;
                }
                uint64_t v7 = &v57[v38 + v147];
                v22 += v536 + v146;
                v79 += v536 + v146;
                uint64_t v57 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
LABEL_264:
            int v528 = v79;
LABEL_872:
            uint64_t v56 = v521;
            if (!v521) {
              return 1;
            }
LABEL_873:
            uint64_t v543 = 0;
            continue;
          case 9:
            uint64_t v148 = (int)v25;
            int v79 = v528;
            uint64_t v57 = v530;
            do
            {
              int v149 = v554[0];
              do
              {
                int v150 = *v58;
                int v151 = *v7;
                unsigned int v152 = (*v52 | (v151 << 16)) * (v150 ^ 0xFF)
                     + (*v63 | (v150 << 16)) * v151
                     + 65537
                     + ((((*v52 | (v151 << 16)) * (v150 ^ 0xFF)
                        + (*v63 | (v150 << 16)) * v151) >> 8) & 0xFF00FF);
                unsigned char *v63 = BYTE1(v152);
                *uint64_t v58 = HIBYTE(v152);
                v63 += v519;
                v58 += v148;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v153 = -(uint64_t)v522;
                }
                else {
                  uint64_t v153 = 0;
                }
                v52 += v519 + v153;
                v7 += v39 + v153;
                --v149;
              }
              while (v149);
              if (v526)
              {
                if ((unint64_t)&v79[v536] >= v526) {
                  uint64_t v154 = -(v536 * v520);
                }
                else {
                  uint64_t v154 = 0;
                }
                char v52 = &v79[v536 + v154];
                if ((unint64_t)&v79[v536] >= v526) {
                  uint64_t v155 = -(v38 * v520);
                }
                else {
                  uint64_t v155 = 0;
                }
                uint64_t v7 = &v57[v38 + v155];
                v22 += v536 + v154;
                v79 += v536 + v154;
                uint64_t v57 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
            goto LABEL_264;
          case 10:
            uint64_t v156 = (int)v25;
            unsigned __int8 v110 = v528;
            uint64_t v57 = v530;
            do
            {
              int v157 = v554[0];
              do
              {
                unsigned int v158 = (*v52 | (*v7 << 16)) * (*v58 ^ 0xFF)
                     + (*v63 | (*v58 << 16)) * (*v7 ^ 0xFF);
                int v159 = v158 + 65537 + ((v158 >> 8) & 0xFF00FF);
                unsigned char *v63 = BYTE1(v159);
                *uint64_t v58 = HIBYTE(v159);
                v63 += v519;
                v58 += v156;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v160 = -(uint64_t)v522;
                }
                else {
                  uint64_t v160 = 0;
                }
                v52 += v519 + v160;
                v7 += v39 + v160;
                --v157;
              }
              while (v157);
              if (v526)
              {
                if ((unint64_t)&v110[v536] >= v526) {
                  uint64_t v161 = -(v536 * v520);
                }
                else {
                  uint64_t v161 = 0;
                }
                char v52 = &v110[v536 + v161];
                if ((unint64_t)&v110[v536] >= v526) {
                  uint64_t v162 = -(v38 * v520);
                }
                else {
                  uint64_t v162 = 0;
                }
                uint64_t v7 = &v57[v38 + v162];
                v22 += v536 + v161;
                v110 += v536 + v161;
                uint64_t v57 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
LABEL_281:
            int v528 = v110;
            goto LABEL_872;
          case 11:
            if (v25)
            {
              uint64_t v163 = (int)v25;
              do
              {
                int v164 = v554[0];
                do
                {
                  if (v39) {
                    int v165 = *v7;
                  }
                  else {
                    int v165 = 255;
                  }
                  unsigned int v166 = ((*v58 - *v63) | (*v58 << 16))
                       + (v165 - *v52)
                       + (v165 << 16);
                  int v167 = (255 * ((v166 >> 8) & 0x10001)) | v166;
                  unsigned char *v63 = BYTE2(v167) - v167;
                  *uint64_t v58 = BYTE2(v167);
                  v63 += v519;
                  v58 += v163;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v168 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v168 = 0;
                  }
                  v52 += v519 + v168;
                  v7 += v39 + v168;
                  --v164;
                }
                while (v164);
                if (v526)
                {
                  if ((unint64_t)&v528[v536] >= v526) {
                    uint64_t v169 = -(v536 * v520);
                  }
                  else {
                    uint64_t v169 = 0;
                  }
                  char v52 = &v528[v536 + v169];
                  if ((unint64_t)&v528[v536] >= v526) {
                    uint64_t v170 = -(v38 * v520);
                  }
                  else {
                    uint64_t v170 = 0;
                  }
                  uint64_t v7 = &v530[v38 + v170];
                  v22 += v536 + v169;
                  v528 += v536 + v169;
                  int v530 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
            }
            else
            {
              do
              {
                int v339 = v554[0];
                do
                {
                  if (v39) {
                    __int16 v340 = *v7;
                  }
                  else {
                    __int16 v340 = 255;
                  }
                  __int16 v341 = v340 - *v52 + (*v63 ^ 0xFF);
                  char v342 = HIBYTE(v341) | (2 * HIBYTE(v341)) | (4 * (HIBYTE(v341) | (2 * HIBYTE(v341))));
                  unsigned char *v63 = ~(v341 | (16 * v342) | v342);
                  v63 += v519;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v343 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v343 = 0;
                  }
                  v52 += v519 + v343;
                  v7 += v39 + v343;
                  --v339;
                }
                while (v339);
                if (v526)
                {
                  if ((unint64_t)&v528[v536] >= v526) {
                    uint64_t v344 = -(v536 * v520);
                  }
                  else {
                    uint64_t v344 = 0;
                  }
                  char v52 = &v528[v536 + v344];
                  if ((unint64_t)&v528[v536] >= v526) {
                    uint64_t v345 = -(v38 * v520);
                  }
                  else {
                    uint64_t v345 = 0;
                  }
                  uint64_t v7 = &v530[v38 + v345];
                  v22 += v536 + v344;
                  v528 += v536 + v344;
                  int v530 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
            }
            goto LABEL_669;
          case 12:
            if (!v25)
            {
              uint64_t v315 = v528;
              uint64_t v57 = v530;
              do
              {
                int v346 = v554[0];
                do
                {
                  unsigned int v347 = *v52 + *v63;
                  unsigned char *v63 = -(v347 >> 8) | v347;
                  v63 += v519;
                  if ((unint64_t)&v52[v519] >= v22) {
                    uint64_t v348 = -(uint64_t)v522;
                  }
                  else {
                    uint64_t v348 = 0;
                  }
                  v52 += v519 + v348;
                  v7 += v39 + v348;
                  --v346;
                }
                while (v346);
                if (v526)
                {
                  if ((unint64_t)&v315[v536] >= v526) {
                    uint64_t v349 = -(v536 * v520);
                  }
                  else {
                    uint64_t v349 = 0;
                  }
                  char v52 = &v315[v536 + v349];
                  if ((unint64_t)&v315[v536] >= v526) {
                    uint64_t v350 = -(v38 * v520);
                  }
                  else {
                    uint64_t v350 = 0;
                  }
                  uint64_t v7 = &v57[v38 + v350];
                  v22 += v536 + v349;
                  v315 += v536 + v349;
                  uint64_t v57 = v7;
                }
                else
                {
                  v52 += v536;
                  v7 += v38;
                }
                v63 += *(void *)v532;
                v58 += v538;
                --v544[0];
              }
              while (v544[0]);
LABEL_835:
              int v528 = v315;
              goto LABEL_872;
            }
            uint64_t v171 = (int)v25;
            do
            {
              int v172 = v554[0];
              do
              {
                if (v39) {
                  int v173 = *v7;
                }
                else {
                  int v173 = 255;
                }
                unsigned int v174 = (*v63 | (*v58 << 16)) + *v52 + (v173 << 16);
                int v175 = (255 * ((v174 >> 8) & 0x10001)) | v174;
                unsigned char *v63 = v175;
                *uint64_t v58 = BYTE2(v175);
                v63 += v519;
                v58 += v171;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v176 = -(uint64_t)v522;
                }
                else {
                  uint64_t v176 = 0;
                }
                v52 += v519 + v176;
                v7 += v39 + v176;
                --v172;
              }
              while (v172);
              if (v526)
              {
                if ((unint64_t)&v528[v536] >= v526) {
                  uint64_t v177 = -(v536 * v520);
                }
                else {
                  uint64_t v177 = 0;
                }
                char v52 = &v528[v536 + v177];
                if ((unint64_t)&v528[v536] >= v526) {
                  uint64_t v178 = -(v38 * v520);
                }
                else {
                  uint64_t v178 = 0;
                }
                uint64_t v7 = &v530[v38 + v178];
                v22 += v536 + v177;
                v528 += v536 + v177;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                v7 += v38;
              }
              v63 += *(void *)v532;
              v58 += v538;
              --v544[0];
            }
            while (v544[0]);
LABEL_669:
            uint64_t v56 = v521;
LABEL_670:
            uint64_t v57 = v530;
            if (!v56) {
              return 1;
            }
            goto LABEL_873;
          case 13:
            uint64_t v179 = (int)v25;
            uint64_t v180 = v39;
            uint64_t v497 = -(v38 * v520);
            while (1)
            {
              int v181 = v554[0];
              do
              {
                if (v39)
                {
                  int v182 = *v7;
                  if (!*v7) {
                    goto LABEL_334;
                  }
                  if (v25) {
                    goto LABEL_329;
                  }
                }
                else
                {
                  int v182 = 255;
                  if (v25)
                  {
LABEL_329:
                    if (*v58)
                    {
                      int v183 = PDAmultiplyPDA_17518(*v63, *v58, *v52, v182);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v183;
                      *uint64_t v58 = HIBYTE(v183);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v182;
                    }
                    goto LABEL_334;
                  }
                }
                char v184 = PDAmultiplyPDA_17518(*v63, 255, *v52, v182);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v184;
LABEL_334:
                v63 += v519;
                v58 += v179;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v185 = -(uint64_t)v522;
                }
                else {
                  uint64_t v185 = 0;
                }
                v52 += v519 + v185;
                v7 += v180 + v185;
                --v181;
              }
              while (v181);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v186 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v186 = 0;
                }
                char v52 = &v528[v536 + v186];
                uint64_t v187 = v497;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v187 = 0;
                }
                uint64_t v7 = &v530[v524 + v187];
                v22 += v536 + v186;
                v528 += v536 + v186;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 14:
            uint64_t v188 = (int)v25;
            uint64_t v189 = v39;
            uint64_t v498 = -(v38 * v520);
            while (1)
            {
              int v190 = v554[0];
              do
              {
                if (v39)
                {
                  int v191 = *v7;
                  if (!*v7) {
                    goto LABEL_357;
                  }
                  if (v25) {
                    goto LABEL_352;
                  }
                }
                else
                {
                  int v191 = 255;
                  if (v25)
                  {
LABEL_352:
                    if (*v58)
                    {
                      int v192 = PDAscreenPDA_17519(*v63, *v58, *v52, v191);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v192;
                      *uint64_t v58 = HIBYTE(v192);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v191;
                    }
                    goto LABEL_357;
                  }
                }
                char v193 = PDAscreenPDA_17519(*v63, 255, *v52, v191);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v193;
LABEL_357:
                v63 += v519;
                v58 += v188;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v194 = -(uint64_t)v522;
                }
                else {
                  uint64_t v194 = 0;
                }
                v52 += v519 + v194;
                v7 += v189 + v194;
                --v190;
              }
              while (v190);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v195 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v195 = 0;
                }
                char v52 = &v528[v536 + v195];
                uint64_t v196 = v498;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v196 = 0;
                }
                uint64_t v7 = &v530[v524 + v196];
                v22 += v536 + v195;
                v528 += v536 + v195;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 15:
            uint64_t v197 = (int)v25;
            uint64_t v198 = v39;
            uint64_t v499 = -(v38 * v520);
            while (1)
            {
              int v199 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v200 = *v7;
                  if (!*v7) {
                    goto LABEL_380;
                  }
                  if (v25) {
                    goto LABEL_375;
                  }
                }
                else
                {
                  unsigned int v200 = 255;
                  if (v25)
                  {
LABEL_375:
                    if (*v58)
                    {
                      int v201 = PDAoverlayPDA_17520(*v63, *v58, *v52, v200);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v201;
                      *uint64_t v58 = HIBYTE(v201);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v200;
                    }
                    goto LABEL_380;
                  }
                }
                char v202 = PDAoverlayPDA_17520(*v63, 0xFFu, *v52, v200);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v202;
LABEL_380:
                v63 += v519;
                v58 += v197;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v203 = -(uint64_t)v522;
                }
                else {
                  uint64_t v203 = 0;
                }
                v52 += v519 + v203;
                v7 += v198 + v203;
                --v199;
              }
              while (v199);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v204 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v204 = 0;
                }
                char v52 = &v528[v536 + v204];
                uint64_t v205 = v499;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v205 = 0;
                }
                uint64_t v7 = &v530[v524 + v205];
                v22 += v536 + v204;
                v528 += v536 + v204;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 16:
            uint64_t v206 = (int)v25;
            uint64_t v207 = v39;
            uint64_t v500 = -(v38 * v520);
            while (1)
            {
              int v208 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v209 = *v7;
                  if (!*v7) {
                    goto LABEL_403;
                  }
                  if (v25) {
                    goto LABEL_398;
                  }
                }
                else
                {
                  unsigned int v209 = 255;
                  if (v25)
                  {
LABEL_398:
                    if (*v58)
                    {
                      int v210 = PDAdarkenPDA_17522(*v63, *v58, *v52, v209);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v210;
                      *uint64_t v58 = HIBYTE(v210);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v209;
                    }
                    goto LABEL_403;
                  }
                }
                char v211 = PDAdarkenPDA_17522(*v63, 0xFFu, *v52, v209);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v211;
LABEL_403:
                v63 += v519;
                v58 += v206;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v212 = -(uint64_t)v522;
                }
                else {
                  uint64_t v212 = 0;
                }
                v52 += v519 + v212;
                v7 += v207 + v212;
                --v208;
              }
              while (v208);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v213 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v213 = 0;
                }
                char v52 = &v528[v536 + v213];
                uint64_t v214 = v500;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v214 = 0;
                }
                uint64_t v7 = &v530[v524 + v214];
                v22 += v536 + v213;
                v528 += v536 + v213;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 17:
            uint64_t v215 = (int)v25;
            uint64_t v216 = v39;
            uint64_t v501 = -(v38 * v520);
            while (1)
            {
              int v217 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v218 = *v7;
                  if (!*v7) {
                    goto LABEL_426;
                  }
                  if (v25) {
                    goto LABEL_421;
                  }
                }
                else
                {
                  unsigned int v218 = 255;
                  if (v25)
                  {
LABEL_421:
                    if (*v58)
                    {
                      int v219 = PDAlightenPDA_17521(*v63, *v58, *v52, v218);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v219;
                      *uint64_t v58 = HIBYTE(v219);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v218;
                    }
                    goto LABEL_426;
                  }
                }
                char v220 = PDAlightenPDA_17521(*v63, 0xFFu, *v52, v218);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v220;
LABEL_426:
                v63 += v519;
                v58 += v215;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v221 = -(uint64_t)v522;
                }
                else {
                  uint64_t v221 = 0;
                }
                v52 += v519 + v221;
                v7 += v216 + v221;
                --v217;
              }
              while (v217);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v222 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v222 = 0;
                }
                char v52 = &v528[v536 + v222];
                uint64_t v223 = v501;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v223 = 0;
                }
                uint64_t v7 = &v530[v524 + v223];
                v22 += v536 + v222;
                v528 += v536 + v222;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 18:
            uint64_t v224 = (int)v25;
            uint64_t v225 = v39;
            uint64_t v502 = -(v38 * v520);
            while (1)
            {
              int v226 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v227 = *v7;
                  if (!*v7) {
                    goto LABEL_449;
                  }
                  if (v25) {
                    goto LABEL_444;
                  }
                }
                else
                {
                  unsigned int v227 = 255;
                  if (v25)
                  {
LABEL_444:
                    if (*v58)
                    {
                      int v228 = PDAcolordodgePDA_17523(*v63, *v58, *v52, v227);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v228;
                      *uint64_t v58 = HIBYTE(v228);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v227;
                    }
                    goto LABEL_449;
                  }
                }
                char v229 = PDAcolordodgePDA_17523(*v63, 0xFFu, *v52, v227);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v229;
LABEL_449:
                v63 += v519;
                v58 += v224;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v230 = -(uint64_t)v522;
                }
                else {
                  uint64_t v230 = 0;
                }
                v52 += v519 + v230;
                v7 += v225 + v230;
                --v226;
              }
              while (v226);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v231 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v231 = 0;
                }
                char v52 = &v528[v536 + v231];
                uint64_t v232 = v502;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v232 = 0;
                }
                uint64_t v7 = &v530[v524 + v232];
                v22 += v536 + v231;
                v528 += v536 + v231;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 19:
            uint64_t v233 = (int)v25;
            uint64_t v234 = v39;
            uint64_t v503 = -(v38 * v520);
            while (1)
            {
              int v235 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v236 = *v7;
                  if (!*v7) {
                    goto LABEL_472;
                  }
                  if (v25) {
                    goto LABEL_467;
                  }
                }
                else
                {
                  unsigned int v236 = 255;
                  if (v25)
                  {
LABEL_467:
                    if (*v58)
                    {
                      int v237 = PDAcolorburnPDA_17524(*v63, *v58, *v52, v236);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v237;
                      *uint64_t v58 = HIBYTE(v237);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v236;
                    }
                    goto LABEL_472;
                  }
                }
                char v238 = PDAcolorburnPDA_17524(*v63, 0xFFu, *v52, v236);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v238;
LABEL_472:
                v63 += v519;
                v58 += v233;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v239 = -(uint64_t)v522;
                }
                else {
                  uint64_t v239 = 0;
                }
                v52 += v519 + v239;
                v7 += v234 + v239;
                --v235;
              }
              while (v235);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v240 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v240 = 0;
                }
                char v52 = &v528[v536 + v240];
                uint64_t v241 = v503;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v241 = 0;
                }
                uint64_t v7 = &v530[v524 + v241];
                v22 += v536 + v240;
                v528 += v536 + v240;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 20:
            uint64_t v242 = (int)v25;
            uint64_t v243 = v39;
            uint64_t v504 = -(v38 * v520);
            while (1)
            {
              int v244 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v245 = *v7;
                  if (!*v7) {
                    goto LABEL_495;
                  }
                  if (v25) {
                    goto LABEL_490;
                  }
                }
                else
                {
                  unsigned int v245 = 255;
                  if (v25)
                  {
LABEL_490:
                    if (*v58)
                    {
                      int v246 = PDAsoftlightPDA_17526(*v63, *v58, *v52, v245);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v246;
                      *uint64_t v58 = HIBYTE(v246);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v245;
                    }
                    goto LABEL_495;
                  }
                }
                char v247 = PDAsoftlightPDA_17526(*v63, 0xFFu, *v52, v245);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v247;
LABEL_495:
                v63 += v519;
                v58 += v242;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v248 = -(uint64_t)v522;
                }
                else {
                  uint64_t v248 = 0;
                }
                v52 += v519 + v248;
                v7 += v243 + v248;
                --v244;
              }
              while (v244);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v249 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v249 = 0;
                }
                char v52 = &v528[v536 + v249];
                uint64_t v250 = v504;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v250 = 0;
                }
                uint64_t v7 = &v530[v524 + v250];
                v22 += v536 + v249;
                v528 += v536 + v249;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 21:
            uint64_t v251 = (int)v25;
            uint64_t v252 = v39;
            uint64_t v505 = -(v38 * v520);
            while (1)
            {
              int v253 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v254 = *v7;
                  if (!*v7) {
                    goto LABEL_518;
                  }
                  if (v25) {
                    goto LABEL_513;
                  }
                }
                else
                {
                  unsigned int v254 = 255;
                  if (v25)
                  {
LABEL_513:
                    if (*v58)
                    {
                      int v255 = PDAhardlightPDA_17525(*v63, *v58, *v52, v254);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v255;
                      *uint64_t v58 = HIBYTE(v255);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v254;
                    }
                    goto LABEL_518;
                  }
                }
                char v256 = PDAhardlightPDA_17525(*v63, 0xFFu, *v52, v254);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v256;
LABEL_518:
                v63 += v519;
                v58 += v251;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v257 = -(uint64_t)v522;
                }
                else {
                  uint64_t v257 = 0;
                }
                v52 += v519 + v257;
                v7 += v252 + v257;
                --v253;
              }
              while (v253);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v258 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v258 = 0;
                }
                char v52 = &v528[v536 + v258];
                uint64_t v259 = v505;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v259 = 0;
                }
                uint64_t v7 = &v530[v524 + v259];
                v22 += v536 + v258;
                v528 += v536 + v258;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 22:
            uint64_t v260 = (int)v25;
            uint64_t v261 = v39;
            uint64_t v506 = -(v38 * v520);
            while (1)
            {
              int v262 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v263 = *v7;
                  if (!*v7) {
                    goto LABEL_541;
                  }
                  if (v25) {
                    goto LABEL_536;
                  }
                }
                else
                {
                  unsigned int v263 = 255;
                  if (v25)
                  {
LABEL_536:
                    if (*v58)
                    {
                      int v264 = PDAdifferencePDA_17527(*v63, *v58, *v52, v263);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v264;
                      *uint64_t v58 = HIBYTE(v264);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v263;
                    }
                    goto LABEL_541;
                  }
                }
                char v265 = PDAdifferencePDA_17527(*v63, 0xFFu, *v52, v263);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v265;
LABEL_541:
                v63 += v519;
                v58 += v260;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v266 = -(uint64_t)v522;
                }
                else {
                  uint64_t v266 = 0;
                }
                v52 += v519 + v266;
                v7 += v261 + v266;
                --v262;
              }
              while (v262);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v267 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v267 = 0;
                }
                char v52 = &v528[v536 + v267];
                uint64_t v268 = v506;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v268 = 0;
                }
                uint64_t v7 = &v530[v524 + v268];
                v22 += v536 + v267;
                v528 += v536 + v267;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 23:
            uint64_t v269 = (int)v25;
            uint64_t v270 = v39;
            uint64_t v507 = -(v38 * v520);
            while (1)
            {
              int v271 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v272 = *v7;
                  if (!*v7) {
                    goto LABEL_564;
                  }
                  if (v25) {
                    goto LABEL_559;
                  }
                }
                else
                {
                  unsigned int v272 = 255;
                  if (v25)
                  {
LABEL_559:
                    if (*v58)
                    {
                      int v273 = PDAexclusionPDA_17528(*v63, *v58, *v52, v272);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v273;
                      *uint64_t v58 = HIBYTE(v273);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v272;
                    }
                    goto LABEL_564;
                  }
                }
                char v274 = PDAexclusionPDA_17528(*v63, 0xFFu, *v52, v272);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v274;
LABEL_564:
                v63 += v519;
                v58 += v269;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v275 = -(uint64_t)v522;
                }
                else {
                  uint64_t v275 = 0;
                }
                v52 += v519 + v275;
                v7 += v270 + v275;
                --v271;
              }
              while (v271);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v276 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v276 = 0;
                }
                char v52 = &v528[v536 + v276];
                uint64_t v277 = v507;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v277 = 0;
                }
                uint64_t v7 = &v530[v524 + v277];
                v22 += v536 + v276;
                v528 += v536 + v276;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 24:
            uint64_t v278 = (int)v25;
            uint64_t v279 = v39;
            uint64_t v508 = -(v38 * v520);
            while (1)
            {
              int v280 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v281 = *v7;
                  if (!*v7) {
                    goto LABEL_587;
                  }
                  if (v25) {
                    goto LABEL_582;
                  }
                }
                else
                {
                  unsigned int v281 = 255;
                  if (v25)
                  {
LABEL_582:
                    if (*v58)
                    {
                      int v282 = PDAhuePDA_17529(*v63, *v58, *v52, v281);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v282;
                      *uint64_t v58 = HIBYTE(v282);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v281;
                    }
                    goto LABEL_587;
                  }
                }
                char v283 = PDAhuePDA_17529(*v63, 0xFFu, *v52, v281);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v283;
LABEL_587:
                v63 += v519;
                v58 += v278;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v284 = -(uint64_t)v522;
                }
                else {
                  uint64_t v284 = 0;
                }
                v52 += v519 + v284;
                v7 += v279 + v284;
                --v280;
              }
              while (v280);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v285 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v285 = 0;
                }
                char v52 = &v528[v536 + v285];
                uint64_t v286 = v508;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v286 = 0;
                }
                uint64_t v7 = &v530[v524 + v286];
                v22 += v536 + v285;
                v528 += v536 + v285;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 25:
            uint64_t v287 = (int)v25;
            uint64_t v288 = v39;
            uint64_t v509 = -(v38 * v520);
            while (1)
            {
              int v289 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v290 = *v7;
                  if (!*v7) {
                    goto LABEL_610;
                  }
                  if (v25) {
                    goto LABEL_605;
                  }
                }
                else
                {
                  unsigned int v290 = 255;
                  if (v25)
                  {
LABEL_605:
                    if (*v58)
                    {
                      int v291 = PDAhuePDA_17529(*v63, *v58, *v52, v290);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v291;
                      *uint64_t v58 = HIBYTE(v291);
                    }
                    else
                    {
                      unsigned char *v63 = *v52;
                      *uint64_t v58 = v290;
                    }
                    goto LABEL_610;
                  }
                }
                char v292 = PDAhuePDA_17529(*v63, 0xFFu, *v52, v290);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v292;
LABEL_610:
                v63 += v519;
                v58 += v287;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v293 = -(uint64_t)v522;
                }
                else {
                  uint64_t v293 = 0;
                }
                v52 += v519 + v293;
                v7 += v288 + v293;
                --v289;
              }
              while (v289);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v294 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v294 = 0;
                }
                char v52 = &v528[v536 + v294];
                uint64_t v295 = v509;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v295 = 0;
                }
                uint64_t v7 = &v530[v524 + v295];
                v22 += v536 + v294;
                v528 += v536 + v294;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 26:
            uint64_t v296 = (int)v25;
            uint64_t v297 = v39;
            uint64_t v510 = -(v38 * v520);
            while (1)
            {
              int v298 = v554[0];
              do
              {
                if (v39)
                {
                  unsigned int v299 = *v7;
                  if (!*v7) {
                    goto LABEL_633;
                  }
                  if (v25) {
                    goto LABEL_628;
                  }
                }
                else
                {
                  unsigned int v299 = 255;
                  if (v25)
                  {
LABEL_628:
                    unsigned int v300 = *v52;
                    if (*v58)
                    {
                      int v301 = PDAluminosityPDA_17531(v300, v299, *v63, *v58);
                      int v39 = v540;
                      LODWORD(v25) = v542;
                      unsigned char *v63 = v301;
                      *uint64_t v58 = HIBYTE(v301);
                    }
                    else
                    {
                      unsigned char *v63 = v300;
                      *uint64_t v58 = v299;
                    }
                    goto LABEL_633;
                  }
                }
                char v302 = PDAluminosityPDA_17531(*v52, v299, *v63, 0xFFu);
                int v39 = v540;
                LODWORD(v25) = v542;
                unsigned char *v63 = v302;
LABEL_633:
                v63 += v519;
                v58 += v296;
                if ((unint64_t)&v52[v519] >= v22) {
                  uint64_t v303 = -(uint64_t)v522;
                }
                else {
                  uint64_t v303 = 0;
                }
                v52 += v519 + v303;
                v7 += v297 + v303;
                --v298;
              }
              while (v298);
              if (v526)
              {
                uint64_t v38 = v524;
                uint64_t v304 = -(v536 * v520);
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v304 = 0;
                }
                char v52 = &v528[v536 + v304];
                uint64_t v305 = v510;
                if ((unint64_t)&v528[v536] < v526) {
                  uint64_t v305 = 0;
                }
                uint64_t v7 = &v530[v524 + v305];
                v22 += v536 + v304;
                v528 += v536 + v304;
                int v530 = v7;
              }
              else
              {
                v52 += v536;
                uint64_t v38 = v524;
                v7 += v524;
              }
              v63 += *(void *)v532;
              v58 += v538;
              if (!--v544[0]) {
                goto LABEL_668;
              }
            }
          case 27:
            uint64_t v306 = (int)v25;
            uint64_t v307 = v39;
            uint64_t v511 = -(v38 * v520);
            break;
          default:
            goto LABEL_669;
        }
        break;
      }
LABEL_647:
      int v308 = v554[0];
      while (1)
      {
        if (v39)
        {
          unsigned int v309 = *v7;
          if (!*v7) {
            goto LABEL_656;
          }
          if (!v25) {
            goto LABEL_654;
          }
        }
        else
        {
          unsigned int v309 = 255;
          if (!v25)
          {
LABEL_654:
            char v311 = PDAluminosityPDA_17531(*v63, 0xFFu, *v52, v309);
            int v39 = v540;
            LODWORD(v25) = v542;
            unsigned char *v63 = v311;
            goto LABEL_656;
          }
        }
        if (*v58)
        {
          int v310 = PDAluminosityPDA_17531(*v63, *v58, *v52, v309);
          int v39 = v540;
          LODWORD(v25) = v542;
          unsigned char *v63 = v310;
          *uint64_t v58 = HIBYTE(v310);
        }
        else
        {
          unsigned char *v63 = *v52;
          *uint64_t v58 = v309;
        }
LABEL_656:
        v63 += v519;
        v58 += v306;
        if ((unint64_t)&v52[v519] >= v22) {
          uint64_t v312 = -(uint64_t)v522;
        }
        else {
          uint64_t v312 = 0;
        }
        v52 += v519 + v312;
        v7 += v307 + v312;
        if (!--v308)
        {
          if (v526)
          {
            uint64_t v38 = v524;
            uint64_t v313 = -(v536 * v520);
            if ((unint64_t)&v528[v536] < v526) {
              uint64_t v313 = 0;
            }
            char v52 = &v528[v536 + v313];
            uint64_t v314 = v511;
            if ((unint64_t)&v528[v536] < v526) {
              uint64_t v314 = 0;
            }
            uint64_t v7 = &v530[v524 + v314];
            v22 += v536 + v313;
            v528 += v536 + v313;
            int v530 = v7;
          }
          else
          {
            v52 += v536;
            uint64_t v38 = v524;
            v7 += v524;
          }
          v63 += *(void *)v532;
          v58 += v538;
          if (!--v544[0])
          {
LABEL_668:
            uint64_t v11 = v512;
            int v9 = v513;
            goto LABEL_669;
          }
          goto LABEL_647;
        }
      }
    }
    unint64_t v59 = v54 * (int)v12;
    uint64_t v538 = v517 - (int)v25 * (int)v12;
    unint64_t v22 = -1;
    int v519 = v54;
    int v520 = v38;
    int v522 = v37;
    goto LABEL_62;
  }
  int v17 = *(_DWORD *)(v3 + 128);
  if ((v17 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      W8_mark_constmask(v3, v9);
    }
    else {
      W8_mark_pixelmask(v3, v9);
    }
    return 1;
  }
  int v26 = *(_DWORD *)(v3 + 112);
  int v27 = *(_DWORD *)(v3 + 116);
  unsigned int v28 = (v26 + 15) & 0xFFFFFFF0;
  size_t v29 = v28 * v27;
  if ((int)v29 <= 4096)
  {
    uint64_t v31 = v554;
    goto LABEL_38;
  }
  uint64_t v30 = malloc_type_malloc(v29, 0x8303D2FuLL);
  if (v30)
  {
    uint64_t v31 = v30;
    uint64_t v16 = *(uint16x4_t **)(v11 + 136);
    int v17 = *(_DWORD *)(v11 + 128);
LABEL_38:
    CGSConvertBitsToMask(v16, *(_DWORD *)(v11 + 124), v31, v28, v26, v27, v17);
    long long v46 = *(_OWORD *)(v11 + 112);
    long long v550 = *(_OWORD *)(v11 + 96);
    long long v551 = v46;
    long long v47 = *(_OWORD *)(v11 + 144);
    long long v552 = *(_OWORD *)(v11 + 128);
    long long v553 = v47;
    long long v48 = *(_OWORD *)(v11 + 48);
    long long v546 = *(_OWORD *)(v11 + 32);
    long long v547 = v48;
    long long v49 = *(_OWORD *)(v11 + 80);
    long long v548 = *(_OWORD *)(v11 + 64);
    long long v549 = v49;
    long long v50 = *(_OWORD *)(v11 + 16);
    *(_OWORD *)int v544 = *(_OWORD *)v11;
    long long v545 = v50;
    HIDWORD(v551) = (v26 + 15) & 0xFFFFFFF0;
    *((void *)&v552 + 1) = v31;
    if (BYTE1(v544[0]) << 8 == 1024) {
      W8_mark_constmask((uint64_t)v544, v9);
    }
    else {
      W8_mark_pixelmask((uint64_t)v544, v9);
    }
    if (v31 == (unsigned char *)v554) {
      return 1;
    }
    uint64_t v51 = v31;
    goto LABEL_1165;
  }
  return 1;
}

uint64_t W8_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  int8x8_t v4 = *(unsigned __int8 **)(a1 + 96);
  if (v4) {
    unsigned int v5 = *v4 << 24;
  }
  else {
    unsigned int v5 = -16777216;
  }
  int v7 = *(_DWORD *)(a1 + 4);
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v254 = *(int *)(a1 + 28);
  uint64_t v8 = *(void *)(a1 + 136);
  uint64_t v250 = *(void *)(a1 + 40);
  int v9 = **(unsigned __int8 **)(a1 + 88);
  unsigned int v10 = v5 | v9;
  pthread_mutex_lock(&W8_cacheColorLock);
  uint64_t v11 = W8_cacheColor;
  int v252 = v7;
  if (!W8_cacheColor || *(_DWORD *)(W8_cacheColor + 16) != v10)
  {
    uint64_t v14 = 0;
    while (1)
    {
      if (!v11) {
        goto LABEL_12;
      }
      uint64_t v15 = (void *)v14;
      uint64_t v14 = v11;
      if (*(_DWORD *)(v11 + 16) == v10) {
        break;
      }
      uint64_t v11 = *(void *)v11;
      if (!*(void *)v14)
      {
        if (W8_cacheColorCount > 6)
        {
          *uint64_t v15 = 0;
        }
        else
        {
LABEL_12:
          uint64_t v16 = (char *)W8_cacheColorBase;
          if (W8_cacheColorBase)
          {
            unsigned int v17 = W8_cacheColorCount;
          }
          else
          {
            uint64_t v16 = (char *)malloc_type_calloc(1uLL, 0x1CA8uLL, 0x10200408056D5EBuLL);
            unsigned int v17 = 0;
            W8_cacheColorBase = (uint64_t)v16;
          }
          uint64_t v14 = (uint64_t)&v16[24 * v17];
          *(void *)(v14 + 8) = &v16[1024 * (unint64_t)v17 + 168];
          W8_cacheColorCFIndex Count = v17 + 1;
        }
        uint64_t v18 = 0;
        *(void *)uint64_t v14 = W8_cacheColor;
        W8_cacheColor = v14;
        *(_DWORD *)(v14 + 16) = v10;
        uint64_t v20 = *(void *)(v14 + 8);
        uint64_t v13 = v14 + 8;
        uint64_t v19 = v20;
        int32x4_t v21 = vdupq_n_s32(v9 | (v5 >> 8));
        int32x4_t v22 = (int32x4_t)xmmword_1850CDC50;
        int32x4_t v23 = vdupq_n_s32(v10);
        v24.i64[0] = 0xFF000000FFLL;
        v24.i64[1] = 0xFF000000FFLL;
        v25.i64[0] = 0x1000100010001;
        v25.i64[1] = 0x1000100010001;
        v26.i64[0] = 0xFF000000FF000000;
        v26.i64[1] = 0xFF000000FF000000;
        v27.i64[0] = 0x400000004;
        v27.i64[1] = 0x400000004;
        do
        {
          int32x4_t v28 = vmulq_s32((int32x4_t)veorq_s8((int8x16_t)v22, v24), v21);
          int8x16_t v29 = (int8x16_t)vaddq_s32(vaddq_s32(v28, v25), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v28, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)));
          *(int32x4_t *)(v19 + v18) = vsubq_s32(v23, (int32x4_t)vorrq_s8(vandq_s8(v29, v26), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v29, 8uLL), v24)));
          int32x4_t v22 = vaddq_s32(v22, v27);
          v18 += 16;
        }
        while (v18 != 1024);
        uint64_t result = pthread_mutex_unlock(&W8_cacheColorLock);
        goto LABEL_23;
      }
    }
    if (v15)
    {
      *uint64_t v15 = *(void *)v11;
      *(void *)uint64_t v11 = W8_cacheColor;
      W8_cacheColor = v11;
    }
  }
  uint64_t result = pthread_mutex_unlock(&W8_cacheColorLock);
  uint64_t v13 = v11 + 8;
LABEL_23:
  uint64_t v30 = *(void *)v13;
  unsigned int v31 = *(_DWORD *)(*(void *)v13 + 1020);
  uint64_t v33 = *(int *)(a1 + 12);
  int v32 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    uint64_t v34 = *(int *)(a1 + 32);
    int v35 = (unsigned __int8 *)(v3 + v33 + (int)v34 * (uint64_t)v32);
    uint64_t v36 = 1;
  }
  else
  {
    int v35 = 0;
    uint64_t v34 = 0;
    uint64_t v36 = 0;
  }
  if (v8)
  {
    uint64_t v37 = v34 - v252;
    if (v3) {
      v34 -= v252;
    }
    uint64_t v253 = v34;
    unsigned int v38 = HIBYTE(v31);
    int v39 = (unsigned __int8 *)(v250 + v33 + v32 * (uint64_t)(int)v254);
    uint64_t v40 = *(int *)(a1 + 124);
    unint64_t v41 = v8 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v40;
    uint64_t v42 = v40 - v252;
    uint64_t v255 = v254 - v252;
    switch(a2)
    {
      case 0:
        if (v3)
        {
          do
          {
            int v43 = v252;
            do
            {
              int v44 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                if (v44 == 255)
                {
                  LOBYTE(v45) = 0;
                  *int v39 = 0;
                }
                else
                {
                  int v46 = *v39;
                  int v47 = *v35;
                  unsigned int v48 = (v46 | (v47 << 16)) * v44
                      + 65537
                      + ((((v46 | (v47 << 16)) * v44) >> 8) & 0xFF00FF);
                  int v49 = v46 | (v47 << 24);
                  *int v39 = v49 - BYTE1(v48);
                  unsigned int v45 = (v49 - (v48 & 0xFF000000 | BYTE1(v48))) >> 24;
                }
                *int v35 = v45;
              }
              ++v41;
              ++v39;
              v35 += v36;
              --v43;
            }
            while (v43);
            v41 += v42;
            v39 += v255;
            v35 += v253;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v80 = v252;
            do
            {
              int v81 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                if (v81 == 255) {
                  LOBYTE(v82) = 0;
                }
                else {
                  unsigned int v82 = *v39 - ((*v39 * v81 + ((*v39 * v81) >> 8) + 1) >> 8);
                }
                *int v39 = v82;
              }
              ++v41;
              ++v39;
              --v80;
            }
            while (v80);
            v41 += v42;
            v39 += v255;
            --v6;
          }
          while (v6);
        }
        return result;
      case 1:
        unsigned int v83 = v41 & 3;
        if (!v3)
        {
          int v165 = -1 << (8 * v83);
          if ((v41 & 3) != 0) {
            char v166 = v41 & 0xFC;
          }
          else {
            char v166 = v41;
          }
          if ((v41 & 3) != 0)
          {
            int v167 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            int v165 = -1;
            int v167 = (unsigned int *)v41;
          }
          if ((v41 & 3) != 0) {
            uint64_t v168 = &v39[-(v41 & 3)];
          }
          else {
            uint64_t v168 = v39;
          }
          if ((v41 & 3) != 0) {
            int v169 = v83 + v252;
          }
          else {
            int v169 = v252;
          }
          if ((((_BYTE)v169 + v166) & 3) != 0)
          {
            int v170 = 4 - (((_BYTE)v169 + v166) & 3);
            v83 += v170;
            unsigned int v171 = 0xFFFFFFFF >> (8 * v170);
            if (v169 >= 4) {
              uint64_t v172 = v171;
            }
            else {
              uint64_t v172 = 0;
            }
            if (v169 >= 4) {
              unsigned int v171 = -1;
            }
            v165 &= v171;
          }
          else
          {
            uint64_t v172 = 0;
          }
          uint64_t v229 = v42 - v83;
          int v230 = v169 >> 2;
          uint64_t v231 = v255 - v83;
          while (1)
          {
            unsigned int v232 = *v167 & v165;
            int v233 = v230;
            uint64_t result = v172;
            if (!v232) {
              goto LABEL_475;
            }
LABEL_457:
            if (v232 == -1)
            {
              *(_DWORD *)uint64_t v168 = 16843009 * v31;
              goto LABEL_475;
            }
            while (1)
            {
              if ((_BYTE)v232)
              {
                LOBYTE(v234) = v31;
                if (v232 != 255) {
                  unsigned int v234 = *(_DWORD *)(v30 + 4 * v232)
                }
                       + (((v232 ^ 0xFF) * *v168
                         + (((v232 ^ 0xFF) * *v168) >> 8)
                         + 1) >> 8);
                *uint64_t v168 = v234;
              }
              if (BYTE1(v232))
              {
                LOBYTE(v235) = v31;
                if (BYTE1(v232) != 255) {
                  unsigned int v235 = *(_DWORD *)(v30 + 4 * BYTE1(v232))
                }
                       + (((BYTE1(v232) ^ 0xFF) * v168[1] + (((BYTE1(v232) ^ 0xFF) * v168[1]) >> 8) + 1) >> 8);
                v168[1] = v235;
              }
              if (BYTE2(v232))
              {
                LOBYTE(v236) = v31;
                if (BYTE2(v232) != 255) {
                  unsigned int v236 = *(_DWORD *)(v30 + 4 * BYTE2(v232))
                }
                       + (((BYTE2(v232) ^ 0xFF) * v168[2] + (((BYTE2(v232) ^ 0xFF) * v168[2]) >> 8) + 1) >> 8);
                v168[2] = v236;
              }
              unsigned int v237 = HIBYTE(v232);
              if (v237 == 255)
              {
                v168[3] = v31;
              }
              else if (v237)
              {
                v168[3] = *(unsigned char *)(v30 + 4 * v237)
                        + ((unsigned __int16)((v237 ^ 0xFF) * v168[3] + (((v237 ^ 0xFF) * v168[3]) >> 8) + 1) >> 8);
              }
LABEL_475:
              while (1)
              {
                int v238 = v233;
                v168 += 4;
                --v233;
                ++v167;
                if (v238 < 2) {
                  break;
                }
                unsigned int v232 = *v167;
                if (*v167) {
                  goto LABEL_457;
                }
              }
              if (!result) {
                break;
              }
              uint64_t result = 0;
              unsigned int v232 = *v167 & v172;
            }
            int v167 = (unsigned int *)((char *)v167 + v229);
            v168 += v231;
            if (!--v6) {
              return result;
            }
          }
        }
        int v84 = -1 << (8 * v83);
        uint64_t v85 = &v39[-(v41 & 3)];
        if ((v41 & 3) != 0) {
          char v86 = v41 & 0xFC;
        }
        else {
          char v86 = v41;
        }
        if ((v41 & 3) != 0)
        {
          uint64_t v87 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v84 = -1;
          uint64_t v87 = (unsigned int *)v41;
        }
        if ((v41 & 3) != 0) {
          uint64_t v88 = &v35[-(v41 & 3)];
        }
        else {
          uint64_t v88 = v35;
        }
        if ((v41 & 3) != 0)
        {
          int v89 = v83 + v252;
        }
        else
        {
          uint64_t v85 = v39;
          int v89 = v252;
        }
        if ((((_BYTE)v89 + v86) & 3) != 0)
        {
          int v90 = 4 - (((_BYTE)v89 + v86) & 3);
          v83 += v90;
          unsigned int v91 = 0xFFFFFFFF >> (8 * v90);
          if (v89 >= 4) {
            unsigned int v92 = v91;
          }
          else {
            unsigned int v92 = 0;
          }
          if (v89 >= 4) {
            unsigned int v91 = -1;
          }
          v84 &= v91;
        }
        else
        {
          unsigned int v92 = 0;
        }
        uint64_t v181 = v42 - v83;
        uint64_t result = v255 - v83;
        int v182 = v89 >> 2;
        uint64_t v183 = v37 - v83;
        do
        {
          unsigned int v184 = *v87 & v84;
          int v185 = v182;
          unsigned int v186 = v92;
          if (!v184) {
            goto LABEL_426;
          }
LABEL_405:
          if (v184 == -1)
          {
            *uint64_t v85 = v31;
            *uint64_t v88 = HIBYTE(v31);
            v85[1] = v31;
            v88[1] = HIBYTE(v31);
            v85[2] = v31;
            v88[2] = HIBYTE(v31);
LABEL_423:
            v85[3] = v31;
            v88[3] = HIBYTE(v31);
            goto LABEL_426;
          }
          while (1)
          {
            if ((_BYTE)v184)
            {
              if (v184 == 255)
              {
                *uint64_t v85 = v31;
                unsigned int v187 = HIBYTE(v31);
              }
              else
              {
                int v188 = *(_DWORD *)(v30 + 4 * v184);
                unsigned int v189 = (*v85 | (*v88 << 16)) * (v184 ^ 0xFF);
                *uint64_t v85 = ((unsigned __int16)(v189 + 1 + BYTE1(v189)) >> 8) + v188;
                unsigned int v187 = (((v189 + 65537 + ((v189 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v189 + 1 + BYTE1(v189)) >> 8))
                      + (v188 & 0xFF0000FF)) >> 24;
              }
              *uint64_t v88 = v187;
            }
            if (BYTE1(v184))
            {
              if (BYTE1(v184) == 255)
              {
                v85[1] = v31;
                unsigned int v190 = HIBYTE(v31);
              }
              else
              {
                int v191 = *(_DWORD *)(v30 + 4 * BYTE1(v184));
                unsigned int v192 = (v85[1] | (v88[1] << 16)) * (BYTE1(v184) ^ 0xFF);
                v85[1] = ((unsigned __int16)(v192 + 1 + BYTE1(v192)) >> 8) + v191;
                unsigned int v190 = (((v192 + 65537 + ((v192 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v192 + 1 + BYTE1(v192)) >> 8))
                      + (v191 & 0xFF0000FF)) >> 24;
              }
              v88[1] = v190;
            }
            if (BYTE2(v184))
            {
              if (BYTE2(v184) == 255)
              {
                v85[2] = v31;
                unsigned int v193 = HIBYTE(v31);
              }
              else
              {
                int v194 = *(_DWORD *)(v30 + 4 * BYTE2(v184));
                unsigned int v195 = (v85[2] | (v88[2] << 16)) * (BYTE2(v184) ^ 0xFF);
                v85[2] = ((unsigned __int16)(v195 + 1 + BYTE1(v195)) >> 8) + v194;
                unsigned int v193 = (((v195 + 65537 + ((v195 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v195 + 1 + BYTE1(v195)) >> 8))
                      + (v194 & 0xFF0000FF)) >> 24;
              }
              v88[2] = v193;
            }
            unsigned int v196 = HIBYTE(v184);
            if (v196 == 255) {
              goto LABEL_423;
            }
            if (v196)
            {
              int v197 = *(_DWORD *)(v30 + 4 * v196);
              unsigned int v198 = (v85[3] | (v88[3] << 16)) * (v196 ^ 0xFF);
              v85[3] = ((unsigned __int16)(v198 + 1 + BYTE1(v198)) >> 8) + v197;
              v88[3] = (((v198 + 65537 + ((v198 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v198 + 1 + BYTE1(v198)) >> 8))
                      + (v197 & 0xFF0000FF)) >> 24;
            }
LABEL_426:
            while (1)
            {
              int v199 = v185;
              v85 += 4;
              v88 += 4;
              --v185;
              ++v87;
              if (v199 < 2) {
                break;
              }
              unsigned int v184 = *v87;
              if (*v87) {
                goto LABEL_405;
              }
            }
            if (!v186) {
              break;
            }
            unsigned int v186 = 0;
            unsigned int v184 = *v87 & v92;
          }
          uint64_t v87 = (unsigned int *)((char *)v87 + v181);
          v85 += result;
          v88 += v183;
          --v6;
        }
        while (v6);
        return result;
      case 2:
        unsigned int v93 = v41 & 3;
        if (v3)
        {
          int v94 = -1 << (8 * v93);
          uint64_t v95 = &v39[-(v41 & 3)];
          if ((v41 & 3) != 0) {
            char v96 = v41 & 0xFC;
          }
          else {
            char v96 = v41;
          }
          if ((v41 & 3) != 0)
          {
            uint64_t v97 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            int v94 = -1;
            uint64_t v97 = (unsigned int *)v41;
          }
          if ((v41 & 3) != 0) {
            uint64_t v98 = &v35[-(v41 & 3)];
          }
          else {
            uint64_t v98 = v35;
          }
          if ((v41 & 3) != 0)
          {
            int v99 = v93 + v252;
          }
          else
          {
            uint64_t v95 = v39;
            int v99 = v252;
          }
          if ((((_BYTE)v99 + v96) & 3) != 0)
          {
            int v100 = 4 - (((_BYTE)v99 + v96) & 3);
            v93 += v100;
            unsigned int v101 = 0xFFFFFFFF >> (8 * v100);
            if (v99 >= 4) {
              unsigned int v102 = v101;
            }
            else {
              unsigned int v102 = 0;
            }
            if (v99 >= 4) {
              unsigned int v101 = -1;
            }
            v94 &= v101;
          }
          else
          {
            unsigned int v102 = 0;
          }
          uint64_t v200 = v42 - v93;
          uint64_t v201 = v255 - v93;
          uint64_t result = (v99 >> 2);
          int v202 = ~HIBYTE(v31);
          unsigned int v203 = v31 & 0xFF0000FF;
          uint64_t v204 = v37 - v93;
          while (1)
          {
            unsigned int v205 = *v97 & v94;
            int v206 = result;
            unsigned int v207 = v102;
            if (!v205) {
              goto LABEL_447;
            }
LABEL_436:
            if (v205 == -1) {
              break;
            }
            while (1)
            {
              if ((_BYTE)v205)
              {
                int v216 = *(_DWORD *)(v30 + 4 * v205);
                unsigned int v217 = (*v95 | (*v98 << 16)) * (~v216 >> 24);
                unsigned int v218 = ((v217 + 65537 + ((v217 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v217 + 1 + BYTE1(v217)) >> 8))
                     + (v216 & 0xFF0000FF);
                unsigned __int8 *v95 = v218;
                *uint64_t v98 = HIBYTE(v218);
              }
              if ((v205 & 0xFF00) != 0)
              {
                int v219 = *(_DWORD *)(v30 + 4 * BYTE1(v205));
                unsigned int v220 = (v95[1] | (v98[1] << 16)) * (~v219 >> 24);
                unsigned int v221 = ((v220 + 65537 + ((v220 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v220 + 1 + BYTE1(v220)) >> 8))
                     + (v219 & 0xFF0000FF);
                v95[1] = v221;
                v98[1] = HIBYTE(v221);
              }
              if ((v205 & 0xFF0000) != 0)
              {
                int v222 = *(_DWORD *)(v30 + 4 * BYTE2(v205));
                unsigned int v223 = (v95[2] | (v98[2] << 16)) * (~v222 >> 24);
                unsigned int v224 = ((v223 + 65537 + ((v223 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v223 + 1 + BYTE1(v223)) >> 8))
                     + (v222 & 0xFF0000FF);
                v95[2] = v224;
                v98[2] = HIBYTE(v224);
              }
              unsigned int v225 = HIBYTE(v205);
              if (v225)
              {
                int v226 = *(_DWORD *)(v30 + 4 * v225);
                unsigned int v227 = (v95[3] | (v98[3] << 16)) * (~v226 >> 24);
                unsigned int v215 = ((v227 + 65537 + ((v227 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v227 + 1 + BYTE1(v227)) >> 8))
                     + (v226 & 0xFF0000FF);
                goto LABEL_446;
              }
LABEL_447:
              while (1)
              {
                int v228 = v206;
                v95 += 4;
                v98 += 4;
                --v206;
                ++v97;
                if (v228 < 2) {
                  break;
                }
                unsigned int v205 = *v97;
                if (*v97) {
                  goto LABEL_436;
                }
              }
              if (!v207) {
                break;
              }
              unsigned int v207 = 0;
              unsigned int v205 = *v97 & v102;
            }
            uint64_t v97 = (unsigned int *)((char *)v97 + v200);
            v95 += v201;
            v98 += v204;
            if (!--v6) {
              return result;
            }
          }
          unsigned int v208 = (*v95 | (*v98 << 16)) * v202;
          unsigned int v209 = ((v208 + 65537 + ((v208 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v208 + 1 + BYTE1(v208)) >> 8))
               + v203;
          unsigned __int8 *v95 = v209;
          *uint64_t v98 = HIBYTE(v209);
          unsigned int v210 = (v95[1] | (v98[1] << 16)) * v202;
          unsigned int v211 = ((v210 + 65537 + ((v210 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v210 + 1 + BYTE1(v210)) >> 8))
               + v203;
          v95[1] = v211;
          v98[1] = HIBYTE(v211);
          unsigned int v212 = (v95[2] | (v98[2] << 16)) * v202;
          unsigned int v213 = ((v212 + 65537 + ((v212 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v212 + 1 + BYTE1(v212)) >> 8))
               + v203;
          v95[2] = v213;
          v98[2] = HIBYTE(v213);
          unsigned int v214 = (v95[3] | (v98[3] << 16)) * v202;
          unsigned int v215 = ((v214 + 65537 + ((v214 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v214 + 1 + BYTE1(v214)) >> 8))
               + v203;
LABEL_446:
          v95[3] = v215;
          v98[3] = HIBYTE(v215);
          goto LABEL_447;
        }
        int v173 = -1 << (8 * v93);
        if ((v41 & 3) != 0) {
          char v174 = v41 & 0xFC;
        }
        else {
          char v174 = v41;
        }
        if ((v41 & 3) != 0)
        {
          int v175 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v173 = -1;
          int v175 = (unsigned int *)v41;
        }
        if ((v41 & 3) != 0) {
          uint64_t v176 = &v39[-(v41 & 3)];
        }
        else {
          uint64_t v176 = v39;
        }
        if ((v41 & 3) != 0) {
          int v177 = v93 + v252;
        }
        else {
          int v177 = v252;
        }
        if ((((_BYTE)v177 + v174) & 3) != 0)
        {
          int v178 = 4 - (((_BYTE)v177 + v174) & 3);
          v93 += v178;
          unsigned int v179 = 0xFFFFFFFF >> (8 * v178);
          if (v177 >= 4) {
            unsigned int v180 = -1;
          }
          else {
            unsigned int v180 = 0xFFFFFFFF >> (8 * v178);
          }
          v173 &= v180;
          if (v177 < 4) {
            unsigned int v179 = 0;
          }
        }
        else
        {
          unsigned int v179 = 0;
        }
        uint64_t v239 = v42 - v93;
        int v240 = v177 >> 2;
        int v241 = ~HIBYTE(v31);
        uint64_t v242 = v255 - v93;
        break;
      case 3:
        do
        {
          int v103 = v252;
          do
          {
            int v104 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              if (v104 == 255)
              {
                unsigned int v105 = *(_DWORD *)(v30 + 4 * *v35);
              }
              else
              {
                int v106 = *v35;
                int v107 = *(_DWORD *)(v30 + 4 * ((v106 * v104 + ((v106 * v104) >> 8) + 1) >> 8));
                unsigned int v108 = (*v39 | (v106 << 16)) * (v104 ^ 0xFF)
                     + 65537
                     + ((((*v39 | (v106 << 16)) * (v104 ^ 0xFFu)) >> 8) & 0xFF00FF);
                unsigned int v105 = (v108 & 0xFF000000 | BYTE1(v108)) + (v107 & 0xFF0000FF);
              }
              *int v39 = v105;
              *int v35 = HIBYTE(v105);
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v103;
          }
          while (v103);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 4:
        do
        {
          int v109 = v252;
          do
          {
            int v110 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              if (v110 == 255)
              {
                unsigned int v111 = *(_DWORD *)(v30 + 4 * ~*v35);
              }
              else
              {
                int v112 = *v35;
                int v113 = *(_DWORD *)(v30 + 4 * (((v112 ^ 0xFF) * v110 + (((v112 ^ 0xFFu) * v110) >> 8) + 1) >> 8));
                unsigned int v114 = (*v39 | (v112 << 16)) * (v110 ^ 0xFF)
                     + 65537
                     + ((((*v39 | (v112 << 16)) * (v110 ^ 0xFFu)) >> 8) & 0xFF00FF);
                unsigned int v111 = (v114 & 0xFF000000 | BYTE1(v114)) + (v113 & 0xFF0000FF);
              }
              *int v39 = v111;
              *int v35 = HIBYTE(v111);
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v109;
          }
          while (v109);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 5:
        do
        {
          int v115 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              unsigned int v116 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v117 = (v116 | (HIBYTE(v116) << 16)) * *v35
                   + (*v39 | (*v35 << 16)) * (HIBYTE(v116) ^ 0xFF);
              int v118 = v117 + 65537 + ((v117 >> 8) & 0xFF00FF);
              *int v39 = BYTE1(v118);
              *int v35 = HIBYTE(v118);
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v115;
          }
          while (v115);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 6:
        do
        {
          int v119 = v252;
          do
          {
            uint64_t v120 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              int v121 = *v35;
              if ((_BYTE)v121 != 0xFF)
              {
                if (~(_BYTE)v121 == 255)
                {
                  unsigned int v122 = *(_DWORD *)(v30 + 4 * v120);
                }
                else
                {
                  unsigned int v123 = (*(_DWORD *)(v30 + 4 * v120) | (HIBYTE(*(_DWORD *)(v30 + 4 * v120)) << 16))
                       * ~(_BYTE)v121;
                  unsigned int v122 = ((v123 + 65537 + ((v123 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v123 + 1 + BYTE1(v123)) >> 8))
                       + (*v39 | (v121 << 24));
                }
                *int v39 = v122;
                *int v35 = HIBYTE(v122);
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v119;
          }
          while (v119);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 7:
        if (v3)
        {
          do
          {
            int v124 = v252;
            do
            {
              int v125 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                int v126 = *v39;
                int v127 = *v35;
                if (v125 == 255) {
                  unsigned int v128 = (v126 | (v127 << 16)) * (v38 ^ 0xFF);
                }
                else {
                  unsigned int v128 = (v126 | (v127 << 16))
                }
                       * (v125 - ((unsigned __int16)(v38 * v125 + ((v38 * v125) >> 8) + 1) >> 8));
                unsigned int v129 = (v126 | (v127 << 24))
                     - ((v128 + 65537 + ((v128 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v128 + 1 + BYTE1(v128)) >> 8));
                *int v39 = v129;
                *int v35 = HIBYTE(v129);
              }
              ++v41;
              ++v39;
              v35 += v36;
              --v124;
            }
            while (v124);
            v41 += v42;
            v39 += v255;
            v35 += v253;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v130 = v252;
            do
            {
              int v131 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                if (v131 == 255)
                {
                  LOBYTE(v132) = *v39;
                  int v133 = v38 ^ 0xFF;
                }
                else
                {
                  int v133 = *v39;
                  int v132 = v131 - ((v38 * v131 + ((v38 * v131) >> 8) + 1) >> 8);
                }
                *v39 -= (unsigned __int16)(v133 * v132
                                         + ((v133 * v132) >> 8)
                                         + 1) >> 8;
              }
              ++v41;
              ++v39;
              --v130;
            }
            while (v130);
            v41 += v42;
            v39 += v255;
            --v6;
          }
          while (v6);
        }
        return result;
      case 8:
        if (v3)
        {
          do
          {
            int v134 = v252;
            do
            {
              int v135 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                int v136 = *v39;
                int v137 = *v35;
                if (v135 == 255) {
                  unsigned int v138 = (v136 | (v137 << 16)) * v38;
                }
                else {
                  unsigned int v138 = (v136 | (v137 << 16))
                }
                       * ((unsigned __int16)(v38 * v135 + ((v38 * v135) >> 8) + 1) >> 8);
                unsigned int v139 = (v136 | (v137 << 24))
                     - ((v138 + 65537 + ((v138 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v138 + 1 + BYTE1(v138)) >> 8));
                *int v39 = v139;
                *int v35 = HIBYTE(v139);
              }
              ++v41;
              ++v39;
              v35 += v36;
              --v134;
            }
            while (v134);
            v41 += v42;
            v39 += v255;
            v35 += v253;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v140 = v252;
            do
            {
              int v141 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                int v142 = *v39;
                if (v141 == 255) {
                  unsigned int v143 = v38 * v142;
                }
                else {
                  unsigned int v143 = ((unsigned __int16)(v38 * v141 + ((v38 * v141) >> 8) + 1) >> 8) * v142;
                }
                *int v39 = v142 - ((unsigned __int16)(v143 + (v143 >> 8) + 1) >> 8);
              }
              ++v41;
              ++v39;
              --v140;
            }
            while (v140);
            v41 += v42;
            v39 += v255;
            --v6;
          }
          while (v6);
        }
        return result;
      case 9:
        do
        {
          int v144 = v252;
          do
          {
            uint64_t v145 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              int v146 = *v35;
              unsigned int v147 = *(_DWORD *)(v30 + 4 * v145);
              unsigned int v148 = (v147 | (HIBYTE(v147) << 16)) * (v146 ^ 0xFF)
                   + (*v39 | (v146 << 16)) * (~(_BYTE)v145 + HIBYTE(v147))
                   + 65537
                   + ((((v147 | (HIBYTE(v147) << 16)) * (v146 ^ 0xFF)
                                    + (*v39 | (v146 << 16)) * (~(_BYTE)v145 + HIBYTE(v147))) >> 8) & 0xFF00FF);
              *int v39 = BYTE1(v148);
              *int v35 = HIBYTE(v148);
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v144;
          }
          while (v144);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 10:
        do
        {
          int v149 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              unsigned int v150 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v151 = (v150 | (HIBYTE(v150) << 16)) * (*v35 ^ 0xFF)
                   + (*v39 | (*v35 << 16)) * (HIBYTE(v150) ^ 0xFF);
              int v152 = v151 + 65537 + ((v151 >> 8) & 0xFF00FF);
              *int v39 = BYTE1(v152);
              *int v35 = HIBYTE(v152);
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v149;
          }
          while (v149);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 11:
        if (v3)
        {
          do
          {
            int v153 = v252;
            do
            {
              if (*(unsigned char *)v41)
              {
                unsigned int v154 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
                unsigned int v155 = ((HIBYTE(v154) - v154) | (HIBYTE(v154) << 16))
                     + (*v35 - *v39)
                     + (*v35 << 16);
                int v156 = (255 * ((v155 >> 8) & 0x10001)) | v155;
                *int v39 = BYTE2(v156) - v156;
                *int v35 = BYTE2(v156);
              }
              ++v41;
              ++v39;
              v35 += v36;
              --v153;
            }
            while (v153);
            v41 += v42;
            v39 += v255;
            v35 += v253;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v157 = v252;
            do
            {
              if (*(unsigned char *)v41)
              {
                int v158 = (*v39 ^ 0xFF)
                     - *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41)
                     + HIBYTE(*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41));
                char v159 = BYTE1(v158) | (2 * BYTE1(v158)) | (4 * (BYTE1(v158) | (2 * BYTE1(v158))));
                *int v39 = ~((~*v39
                        - *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41)
                        + HIBYTE(*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41))) | (16 * v159) | v159);
              }
              ++v41;
              ++v39;
              --v157;
            }
            while (v157);
            v41 += v42;
            v39 += v255;
            --v6;
          }
          while (v6);
        }
        return result;
      case 12:
        if (v3)
        {
          do
          {
            int v160 = v252;
            do
            {
              if (*(unsigned char *)v41)
              {
                unsigned int v161 = (*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41) | (HIBYTE(*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41)) << 16))
                     + (*v39 | (*v35 << 16));
                int v162 = (255 * ((v161 >> 8) & 0x10001)) | v161;
                *int v39 = v162;
                *int v35 = BYTE2(v162);
              }
              ++v41;
              ++v39;
              v35 += v36;
              --v160;
            }
            while (v160);
            v41 += v42;
            v39 += v255;
            v35 += v253;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v163 = v252;
            do
            {
              if (*(unsigned char *)v41)
              {
                unsigned int v164 = *(unsigned __int8 *)(v30 + 4 * *(unsigned __int8 *)v41) + *v39;
                *int v39 = -(v164 >> 8) | v164;
              }
              ++v41;
              ++v39;
              --v163;
            }
            while (v163);
            v41 += v42;
            v39 += v255;
            --v6;
          }
          while (v6);
        }
        return result;
      case 13:
        do
        {
          int v50 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v51 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAmultiplyPDA_17518(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v51);
                    unsigned int v51 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v51;
                }
                else
                {
                  uint64_t result = PDAmultiplyPDA_17518(*v39, 255, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v51);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v50;
          }
          while (v50);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 14:
        do
        {
          int v52 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v53 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAscreenPDA_17519(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v53);
                    unsigned int v53 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v53;
                }
                else
                {
                  uint64_t result = PDAscreenPDA_17519(*v39, 255, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v53);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v52;
          }
          while (v52);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 15:
        do
        {
          int v54 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v55 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAoverlayPDA_17520(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v55);
                    unsigned int v55 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v55;
                }
                else
                {
                  uint64_t result = PDAoverlayPDA_17520(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v55);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v54;
          }
          while (v54);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 16:
        do
        {
          int v56 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v57 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAdarkenPDA_17522(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v57);
                    unsigned int v57 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v57;
                }
                else
                {
                  uint64_t result = PDAdarkenPDA_17522(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v57);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v56;
          }
          while (v56);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 17:
        do
        {
          int v58 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v59 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAlightenPDA_17521(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v59);
                    unsigned int v59 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v59;
                }
                else
                {
                  uint64_t result = PDAlightenPDA_17521(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v59);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v58;
          }
          while (v58);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 18:
        do
        {
          int v60 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v61 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAcolordodgePDA_17523(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v61);
                    unsigned int v61 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v61;
                }
                else
                {
                  uint64_t result = PDAcolordodgePDA_17523(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v61);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v60;
          }
          while (v60);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 19:
        do
        {
          int v62 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v63 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAcolorburnPDA_17524(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v63);
                    unsigned int v63 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v63;
                }
                else
                {
                  uint64_t result = PDAcolorburnPDA_17524(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v63);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v62;
          }
          while (v62);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 20:
        do
        {
          int v64 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v65 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAsoftlightPDA_17526(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v65);
                    unsigned int v65 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v65;
                }
                else
                {
                  uint64_t result = PDAsoftlightPDA_17526(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v65);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v64;
          }
          while (v64);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 21:
        do
        {
          int v66 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v67 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAhardlightPDA_17525(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v67);
                    unsigned int v67 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v67;
                }
                else
                {
                  uint64_t result = PDAhardlightPDA_17525(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v67);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v66;
          }
          while (v66);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 22:
        do
        {
          int v68 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v69 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAdifferencePDA_17527(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v69);
                    unsigned int v69 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v69;
                }
                else
                {
                  uint64_t result = PDAdifferencePDA_17527(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v69);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v68;
          }
          while (v68);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 23:
        do
        {
          int v70 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v71 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAexclusionPDA_17528(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v71);
                    unsigned int v71 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v71;
                }
                else
                {
                  uint64_t result = PDAexclusionPDA_17528(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v71);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v70;
          }
          while (v70);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 24:
        do
        {
          int v72 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v73 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAhuePDA_17529(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v73);
                    unsigned int v73 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v73;
                }
                else
                {
                  uint64_t result = PDAhuePDA_17529(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v73);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v72;
          }
          while (v72);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 25:
        do
        {
          int v74 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v75 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAhuePDA_17529(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v75);
                    unsigned int v75 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v75;
                }
                else
                {
                  uint64_t result = PDAhuePDA_17529(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v75);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v74;
          }
          while (v74);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 26:
        do
        {
          int v76 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v77 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAluminosityPDA_17531(*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v77, *v39, *v35);
                    unsigned int v77 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v77;
                }
                else
                {
                  uint64_t result = PDAluminosityPDA_17531(*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v77, *v39, 0xFFu);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v76;
          }
          while (v76);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      case 27:
        do
        {
          int v78 = v252;
          do
          {
            if (*(unsigned char *)v41)
            {
              uint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v79 = BYTE3(result);
              if (BYTE3(result))
              {
                if (v3)
                {
                  if (*v35)
                  {
                    uint64_t result = PDAluminosityPDA_17531(*v39, *v35, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v79);
                    unsigned int v79 = BYTE3(result);
                  }
                  *int v39 = result;
                  *int v35 = v79;
                }
                else
                {
                  uint64_t result = PDAluminosityPDA_17531(*v39, 0xFFu, *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v79);
                  *int v39 = result;
                }
              }
            }
            ++v41;
            ++v39;
            v35 += v36;
            --v78;
          }
          while (v78);
          v41 += v42;
          v39 += v255;
          v35 += v253;
          --v6;
        }
        while (v6);
        return result;
      default:
        return result;
    }
    while (1)
    {
      unsigned int v243 = *v175 & v173;
      unsigned int v244 = v179;
      LODWORD(result) = v240;
      if (!v243) {
        goto LABEL_496;
      }
LABEL_485:
      if (v243 == -1) {
        break;
      }
      while (1)
      {
        if ((_BYTE)v243) {
          *uint64_t v176 = *(unsigned char *)(v30 + 4 * v243)
        }
                + ((unsigned __int16)((~*(_DWORD *)(v30 + 4 * v243) >> 24) * *v176
                                    + (((~*(_DWORD *)(v30 + 4 * v243) >> 24) * *v176) >> 8)
                                    + 1) >> 8);
        if ((v243 & 0xFF00) != 0) {
          v176[1] = *(unsigned char *)(v30 + 4 * BYTE1(v243))
        }
                  + ((unsigned __int16)((~*(_DWORD *)(v30 + 4 * BYTE1(v243)) >> 24) * v176[1]
                                      + (((~*(_DWORD *)(v30 + 4 * BYTE1(v243)) >> 24) * v176[1]) >> 8)
                                      + 1) >> 8);
        if ((v243 & 0xFF0000) != 0) {
          v176[2] = *(unsigned char *)(v30 + 4 * BYTE2(v243))
        }
                  + ((unsigned __int16)((~*(_DWORD *)(v30 + 4 * BYTE2(v243)) >> 24) * v176[2]
                                      + (((~*(_DWORD *)(v30 + 4 * BYTE2(v243)) >> 24) * v176[2]) >> 8)
                                      + 1) >> 8);
        unsigned int v248 = HIBYTE(v243);
        if (v248)
        {
          int v247 = *(_DWORD *)(v30 + 4 * v248);
          int v246 = v176[3];
          unsigned int v245 = ~v247 >> 24;
          goto LABEL_495;
        }
LABEL_496:
        while (1)
        {
          int v249 = result;
          v176 += 4;
          uint64_t result = (result - 1);
          ++v175;
          if (v249 < 2) {
            break;
          }
          unsigned int v243 = *v175;
          if (*v175) {
            goto LABEL_485;
          }
        }
        if (!v244) {
          break;
        }
        unsigned int v244 = 0;
        unsigned int v243 = *v175 & v179;
      }
      int v175 = (unsigned int *)((char *)v175 + v239);
      v176 += v242;
      if (!--v6) {
        return result;
      }
    }
    *uint64_t v176 = v31 + ((unsigned __int16)(*v176 * (_WORD)v241 + ((*v176 * v241) >> 8) + 1) >> 8);
    v176[1] = v31 + ((unsigned __int16)(v176[1] * (_WORD)v241 + ((v176[1] * v241) >> 8) + 1) >> 8);
    v176[2] = v31 + ((unsigned __int16)(v176[2] * (_WORD)v241 + ((v176[2] * v241) >> 8) + 1) >> 8);
    unsigned int v245 = v176[3];
    int v246 = ~HIBYTE(v31);
    LOBYTE(v247) = v31;
LABEL_495:
    v176[3] = v247 + ((unsigned __int16)(v245 * v246 + ((v245 * v246) >> 8) + 1) >> 8);
    goto LABEL_496;
  }
  return result;
}

uint64_t W8_mark_pixelmask(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 136);
  uint64_t v5 = *(int *)(result + 12);
  int v4 = *(_DWORD *)(result + 16);
  if (v2)
  {
    uint64_t v6 = *(int *)(result + 32);
    int v7 = (unsigned char *)(v2 + v5 + (int)v6 * (uint64_t)v4);
    int v8 = -1;
    if (!v3) {
      return result;
    }
  }
  else
  {
    int v7 = 0;
    uint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return result;
    }
  }
  int v9 = *(_DWORD *)(result + 4);
  int v10 = *(_DWORD *)(result + 8);
  uint64_t v11 = *(int *)(result + 28);
  uint64_t v13 = *(unsigned char **)(result + 88);
  unint64_t v12 = *(unsigned char **)(result + 96);
  unint64_t v14 = *(void *)(result + 40) + v5 + v4 * (uint64_t)(int)v11;
  uint64_t v15 = *(int *)(result + 124);
  uint64_t v16 = v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15;
  uint64_t v17 = *(int *)(result + 56);
  int v18 = *(_DWORD *)(result + 60);
  uint64_t v640 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    int v20 = *(_DWORD *)(result + 64);
    int v21 = *(_DWORD *)(result + 68);
    if (v12)
    {
      uint64_t v623 = *(int *)(result + 80);
      int v19 = 1;
    }
    else
    {
      uint64_t v623 = 0;
      int v19 = 0;
    }
    uint64_t result = (uint64_t)&v13[*(int *)(result + 68) * (uint64_t)(int)v640];
    v8 &= 1u;
    int v24 = 1;
    unint64_t v25 = (unint64_t)v13;
    int v641 = v13;
    goto LABEL_19;
  }
  if (v12)
  {
    uint64_t v623 = *(int *)(result + 80);
    v12 += v17 + (int)v623 * (uint64_t)v18;
    int v19 = -1;
  }
  else
  {
    uint64_t v623 = 0;
    int v19 = 0;
  }
  v13 += v17 + v18 * (uint64_t)(int)v640;
  if (v640 == v11 && (uint64_t)(v14 - (void)v13) >= 1)
  {
    if ((uint64_t)(v14 - (void)v13) <= v9)
    {
      v14 += v9 - 1;
      v13 += v9 - 1;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      v12 += v19 & (v9 - 1);
      int v24 = -1;
      goto LABEL_16;
    }
    uint64_t v22 = v10 - 1;
    int32x4_t v23 = &v13[v640 * v22];
    if (v14 <= (unint64_t)&v23[v9 - 1])
    {
      v14 += v11 * v22;
      uint64_t v11 = -v11;
      uint64_t v640 = -v640;
      v16 += v15 * v22;
      uint64_t v15 = -v15;
      v7 += v6 * v22;
      uint64_t v6 = -v6;
      v8 &= 1u;
      v12 += v623 * v22;
      uint64_t v623 = -v623;
      v19 &= 1u;
      int v24 = 1;
      uint64_t v13 = v23;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v19 &= 1u;
  int v24 = 1;
LABEL_16:
  int v641 = 0;
  uint64_t result = 0;
  unint64_t v25 = -1;
  int v21 = v623;
  int v20 = v640;
LABEL_19:
  int v26 = v24 * v9;
  int v624 = v9;
  unint64_t v620 = result;
  if (result)
  {
    uint64_t v27 = v18 % v21;
    int32x4_t v28 = &v13[v640 * v27];
    uint64_t result = (int)v17 % v20;
    uint64_t v13 = &v28[result];
    unint64_t v25 = (unint64_t)&v28[v20];
    if (v19) {
      v12 += v623 * v27 + result;
    }
    int v641 = &v28[(int)v17 % v20];
  }
  else
  {
    v640 -= v26;
    v623 -= v19 * v9;
  }
  uint64_t v621 = v11 - v26;
  uint64_t v622 = v15 - v26;
  uint64_t v619 = v6 - v8 * v624;
  int v643 = v19;
  int v642 = v8;
  switch(a2)
  {
    case 0:
      uint64_t v29 = v24;
      if (v8)
      {
        do
        {
          uint64_t v30 = 0;
          int v31 = v624;
          do
          {
            int v32 = *(unsigned __int8 *)(v16 + v30);
            if (*(unsigned char *)(v16 + v30))
            {
              if (v32 == 255)
              {
                LOBYTE(v33) = 0;
                *(unsigned char *)(v14 + v30) = 0;
              }
              else
              {
                int v34 = *(unsigned __int8 *)(v14 + v30);
                int v35 = *v7;
                unsigned int v36 = (v34 | (v35 << 16)) * v32 + 65537 + ((((v34 | (v35 << 16)) * v32) >> 8) & 0xFF00FF);
                int v37 = v34 | (v35 << 24);
                *(unsigned char *)(v14 + v30) = v37 - BYTE1(v36);
                unsigned int v33 = (v37 - (v36 & 0xFF000000 | BYTE1(v36))) >> 24;
              }
              *int v7 = v33;
            }
            v7 += v8;
            v30 += v29;
            --v31;
          }
          while (v31);
          v16 += v30 + v622;
          v14 += v30 + v621;
          v7 += v619;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v38 = 0;
          int v39 = v624;
          do
          {
            int v40 = *(unsigned __int8 *)(v16 + v38);
            if (*(unsigned char *)(v16 + v38))
            {
              if (v40 == 255) {
                LOBYTE(v41) = 0;
              }
              else {
                unsigned int v41 = *(unsigned __int8 *)(v14 + v38)
              }
                    - ((*(unsigned __int8 *)(v14 + v38) * v40
                      + ((*(unsigned __int8 *)(v14 + v38) * v40) >> 8)
                      + 1) >> 8);
              *(unsigned char *)(v14 + v38) = v41;
            }
            v38 += v24;
            --v39;
          }
          while (v39);
          v16 += v38 + v622;
          v14 += v38 + v621;
          --v10;
        }
        while (v10);
      }
      return result;
    case 1:
      if (v8)
      {
        uint64_t v42 = v24;
        if (v19)
        {
          uint64_t v43 = -(uint64_t)v20;
          uint64_t v44 = v21;
          uint64_t v45 = -(v640 * v21);
          uint64_t v46 = -(v623 * v44);
          int v47 = v12;
          do
          {
            uint64_t v48 = 0;
            int v49 = v624;
            do
            {
              int v50 = *(unsigned __int8 *)(v16 + v48);
              if (*(unsigned char *)(v16 + v48))
              {
                if (v50 == 255)
                {
                  *(unsigned char *)(v14 + v48) = *v13;
                  LOBYTE(v51) = *v12;
                }
                else
                {
                  unsigned int v52 = (*v13 | (*v12 << 16)) * v50
                      + (*(unsigned __int8 *)(v14 + v48) | (*v7 << 16)) * (v50 ^ 0xFF);
                  unsigned int v53 = v52 + 65537 + ((v52 >> 8) & 0xFF00FF);
                  *(unsigned char *)(v14 + v48) = BYTE1(v53);
                  unsigned int v51 = HIBYTE(v53);
                }
                *int v7 = v51;
              }
              v7 += v8;
              if ((unint64_t)&v13[v42] >= v25) {
                uint64_t v54 = v43;
              }
              else {
                uint64_t v54 = 0;
              }
              v12 += v19 + v54;
              v13 += v42 + v54;
              v48 += v42;
              --v49;
            }
            while (v49);
            if (v620)
            {
              unsigned int v55 = &v47[v623];
              if ((unint64_t)&v641[v640] >= v620) {
                uint64_t v56 = v45;
              }
              else {
                uint64_t v56 = 0;
              }
              uint64_t v13 = &v641[v640 + v56];
              if ((unint64_t)&v641[v640] >= v620) {
                uint64_t v57 = v46;
              }
              else {
                uint64_t v57 = 0;
              }
              unint64_t v12 = &v55[v57];
              v25 += v640 + v56;
              int v47 = &v55[v57];
              v641 += v640 + v56;
            }
            else
            {
              v13 += v640;
              v12 += v623;
            }
            uint64_t result = v14 + v48;
            v16 += v48 + v622;
            v14 += v48 + v621;
            v7 += v619;
            --v10;
          }
          while (v10);
        }
        else
        {
          uint64_t v546 = -(uint64_t)v20;
          uint64_t v547 = -(v640 * v21);
          do
          {
            uint64_t v548 = 0;
            int v549 = v624;
            do
            {
              int v550 = *(unsigned __int8 *)(v16 + v548);
              if (*(unsigned char *)(v16 + v548))
              {
                if (v550 == 255)
                {
                  *(unsigned char *)(v14 + v548) = *v13;
                  LOBYTE(v551) = -1;
                }
                else
                {
                  unsigned int v552 = (*v13 | 0xFF0000) * v550
                       + (*(unsigned __int8 *)(v14 + v548) | (*v7 << 16)) * (v550 ^ 0xFF);
                  unsigned int v553 = v552 + 65537 + ((v552 >> 8) & 0xFF00FF);
                  *(unsigned char *)(v14 + v548) = BYTE1(v553);
                  unsigned int v551 = HIBYTE(v553);
                }
                *int v7 = v551;
              }
              v7 += v8;
              if ((unint64_t)&v13[v42] >= v25) {
                uint64_t v554 = v546;
              }
              else {
                uint64_t v554 = 0;
              }
              v13 += v42 + v554;
              v548 += v42;
              --v549;
            }
            while (v549);
            v16 += v548 + v622;
            uint64_t result = v620;
            v14 += v548 + v621;
            v7 += v619;
            uint64_t v555 = v641;
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v556 = v547;
            }
            else {
              uint64_t v556 = 0;
            }
            long long v557 = &v641[v640 + v556];
            unint64_t v558 = v25 + v640 + v556;
            if (v620) {
              uint64_t v555 = v557;
            }
            int v641 = v555;
            if (v620)
            {
              unint64_t v25 = v558;
              uint64_t v13 = v557;
            }
            else
            {
              v13 += v640;
            }
            --v10;
          }
          while (v10);
        }
      }
      else
      {
        uint64_t v466 = -(uint64_t)v20;
        uint64_t v467 = -(v640 * v21);
        do
        {
          uint64_t v468 = 0;
          int v469 = v624;
          do
          {
            int v470 = *(unsigned __int8 *)(v16 + v468);
            if (*(unsigned char *)(v16 + v468))
            {
              if (v470 == 255) {
                LOBYTE(v471) = *v13;
              }
              else {
                unsigned int v471 = (*v13 * v470
              }
                      + *(unsigned __int8 *)(v14 + v468) * (v470 ^ 0xFF)
                      + ((*v13 * v470 + *(unsigned __int8 *)(v14 + v468) * (v470 ^ 0xFFu)) >> 8)
                      + 1) >> 8;
              *(unsigned char *)(v14 + v468) = v471;
            }
            if ((unint64_t)&v13[v24] >= v25) {
              uint64_t v472 = v466;
            }
            else {
              uint64_t v472 = 0;
            }
            v13 += v24 + v472;
            v468 += v24;
            --v469;
          }
          while (v469);
          v16 += v468 + v622;
          v14 += v468 + v621;
          int v473 = v641;
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v474 = v467;
          }
          else {
            uint64_t v474 = 0;
          }
          int v475 = &v641[v640 + v474];
          unint64_t v476 = v25 + v640 + v474;
          if (v620) {
            int v473 = v475;
          }
          int v641 = v473;
          if (v620)
          {
            unint64_t v25 = v476;
            uint64_t v13 = v475;
          }
          else
          {
            v13 += v640;
          }
          --v10;
        }
        while (v10);
      }
      return result;
    case 2:
      uint64_t v58 = v24;
      if (v8)
      {
        uint64_t v59 = v21;
        uint64_t v60 = -(v640 * v21);
        uint64_t v61 = -(v623 * v59);
        int v62 = v12;
        uint64_t v63 = -(uint64_t)v20;
        while (1)
        {
          uint64_t v64 = 0;
          int v65 = v624;
          do
          {
            int v66 = *(unsigned __int8 *)(v16 + v64);
            if (!*(unsigned char *)(v16 + v64)) {
              goto LABEL_83;
            }
            if (v66 != 255)
            {
              int v69 = *v13;
              int v70 = *v12;
              unsigned int v71 = (v69 | (v70 << 16)) * (v66 ^ 0xFF)
                  + 65537
                  + ((((v69 | (v70 << 16)) * (v66 ^ 0xFFu)) >> 8) & 0xFF00FF);
              unsigned int v72 = (v69 | (v70 << 24)) - (v71 & 0xFF000000 | BYTE1(v71));
              if (!HIBYTE(v72)) {
                goto LABEL_83;
              }
              unsigned int v73 = (*(unsigned __int8 *)(v14 + v64) | (*v7 << 16)) * (~v72 >> 24);
              unsigned int v74 = ((v73 + 65537 + ((v73 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v73 + 1 + BYTE1(v73)) >> 8))
                  + (v72 & 0xFF0000FF);
              goto LABEL_81;
            }
            int v67 = *v12;
            if (!*v12) {
              goto LABEL_83;
            }
            if (v67 != 255)
            {
              unsigned int v75 = (*(unsigned __int8 *)(v14 + v64) | (*v7 << 16)) * (v67 ^ 0xFF);
              unsigned int v74 = ((v75 + 65537 + ((v75 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v75 + 1 + BYTE1(v75)) >> 8))
                  + (*v13 | (v67 << 24));
LABEL_81:
              *(unsigned char *)(v14 + v64) = v74;
              unsigned int v68 = HIBYTE(v74);
              goto LABEL_82;
            }
            *(unsigned char *)(v14 + v64) = *v13;
            LOBYTE(v68) = -1;
LABEL_82:
            *int v7 = v68;
LABEL_83:
            v7 += v8;
            if ((unint64_t)&v13[v58] >= v25) {
              uint64_t v76 = v63;
            }
            else {
              uint64_t v76 = 0;
            }
            v12 += v19 + v76;
            v13 += v58 + v76;
            v64 += v58;
            --v65;
          }
          while (v65);
          if (v620)
          {
            unsigned int v77 = &v62[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v78 = v60;
            }
            else {
              uint64_t v78 = 0;
            }
            uint64_t v13 = &v641[v640 + v78];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v79 = v61;
            }
            else {
              uint64_t v79 = 0;
            }
            unint64_t v12 = &v77[v79];
            v25 += v640 + v78;
            int v62 = &v77[v79];
            v641 += v640 + v78;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          uint64_t result = v14 + v64;
          v16 += v64 + v622;
          v14 += v64 + v621;
          v7 += v619;
          if (!--v10) {
            return result;
          }
        }
      }
      uint64_t v477 = -(uint64_t)v20;
      uint64_t v478 = v21;
      uint64_t v479 = -(v640 * v21);
      uint64_t v480 = -(v623 * v478);
      int v481 = v12;
      break;
    case 3:
      uint64_t v80 = v24;
      uint64_t v81 = v21;
      uint64_t v82 = -(v640 * v21);
      uint64_t v83 = -(uint64_t)v20;
      uint64_t v84 = -(v623 * v81);
      uint64_t v85 = v12;
      do
      {
        uint64_t v86 = 0;
        int v87 = v624;
        do
        {
          int v88 = *(unsigned __int8 *)(v16 + v86);
          if (*(unsigned char *)(v16 + v86))
          {
            if (v88 == 255)
            {
              if (v19) {
                int v89 = *v12;
              }
              else {
                int v89 = 255;
              }
              unsigned int v93 = *v13;
              unsigned int v91 = (v93 | (v89 << 16)) * (*v7 ^ 0xFF);
              unsigned int v92 = (v93 | (v89 << 24))
                  - ((v91 + 65537 + ((v91 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v91 + 1 + BYTE1(v91)) >> 8));
              HIBYTE(v93) = HIBYTE(v92);
            }
            else
            {
              if (v19) {
                int v90 = *v12;
              }
              else {
                int v90 = 255;
              }
              unsigned int v94 = (*v13 | (v90 << 16))
                  * ((*v7 * v88 + ((*v7 * v88) >> 8) + 1) >> 8)
                  + (*(unsigned __int8 *)(v14 + v86) | (*v7 << 16)) * (v88 ^ 0xFF);
              unsigned int v93 = v94 + 65537 + ((v94 >> 8) & 0xFF00FF);
              unsigned int v92 = v93 >> 8;
            }
            *(unsigned char *)(v14 + v86) = v92;
            *int v7 = HIBYTE(v93);
          }
          v7 += v8;
          if ((unint64_t)&v13[v80] >= v25) {
            uint64_t v95 = v83;
          }
          else {
            uint64_t v95 = 0;
          }
          v12 += v19 + v95;
          v13 += v80 + v95;
          v86 += v80;
          --v87;
        }
        while (v87);
        if (v620)
        {
          char v96 = &v85[v623];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v97 = v82;
          }
          else {
            uint64_t v97 = 0;
          }
          uint64_t v13 = &v641[v640 + v97];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v98 = v84;
          }
          else {
            uint64_t v98 = 0;
          }
          unint64_t v12 = &v96[v98];
          v25 += v640 + v97;
          uint64_t v85 = &v96[v98];
          v641 += v640 + v97;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        uint64_t result = v14 + v86;
        v16 += v86 + v622;
        v14 += v86 + v621;
        v7 += v619;
        --v10;
      }
      while (v10);
      return result;
    case 4:
      uint64_t v99 = v24;
      uint64_t v100 = v21;
      uint64_t v101 = -(v640 * v21);
      uint64_t v102 = -(uint64_t)v20;
      uint64_t v103 = -(v623 * v100);
      int v104 = v12;
      do
      {
        uint64_t v105 = 0;
        int v106 = v624;
        do
        {
          int v107 = *(unsigned __int8 *)(v16 + v105);
          if (*(unsigned char *)(v16 + v105))
          {
            if (v107 == 255)
            {
              if (v19) {
                int v108 = *v12;
              }
              else {
                int v108 = 255;
              }
              unsigned int v112 = *v13;
              unsigned int v110 = (v112 | (v108 << 16)) * *v7;
              unsigned int v111 = (v112 | (v108 << 24))
                   - ((v110 + 65537 + ((v110 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v110 + 1 + BYTE1(v110)) >> 8));
              HIBYTE(v112) = HIBYTE(v111);
            }
            else
            {
              if (v19) {
                int v109 = *v12;
              }
              else {
                int v109 = 255;
              }
              unsigned int v113 = (*v13 | (v109 << 16))
                   * (((*v7 ^ 0xFF) * v107 + (((*v7 ^ 0xFFu) * v107) >> 8) + 1) >> 8)
                   + (*(unsigned __int8 *)(v14 + v105) | (*v7 << 16)) * (v107 ^ 0xFF);
              unsigned int v112 = v113 + 65537 + ((v113 >> 8) & 0xFF00FF);
              unsigned int v111 = v112 >> 8;
            }
            *(unsigned char *)(v14 + v105) = v111;
            *int v7 = HIBYTE(v112);
          }
          v7 += v8;
          if ((unint64_t)&v13[v99] >= v25) {
            uint64_t v114 = v102;
          }
          else {
            uint64_t v114 = 0;
          }
          v12 += v19 + v114;
          v13 += v99 + v114;
          v105 += v99;
          --v106;
        }
        while (v106);
        if (v620)
        {
          int v115 = &v104[v623];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v116 = v101;
          }
          else {
            uint64_t v116 = 0;
          }
          uint64_t v13 = &v641[v640 + v116];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v117 = v103;
          }
          else {
            uint64_t v117 = 0;
          }
          unint64_t v12 = &v115[v117];
          v25 += v640 + v116;
          int v104 = &v115[v117];
          v641 += v640 + v116;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        uint64_t result = v14 + v105;
        v16 += v105 + v622;
        v14 += v105 + v621;
        v7 += v619;
        --v10;
      }
      while (v10);
      return result;
    case 5:
      uint64_t v118 = v24;
      uint64_t v119 = v8;
      uint64_t v120 = v21;
      uint64_t v121 = -(v640 * v21);
      uint64_t v122 = -(uint64_t)v20;
      uint64_t v123 = -(v623 * v120);
      int v124 = v12;
      do
      {
        uint64_t v125 = 0;
        int v126 = v624;
        do
        {
          if (*(unsigned char *)(v16 + v125))
          {
            int v127 = *v13;
            int v128 = *v12;
            unsigned int v129 = (v127 | (v128 << 16)) * (*(unsigned __int8 *)(v16 + v125) ^ 0xFF)
                 + 65537
                 + ((((v127 | (v128 << 16)) * (*(unsigned __int8 *)(v16 + v125) ^ 0xFFu)) >> 8) & 0xFF00FF);
            unsigned int v130 = (v127 | (v128 << 24)) - (v129 & 0xFF000000 | BYTE1(v129));
            unsigned int v131 = (HIBYTE(v130) ^ 0xFF) * (*(unsigned __int8 *)(v14 + v125) | (*v7 << 16))
                 + (v130 | (HIBYTE(v130) << 16)) * *v7;
            int v132 = v131 + 65537 + ((v131 >> 8) & 0xFF00FF);
            *(unsigned char *)(v14 + v125) = BYTE1(v132);
            *int v7 = HIBYTE(v132);
          }
          v7 += v119;
          if ((unint64_t)&v13[v118] >= v25) {
            uint64_t v133 = v122;
          }
          else {
            uint64_t v133 = 0;
          }
          v12 += v19 + v133;
          v13 += v118 + v133;
          v125 += v118;
          --v126;
        }
        while (v126);
        if (v620)
        {
          int v134 = &v124[v623];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v135 = v121;
          }
          else {
            uint64_t v135 = 0;
          }
          uint64_t v13 = &v641[v640 + v135];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v136 = v123;
          }
          else {
            uint64_t v136 = 0;
          }
          unint64_t v12 = &v134[v136];
          v25 += v640 + v135;
          int v124 = &v134[v136];
          v641 += v640 + v135;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        uint64_t result = v14 + v125;
        v16 += v125 + v622;
        v14 += v125 + v621;
        v7 += v619;
        --v10;
      }
      while (v10);
      return result;
    case 6:
      uint64_t v137 = v24;
      uint64_t v138 = v8;
      uint64_t v139 = v19;
      uint64_t v140 = v21;
      uint64_t v141 = -(v640 * v21);
      uint64_t v142 = -(uint64_t)v20;
      uint64_t v143 = -(v623 * v140);
      int v144 = v12;
      do
      {
        uint64_t v145 = 0;
        int v146 = v624;
        do
        {
          int v147 = *(unsigned __int8 *)(v16 + v145);
          if (*(unsigned char *)(v16 + v145))
          {
            int v148 = *v7;
            if ((_BYTE)v148 != 0xFF)
            {
              if (~(_BYTE)v148 == 255)
              {
                if (v19) {
                  int v149 = *v12;
                }
                else {
                  int v149 = 255;
                }
                int v151 = *v13;
                unsigned int v152 = (v151 | (v149 << 16)) * (v147 ^ 0xFF)
                     + 65537
                     + ((((v151 | (v149 << 16)) * (v147 ^ 0xFFu)) >> 8) & 0xFF00FF);
                unsigned int v153 = (v151 | (v149 << 24)) - (v152 & 0xFF000000 | BYTE1(v152));
              }
              else
              {
                if (v19) {
                  int v150 = *v12;
                }
                else {
                  int v150 = 255;
                }
                unsigned int v154 = (*v13 | (v150 << 16))
                     * ((~(_BYTE)v148 * v147
                       + ((~(_BYTE)v148 * v147) >> 8)
                       + 1) >> 8);
                unsigned int v153 = ((v154 + 65537 + ((v154 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v154 + 1 + BYTE1(v154)) >> 8))
                     + (*(unsigned __int8 *)(v14 + v145) | (v148 << 24));
                int v19 = v643;
              }
              *(unsigned char *)(v14 + v145) = v153;
              *int v7 = HIBYTE(v153);
            }
          }
          v7 += v138;
          if ((unint64_t)&v13[v137] >= v25) {
            uint64_t v155 = v142;
          }
          else {
            uint64_t v155 = 0;
          }
          v12 += v139 + v155;
          v13 += v137 + v155;
          v145 += v137;
          --v146;
        }
        while (v146);
        if (v620)
        {
          int v156 = &v144[v623];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v157 = v141;
          }
          else {
            uint64_t v157 = 0;
          }
          uint64_t v13 = &v641[v640 + v157];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v158 = v143;
          }
          else {
            uint64_t v158 = 0;
          }
          unint64_t v12 = &v156[v158];
          v25 += v640 + v157;
          int v144 = &v156[v158];
          v641 += v640 + v157;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v145 + v622;
        v14 += v145 + v621;
        uint64_t result = v619;
        v7 += v619;
        --v10;
      }
      while (v10);
      return result;
    case 7:
      uint64_t v159 = v24;
      if (v8)
      {
        uint64_t v160 = v21;
        uint64_t v161 = -(v640 * v21);
        uint64_t v162 = -(v623 * v160);
        int v163 = v12;
        uint64_t v164 = -(uint64_t)v20;
        do
        {
          uint64_t v165 = 0;
          int v166 = v624;
          do
          {
            int v167 = *(unsigned __int8 *)(v16 + v165);
            if (*(unsigned char *)(v16 + v165))
            {
              if (v167 == 255)
              {
                int v168 = *(unsigned __int8 *)(v14 + v165);
                unsigned int v171 = *v7;
                unsigned int v169 = (v168 | (v171 << 16)) * (*v12 ^ 0xFF);
                unsigned int v170 = (v168 | (v171 << 24))
                     - ((v169 + 65537 + ((v169 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v169 + 1 + BYTE1(v169)) >> 8));
                HIBYTE(v171) = HIBYTE(v170);
              }
              else
              {
                unsigned int v172 = ((v167 ^ 0xFF)
                      + ((*v12 * v167 + ((*v12 * v167) >> 8) + 1) >> 8))
                     * (*(unsigned __int8 *)(v14 + v165) | (*v7 << 16));
                unsigned int v171 = v172 + 65537 + ((v172 >> 8) & 0xFF00FF);
                unsigned int v170 = v171 >> 8;
              }
              *(unsigned char *)(v14 + v165) = v170;
              *int v7 = HIBYTE(v171);
            }
            v7 += v8;
            if ((unint64_t)&v13[v159] >= v25) {
              uint64_t v173 = v164;
            }
            else {
              uint64_t v173 = 0;
            }
            v12 += v19 + v173;
            v13 += v159 + v173;
            v165 += v159;
            --v166;
          }
          while (v166);
          if (v620)
          {
            char v174 = &v163[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v175 = v161;
            }
            else {
              uint64_t v175 = 0;
            }
            uint64_t v13 = &v641[v640 + v175];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v176 = v162;
            }
            else {
              uint64_t v176 = 0;
            }
            unint64_t v12 = &v174[v176];
            v25 += v640 + v175;
            int v163 = &v174[v176];
            v641 += v640 + v175;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          uint64_t result = v14 + v165;
          v16 += v165 + v622;
          v14 += v165 + v621;
          v7 += v619;
          --v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v495 = -(uint64_t)v20;
        uint64_t v496 = v21;
        uint64_t v497 = -(v640 * v21);
        uint64_t v498 = -(v623 * v496);
        uint64_t v499 = v12;
        do
        {
          uint64_t v500 = 0;
          int v501 = v624;
          do
          {
            int v502 = *(unsigned __int8 *)(v16 + v500);
            if (*(unsigned char *)(v16 + v500))
            {
              if (v502 == 255)
              {
                unsigned int v503 = *(unsigned __int8 *)(v14 + v500)
                     - (((*v12 ^ 0xFF) * *(unsigned __int8 *)(v14 + v500)
                       + (((*v12 ^ 0xFF) * *(unsigned __int8 *)(v14 + v500)) >> 8)
                       + 1) >> 8);
              }
              else
              {
                unsigned int v504 = *v12 * v502 + ((*v12 * v502) >> 8) + 1;
                unsigned int v503 = (((v502 ^ 0xFF) + (v504 >> 8)) * *(unsigned __int8 *)(v14 + v500)
                      + ((((v502 ^ 0xFF) + (v504 >> 8)) * *(unsigned __int8 *)(v14 + v500)) >> 8)
                      + 1) >> 8;
              }
              *(unsigned char *)(v14 + v500) = v503;
            }
            if ((unint64_t)&v13[v159] >= v25) {
              uint64_t result = v495;
            }
            else {
              uint64_t result = 0;
            }
            v12 += v19 + result;
            v13 += v159 + result;
            v500 += v159;
            --v501;
          }
          while (v501);
          if (v620)
          {
            uint64_t result = v623;
            uint64_t v505 = &v499[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v506 = v497;
            }
            else {
              uint64_t v506 = 0;
            }
            uint64_t v13 = &v641[v640 + v506];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v507 = v498;
            }
            else {
              uint64_t v507 = 0;
            }
            unint64_t v12 = &v505[v507];
            v25 += v640 + v506;
            uint64_t v499 = &v505[v507];
            v641 += v640 + v506;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          v16 += v500 + v622;
          v14 += v500 + v621;
          --v10;
        }
        while (v10);
      }
      return result;
    case 8:
      uint64_t v177 = v24;
      if (v8)
      {
        uint64_t v178 = v21;
        uint64_t v179 = -(v640 * v21);
        uint64_t v180 = -(v623 * v178);
        uint64_t v181 = v12;
        uint64_t v182 = -(uint64_t)v20;
        do
        {
          uint64_t v183 = 0;
          int v184 = v624;
          do
          {
            int v185 = *(unsigned __int8 *)(v16 + v183);
            if (*(unsigned char *)(v16 + v183))
            {
              int v186 = *(unsigned __int8 *)(v14 + v183);
              int v187 = *v7;
              if (v185 == 255) {
                unsigned int v188 = (v186 | (v187 << 16)) * *v12;
              }
              else {
                unsigned int v188 = ((*v12 * v185 + ((*v12 * v185) >> 8) + 1) >> 8)
              }
                     * (v186 | (v187 << 16));
              unsigned int v189 = (v186 | (v187 << 24))
                   - ((v188 + 65537 + ((v188 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v188 + 1 + BYTE1(v188)) >> 8));
              *(unsigned char *)(v14 + v183) = v189;
              *int v7 = HIBYTE(v189);
            }
            v7 += v8;
            if ((unint64_t)&v13[v177] >= v25) {
              uint64_t v190 = v182;
            }
            else {
              uint64_t v190 = 0;
            }
            v12 += v19 + v190;
            v13 += v177 + v190;
            v183 += v177;
            --v184;
          }
          while (v184);
          if (v620)
          {
            int v191 = &v181[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v192 = v179;
            }
            else {
              uint64_t v192 = 0;
            }
            uint64_t v13 = &v641[v640 + v192];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v193 = v180;
            }
            else {
              uint64_t v193 = 0;
            }
            unint64_t v12 = &v191[v193];
            v25 += v640 + v192;
            uint64_t v181 = &v191[v193];
            v641 += v640 + v192;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          uint64_t result = v14 + v183;
          v16 += v183 + v622;
          v14 += v183 + v621;
          v7 += v619;
          --v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v508 = -(uint64_t)v20;
        uint64_t v509 = v21;
        uint64_t v510 = -(v640 * v21);
        uint64_t v511 = -(v623 * v509);
        uint64_t v512 = v12;
        do
        {
          uint64_t v513 = 0;
          int v514 = v624;
          do
          {
            int v515 = *(unsigned __int8 *)(v16 + v513);
            if (*(unsigned char *)(v16 + v513))
            {
              if (v515 == 255) {
                unsigned int v516 = *v12;
              }
              else {
                unsigned int v516 = (*v12 * v515 + ((*v12 * v515) >> 8) + 1) >> 8;
              }
              *(unsigned char *)(v14 + v513) -= (unsigned __int16)(v516 * *(unsigned __int8 *)(v14 + v513)
                                                         + ((v516 * *(unsigned __int8 *)(v14 + v513)) >> 8)
                                                         + 1) >> 8;
            }
            if ((unint64_t)&v13[v177] >= v25) {
              uint64_t result = v508;
            }
            else {
              uint64_t result = 0;
            }
            v12 += v19 + result;
            v13 += v177 + result;
            v513 += v177;
            --v514;
          }
          while (v514);
          if (v620)
          {
            uint64_t result = v623;
            uint64_t v517 = &v512[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v518 = v510;
            }
            else {
              uint64_t v518 = 0;
            }
            uint64_t v13 = &v641[v640 + v518];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v519 = v511;
            }
            else {
              uint64_t v519 = 0;
            }
            unint64_t v12 = &v517[v519];
            v25 += v640 + v518;
            uint64_t v512 = &v517[v519];
            v641 += v640 + v518;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          v16 += v513 + v622;
          v14 += v513 + v621;
          --v10;
        }
        while (v10);
      }
      return result;
    case 9:
      uint64_t v194 = v24;
      uint64_t v195 = v8;
      uint64_t v196 = v19;
      uint64_t v197 = v21;
      uint64_t v198 = -(v640 * v21);
      uint64_t v199 = -(uint64_t)v20;
      uint64_t v200 = -(v623 * v197);
      uint64_t v201 = v12;
      do
      {
        uint64_t v202 = 0;
        int v203 = v624;
        do
        {
          char v204 = *(unsigned char *)(v16 + v202);
          if (v204)
          {
            int v205 = *v13;
            int v206 = *v12;
            char v207 = ~v204;
            unsigned int v208 = (v205 | (v206 << 16)) * ~v204;
            unsigned int v209 = (v205 | (v206 << 24))
                 - ((v208 + 65537 + ((v208 >> 8) & 0xFF00FF)) & 0xFF000000 | ((unsigned __int16)(v208 + 1 + BYTE1(v208)) >> 8));
            unsigned int v210 = (v209 | (HIBYTE(v209) << 16)) * (*v7 ^ 0xFF)
                 + (*(unsigned __int8 *)(v14 + v202) | (*v7 << 16))
                 * (v207 + HIBYTE(v209));
            int v211 = v210 + 65537 + ((v210 >> 8) & 0xFF00FF);
            *(unsigned char *)(v14 + v202) = BYTE1(v211);
            *int v7 = HIBYTE(v211);
          }
          v7 += v195;
          if ((unint64_t)&v13[v194] >= v25) {
            uint64_t v212 = v199;
          }
          else {
            uint64_t v212 = 0;
          }
          v12 += v196 + v212;
          v13 += v194 + v212;
          v202 += v194;
          --v203;
        }
        while (v203);
        if (v620)
        {
          unsigned int v213 = &v201[v623];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v214 = v198;
          }
          else {
            uint64_t v214 = 0;
          }
          uint64_t v13 = &v641[v640 + v214];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v215 = v200;
          }
          else {
            uint64_t v215 = 0;
          }
          unint64_t v12 = &v213[v215];
          v25 += v640 + v214;
          uint64_t v201 = &v213[v215];
          v641 += v640 + v214;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v202 + v622;
        v14 += v202 + v621;
        uint64_t result = v619;
        v7 += v619;
        --v10;
      }
      while (v10);
      return result;
    case 10:
      uint64_t v216 = v24;
      uint64_t v217 = v8;
      uint64_t v218 = v21;
      uint64_t v219 = -(v640 * v21);
      uint64_t v220 = -(uint64_t)v20;
      uint64_t v221 = -(v623 * v218);
      int v222 = v12;
      do
      {
        uint64_t v223 = 0;
        int v224 = v624;
        do
        {
          if (*(unsigned char *)(v16 + v223))
          {
            int v225 = *v13;
            int v226 = *v12;
            unsigned int v227 = (v225 | (v226 << 16)) * (*(unsigned __int8 *)(v16 + v223) ^ 0xFF)
                 + 65537
                 + ((((v225 | (v226 << 16)) * (*(unsigned __int8 *)(v16 + v223) ^ 0xFFu)) >> 8) & 0xFF00FF);
            unsigned int v228 = (v225 | (v226 << 24)) - (v227 & 0xFF000000 | BYTE1(v227));
            unsigned int v229 = (HIBYTE(v228) ^ 0xFF) * (*(unsigned __int8 *)(v14 + v223) | (*v7 << 16))
                 + (v228 | (HIBYTE(v228) << 16)) * (*v7 ^ 0xFF);
            int v230 = v229 + 65537 + ((v229 >> 8) & 0xFF00FF);
            *(unsigned char *)(v14 + v223) = BYTE1(v230);
            *int v7 = HIBYTE(v230);
          }
          v7 += v217;
          if ((unint64_t)&v13[v216] >= v25) {
            uint64_t v231 = v220;
          }
          else {
            uint64_t v231 = 0;
          }
          v12 += v19 + v231;
          v13 += v216 + v231;
          v223 += v216;
          --v224;
        }
        while (v224);
        if (v620)
        {
          unsigned int v232 = &v222[v623];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v233 = v219;
          }
          else {
            uint64_t v233 = 0;
          }
          uint64_t v13 = &v641[v640 + v233];
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v234 = v221;
          }
          else {
            uint64_t v234 = 0;
          }
          unint64_t v12 = &v232[v234];
          v25 += v640 + v233;
          int v222 = &v232[v234];
          v641 += v640 + v233;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        uint64_t result = v14 + v223;
        v16 += v223 + v622;
        v14 += v223 + v621;
        v7 += v619;
        --v10;
      }
      while (v10);
      return result;
    case 11:
      uint64_t v235 = v24;
      if (v8)
      {
        uint64_t v236 = v21;
        uint64_t v237 = -(v640 * v21);
        uint64_t v238 = -(v623 * v236);
        uint64_t v239 = v12;
        uint64_t v240 = -(uint64_t)v20;
        do
        {
          uint64_t v241 = 0;
          int v242 = v624;
          do
          {
            if (*(unsigned char *)(v16 + v241))
            {
              if (v19) {
                int v243 = *v12;
              }
              else {
                int v243 = 255;
              }
              int v244 = *v13;
              unsigned int v245 = (v244 | (v243 << 16)) * (*(unsigned __int8 *)(v16 + v241) ^ 0xFF)
                   + 65537
                   + ((((v244 | (v243 << 16)) * (*(unsigned __int8 *)(v16 + v241) ^ 0xFFu)) >> 8) & 0xFF00FF);
              unsigned int v246 = (v244 | (v243 << 24)) - (v245 & 0xFF000000 | BYTE1(v245));
              unsigned int v247 = ((*v7 - *(unsigned char *)(v14 + v241)) | (*v7 << 16))
                   + (HIBYTE(v246) << 16)
                   + (HIBYTE(v246) - v246);
              int v248 = (255 * ((v247 >> 8) & 0x10001)) | v247;
              *(unsigned char *)(v14 + v241) = BYTE2(v248) - v248;
              *int v7 = BYTE2(v248);
            }
            v7 += v8;
            if ((unint64_t)&v13[v235] >= v25) {
              uint64_t v249 = v240;
            }
            else {
              uint64_t v249 = 0;
            }
            v12 += v19 + v249;
            v13 += v235 + v249;
            v241 += v235;
            --v242;
          }
          while (v242);
          if (v620)
          {
            uint64_t v250 = &v239[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v251 = v237;
            }
            else {
              uint64_t v251 = 0;
            }
            uint64_t v13 = &v641[v640 + v251];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v252 = v238;
            }
            else {
              uint64_t v252 = 0;
            }
            unint64_t v12 = &v250[v252];
            v25 += v640 + v251;
            uint64_t v239 = &v250[v252];
            v641 += v640 + v251;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          uint64_t result = v14 + v241;
          v16 += v241 + v622;
          v14 += v241 + v621;
          v7 += v619;
          --v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v520 = -(uint64_t)v20;
        uint64_t v521 = v21;
        uint64_t v522 = -(v640 * v21);
        uint64_t v523 = -(v623 * v521);
        uint64_t v524 = v12;
        do
        {
          uint64_t v525 = 0;
          int v526 = v624;
          do
          {
            if (*(unsigned char *)(v16 + v525))
            {
              if (v19) {
                int v527 = *v12;
              }
              else {
                int v527 = 255;
              }
              int v528 = *v13;
              unsigned int v529 = (v528 | (v527 << 16)) * (*(unsigned __int8 *)(v16 + v525) ^ 0xFF)
                   + 65537
                   + ((((v528 | (v527 << 16)) * (*(unsigned __int8 *)(v16 + v525) ^ 0xFFu)) >> 8) & 0xFF00FF);
              unsigned int v530 = (*(unsigned __int8 *)(v14 + v525) ^ 0xFF)
                   - (v528 - BYTE1(v529))
                   + (((v528 | (v527 << 24)) - (v529 & 0xFF000000 | BYTE1(v529))) >> 24);
              char v531 = BYTE1(v530) | (2 * BYTE1(v530)) | (4 * (BYTE1(v530) | (2 * BYTE1(v530))));
              *(unsigned char *)(v14 + v525) = ~(v530 | (16 * v531) | v531);
            }
            if ((unint64_t)&v13[v235] >= v25) {
              uint64_t v532 = v520;
            }
            else {
              uint64_t v532 = 0;
            }
            v12 += v19 + v532;
            v13 += v235 + v532;
            v525 += v235;
            --v526;
          }
          while (v526);
          if (v620)
          {
            int v533 = &v524[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v534 = v522;
            }
            else {
              uint64_t v534 = 0;
            }
            uint64_t v13 = &v641[v640 + v534];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v535 = v523;
            }
            else {
              uint64_t v535 = 0;
            }
            unint64_t v12 = &v533[v535];
            v25 += v640 + v534;
            uint64_t v524 = &v533[v535];
            v641 += v640 + v534;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          uint64_t result = v622;
          v16 += v525 + v622;
          v14 += v525 + v621;
          --v10;
        }
        while (v10);
      }
      return result;
    case 12:
      uint64_t v253 = v24;
      if (v8)
      {
        uint64_t v254 = v21;
        uint64_t v255 = -(v640 * v21);
        uint64_t v256 = -(v623 * v254);
        uint64_t v257 = v12;
        uint64_t v258 = -(uint64_t)v20;
        do
        {
          uint64_t v259 = 0;
          int v260 = v624;
          do
          {
            if (*(unsigned char *)(v16 + v259))
            {
              if (v19) {
                int v261 = *v12;
              }
              else {
                int v261 = 255;
              }
              int v262 = *v13;
              unsigned int v263 = (v262 | (v261 << 16)) * (*(unsigned __int8 *)(v16 + v259) ^ 0xFF)
                   + 65537
                   + ((((v262 | (v261 << 16)) * (*(unsigned __int8 *)(v16 + v259) ^ 0xFFu)) >> 8) & 0xFF00FF);
              unsigned int v264 = (v262 | (v261 << 24)) - (v263 & 0xFF000000 | BYTE1(v263));
              unsigned int v265 = (*(unsigned __int8 *)(v14 + v259) | (*v7 << 16))
                   + v264
                   + (HIBYTE(v264) << 16);
              int v266 = (255 * ((v265 >> 8) & 0x10001)) | v265;
              *(unsigned char *)(v14 + v259) = v266;
              *int v7 = BYTE2(v266);
            }
            v7 += v8;
            if ((unint64_t)&v13[v253] >= v25) {
              uint64_t v267 = v258;
            }
            else {
              uint64_t v267 = 0;
            }
            v12 += v19 + v267;
            v13 += v253 + v267;
            v259 += v253;
            --v260;
          }
          while (v260);
          if (v620)
          {
            uint64_t v268 = &v257[v623];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v269 = v255;
            }
            else {
              uint64_t v269 = 0;
            }
            uint64_t v13 = &v641[v640 + v269];
            if ((unint64_t)&v641[v640] >= v620) {
              uint64_t v270 = v256;
            }
            else {
              uint64_t v270 = 0;
            }
            unint64_t v12 = &v268[v270];
            v25 += v640 + v269;
            uint64_t v257 = &v268[v270];
            v641 += v640 + v269;
          }
          else
          {
            v13 += v640;
            v12 += v623;
          }
          uint64_t result = v14 + v259;
          v16 += v259 + v622;
          v14 += v259 + v621;
          v7 += v619;
          --v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v536 = -(uint64_t)v20;
        uint64_t v537 = -(v640 * v21);
        do
        {
          uint64_t v538 = 0;
          int v539 = v624;
          do
          {
            if (*(unsigned char *)(v16 + v538))
            {
              unsigned int v540 = *(unsigned __int8 *)(v14 + v538)
                   + (*v13
                                     - ((unsigned __int16)(*v13
                                                         * (*(unsigned __int8 *)(v16 + v538) ^ 0xFF)
                                                         + ((*v13
                                                           * (*(unsigned __int8 *)(v16 + v538) ^ 0xFFu)) >> 8)
                                                         + 1) >> 8));
              *(unsigned char *)(v14 + v538) = -(v540 >> 8) | v540;
            }
            if ((unint64_t)&v13[v24] >= v25) {
              uint64_t v541 = v536;
            }
            else {
              uint64_t v541 = 0;
            }
            v13 += v24 + v541;
            v538 += v24;
            --v539;
          }
          while (v539);
          v16 += v538 + v622;
          v14 += v538 + v621;
          int v542 = v641;
          if ((unint64_t)&v641[v640] >= v620) {
            uint64_t v543 = v537;
          }
          else {
            uint64_t v543 = 0;
          }
          int v544 = &v641[v640 + v543];
          unint64_t v545 = v25 + v640 + v543;
          if (v620) {
            int v542 = v544;
          }
          int v641 = v542;
          if (v620)
          {
            unint64_t v25 = v545;
            uint64_t v13 = v544;
          }
          else
          {
            v13 += v640;
          }
          --v10;
        }
        while (v10);
      }
      return result;
    case 13:
      uint64_t v271 = v24;
      uint64_t v272 = v8;
      uint64_t v273 = v19;
      uint64_t v274 = -(uint64_t)v20;
      uint64_t v559 = -(v623 * v21);
      uint64_t v574 = -(v640 * v21);
      int v589 = v12;
      uint64_t v604 = v8;
      do
      {
        int v625 = v10;
        uint64_t v275 = 0;
        int v276 = v624;
        unint64_t v644 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v275))
          {
            int v277 = v19 ? *v12 : 255;
            int v278 = *v13;
            unsigned int v279 = (v278 | (v277 << 16)) * (*(unsigned __int8 *)(v16 + v275) ^ 0xFF)
                 + 65537
                 + ((((v278 | (v277 << 16)) * (*(unsigned __int8 *)(v16 + v275) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v278 | (v277 << 24)) - (v279 & 0xFF000000 | BYTE1(v279));
            unsigned int v280 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAmultiplyPDA_17518(*(unsigned __int8 *)(v14 + v275), *v7, (v278- ((unsigned __int16)(v278 * (*(unsigned __int8 *)(v16 + v275) ^ 0xFF)+ 1+ ((unsigned __int16)(v278 * (*(unsigned __int8 *)(v16 + v275) ^ 0xFF)) >> 8)) >> 8)), v280);
                  uint64_t v272 = v604;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v644;
                  unsigned int v280 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v275) = result;
                *int v7 = v280;
              }
              else
              {
                uint64_t result = PDAmultiplyPDA_17518(*(unsigned __int8 *)(v14 + v275), 255, (v278- ((unsigned __int16)(v278 * (*(unsigned __int8 *)(v16 + v275) ^ 0xFF)+ 1+ ((unsigned __int16)(v278 * (*(unsigned __int8 *)(v16 + v275) ^ 0xFF)) >> 8)) >> 8)), v280);
                uint64_t v272 = v604;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v644;
                *(unsigned char *)(v644 + v275) = result;
              }
            }
          }
          v7 += v272;
          if ((unint64_t)&v13[v271] >= v25) {
            uint64_t v281 = v274;
          }
          else {
            uint64_t v281 = 0;
          }
          v12 += v273 + v281;
          v13 += v271 + v281;
          v275 += v271;
          --v276;
        }
        while (v276);
        if (v620)
        {
          uint64_t v282 = v574;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v282 = 0;
          }
          uint64_t v13 = &v641[v640 + v282];
          uint64_t v283 = v559;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v283 = 0;
          }
          unint64_t v12 = &v589[v623 + v283];
          v25 += v640 + v282;
          int v589 = v12;
          v641 += v640 + v282;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v275 + v622;
        v14 += v275 + v621;
        v7 += v619;
        int v10 = v625 - 1;
      }
      while (v625 != 1);
      return result;
    case 14:
      uint64_t v284 = v24;
      uint64_t v285 = v8;
      uint64_t v286 = v19;
      uint64_t v287 = -(uint64_t)v20;
      uint64_t v560 = -(v623 * v21);
      uint64_t v575 = -(v640 * v21);
      int v590 = v12;
      uint64_t v605 = v8;
      do
      {
        int v626 = v10;
        uint64_t v288 = 0;
        int v289 = v624;
        unint64_t v645 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v288))
          {
            int v290 = v19 ? *v12 : 255;
            int v291 = *v13;
            unsigned int v292 = (v291 | (v290 << 16)) * (*(unsigned __int8 *)(v16 + v288) ^ 0xFF)
                 + 65537
                 + ((((v291 | (v290 << 16)) * (*(unsigned __int8 *)(v16 + v288) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v291 | (v290 << 24)) - (v292 & 0xFF000000 | BYTE1(v292));
            unsigned int v293 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAscreenPDA_17519(*(unsigned __int8 *)(v14 + v288), *v7, (v291- ((unsigned __int16)(v291 * (*(unsigned __int8 *)(v16 + v288) ^ 0xFF)+ 1+ ((unsigned __int16)(v291 * (*(unsigned __int8 *)(v16 + v288) ^ 0xFF)) >> 8)) >> 8)), v293);
                  uint64_t v285 = v605;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v645;
                  unsigned int v293 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v288) = result;
                *int v7 = v293;
              }
              else
              {
                uint64_t result = PDAscreenPDA_17519(*(unsigned __int8 *)(v14 + v288), 255, (v291- ((unsigned __int16)(v291 * (*(unsigned __int8 *)(v16 + v288) ^ 0xFF)+ 1+ ((unsigned __int16)(v291 * (*(unsigned __int8 *)(v16 + v288) ^ 0xFF)) >> 8)) >> 8)), v293);
                uint64_t v285 = v605;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v645;
                *(unsigned char *)(v645 + v288) = result;
              }
            }
          }
          v7 += v285;
          if ((unint64_t)&v13[v284] >= v25) {
            uint64_t v294 = v287;
          }
          else {
            uint64_t v294 = 0;
          }
          v12 += v286 + v294;
          v13 += v284 + v294;
          v288 += v284;
          --v289;
        }
        while (v289);
        if (v620)
        {
          uint64_t v295 = v575;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v295 = 0;
          }
          uint64_t v13 = &v641[v640 + v295];
          uint64_t v296 = v560;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v296 = 0;
          }
          unint64_t v12 = &v590[v623 + v296];
          v25 += v640 + v295;
          int v590 = v12;
          v641 += v640 + v295;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v288 + v622;
        v14 += v288 + v621;
        v7 += v619;
        int v10 = v626 - 1;
      }
      while (v626 != 1);
      return result;
    case 15:
      uint64_t v297 = v24;
      uint64_t v298 = v8;
      uint64_t v299 = v19;
      uint64_t v300 = -(uint64_t)v20;
      uint64_t v561 = -(v623 * v21);
      uint64_t v576 = -(v640 * v21);
      int32x4_t v591 = v12;
      uint64_t v606 = v8;
      do
      {
        int v627 = v10;
        uint64_t v301 = 0;
        int v302 = v624;
        unint64_t v646 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v301))
          {
            int v303 = v19 ? *v12 : 255;
            int v304 = *v13;
            unsigned int v305 = (v304 | (v303 << 16)) * (*(unsigned __int8 *)(v16 + v301) ^ 0xFF)
                 + 65537
                 + ((((v304 | (v303 << 16)) * (*(unsigned __int8 *)(v16 + v301) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v304 | (v303 << 24)) - (v305 & 0xFF000000 | BYTE1(v305));
            unsigned int v306 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAoverlayPDA_17520(*(unsigned __int8 *)(v14 + v301), *v7, (v304- ((unsigned __int16)(v304 * (*(unsigned __int8 *)(v16 + v301) ^ 0xFF)+ 1+ ((unsigned __int16)(v304 * (*(unsigned __int8 *)(v16 + v301) ^ 0xFF)) >> 8)) >> 8)), v306);
                  uint64_t v298 = v606;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v646;
                  unsigned int v306 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v301) = result;
                *int v7 = v306;
              }
              else
              {
                uint64_t result = PDAoverlayPDA_17520(*(unsigned __int8 *)(v14 + v301), 0xFFu, (v304- ((unsigned __int16)(v304 * (*(unsigned __int8 *)(v16 + v301) ^ 0xFF)+ 1+ ((unsigned __int16)(v304 * (*(unsigned __int8 *)(v16 + v301) ^ 0xFF)) >> 8)) >> 8)), v306);
                uint64_t v298 = v606;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v646;
                *(unsigned char *)(v646 + v301) = result;
              }
            }
          }
          v7 += v298;
          if ((unint64_t)&v13[v297] >= v25) {
            uint64_t v307 = v300;
          }
          else {
            uint64_t v307 = 0;
          }
          v12 += v299 + v307;
          v13 += v297 + v307;
          v301 += v297;
          --v302;
        }
        while (v302);
        if (v620)
        {
          uint64_t v308 = v576;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v308 = 0;
          }
          uint64_t v13 = &v641[v640 + v308];
          uint64_t v309 = v561;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v309 = 0;
          }
          unint64_t v12 = &v591[v623 + v309];
          v25 += v640 + v308;
          int32x4_t v591 = v12;
          v641 += v640 + v308;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v301 + v622;
        v14 += v301 + v621;
        v7 += v619;
        int v10 = v627 - 1;
      }
      while (v627 != 1);
      return result;
    case 16:
      uint64_t v310 = v24;
      uint64_t v311 = v8;
      uint64_t v312 = v19;
      uint64_t v313 = -(uint64_t)v20;
      uint64_t v562 = -(v623 * v21);
      uint64_t v577 = -(v640 * v21);
      int32x4_t v592 = v12;
      uint64_t v607 = v8;
      do
      {
        int v628 = v10;
        uint64_t v314 = 0;
        int v315 = v624;
        unint64_t v647 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v314))
          {
            int v316 = v19 ? *v12 : 255;
            int v317 = *v13;
            unsigned int v318 = (v317 | (v316 << 16)) * (*(unsigned __int8 *)(v16 + v314) ^ 0xFF)
                 + 65537
                 + ((((v317 | (v316 << 16)) * (*(unsigned __int8 *)(v16 + v314) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v317 | (v316 << 24)) - (v318 & 0xFF000000 | BYTE1(v318));
            unsigned int v319 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAdarkenPDA_17522(*(unsigned __int8 *)(v14 + v314), *v7, (v317- ((unsigned __int16)(v317 * (*(unsigned __int8 *)(v16 + v314) ^ 0xFF)+ 1+ ((unsigned __int16)(v317 * (*(unsigned __int8 *)(v16 + v314) ^ 0xFF)) >> 8)) >> 8)), v319);
                  uint64_t v311 = v607;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v647;
                  unsigned int v319 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v314) = result;
                *int v7 = v319;
              }
              else
              {
                uint64_t result = PDAdarkenPDA_17522(*(unsigned __int8 *)(v14 + v314), 0xFFu, (v317- ((unsigned __int16)(v317 * (*(unsigned __int8 *)(v16 + v314) ^ 0xFF)+ 1+ ((unsigned __int16)(v317 * (*(unsigned __int8 *)(v16 + v314) ^ 0xFF)) >> 8)) >> 8)), v319);
                uint64_t v311 = v607;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v647;
                *(unsigned char *)(v647 + v314) = result;
              }
            }
          }
          v7 += v311;
          if ((unint64_t)&v13[v310] >= v25) {
            uint64_t v320 = v313;
          }
          else {
            uint64_t v320 = 0;
          }
          v12 += v312 + v320;
          v13 += v310 + v320;
          v314 += v310;
          --v315;
        }
        while (v315);
        if (v620)
        {
          uint64_t v321 = v577;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v321 = 0;
          }
          uint64_t v13 = &v641[v640 + v321];
          uint64_t v322 = v562;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v322 = 0;
          }
          unint64_t v12 = &v592[v623 + v322];
          v25 += v640 + v321;
          int32x4_t v592 = v12;
          v641 += v640 + v321;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v314 + v622;
        v14 += v314 + v621;
        v7 += v619;
        int v10 = v628 - 1;
      }
      while (v628 != 1);
      return result;
    case 17:
      uint64_t v323 = v24;
      uint64_t v324 = v8;
      uint64_t v325 = v19;
      uint64_t v326 = -(uint64_t)v20;
      uint64_t v563 = -(v623 * v21);
      uint64_t v578 = -(v640 * v21);
      int32x4_t v593 = v12;
      uint64_t v608 = v8;
      do
      {
        int v629 = v10;
        uint64_t v327 = 0;
        int v328 = v624;
        unint64_t v648 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v327))
          {
            int v329 = v19 ? *v12 : 255;
            int v330 = *v13;
            unsigned int v331 = (v330 | (v329 << 16)) * (*(unsigned __int8 *)(v16 + v327) ^ 0xFF)
                 + 65537
                 + ((((v330 | (v329 << 16)) * (*(unsigned __int8 *)(v16 + v327) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v330 | (v329 << 24)) - (v331 & 0xFF000000 | BYTE1(v331));
            unsigned int v332 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAlightenPDA_17521(*(unsigned __int8 *)(v14 + v327), *v7, (v330- ((unsigned __int16)(v330 * (*(unsigned __int8 *)(v16 + v327) ^ 0xFF)+ 1+ ((unsigned __int16)(v330 * (*(unsigned __int8 *)(v16 + v327) ^ 0xFF)) >> 8)) >> 8)), v332);
                  uint64_t v324 = v608;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v648;
                  unsigned int v332 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v327) = result;
                *int v7 = v332;
              }
              else
              {
                uint64_t result = PDAlightenPDA_17521(*(unsigned __int8 *)(v14 + v327), 0xFFu, (v330- ((unsigned __int16)(v330 * (*(unsigned __int8 *)(v16 + v327) ^ 0xFF)+ 1+ ((unsigned __int16)(v330 * (*(unsigned __int8 *)(v16 + v327) ^ 0xFF)) >> 8)) >> 8)), v332);
                uint64_t v324 = v608;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v648;
                *(unsigned char *)(v648 + v327) = result;
              }
            }
          }
          v7 += v324;
          if ((unint64_t)&v13[v323] >= v25) {
            uint64_t v333 = v326;
          }
          else {
            uint64_t v333 = 0;
          }
          v12 += v325 + v333;
          v13 += v323 + v333;
          v327 += v323;
          --v328;
        }
        while (v328);
        if (v620)
        {
          uint64_t v334 = v578;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v334 = 0;
          }
          uint64_t v13 = &v641[v640 + v334];
          uint64_t v335 = v563;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v335 = 0;
          }
          unint64_t v12 = &v593[v623 + v335];
          v25 += v640 + v334;
          int32x4_t v593 = v12;
          v641 += v640 + v334;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v327 + v622;
        v14 += v327 + v621;
        v7 += v619;
        int v10 = v629 - 1;
      }
      while (v629 != 1);
      return result;
    case 18:
      uint64_t v336 = v24;
      uint64_t v337 = v8;
      uint64_t v338 = v19;
      uint64_t v339 = -(uint64_t)v20;
      uint64_t v564 = -(v623 * v21);
      uint64_t v579 = -(v640 * v21);
      int32x4_t v594 = v12;
      uint64_t v609 = v8;
      do
      {
        int v630 = v10;
        uint64_t v340 = 0;
        int v341 = v624;
        unint64_t v649 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v340))
          {
            int v342 = v19 ? *v12 : 255;
            int v343 = *v13;
            unsigned int v344 = (v343 | (v342 << 16)) * (*(unsigned __int8 *)(v16 + v340) ^ 0xFF)
                 + 65537
                 + ((((v343 | (v342 << 16)) * (*(unsigned __int8 *)(v16 + v340) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v343 | (v342 << 24)) - (v344 & 0xFF000000 | BYTE1(v344));
            unsigned int v345 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAcolordodgePDA_17523(*(unsigned __int8 *)(v14 + v340), *v7, (v343- ((unsigned __int16)(v343 * (*(unsigned __int8 *)(v16 + v340) ^ 0xFF)+ 1+ ((unsigned __int16)(v343 * (*(unsigned __int8 *)(v16 + v340) ^ 0xFF)) >> 8)) >> 8)), v345);
                  uint64_t v337 = v609;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v649;
                  unsigned int v345 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v340) = result;
                *int v7 = v345;
              }
              else
              {
                uint64_t result = PDAcolordodgePDA_17523(*(unsigned __int8 *)(v14 + v340), 0xFFu, (v343- ((unsigned __int16)(v343 * (*(unsigned __int8 *)(v16 + v340) ^ 0xFF)+ 1+ ((unsigned __int16)(v343 * (*(unsigned __int8 *)(v16 + v340) ^ 0xFF)) >> 8)) >> 8)), v345);
                uint64_t v337 = v609;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v649;
                *(unsigned char *)(v649 + v340) = result;
              }
            }
          }
          v7 += v337;
          if ((unint64_t)&v13[v336] >= v25) {
            uint64_t v346 = v339;
          }
          else {
            uint64_t v346 = 0;
          }
          v12 += v338 + v346;
          v13 += v336 + v346;
          v340 += v336;
          --v341;
        }
        while (v341);
        if (v620)
        {
          uint64_t v347 = v579;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v347 = 0;
          }
          uint64_t v13 = &v641[v640 + v347];
          uint64_t v348 = v564;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v348 = 0;
          }
          unint64_t v12 = &v594[v623 + v348];
          v25 += v640 + v347;
          int32x4_t v594 = v12;
          v641 += v640 + v347;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v340 + v622;
        v14 += v340 + v621;
        v7 += v619;
        int v10 = v630 - 1;
      }
      while (v630 != 1);
      return result;
    case 19:
      uint64_t v349 = v24;
      uint64_t v350 = v8;
      uint64_t v351 = v19;
      uint64_t v352 = -(uint64_t)v20;
      uint64_t v565 = -(v623 * v21);
      uint64_t v580 = -(v640 * v21);
      int v595 = v12;
      uint64_t v610 = v8;
      do
      {
        int v631 = v10;
        uint64_t v353 = 0;
        int v354 = v624;
        unint64_t v650 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v353))
          {
            int v355 = v19 ? *v12 : 255;
            int v356 = *v13;
            unsigned int v357 = (v356 | (v355 << 16)) * (*(unsigned __int8 *)(v16 + v353) ^ 0xFF)
                 + 65537
                 + ((((v356 | (v355 << 16)) * (*(unsigned __int8 *)(v16 + v353) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v356 | (v355 << 24)) - (v357 & 0xFF000000 | BYTE1(v357));
            unsigned int v358 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAcolorburnPDA_17524(*(unsigned __int8 *)(v14 + v353), *v7, (v356- ((unsigned __int16)(v356 * (*(unsigned __int8 *)(v16 + v353) ^ 0xFF)+ 1+ ((unsigned __int16)(v356 * (*(unsigned __int8 *)(v16 + v353) ^ 0xFF)) >> 8)) >> 8)), v358);
                  uint64_t v350 = v610;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v650;
                  unsigned int v358 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v353) = result;
                *int v7 = v358;
              }
              else
              {
                uint64_t result = PDAcolorburnPDA_17524(*(unsigned __int8 *)(v14 + v353), 0xFFu, (v356- ((unsigned __int16)(v356 * (*(unsigned __int8 *)(v16 + v353) ^ 0xFF)+ 1+ ((unsigned __int16)(v356 * (*(unsigned __int8 *)(v16 + v353) ^ 0xFF)) >> 8)) >> 8)), v358);
                uint64_t v350 = v610;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v650;
                *(unsigned char *)(v650 + v353) = result;
              }
            }
          }
          v7 += v350;
          if ((unint64_t)&v13[v349] >= v25) {
            uint64_t v359 = v352;
          }
          else {
            uint64_t v359 = 0;
          }
          v12 += v351 + v359;
          v13 += v349 + v359;
          v353 += v349;
          --v354;
        }
        while (v354);
        if (v620)
        {
          uint64_t v360 = v580;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v360 = 0;
          }
          uint64_t v13 = &v641[v640 + v360];
          uint64_t v361 = v565;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v361 = 0;
          }
          unint64_t v12 = &v595[v623 + v361];
          v25 += v640 + v360;
          int v595 = v12;
          v641 += v640 + v360;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v353 + v622;
        v14 += v353 + v621;
        v7 += v619;
        int v10 = v631 - 1;
      }
      while (v631 != 1);
      return result;
    case 20:
      uint64_t v362 = v24;
      uint64_t v363 = v8;
      uint64_t v364 = v19;
      uint64_t v365 = -(uint64_t)v20;
      uint64_t v566 = -(v623 * v21);
      uint64_t v581 = -(v640 * v21);
      v596 = v12;
      uint64_t v611 = v8;
      do
      {
        int v632 = v10;
        uint64_t v366 = 0;
        int v367 = v624;
        unint64_t v651 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v366))
          {
            int v368 = v19 ? *v12 : 255;
            int v369 = *v13;
            unsigned int v370 = (v369 | (v368 << 16)) * (*(unsigned __int8 *)(v16 + v366) ^ 0xFF)
                 + 65537
                 + ((((v369 | (v368 << 16)) * (*(unsigned __int8 *)(v16 + v366) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v369 | (v368 << 24)) - (v370 & 0xFF000000 | BYTE1(v370));
            unsigned int v371 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAsoftlightPDA_17526(*(unsigned __int8 *)(v14 + v366), *v7, (v369- ((unsigned __int16)(v369 * (*(unsigned __int8 *)(v16 + v366) ^ 0xFF)+ 1+ ((unsigned __int16)(v369 * (*(unsigned __int8 *)(v16 + v366) ^ 0xFF)) >> 8)) >> 8)), v371);
                  uint64_t v363 = v611;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v651;
                  unsigned int v371 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v366) = result;
                *int v7 = v371;
              }
              else
              {
                uint64_t result = PDAsoftlightPDA_17526(*(unsigned __int8 *)(v14 + v366), 0xFFu, (v369- ((unsigned __int16)(v369 * (*(unsigned __int8 *)(v16 + v366) ^ 0xFF)+ 1+ ((unsigned __int16)(v369 * (*(unsigned __int8 *)(v16 + v366) ^ 0xFF)) >> 8)) >> 8)), v371);
                uint64_t v363 = v611;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v651;
                *(unsigned char *)(v651 + v366) = result;
              }
            }
          }
          v7 += v363;
          if ((unint64_t)&v13[v362] >= v25) {
            uint64_t v372 = v365;
          }
          else {
            uint64_t v372 = 0;
          }
          v12 += v364 + v372;
          v13 += v362 + v372;
          v366 += v362;
          --v367;
        }
        while (v367);
        if (v620)
        {
          uint64_t v373 = v581;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v373 = 0;
          }
          uint64_t v13 = &v641[v640 + v373];
          uint64_t v374 = v566;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v374 = 0;
          }
          unint64_t v12 = &v596[v623 + v374];
          v25 += v640 + v373;
          v596 = v12;
          v641 += v640 + v373;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v366 + v622;
        v14 += v366 + v621;
        v7 += v619;
        int v10 = v632 - 1;
      }
      while (v632 != 1);
      return result;
    case 21:
      uint64_t v375 = v24;
      uint64_t v376 = v8;
      uint64_t v377 = v19;
      uint64_t v378 = -(uint64_t)v20;
      uint64_t v567 = -(v623 * v21);
      uint64_t v582 = -(v640 * v21);
      unsigned int v597 = v12;
      uint64_t v612 = v8;
      do
      {
        int v633 = v10;
        uint64_t v379 = 0;
        int v380 = v624;
        unint64_t v652 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v379))
          {
            int v381 = v19 ? *v12 : 255;
            int v382 = *v13;
            unsigned int v383 = (v382 | (v381 << 16)) * (*(unsigned __int8 *)(v16 + v379) ^ 0xFF)
                 + 65537
                 + ((((v382 | (v381 << 16)) * (*(unsigned __int8 *)(v16 + v379) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v382 | (v381 << 24)) - (v383 & 0xFF000000 | BYTE1(v383));
            unsigned int v384 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAhardlightPDA_17525(*(unsigned __int8 *)(v14 + v379), *v7, (v382- ((unsigned __int16)(v382 * (*(unsigned __int8 *)(v16 + v379) ^ 0xFF)+ 1+ ((unsigned __int16)(v382 * (*(unsigned __int8 *)(v16 + v379) ^ 0xFF)) >> 8)) >> 8)), v384);
                  uint64_t v376 = v612;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v652;
                  unsigned int v384 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v379) = result;
                *int v7 = v384;
              }
              else
              {
                uint64_t result = PDAhardlightPDA_17525(*(unsigned __int8 *)(v14 + v379), 0xFFu, (v382- ((unsigned __int16)(v382 * (*(unsigned __int8 *)(v16 + v379) ^ 0xFF)+ 1+ ((unsigned __int16)(v382 * (*(unsigned __int8 *)(v16 + v379) ^ 0xFF)) >> 8)) >> 8)), v384);
                uint64_t v376 = v612;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v652;
                *(unsigned char *)(v652 + v379) = result;
              }
            }
          }
          v7 += v376;
          if ((unint64_t)&v13[v375] >= v25) {
            uint64_t v385 = v378;
          }
          else {
            uint64_t v385 = 0;
          }
          v12 += v377 + v385;
          v13 += v375 + v385;
          v379 += v375;
          --v380;
        }
        while (v380);
        if (v620)
        {
          uint64_t v386 = v582;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v386 = 0;
          }
          uint64_t v13 = &v641[v640 + v386];
          uint64_t v387 = v567;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v387 = 0;
          }
          unint64_t v12 = &v597[v623 + v387];
          v25 += v640 + v386;
          unsigned int v597 = v12;
          v641 += v640 + v386;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v379 + v622;
        v14 += v379 + v621;
        v7 += v619;
        int v10 = v633 - 1;
      }
      while (v633 != 1);
      return result;
    case 22:
      uint64_t v388 = v24;
      uint64_t v389 = v8;
      uint64_t v390 = v19;
      uint64_t v391 = -(uint64_t)v20;
      uint64_t v568 = -(v623 * v21);
      uint64_t v583 = -(v640 * v21);
      v598 = v12;
      uint64_t v613 = v8;
      do
      {
        int v634 = v10;
        uint64_t v392 = 0;
        int v393 = v624;
        unint64_t v653 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v392))
          {
            int v394 = v19 ? *v12 : 255;
            int v395 = *v13;
            unsigned int v396 = (v395 | (v394 << 16)) * (*(unsigned __int8 *)(v16 + v392) ^ 0xFF)
                 + 65537
                 + ((((v395 | (v394 << 16)) * (*(unsigned __int8 *)(v16 + v392) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v395 | (v394 << 24)) - (v396 & 0xFF000000 | BYTE1(v396));
            unsigned int v397 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAdifferencePDA_17527(*(unsigned __int8 *)(v14 + v392), *v7, (v395- ((unsigned __int16)(v395 * (*(unsigned __int8 *)(v16 + v392) ^ 0xFF)+ 1+ ((unsigned __int16)(v395 * (*(unsigned __int8 *)(v16 + v392) ^ 0xFF)) >> 8)) >> 8)), v397);
                  uint64_t v389 = v613;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v653;
                  unsigned int v397 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v392) = result;
                *int v7 = v397;
              }
              else
              {
                uint64_t result = PDAdifferencePDA_17527(*(unsigned __int8 *)(v14 + v392), 0xFFu, (v395- ((unsigned __int16)(v395 * (*(unsigned __int8 *)(v16 + v392) ^ 0xFF)+ 1+ ((unsigned __int16)(v395 * (*(unsigned __int8 *)(v16 + v392) ^ 0xFF)) >> 8)) >> 8)), v397);
                uint64_t v389 = v613;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v653;
                *(unsigned char *)(v653 + v392) = result;
              }
            }
          }
          v7 += v389;
          if ((unint64_t)&v13[v388] >= v25) {
            uint64_t v398 = v391;
          }
          else {
            uint64_t v398 = 0;
          }
          v12 += v390 + v398;
          v13 += v388 + v398;
          v392 += v388;
          --v393;
        }
        while (v393);
        if (v620)
        {
          uint64_t v399 = v583;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v399 = 0;
          }
          uint64_t v13 = &v641[v640 + v399];
          uint64_t v400 = v568;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v400 = 0;
          }
          unint64_t v12 = &v598[v623 + v400];
          v25 += v640 + v399;
          v598 = v12;
          v641 += v640 + v399;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v392 + v622;
        v14 += v392 + v621;
        v7 += v619;
        int v10 = v634 - 1;
      }
      while (v634 != 1);
      return result;
    case 23:
      uint64_t v401 = v24;
      uint64_t v402 = v8;
      uint64_t v403 = v19;
      uint64_t v404 = -(uint64_t)v20;
      uint64_t v569 = -(v623 * v21);
      uint64_t v584 = -(v640 * v21);
      unsigned int v599 = v12;
      uint64_t v614 = v8;
      do
      {
        int v635 = v10;
        uint64_t v405 = 0;
        int v406 = v624;
        unint64_t v654 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v405))
          {
            int v407 = v19 ? *v12 : 255;
            int v408 = *v13;
            unsigned int v409 = (v408 | (v407 << 16)) * (*(unsigned __int8 *)(v16 + v405) ^ 0xFF)
                 + 65537
                 + ((((v408 | (v407 << 16)) * (*(unsigned __int8 *)(v16 + v405) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v408 | (v407 << 24)) - (v409 & 0xFF000000 | BYTE1(v409));
            unsigned int v410 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAexclusionPDA_17528(*(unsigned __int8 *)(v14 + v405), *v7, (v408- ((unsigned __int16)(v408 * (*(unsigned __int8 *)(v16 + v405) ^ 0xFF)+ 1+ ((unsigned __int16)(v408 * (*(unsigned __int8 *)(v16 + v405) ^ 0xFF)) >> 8)) >> 8)), v410);
                  uint64_t v402 = v614;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v654;
                  unsigned int v410 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v405) = result;
                *int v7 = v410;
              }
              else
              {
                uint64_t result = PDAexclusionPDA_17528(*(unsigned __int8 *)(v14 + v405), 0xFFu, (v408- ((unsigned __int16)(v408 * (*(unsigned __int8 *)(v16 + v405) ^ 0xFF)+ 1+ ((unsigned __int16)(v408 * (*(unsigned __int8 *)(v16 + v405) ^ 0xFF)) >> 8)) >> 8)), v410);
                uint64_t v402 = v614;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v654;
                *(unsigned char *)(v654 + v405) = result;
              }
            }
          }
          v7 += v402;
          if ((unint64_t)&v13[v401] >= v25) {
            uint64_t v411 = v404;
          }
          else {
            uint64_t v411 = 0;
          }
          v12 += v403 + v411;
          v13 += v401 + v411;
          v405 += v401;
          --v406;
        }
        while (v406);
        if (v620)
        {
          uint64_t v412 = v584;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v412 = 0;
          }
          uint64_t v13 = &v641[v640 + v412];
          uint64_t v413 = v569;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v413 = 0;
          }
          unint64_t v12 = &v599[v623 + v413];
          v25 += v640 + v412;
          unsigned int v599 = v12;
          v641 += v640 + v412;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v405 + v622;
        v14 += v405 + v621;
        v7 += v619;
        int v10 = v635 - 1;
      }
      while (v635 != 1);
      return result;
    case 24:
      uint64_t v414 = v24;
      uint64_t v415 = v8;
      uint64_t v416 = v19;
      uint64_t v417 = -(uint64_t)v20;
      uint64_t v570 = -(v623 * v21);
      uint64_t v585 = -(v640 * v21);
      int8x8_t v600 = v12;
      uint64_t v615 = v8;
      do
      {
        int v636 = v10;
        uint64_t v418 = 0;
        int v419 = v624;
        unint64_t v655 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v418))
          {
            int v420 = v19 ? *v12 : 255;
            int v421 = *v13;
            unsigned int v422 = (v421 | (v420 << 16)) * (*(unsigned __int8 *)(v16 + v418) ^ 0xFF)
                 + 65537
                 + ((((v421 | (v420 << 16)) * (*(unsigned __int8 *)(v16 + v418) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v421 | (v420 << 24)) - (v422 & 0xFF000000 | BYTE1(v422));
            unsigned int v423 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAhuePDA_17529(*(unsigned __int8 *)(v14 + v418), *v7, (v421- ((unsigned __int16)(v421 * (*(unsigned __int8 *)(v16 + v418) ^ 0xFF)+ 1+ ((unsigned __int16)(v421 * (*(unsigned __int8 *)(v16 + v418) ^ 0xFF)) >> 8)) >> 8)), v423);
                  uint64_t v415 = v615;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v655;
                  unsigned int v423 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v418) = result;
                *int v7 = v423;
              }
              else
              {
                uint64_t result = PDAhuePDA_17529(*(unsigned __int8 *)(v14 + v418), 0xFFu, (v421- ((unsigned __int16)(v421 * (*(unsigned __int8 *)(v16 + v418) ^ 0xFF)+ 1+ ((unsigned __int16)(v421 * (*(unsigned __int8 *)(v16 + v418) ^ 0xFF)) >> 8)) >> 8)), v423);
                uint64_t v415 = v615;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v655;
                *(unsigned char *)(v655 + v418) = result;
              }
            }
          }
          v7 += v415;
          if ((unint64_t)&v13[v414] >= v25) {
            uint64_t v424 = v417;
          }
          else {
            uint64_t v424 = 0;
          }
          v12 += v416 + v424;
          v13 += v414 + v424;
          v418 += v414;
          --v419;
        }
        while (v419);
        if (v620)
        {
          uint64_t v425 = v585;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v425 = 0;
          }
          uint64_t v13 = &v641[v640 + v425];
          uint64_t v426 = v570;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v426 = 0;
          }
          unint64_t v12 = &v600[v623 + v426];
          v25 += v640 + v425;
          int8x8_t v600 = v12;
          v641 += v640 + v425;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v418 + v622;
        v14 += v418 + v621;
        v7 += v619;
        int v10 = v636 - 1;
      }
      while (v636 != 1);
      return result;
    case 25:
      uint64_t v427 = v24;
      uint64_t v428 = v8;
      uint64_t v429 = v19;
      uint64_t v430 = -(uint64_t)v20;
      uint64_t v571 = -(v623 * v21);
      uint64_t v586 = -(v640 * v21);
      uint64_t v601 = v12;
      uint64_t v616 = v8;
      do
      {
        int v637 = v10;
        uint64_t v431 = 0;
        int v432 = v624;
        unint64_t v656 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v431))
          {
            int v433 = v19 ? *v12 : 255;
            int v434 = *v13;
            unsigned int v435 = (v434 | (v433 << 16)) * (*(unsigned __int8 *)(v16 + v431) ^ 0xFF)
                 + 65537
                 + ((((v434 | (v433 << 16)) * (*(unsigned __int8 *)(v16 + v431) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v434 | (v433 << 24)) - (v435 & 0xFF000000 | BYTE1(v435));
            unsigned int v436 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAhuePDA_17529(*(unsigned __int8 *)(v14 + v431), *v7, (v434- ((unsigned __int16)(v434 * (*(unsigned __int8 *)(v16 + v431) ^ 0xFF)+ 1+ ((unsigned __int16)(v434 * (*(unsigned __int8 *)(v16 + v431) ^ 0xFF)) >> 8)) >> 8)), v436);
                  uint64_t v428 = v616;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v656;
                  unsigned int v436 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v431) = result;
                *int v7 = v436;
              }
              else
              {
                uint64_t result = PDAhuePDA_17529(*(unsigned __int8 *)(v14 + v431), 0xFFu, (v434- ((unsigned __int16)(v434 * (*(unsigned __int8 *)(v16 + v431) ^ 0xFF)+ 1+ ((unsigned __int16)(v434 * (*(unsigned __int8 *)(v16 + v431) ^ 0xFF)) >> 8)) >> 8)), v436);
                uint64_t v428 = v616;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v656;
                *(unsigned char *)(v656 + v431) = result;
              }
            }
          }
          v7 += v428;
          if ((unint64_t)&v13[v427] >= v25) {
            uint64_t v437 = v430;
          }
          else {
            uint64_t v437 = 0;
          }
          v12 += v429 + v437;
          v13 += v427 + v437;
          v431 += v427;
          --v432;
        }
        while (v432);
        if (v620)
        {
          uint64_t v438 = v586;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v438 = 0;
          }
          uint64_t v13 = &v641[v640 + v438];
          uint64_t v439 = v571;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v439 = 0;
          }
          unint64_t v12 = &v601[v623 + v439];
          v25 += v640 + v438;
          uint64_t v601 = v12;
          v641 += v640 + v438;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v431 + v622;
        v14 += v431 + v621;
        v7 += v619;
        int v10 = v637 - 1;
      }
      while (v637 != 1);
      return result;
    case 26:
      uint64_t v440 = v24;
      uint64_t v441 = v8;
      uint64_t v442 = v19;
      uint64_t v443 = -(uint64_t)v20;
      uint64_t v572 = -(v623 * v21);
      uint64_t v587 = -(v640 * v21);
      uint64_t v602 = v12;
      uint64_t v617 = v8;
      do
      {
        int v638 = v10;
        uint64_t v444 = 0;
        int v445 = v624;
        unint64_t v657 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v444))
          {
            int v446 = v19 ? *v12 : 255;
            int v447 = *v13;
            unsigned int v448 = (v447 | (v446 << 16)) * (*(unsigned __int8 *)(v16 + v444) ^ 0xFF)
                 + 65537
                 + ((((v447 | (v446 << 16)) * (*(unsigned __int8 *)(v16 + v444) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v447 | (v446 << 24)) - (v448 & 0xFF000000 | BYTE1(v448));
            unsigned int v449 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAluminosityPDA_17531((v447- ((unsigned __int16)(v447 * (*(unsigned __int8 *)(v16 + v444) ^ 0xFF)+ 1+ ((unsigned __int16)(v447 * (*(unsigned __int8 *)(v16 + v444) ^ 0xFF)) >> 8)) >> 8)), v449, *(unsigned __int8 *)(v14 + v444), *v7);
                  uint64_t v441 = v617;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v657;
                  unsigned int v449 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v444) = result;
                *int v7 = v449;
              }
              else
              {
                uint64_t result = PDAluminosityPDA_17531((v447- ((unsigned __int16)(v447 * (*(unsigned __int8 *)(v16 + v444) ^ 0xFF)+ 1+ ((unsigned __int16)(v447 * (*(unsigned __int8 *)(v16 + v444) ^ 0xFF)) >> 8)) >> 8)), v449, *(unsigned __int8 *)(v14 + v444), 0xFFu);
                uint64_t v441 = v617;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v657;
                *(unsigned char *)(v657 + v444) = result;
              }
            }
          }
          v7 += v441;
          if ((unint64_t)&v13[v440] >= v25) {
            uint64_t v450 = v443;
          }
          else {
            uint64_t v450 = 0;
          }
          v12 += v442 + v450;
          v13 += v440 + v450;
          v444 += v440;
          --v445;
        }
        while (v445);
        if (v620)
        {
          uint64_t v451 = v587;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v451 = 0;
          }
          uint64_t v13 = &v641[v640 + v451];
          uint64_t v452 = v572;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v452 = 0;
          }
          unint64_t v12 = &v602[v623 + v452];
          v25 += v640 + v451;
          uint64_t v602 = v12;
          v641 += v640 + v451;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v444 + v622;
        v14 += v444 + v621;
        v7 += v619;
        int v10 = v638 - 1;
      }
      while (v638 != 1);
      return result;
    case 27:
      uint64_t v453 = v24;
      uint64_t v454 = v8;
      uint64_t v455 = v19;
      uint64_t v588 = -(v640 * v21);
      int v603 = v12;
      uint64_t v573 = -(v623 * v21);
      uint64_t v456 = -(uint64_t)v20;
      uint64_t v618 = v8;
      do
      {
        int v639 = v10;
        uint64_t v457 = 0;
        int v458 = v624;
        unint64_t v658 = v14;
        do
        {
          if (*(unsigned char *)(v16 + v457))
          {
            int v459 = v19 ? *v12 : 255;
            int v460 = *v13;
            unsigned int v461 = (v460 | (v459 << 16)) * (*(unsigned __int8 *)(v16 + v457) ^ 0xFF)
                 + 65537
                 + ((((v460 | (v459 << 16)) * (*(unsigned __int8 *)(v16 + v457) ^ 0xFFu)) >> 8) & 0xFF00FF);
            uint64_t result = (v460 | (v459 << 24)) - (v461 & 0xFF000000 | BYTE1(v461));
            unsigned int v462 = BYTE3(result);
            if (BYTE3(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  uint64_t result = PDAluminosityPDA_17531(*(unsigned __int8 *)(v14 + v457), *v7, (v460- ((unsigned __int16)(v460 * (*(unsigned __int8 *)(v16 + v457) ^ 0xFF)+ 1+ ((unsigned __int16)(v460 * (*(unsigned __int8 *)(v16 + v457) ^ 0xFF)) >> 8)) >> 8)), v462);
                  uint64_t v454 = v618;
                  int v8 = v642;
                  int v19 = v643;
                  unint64_t v14 = v658;
                  unsigned int v462 = BYTE3(result);
                }
                *(unsigned char *)(v14 + v457) = result;
                *int v7 = v462;
              }
              else
              {
                uint64_t result = PDAluminosityPDA_17531(*(unsigned __int8 *)(v14 + v457), 0xFFu, (v460- ((unsigned __int16)(v460 * (*(unsigned __int8 *)(v16 + v457) ^ 0xFF)+ 1+ ((unsigned __int16)(v460 * (*(unsigned __int8 *)(v16 + v457) ^ 0xFF)) >> 8)) >> 8)), v462);
                uint64_t v454 = v618;
                int v8 = v642;
                int v19 = v643;
                unint64_t v14 = v658;
                *(unsigned char *)(v658 + v457) = result;
              }
            }
          }
          v7 += v454;
          if ((unint64_t)&v13[v453] >= v25) {
            uint64_t v463 = v456;
          }
          else {
            uint64_t v463 = 0;
          }
          v12 += v455 + v463;
          v13 += v453 + v463;
          v457 += v453;
          --v458;
        }
        while (v458);
        if (v620)
        {
          uint64_t v464 = v588;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v464 = 0;
          }
          uint64_t v13 = &v641[v640 + v464];
          uint64_t v465 = v573;
          if ((unint64_t)&v641[v640] < v620) {
            uint64_t v465 = 0;
          }
          unint64_t v12 = &v603[v623 + v465];
          v25 += v640 + v464;
          int v603 = v12;
          v641 += v640 + v464;
        }
        else
        {
          v13 += v640;
          v12 += v623;
        }
        v16 += v457 + v622;
        v14 += v457 + v621;
        v7 += v619;
        int v10 = v639 - 1;
      }
      while (v639 != 1);
      return result;
    default:
      return result;
  }
  do
  {
    uint64_t v482 = 0;
    int v483 = v624;
    do
    {
      int v484 = *(unsigned __int8 *)(v16 + v482);
      if (!*(unsigned char *)(v16 + v482)) {
        goto LABEL_739;
      }
      if (v484 == 255)
      {
        int v485 = *v12;
        if (!*v12) {
          goto LABEL_739;
        }
        if (v485 == 255) {
          LOBYTE(v486) = *v13;
        }
        else {
          unsigned int v486 = *v13
        }
               + ((*(unsigned __int8 *)(v14 + v482) * (v485 ^ 0xFF)
                 + ((*(unsigned __int8 *)(v14 + v482) * (v485 ^ 0xFFu)) >> 8)
                 + 1) >> 8);
      }
      else
      {
        int v487 = *v13;
        int v488 = *v12;
        unsigned int v489 = (v487 | (v488 << 16)) * (v484 ^ 0xFF)
             + 65537
             + ((((v487 | (v488 << 16)) * (v484 ^ 0xFFu)) >> 8) & 0xFF00FF);
        unsigned int v490 = (v487 | (v488 << 24)) - (v489 & 0xFF000000 | BYTE1(v489));
        if (!HIBYTE(v490)) {
          goto LABEL_739;
        }
        unsigned int v486 = v490
             + (((~v490 >> 24) * *(unsigned __int8 *)(v14 + v482)
               + (((~v490 >> 24) * *(unsigned __int8 *)(v14 + v482)) >> 8)
               + 1) >> 8);
      }
      *(unsigned char *)(v14 + v482) = v486;
LABEL_739:
      if ((unint64_t)&v13[v58] >= v25) {
        uint64_t v491 = v477;
      }
      else {
        uint64_t v491 = 0;
      }
      v12 += v19 + v491;
      v13 += v58 + v491;
      v482 += v58;
      --v483;
    }
    while (v483);
    if (v620)
    {
      char v492 = &v481[v623];
      if ((unint64_t)&v641[v640] >= v620) {
        uint64_t v493 = v479;
      }
      else {
        uint64_t v493 = 0;
      }
      uint64_t v13 = &v641[v640 + v493];
      if ((unint64_t)&v641[v640] >= v620) {
        uint64_t v494 = v480;
      }
      else {
        uint64_t v494 = 0;
      }
      unint64_t v12 = &v492[v494];
      v25 += v640 + v493;
      int v481 = &v492[v494];
      v641 += v640 + v493;
    }
    else
    {
      v13 += v640;
      v12 += v623;
    }
    uint64_t result = v622;
    v16 += v482 + v622;
    v14 += v482 + v621;
    --v10;
  }
  while (v10);
  return result;
}

CGDataProviderRef CGDataProviderCreatePartial(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t *a7, uint64_t *a8)
{
  DiCGRect rect = 0;
  if (!a1) {
    return Direct;
  }
  if (!a4) {
    return Direct;
  }
  unint64_t v9 = a5;
  if (!a5 || !a7 || !a8) {
    return Direct;
  }
  CGDataProviderRef v12 = (CGDataProviderRef)a1;
  unint64_t v13 = a6 * a2;
  uint64_t v14 = a6 * a4;
  uint64_t v15 = (a6 * a2) & 7;
  if (*(void (**)(uint64_t))(a1 + 72) != partial_release_info)
  {
    DiCGRect rect = 0;
    uint64_t v16 = *a8;
    unint64_t v17 = *a7;
    uint64_t v18 = *a8;
    switch(*a8)
    {
      case 1:
        goto LABEL_23;
      case 2:
        if (a6 & 0xF | *a7 & 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = 2;
        }
        goto LABEL_23;
      case 4:
        BOOL v25 = (a6 & 0x1F | *a7 & 3) == 0;
        uint64_t v26 = 4;
        goto LABEL_20;
      case 8:
        BOOL v25 = (a6 & 0x3F | *a7 & 7) == 0;
        uint64_t v26 = 8;
LABEL_20:
        if (v25) {
          uint64_t v18 = v26;
        }
        else {
          uint64_t v18 = 1;
        }
LABEL_23:
        unint64_t v24 = v17 * a3 + (v13 >> 3);
        unint64_t v23 = (unint64_t)(v14 + v15 + 7) >> 3;
        goto LABEL_24;
      default:
        return Direct;
    }
  }
  uint64_t v19 = *(void *)(a1 + 24);
  if (!v19) {
    return 0;
  }
  unint64_t v17 = *(void *)(v19 + 16);
  CGDataProviderRef v12 = *(CGDataProviderRef *)v19;
  unint64_t v20 = v17 * a3 + (v13 >> 3) + *(void *)(v19 + 8);
  unint64_t v21 = *(void *)(v19 + 72) + v15;
  unint64_t v22 = (unint64_t)(v14 + v15 + 7) >> 3;
  if (v22 >= *(void *)(v19 + 24)) {
    unint64_t v23 = *(void *)(v19 + 24);
  }
  else {
    unint64_t v23 = v22;
  }
  uint64_t v16 = *(void *)(v19 + 96);
  unint64_t v24 = v20 + (v21 >> 3);
  uint64_t v15 = v21 & 7;
  if (*(void *)(v19 + 32) < a5) {
    unint64_t v9 = *(void *)(v19 + 32);
  }
  uint64_t v18 = *(void *)(v19 + 96);
LABEL_24:
  if (v23 > v17) {
    return 0;
  }
  uint64_t v40 = v18;
  uint64_t v27 = (unint64_t *)malloc_type_malloc(0x68uLL, 0x2062DE7BuLL);
  v27[2] = v17;
  _OWORD v27[3] = v23;
  *uint64_t v27 = 0;
  v27[1] = v24;
  v27[4] = v9;
  v27[5] = 0;
  v27[6] = 0;
  v27[7] = v23 * v9;
  v27[8] = 0;
  v27[9] = v15;
  v27[10] = 0;
  v27[11] = 0;
  v27[12] = v16;
  if (v16 == v40 && !v15)
  {
    unint64_t v28 = *((void *)v12 + 4);
    if ((v28 & 0x8000000000000000) == 0)
    {
      off_t v29 = v23 + v17 * (v9 - 1);
      if (v29 + v24 <= v28)
      {
        if (CGDataProviderHasDataPtr(v12))
        {
          DiCGRect rect = CGDataProviderCreateDirect(v27, v29, &partial_direct_callbacks);
          uint64_t v35 = v40;
          goto LABEL_35;
        }
        if (*((void *)v12 + 12) || *((void *)v12 + 14) || *((void *)v12 + 10))
        {
          CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v27, v29, (uint64_t)&partial_internal_callbacks, v30, v31, v32, v33, v34);
          uint64_t v35 = v40;
          DiCGRect rect = v36;
LABEL_35:
          if (Direct) {
            goto LABEL_38;
          }
        }
      }
    }
  }
  CGDataProviderRef Sequential = CGDataProviderCreateSequential(v27, (const CGDataProviderSequentialCallbacks *)&partial_sequential_callbacks + (v15 != 0));
  DiCGRect rect = Sequential;
  if (!Sequential)
  {
    free(v27);
    return Direct;
  }
  *((void *)Sequential + 4) = v27[7];
  uint64_t v35 = v40;
LABEL_38:
  if (v16 == v35) {
    CGDataProviderRetain(v12);
  }
  else {
    CGDataProviderRef v12 = CGDataProviderCreateWithSwappedProvider(v12, v35);
  }
  *uint64_t v27 = (unint64_t)v12;
  if (!v12)
  {
    CGDataProviderRelease(Direct);
    return 0;
  }
  uint64_t v38 = v27 + 2;
  if (*((_DWORD *)Direct + 5) == 1) {
    uint64_t v38 = v27 + 3;
  }
  *a7 = *v38;
  *a8 = v16;
  return Direct;
}

void *CGDataProviderHasDataPtr(void *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
    }
    if (v2 == CGDataProviderGetTypeID_id) {
      return (void *)(v1[10] != 0);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t *__color_space_state_create_itur_709_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (uint64_t result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncITUR709Profile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_itur_709_s = v1;
  return result;
}

uint64_t (*__color_space_state_create_itur_709_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_itur_709_f = v1;
  return result;
}

uint64_t __cg_create_colorspace_block_invoke()
{
  return pthread_key_create(cg_colorspaces_key, (void (__cdecl *)(void *))cg_build_colorspace_destroy);
}

void *CGGlyphLockCreate()
{
  return malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
}

void __CGPDFDocumentCreateWithProvider_block_invoke()
{
  _ZZZ31CGPDFDocumentCreateWithProviderEUb_E21memory_pressure_queue = (uint64_t)dispatch_queue_create("com.apple.CoreGraphics.CGPDFDocumentMemoryPressureResponse", 0);
  _ZZZ31CGPDFDocumentCreateWithProviderEUb_E22memory_pressure_source = (uint64_t)dispatch_source_create(MEMORY[0x1E4F14468], 0, 6uLL, (dispatch_queue_t)_ZZZ31CGPDFDocumentCreateWithProviderEUb_E21memory_pressure_queue);
  dispatch_source_set_event_handler((dispatch_source_t)_ZZZ31CGPDFDocumentCreateWithProviderEUb_E22memory_pressure_source, &__block_literal_global_15);
  uint64_t v0 = _ZZZ31CGPDFDocumentCreateWithProviderEUb_E22memory_pressure_source;

  dispatch_resume(v0);
}

void __CGColorSpaceCreateWithName_block_invoke()
{
  v3[88] = *MEMORY[0x1E4F143B8];
  v3[0] = @"kCGColorSpaceDeviceGray";
  v3[1] = CGColorSpaceCreateDeviceGray;
  v3[2] = @"kCGColorSpaceDeviceRGB";
  v3[3] = CGColorSpaceCreateDeviceRGB;
  v3[4] = @"kCGColorSpaceDeviceCMYK";
  v3[5] = CGColorSpaceCreateDeviceCMYK;
  v3[6] = @"kCGColorSpaceUncalibratedGray";
  v3[7] = CGColorSpaceCreateUncalibratedGray;
  v3[8] = @"kCGColorSpaceUncalibratedRGB";
  v3[9] = CGColorSpaceCreateUncalibratedRGB;
  v3[10] = @"kCGColorSpaceUncalibratedCMYK";
  v3[11] = CGColorSpaceCreateUncalibratedCMYK;
  v3[12] = @"kCGColorSpaceGenericGray";
  v3[13] = CGColorSpaceCreateGenericGray;
  v3[14] = @"kCGColorSpaceGenericRGB";
  v3[15] = CGColorSpaceCreateGenericRGB;
  v3[16] = @"kCGColorSpaceGenericCMYK";
  v3[17] = CGColorSpaceCreateGenericCMYK;
  v3[18] = @"kCGColorSpaceDisplayP3";
  v3[19] = CGColorSpaceCreateDisplayP3;
  v3[20] = @"kCGColorSpaceExtendedDisplayP3";
  v3[21] = CGColorSpaceCreateExtendedDisplayP3;
  v3[22] = @"kCGColorSpaceLinearDisplayP3";
  v3[23] = CGColorSpaceCreateLinearDisplayP3;
  v3[24] = @"kCGColorSpaceExtendedLinearDisplayP3";
  v3[25] = CGColorSpaceCreateExtendedLinearDisplayP3;
  v3[26] = @"kCGColorSpaceDisplayP3_PQ";
  v3[27] = CGColorSpaceCreateDisplayP3_PQ;
  v3[28] = @"kCGColorSpaceDisplayP3_HLG";
  v3[29] = CGColorSpaceCreateDisplayP3_HLG;
  v3[30] = @"kCGColorSpaceDisplayP3_709OETF";
  v3[31] = CGColorSpaceCreateDisplayP3_709OETF;
  v3[32] = @"kCGColorSpaceGenericGrayGamma2_2";
  v3[33] = CGColorSpaceCreateGenericGrayGamma22;
  v3[34] = @"kCGColorSpaceAdobeRGB1998";
  v3[35] = CGColorSpaceCreateAdobeRGB1998;
  v3[36] = @"kCGColorSpaceSRGB";
  v3[37] = CGColorSpaceCreateSRGB;
  v3[38] = @"kCGColorSpaceGenericLab";
  v3[39] = CGColorSpaceCreateGenericLab;
  v3[40] = @"kCGColorSpaceGenericRGBLinear";
  v3[41] = CGColorSpaceCreateGenericRGBLinear;
  v3[42] = @"kCGColorSpaceGenericXYZ";
  v3[43] = CGColorSpaceCreateGenericXYZ;
  v3[44] = @"kCGColorSpaceACESCGLinear";
  v3[45] = CGColorSpaceCreateACESCGLinear;
  v3[46] = @"kCGColorSpaceITUR_709";
  v3[47] = CGColorSpaceCreateITUR_709;
  v3[48] = @"kCGColorSpaceITUR_709_PQ";
  v3[49] = CGColorSpaceCreateITUR_709_PQ;
  v3[50] = @"kCGColorSpaceITUR_709_HLG";
  v3[51] = CGColorSpaceCreateITUR_709_HLG;
  v3[52] = @"kCGColorSpaceITUR_2020";
  v3[53] = CGColorSpaceCreateITUR_2020;
  v3[54] = @"kCGColorSpaceITUR_2020_sRGBGamma";
  v3[55] = CGColorSpaceCreateITUR_2020_sRGBGamma;
  v3[56] = @"kCGColorSpaceLinearITUR_2020";
  v3[57] = CGColorSpaceCreateLinearITUR_2020;
  v3[58] = @"kCGColorSpaceExtendedITUR_2020";
  v3[59] = CGColorSpaceCreateExtendedITUR_2020;
  v3[60] = @"kCGColorSpaceExtendedLinearITUR_2020";
  v3[61] = CGColorSpaceCreateExtendedLinearITUR_2020;
  v3[62] = @"kCGColorSpaceITUR_2100_PQ";
  v3[63] = CGColorSpaceCreateITUR_2100_PQ;
  v3[64] = @"kCGColorSpaceITUR_2100_HLG";
  v3[65] = CGColorSpaceCreateITUR_2100_HLG;
  v3[66] = @"kCGColorSpaceROMMRGB";
  v3[67] = CGColorSpaceCreateROMMRGB;
  v3[68] = @"kCGColorSpaceDCIP3";
  v3[69] = CGColorSpaceCreateDCIP3;
  v3[70] = @"kCGColorSpaceExtendedSRGB";
  v3[71] = CGColorSpaceExtendedSRGB;
  v3[72] = @"kCGColorSpaceLinearSRGB";
  v3[73] = CGColorSpaceLinearSRGB;
  v3[74] = @"kCGColorSpaceExtendedLinearSRGB";
  v3[75] = CGColorSpaceExtendedLinearSRGB;
  v3[76] = @"kCGColorSpaceExtendedGray";
  v3[77] = CGColorSpaceExtendedGray;
  v3[78] = @"kCGColorSpaceLinearGray";
  v3[79] = CGColorSpaceLinearGray;
  v3[80] = @"kCGColorSpaceExtendedLinearGray";
  v3[81] = CGColorSpaceExtendedLinearGray;
  v3[82] = @"kCGColorSpacePerceptualStandardRGB";
  v3[83] = CGColorSpacePerceptualStandardRGB;
  v3[84] = @"kCGColorSpaceCoreMedia709";
  v3[85] = CGColorSpaceCoreMedia709;
  v3[86] = @"kCGColorSpaceColoredPattern";
  v3[87] = CGColorSpaceCreateColoredPattern;
  uint64_t v0 = 0;
  CGColorSpaceCreateWithName_name_creator_pair_CGPDFDictionaryRef dict = (uint64_t)CFDictionaryCreateMutable(0, 44, MEMORY[0x1E4F1D530], 0);
  do
  {
    CFDictionarySetValue((CFMutableDictionaryRef)CGColorSpaceCreateWithName_name_creator_pair_dict, (const void *)v3[v0], (const void *)v3[v0 + 1]);
    v0 += 2;
  }
  while (v0 != 88);
  uint64_t v1 = (char *)malloc_type_malloc(0x2C0uLL, 0xE004020B7322BuLL);
  uint64_t v2 = 0;
  CGColorSpaceCreateWithName_name_creator_pair_arraCGFloat y = (uint64_t)v1;
  CGColorSpaceCreateWithName_name_creator_pair_count = 1;
  do
  {
    *(_OWORD *)&v1[v2 * 8] = *(_OWORD *)&v3[v2];
    v2 += 2;
  }
  while (v2 != 88);

  qsort(v1, 0x2CuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))compare_names);
}

double __RIPStyleShadow_block_invoke()
{
  rips_s_cs = (uint64_t)CGColorSpaceCreateDeviceGray();
  if (rips_s_cs)
  {
    double result = *(double *)&_rips_class;
    *(void *)&RIPStyleShadow_rips_s_cls = rips_s_super;
    *((void *)&RIPStyleShadow_rips_s_cls + 1) = rips_s_size;
    unk_1EB289978 = off_1ED097580[0];
    qword_1EB289980 = (uint64_t)rips_s_release;
    qword_1EB289988 = (uint64_t)rips_s_Create;
    qword_1EB289990 = (uint64_t)rips_s_Growth;
    qword_1EB289998 = (uint64_t)rips_s_ColorSpace;
    qword_1EB2899A0 = (uint64_t)rips_s_BltShape;
    qword_1EB2899A8 = (uint64_t)rips_s_BltGlyph;
    qword_1EB2899B0 = (uint64_t)rips_s_BltImage;
    qword_1EB2899B8 = (uint64_t)rips_s_BltShade;
  }
  return result;
}

void CGContextFlush(CGContextRef c)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      int v8 = (void (*)(CGContextRef))*((void *)c + 7);
      if (v8) {
        v8(c);
      }
      uint64_t v9 = *((void *)c + 5);
      if (v9)
      {
        int v10 = *(void (**)(void))(v9 + 168);
        if (v10)
        {
          v10();
        }
      }
      return;
    }
    CGContextRef v11 = c;
  }
  else
  {
    CGContextRef v11 = 0;
  }

  handle_invalid_context((char)"CGContextFlush", (uint64_t)v11, v1, v2, v3, v4, v5, v6);
}

BOOL CGClipStackIsInfinite(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (*(void *)(a1 + 120)) {
    return 0;
  }
  v2.origin.CGFloat x = -8.98846567e307;
  v2.size.CGFloat width = 1.79769313e308;
  v2.origin.CGFloat y = -8.98846567e307;
  v2.size.CGFloat height = 1.79769313e308;
  return CGRectEqualToRect(*(CGRect *)(a1 + 16), v2);
}

uint64_t CG::DisplayList::getEntryPatternState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ++*(void *)(a1 + 744);
  uint64_t v5 = a1 + 560;
  uint64_t v6 = *(void *)(a1 + 560);
  if (!v6) {
    goto LABEL_13;
  }
  uint64_t v7 = a1 + 560;
  do
  {
    uint64_t v8 = *(void *)(v6 + 32);
    uint64_t v9 = *(std::__shared_weak_count **)(v6 + 40);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v10 = CG::CompareEntryStatePattern::operator()(v8, a2, a3);
      std::__shared_weak_count::__release_shared[abi:fe180100](v9);
    }
    else
    {
      BOOL v10 = CG::CompareEntryStatePattern::operator()(v8, a2, a3);
    }
    CGContextRef v11 = (uint64_t *)(v6 + 8);
    if (!v10)
    {
      uint64_t v7 = v6;
      CGContextRef v11 = (uint64_t *)v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v5 == v7) {
    goto LABEL_13;
  }
  uint64_t v12 = *(void *)(v7 + 32);
  unint64_t v13 = *(std::__shared_weak_count **)(v7 + 40);
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    if (CG::CompareEntryStatePattern::operator()(v12, a2, a3))
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
      goto LABEL_13;
    }
    uint64_t v15 = *(void *)(v7 + 32);
    unint64_t v17 = *(std::__shared_weak_count **)(v7 + 40);
    BOOL v16 = v17 == 0;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    if (CG::CompareEntryStatePattern::operator()(v12, a2, a3)) {
      goto LABEL_13;
    }
    uint64_t v15 = *(void *)(v7 + 32);
    BOOL v16 = 1;
    unint64_t v17 = 0;
  }
  long long v18 = *(_OWORD *)(a3 + 40);
  __s1[0] = *(_OWORD *)(a3 + 24);
  __s1[1] = v18;
  __s1[2] = *(_OWORD *)(a3 + 56);
  v26[0] = *(_OWORD *)(v15 + 8);
  v26[1] = *(_OWORD *)(v15 + 24);
  void v26[2] = *(_OWORD *)(v15 + 40);
  int v19 = memcmp(__s1, v26, 0x30uLL);
  if (v19 < 0)
  {
LABEL_20:
    BOOL v20 = 1;
    if (v16) {
      goto LABEL_25;
    }
LABEL_24:
    std::__shared_weak_count::__release_shared[abi:fe180100](v17);
    goto LABEL_25;
  }
  if (v19) {
    goto LABEL_23;
  }
  uint64_t v21 = *(void *)(a2 + 120);
  double v22 = *(double *)(v21 + 24);
  double v23 = *(double *)(v15 + 56);
  if (v22 < v23) {
    goto LABEL_20;
  }
  if (v22 > v23) {
    goto LABEL_23;
  }
  double v24 = *(double *)(v21 + 32);
  double v25 = *(double *)(v15 + 64);
  if (v24 < v25) {
    goto LABEL_20;
  }
  if (v24 > v25)
  {
LABEL_23:
    BOOL v20 = 0;
    if (v16) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  BOOL v20 = *(double *)(*(void *)(a2 + 144) + 16) < *(double *)(v15 + 72);
  if (!v16) {
    goto LABEL_24;
  }
LABEL_25:
  if (!v13)
  {
    if (!v20) {
      return *(void *)(v7 + 32);
    }
LABEL_13:
    operator new();
  }
  std::__shared_weak_count::__release_shared[abi:fe180100](v13);
  if (v20) {
    goto LABEL_13;
  }
  return *(void *)(v7 + 32);
}

void sub_184CBA160(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

void *std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStatePattern const>>(void *a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  uint64_t v9 = a1 + 1;
  if (a1 + 1 == a2) {
    goto LABEL_7;
  }
  uint64_t v11 = *a5;
  uint64_t v12 = (std::__shared_weak_count *)a5[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = a2[4];
  uint64_t v14 = (std::__shared_weak_count *)a2[5];
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v15 = CG::CompareEntryStatePattern::operator()(v11, v13);
    std::__shared_weak_count::__release_shared[abi:fe180100](v14);
    if (v12) {
      goto LABEL_6;
    }
LABEL_13:
    if (v15) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v18 = a2[4];
    int v19 = (std::__shared_weak_count *)a2[5];
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v20 = *a5;
    uint64_t v21 = (std::__shared_weak_count *)a5[1];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v22 = CG::CompareEntryStatePattern::operator()(v18, v20);
      std::__shared_weak_count::__release_shared[abi:fe180100](v21);
      if (!v19) {
        goto LABEL_19;
      }
    }
    else
    {
      BOOL v22 = CG::CompareEntryStatePattern::operator()(v18, v20);
      if (!v19)
      {
LABEL_19:
        if (!v22)
        {
          *a3 = a2;
          *a4 = a2;
          return a4;
        }
        a4 = a2 + 1;
        double v23 = (void *)a2[1];
        if (v23)
        {
          do
          {
            double v24 = v23;
            double v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          uint64_t v32 = a2;
          do
          {
            double v24 = (void *)v32[2];
            BOOL v26 = *v24 == (void)v32;
            uint64_t v32 = v24;
          }
          while (!v26);
        }
        if (v24 == v9) {
          goto LABEL_48;
        }
        uint64_t v33 = *a5;
        uint64_t v34 = (std::__shared_weak_count *)a5[1];
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v35 = v24[4];
        unsigned int v36 = (std::__shared_weak_count *)v24[5];
        if (v36)
        {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v37 = CG::CompareEntryStatePattern::operator()(v33, v35);
          std::__shared_weak_count::__release_shared[abi:fe180100](v36);
          if (v34) {
            goto LABEL_47;
          }
        }
        else
        {
          BOOL v37 = CG::CompareEntryStatePattern::operator()(v33, v35);
          if (v34)
          {
LABEL_47:
            std::__shared_weak_count::__release_shared[abi:fe180100](v34);
            if (!v37) {
              goto LABEL_52;
            }
LABEL_48:
            if (*a4)
            {
              *a3 = v24;
              return v24;
            }
            else
            {
              *a3 = a2;
            }
            return a4;
          }
        }
        if (!v37) {
          goto LABEL_52;
        }
        goto LABEL_48;
      }
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v19);
    goto LABEL_19;
  }
  BOOL v15 = CG::CompareEntryStatePattern::operator()(v11, v13);
  if (!v12) {
    goto LABEL_13;
  }
LABEL_6:
  std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  if (!v15) {
    goto LABEL_14;
  }
LABEL_7:
  if ((void *)*a1 == a2)
  {
    unint64_t v17 = a2;
    goto LABEL_33;
  }
  BOOL v16 = (void *)*a2;
  if (*a2)
  {
    do
    {
      unint64_t v17 = v16;
      BOOL v16 = (void *)v16[1];
    }
    while (v16);
  }
  else
  {
    double v25 = a2;
    do
    {
      unint64_t v17 = (void *)v25[2];
      BOOL v26 = *v17 == (void)v25;
      double v25 = v17;
    }
    while (v26);
  }
  uint64_t v27 = v17[4];
  unint64_t v28 = (std::__shared_weak_count *)v17[5];
  if (v28) {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v29 = *a5;
  uint64_t v30 = (std::__shared_weak_count *)a5[1];
  if (v30)
  {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v31 = CG::CompareEntryStatePattern::operator()(v27, v29);
    std::__shared_weak_count::__release_shared[abi:fe180100](v30);
    if (v28) {
      goto LABEL_29;
    }
  }
  else
  {
    BOOL v31 = CG::CompareEntryStatePattern::operator()(v27, v29);
    if (v28)
    {
LABEL_29:
      std::__shared_weak_count::__release_shared[abi:fe180100](v28);
      if (!v31) {
        goto LABEL_52;
      }
      goto LABEL_33;
    }
  }
  if (v31)
  {
LABEL_33:
    if (*a2)
    {
      *a3 = v17;
      return v17 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
LABEL_52:

  return std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStatePattern const>>((uint64_t)a1, a3, a5);
}

uint64_t *__color_space_state_create_itur_2020_block_invoke_2()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  double result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (double result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncITUR2020Profile")) != 0)
  {
    uint64_t v1 = *result;
  }
  else
  {
    uint64_t v1 = 0;
  }
  color_space_state_create_itur_2020_s = v1;
  return result;
}

void CGContextSetRGBFillColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  v20[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      v20[0] = red;
      v20[1] = green;
      void v20[2] = blue;
      v20[3] = alpha;
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
      set_fill_color_with_components((uint64_t *)c, DeviceRGB, v20, v13, v14, v15, v16, v17, v19);
      CGColorSpaceRelease(DeviceRGB);
      return;
    }
    CGContextRef v18 = c;
  }
  else
  {
    CGContextRef v18 = 0;
  }

  handle_invalid_context((char)"CGContextSetRGBFillColor", (uint64_t)v18, v5, v6, v7, v8, v9, v10);
}

const void *__pdf_page_draw_in_context_block_invoke()
{
  return get_BOOLean_property("CGPDFHighlightContent", copy_preference_value, (BOOL *)&pdf_page_draw_in_context_highlight_content);
}

uint64_t (*__color_space_state_create_itur_2020_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  double result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    double result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_1748;
  }
  color_space_state_create_itur_2020_f = v1;
  return result;
}

CGColorSpaceRef __CGColorSpaceFindMatchingSingleton_block_invoke_2()
{
  for (uint64_t i = 0; i != 14; ++i)
  {
    CGColorSpaceRef result = CGColorSpaceCreateWithName(CGColorSpaceFindMatchingSingleton_names[i]);
    CGColorSpaceFindMatchingSingleton_spaces_171[i] = (uint64_t)result;
  }
  return result;
}

uint64_t RGBAf16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  memset(v37, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  signed int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v31, (uint64_t)v37) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v25 = *(_DWORD *)v6;
  unsigned int v26 = *(_DWORD *)a3;
  int v32 = v26;
  int v33 = v25;
  if (v26 != 269497257)
  {
    unsigned int v27 = SAMPLEINDEX(v26, v10, v11, v12, v13, v14, v15, v16);
    if (v27)
    {
      if (v27 <= 0x1B) {
        _CGHandleAssert("RGBAf16_image_inner", 13913, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "index > SAMPLEF", "indeCGFloat x = %u", v28, v29, v30, v27);
      }
      BOOL v31 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, int))RGBF16_image_sample[v27 + 1];
      if (v31)
      {
        int v32 = 269497257;
        goto LABEL_20;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        BOOL v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&RGB8_image_sample[2 * v27 + 2];
        if (v31)
        {
          int v34 = 4;
          int v32 = 134755224;
          goto LABEL_20;
        }
      }
      BOOL v31 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&RGB16_image_sample[2 * v27 + 2];
      if (v31)
      {
        int v32 = 269497256;
        goto LABEL_20;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v36 && (~v35 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    v18.n128_u32[0] = 1.0;
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v35 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      RGBAf16_mark_inner(a1, (uint64_t)a2, v17, v18, v19, v20, v21, v22, v23, v24, v11, v12, v13, v14, v15, v16);
      return 1;
    }
  }
  BOOL v31 = RGBAf16_sample_RGBAf_inner;
LABEL_20:
  RGBAf16_image_mark((uint64_t)a2, (uint64_t)&v31, v8, v17);
  return 1;
}

uint64_t RGBAf16_mark_inner(uint64_t *a1, uint64_t a2, __n128 a3, __n128 _Q1, __n128 a5, double _D3, float32x4_t a7, float32x4_t _Q5, float32x4_t _Q6, float32x4_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v715 = *MEMORY[0x1E4F143B8];
  int v20 = *(_DWORD *)a2;
  uint64_t v21 = *(void *)(a2 + 96);
  uint64_t v22 = *(void *)(a2 + 48);
  uint64_t v23 = *(unsigned int *)(*(void *)(*a1 + 56)
                        + 16 * *(_DWORD *)a2
                        + 8 * (v21 == 0)
                        + 4 * (v22 == 0));
  if ((int)v23 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v25 = a2;
  unint64_t v26 = *(unsigned int *)(a2 + 4);
  unsigned int v27 = v26 - 1;
  if ((int)v26 < 1) {
    return 0;
  }
  int v28 = *(_DWORD *)(a2 + 8);
  if (v28 < 1) {
    return 0;
  }
  uint64_t v29 = *(int **)(a2 + 136);
  if ((v20 & 0xFF0000) != 0x50000 && v29)
  {
    int v30 = *(_DWORD *)(a2 + 128);
    if ((v30 | 8) == 8)
    {
      if ((*(_DWORD *)a2 & 0xFF00) == 0x400) {
        RGBAf16_mark_constmask(a2, v23, (uint64_t)v29, a12, a3.n128_f64[0], _Q1, a5, _D3, *(double *)a7.i64, *(double *)_Q5.i64, *(double *)_Q6.i64, *(float16x4_t *)a10.f32, a13, a14, a15, a16);
      }
      else {
        RGBAf16_mark_pixelmask((_DWORD *)*a1, (int *)a2, v23, a3, _Q1, a5, _D3, *(double *)a7.i64, _Q5, _Q6, *(double *)a10.i64);
      }
    }
    else
    {
      int v52 = *(_DWORD *)a2 & 0xFF00;
      if ((v23 - 1) <= 1 && v52 == 1024 && v30 == 16)
      {
        if (v22)
        {
          uint64_t v53 = *(void *)(a2 + 152);
          if (v53 && *(double *)(a2 + 144) == 2.0)
          {
            long long v713 = 0u;
            memset(v714, 0, sizeof(v714));
            long long v711 = 0u;
            long long v712 = 0u;
            RGBAf16_pattern((uint64_t)a1, &v711, 8u, *(_DWORD *)v53, *(float **)(v53 + 8), *(float *)(v53 + 16));
            RGBAf16_mark_const_deep_mask_BGColorARGB(v25, v23, (float16x4_t *)v714, v65, v66, v67, v68, v69);
          }
          else
          {
            RGBAf16_mark_const_deep_mask_ARGB(a2, v23, (uint64_t)v29, a12, a13, a14, a15, a16);
          }
        }
        else
        {
          RGBAf16_mark_const_deep_mask_XRGB(a2, v23, (uint64_t)v29, a12, a13, a14, a15, a16);
        }
      }
      else if ((v23 - 1) > 1 || v52 == 1024 || v30 != 16)
      {
        RGBAf16_mark_bits(*a1, a3);
      }
      else
      {
        RGBAf16_mark_deep_pixel(a2, v23, a3.n128_f64[0], _Q1.n128_f64[0], a5.n128_f64[0], _D3, *(double *)a7.i64, *(double *)_Q5.i64, *(double *)_Q6.i64, a10, (uint64_t)v29, a12, a13, a14, a15, a16);
      }
    }
    return 1;
  }
  int v667 = *(_DWORD *)(*(void *)(*a1 + 56) + 16 * *(_DWORD *)a2 + 8 * (v21 == 0) + 4 * (v22 == 0));
  if ((*(_DWORD *)a2 & 0xFF00) != 0x400)
  {
    __int32 v703 = *(_DWORD *)(a2 + 4);
    unsigned int v707 = v28;
    uint64_t v43 = *(void *)(a2 + 88);
    unint64_t v44 = (unint64_t)*(int *)(a2 + 28) >> 3;
    unint64_t v45 = *(void *)(a2 + 40) + 8 * (*(int *)(a2 + 12) + v44 * *(int *)(a2 + 16));
    uint64_t v46 = *(unsigned int *)(a2 + 104);
    uint64_t v47 = *(unsigned int *)(a2 + 108);
    int v48 = *(_DWORD *)(a2 + 56);
    int v49 = *(_DWORD *)(a2 + 60);
    unint64_t v50 = (unint64_t)*(int *)(a2 + 76) >> 3;
    if ((v20 & 0xFF00) != 0x100)
    {
      LODWORD(v672) = *(_DWORD *)(a2 + 64);
      uint64_t v668 = *(int *)(a2 + 68);
      unint64_t v695 = v43 + 8 * v50 * v668;
      BOOL v54 = v21 != 0;
      if (v29)
      {
        unint64_t v697 = (unint64_t)*(int *)(a2 + 76) >> 3;
        int v662 = *(_DWORD *)(a2 + 60);
        int v663 = *(_DWORD *)(a2 + 56);
        LODWORD(a12) = 1;
        unint64_t v55 = *(void *)(a2 + 88);
        unint64_t v56 = v55;
        goto LABEL_45;
      }
      if (v43)
      {
        uint64_t v669 = 0;
        uint64_t v670 = *(void *)(a2 + 88);
        int v59 = v48 % (int)v672;
        unint64_t v697 = (unint64_t)*(int *)(a2 + 76) >> 3;
        unint64_t v60 = v43 + 8 * v50 * (v49 % (int)v668);
        unint64_t v55 = v60 + 8 * v59;
        unint64_t v56 = v60 + 8 * (int)v672;
        int v666 = 1;
        uint64_t v43 = v55;
        unint64_t v61 = *(void *)(a2 + 40) + 8 * (*(int *)(a2 + 12) + v44 * *(int *)(a2 + 16));
        unint64_t v62 = v26;
        int v662 = v49 % (int)v668;
        int v663 = v59;
        goto LABEL_51;
      }
      int v662 = *(_DWORD *)(a2 + 60);
      int v663 = *(_DWORD *)(a2 + 56);
      unint64_t v56 = 0;
      int v666 = 1;
      unint64_t v62 = v26;
      goto LABEL_49;
    }
    v43 += 8 * (v48 + v50 * v49);
    if (v50 == v44)
    {
      if ((uint64_t)(v45 - v43) >= 1)
      {
        if (v26 >= (v45 - v43) >> 3)
        {
          v45 += 8 * v27;
          a12 = 0xFFFFFFFFLL;
          unint64_t v672 = (unint64_t)*(int *)(a2 + 28) >> 3;
          v43 += 8 * v27;
          goto LABEL_43;
        }
        unint64_t v51 = v44 * (v28 - 1);
        if (v45 <= v43 + 8 * v51 + 8 * v27)
        {
          v45 += 8 * v51;
          unint64_t v44 = -(uint64_t)v44;
          v43 += 8 * v51;
        }
      }
      a12 = 1;
      unint64_t v672 = v44;
    }
    else
    {
      a12 = 1;
      unint64_t v672 = (unint64_t)*(int *)(a2 + 76) >> 3;
    }
LABEL_43:
    int v662 = *(_DWORD *)(a2 + 60);
    int v663 = *(_DWORD *)(a2 + 56);
    BOOL v54 = v21 != 0;
    if (v29)
    {
      LODWORD(v668) = 0;
      unint64_t v55 = 0;
      unint64_t v695 = 0;
      unint64_t v56 = -1;
      unint64_t v697 = v672;
LABEL_45:
      int v666 = a12;
      shape_enum_clip_alloc((uint64_t)a1, a2, v29, a12, v44, 1, v46, v47, v26, v28);
      uint64_t v64 = v63;
      if (!v63) {
        return 1;
      }
      goto LABEL_614;
    }
    LODWORD(v668) = 0;
    int v666 = a12;
    unint64_t v62 = (int)a12 * (int)v26;
    unint64_t v56 = -1;
    unint64_t v50 = v672;
LABEL_49:
    unint64_t v695 = 0;
    uint64_t v669 = 0;
    uint64_t v670 = v43;
    unint64_t v55 = 0;
    unint64_t v697 = v50 - v62;
    unint64_t v61 = v45;
LABEL_51:
    unint64_t v693 = v44 - v62;
    switch(v667)
    {
      case 0:
        unint64_t v70 = v61 - 8 * ((int)v26 - 1);
        uint64_t v71 = v693 + (int)v26;
        if (v666 < 0) {
          uint64_t v71 = v693 - (int)v26;
        }
        else {
          unint64_t v70 = v61;
        }
        unsigned int v72 = (char *)(v70 + 8 * ((v71 * ((int)v707 - 1)) & (v71 >> 63)));
        if (v71 < 0) {
          uint64_t v71 = -v71;
        }
        CGBlt_fillBytes(8 * v26, v707, 0, v72, 8 * v71);
        goto LABEL_611;
      case 1:
        int v73 = *(unsigned __int8 *)(v25 + 1);
        unint64_t v665 = v44;
        if (v73 == 2)
        {
          if ((int)v26 >= 4 && (8 * v672) <= 0x40)
          {
            a3.n128_u32[0] = 8 * v672;
            uint8x8_t v444 = (uint8x8_t)vcnt_s8((int8x8_t)a3.n128_u64[0]);
            v444.i16[0] = vaddlv_u8(v444);
            if (v444.i32[0] <= 1u)
            {
              uint64_t v43 = v670;
              CGSFillDRAM64(v61, 8 * (v26 + v693), 8 * v26, v707, v670, 8 * v697, 8 * v672, v668, 8 * v663, v662);
              goto LABEL_612;
            }
          }
        }
        else if (v73 == 1)
        {
          int v74 = v707;
          uint64_t v75 = (int)v707;
          if (use_vImage_fp16_compositing(void)::predicate != -1)
          {
            unsigned int v689 = v707;
            dispatch_once(&use_vImage_fp16_compositing(void)::predicate, &__block_literal_global_21437);
            int v74 = v689;
          }
          if ((v666 & 0x80000000) == 0 && use_vImage_fp16_compositing(void)::status)
          {
LABEL_627:
            LODWORD(v699) = 66051;
            *(void *)&long long v711 = v61;
            *((void *)&v711 + 1) = v75;
            *(void *)&long long v712 = (int)v26;
            *((void *)&v712 + 1) = 8 * (v693 + (int)v26);
            int v708 = (_DWORD *)v43;
            v709.i64[0] = v75;
            v709.i64[1] = (int)v26;
            uint64_t v710 = 8 * (v697 + (int)v26);
            vImageCGCompositePixelShape_ARGB16F();
            goto LABEL_610;
          }
          if (!v22 || v54)
          {
            if (v666 < 0)
            {
              uint64_t v477 = v697 - (int)v26;
              v43 -= 8 * ((int)v26 - 1);
              uint64_t v478 = v693 - (int)v26;
              v61 -= 8 * ((int)v26 - 1);
            }
            else
            {
              uint64_t v477 = v697 + (int)v26;
              uint64_t v478 = v693 + (int)v26;
            }
            if (v477 >= 0) {
              LODWORD(v479) = v477;
            }
            else {
              uint64_t v479 = -v477;
            }
            uint64_t v480 = (char *)(v43 + 8 * ((v477 * (v75 - 1)) & (v477 >> 63)));
            uint64_t v481 = (v478 * (v75 - 1)) & (v478 >> 63);
            if (v478 < 0) {
              uint64_t v478 = -v478;
            }
            CGBlt_copyBytes(8 * v26, v74, v480, (char *)(v61 + 8 * v481), 8 * v479, 8 * v478);
            goto LABEL_610;
          }
          int v457 = v26 + 1;
          unint64_t v458 = v56;
          unint64_t v459 = v55;
          unint64_t v44 = v665;
          uint64_t v64 = v669;
          do
          {
            int v460 = v457;
            do
            {
              *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
              *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
              *(_WORD *)(v61 + 6) = COERCE_UNSIGNED_INT(1.0);
              unint64_t v461 = v43 + 8 * v666;
              if (v461 >= v458) {
                uint64_t v462 = -(uint64_t)(int)v672;
              }
              else {
                uint64_t v462 = 0;
              }
              uint64_t v43 = v461 + 8 * v462;
              v61 += 8 * v666;
              --v460;
            }
            while (v460 > 1);
            v61 += 8 * v693;
            unint64_t v463 = v459 + 8 * v697;
            if (v463 >= v695) {
              uint64_t v464 = -(uint64_t)(v697 * (int)v668);
            }
            else {
              uint64_t v464 = 0;
            }
            uint64_t v465 = v463 + 8 * v464;
            uint64_t v466 = v458 + 8 * v464 + 8 * v697;
            if (v695)
            {
              unint64_t v458 = v466;
              unint64_t v459 = v465;
              uint64_t v43 = v465;
            }
            else
            {
              v43 += 8 * v697;
            }
            _VF = __OFSUB__(v74--, 1);
          }
          while (!((v74 < 0) ^ _VF | (v74 == 0)));
LABEL_676:
          uint64_t v43 = v670;
          if (!v64) {
            return 1;
          }
          goto LABEL_613;
        }
        int v445 = v707;
        uint64_t v75 = (int)v707;
        if (use_vImage_fp16_compositing(void)::predicate != -1)
        {
          unsigned int v688 = v707;
          dispatch_once(&use_vImage_fp16_compositing(void)::predicate, &__block_literal_global_21437);
          int v445 = v688;
        }
        if (use_vImage_fp16_compositing(void)::status) {
          goto LABEL_627;
        }
        uint64_t v446 = 8 * v666;
        if (v22 && !v54)
        {
          int v447 = v26 + 1;
          unint64_t v448 = v56;
          unint64_t v449 = v55;
          unint64_t v44 = v665;
          uint64_t v64 = v669;
          do
          {
            int v450 = v447;
            do
            {
              *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
              *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
              *(_WORD *)(v61 + 6) = COERCE_UNSIGNED_INT(1.0);
              unint64_t v451 = v43 + 8 * v666;
              if (v451 >= v448) {
                uint64_t v452 = -(uint64_t)(int)v672;
              }
              else {
                uint64_t v452 = 0;
              }
              uint64_t v43 = v451 + 8 * v452;
              v61 += v446;
              --v450;
            }
            while (v450 > 1);
            v61 += 8 * v693;
            unint64_t v453 = v449 + 8 * v697;
            if (v453 >= v695) {
              uint64_t v454 = -(uint64_t)(v697 * (int)v668);
            }
            else {
              uint64_t v454 = 0;
            }
            uint64_t v455 = v453 + 8 * v454;
            uint64_t v456 = v448 + 8 * v454 + 8 * v697;
            if (v695)
            {
              unint64_t v448 = v456;
              unint64_t v449 = v455;
              uint64_t v43 = v455;
            }
            else
            {
              v43 += 8 * v697;
            }
            _VF = __OFSUB__(v445--, 1);
          }
          while (!((v445 < 0) ^ _VF | (v445 == 0)));
        }
        else
        {
          int v467 = v26 + 1;
          unint64_t v468 = v56;
          unint64_t v469 = v55;
          unint64_t v44 = v665;
          uint64_t v64 = v669;
          do
          {
            int v470 = v467;
            do
            {
              *(void *)unint64_t v61 = *(void *)v43;
              unint64_t v471 = v43 + 8 * v666;
              if (v471 >= v468) {
                uint64_t v472 = -(uint64_t)v697;
              }
              else {
                uint64_t v472 = 0;
              }
              uint64_t v43 = v471 + 8 * v472;
              v61 += v446;
              --v470;
            }
            while (v470 > 1);
            v61 += 8 * v693;
            unint64_t v473 = v469 + 8 * v697;
            if (v473 >= v695) {
              uint64_t v474 = -(uint64_t)(v697 * (int)v668);
            }
            else {
              uint64_t v474 = 0;
            }
            uint64_t v475 = v473 + 8 * v474;
            uint64_t v476 = v468 + 8 * v474 + 8 * v697;
            if (v695)
            {
              unint64_t v468 = v476;
              unint64_t v469 = v475;
              uint64_t v43 = v475;
            }
            else
            {
              v43 += 8 * v697;
            }
            _VF = __OFSUB__(v445--, 1);
          }
          while (!((v445 < 0) ^ _VF | (v445 == 0)));
        }
        goto LABEL_676;
      case 2:
        unsigned int v76 = v707;
        do
        {
          int v77 = v26;
          do
          {
            short float v78 = *(short float *)(v43 + 6);
            if (v78 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
            {
              *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
              *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
              *(short float *)(v61 + 6) = v78;
            }
            else
            {
              __asm { FCMP            H2, #0 }
              if (!(_NF ^ _VF | _ZF))
              {
                __asm { FCVT            S2, H2 }
                a7.i32[0] = *(_DWORD *)v43;
                v81.i64[0] = vcvtq_f32_f16(*(float16x4_t *)a7.f32).u64[0];
                _H5 = *(_WORD *)(v43 + 4);
                __asm { FCVT            S5, H5 }
                v81.i64[1] = __PAIR64__(LODWORD(_S2), _S5);
                a7 = vmlaq_n_f32(v81, vcvtq_f32_f16(*(float16x4_t *)v61), 1.0 - _S2);
                *(float16x4_t *)unint64_t v61 = vcvt_f16_f32(a7);
              }
            }
            unint64_t v84 = v43 + 8 * v666;
            if (v84 >= v56) {
              uint64_t v85 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v85 = 0;
            }
            uint64_t v43 = v84 + 8 * v85;
            v61 += 8 * v666;
            --v77;
          }
          while (v77);
          v61 += 8 * v693;
          unint64_t v86 = v55 + 8 * v697;
          if (v86 >= v695) {
            uint64_t v87 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v87 = 0;
          }
          unint64_t v88 = v86 + 8 * v87;
          uint64_t v89 = v56 + 8 * v87 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v89;
            unint64_t v55 = v88;
            uint64_t v43 = v88;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v76;
        }
        while (v76);
        goto LABEL_323;
      case 3:
        unsigned int v90 = v707;
        do
        {
          int v91 = v26;
          do
          {
            __asm { FCMP            H1, #0 }
            if (!_ZF & _CF)
            {
              short float v93 = *(short float *)v43;
              if (_H1 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                *(short float *)unint64_t v61 = v93;
                *(_DWORD *)(v61 + 2) = *(_DWORD *)(v43 + 2);
                _H1 = COERCE_UNSIGNED_INT(1.0);
                if (v54) {
                  _H1 = *(_WORD *)(v43 + 6);
                }
              }
              else
              {
                *(short float *)unint64_t v61 = _H1 * v93;
                *(short float *)(v61 + 2) = _H1 * *(short float *)(v43 + 2);
                *(short float *)(v61 + 4) = _H1 * *(short float *)(v43 + 4);
                _S2 = 1.0;
                if (v54)
                {
                  _H2 = *(_WORD *)(v43 + 6);
                  __asm { FCVT            S2, H2 }
                }
                __asm { FCVT            S1, H1 }
                _S1 = _S2 * _S1;
                __asm { FCVT            H1, S1 }
              }
              *(_WORD *)(v61 + 6) = _H1;
            }
            else
            {
              *(void *)unint64_t v61 = 0;
            }
            unint64_t v99 = v43 + 8 * v666;
            if (v99 >= v56) {
              uint64_t v100 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v100 = 0;
            }
            uint64_t v43 = v99 + 8 * v100;
            v61 += 8 * v666;
            --v91;
          }
          while (v91);
          v61 += 8 * v693;
          unint64_t v101 = v55 + 8 * v697;
          if (v101 >= v695) {
            uint64_t v102 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v102 = 0;
          }
          unint64_t v103 = v101 + 8 * v102;
          uint64_t v104 = v56 + 8 * v102 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v104;
            unint64_t v55 = v103;
            uint64_t v43 = v103;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v90;
        }
        while (v90);
        goto LABEL_323;
      case 4:
        unsigned int v105 = v707;
        do
        {
          int v106 = v26;
          do
          {
            _H1 = *(_WORD *)(v61 + 6);
            __asm { FCVT            S1, H1 }
            float v109 = 1.0 - _S1;
            if (v109 <= 0.0)
            {
              *(void *)unint64_t v61 = 0;
            }
            else
            {
              _H2 = *(short float *)v43;
              if (v109 >= 1.0)
              {
                *(short float *)unint64_t v61 = _H2;
                *(_DWORD *)(v61 + 2) = *(_DWORD *)(v43 + 2);
                _H1 = COERCE_UNSIGNED_INT(1.0);
                if (v54) {
                  _H1 = *(_WORD *)(v43 + 6);
                }
              }
              else
              {
                __asm { FCVT            S2, H2 }
                _S2 = v109 * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)unint64_t v61 = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v43 + 2);
                __asm { FCVT            S2, H2 }
                _S2 = v109 * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v61 + 2) = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v43 + 4);
                __asm { FCVT            S2, H2 }
                _S2 = v109 * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v61 + 4) = LOWORD(_S2);
                _S2 = 1.0;
                if (v54)
                {
                  _H2 = *(_WORD *)(v43 + 6);
                  __asm { FCVT            S2, H2 }
                }
                _S1 = v109 * _S2;
                __asm { FCVT            H1, S1 }
              }
              *(_WORD *)(v61 + 6) = _H1;
            }
            unint64_t v121 = v43 + 8 * v666;
            if (v121 >= v56) {
              uint64_t v122 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v122 = 0;
            }
            uint64_t v43 = v121 + 8 * v122;
            v61 += 8 * v666;
            --v106;
          }
          while (v106);
          v61 += 8 * v693;
          unint64_t v123 = v55 + 8 * v697;
          if (v123 >= v695) {
            uint64_t v124 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v124 = 0;
          }
          unint64_t v125 = v123 + 8 * v124;
          uint64_t v126 = v56 + 8 * v124 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v126;
            unint64_t v55 = v125;
            uint64_t v43 = v125;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v105;
        }
        while (v105);
        goto LABEL_323;
      case 5:
        unsigned int v127 = v707;
        do
        {
          int v128 = v26;
          do
          {
            float32x4_t v129 = vcvtq_f32_f16(*(float16x4_t *)v43);
            float32x4_t v130 = vcvtq_f32_f16(*(float16x4_t *)v61);
            *(float16x4_t *)unint64_t v61 = vcvt_f16_f32(vmlaq_laneq_f32(vmulq_n_f32(v130, 1.0 - v129.f32[3]), v129, v130, 3));
            unint64_t v131 = v43 + 8 * v666;
            if (v131 >= v56) {
              uint64_t v132 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v132 = 0;
            }
            uint64_t v43 = v131 + 8 * v132;
            v61 += 8 * v666;
            --v128;
          }
          while (v128);
          v61 += 8 * v693;
          unint64_t v133 = v55 + 8 * v697;
          if (v133 >= v695) {
            uint64_t v134 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v134 = 0;
          }
          unint64_t v135 = v133 + 8 * v134;
          uint64_t v136 = v56 + 8 * v134 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v136;
            unint64_t v55 = v135;
            uint64_t v43 = v135;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v127;
        }
        while (v127);
        goto LABEL_323;
      case 6:
        unsigned int v137 = v707;
        while (1)
        {
          int v138 = v26;
          do
          {
            _H1 = *(_WORD *)(v61 + 6);
            __asm { FCVT            S1, H1 }
            float v141 = 1.0 - _S1;
            if ((float)(1.0 - _S1) >= 1.0)
            {
              *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
              *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
              _H1 = COERCE_UNSIGNED_INT(1.0);
              if (v54) {
                _H1 = *(_WORD *)(v43 + 6);
              }
            }
            else
            {
              if (v141 <= 0.0) {
                goto LABEL_153;
              }
              _H3 = *(_WORD *)v61;
              __asm { FCVT            S3, H3 }
              _H4 = *(short float *)v43;
              __asm { FCVT            S4, H4 }
              _S3 = _S3 + (float)(_S4 * v141);
              __asm { FCVT            H3, S3 }
              *(_WORD *)unint64_t v61 = LOWORD(_S3);
              LOWORD(_S3) = *(_WORD *)(v61 + 2);
              __asm { FCVT            S3, H3 }
              LOWORD(_S4) = *(_WORD *)(v43 + 2);
              __asm { FCVT            S4, H4 }
              _S3 = _S3 + (float)(_S4 * v141);
              __asm { FCVT            H3, S3 }
              *(_WORD *)(v61 + 2) = LOWORD(_S3);
              LOWORD(_S3) = *(_WORD *)(v61 + 4);
              __asm { FCVT            S3, H3 }
              LOWORD(_S4) = *(_WORD *)(v43 + 4);
              __asm { FCVT            S4, H4 }
              _S3 = _S3 + (float)(_S4 * v141);
              __asm { FCVT            H3, S3 }
              *(_WORD *)(v61 + 4) = LOWORD(_S3);
              _S3 = 1.0;
              if (v54)
              {
                _H3 = *(_WORD *)(v43 + 6);
                __asm { FCVT            S3, H3 }
              }
              _S1 = _S1 + (float)(_S3 * v141);
              __asm { FCVT            H1, S1 }
            }
            *(_WORD *)(v61 + 6) = _H1;
LABEL_153:
            unint64_t v157 = v43 + 8 * v666;
            if (v157 >= v56) {
              uint64_t v158 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v158 = 0;
            }
            uint64_t v43 = v157 + 8 * v158;
            v61 += 8 * v666;
            --v138;
          }
          while (v138);
          v61 += 8 * v693;
          unint64_t v159 = v55 + 8 * v697;
          if (v159 >= v695) {
            uint64_t v160 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v160 = 0;
          }
          unint64_t v161 = v159 + 8 * v160;
          uint64_t v162 = v56 + 8 * v160 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v162;
            unint64_t v55 = v161;
            uint64_t v43 = v161;
          }
          else
          {
            v43 += 8 * v697;
          }
          if (!--v137) {
            goto LABEL_323;
          }
        }
      case 7:
        unsigned int v163 = v707;
        do
        {
          int v164 = v26;
          do
          {
            __asm { FCMP            H1, #0 }
            if (!_ZF & _CF)
            {
              if (_H1 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                *(float16x4_t *)unint64_t v61 = vmul_n_f16(*(float16x4_t *)v61, _H1);
              }
            }
            else
            {
              *(void *)unint64_t v61 = 0;
            }
            unint64_t v166 = v43 + 8 * v666;
            if (v166 >= v56) {
              uint64_t v167 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v167 = 0;
            }
            uint64_t v43 = v166 + 8 * v167;
            v61 += 8 * v666;
            --v164;
          }
          while (v164);
          v61 += 8 * v693;
          unint64_t v168 = v55 + 8 * v697;
          if (v168 >= v695) {
            uint64_t v169 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v169 = 0;
          }
          unint64_t v170 = v168 + 8 * v169;
          uint64_t v171 = v56 + 8 * v169 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v171;
            unint64_t v55 = v170;
            uint64_t v43 = v170;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v163;
        }
        while (v163);
        goto LABEL_323;
      case 8:
        unsigned int v172 = v707;
        do
        {
          int v173 = v26;
          do
          {
            _H1 = *(_WORD *)(v43 + 6);
            __asm { FCVT            S1, H1 }
            float v176 = 1.0 - _S1;
            if (v176 <= 0.0)
            {
              *(void *)unint64_t v61 = 0;
            }
            else if (v176 < 1.0)
            {
              *(float16x4_t *)unint64_t v61 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v61), v176));
            }
            unint64_t v177 = v43 + 8 * v666;
            if (v177 >= v56) {
              uint64_t v178 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v178 = 0;
            }
            uint64_t v43 = v177 + 8 * v178;
            v61 += 8 * v666;
            --v173;
          }
          while (v173);
          v61 += 8 * v693;
          unint64_t v179 = v55 + 8 * v697;
          if (v179 >= v695) {
            uint64_t v180 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v180 = 0;
          }
          unint64_t v181 = v179 + 8 * v180;
          uint64_t v182 = v56 + 8 * v180 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v182;
            unint64_t v55 = v181;
            uint64_t v43 = v181;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v172;
        }
        while (v172);
        goto LABEL_323;
      case 9:
        unsigned int v183 = v707;
        do
        {
          int v184 = v26;
          do
          {
            float32x4_t v185 = vcvtq_f32_f16(*(float16x4_t *)v61);
            float32x4_t v186 = vcvtq_f32_f16(*(float16x4_t *)v43);
            *(float16x4_t *)unint64_t v61 = vcvt_f16_f32(vmlaq_n_f32(vmulq_laneq_f32(v185, v186, 3), v186, 1.0 - v185.f32[3]));
            unint64_t v187 = v43 + 8 * v666;
            if (v187 >= v56) {
              uint64_t v188 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v188 = 0;
            }
            uint64_t v43 = v187 + 8 * v188;
            v61 += 8 * v666;
            --v184;
          }
          while (v184);
          v61 += 8 * v693;
          unint64_t v189 = v55 + 8 * v697;
          if (v189 >= v695) {
            uint64_t v190 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v190 = 0;
          }
          unint64_t v191 = v189 + 8 * v190;
          uint64_t v192 = v56 + 8 * v190 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v192;
            unint64_t v55 = v191;
            uint64_t v43 = v191;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v183;
        }
        while (v183);
        goto LABEL_323;
      case 10:
        unsigned int v193 = v707;
        do
        {
          int v194 = v26;
          do
          {
            float32x4_t v195 = vcvtq_f32_f16(*(float16x4_t *)v61);
            float32x4_t v196 = vcvtq_f32_f16(*(float16x4_t *)v43);
            *(float16x4_t *)unint64_t v61 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v195, 1.0 - v196.f32[3]), v196, 1.0 - v195.f32[3]));
            unint64_t v197 = v43 + 8 * v666;
            if (v197 >= v56) {
              uint64_t v198 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v198 = 0;
            }
            uint64_t v43 = v197 + 8 * v198;
            v61 += 8 * v666;
            --v194;
          }
          while (v194);
          v61 += 8 * v693;
          unint64_t v199 = v55 + 8 * v697;
          if (v199 >= v695) {
            uint64_t v200 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v200 = 0;
          }
          unint64_t v201 = v199 + 8 * v200;
          uint64_t v202 = v56 + 8 * v200 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v202;
            unint64_t v55 = v201;
            uint64_t v43 = v201;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v193;
        }
        while (v193);
        goto LABEL_323;
      case 11:
        unsigned int v203 = v707;
        do
        {
          int v204 = v26;
          do
          {
            _S0 = 1.0;
            _S1 = 1.0;
            if (v22)
            {
              _H1 = *(_WORD *)(v61 + 6);
              __asm { FCVT            S1, H1 }
            }
            if (v54)
            {
              _H0 = *(_WORD *)(v43 + 6);
              __asm { FCVT            S0, H0 }
            }
            _S3 = 1.0;
            _S4 = 1.0;
            if (v22)
            {
              _H2 = *(_WORD *)(v61 + 6);
              __asm { FCVT            S4, H2 }
            }
            if (v54)
            {
              _H2 = *(_WORD *)(v43 + 6);
              __asm { FCVT            S3, H2 }
            }
            _S0 = _S1 + _S0;
            _S1 = 1.0;
            if (_S0 > 1.0) {
              _S0 = 1.0;
            }
            _S2 = 1.0;
            if (v22)
            {
              _H2 = *(_WORD *)(v61 + 6);
              __asm { FCVT            S2, H2 }
            }
            if (v54)
            {
              _H1 = *(_WORD *)(v43 + 6);
              __asm { FCVT            S1, H1 }
            }
            _H5 = *(_WORD *)v61;
            __asm { FCVT            S5, H5 }
            float v220 = _S4 - _S5;
            LOWORD(_S5) = *(_WORD *)v43;
            __asm { FCVT            S5, H5 }
            float v222 = v220 + (float)(_S3 - _S5);
            _H5 = *(_WORD *)(v61 + 2);
            _H4 = *(_WORD *)(v43 + 2);
            _S3 = _S0 - v222;
            __asm { FCVT            H3, S3 }
            *(_WORD *)unint64_t v61 = LOWORD(_S3);
            _S3 = 1.0;
            _S6 = 1.0;
            if (v22)
            {
              _H6 = *(_WORD *)(v61 + 6);
              __asm { FCVT            S6, H6 }
            }
            if (v54)
            {
              _H3 = *(_WORD *)(v43 + 6);
              __asm { FCVT            S3, H3 }
            }
            __asm
            {
              FCVT            S5, H5
              FCVT            S4, H4
            }
            float v232 = (float)(_S2 - _S5) + (float)(_S1 - _S4);
            _H2 = *(_WORD *)(v61 + 4);
            __asm { FCVT            S2, H2 }
            LOWORD(_S4) = *(_WORD *)(v43 + 4);
            __asm { FCVT            S4, H4 }
            _S1 = _S0 - v232;
            __asm { FCVT            H1, S1 }
            *(_WORD *)(v61 + 2) = LOWORD(_S1);
            __asm { FCVT            H1, S0 }
            *(_WORD *)(v61 + 6) = LOWORD(_S1);
            _S0 = _S0 - (float)((float)(_S6 - _S2) + (float)(_S3 - _S4));
            __asm { FCVT            H0, S0 }
            *(_WORD *)(v61 + 4) = LOWORD(_S0);
            unint64_t v238 = v43 + 8 * v666;
            if (v238 >= v56) {
              uint64_t v239 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v239 = 0;
            }
            uint64_t v43 = v238 + 8 * v239;
            v61 += 8 * v666;
            --v204;
          }
          while (v204);
          v61 += 8 * v693;
          unint64_t v240 = v55 + 8 * v697;
          if (v240 >= v695) {
            uint64_t v241 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v241 = 0;
          }
          unint64_t v242 = v240 + 8 * v241;
          uint64_t v243 = v56 + 8 * v241 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v243;
            unint64_t v55 = v242;
            uint64_t v43 = v242;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v203;
        }
        while (v203);
        goto LABEL_323;
      case 12:
        unsigned int v244 = v707;
        do
        {
          int v245 = v26;
          do
          {
            short float v246 = *(short float *)(v61 + 2);
            short float v247 = *(short float *)(v43 + 2);
            *(short float *)unint64_t v61 = *(short float *)v61 + *(short float *)v43;
            *(short float *)(v61 + 2) = v246 + v247;
            _S1 = 1.0;
            if (v54)
            {
              _H1 = *(_WORD *)(v43 + 6);
              __asm { FCVT            S1, H1 }
            }
            _H2 = *(_WORD *)(v61 + 6);
            __asm { FCVT            S2, H2 }
            _S1 = _S1 + _S2;
            if (_S1 > 1.0) {
              _S1 = 1.0;
            }
            *(short float *)(v61 + 4) = *(short float *)(v61 + 4) + *(short float *)(v43 + 4);
            __asm { FCVT            H1, S1 }
            *(_WORD *)(v61 + 6) = _H1;
            unint64_t v254 = v43 + 8 * v666;
            if (v254 >= v56) {
              uint64_t v255 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v255 = 0;
            }
            uint64_t v43 = v254 + 8 * v255;
            v61 += 8 * v666;
            --v245;
          }
          while (v245);
          v61 += 8 * v693;
          unint64_t v256 = v55 + 8 * v697;
          if (v256 >= v695) {
            uint64_t v257 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v257 = 0;
          }
          unint64_t v258 = v256 + 8 * v257;
          uint64_t v259 = v56 + 8 * v257 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v259;
            unint64_t v55 = v258;
            uint64_t v43 = v258;
          }
          else
          {
            v43 += 8 * v697;
          }
          --v244;
        }
        while (v244);
        goto LABEL_323;
      case 13:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v260 = v707;
        while (1)
        {
          unsigned int v674 = v260;
          int v261 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_290;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_290;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAmultiplyPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_290:
            unint64_t v265 = v43 + 8 * v666;
            if (v265 >= v56) {
              uint64_t v266 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v266 = 0;
            }
            uint64_t v43 = v265 + 8 * v266;
            v61 += 8 * v666;
            --v261;
          }
          while (v261);
          v61 += 8 * v693;
          unint64_t v267 = v55 + 8 * v697;
          uint64_t v268 = -(uint64_t)(v697 * (int)v668);
          if (v267 < v695) {
            uint64_t v268 = 0;
          }
          unint64_t v269 = v267 + 8 * v268;
          uint64_t v270 = v56 + 8 * v268 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v270;
            unint64_t v55 = v269;
            uint64_t v43 = v269;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v260 = v674 - 1;
          if (v674 == 1) {
            goto LABEL_609;
          }
        }
      case 14:
        unsigned int v271 = v707;
        while (1)
        {
          int v272 = v26;
          do
          {
            _S2 = 1.0;
            _S1 = 1.0;
            if (v54)
            {
              __asm { FCMP            H1, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_312;
              }
              __asm { FCVT            S1, H1 }
            }
            if (!v22) {
              goto LABEL_310;
            }
            __asm { FCMP            H2, #0 }
            if (!_ZF & _CF)
            {
              __asm { FCVT            S2, H2 }
LABEL_310:
              _H3 = *(_WORD *)v61;
              _H4 = *(_WORD *)(v61 + 2);
              _H5 = *(_WORD *)(v61 + 4);
              _H6 = *(short float *)v43;
              _H7 = *(_WORD *)(v43 + 2);
              _H16 = *(_WORD *)(v43 + 4);
              __asm
              {
                FCVT            S3, H3
                FCVT            S4, H4
                FCVT            S5, H5
                FCVT            S6, H6
                FCVT            S7, H7
                FCVT            S16, H16
              }
              _S3 = _S3 + (float)(_S6 * (float)(1.0 - _S3));
              _S4 = _S4 + (float)(_S7 * (float)(1.0 - _S4));
              _S5 = _S5 + (float)(_S16 * (float)(1.0 - _S5));
              _S1 = (float)(_S1 + _S2) - (float)(_S2 * _S1);
              __asm
              {
                FCVT            H2, S3
                FCVT            H3, S4
                FCVT            H4, S5
              }
              *(_WORD *)unint64_t v61 = _H2;
              *(_WORD *)(v61 + 2) = LOWORD(_S3);
              __asm { FCVT            H1, S1 }
              *(_WORD *)(v61 + 4) = LOWORD(_S4);
              goto LABEL_311;
            }
            *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
            *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
            __asm { FCVT            H1, S1 }
LABEL_311:
            *(_WORD *)(v61 + 6) = _H1;
LABEL_312:
            unint64_t v295 = v43 + 8 * v666;
            if (v295 >= v56) {
              uint64_t v296 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v296 = 0;
            }
            uint64_t v43 = v295 + 8 * v296;
            v61 += 8 * v666;
            --v272;
          }
          while (v272);
          v61 += 8 * v693;
          unint64_t v297 = v55 + 8 * v697;
          if (v297 >= v695) {
            uint64_t v298 = -(uint64_t)(v697 * (int)v668);
          }
          else {
            uint64_t v298 = 0;
          }
          unint64_t v299 = v297 + 8 * v298;
          uint64_t v300 = v56 + 8 * v298 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v300;
            unint64_t v55 = v299;
            uint64_t v43 = v299;
          }
          else
          {
            v43 += 8 * v697;
          }
          if (!--v271)
          {
LABEL_323:
            unsigned int v707 = 0;
            goto LABEL_611;
          }
        }
      case 15:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v301 = v707;
        while (1)
        {
          unsigned int v675 = v301;
          int v302 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_335;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_335;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAoverlayPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_335:
            unint64_t v306 = v43 + 8 * v666;
            if (v306 >= v56) {
              uint64_t v307 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v307 = 0;
            }
            uint64_t v43 = v306 + 8 * v307;
            v61 += 8 * v666;
            --v302;
          }
          while (v302);
          v61 += 8 * v693;
          unint64_t v308 = v55 + 8 * v697;
          uint64_t v309 = -(uint64_t)(v697 * (int)v668);
          if (v308 < v695) {
            uint64_t v309 = 0;
          }
          unint64_t v310 = v308 + 8 * v309;
          uint64_t v311 = v56 + 8 * v309 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v311;
            unint64_t v55 = v310;
            uint64_t v43 = v310;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v301 = v675 - 1;
          if (v675 == 1) {
            goto LABEL_609;
          }
        }
      case 16:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v312 = v707;
        while (1)
        {
          unsigned int v676 = v312;
          int v313 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_357;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_357;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAdarkenPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_357:
            unint64_t v317 = v43 + 8 * v666;
            if (v317 >= v56) {
              uint64_t v318 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v318 = 0;
            }
            uint64_t v43 = v317 + 8 * v318;
            v61 += 8 * v666;
            --v313;
          }
          while (v313);
          v61 += 8 * v693;
          unint64_t v319 = v55 + 8 * v697;
          uint64_t v320 = -(uint64_t)(v697 * (int)v668);
          if (v319 < v695) {
            uint64_t v320 = 0;
          }
          unint64_t v321 = v319 + 8 * v320;
          uint64_t v322 = v56 + 8 * v320 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v322;
            unint64_t v55 = v321;
            uint64_t v43 = v321;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v312 = v676 - 1;
          if (v676 == 1) {
            goto LABEL_609;
          }
        }
      case 17:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v323 = v707;
        while (1)
        {
          unsigned int v677 = v323;
          int v324 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_379;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_379;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAlightenPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_379:
            unint64_t v328 = v43 + 8 * v666;
            if (v328 >= v56) {
              uint64_t v329 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v329 = 0;
            }
            uint64_t v43 = v328 + 8 * v329;
            v61 += 8 * v666;
            --v324;
          }
          while (v324);
          v61 += 8 * v693;
          unint64_t v330 = v55 + 8 * v697;
          uint64_t v331 = -(uint64_t)(v697 * (int)v668);
          if (v330 < v695) {
            uint64_t v331 = 0;
          }
          unint64_t v332 = v330 + 8 * v331;
          uint64_t v333 = v56 + 8 * v331 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v333;
            unint64_t v55 = v332;
            uint64_t v43 = v332;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v323 = v677 - 1;
          if (v677 == 1) {
            goto LABEL_609;
          }
        }
      case 18:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v334 = v707;
        while (1)
        {
          unsigned int v678 = v334;
          int v335 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_401;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_401;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAcolordodgePDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_401:
            unint64_t v339 = v43 + 8 * v666;
            if (v339 >= v56) {
              uint64_t v340 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v340 = 0;
            }
            uint64_t v43 = v339 + 8 * v340;
            v61 += 8 * v666;
            --v335;
          }
          while (v335);
          v61 += 8 * v693;
          unint64_t v341 = v55 + 8 * v697;
          uint64_t v342 = -(uint64_t)(v697 * (int)v668);
          if (v341 < v695) {
            uint64_t v342 = 0;
          }
          unint64_t v343 = v341 + 8 * v342;
          uint64_t v344 = v56 + 8 * v342 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v344;
            unint64_t v55 = v343;
            uint64_t v43 = v343;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v334 = v678 - 1;
          if (v678 == 1) {
            goto LABEL_609;
          }
        }
      case 19:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v345 = v707;
        while (1)
        {
          unsigned int v679 = v345;
          int v346 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_423;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_423;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAcolorburnPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_423:
            unint64_t v350 = v43 + 8 * v666;
            if (v350 >= v56) {
              uint64_t v351 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v351 = 0;
            }
            uint64_t v43 = v350 + 8 * v351;
            v61 += 8 * v666;
            --v346;
          }
          while (v346);
          v61 += 8 * v693;
          unint64_t v352 = v55 + 8 * v697;
          uint64_t v353 = -(uint64_t)(v697 * (int)v668);
          if (v352 < v695) {
            uint64_t v353 = 0;
          }
          unint64_t v354 = v352 + 8 * v353;
          uint64_t v355 = v56 + 8 * v353 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v355;
            unint64_t v55 = v354;
            uint64_t v43 = v354;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v345 = v679 - 1;
          if (v679 == 1) {
            goto LABEL_609;
          }
        }
      case 20:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v356 = v707;
        while (1)
        {
          unsigned int v680 = v356;
          int v357 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_445;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_445;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAsoftlightPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_445:
            unint64_t v361 = v43 + 8 * v666;
            if (v361 >= v56) {
              uint64_t v362 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v362 = 0;
            }
            uint64_t v43 = v361 + 8 * v362;
            v61 += 8 * v666;
            --v357;
          }
          while (v357);
          v61 += 8 * v693;
          unint64_t v363 = v55 + 8 * v697;
          uint64_t v364 = -(uint64_t)(v697 * (int)v668);
          if (v363 < v695) {
            uint64_t v364 = 0;
          }
          unint64_t v365 = v363 + 8 * v364;
          uint64_t v366 = v56 + 8 * v364 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v366;
            unint64_t v55 = v365;
            uint64_t v43 = v365;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v356 = v680 - 1;
          if (v680 == 1) {
            goto LABEL_609;
          }
        }
      case 21:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v367 = v707;
        while (1)
        {
          unsigned int v681 = v367;
          int v368 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_467;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_467;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAhardlightPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_467:
            unint64_t v372 = v43 + 8 * v666;
            if (v372 >= v56) {
              uint64_t v373 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v373 = 0;
            }
            uint64_t v43 = v372 + 8 * v373;
            v61 += 8 * v666;
            --v368;
          }
          while (v368);
          v61 += 8 * v693;
          unint64_t v374 = v55 + 8 * v697;
          uint64_t v375 = -(uint64_t)(v697 * (int)v668);
          if (v374 < v695) {
            uint64_t v375 = 0;
          }
          unint64_t v376 = v374 + 8 * v375;
          uint64_t v377 = v56 + 8 * v375 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v377;
            unint64_t v55 = v376;
            uint64_t v43 = v376;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v367 = v681 - 1;
          if (v681 == 1) {
            goto LABEL_609;
          }
        }
      case 22:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v378 = v707;
        while (1)
        {
          unsigned int v682 = v378;
          int v379 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_489;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_489;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAdifferencePDA(a3, _Q1.n128_f64[0], a5.n128_f64[0], _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, *(_DWORD *)(v43 + 4), _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_489:
            unint64_t v383 = v43 + 8 * v666;
            if (v383 >= v56) {
              uint64_t v384 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v384 = 0;
            }
            uint64_t v43 = v383 + 8 * v384;
            v61 += 8 * v666;
            --v379;
          }
          while (v379);
          v61 += 8 * v693;
          unint64_t v385 = v55 + 8 * v697;
          uint64_t v386 = -(uint64_t)(v697 * (int)v668);
          if (v385 < v695) {
            uint64_t v386 = 0;
          }
          unint64_t v387 = v385 + 8 * v386;
          uint64_t v388 = v56 + 8 * v386 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v388;
            unint64_t v55 = v387;
            uint64_t v43 = v387;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v378 = v682 - 1;
          if (v682 == 1) {
            goto LABEL_609;
          }
        }
      case 23:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v389 = v707;
        while (1)
        {
          unsigned int v683 = v389;
          int v390 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_511;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_511;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAexclusionPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_511:
            unint64_t v394 = v43 + 8 * v666;
            if (v394 >= v56) {
              uint64_t v395 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v395 = 0;
            }
            uint64_t v43 = v394 + 8 * v395;
            v61 += 8 * v666;
            --v390;
          }
          while (v390);
          v61 += 8 * v693;
          unint64_t v396 = v55 + 8 * v697;
          uint64_t v397 = -(uint64_t)(v697 * (int)v668);
          if (v396 < v695) {
            uint64_t v397 = 0;
          }
          unint64_t v398 = v396 + 8 * v397;
          uint64_t v399 = v56 + 8 * v397 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v399;
            unint64_t v55 = v398;
            uint64_t v43 = v398;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v389 = v683 - 1;
          if (v683 == 1) {
            goto LABEL_609;
          }
        }
      case 24:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v400 = v707;
        while (1)
        {
          unsigned int v684 = v400;
          int v401 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_533;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_533;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAhuePDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_533:
            unint64_t v405 = v43 + 8 * v666;
            if (v405 >= v56) {
              uint64_t v406 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v406 = 0;
            }
            uint64_t v43 = v405 + 8 * v406;
            v61 += 8 * v666;
            --v401;
          }
          while (v401);
          v61 += 8 * v693;
          unint64_t v407 = v55 + 8 * v697;
          uint64_t v408 = -(uint64_t)(v697 * (int)v668);
          if (v407 < v695) {
            uint64_t v408 = 0;
          }
          unint64_t v409 = v407 + 8 * v408;
          uint64_t v410 = v56 + 8 * v408 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v410;
            unint64_t v55 = v409;
            uint64_t v43 = v409;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v400 = v684 - 1;
          if (v684 == 1) {
            goto LABEL_609;
          }
        }
      case 25:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v411 = v707;
        while (1)
        {
          unsigned int v685 = v411;
          int v412 = v26;
          do
          {
            _Q5.i32[0] = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_555;
              }
              __asm { FCVT            S5, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S5 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_555;
              }
              __asm { FCVT            S4, H3 }
            }
            else
            {
              LOWORD(_D3) = *(_WORD *)(v61 + 6);
              _S4 = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v61;
            _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
            a5.n128_u16[0] = *(_WORD *)(v61 + 4);
            *(_WORD *)unint64_t v61 = PDAsaturationPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                              _Q5.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_555:
            unint64_t v416 = v43 + 8 * v666;
            if (v416 >= v56) {
              uint64_t v417 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v417 = 0;
            }
            uint64_t v43 = v416 + 8 * v417;
            v61 += 8 * v666;
            --v412;
          }
          while (v412);
          v61 += 8 * v693;
          unint64_t v418 = v55 + 8 * v697;
          uint64_t v419 = -(uint64_t)(v697 * (int)v668);
          if (v418 < v695) {
            uint64_t v419 = 0;
          }
          unint64_t v420 = v418 + 8 * v419;
          uint64_t v421 = v56 + 8 * v419 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v421;
            unint64_t v55 = v420;
            uint64_t v43 = v420;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v411 = v685 - 1;
          if (v685 == 1) {
            goto LABEL_609;
          }
        }
      case 26:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v422 = v707;
        int v691 = v26;
        while (1)
        {
          unsigned int v686 = v422;
          do
          {
            _S4 = 1.0;
            if (v54)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_577;
              }
              __asm { FCVT            S4, H0 }
            }
            if (v22)
            {
              __asm { FCMP            H5, #0 }
              if (!(!_ZF & _CF))
              {
                *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
                *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
                __asm { FCVT            H0, S4 }
                *(_WORD *)(v61 + 6) = _H0;
                goto LABEL_577;
              }
              __asm { FCVT            S6, H5 }
            }
            else
            {
              _Q5.i16[0] = *(_WORD *)(v61 + 6);
              _Q6.i32[0] = 1.0;
            }
            a3.n128_u16[0] = *(_WORD *)v43;
            _Q1.n128_u16[0] = *(_WORD *)(v43 + 2);
            a5.n128_u16[0] = *(_WORD *)(v43 + 4);
            LOWORD(_D3) = *(_WORD *)(v43 + 6);
            a10.i16[0] = *(_WORD *)v61;
            *(_WORD *)unint64_t v61 = PDAluminosityPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_WORD *)v61, *(_DWORD *)(v61 + 2), HIWORD(*(_DWORD *)(v61 + 2)),
                              _Q6.f32[0]);
            *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
            *(_WORD *)(v61 + 4) = a5.n128_u16[0];
            *(_WORD *)(v61 + 6) = LOWORD(_D3);
LABEL_577:
            unint64_t v426 = v43 + 8 * v666;
            if (v426 >= v56) {
              uint64_t v427 = -(uint64_t)(int)v672;
            }
            else {
              uint64_t v427 = 0;
            }
            uint64_t v43 = v426 + 8 * v427;
            v61 += 8 * v666;
            LODWORD(v26) = v26 - 1;
          }
          while (v26);
          v61 += 8 * v693;
          unint64_t v428 = v55 + 8 * v697;
          uint64_t v429 = -(uint64_t)(v697 * (int)v668);
          if (v428 < v695) {
            uint64_t v429 = 0;
          }
          unint64_t v430 = v428 + 8 * v429;
          uint64_t v431 = v56 + 8 * v429 + 8 * v697;
          if (v695)
          {
            unint64_t v56 = v431;
            unint64_t v55 = v430;
            uint64_t v43 = v430;
          }
          else
          {
            v43 += 8 * v697;
          }
          unsigned int v422 = v686 - 1;
          LODWORD(v26) = v691;
          if (v686 == 1) {
            goto LABEL_609;
          }
        }
      case 27:
        unint64_t v664 = v45;
        unint64_t v665 = v44;
        unsigned int v432 = v707;
        break;
      default:
        goto LABEL_611;
    }
LABEL_589:
    unsigned int v687 = v432;
    int v433 = v26;
    while (1)
    {
      _Q5.i32[0] = 1.0;
      if (v54)
      {
        __asm { FCMP            H0, #0 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_599;
        }
        __asm { FCVT            S5, H0 }
      }
      if (!v22)
      {
        LOWORD(_D3) = *(_WORD *)(v61 + 6);
        _S4 = 1.0;
        goto LABEL_598;
      }
      __asm { FCMP            H3, #0 }
      if (!_ZF & _CF)
      {
        __asm { FCVT            S4, H3 }
LABEL_598:
        a3.n128_u16[0] = *(_WORD *)v61;
        _Q1.n128_u16[0] = *(_WORD *)(v61 + 2);
        a5.n128_u16[0] = *(_WORD *)(v61 + 4);
        *(_WORD *)unint64_t v61 = PDAluminosityPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, v46, v47, *(_DWORD *)v43, HIWORD(*(_DWORD *)v43), *(_DWORD *)(v43 + 4),
                          _Q5.f32[0]);
        *(_WORD *)(v61 + 2) = _Q1.n128_u16[0];
        *(_WORD *)(v61 + 4) = a5.n128_u16[0];
        *(_WORD *)(v61 + 6) = LOWORD(_D3);
        goto LABEL_599;
      }
      *(_DWORD *)unint64_t v61 = *(_DWORD *)v43;
      *(_WORD *)(v61 + 4) = *(_WORD *)(v43 + 4);
      __asm { FCVT            H0, S5 }
      *(_WORD *)(v61 + 6) = _H0;
LABEL_599:
      unint64_t v437 = v43 + 8 * v666;
      if (v437 >= v56) {
        uint64_t v438 = -(uint64_t)(int)v672;
      }
      else {
        uint64_t v438 = 0;
      }
      uint64_t v43 = v437 + 8 * v438;
      v61 += 8 * v666;
      if (!--v433)
      {
        v61 += 8 * v693;
        unint64_t v439 = v55 + 8 * v697;
        uint64_t v440 = -(uint64_t)(v697 * (int)v668);
        if (v439 < v695) {
          uint64_t v440 = 0;
        }
        unint64_t v441 = v439 + 8 * v440;
        uint64_t v442 = v56 + 8 * v440 + 8 * v697;
        if (v695)
        {
          unint64_t v56 = v442;
          unint64_t v55 = v441;
          uint64_t v43 = v441;
        }
        else
        {
          v43 += 8 * v697;
        }
        unsigned int v432 = v687 - 1;
        if (v687 == 1)
        {
LABEL_609:
          unsigned int v707 = 0;
          uint64_t v25 = a2;
          unint64_t v45 = v664;
LABEL_610:
          unint64_t v44 = v665;
LABEL_611:
          uint64_t v43 = v670;
LABEL_612:
          uint64_t v64 = v669;
          if (!v669) {
            return 1;
          }
LABEL_613:
          uint64_t v706 = 0;
LABEL_614:
          a1 = (uint64_t *)shape_enum_clip_next(v64, (int *)&v706 + 1, &v706, &v703, &v707);
          if (!a1)
          {
            uint64_t v443 = (void *)v64;
            goto LABEL_959;
          }
          uint64_t v669 = v64;
          uint64_t v670 = v43;
          if (v695)
          {
            unint64_t v61 = v45 + 8 * v44 * (int)v706 + 8 * SHIDWORD(v706);
            LODWORD(v26) = v703;
            unint64_t v62 = v43 + 8 * v697 * (((int)v706 + *(_DWORD *)(v25 + 60)) % (int)v668);
            unint64_t v55 = v62 + 8 * ((HIDWORD(v706) + *(_DWORD *)(v25 + 56)) % (int)v672);
            unint64_t v56 = v62 + 8 * (int)v672;
            uint64_t v43 = v55;
            LODWORD(v62) = v703;
            int v662 = ((int)v706 + *(_DWORD *)(v25 + 60)) % (int)v668;
            int v663 = (HIDWORD(v706) + *(_DWORD *)(v25 + 56)) % (int)v672;
          }
          else
          {
            LODWORD(v26) = v703;
            LODWORD(v62) = v703 * v666;
            unint64_t v61 = v45 + 8 * v44 * (int)v706 + 8 * HIDWORD(v706) * v666;
            v43 += 8 * (int)v706 * (int)v672 + 8 * HIDWORD(v706) * v666;
            unint64_t v697 = (int)v672 - v703 * v666;
          }
          unint64_t v62 = (int)v62;
          goto LABEL_51;
        }
        goto LABEL_589;
      }
    }
  }
  LODWORD(v706) = *(_DWORD *)(a2 + 8);
  HIDWORD(v706) = v26;
  uint64_t v31 = *(void *)(a2 + 40);
  uint64_t v32 = *(void *)(a2 + 88);
  _D18.i32[0] = *(_DWORD *)v32;
  LOWORD(_S19) = *(_WORD *)(v32 + 4);
  LOWORD(_S9) = *(_WORD *)(v32 + 6);
  __asm { FCVT            S20, H9 }
  a3.n128_f32[0] = 1.0 - _S20;
  int32x2_t v673 = (int32x2_t)a3.n128_u64[0];
  int v690 = _S9;
  unint64_t v671 = *(int *)(a2 + 28);
  unint64_t v38 = v671 >> 3;
  unint64_t v39 = *(int *)(a2 + 12) + (v671 >> 3) * *(int *)(a2 + 16);
  uint64_t v40 = v31 + 8 * v39;
  unsigned __int32 v694 = _S19;
  float16x4_t v696 = _D18;
  float v692 = _S20;
  if (v29)
  {
    shape_enum_clip_alloc((uint64_t)a1, a2, v29, 1, 1, 1, *(_DWORD *)(a2 + 104), *(_DWORD *)(a2 + 108), v26, v28);
    uint64_t v42 = v41;
    if (!v41) {
      return 1;
    }
    goto LABEL_956;
  }
  int v57 = v26;
  uint64_t v42 = 0;
  uint64_t v58 = (float16x4_t *)(v31 + 8 * v39);
LABEL_687:
  unint64_t v482 = v38 - v57;
  switch((int)v23)
  {
    case 0:
      unsigned int v483 = v706;
      int v484 = 8 * v57;
      goto LABEL_962;
    case 1:
      uint64_t v485 = *(void *)(v25 + 88);
      if (v485)
      {
        CGSFillDRAM64((unint64_t)v58, v671 & 0xFFFFFFF8, 8 * v57, v706, v485, 8, 8, 1, 0, 0);
        if (!v42) {
          return 1;
        }
        goto LABEL_955;
      }
      int v484 = 8 * v57;
      unsigned int v483 = v706;
LABEL_962:
      CGBlt_fillBytes(v484, v483, 0, (char *)v58, v671 & 0xFFFFFFF8);
      if (v42) {
        goto LABEL_955;
      }
      return 1;
    case 2:
      int v486 = v706;
      __int32 v703 = _D18.i32[0];
      __int16 v704 = _S19;
      __int16 v705 = _S9;
      if (use_vImage_fp16_compositing(void)::predicate != -1)
      {
        dispatch_once(&use_vImage_fp16_compositing(void)::predicate, &__block_literal_global_21437);
        _S20 = v692;
        LOWORD(_S19) = v694;
        _D18 = v696;
      }
      if (use_vImage_fp16_compositing(void)::status)
      {
        unsigned int v707 = 66051;
        *(void *)&long long v711 = v58;
        *((void *)&v711 + 1) = v486;
        *(void *)&long long v712 = v57;
        *((void *)&v712 + 1) = v671 & 0xFFFFFFFFFFFFFFF8;
        int v708 = &v703;
        int64x2_t v709 = vdupq_n_s64(1uLL);
        uint64_t v710 = 8;
        uint64_t v699 = v42;
        uint64_t v700 = v486;
        uint64_t v701 = v57;
        uint64_t v702 = v57;
        vImageCGCompositeConstShape_ARGB16F();
        uint64_t v25 = a2;
      }
      else
      {
        v657.i64[0] = vcvtq_f32_f16(_D18).u64[0];
        float32x4_t v655 = (float32x4_t)vdupq_lane_s32(v673, 0);
        __asm { FCVT            S2, H19 }
        v657.i64[1] = __PAIR64__(LODWORD(_S20), _S2);
        uint64_t v25 = a2;
        do
        {
          if (v57 >= 1)
          {
            unsigned int v658 = v57 + 1;
            do
            {
              *uint64_t v58 = vcvt_f16_f32(vmlaq_f32(v657, v655, vcvtq_f32_f16(*v58)));
              ++v58;
              --v658;
            }
            while (v658 > 1);
          }
          v58 += v482;
          _VF = __OFSUB__(v486--, 1);
        }
        while (!((v486 < 0) ^ _VF | (v486 == 0)));
      }
      goto LABEL_953;
    case 3:
      int v487 = v706;
      v488.i32[0] = _D18.i32[0];
      v488.i16[2] = _S19;
      v488.i16[3] = _S9;
      do
      {
        int v489 = v57;
        do
        {
          __asm { FCMP            H3, #0 }
          if (!_ZF & _CF)
          {
            if (_H3 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
            {
              v58->i32[0] = _D18.i32[0];
              v58->i16[2] = _S19;
              v58->i16[3] = _S9;
            }
            else
            {
              *uint64_t v58 = vmul_n_f16(v488, _H3);
            }
          }
          else
          {
            *uint64_t v58 = 0;
          }
          ++v58;
          --v489;
        }
        while (v489);
        v58 += v482;
        --v487;
      }
      while (v487);
      goto LABEL_795;
    case 4:
      v493.i64[0] = vcvtq_f32_f16(_D18).u64[0];
      __asm { FCVT            S2, H19 }
      int v492 = v706;
      v493.i64[1] = __PAIR64__(LODWORD(_S20), _S2);
      do
      {
        int v494 = v57;
        do
        {
          _H3 = v58->i16[3];
          __asm { FCVT            S3, H3 }
          float v497 = 1.0 - _S3;
          if (v497 <= 0.0)
          {
            *uint64_t v58 = 0;
          }
          else if (v497 >= 1.0)
          {
            v58->i32[0] = _D18.i32[0];
            v58->i16[2] = _S19;
            v58->i16[3] = _S9;
          }
          else
          {
            *uint64_t v58 = vcvt_f16_f32(vmulq_n_f32(v493, v497));
          }
          ++v58;
          --v494;
        }
        while (v494);
        v58 += v482;
        --v492;
      }
      while (v492);
      goto LABEL_795;
    case 5:
      v500.i64[0] = vcvtq_f32_f16(_D18).u64[0];
      __asm { FCVT            S1, H19 }
      int v499 = v706;
      v500.i64[1] = __PAIR64__(LODWORD(_S20), _S1);
      do
      {
        int v501 = v57;
        do
        {
          float32x4_t v502 = vcvtq_f32_f16(*v58);
          *v58++ = vcvt_f16_f32(vmlaq_laneq_f32(vmulq_n_f32(v502, *(float *)v673.i32), v500, v502, 3));
          --v501;
        }
        while (v501);
        v58 += v482;
        --v499;
      }
      while (v499);
      goto LABEL_795;
    case 6:
      __asm { FCVT            S0, H18; jumptable 0000000184CBD104 case 6 }
      _H1 = _D18.i16[1];
      __asm
      {
        FCVT            S2, H1
        FCVT            S3, H19
      }
      int v507 = v706;
      while (1)
      {
        int v508 = v57;
        do
        {
          _H5 = v58->i16[3];
          __asm { FCVT            S5, H5 }
          float v511 = 1.0 - _S5;
          if ((float)(1.0 - _S5) >= 1.0)
          {
            v58->i32[0] = _D18.i32[0];
            _H5 = _S9;
            v58->i16[2] = _S19;
          }
          else
          {
            if (v511 <= 0.0) {
              goto LABEL_728;
            }
            _H7 = v58->i16[0];
            __asm { FCVT            S7, H7 }
            _S7 = _S7 + (float)(_S0 * v511);
            __asm { FCVT            H7, S7 }
            v58->i16[0] = LOWORD(_S7);
            LOWORD(_S7) = v58->i16[1];
            __asm { FCVT            S7, H7 }
            _S7 = _S7 + (float)(_S2 * v511);
            __asm { FCVT            H7, S7 }
            v58->i16[1] = LOWORD(_S7);
            LOWORD(_S7) = v58->i16[2];
            __asm { FCVT            S7, H7 }
            _S7 = _S7 + (float)(_S3 * v511);
            __asm { FCVT            H7, S7 }
            v58->i16[2] = LOWORD(_S7);
            _S5 = _S5 + (float)(_S20 * v511);
            __asm { FCVT            H5, S5 }
          }
          v58->i16[3] = _H5;
LABEL_728:
          ++v58;
          --v508;
        }
        while (v508);
        v58 += v482;
        if (!--v507)
        {
LABEL_795:
          LODWORD(v706) = 0;
          if (!v42) {
            return 1;
          }
LABEL_955:
          uint64_t v698 = 0;
LABEL_956:
          a1 = (uint64_t *)shape_enum_clip_next(v42, (int *)&v698 + 1, &v698, (_DWORD *)&v706 + 1, &v706);
          if (a1)
          {
            uint64_t v58 = (float16x4_t *)(v40 + 8 * v38 * (int)v698 + 8 * SHIDWORD(v698));
            int v57 = HIDWORD(v706);
            _S19 = v694;
            _D18 = v696;
            _S9 = v690;
            _S20 = v692;
            goto LABEL_687;
          }
          uint64_t v443 = (void *)v42;
LABEL_959:
          free(v443);
          return 1;
        }
      }
    case 7:
      int v521 = v706;
      do
      {
        int v522 = v57;
        do
        {
          *uint64_t v58 = vmul_n_f16(*v58, *(short float *)&_S9);
          ++v58;
          --v522;
        }
        while (v522);
        v58 += v482;
        --v521;
      }
      while (v521);
      goto LABEL_795;
    case 8:
      int v523 = v706;
      do
      {
        int v524 = v57;
        do
        {
          *uint64_t v58 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v58), *(float *)v673.i32));
          ++v58;
          --v524;
        }
        while (v524);
        v58 += v482;
        --v523;
      }
      while (v523);
      goto LABEL_795;
    case 9:
      v527.i64[0] = vcvtq_f32_f16(_D18).u64[0];
      __asm { FCVT            S1, H19 }
      int v526 = v706;
      v527.i64[1] = __PAIR64__(LODWORD(_S20), _S1);
      do
      {
        int v528 = v57;
        do
        {
          float32x4_t v529 = vcvtq_f32_f16(*v58);
          *v58++ = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v529, _S20), v527, 1.0 - v529.f32[3]));
          --v528;
        }
        while (v528);
        v58 += v482;
        --v526;
      }
      while (v526);
      goto LABEL_795;
    case 10:
      v532.i64[0] = vcvtq_f32_f16(_D18).u64[0];
      __asm { FCVT            S1, H19 }
      int v531 = v706;
      v532.i64[1] = __PAIR64__(LODWORD(_S20), _S1);
      do
      {
        int v533 = v57;
        do
        {
          float32x4_t v534 = vcvtq_f32_f16(*v58);
          *v58++ = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v534, *(float *)v673.i32), v532, 1.0 - v534.f32[3]));
          --v533;
        }
        while (v533);
        v58 += v482;
        --v531;
      }
      while (v531);
      goto LABEL_795;
    case 11:
      __asm { FCVT            S0, H18; jumptable 0000000184CBD104 case 11 }
      float v536 = _S20 - _S0;
      _H1 = _D18.i16[1];
      __asm { FCVT            S1, H1 }
      float v539 = _S20 - _S1;
      __asm { FCVT            S2, H19 }
      float v541 = _S20 - _S2;
      int v542 = v706;
      do
      {
        int v543 = v57;
        do
        {
          _S4 = 1.0;
          _S5 = 1.0;
          if (v22)
          {
            _H3 = v58->i16[3];
            __asm { FCVT            S5, H3 }
          }
          _S3 = _S5 + _S20;
          if ((float)(_S5 + _S20) > 1.0) {
            _S3 = 1.0;
          }
          if (v22)
          {
            _H4 = v58->i16[3];
            __asm { FCVT            S4, H4 }
          }
          _H6 = v58->i16[0];
          __asm { FCVT            S6, H6 }
          float v551 = v536 + (float)(_S5 - _S6);
          _H5 = v58->i16[1];
          _S6 = _S3 - v551;
          __asm { FCVT            H6, S6 }
          v58->i16[0] = LOWORD(_S6);
          if (v22)
          {
            _H6 = v58->i16[3];
            __asm { FCVT            S6, H6 }
          }
          else
          {
            _S6 = 1.0;
          }
          __asm { FCVT            S5, H5 }
          float v557 = v539 + (float)(_S4 - _S5);
          LOWORD(_S5) = v58->i16[2];
          __asm { FCVT            S5, H5 }
          _S4 = _S3 - v557;
          __asm { FCVT            H4, S4 }
          v58->i16[1] = LOWORD(_S4);
          __asm { FCVT            H4, S3 }
          v58->i16[3] = LOWORD(_S4);
          _S3 = _S3 - (float)(v541 + (float)(_S6 - _S5));
          __asm { FCVT            H3, S3 }
          v58->i16[2] = LOWORD(_S3);
          ++v58;
          --v543;
        }
        while (v543);
        v58 += v482;
        --v542;
      }
      while (v542);
      goto LABEL_795;
    case 12:
      int v561 = v706;
      do
      {
        int v562 = v57;
        do
        {
          short float v563 = *(short float *)&v58->i16[1];
          *(short float *)v58->i16 = *(short float *)_D18.i16 + *(short float *)v58->i16;
          *(short float *)&v58->i16[1] = *(short float *)&_D18.i16[1] + v563;
          _H2 = v58->i16[3];
          __asm { FCVT            S2, H2 }
          _S2 = _S20 + _S2;
          if (_S2 > 1.0) {
            _S2 = 1.0;
          }
          *(short float *)&v58->i16[2] = *(short float *)&_S19 + *(short float *)&v58->i16[2];
          __asm { FCVT            H2, S2 }
          v58->i16[3] = _H2;
          ++v58;
          --v562;
        }
        while (v562);
        v58 += v482;
        --v561;
      }
      while (v561);
      goto LABEL_795;
    case 13:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 13 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v569 = _D18.i16[1];
      int v570 = v706;
      while (1)
      {
        int v571 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v569;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_781;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAmultiplyPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v569, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_781:
          ++v58;
          --v571;
        }
        while (v571);
        v58 += v482;
        if (!--v570) {
          goto LABEL_952;
        }
      }
    case 14:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 14 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __asm { FCVT            S0, H18 }
      _H1 = _D18.i16[1];
      __asm
      {
        FCVT            S2, H1
        FCVT            S3, H19
      }
      int v578 = v706;
      while (1)
      {
        int v579 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H5, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i32[0] = _D18.i32[0];
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_793;
            }
            __asm { FCVT            S5, H5 }
          }
          else
          {
            _S5 = 1.0;
          }
          _H6 = v58->i16[0];
          _H7 = v58->i16[1];
          _H16 = v58->i16[2];
          __asm
          {
            FCVT            S6, H6
            FCVT            S7, H7
            FCVT            S16, H16
          }
          _S6 = _S6 + (float)(_S0 * (float)(1.0 - _S6));
          _S7 = _S7 + (float)(_S2 * (float)(1.0 - _S7));
          _S16 = _S16 + (float)(_S3 * (float)(1.0 - _S16));
          _S5 = (float)(_S5 + _S20) - (float)(_S5 * _S20);
          __asm
          {
            FCVT            H6, S6
            FCVT            H7, S7
            FCVT            H16, S16
          }
          v58->i16[0] = LOWORD(_S6);
          v58->i16[1] = LOWORD(_S7);
          __asm { FCVT            H5, S5 }
          v58->i16[2] = LOWORD(_S16);
          v58->i16[3] = LOWORD(_S5);
LABEL_793:
          ++v58;
          --v579;
        }
        while (v579);
        v58 += v482;
        if (!--v578) {
          goto LABEL_795;
        }
      }
    case 15:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 15 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v593 = _D18.i16[1];
      int v594 = v706;
      while (1)
      {
        int v595 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v593;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_806;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAoverlayPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v593, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_806:
          ++v58;
          --v595;
        }
        while (v595);
        v58 += v482;
        if (!--v594) {
          goto LABEL_952;
        }
      }
    case 16:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 16 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v598 = _D18.i16[1];
      int v599 = v706;
      while (1)
      {
        int v600 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v598;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_818;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAdarkenPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v598, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_818:
          ++v58;
          --v600;
        }
        while (v600);
        v58 += v482;
        if (!--v599) {
          goto LABEL_952;
        }
      }
    case 17:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 17 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v603 = _D18.i16[1];
      int v604 = v706;
      while (1)
      {
        int v605 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v603;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_830;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAlightenPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v603, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_830:
          ++v58;
          --v605;
        }
        while (v605);
        v58 += v482;
        if (!--v604) {
          goto LABEL_952;
        }
      }
    case 18:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 18 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v608 = _D18.i16[1];
      int v609 = v706;
      while (1)
      {
        int v610 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v608;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_842;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAcolordodgePDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v608, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_842:
          ++v58;
          --v610;
        }
        while (v610);
        v58 += v482;
        if (!--v609) {
          goto LABEL_952;
        }
      }
    case 19:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 19 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v613 = _D18.i16[1];
      int v614 = v706;
      while (1)
      {
        int v615 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v613;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_854;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAcolorburnPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v613, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_854:
          ++v58;
          --v615;
        }
        while (v615);
        v58 += v482;
        if (!--v614) {
          goto LABEL_952;
        }
      }
    case 20:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 20 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v618 = _D18.i16[1];
      int v619 = v706;
      while (1)
      {
        int v620 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v618;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_866;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAsoftlightPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v618, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_866:
          ++v58;
          --v620;
        }
        while (v620);
        v58 += v482;
        if (!--v619) {
          goto LABEL_952;
        }
      }
    case 21:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 21 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v623 = _D18.i16[1];
      int v624 = v706;
      while (1)
      {
        int v625 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v623;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_878;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAhardlightPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v623, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_878:
          ++v58;
          --v625;
        }
        while (v625);
        v58 += v482;
        if (!--v624) {
          goto LABEL_952;
        }
      }
    case 22:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 22 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v628 = _D18.i16[1];
      int v629 = v706;
      while (1)
      {
        int v630 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v628;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_890;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          HIWORD(v659) = _H9;
          LOWORD(v659) = _S19;
          a3.n128_u16[0] = PDAdifferencePDA(a3, _Q1.n128_f64[0], a5.n128_f64[0], _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v659, _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_890:
          ++v58;
          --v630;
        }
        while (v630);
        v58 += v482;
        if (!--v629) {
          goto LABEL_952;
        }
      }
    case 23:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 23 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v633 = _D18.i16[1];
      int v634 = v706;
      while (1)
      {
        int v635 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v633;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_902;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAexclusionPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v633, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_902:
          ++v58;
          --v635;
        }
        while (v635);
        v58 += v482;
        if (!--v634) {
          goto LABEL_952;
        }
      }
    case 24:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 24 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v638 = _D18.i16[1];
      int v639 = v706;
      while (1)
      {
        int v640 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v638;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_914;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAhuePDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v638, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_914:
          ++v58;
          --v640;
        }
        while (v640);
        v58 += v482;
        if (!--v639) {
          goto LABEL_952;
        }
      }
    case 25:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 25 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v643 = _D18.i16[1];
      int v644 = v706;
      while (1)
      {
        int v645 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H3, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v643;
              v58->i16[2] = _S19;
              v58->i16[3] = _H9;
              goto LABEL_926;
            }
            __asm { FCVT            S4, H3 }
          }
          else
          {
            LOWORD(_D3) = v58->i16[3];
            _S4 = 1.0;
          }
          a3.n128_u16[0] = v58->i16[0];
          _Q1.n128_u16[0] = v58->u16[1];
          a5.n128_u16[0] = v58->u16[2];
          a3.n128_u16[0] = PDAsaturationPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v643, _S19,
                             _S20);
          _H9 = v690;
          _S20 = v692;
          LOWORD(_S19) = v694;
          _D18.i16[0] = v696.i16[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_926:
          ++v58;
          --v645;
        }
        while (v645);
        v58 += v482;
        if (!--v644) {
          goto LABEL_952;
        }
      }
    case 26:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 26 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      LOWORD(v16) = _D18.i16[1];
      int v647 = v706;
      do
      {
        int v648 = v57;
        do
        {
          if (v22)
          {
            __asm { FCMP            H0, #0 }
            if (!(!_ZF & _CF))
            {
              v58->i16[0] = _D18.i16[0];
              v58->i16[1] = v16;
              v58->i16[2] = _S19;
              v58->i16[3] = _S9;
              goto LABEL_938;
            }
            __asm { FCVT            S1, H0 }
          }
          else
          {
            _Q1.n128_u32[0] = 1.0;
          }
          float v660 = _Q1.n128_f32[0];
          a3.n128_u32[0] = _D18.i32[0];
          _Q1.n128_u32[0] = v16;
          a5.n128_u32[0] = _S19;
          LODWORD(_D3) = _S9;
          a3.n128_u16[0] = PDAluminosityPDA(a3, _Q1, a5, _D3, _S20, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, v58->i16[0], *(__int32 *)((char *)v58->i32 + 2), HIWORD(*(unsigned __int32 *)((char *)v58->i32 + 2)),
                             v660);
          _S9 = v690;
          _S20 = v692;
          _S19 = v694;
          _D18.i32[0] = v696.i32[0];
          v58->i16[0] = a3.n128_u16[0];
          v58->i16[1] = _Q1.n128_u16[0];
          v58->i16[2] = a5.n128_u16[0];
          v58->i16[3] = LOWORD(_D3);
LABEL_938:
          ++v58;
          --v648;
        }
        while (v648);
        v58 += v482;
        --v647;
      }
      while (v647);
LABEL_952:
      LODWORD(v706) = 0;
LABEL_953:
      LODWORD(v23) = v667;
LABEL_954:
      if (v42) {
        goto LABEL_955;
      }
      return 1;
    case 27:
      __asm { FCMP            H9, #0; jumptable 0000000184CBD104 case 27 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_954;
      }
      __int16 v651 = _D18.i16[1];
      int v652 = v706;
      break;
    default:
      goto LABEL_954;
  }
LABEL_943:
  int v653 = v57;
  while (v22)
  {
    __asm { FCMP            H3, #0 }
    if (!_ZF & _CF)
    {
      __asm { FCVT            S4, H3 }
LABEL_949:
      a3.n128_u16[0] = v58->i16[0];
      _Q1.n128_u16[0] = v58->u16[1];
      a5.n128_u16[0] = v58->u16[2];
      a3.n128_u16[0] = PDAluminosityPDA(a3, _Q1, a5, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, *(double *)a10.i64, (uint64_t)a1, a2, (uint64_t)v29, a12, a13, a14, a15, a16, _D18.i16[0], v651, _S19,
                         _S20);
      _H9 = v690;
      _S20 = v692;
      LOWORD(_S19) = v694;
      _D18.i16[0] = v696.i16[0];
      v58->i16[0] = a3.n128_u16[0];
      v58->i16[1] = _Q1.n128_u16[0];
      v58->i16[2] = a5.n128_u16[0];
      v58->i16[3] = LOWORD(_D3);
      goto LABEL_950;
    }
    v58->i16[0] = _D18.i16[0];
    v58->i16[1] = v651;
    v58->i16[2] = _S19;
    v58->i16[3] = _H9;
LABEL_950:
    ++v58;
    if (!--v653)
    {
      v58 += v482;
      if (!--v652) {
        goto LABEL_952;
      }
      goto LABEL_943;
    }
  }
  LOWORD(_D3) = v58->i16[3];
  _S4 = 1.0;
  goto LABEL_949;
}