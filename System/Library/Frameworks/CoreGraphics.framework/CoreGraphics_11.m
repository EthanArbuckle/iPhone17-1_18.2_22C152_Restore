int *resample_float16_h_4cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float16x4_t *v12;
  int v13;
  int *v14;
  int v15;
  int *v16;
  float16x4_t *v17;
  float16x4_t v18;
  int v19;
  float16x4_t v26;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = *a6;
    v10 = *a7;
    v11 = 4 * a2 + 8;
    do
    {
      if (a4)
      {
        v12 = *(float16x4_t **)(a5 + 8 * v8);
        v13 = a4;
        v14 = result;
        do
        {
          v15 = v14[1];
          if (v15)
          {
            v16 = v14 + 2;
            v17 = (float16x4_t *)(v9 + v8 * v10 + 8 * *v14);
            v18 = 0;
            do
            {
              v19 = *v16++;
              _S1 = v19;
              __asm
              {
                FCVT            H1, S1
                FCVT            S1, H1
              }
              v26 = *v17++;
              v18 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v18), vcvtq_f32_f16(v26), _S1));
              --v15;
            }
            while (v15);
          }
          else
          {
            v18 = 0;
          }
          *v12++ = v18;
          v14 = (int *)((char *)v14 + v11);
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

int *resample_float16_h_3cpp(int *result, unsigned int a2, double a3, double a4, double a5, double _D3, uint64_t a7, int a8, uint64_t a9, uint64_t *a10, int *a11, int a12)
{
  if (a12 >= 1)
  {
    uint64_t v12 = 0;
    uint64_t v13 = *a10;
    uint64_t v14 = *a11;
    uint64_t v15 = 4 * a2 + 8;
    do
    {
      if (a8)
      {
        uint64_t v16 = *(void *)(a9 + 8 * v12);
        int v17 = a8;
        v18 = result;
        do
        {
          int v19 = v18[1];
          if (v19)
          {
            v20 = v18 + 2;
            uint64_t v21 = v13 + v12 * v14 + 6 * *v18;
            float16x4_t v22 = 0;
            _H0 = 0;
            do
            {
              int v24 = *v20++;
              _S2 = v24;
              __asm { FCVT            H2, S2 }
              LOWORD(_D3) = *(_WORD *)v21;
              __asm
              {
                FCVT            S3, H3
                FCVT            S2, H2
                FCVT            S0, H0
              }
              _S0 = _S0 + (float)(*(float *)&_D3 * _S2);
              __asm { FCVT            H0, S0 }
              float32x4_t v33 = vcvtq_f32_f16(v22);
              LODWORD(_D3) = *(_DWORD *)(v21 + 2);
              *(void *)&_D3 = vcvtq_f32_f16(*(float16x4_t *)&_D3).u64[0];
              *(float32x2_t *)v33.f32 = vmla_n_f32(*(float32x2_t *)v33.f32, *(float32x2_t *)&_D3, _S2);
              float16x4_t v22 = vcvt_f16_f32(v33);
              v21 += 6;
              --v19;
            }
            while (v19);
          }
          else
          {
            v22.i32[0] = 0;
            _H0 = 0;
          }
          *(_WORD *)uint64_t v16 = _H0;
          *(_DWORD *)(v16 + 2) = v22.i32[0];
          v16 += 6;
          v18 = (int *)((char *)v18 + v15);
          --v17;
        }
        while (v17);
      }
      ++v12;
    }
    while (v12 != a12);
  }
  return result;
}

int *resample_float16_h_1cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = *a7;
    uint64_t v11 = 4 * a2 + 8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == a8) {
        return result;
      }
    }
    uint64_t v12 = *(_WORD **)(a5 + 8 * v8);
    int v13 = a4;
    uint64_t v14 = result;
    while (1)
    {
      int v15 = v14[1];
      uint64_t v16 = v14 + 2;
      _S0 = v14[2];
      uint64_t v18 = v9 + v8 * v10 + 2 * *v14 - 2;
      __asm { FCVT            H1, S0 }
      if (v15 >= 4) {
        break;
      }
      _H0 = 0;
      if (v15) {
        goto LABEL_11;
      }
LABEL_13:
      *v12++ = _H0;
      uint64_t v14 = (int *)((char *)v14 + v11);
      if (!--v13) {
        goto LABEL_14;
      }
    }
    int v24 = v14 + 6;
    _H0 = 0;
    do
    {
      unsigned int v26 = v15;
      __int16 v27 = *(_WORD *)(v18 + 8);
      v18 += 8;
      _H2 = v27;
      _H3 = *(_WORD *)(v18 - 6);
      v15 -= 4;
      _S4 = *(v24 - 3);
      _S5 = *(v24 - 2);
      __asm
      {
        FCVT            H4, S4
        FCVT            S3, H3
        FCVT            S1, H1
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S3 * _S1);
      LOWORD(_S1) = *(_WORD *)(v18 - 4);
      __asm
      {
        FCVT            H0, S0
        FCVT            H3, S5
      }
      LOWORD(_S5) = *(_WORD *)(v18 - 2);
      __asm
      {
        FCVT            S1, H1
        FCVT            S4, H4
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S1 * _S4);
      __asm { FCVT            H0, S0 }
      _S1 = *(v24 - 1);
      __asm
      {
        FCVT            H1, S1
        FCVT            S4, H5
        FCVT            S3, H3
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S4 * _S3);
      __asm
      {
        FCVT            H0, S0
        FCVT            S2, H2
        FCVT            S1, H1
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S2 * _S1);
      __asm { FCVT            H0, S0 }
      int v49 = *v24;
      v24 += 4;
      _S1 = v49;
      __asm { FCVT            H1, S1 }
    }
    while (v26 > 7);
    uint64_t v16 = v24 - 4;
    if (!v15) {
      goto LABEL_13;
    }
LABEL_11:
    v51 = (__int16 *)(v18 + 2);
    v52 = v16 + 1;
    do
    {
      __int16 v53 = *v51++;
      _H2 = v53;
      __asm
      {
        FCVT            S2, H2
        FCVT            S1, H1
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S2 * _S1);
      __asm { FCVT            H0, S0 }
      int v59 = *v52++;
      _S1 = v59;
      __asm { FCVT            H1, S1 }
      --v15;
    }
    while (v15);
    goto LABEL_13;
  }
  return result;
}

uint64_t resample_float16_v_Ncpp_al(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v6 = *a5 - 2;
  int v7 = *(_DWORD *)(result + 4);
  uint64_t v8 = (int *)(result + 8);
  uint64_t v9 = a3 * a4;
  unint64_t v10 = v9 & 0xFFFFFFFC;
  if ((int)v10 < 1)
  {
    LODWORD(v11) = 0;
    LOWORD(v12) = 0;
    unsigned int v14 = a3;
  }
  else
  {
    unint64_t v11 = 0;
    LOWORD(v12) = 0;
    LOWORD(v13) = COERCE_UNSIGNED_INT(1.0);
    unsigned int v14 = a3;
    do
    {
      float16x4_t v15 = 0;
      if (v7)
      {
        uint64_t v16 = a6;
        int v17 = v8;
        LODWORD(result) = v7;
        do
        {
          int v18 = *v17++;
          _S3 = v18;
          __asm { FCVT            H3, S3 }
          uint64_t v24 = *v16++;
          __asm { FCVT            S3, H3 }
          float16x4_t v15 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v15), vcvtq_f32_f16(*(float16x4_t *)(v24 + 2 * v11)), _S3));
          result = (result - 1);
        }
        while (result);
      }
      if (v12 < *(short float *)v15.i16) {
        short float v12 = *(short float *)v15.i16;
      }
      if ((v11 | 1) == v14)
      {
        __asm { FCMP            H0, #0 }
        LOWORD(v27) = 0;
        if (!_NF) {
          short float v27 = _H0;
        }
        if (_H0 > v13) {
          LOWORD(v27) = COERCE_UNSIGNED_INT(1.0);
        }
        uint64_t v28 = v14 + a3;
        v14 += a3;
        LOWORD(v12) = 0;
      }
      else
      {
        short float v27 = *(short float *)v15.i16;
        uint64_t v28 = v14;
      }
      *(short float *)(v6 + 2) = v27;
      short float v29 = *(short float *)&v15.i16[1];
      if (v12 < *(short float *)&v15.i16[1]) {
        short float v12 = *(short float *)&v15.i16[1];
      }
      if ((v11 | 2) == v28)
      {
        __asm { FCMP            H0, #0 }
        LOWORD(v29) = 0;
        if (!_NF) {
          short float v29 = _H0;
        }
        if (_H0 > v13) {
          LOWORD(v29) = COERCE_UNSIGNED_INT(1.0);
        }
        uint64_t v28 = v14 + a3;
        v14 += a3;
        LOWORD(v12) = 0;
      }
      *(short float *)(v6 + 4) = v29;
      short float v31 = *(short float *)&v15.i16[2];
      if (v12 < *(short float *)&v15.i16[2]) {
        short float v12 = *(short float *)&v15.i16[2];
      }
      if ((v11 | 3) == v28)
      {
        __asm { FCMP            H0, #0 }
        LOWORD(v31) = 0;
        if (!_NF) {
          short float v31 = _H0;
        }
        if (_H0 > v13) {
          LOWORD(v31) = COERCE_UNSIGNED_INT(1.0);
        }
        uint64_t v28 = v14 + a3;
        v14 += a3;
        LOWORD(v12) = 0;
      }
      *(short float *)(v6 + 6) = v31;
      v15.i16[0] = v15.i16[3];
      if (v12 < *(short float *)&v15.i16[3]) {
        short float v12 = *(short float *)&v15.i16[3];
      }
      v11 += 4;
      if (v11 == v28)
      {
        __asm { FCMP            H0, #0 }
        v15.i16[0] = 0;
        if (!_NF) {
          *(short float *)v15.i16 = _H0;
        }
        if (_H0 > v13) {
          v15.i16[0] = COERCE_UNSIGNED_INT(1.0);
        }
        v14 += a3;
        LOWORD(v12) = 0;
      }
      *(_WORD *)(v6 + 8) = v15.i16[0];
      v6 += 8;
    }
    while (v11 < v10);
  }
  if ((int)v11 < (int)v9)
  {
    unint64_t v11 = v11;
    do
    {
      LOWORD(_H2) = 0;
      if (v7)
      {
        v35 = a6;
        v36 = v8;
        int v37 = v7;
        do
        {
          int v38 = *v36++;
          _S3 = v38;
          __asm { FCVT            H3, S3 }
          uint64_t v40 = *v35++;
          result = v40;
          _H4 = *(_WORD *)(v40 + 2 * v11);
          __asm
          {
            FCVT            S4, H4
            FCVT            S3, H3
            FCVT            S2, H2
          }
          _S2 = _S2 + (float)(_S4 * _S3);
          __asm { FCVT            H2, S2 }
          --v37;
        }
        while (v37);
      }
      if (v12 < _H2) {
        short float v12 = _H2;
      }
      if (++v11 == v14)
      {
        __asm { FCMP            H0, #0 }
        LOWORD(_H2) = 0;
        if (!_NF) {
          _H2 = _H0;
        }
        if (_H0 > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
          LOWORD(_H2) = COERCE_UNSIGNED_INT(1.0);
        }
        v14 += a3;
        LOWORD(v12) = 0;
      }
      *(short float *)(v6 + 2) = _H2;
      v6 += 2;
    }
    while (v11 != v9);
  }
  return result;
}

uint64_t resample_float16_v_3cpp_al(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, uint64_t *a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *(_DWORD *)(result + 4);
    uint64_t v9 = *a5;
    do
    {
      float16x4_t v10 = 0;
      if (v8)
      {
        unint64_t v11 = a6;
        short float v12 = (int *)(result + 8);
        int v13 = v8;
        do
        {
          int v14 = *v12++;
          _S3 = v14;
          __asm { FCVT            H3, S3 }
          uint64_t v20 = *v11++;
          __asm { FCVT            S3, H3 }
          float16x4_t v10 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v10), vcvtq_f32_f16(*(float16x4_t *)(v20 + 2 * v7)), _S3));
          --v13;
        }
        while (v13);
      }
      *(_DWORD *)uint64_t v9 = v10.i32[0];
      *(_WORD *)(v9 + 4) = v10.i16[2];
      __asm { FCMP            H3, #0 }
      if (_NF) {
        short float v23 = COERCE_SHORT_FLOAT(0);
      }
      else {
        short float v23 = _H3;
      }
      if (_H3 > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
        LOWORD(v23) = COERCE_UNSIGNED_INT(1.0);
      }
      *(short float *)(v9 + 6) = v23;
      v9 += 8;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t resample_float16_v_Ncpp_af(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  unint64_t v6 = (short float *)(*a5 - 2);
  int v7 = *(_DWORD *)(result + 4);
  int v8 = (int *)(result + 8);
  int v9 = a3;
  uint64_t v10 = 2 - a3;
  uint64_t v11 = a3 * a4;
  unint64_t v12 = v11 & 0xFFFFFFFC;
  if ((int)v12 < 1)
  {
    LODWORD(v13) = 0;
    LOWORD(v14) = 0;
    unsigned int v16 = a3;
  }
  else
  {
    unint64_t v13 = 0;
    LOWORD(v14) = 0;
    LOWORD(v15) = COERCE_UNSIGNED_INT(1.0);
    unsigned int v16 = a3;
    do
    {
      float16x4_t v17 = 0;
      if (v7)
      {
        int v18 = a6;
        int v19 = v8;
        int v20 = v7;
        do
        {
          int v21 = *v19++;
          _S3 = v21;
          __asm { FCVT            H3, S3 }
          uint64_t v27 = *v18++;
          __asm { FCVT            S3, H3 }
          float16x4_t v17 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v17), vcvtq_f32_f16(*(float16x4_t *)(v27 + 2 * v13)), _S3));
          --v20;
        }
        while (v20);
      }
      if (v14 >= *(short float *)v17.i16) {
        short float v29 = v14;
      }
      else {
        short float v29 = *(short float *)v17.i16;
      }
      if ((v13 | 1) == v16)
      {
        __asm { FCMP            H3, #0 }
        LOWORD(v31) = 0;
        if (!_NF) {
          short float v31 = _H3;
        }
        if (_H3 > v15) {
          LOWORD(v31) = COERCE_UNSIGNED_INT(1.0);
        }
        v6[(int)v10] = v31;
        result = v16 + v9;
        v16 += v9;
        LOWORD(v29) = 0;
      }
      else
      {
        result = v16;
      }
      v6[1] = *(short float *)v17.i16;
      if (v29 < *(short float *)&v17.i16[1]) {
        short float v29 = *(short float *)&v17.i16[1];
      }
      if ((v13 | 2) == result)
      {
        __asm { FCMP            H3, #0 }
        LOWORD(v33) = 0;
        if (!_NF) {
          short float v33 = _H3;
        }
        if (_H3 <= v15) {
          short float v34 = v33;
        }
        else {
          LOWORD(v34) = COERCE_UNSIGNED_INT(1.0);
        }
        v6[(int)v10 + 1] = v34;
        result = v16 + v9;
        v16 += v9;
        LOWORD(v29) = 0;
      }
      v6[2] = *(short float *)&v17.i16[1];
      if (v29 < *(short float *)&v17.i16[2]) {
        short float v29 = *(short float *)&v17.i16[2];
      }
      if ((v13 | 3) == result)
      {
        __asm { FCMP            H3, #0 }
        LOWORD(v36) = 0;
        if (!_NF) {
          short float v36 = _H3;
        }
        if (_H3 <= v15) {
          short float v37 = v36;
        }
        else {
          LOWORD(v37) = COERCE_UNSIGNED_INT(1.0);
        }
        v6[(int)v10 + 2] = v37;
        result = v16 + v9;
        v16 += v9;
        LOWORD(v29) = 0;
      }
      v6[3] = *(short float *)&v17.i16[2];
      if (v29 >= *(short float *)&v17.i16[3]) {
        short float v14 = v29;
      }
      else {
        short float v14 = *(short float *)&v17.i16[3];
      }
      v13 += 4;
      if (v13 == result)
      {
        __asm { FCMP            H0, #0 }
        LOWORD(v39) = 0;
        if (!_NF) {
          short float v39 = _H0;
        }
        if (_H0 <= v15) {
          short float v40 = v39;
        }
        else {
          LOWORD(v40) = COERCE_UNSIGNED_INT(1.0);
        }
        v6[(int)v10 + 3] = v40;
        v16 += v9;
        LOWORD(v14) = 0;
      }
      v6[4] = *(short float *)&v17.i16[3];
      v6 += 4;
    }
    while (v13 < v12);
  }
  if ((int)v13 < (int)v11)
  {
    unint64_t v13 = v13;
    do
    {
      LOWORD(_H2) = 0;
      if (v7)
      {
        v42 = a6;
        v43 = v8;
        LODWORD(result) = v7;
        do
        {
          int v44 = *v43++;
          _S3 = v44;
          __asm { FCVT            H3, S3 }
          uint64_t v46 = *v42++;
          _H4 = *(_WORD *)(v46 + 2 * v13);
          __asm
          {
            FCVT            S4, H4
            FCVT            S3, H3
            FCVT            S2, H2
          }
          _S2 = _S2 + (float)(_S4 * _S3);
          __asm { FCVT            H2, S2 }
          result = (result - 1);
        }
        while (result);
      }
      if (v14 < _H2) {
        short float v14 = _H2;
      }
      if (++v13 == v16)
      {
        __asm { FCMP            H0, #0 }
        LOWORD(v53) = 0;
        if (!_NF) {
          short float v53 = _H0;
        }
        if (_H0 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
          short float v54 = v53;
        }
        else {
          LOWORD(v54) = COERCE_UNSIGNED_INT(1.0);
        }
        v6[v10] = v54;
        v16 += v9;
        LOWORD(v14) = 0;
      }
      v6[1] = _H2;
      ++v6;
    }
    while (v13 != v11);
  }
  return result;
}

uint64_t resample_float16_v_3cpp_af(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, uint64_t *a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *(_DWORD *)(result + 4);
    uint64_t v9 = *a5;
    do
    {
      float16x4_t v10 = 0;
      if (v8)
      {
        uint64_t v11 = a6;
        unint64_t v12 = (int *)(result + 8);
        int v13 = v8;
        do
        {
          int v14 = *v12++;
          _S3 = v14;
          __asm { FCVT            H3, S3 }
          uint64_t v20 = *v11++;
          __asm { FCVT            S3, H3 }
          float16x4_t v10 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v10), vcvtq_f32_f16(*(float16x4_t *)(v20 + 2 * v7)), _S3));
          --v13;
        }
        while (v13);
      }
      __asm { FCMP            H3, #0 }
      if (_NF) {
        short float v23 = COERCE_SHORT_FLOAT(0);
      }
      else {
        short float v23 = _H3;
      }
      if (_H3 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
        short float v24 = v23;
      }
      else {
        LOWORD(v24) = COERCE_UNSIGNED_INT(1.0);
      }
      *(short float *)uint64_t v9 = v24;
      *(_WORD *)(v9 + 2) = v10.i16[1];
      *(_DWORD *)(v9 + 4) = v10.i32[1];
      v9 += 8;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t resample_float16_v_Ncpp(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float16x4_t **a5, uint64_t *a6)
{
  unint64_t v6 = *a5;
  int v7 = *(_DWORD *)(result + 4);
  int v8 = (int *)(result + 8);
  uint64_t v9 = a3 * a4;
  unint64_t v10 = v9 & 0xFFFFFFFC;
  if ((int)v10 < 1)
  {
    LODWORD(i) = 0;
  }
  else
  {
    for (unint64_t i = 0; i < v10; i += 4)
    {
      float16x4_t v12 = 0;
      if (v7)
      {
        int v13 = a6;
        int v14 = v8;
        int v15 = v7;
        do
        {
          int v16 = *v14++;
          _S1 = v16;
          __asm { FCVT            H1, S1 }
          uint64_t v22 = *v13++;
          result = 2 * i;
          __asm { FCVT            S1, H1 }
          float16x4_t v12 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v12), vcvtq_f32_f16(*(float16x4_t *)(v22 + 2 * i)), _S1));
          --v15;
        }
        while (v15);
      }
      *v6++ = v12;
    }
  }
  if ((int)i < (int)v9)
  {
    unint64_t i = i;
    do
    {
      _H0 = 0;
      if (v7)
      {
        v25 = a6;
        unsigned int v26 = v8;
        int v27 = v7;
        do
        {
          int v28 = *v26++;
          _S1 = v28;
          __asm { FCVT            H1, S1 }
          uint64_t v30 = *v25++;
          _H2 = *(_WORD *)(v30 + 2 * i);
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
            FCVT            S0, H0
          }
          _S0 = _S0 + (float)(_S2 * _S1);
          __asm { FCVT            H0, S0 }
          --v27;
        }
        while (v27);
      }
      v6->i16[0] = _H0;
      unint64_t v6 = (float16x4_t *)((char *)v6 + 2);
      ++i;
    }
    while (i != v9);
  }
  return result;
}

int *resample_float16_h_Ncpp_ap(int *result, unsigned int a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    unsigned int v9 = a3;
    int v10 = a3 - 1;
    uint64_t v11 = *a6;
    uint64_t v12 = a6[1];
    uint64_t v13 = *a7;
    uint64_t v14 = a7[1];
    uint64_t v15 = a8;
    uint64_t v16 = 2 * a3 - 2;
    do
    {
      if (a4)
      {
        float16x4_t v17 = *(_WORD **)(a5 + 8 * v8);
        int v18 = a4;
        int v19 = result;
        do
        {
          int v21 = *v19;
          int v20 = v19[1];
          uint64_t v22 = v19 + 2;
          if (v9 >= 2)
          {
            int v23 = 0;
            do
            {
              _H0 = 0;
              if (v20)
              {
                v25 = (__int16 *)(v11 + v8 * v13 + 2 * v21 * v10);
                unsigned int v26 = v19 + 2;
                int v27 = v20;
                do
                {
                  int v28 = *v26++;
                  _S1 = v28;
                  __asm { FCVT            H1, S1 }
                  _H2 = *v25;
                  __asm
                  {
                    FCVT            S2, H2
                    FCVT            S1, H1
                    FCVT            S0, H0
                  }
                  _S0 = _S0 + (float)(_S2 * _S1);
                  __asm { FCVT            H0, S0 }
                  v25 = (__int16 *)((char *)v25 + v16);
                  --v27;
                }
                while (v27);
              }
              *v17++ = _H0;
              ++v23;
            }
            while (v23 != v10);
          }
          if (v20)
          {
            short float v39 = (_WORD *)(v12 + v8 * v14 + 2 + 2 * (v21 - 1));
            _H0 = 0;
            do
            {
              int v41 = *v22++;
              _S1 = v41;
              __asm { FCVT            H1, S1 }
              LOWORD(v41) = *v39++;
              _H2 = v41;
              __asm
              {
                FCVT            S2, H2
                FCVT            S1, H1
                FCVT            S0, H0
              }
              _S0 = _S0 + (float)(_S2 * _S1);
              __asm { FCVT            H0, S0 }
              --v20;
            }
            while (v20);
          }
          else
          {
            _H0 = 0;
          }
          *v17++ = _H0;
          v19 += a2 + 2;
          --v18;
        }
        while (v18);
      }
      ++v8;
    }
    while (v8 != v15);
  }
  return result;
}

int *resample_float16_h_4cpp_ap(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    do
    {
      if (a4)
      {
        uint64_t v15 = *(float16x4_t **)(a5 + 8 * v8);
        int v16 = a4;
        float16x4_t v17 = result;
        do
        {
          int v18 = v17[1];
          if (v18)
          {
            int v19 = v17 + 2;
            uint64_t v20 = *v17;
            int v21 = (float16x4_t *)(v9 + v8 * v11 + 8 * v20);
            uint64_t v22 = (_WORD *)(v10 + v8 * v12 + 2 * v20);
            float16x4_t v23 = 0;
            _H0 = 0;
            do
            {
              int v25 = *v19++;
              _S2 = v25;
              __asm
              {
                FCVT            H2, S2
                FCVT            S2, H2
              }
              LOWORD(v25) = *v22++;
              _H3 = v25;
              float16x4_t v33 = *v21++;
              float16x4_t v23 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v23), vcvtq_f32_f16(v33), _S2));
              __asm
              {
                FCVT            S3, H3
                FCVT            S0, H0
              }
              _S0 = _S0 + (float)(_S3 * _S2);
              __asm { FCVT            H0, S0 }
              --v18;
            }
            while (v18);
          }
          else
          {
            float16x4_t v23 = 0;
            _H0 = 0;
          }
          *uint64_t v15 = v23;
          v15[1].i16[0] = _H0;
          uint64_t v15 = (float16x4_t *)((char *)v15 + 10);
          float16x4_t v17 = (int *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

_DWORD *resample_float16_h_3cpp_ap(_DWORD *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    do
    {
      if (a4)
      {
        uint64_t v15 = *(float16x4_t **)(a5 + 8 * v8);
        int v16 = a4;
        float16x4_t v17 = result;
        do
        {
          int v18 = v17[1];
          if (v18)
          {
            int v19 = v17 + 2;
            uint64_t v20 = v9 + v8 * v11 + 6 * *v17;
            int v21 = (__int16 *)(v10 + v8 * v12 + 2 + 2 * (*v17 - 1));
            float16x4_t v22 = 0;
            do
            {
              int v23 = *v19++;
              _S1 = v23;
              __asm { FCVT            H1, S1 }
              v29.i32[0] = *(_DWORD *)v20;
              __asm { FCVT            S1, H1 }
              v29.i16[2] = *(_WORD *)(v20 + 4);
              v29.i16[3] = *v21++;
              float16x4_t v22 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v22), vcvtq_f32_f16(v29), _S1));
              v20 += 6;
              --v18;
            }
            while (v18);
          }
          else
          {
            float16x4_t v22 = 0;
          }
          *v15++ = v22;
          float16x4_t v17 = (_DWORD *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

int *resample_float16_h_1cpp_ap(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == v14) {
        return result;
      }
    }
    uint64_t v15 = *(_WORD **)(a5 + 8 * v8);
    int v16 = a4;
    float16x4_t v17 = result;
    while (1)
    {
      int v18 = v17[1];
      int v19 = v17 + 2;
      _S0 = v17[2];
      uint64_t v21 = *v17 - 1;
      __asm { FCVT            H2, S0 }
      if (v18 >= 2) {
        break;
      }
      uint64_t v54 = v9 + v8 * v11 + 2 * v21;
      _H0 = 0;
      _H1 = 0;
      uint64_t v53 = v10 + v8 * v12 + 2 * v21;
      if (v18) {
        goto LABEL_11;
      }
LABEL_13:
      *uint64_t v15 = _H0;
      v15[1] = _H1;
      v15 += 2;
      float16x4_t v17 = (int *)((char *)v17 + v13);
      if (!--v16) {
        goto LABEL_14;
      }
    }
    uint64_t v27 = 2 * v21;
    _H1 = 0;
    uint64_t v29 = v9 + v8 * v11;
    uint64_t v30 = v10 + v8 * v12;
    _H0 = 0;
    do
    {
      unsigned int v32 = v18;
      _H3 = *(_WORD *)(v29 + v27 + 2);
      _H4 = *(_WORD *)(v30 + v27 + 2);
      v18 -= 2;
      __asm
      {
        FCVT            S3, H3
        FCVT            S2, H2
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S3 * _S2);
      __asm { FCVT            H0, S0 }
      LOWORD(_S3) = *(_WORD *)(v29 + v27 + 4);
      __asm
      {
        FCVT            S4, H4
        FCVT            S1, H1
      }
      _S1 = _S1 + (float)(_S4 * _S2);
      __asm { FCVT            H1, S1 }
      int v42 = v19[2];
      v19 += 2;
      _S2 = v42;
      _S4 = *(v19 - 1);
      __asm { FCVT            H4, S4 }
      _H5 = *(_WORD *)(v30 + v27 + 4);
      __asm
      {
        FCVT            S3, H3
        FCVT            S4, H4
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S3 * _S4);
      __asm
      {
        FCVT            H0, S0
        FCVT            S3, H5
        FCVT            S1, H1
      }
      _S1 = _S1 + (float)(_S3 * _S4);
      __asm
      {
        FCVT            H1, S1
        FCVT            H2, S2
      }
      v30 += 4;
      v29 += 4;
    }
    while (v32 > 3);
    uint64_t v53 = v30 + 2 * v21;
    uint64_t v54 = v29 + 2 * v21;
    if (!v18) {
      goto LABEL_13;
    }
LABEL_11:
    v55 = (__int16 *)(v53 + 2);
    v56 = (__int16 *)(v54 + 2);
    v57 = v19 + 1;
    do
    {
      __int16 v58 = *v56++;
      _H3 = v58;
      __int16 v60 = *v55++;
      _H4 = v60;
      __asm
      {
        FCVT            S3, H3
        FCVT            S2, H2
        FCVT            S0, H0
      }
      _S0 = _S0 + (float)(_S3 * _S2);
      __asm
      {
        FCVT            H0, S0
        FCVT            S3, H4
        FCVT            S1, H1
      }
      _S1 = _S1 + (float)(_S3 * _S2);
      __asm { FCVT            H1, S1 }
      int v69 = *v57++;
      _S2 = v69;
      __asm { FCVT            H2, S2 }
      --v18;
    }
    while (v18);
    goto LABEL_13;
  }
  return result;
}

uint64_t resample_float16_v_Ncpp_ap(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v6 = *a5 - 2;
  uint64_t v7 = a5[1] - 2;
  int v8 = *(_DWORD *)(result + 4);
  uint64_t v9 = (int *)(result + 8);
  uint64_t v10 = a3 * a4;
  unint64_t v11 = v10 & 0xFFFFFFFC;
  if ((int)v11 < 1)
  {
    LODWORD(v12) = 0;
    LOWORD(v13) = 0;
    unsigned int v15 = a3;
  }
  else
  {
    unint64_t v12 = 0;
    LOWORD(v13) = 0;
    LOWORD(v14) = COERCE_UNSIGNED_INT(1.0);
    unsigned int v15 = a3;
    do
    {
      float16x4_t v16 = 0;
      if (v8)
      {
        float16x4_t v17 = a6;
        int v18 = v9;
        int v19 = v8;
        do
        {
          int v20 = *v18++;
          _S3 = v20;
          __asm { FCVT            H3, S3 }
          uint64_t v26 = *v17++;
          __asm { FCVT            S3, H3 }
          float16x4_t v16 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v16), vcvtq_f32_f16(*(float16x4_t *)(v26 + 2 * v12)), _S3));
          --v19;
        }
        while (v19);
      }
      if (v13 < *(short float *)v16.i16) {
        short float v13 = *(short float *)v16.i16;
      }
      if ((v12 | 1) == v15)
      {
        __asm { FCMP            H1, #0 }
        LOWORD(v29) = 0;
        if (!_NF) {
          short float v29 = _H1;
        }
        if (_H1 <= v14) {
          short float v30 = v29;
        }
        else {
          LOWORD(v30) = COERCE_UNSIGNED_INT(1.0);
        }
        *(short float *)(v7 + 2) = v30;
        v7 += 2;
        uint64_t v31 = v15 + a3;
        v15 += a3;
        LOWORD(v13) = 0;
      }
      else
      {
        uint64_t v31 = v15;
        *(_WORD *)(v6 + 2) = v16.i16[0];
        v6 += 2;
      }
      if (v13 < *(short float *)&v16.i16[1]) {
        short float v13 = *(short float *)&v16.i16[1];
      }
      if ((v12 | 2) == v31)
      {
        __asm { FCMP            H1, #0 }
        LOWORD(v33) = 0;
        if (!_NF) {
          short float v33 = _H1;
        }
        if (_H1 <= v14) {
          short float v34 = v33;
        }
        else {
          LOWORD(v34) = COERCE_UNSIGNED_INT(1.0);
        }
        *(short float *)(v7 + 2) = v34;
        v7 += 2;
        uint64_t v31 = v15 + a3;
        v15 += a3;
        LOWORD(v13) = 0;
      }
      else
      {
        *(_WORD *)(v6 + 2) = v16.i16[1];
        v6 += 2;
      }
      if (v13 < *(short float *)&v16.i16[2]) {
        short float v13 = *(short float *)&v16.i16[2];
      }
      result = v12 | 3;
      if ((v12 | 3) == v31)
      {
        __asm { FCMP            H1, #0 }
        LOWORD(v36) = 0;
        if (!_NF) {
          short float v36 = _H1;
        }
        if (_H1 <= v14) {
          short float v37 = v36;
        }
        else {
          LOWORD(v37) = COERCE_UNSIGNED_INT(1.0);
        }
        *(short float *)(v7 + 2) = v37;
        v7 += 2;
        uint64_t v31 = v15 + a3;
        v15 += a3;
        LOWORD(v13) = 0;
      }
      else
      {
        *(_WORD *)(v6 + 2) = v16.i16[2];
        v6 += 2;
      }
      if (v13 < *(short float *)&v16.i16[3]) {
        short float v13 = *(short float *)&v16.i16[3];
      }
      v12 += 4;
      if (v12 == v31)
      {
        __asm { FCMP            H1, #0 }
        LOWORD(v39) = 0;
        if (!_NF) {
          short float v39 = _H1;
        }
        if (_H1 <= v14) {
          short float v40 = v39;
        }
        else {
          LOWORD(v40) = COERCE_UNSIGNED_INT(1.0);
        }
        *(short float *)(v7 + 2) = v40;
        v7 += 2;
        v15 += a3;
        LOWORD(v13) = 0;
      }
      else
      {
        *(_WORD *)(v6 + 2) = v16.i16[3];
        v6 += 2;
      }
    }
    while (v12 < v11);
  }
  if ((int)v12 < (int)v10)
  {
    unint64_t v12 = v12;
    do
    {
      LOWORD(_H2) = 0;
      if (v8)
      {
        int v42 = a6;
        v43 = v9;
        LODWORD(result) = v8;
        do
        {
          int v44 = *v43++;
          _S3 = v44;
          __asm { FCVT            H3, S3 }
          uint64_t v46 = *v42++;
          _H4 = *(_WORD *)(v46 + 2 * v12);
          __asm
          {
            FCVT            S4, H4
            FCVT            S3, H3
            FCVT            S2, H2
          }
          _S2 = _S2 + (float)(_S4 * _S3);
          __asm { FCVT            H2, S2 }
          result = (result - 1);
        }
        while (result);
      }
      if (v13 < _H2) {
        short float v13 = _H2;
      }
      if (++v12 == v15)
      {
        __asm { FCMP            H1, #0 }
        LOWORD(v53) = 0;
        if (!_NF) {
          short float v53 = _H1;
        }
        if (_H1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
          short float v54 = v53;
        }
        else {
          LOWORD(v54) = COERCE_UNSIGNED_INT(1.0);
        }
        *(short float *)(v7 + 2) = v54;
        v7 += 2;
        v15 += a3;
        LOWORD(v13) = 0;
      }
      else
      {
        *(short float *)(v6 + 2) = _H2;
        v6 += 2;
      }
    }
    while (v12 != v10);
  }
  return result;
}

uint64_t resample_float16_v_3cpp_ap(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, uint64_t *a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *(_DWORD *)(result + 4);
    uint64_t v9 = (int *)(result + 8);
    uint64_t v11 = *a5;
    uint64_t v10 = (short float *)a5[1];
    do
    {
      float16x4_t v12 = 0;
      if (v8)
      {
        short float v13 = a6;
        short float v14 = v9;
        int v15 = v8;
        do
        {
          int v16 = *v14++;
          _S3 = v16;
          __asm { FCVT            H3, S3 }
          uint64_t v22 = *v13++;
          result = 2 * v7;
          __asm { FCVT            S3, H3 }
          float16x4_t v12 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(v12), vcvtq_f32_f16(*(float16x4_t *)(v22 + 2 * v7)), _S3));
          --v15;
        }
        while (v15);
      }
      *(_DWORD *)uint64_t v11 = v12.i32[0];
      *(_WORD *)(v11 + 4) = v12.i16[2];
      v11 += 6;
      __asm { FCMP            H3, #0 }
      if (_NF) {
        short float v25 = COERCE_SHORT_FLOAT(0);
      }
      else {
        short float v25 = _H3;
      }
      if (_H3 > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
        LOWORD(v25) = COERCE_UNSIGNED_INT(1.0);
      }
      *v10++ = v25;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

const void *__resample_float16_select_block_invoke()
{
  BOOL v1 = 1;
  result = get_BOOLean_property("USE_FP16_EXPANDED_FUNCTIONS", (const void *(*)(const char *))copy_local_domain_value, &v1);
  if (v1)
  {
    resample_float16_select_float16_v_3cpp_ap[0] = (uint64_t (*)())resample_float16_v_3cpp_ap_expanded;
    resample_float16_select_float16_v_Ncpp_ap = (uint64_t (*)())resample_float16_v_Ncpp_ap_expanded;
    resample_float16_select_float16_h_1cpp_ap[0] = (uint64_t (*)())resample_float16_h_1cpp_ap_expanded;
    resample_float16_select_float16_h_3cpp_ap[0] = (uint64_t (*)())resample_float16_h_3cpp_ap_expanded;
    resample_float16_select_float16_h_4cpp_ap[0] = (uint64_t (*)())resample_float16_h_4cpp_ap_expanded;
    resample_float16_select_float16_h_Ncpp_ap[0] = (uint64_t (*)())resample_float16_h_Ncpp_ap_expanded;
    resample_float16_select_float16_v_3cpp_af[0] = (uint64_t (*)())resample_float16_v_3cpp_af_expanded;
    resample_float16_select_float16_v_Ncpp_af[0] = (uint64_t (*)())resample_float16_v_Ncpp_af_expanded;
    resample_float16_select_float16_v_3cpp_al[0] = (uint64_t (*)())resample_float16_v_3cpp_al_expanded;
    resample_float16_select_float16_v_Ncpp_al[0] = (uint64_t (*)())resample_float16_v_Ncpp_al_expanded;
    resample_float16_select_float16_h_1cpp[0] = (uint64_t (*)())resample_float16_h_1cpp_expanded;
    resample_float16_select_float16_h_3cpp[0] = (uint64_t (*)())resample_float16_h_3cpp_expanded;
    resample_float16_select_float16_h_4cpp[0] = (uint64_t (*)())resample_float16_h_4cpp_expanded;
    resample_float16_select_float16_h_Ncpp[0] = (uint64_t (*)())resample_float16_h_Ncpp_expanded;
  }
  return result;
}

_DWORD *resample_float16_h_Ncpp_expanded(_DWORD *result, unsigned int a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a3;
    uint64_t v10 = *a6;
    uint64_t v11 = *a7;
    uint64_t v12 = 4 * a2 + 8;
    uint64_t v13 = a8;
    do
    {
      if (a4)
      {
        short float v14 = *(_WORD **)(a5 + 8 * v8);
        int v15 = a4;
        int v16 = result;
        do
        {
          if (v9)
          {
            uint64_t v17 = 0;
            int v18 = v16[1];
            uint64_t v19 = v10 + v8 * v11 + 2 * *v16 * (int)v9;
            do
            {
              _S0 = 0.0;
              if (v18)
              {
                uint64_t v21 = (__int16 *)v19;
                uint64_t v22 = (float *)(v16 + 2);
                int v23 = v18;
                do
                {
                  float v24 = *v22++;
                  _H2 = *v21;
                  __asm { FCVT            S2, H2 }
                  _S0 = _S0 + (float)(_S2 * v24);
                  v21 += v9;
                  --v23;
                }
                while (v23);
              }
              __asm { FCVT            H0, S0 }
              *v14++ = _H0;
              ++v17;
              v19 += 2;
            }
            while (v17 != v9);
          }
          int v16 = (_DWORD *)((char *)v16 + v12);
          --v15;
        }
        while (v15);
      }
      ++v8;
    }
    while (v8 != v13);
  }
  return result;
}

int *resample_float16_h_4cpp_expanded(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, void *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 4 * a2 + 8;
    do
    {
      if (a4)
      {
        uint64_t v10 = *a6 + *a7 * (uint64_t)(int)v8;
        uint64_t v11 = *(float16x4_t **)(a5 + 8 * v8);
        int v12 = a4;
        uint64_t v13 = result;
        do
        {
          int v14 = v13[1];
          int v15 = (float *)(v13 + 2);
          int v16 = (float16x4_t *)(v10 + 8 * *v13);
          float32x4_t v17 = 0uLL;
          if (v14 >= 2)
          {
            float32x4_t v18 = 0uLL;
            do
            {
              unsigned int v19 = v14;
              float32x2_t v20 = *(float32x2_t *)v15;
              v15 += 2;
              float32x2_t v21 = v20;
              float16x8_t v22 = *(float16x8_t *)v16->i8;
              v16 += 2;
              float32x4_t v18 = vaddq_f32(v18, vmulq_lane_f32(vcvt_hight_f32_f16(v22), v21, 1));
              float32x4_t v17 = vaddq_f32(v17, vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v22.i8), v21.f32[0]));
              v14 -= 2;
            }
            while (v19 > 3);
            float32x4_t v17 = vaddq_f32(v18, v17);
          }
          if (v14) {
            float32x4_t v17 = vaddq_f32(v17, vmulq_n_f32(vcvtq_f32_f16(*v16), *v15));
          }
          *v11++ = vcvt_f16_f32(v17);
          uint64_t v13 = (int *)((char *)v13 + v9);
          --v12;
        }
        while (v12);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

int *resample_float16_h_3cpp_expanded(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = *a7;
    uint64_t v11 = 4 * a2 + 8;
    do
    {
      if (a4)
      {
        int v12 = *(_WORD **)(a5 + 8 * v8);
        int v13 = a4;
        int v14 = result;
        do
        {
          int v15 = v14[1];
          if (v15)
          {
            int v16 = (float *)(v14 + 2);
            float32x4_t v17 = (__int16 *)(v9 + v8 * v10 + 6 * *v14);
            _S0 = 0.0;
            _S1 = 0.0;
            _S2 = 0.0;
            do
            {
              float v21 = *v16++;
              _H4 = *v17;
              __asm { FCVT            S4, H4 }
              _H5 = v17[1];
              __asm { FCVT            S5, H5 }
              _S2 = _S2 + (float)(_S4 * v21);
              LOWORD(_S4) = v17[2];
              __asm { FCVT            S4, H4 }
              _S1 = _S1 + (float)(_S5 * v21);
              _S0 = _S0 + (float)(_S4 * v21);
              v17 += 3;
              --v15;
            }
            while (v15);
          }
          else
          {
            _S2 = 0.0;
            _S1 = 0.0;
            _S0 = 0.0;
          }
          __asm { FCVT            H2, S2 }
          *int v12 = _H2;
          __asm { FCVT            H1, S1 }
          v12[1] = _H1;
          __asm { FCVT            H0, S0 }
          v12[2] = _H0;
          v12 += 3;
          int v14 = (int *)((char *)v14 + v11);
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

int *resample_float16_h_1cpp_expanded(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = *a7;
    uint64_t v11 = 4 * a2 + 8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == a8) {
        return result;
      }
    }
    int v12 = *(_WORD **)(a5 + 8 * v8);
    int v13 = a4;
    int v14 = result;
    while (1)
    {
      int v15 = v14[1];
      int v16 = v14 + 2;
      float v17 = *((float *)v14 + 2);
      uint64_t v18 = v9 + v8 * v10 + 2 * *v14 - 2;
      if (v15 >= 4) {
        break;
      }
      _S1 = 0.0;
      if (v15) {
        goto LABEL_11;
      }
LABEL_13:
      __asm { FCVT            H0, S1 }
      *v12++ = _H0;
      int v14 = (int *)((char *)v14 + v11);
      if (!--v13) {
        goto LABEL_14;
      }
    }
    unsigned int v19 = (float *)(v14 + 6);
    _S1 = 0.0;
    do
    {
      unsigned int v21 = v15;
      __int16 v22 = *(_WORD *)(v18 + 8);
      v18 += 8;
      _H2 = v22;
      _H3 = *(_WORD *)(v18 - 6);
      __asm { FCVT            S3, H3 }
      v15 -= 4;
      _H4 = *(_WORD *)(v18 - 4);
      __asm { FCVT            S4, H4 }
      _H5 = *(_WORD *)(v18 - 2);
      __asm
      {
        FCVT            S5, H5
        FCVT            S2, H2
      }
      _S1 = (float)((float)((float)(_S1 + (float)(_S3 * v17)) + (float)(_S4 * *(v19 - 3))) + (float)(_S5 * *(v19 - 2)))
          + (float)(_S2 * *(v19 - 1));
      float v35 = *v19;
      v19 += 4;
      float v17 = v35;
    }
    while (v21 > 7);
    int v16 = (int *)(v19 - 4);
    if (!v15) {
      goto LABEL_13;
    }
LABEL_11:
    short float v36 = (__int16 *)(v18 + 2);
    short float v37 = (float *)(v16 + 1);
    do
    {
      __int16 v38 = *v36++;
      _H2 = v38;
      __asm { FCVT            S2, H2 }
      _S1 = _S1 + (float)(_S2 * v17);
      float v41 = *v37++;
      float v17 = v41;
      --v15;
    }
    while (v15);
    goto LABEL_13;
  }
  return result;
}

uint64_t resample_float16_v_Ncpp_al_expanded(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v6 = *a5 - 2;
  int v7 = *(_DWORD *)(result + 4);
  uint64_t v8 = (float *)(result + 8);
  uint64_t v9 = a3 * a4;
  unint64_t v10 = v9 & 0xFFFFFFFC;
  if ((int)v10 < 1)
  {
    LODWORD(v11) = 0;
    float v12 = 0.0;
    int v13 = a3;
  }
  else
  {
    unint64_t v11 = 0;
    float v12 = 0.0;
    int v13 = a3;
    do
    {
      _Q3 = 0uLL;
      if (v7)
      {
        int v15 = a6;
        int v16 = v8;
        int v17 = v7;
        do
        {
          float v18 = *v16++;
          float v19 = v18;
          uint64_t v20 = *v15++;
          _Q3 = vmlaq_n_f32(_Q3, vcvtq_f32_f16(*(float16x4_t *)(v20 + 2 * v11)), v19);
          --v17;
        }
        while (v17);
      }
      uint64_t v21 = v11 | 1;
      uint64_t v22 = v11 | 2;
      result = v11 | 3;
      if (v12 < _Q3.f32[0]) {
        float v12 = _Q3.f32[0];
      }
      if (v12 < 1.0) {
        _S4 = v12;
      }
      else {
        _S4 = 1.0;
      }
      _ZF = v21 == v13;
      if (v21 == v13) {
        int v25 = a3;
      }
      else {
        int v25 = 0;
      }
      uint64_t v26 = (v25 + v13);
      if (_ZF) {
        float v12 = 0.0;
      }
      else {
        _S4 = _Q3.f32[0];
      }
      __asm { FCVT            H4, S4 }
      _S5 = _Q3.f32[1];
      if (v12 < _Q3.f32[1]) {
        float v12 = _Q3.f32[1];
      }
      if (v12 < 1.0) {
        float v32 = v12;
      }
      else {
        float v32 = 1.0;
      }
      BOOL v33 = v22 == v26;
      if (v22 == v26) {
        int v34 = a3;
      }
      else {
        int v34 = 0;
      }
      uint64_t v35 = (v34 + v26);
      if (v33)
      {
        float v12 = 0.0;
        _S5 = v32;
      }
      _S6 = _Q3.f32[2];
      if (v12 < _Q3.f32[2]) {
        float v12 = _Q3.f32[2];
      }
      if (v12 < 1.0) {
        float v37 = v12;
      }
      else {
        float v37 = 1.0;
      }
      BOOL v38 = result == v35;
      if (result == v35) {
        int v39 = a3;
      }
      else {
        int v39 = 0;
      }
      uint64_t v40 = (v39 + v35);
      if (v38)
      {
        float v12 = 0.0;
        _S6 = v37;
      }
      _Q3.i32[0] = _Q3.i32[3];
      if (v12 < _Q3.f32[3]) {
        float v12 = _Q3.f32[3];
      }
      v11 += 4;
      if (v12 < 1.0) {
        float v41 = v12;
      }
      else {
        float v41 = 1.0;
      }
      if (v11 == v40) {
        _Q3.f32[0] = v41;
      }
      __asm { FCVT            H3, S3 }
      *(_WORD *)(v6 + 8) = _H3;
      v6 += 8;
      *(_WORD *)(v6 - 6) = _H4;
      __asm { FCVT            H3, S5 }
      *(_WORD *)(v6 - 4) = _H3;
      __asm { FCVT            H3, S6 }
      *(_WORD *)(v6 - 2) = _H3;
      if (_ZF) {
        int v46 = a3;
      }
      else {
        int v46 = 0;
      }
      int v13 = v46 + v40;
      if (_ZF) {
        float v12 = 0.0;
      }
    }
    while (v11 < v10);
  }
  if ((int)v11 < (int)v9)
  {
    unint64_t v11 = v11;
    do
    {
      _S3 = 0.0;
      if (v7)
      {
        v48 = a6;
        int v49 = v8;
        int v50 = v7;
        do
        {
          float v51 = *v49++;
          float v52 = v51;
          uint64_t v53 = *v48++;
          result = v53;
          _H5 = *(_WORD *)(v53 + 2 * v11);
          __asm { FCVT            S5, H5 }
          _S3 = _S3 + (float)(_S5 * v52);
          --v50;
        }
        while (v50);
      }
      if (v12 < _S3) {
        float v12 = _S3;
      }
      ++v11;
      if (v12 < 1.0) {
        float v56 = v12;
      }
      else {
        float v56 = 1.0;
      }
      BOOL v57 = v11 == v13;
      if (v11 == v13) {
        int v58 = a3;
      }
      else {
        int v58 = 0;
      }
      v13 += v58;
      if (v57)
      {
        float v12 = 0.0;
        _S3 = v56;
      }
      __asm { FCVT            H3, S3 }
      *(_WORD *)(v6 + 2) = _H3;
      v6 += 2;
    }
    while (v11 != v9);
  }
  return result;
}

uint64_t resample_float16_v_3cpp_al_expanded(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float16x8_t **a5, uint64_t *a6)
{
  uint64_t v6 = *a5;
  int v7 = *(_DWORD *)(result + 4);
  uint64_t v8 = (const float *)(result + 8);
  int v9 = a3 * a4;
  unint64_t v10 = v9 & 0xFFFFFFF0;
  if ((int)v10 < 1)
  {
    LODWORD(i) = 0;
  }
  else
  {
    for (unint64_t i = 0; i < v10; i += 16)
    {
      if (v7)
      {
        float32x4_t v12 = 0uLL;
        int v13 = a6;
        float32x4_t v14 = 0uLL;
        float32x4_t v15 = 0uLL;
        int v16 = v8;
        float32x4_t v17 = 0uLL;
        LODWORD(result) = v7;
        do
        {
          uint64_t v18 = *v13++;
          float16x8_t v19 = *(float16x8_t *)(v18 + 2 * i);
          float32x4_t v20 = vld1q_dup_f32(v16++);
          float32x4_t v17 = vaddq_f32(v17, vmulq_f32(v20, vcvt_hight_f32_f16(v19)));
          float32x4_t v15 = vaddq_f32(v15, vmulq_f32(v20, vcvtq_f32_f16(*(float16x4_t *)v19.i8)));
          float16x8_t v21 = *(float16x8_t *)(v18 + 2 * (i | 8));
          float32x4_t v14 = vaddq_f32(v14, vmulq_f32(v20, vcvt_hight_f32_f16(v21)));
          float32x4_t v12 = vaddq_f32(v12, vmulq_f32(v20, vcvtq_f32_f16(*(float16x4_t *)v21.i8)));
          result = (result - 1);
        }
        while (result);
      }
      else
      {
        float32x4_t v15 = 0uLL;
        float32x4_t v17 = 0uLL;
        float32x4_t v12 = 0uLL;
        float32x4_t v14 = 0uLL;
      }
      float32x4_t v22 = vmaxnmq_f32(v15, (float32x4_t)vrev64q_s32((int32x4_t)v15));
      float32x4_t v23 = vmaxnmq_f32(v17, (float32x4_t)vrev64q_s32((int32x4_t)v17));
      v17.i32[3] = vminnmq_f32(vmaxnmq_f32(v23, (float32x4_t)vextq_s8(*(int8x16_t *)&v23, *(int8x16_t *)&v23, 8uLL)), (float32x4_t)xmmword_1850CDF80).i32[3];
      v15.i32[3] = vminnmq_f32(vmaxnmq_f32(v22, (float32x4_t)vextq_s8(*(int8x16_t *)&v22, *(int8x16_t *)&v22, 8uLL)), (float32x4_t)xmmword_1850CDF80).i32[3];
      float32x4_t v24 = vmaxnmq_f32(v12, (float32x4_t)vrev64q_s32((int32x4_t)v12));
      float32x4_t v25 = vmaxnmq_f32(v14, (float32x4_t)vrev64q_s32((int32x4_t)v14));
      v14.i32[3] = vminnmq_f32(vmaxnmq_f32(v25, (float32x4_t)vextq_s8(*(int8x16_t *)&v25, *(int8x16_t *)&v25, 8uLL)), (float32x4_t)xmmword_1850CDF80).i32[3];
      v12.i32[3] = vminnmq_f32(vmaxnmq_f32(v24, (float32x4_t)vextq_s8(*(int8x16_t *)&v24, *(int8x16_t *)&v24, 8uLL)), (float32x4_t)xmmword_1850CDF80).i32[3];
      *uint64_t v6 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v15), v17);
      v6[1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v12), v14);
      v6 += 2;
    }
  }
  signed int v26 = v9 & 0xFFFFFFFC;
  if ((int)i < v26)
  {
    uint64_t v27 = i;
    do
    {
      float32x4_t v28 = 0uLL;
      if (v7)
      {
        short float v29 = a6;
        short float v30 = (float *)v8;
        int v31 = v7;
        do
        {
          float v32 = *v30++;
          float v33 = v32;
          uint64_t v34 = *v29++;
          float32x4_t v28 = vaddq_f32(v28, vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)(v34 + 2 * v27)), v33));
          --v31;
        }
        while (v31);
      }
      float32x4_t v35 = vmaxnmq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28));
      v28.i32[3] = vminnmq_f32(vmaxnmq_f32(v35, (float32x4_t)vextq_s8(*(int8x16_t *)&v35, *(int8x16_t *)&v35, 8uLL)), (float32x4_t)xmmword_1850CDF80).i32[3];
      *(float16x4_t *)v6->i8 = vcvt_f16_f32(v28);
      uint64_t v6 = (float16x8_t *)((char *)v6 + 8);
      v27 += 4;
    }
    while (v27 < v26);
  }
  return result;
}

uint64_t resample_float16_v_Ncpp_af_expanded(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v6 = (_WORD *)(*a5 - 2);
  int v7 = *(_DWORD *)(result + 4);
  uint64_t v8 = (float *)(result + 8);
  int v9 = a3;
  uint64_t v10 = 2 - a3;
  uint64_t v11 = a3 * a4;
  unint64_t v12 = v11 & 0xFFFFFFFC;
  if ((int)v12 < 1)
  {
    LODWORD(v13) = 0;
    _S0 = 0.0;
    unsigned int v15 = a3;
  }
  else
  {
    unint64_t v13 = 0;
    _S0 = 0.0;
    unsigned int v15 = a3;
    do
    {
      _Q2 = 0uLL;
      if (v7)
      {
        float32x4_t v17 = a6;
        uint64_t v18 = v8;
        int v19 = v7;
        do
        {
          float v20 = *v18++;
          float v21 = v20;
          uint64_t v22 = *v17++;
          _Q2 = vmlaq_n_f32(_Q2, vcvtq_f32_f16(*(float16x4_t *)(v22 + 2 * v13)), v21);
          --v19;
        }
        while (v19);
      }
      if (_S0 >= _Q2.f32[0]) {
        _S3 = _S0;
      }
      else {
        _S3 = _Q2.f32[0];
      }
      if ((v13 | 1) == v15)
      {
        if (_S3 < 1.0) {
          _S0 = _S3;
        }
        else {
          _S0 = 1.0;
        }
        __asm { FCVT            H0, S0 }
        v6[(int)v10] = _H0;
        result = v15 + v9;
        _S3 = 0.0;
        v15 += v9;
      }
      else
      {
        result = v15;
      }
      __asm { FCVT            H0, S2 }
      v6[1] = _H0;
      _S0 = _Q2.i32[1];
      if (_S3 < _Q2.f32[1]) {
        _S3 = _Q2.f32[1];
      }
      if ((v13 | 2) == result)
      {
        if (_S3 >= 1.0) {
          _S3 = 1.0;
        }
        __asm { FCVT            H3, S3 }
        v6[(int)v10 + 1] = _H3;
        result = v15 + v9;
        _S3 = 0.0;
        v15 += v9;
      }
      __asm { FCVT            H0, S0 }
      v6[2] = _H0;
      _S0 = _Q2.i32[2];
      if (_S3 < _Q2.f32[2]) {
        _S3 = _Q2.f32[2];
      }
      if ((v13 | 3) == result)
      {
        if (_S3 >= 1.0) {
          _S3 = 1.0;
        }
        __asm { FCVT            H3, S3 }
        v6[(int)v10 + 2] = _H3;
        result = v15 + v9;
        _S3 = 0.0;
        v15 += v9;
      }
      __asm { FCVT            H0, S0 }
      v6[3] = _H0;
      _Q2.i32[0] = _Q2.i32[3];
      if (_S3 >= _Q2.f32[3]) {
        _S0 = _S3;
      }
      else {
        _S0 = _Q2.f32[3];
      }
      v13 += 4;
      if (v13 == result)
      {
        if (_S0 >= 1.0) {
          _S0 = 1.0;
        }
        __asm { FCVT            H0, S0 }
        v6[(int)v10 + 3] = _H0;
        v15 += v9;
        _S0 = 0.0;
      }
      __asm { FCVT            H2, S2 }
      v6[4] = _H2;
      v6 += 4;
    }
    while (v13 < v12);
  }
  if ((int)v13 < (int)v11)
  {
    unint64_t v13 = v13;
    do
    {
      _S2 = 0.0;
      if (v7)
      {
        uint64_t v40 = a6;
        float v41 = v8;
        LODWORD(result) = v7;
        do
        {
          float v42 = *v41++;
          float v43 = v42;
          uint64_t v44 = *v40++;
          _H4 = *(_WORD *)(v44 + 2 * v13);
          __asm { FCVT            S4, H4 }
          _S2 = _S2 + (float)(_S4 * v43);
          result = (result - 1);
        }
        while (result);
      }
      if (_S0 < _S2) {
        _S0 = _S2;
      }
      if (++v13 == v15)
      {
        if (_S0 >= 1.0) {
          _S0 = 1.0;
        }
        __asm { FCVT            H0, S0 }
        v6[v10] = _H0;
        v15 += v9;
        _S0 = 0.0;
      }
      __asm { FCVT            H2, S2 }
      v6[1] = _H2;
      ++v6;
    }
    while (v13 != v11);
  }
  return result;
}

uint64_t resample_float16_v_3cpp_af_expanded(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float16x4_t **a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *(_DWORD *)(result + 4);
    int v9 = *a5;
    do
    {
      float32x4_t v10 = 0uLL;
      if (v8)
      {
        uint64_t v11 = a6;
        unint64_t v12 = (float *)(result + 8);
        int v13 = v8;
        do
        {
          float v14 = *v12++;
          float v15 = v14;
          uint64_t v16 = *v11++;
          float32x4_t v10 = vmlaq_n_f32(v10, vcvtq_f32_f16(*(float16x4_t *)(v16 + 2 * v7)), v15);
          --v13;
        }
        while (v13);
      }
      float v17 = v10.f32[1];
      if (v10.f32[1] <= v10.f32[0]) {
        float v17 = v10.f32[0];
      }
      if (v10.f32[2] > v17) {
        float v17 = v10.f32[2];
      }
      if (v10.f32[3] > v17) {
        float v17 = v10.f32[3];
      }
      if (v17 >= 1.0) {
        float v17 = 1.0;
      }
      v10.f32[0] = v17;
      *v9++ = vcvt_f16_f32(v10);
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

_DWORD *resample_float16_h_Ncpp_ap_expanded(_DWORD *result, unsigned int a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    unsigned int v9 = a3;
    int v10 = a3 - 1;
    uint64_t v11 = *a6;
    uint64_t v12 = a6[1];
    uint64_t v13 = *a7;
    uint64_t v14 = a7[1];
    uint64_t v15 = a8;
    uint64_t v16 = 2 * a3 - 2;
    do
    {
      if (a4)
      {
        float v17 = *(_WORD **)(a5 + 8 * v8);
        int v18 = a4;
        int v19 = result;
        do
        {
          int v21 = *v19;
          int v20 = v19[1];
          uint64_t v22 = (float *)(v19 + 2);
          if (v9 >= 2)
          {
            int v23 = 0;
            do
            {
              _S0 = 0.0;
              if (v20)
              {
                float32x4_t v25 = (__int16 *)(v11 + v8 * v13 + 2 * v21 * v10);
                signed int v26 = (float *)(v19 + 2);
                int v27 = v20;
                do
                {
                  float v28 = *v26++;
                  _H2 = *v25;
                  __asm { FCVT            S2, H2 }
                  _S0 = _S0 + (float)(_S2 * v28);
                  float32x4_t v25 = (__int16 *)((char *)v25 + v16);
                  --v27;
                }
                while (v27);
              }
              __asm { FCVT            H0, S0 }
              *v17++ = _H0;
              ++v23;
            }
            while (v23 != v10);
          }
          if (v20)
          {
            short float v36 = (_WORD *)(v12 + v8 * v14 + 2 + 2 * (v21 - 1));
            _S0 = 0.0;
            do
            {
              float v38 = *v22++;
              float v39 = v38;
              LOWORD(v38) = *v36++;
              _H2 = LOWORD(v38);
              __asm { FCVT            S2, H2 }
              _S0 = _S0 + (float)(_S2 * v39);
              --v20;
            }
            while (v20);
          }
          else
          {
            _S0 = 0.0;
          }
          __asm { FCVT            H0, S0 }
          *v17++ = _H0;
          v19 += a2 + 2;
          --v18;
        }
        while (v18);
      }
      ++v8;
    }
    while (v8 != v15);
  }
  return result;
}

int *resample_float16_h_4cpp_ap_expanded(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    do
    {
      if (a4)
      {
        uint64_t v15 = *(float16x4_t **)(a5 + 8 * v8);
        int v16 = a4;
        float v17 = result;
        do
        {
          int v18 = v17[1];
          if (v18)
          {
            int v19 = (float *)(v17 + 2);
            uint64_t v20 = *v17;
            int v21 = (float16x4_t *)(v9 + v8 * v11 + 8 * v20);
            uint64_t v22 = (__int16 *)(v10 + v8 * v12 + 2 * v20);
            float32x4_t v23 = 0uLL;
            _S0 = 0.0;
            do
            {
              float v25 = *v19++;
              float v26 = v25;
              float16x4_t v27 = *v21++;
              float32x4_t v28 = vcvtq_f32_f16(v27);
              v27.i16[0] = *v22++;
              _H4 = v27.i16[0];
              __asm { FCVT            S4, H4 }
              float32x4_t v23 = vmlaq_n_f32(v23, v28, v26);
              _S0 = _S0 + (float)(_S4 * v26);
              --v18;
            }
            while (v18);
          }
          else
          {
            float32x4_t v23 = 0uLL;
            _S0 = 0.0;
          }
          *uint64_t v15 = vcvt_f16_f32(v23);
          __asm { FCVT            H0, S0 }
          v15[1].i16[0] = _H0;
          uint64_t v15 = (float16x4_t *)((char *)v15 + 10);
          float v17 = (int *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

_DWORD *resample_float16_h_3cpp_ap_expanded(_DWORD *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    do
    {
      if (a4)
      {
        uint64_t v15 = *(_WORD **)(a5 + 8 * v8);
        int v16 = a4;
        float v17 = result;
        do
        {
          int v18 = v17[1];
          if (v18)
          {
            int v19 = (float *)(v17 + 2);
            uint64_t v20 = (__int16 *)(v9 + v8 * v11 + 6 * *v17);
            int v21 = (_WORD *)(v10 + v8 * v12 + 2 + 2 * (*v17 - 1));
            _S0 = 0.0;
            _S1 = 0.0;
            _S2 = 0.0;
            _S3 = 0.0;
            do
            {
              float v26 = *v19++;
              float v27 = v26;
              _H5 = *v20;
              __asm { FCVT            S5, H5 }
              _H6 = v20[1];
              __asm { FCVT            S6, H6 }
              _S3 = _S3 + (float)(_S5 * v26);
              LOWORD(_S5) = v20[2];
              _S2 = _S2 + (float)(_S6 * v26);
              LOWORD(v26) = *v21++;
              LOWORD(_S6) = LOWORD(v26);
              __asm
              {
                FCVT            S5, H5
                FCVT            S6, H6
              }
              _S1 = _S1 + (float)(_S5 * v27);
              _S0 = _S0 + (float)(_S6 * v27);
              v20 += 3;
              --v18;
            }
            while (v18);
          }
          else
          {
            _S3 = 0.0;
            _S2 = 0.0;
            _S1 = 0.0;
            _S0 = 0.0;
          }
          __asm { FCVT            H3, S3 }
          *uint64_t v15 = _H3;
          __asm { FCVT            H2, S2 }
          v15[1] = _H2;
          __asm { FCVT            H1, S1 }
          v15[2] = _H1;
          __asm { FCVT            H0, S0 }
          v15[3] = _H0;
          v15 += 4;
          float v17 = (_DWORD *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

float *resample_float16_h_1cpp_ap_expanded(float *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  if (a8 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *a6;
    uint64_t v10 = a6[1];
    uint64_t v11 = *a7;
    uint64_t v12 = a7[1];
    uint64_t v13 = 4 * a2 + 8;
    uint64_t v14 = a8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == v14) {
        return result;
      }
    }
    uint64_t v15 = *(_WORD **)(a5 + 8 * v8);
    int v16 = a4;
    float v17 = result;
    while (1)
    {
      int v18 = *((_DWORD *)v17 + 1);
      int v19 = (int *)(v17 + 2);
      float v20 = v17[2];
      uint64_t v21 = *(int *)v17 - 1;
      if (v18 >= 2) {
        break;
      }
      uint64_t v44 = v9 + v8 * v11 + 2 * v21;
      _S2 = 0.0;
      _S1 = 0.0;
      uint64_t v43 = v10 + v8 * v12 + 2 * v21;
      if (v18) {
        goto LABEL_11;
      }
LABEL_13:
      __asm { FCVT            H0, S2 }
      *uint64_t v15 = _H0;
      __asm { FCVT            H0, S1 }
      v15[1] = _H0;
      v15 += 2;
      float v17 = (float *)((char *)v17 + v13);
      if (!--v16) {
        goto LABEL_14;
      }
    }
    uint64_t v22 = 2 * v21;
    _S1 = 0.0;
    uint64_t v24 = v9 + v8 * v11;
    uint64_t v25 = v10 + v8 * v12;
    _S2 = 0.0;
    do
    {
      unsigned int v27 = v18;
      _H3 = *(_WORD *)(v24 + v22 + 2);
      __asm { FCVT            S3, H3 }
      _H4 = *(_WORD *)(v25 + v22 + 2);
      __asm { FCVT            S4, H4 }
      v18 -= 2;
      float v36 = _S2 + (float)(_S3 * v20);
      LOWORD(_S3) = *(_WORD *)(v24 + v22 + 4);
      __asm { FCVT            S3, H3 }
      float v38 = _S1 + (float)(_S4 * v20);
      float v39 = *((float *)v19 + 2);
      v19 += 2;
      float v20 = v39;
      float v40 = *((float *)v19 - 1);
      _H5 = *(_WORD *)(v25 + v22 + 4);
      __asm { FCVT            S5, H5 }
      _S2 = v36 + (float)(_S3 * v40);
      _S1 = v38 + (float)(_S5 * v40);
      v25 += 4;
      v24 += 4;
    }
    while (v27 > 3);
    uint64_t v43 = v25 + 2 * v21;
    uint64_t v44 = v24 + 2 * v21;
    if (!v18) {
      goto LABEL_13;
    }
LABEL_11:
    v45 = (__int16 *)(v43 + 2);
    int v46 = (__int16 *)(v44 + 2);
    v47 = (float *)(v19 + 1);
    do
    {
      __int16 v48 = *v46++;
      _H3 = v48;
      __asm { FCVT            S3, H3 }
      __int16 v51 = *v45++;
      _H4 = v51;
      __asm { FCVT            S4, H4 }
      _S2 = _S2 + (float)(_S3 * v20);
      _S1 = _S1 + (float)(_S4 * v20);
      float v54 = *v47++;
      float v20 = v54;
      --v18;
    }
    while (v18);
    goto LABEL_13;
  }
  return result;
}

uint64_t resample_float16_v_Ncpp_ap_expanded(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v6 = *a5 - 2;
  uint64_t v7 = a5[1] - 2;
  int v8 = *(_DWORD *)(result + 4);
  uint64_t v9 = (float *)(result + 8);
  uint64_t v10 = a3 * a4;
  unint64_t v11 = v10 & 0xFFFFFFFC;
  if ((int)v11 < 1)
  {
    LODWORD(v12) = 0;
    _S1 = 0.0;
    unsigned int v14 = a3;
  }
  else
  {
    unint64_t v12 = 0;
    _S1 = 0.0;
    unsigned int v14 = a3;
    do
    {
      _Q2 = 0uLL;
      if (v8)
      {
        int v16 = a6;
        float v17 = v9;
        int v18 = v8;
        do
        {
          float v19 = *v17++;
          float v20 = v19;
          uint64_t v21 = *v16++;
          _Q2 = vmlaq_n_f32(_Q2, vcvtq_f32_f16(*(float16x4_t *)(v21 + 2 * v12)), v20);
          --v18;
        }
        while (v18);
      }
      if (_S1 < _Q2.f32[0]) {
        _S1 = _Q2.f32[0];
      }
      if ((v12 | 1) == v14)
      {
        if (_S1 >= 1.0) {
          _S1 = 1.0;
        }
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v7 + 2) = _H1;
        v7 += 2;
        uint64_t v27 = v14 + a3;
        _S1 = 0.0;
        v14 += a3;
      }
      else
      {
        uint64_t v27 = v14;
        __asm { FCVT            H3, S2 }
        *(_WORD *)(v6 + 2) = _H3;
        v6 += 2;
      }
      _S3 = _Q2.i32[1];
      if (_S1 < _Q2.f32[1]) {
        _S1 = _Q2.f32[1];
      }
      if ((v12 | 2) == v27)
      {
        if (_S1 >= 1.0) {
          _S1 = 1.0;
        }
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v7 + 2) = _H1;
        v7 += 2;
        uint64_t v27 = v14 + a3;
        _S1 = 0.0;
        v14 += a3;
      }
      else
      {
        __asm { FCVT            H3, S3 }
        *(_WORD *)(v6 + 2) = _H3;
        v6 += 2;
      }
      _S3 = _Q2.i32[2];
      if (_S1 < _Q2.f32[2]) {
        _S1 = _Q2.f32[2];
      }
      result = v12 | 3;
      if ((v12 | 3) == v27)
      {
        if (_S1 >= 1.0) {
          _S1 = 1.0;
        }
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v7 + 2) = _H1;
        v7 += 2;
        uint64_t v27 = v14 + a3;
        _S1 = 0.0;
        v14 += a3;
      }
      else
      {
        __asm { FCVT            H3, S3 }
        *(_WORD *)(v6 + 2) = _H3;
        v6 += 2;
      }
      _Q2.i32[0] = _Q2.i32[3];
      if (_S1 < _Q2.f32[3]) {
        _S1 = _Q2.f32[3];
      }
      v12 += 4;
      if (v12 == v27)
      {
        if (_S1 >= 1.0) {
          _S1 = 1.0;
        }
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v7 + 2) = _H1;
        v7 += 2;
        v14 += a3;
        _S1 = 0.0;
      }
      else
      {
        __asm { FCVT            H2, S2 }
        *(_WORD *)(v6 + 2) = _H2;
        v6 += 2;
      }
    }
    while (v12 < v11);
  }
  if ((int)v12 < (int)v10)
  {
    unint64_t v12 = v12;
    do
    {
      _S2 = 0.0;
      if (v8)
      {
        float v38 = a6;
        float v39 = v9;
        LODWORD(result) = v8;
        do
        {
          float v40 = *v39++;
          float v41 = v40;
          uint64_t v42 = *v38++;
          _H4 = *(_WORD *)(v42 + 2 * v12);
          __asm { FCVT            S4, H4 }
          _S2 = _S2 + (float)(_S4 * v41);
          result = (result - 1);
        }
        while (result);
      }
      if (_S1 < _S2) {
        _S1 = _S2;
      }
      if (++v12 == v14)
      {
        if (_S1 >= 1.0) {
          _S1 = 1.0;
        }
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v7 + 2) = _H1;
        v7 += 2;
        v14 += a3;
        _S1 = 0.0;
      }
      else
      {
        __asm { FCVT            H2, S2 }
        *(_WORD *)(v6 + 2) = _H2;
        v6 += 2;
      }
    }
    while (v12 != v10);
  }
  return result;
}

uint64_t resample_float16_v_3cpp_ap_expanded(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    unint64_t v7 = 0;
    int v8 = *(_DWORD *)(result + 4);
    uint64_t v9 = (float *)(result + 8);
    unint64_t v11 = *(_WORD **)a5;
    uint64_t v10 = *(_WORD **)(a5 + 8);
    do
    {
      _Q1 = 0uLL;
      if (v8)
      {
        uint64_t v13 = a6;
        unsigned int v14 = v9;
        int v15 = v8;
        do
        {
          float v16 = *v14++;
          float v17 = v16;
          uint64_t v18 = *v13++;
          result = 2 * v7;
          _Q1 = vmlaq_n_f32(_Q1, vcvtq_f32_f16(*(float16x4_t *)(v18 + 2 * v7)), v17);
          --v15;
        }
        while (v15);
      }
      float v19 = _Q1.f32[3];
      if (_Q1.f32[0] > _Q1.f32[3]) {
        float v19 = _Q1.f32[0];
      }
      _S3 = _Q1.i32[1];
      if (_Q1.f32[1] > v19) {
        float v19 = _Q1.f32[1];
      }
      _S4 = _Q1.i32[2];
      if (_Q1.f32[2] > v19) {
        float v19 = _Q1.f32[2];
      }
      __asm { FCVT            H1, S1 }
      *unint64_t v11 = _H1;
      __asm { FCVT            H1, S3 }
      v11[1] = _H1;
      __asm { FCVT            H1, S4 }
      v11[2] = _H1;
      v11 += 3;
      if (v19 < 1.0) {
        _S1 = v19;
      }
      else {
        _S1 = 1.0;
      }
      __asm { FCVT            H1, S1 }
      *v10++ = _H1;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

void sub_18504100C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__20381(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20382(uint64_t a1)
{
}

void sub_185041180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18504129C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1850413B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_185041604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CG::dasher::add_path_dash_segment<CG::Quadratic>(double *a1, float64x2_t *a2, double a3, double a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  float64x2_t v8 = a2[1];
  float64x2_t v33 = *a2;
  float64x2_t v34 = v8;
  float64x2_t v9 = a2[3];
  float64x2_t v35 = a2[2];
  float64x2_t v36 = v9;
  double v10 = a1[6];
  double v11 = a1[7];
  double v12 = a1[4];
  double v13 = a1[5];
  float64_t v14 = v33.f64[1] * v11 + v33.f64[0] * v13;
  v9.f64[0] = v11 * v34.f64[1] + v34.f64[0] * v13;
  double v15 = v11 * v35.f64[1] + v35.f64[0] * v13;
  v33.f64[0] = v33.f64[1] * v10 + v33.f64[0] * v12;
  v33.f64[1] = v14;
  v34.f64[0] = v10 * v34.f64[1] + v34.f64[0] * v12;
  v34.f64[1] = v9.f64[0];
  v35.f64[0] = v10 * v35.f64[1] + v35.f64[0] * v12;
  v35.f64[1] = v15;
  float64x2_t v16 = vsubq_f64(v34, v33);
  float64x2_t v36 = vaddq_f64(v16, v16);
  float64x2_t v37 = vsubq_f64(vsubq_f64(v35, v34), v16);
  CG::Quadratic::index(v33.f64, a3);
  CG::Quadratic::split((CG::Quadratic *)&v33, v17, a2->f64);
  if (*((unsigned char *)a1 + 144))
  {
    double v18 = *a1;
    float64x2_t v28 = v38;
    if (v18 != 0.0) {
      (*(void (**)(void, void, float64x2_t *, void))(*(void *)&v18 + 24))(*(void *)(*(void *)&v18 + 8), 0, &v28, *(void *)(*(void *)&v18 + 48));
    }
  }
  if (a3 == a4)
  {
    float64x2_t v19 = vaddq_f64(vmulq_f64(vaddq_f64(v42, v42), (float64x2_t)0), v41);
    if (v19.f64[0] != 0.0 || v19.f64[1] != 0.0) {
      float64x2_t v19 = vdivq_f64(v19, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(v19.f64[1] * v19.f64[1] + v19.f64[0] * v19.f64[0])), 0));
    }
    double v20 = *a1;
    float64x2_t v28 = vaddq_f64(vmulq_f64(v19, (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL)), v38);
    if (v20 != 0.0) {
      (*(void (**)(void, uint64_t, float64x2_t *, void))(*(void *)&v20 + 24))(*(void *)(*(void *)&v20 + 8), 1, &v28, *(void *)(*(void *)&v20 + 48));
    }
  }
  else
  {
    float64x2_t v28 = v38;
    float64x2_t v29 = v39;
    float64x2_t v30 = v40;
    float64x2_t v31 = v41;
    double v21 = a1[6];
    double v22 = a1[7];
    double v23 = a1[4];
    double v24 = a1[5];
    v28.f64[0] = v38.f64[1] * v21 + v38.f64[0] * v23;
    v28.f64[1] = v38.f64[1] * v22 + v38.f64[0] * v24;
    v29.f64[0] = v21 * v39.f64[1] + v39.f64[0] * v23;
    v29.f64[1] = v22 * v39.f64[1] + v39.f64[0] * v24;
    v30.f64[0] = v21 * v40.f64[1] + v40.f64[0] * v23;
    v30.f64[1] = v22 * v40.f64[1] + v40.f64[0] * v24;
    float64x2_t v25 = vsubq_f64(v29, v28);
    float64x2_t v31 = vaddq_f64(v25, v25);
    float64x2_t v32 = vsubq_f64(vsubq_f64(v30, v29), v25);
    CG::Quadratic::index(v28.f64, a4 - a3);
    CG::Quadratic::split((CG::Quadratic *)&v28, v26, v38.f64);
    double v27 = *a1;
    if (*(void *)a1)
    {
      v43[0] = v29;
      v43[1] = v30;
      (*(void (**)(void, uint64_t, _OWORD *, void))(*(void *)&v27 + 24))(*(void *)(*(void *)&v27 + 8), 2, v43, *(void *)(*(void *)&v27 + 48));
    }
  }
}

uint64_t anonymous namespace'::release_data(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    v2 = *(void **)(result + 8);
    if (v2)
    {
      *(void *)(v1 + 16) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x18532A2A0);
  }
  return result;
}

void *anonymous namespace'::end(void *result)
{
  uint64_t v1 = (void *)*result;
  if (*result)
  {
    v2 = (uint64_t (*)(void, void))v1[4];
    if (v2) {
      return (void *)v2(v1[1], v1[6]);
    }
  }
  return result;
}

void anonymous namespace'::iterate(CG::dasher *this, int a2, float64x2_t *a3, void *a4)
{
  if (*((void *)this + 1) == *((void *)this + 2))
  {
    if (a4)
    {
      v5 = (void (*)(uint64_t, uint64_t))a4[4];
      if (v5)
      {
        uint64_t v6 = a4[1];
        uint64_t v7 = a4[6];
        v5(v6, v7);
      }
    }
  }
  else
  {
    switch(a2)
    {
      case 0:
        *(float64x2_t *)((char *)this + 88) = *a3;
        goto LABEL_25;
      case 1:
        float64_t v8 = a3->f64[0];
        float64_t v9 = a3->f64[1];
        float64x2_t v52 = *((float64x2_t *)this + 8);
        v53.f64[0] = v8;
        v53.f64[1] = v9;
        CG::dasher::dash_path_element<CG::LineSegment>((uint64_t)this, &v52);
        *((float64_t *)this + 16) = v8;
        *((float64_t *)this + 17) = v9;
        return;
      case 2:
        float64x2_t v10 = *a3;
        double v11 = (float64x2_t *)((char *)this + 128);
        float64x2_t v44 = a3[1];
        float64x2_t v45 = *((float64x2_t *)this + 8);
        float64x2_t v46 = v10;
        float64x2_t v47 = v44;
        float64x2_t v12 = vsubq_f64(v10, v45);
        float64x2_t v48 = vaddq_f64(v12, v12);
        float64x2_t v49 = vsubq_f64(vsubq_f64(v44, v10), v12);
        float64x2_t v52 = v45;
        float64x2_t v53 = v10;
        float64x2_t v54 = v44;
        float64x2_t v55 = v48;
        v12.f64[0] = *((float64_t *)this + 6);
        double v13 = *((double *)this + 7);
        double v14 = *((double *)this + 4);
        double v15 = *((double *)this + 5);
        v52.f64[0] = v45.f64[1] * v12.f64[0] + v45.f64[0] * v14;
        v52.f64[1] = v45.f64[1] * v13 + v45.f64[0] * v15;
        v53.f64[0] = v12.f64[0] * v10.f64[1] + v10.f64[0] * v14;
        v53.f64[1] = v13 * v10.f64[1] + v10.f64[0] * v15;
        v54.f64[0] = v12.f64[0] * v44.f64[1] + v44.f64[0] * v14;
        v54.f64[1] = v13 * v44.f64[1] + v44.f64[0] * v15;
        float64x2_t v16 = vsubq_f64(v53, v52);
        float64x2_t v55 = vaddq_f64(v16, v16);
        float64x2_t v56 = vsubq_f64(vsubq_f64(v54, v53), v16);
        CG::Quadratic::length(v52.f64, 0);
        float64x2_t v18 = v44;
        if (v17 == 0.0) {
          goto LABEL_41;
        }
        double v19 = v17;
        double v20 = *((double *)this + 15);
        if (v19 <= v20)
        {
          if (!*((unsigned char *)this + 104)) {
            goto LABEL_34;
          }
          CG::dasher::add_path_dash_segment<CG::Quadratic>((double *)this, &v45, 0.0, v19);
          goto LABEL_33;
        }
        double v21 = 0.0;
        for (double i = v20 + 0.0; i < v19; double i = v21 + v20)
        {
          if (*((unsigned char *)this + 104))
          {
            CG::dasher::add_path_dash_segment<CG::Quadratic>((double *)this, &v45, v21, i);
            double v20 = *((double *)this + 15);
          }
          double v21 = v21 + v20;
          CG::dasher::advance_dash_index((uint64_t)this);
          double v20 = *((double *)this + 15);
        }
        float64x2_t v18 = v44;
        if (v21 >= v19) {
          goto LABEL_41;
        }
        if (!*((unsigned char *)this + 104)) {
          goto LABEL_39;
        }
        CG::dasher::add_path_dash_segment<CG::Quadratic>((double *)this, &v45, v21, v19);
        goto LABEL_38;
      case 3:
        float64x2_t v23 = *a3;
        float64x2_t v24 = a3[1];
        float64x2_t v25 = a3[2];
        double v11 = (float64x2_t *)((char *)this + 128);
        float64x2_t v45 = *((float64x2_t *)this + 8);
        float64x2_t v46 = v23;
        float64x2_t v47 = v24;
        float64x2_t v48 = v25;
        float64x2_t v26 = v25;
        float64x2_t v44 = v25;
        float64x2_t v27 = v23;
        float64x2_t v28 = vsubq_f64(v23, v45);
        __asm { FMOV            V5.2D, #3.0 }
        float64x2_t v34 = vsubq_f64(v24, v23);
        float64x2_t v49 = vmulq_f64(v28, _Q5);
        float64x2_t v50 = vmulq_f64(vsubq_f64(v34, v28), _Q5);
        float64x2_t v51 = vaddq_f64(v28, vsubq_f64(vsubq_f64(v26, v24), vaddq_f64(v34, v34)));
        float64x2_t v52 = v45;
        float64x2_t v53 = v27;
        float64x2_t v54 = v24;
        float64x2_t v55 = v48;
        float64x2_t v56 = v49;
        float64x2_t v57 = v50;
        float64x2_t v58 = v51;
        double v35 = *((double *)this + 6);
        v28.f64[0] = *((float64_t *)this + 7);
        double v36 = *((double *)this + 4);
        double v37 = *((double *)this + 5);
        v52.f64[0] = v45.f64[1] * v35 + v45.f64[0] * v36;
        v52.f64[1] = v45.f64[1] * v28.f64[0] + v45.f64[0] * v37;
        v53.f64[0] = v35 * v27.f64[1] + v27.f64[0] * v36;
        v53.f64[1] = v28.f64[0] * v27.f64[1] + v27.f64[0] * v37;
        v54.f64[0] = v35 * v24.f64[1] + v24.f64[0] * v36;
        v54.f64[1] = v28.f64[0] * v24.f64[1] + v24.f64[0] * v37;
        v55.f64[0] = v35 * v48.f64[1] + v48.f64[0] * v36;
        v55.f64[1] = v28.f64[0] * v48.f64[1] + v48.f64[0] * v37;
        float64x2_t v38 = vsubq_f64(v53, v52);
        float64x2_t v39 = vsubq_f64(v54, v53);
        float64x2_t v56 = vmulq_f64(v38, _Q5);
        float64x2_t v57 = vmulq_f64(vsubq_f64(v39, v38), _Q5);
        float64x2_t v58 = vaddq_f64(v38, vsubq_f64(vsubq_f64(v55, v54), vaddq_f64(v39, v39)));
        CG::Cubic::length(&v52, 0);
        float64x2_t v18 = v44;
        if (v40 == 0.0) {
          goto LABEL_41;
        }
        double v19 = v40;
        double v20 = *((double *)this + 15);
        if (v19 <= v20)
        {
          if (*((unsigned char *)this + 104))
          {
            CG::dasher::add_path_dash_segment<CG::Cubic>((double *)this, &v45, 0.0, v19);
LABEL_33:
            *((unsigned char *)this + 144) = 0;
            double v20 = *((double *)this + 15);
          }
LABEL_34:
          double v43 = v20 - v19;
LABEL_40:
          *((double *)this + 15) = v43;
          float64x2_t v18 = v44;
          goto LABEL_41;
        }
        double v21 = 0.0;
        for (double j = v20 + 0.0; j < v19; double j = v21 + v20)
        {
          if (*((unsigned char *)this + 104))
          {
            CG::dasher::add_path_dash_segment<CG::Cubic>((double *)this, &v45, v21, j);
            double v20 = *((double *)this + 15);
          }
          double v21 = v21 + v20;
          CG::dasher::advance_dash_index((uint64_t)this);
          double v20 = *((double *)this + 15);
        }
        float64x2_t v18 = v44;
        if (v21 < v19)
        {
          if (*((unsigned char *)this + 104))
          {
            CG::dasher::add_path_dash_segment<CG::Cubic>((double *)this, &v45, v21, v19);
LABEL_38:
            *((unsigned char *)this + 144) = 0;
            double v20 = *((double *)this + 15);
          }
LABEL_39:
          double v43 = v20 - (v19 - v21);
          goto LABEL_40;
        }
LABEL_41:
        *double v11 = v18;
        break;
      case 4:
        float64x2_t v42 = *(float64x2_t *)((char *)this + 88);
        float64x2_t v52 = *((float64x2_t *)this + 8);
        float64x2_t v53 = v42;
        CG::dasher::dash_path_element<CG::LineSegment>((uint64_t)this, &v52);
LABEL_25:
        *((void *)this + 14) = *((void *)this + 9);
        *((unsigned char *)this + 104) = *((unsigned char *)this + 64);
        *((unsigned char *)this + 144) = 1;
        *((void *)this + 15) = *((void *)this + 10);
        *((_OWORD *)this + 8) = *(_OWORD *)((char *)this + 88);
        return;
      default:
        abort();
    }
  }
}

void *anonymous namespace'::begin(void *result, uint64_t a2)
{
  v2 = (void *)*result;
  if (*result)
  {
    v3 = (uint64_t (*)(void, uint64_t, void))v2[2];
    if (v3) {
      return (void *)v3(v2[1], a2, v2[6]);
    }
  }
  return result;
}

uint64_t CGAccessSessionGetBytePointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t CGAccessSessionSkipForward(uint64_t result, uint64_t a2)
{
  if (result)
  {
    v3 = (uint64_t *)result;
    check_same_thread();
    uint64_t v4 = *v3;
    switch(*(_DWORD *)(*v3 + 20))
    {
      case 0:
      case 2:
        uint64_t v5 = v3[2];
        uint64_t v6 = *(void *)(v4 + 32);
        if (v5 + a2 <= v6) {
          result = a2;
        }
        else {
          result = v6 - v5;
        }
        v3[2] = result + v5;
        break;
      case 1:
      case 3:
        result = CGDataProviderSkipForwardInternal(v4, a2);
        break;
      default:
        result = -1;
        break;
    }
  }
  return result;
}

uint64_t CGAccessSessionGetChunks(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !(a3 | a2)) {
    return 0;
  }
  if (!*a1) {
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, vars0);
  }
  switch(*(_DWORD *)(*a1 + 20))
  {
    case 0:
    case 2:
      if (a6 | a3) {
        uint64_t v8 = a4;
      }
      else {
        uint64_t v8 = 1;
      }
      if (a6 | a3) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = a4;
      }
      int64_t v10 = v9 * a2;
      uint64_t result = get_chunks_direct(a1, v10, a3, v8, a5, a6);
      break;
    case 1:
    case 3:
      uint64_t result = get_chunks_sequential(a1, a2, a3, a4, (uint64_t)a5, a6);
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t get_chunks_sequential(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  check_same_thread();
  uint64_t v15 = *a1;
  if ((*(_DWORD *)(*a1 + 20) & 0xFFFFFFFD) != 1 || !*(void *)(*a1 + 40)) {
    _CGHandleAssert("get_chunks_sequential", 225, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGAccessSession.c", "CGDataProviderCanGetSequentialChunks(provider)", "data provider is not sequential or provides no method (%p) to sequentially read data", v12, v13, v14, *(void *)(*a1 + 40));
  }
  for (uint64_t i = 0; a4; --a4)
  {
    if (a2)
    {
      unint64_t BytesInternal = CGDataProviderSequentialGetBytesInternal(v15, a5, a2);
      i += BytesInternal;
      a1[2] += BytesInternal;
      if (BytesInternal < a2) {
        break;
      }
    }
    if (a3)
    {
      uint64_t v18 = CGDataProviderSkipForwardInternal(v15, a3);
      i += v18;
      a1[2] += v18;
    }
    a5 += a2 + a6;
  }
  return i;
}

uint64_t CGAccessSessionHasError(CFTypeRef *a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(*a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  if (v2 != CGDataProviderGetTypeID_id) {
    return 0;
  }
  v3 = (uint64_t (*)(uint64_t))v1[15];
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v1[3];

  return v3(v4);
}

CGPDFStreamRef get_font_stream_20452(uint64_t a1)
{
  unint64_t FontDescriptor = CGPDFFontGetFontDescriptor(a1);
  if (!FontDescriptor) {
    return 0;
  }
  unint64_t v2 = FontDescriptor;
  CGPDFStreamRef value = 0;
  if (CGPDFDictionaryGetStream(*(CGPDFDictionaryRef *)(FontDescriptor + 32), "FontFile2", &value)) {
    CGPDFStreamRef v3 = value;
  }
  else {
    CGPDFStreamRef v3 = 0;
  }
  if (!v3)
  {
    CGPDFStreamRef value = 0;
    CGPDFStreamRef v3 = CGPDFDictionaryGetStream(*(CGPDFDictionaryRef *)(v2 + 32), "FontFile3", &value) ? value : 0;
    if (v3)
    {
      CGPDFStreamRef value = 0;
      if (CGPDFDictionaryGetName(*((CGPDFDictionaryRef *)v3 + 6), "Subtype", (const char **)&value))
      {
        uint64_t v4 = (const char *)value;
        if (strcmp((const char *)value, "OpenType"))
        {
          return 0;
        }
      }
    }
  }
  return v3;
}

uint64_t A8_sample_ALPHA16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  int v103 = *(_DWORD *)(result + 28);
  if (v4)
  {
    uint64_t v5 = *(void *)(result + 176);
    uint64_t v6 = *(void *)(result + 64);
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v8 = *(void *)(result + 112);
    uint64_t v9 = *(void *)(result + 120);
    uint64_t v11 = *(void *)(result + 48);
    uint64_t v10 = *(void *)(result + 56);
    BOOL v12 = v11 == 0;
    if (v11)
    {
      uint64_t v100 = *(void *)(result + 112);
      if (v8 > v11) {
        uint64_t v100 = v8 % v11;
      }
    }
    else
    {
      uint64_t v100 = 0;
    }
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v98 = *(void *)(result + 88);
    if (v10)
    {
      if (v9 <= v10) {
        uint64_t v99 = *(void *)(result + 120);
      }
      else {
        uint64_t v99 = v9 % v10;
      }
    }
    else
    {
      uint64_t v99 = 0;
    }
  }
  else
  {
    uint64_t v99 = 0;
    uint64_t v100 = 0;
    uint64_t v11 = 0;
    uint64_t v5 = 0;
    uint64_t v10 = 0;
    uint64_t v6 = *(void *)(result + 64);
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v98 = *(void *)(result + 88);
    BOOL v12 = 1;
    uint64_t v8 = *(void *)(result + 112);
    uint64_t v9 = *(void *)(result + 120);
  }
  uint64_t v13 = *(void *)(result + 152) - 1;
  uint64_t v14 = *(void *)(result + 144) - 1;
  char v101 = *(unsigned char *)(result + 248);
  unint64_t v15 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v103)
      + 2 * ((*(_DWORD *)(result + 256) - 1) << v101);
  int v96 = *(_DWORD *)(result + 188);
  uint64_t v102 = 2 * *(_DWORD *)(result + 252);
  uint64_t v16 = -v7;
  while (1)
  {
LABEL_13:
    if (a3 >= v7)
    {
      if (a3 <= v98)
      {
        uint64_t v25 = 0;
        uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v27 = 0x3FFFFFFF;
        uint64_t v28 = a3;
      }
      else
      {
        uint64_t v21 = *(void *)(result + 216);
        uint64_t v22 = *(void *)(result + 224) + v98;
        uint64_t v23 = v22 - a3 + (v21 >> 1);
        if (v23 < 1) {
          break;
        }
        if (v23 >= v21) {
          LODWORD(v24) = 0x3FFFFFFF;
        }
        else {
          unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
        }
        unsigned int v27 = v24 | v96;
        uint64_t v28 = v22 - 0x1000000;
        uint64_t v25 = a3 - (v22 - 0x1000000);
        uint64_t v26 = 448;
      }
    }
    else
    {
      uint64_t v17 = *(void *)(result + 216);
      uint64_t v18 = v7 - *(void *)(result + 224);
      uint64_t v19 = a3 - v18 + (v17 >> 1);
      if (v19 < 1) {
        break;
      }
      if (v19 >= v17) {
        LODWORD(v20) = 0x3FFFFFFF;
      }
      else {
        unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
      }
      unsigned int v27 = v20 | v96;
      uint64_t v28 = v18 + 0x1000000;
      uint64_t v25 = a3 - (v18 + 0x1000000);
      uint64_t v26 = 512;
    }
    if (a2 >= v6)
    {
      if (a2 <= v97)
      {
        uint64_t v33 = 0;
        uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v32 = a2;
      }
      else
      {
        uint64_t v35 = *(void *)(result + 192);
        uint64_t v36 = *(void *)(result + 200) + v97;
        uint64_t v37 = v36 - a2 + (v35 >> 1);
        if (v37 < 1) {
          break;
        }
        if (v37 < v35) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v96;
        }
        uint64_t v32 = v36 - 0x1000000;
        uint64_t v33 = a2 - (v36 - 0x1000000);
        uint64_t v34 = 28;
      }
    }
    else
    {
      uint64_t v29 = *(void *)(result + 192);
      uint64_t v30 = v6 - *(void *)(result + 200);
      uint64_t v31 = a2 - v30 + (v29 >> 1);
      if (v31 < 1) {
        break;
      }
      if (v31 < v29) {
        unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v96;
      }
      uint64_t v32 = v30 + 0x1000000;
      uint64_t v33 = a2 - (v30 + 0x1000000);
      uint64_t v34 = 32;
    }
    if (v27 < 0x400000) {
      break;
    }
    if (!v12)
    {
      uint64_t v38 = (v10 & ((v28 % v10) >> 63)) + v28 % v10;
      uint64_t v39 = (v11 & ((v32 % v11) >> 63)) + v32 % v11;
      if (v38 >= v10) {
        uint64_t v40 = v10;
      }
      else {
        uint64_t v40 = 0;
      }
      uint64_t v28 = v38 - v40;
      if (v39 >= v11) {
        uint64_t v41 = v11;
      }
      else {
        uint64_t v41 = 0;
      }
      uint64_t v32 = v39 - v41;
      v25 += v28;
      v33 += v32;
    }
    if (v4)
    {
      uint64_t v42 = v4 + SHIDWORD(v28) * (uint64_t)v103 + 2 * (v32 >> 32 << v101);
      double v43 = (unsigned __int16 *)(v42 + v102);
      if (v15 < v42 + v102) {
        double v43 = (unsigned __int16 *)v15;
      }
      if ((unint64_t)v43 < *(void *)(result + 40)) {
        double v43 = *(unsigned __int16 **)(result + 40);
      }
      unsigned int v44 = bswap32(*v43) >> 16;
      if (v5)
      {
LABEL_56:
        unsigned int v45 = *(_DWORD *)(v5 + (v34 | v26));
LABEL_58:
        int v46 = v45 & 0xF;
        uint64_t v47 = v45 >> 8;
        int v48 = HIBYTE(v45) & 3;
        switch(v46)
        {
          case 1:
            LODWORD(v71) = SBYTE1(v45);
            if (!v12)
            {
              uint64_t v72 = v25 + ((uint64_t)(char)v47 << 32);
              uint64_t v73 = v10 & (v72 >> 63);
              if (v73 + v72 >= v10) {
                uint64_t v74 = v10;
              }
              else {
                uint64_t v74 = 0;
              }
              uint64_t v71 = (v73 + ((uint64_t)(char)v47 << 32) - v74) >> 32;
            }
            unsigned int v75 = 0xFFFF;
            if (v4)
            {
              v76 = (unsigned __int16 *)(v42 + (int)v71 * (uint64_t)v103 + v102);
              if (v15 < (unint64_t)v76) {
                v76 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v76 < *(void *)(result + 40)) {
                v76 = *(unsigned __int16 **)(result + 40);
              }
              unsigned int v75 = bswap32(*v76) >> 16;
            }
            unsigned int v44 = v44 - ((interpolate_1616[v48] & v44) >> (v48 + 1)) + ((interpolate_1616[v48] & v75) >> (v48 + 1));
            break;
          case 2:
            uint64_t v77 = SBYTE2(v45);
            if (!v12)
            {
              uint64_t v78 = v33 + ((uint64_t)SBYTE2(v45) << 32);
              uint64_t v79 = v11 & (v78 >> 63);
              if (v79 + v78 >= v11) {
                uint64_t v80 = v11;
              }
              else {
                uint64_t v80 = 0;
              }
              uint64_t v77 = (v79 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 24) - v80) >> 32;
            }
            unsigned int v81 = 0xFFFF;
            if (v4)
            {
              v82 = (unsigned __int16 *)(v42 + 2 * (v77 << v101) + v102);
              if (v15 < (unint64_t)v82) {
                v82 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v82 < *(void *)(result + 40)) {
                v82 = *(unsigned __int16 **)(result + 40);
              }
              unsigned int v81 = bswap32(*v82) >> 16;
            }
            unsigned int v44 = v44
                - ((interpolate_1616[(v45 >> 28) & 3] & v44) >> (((v45 >> 28) & 3) + 1))
                + ((interpolate_1616[(v45 >> 28) & 3] & v81) >> (((v45 >> 28) & 3) + 1));
            break;
          case 3:
            int v94 = HIBYTE(v45) & 3;
            uint64_t v95 = v7;
            LODWORD(v49) = SBYTE1(v45);
            uint64_t v50 = SBYTE2(v45);
            if (!v12)
            {
              uint64_t v51 = v47 << 56;
              uint64_t v52 = v25 + (v51 >> 24);
              uint64_t v53 = v33 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 24);
              uint64_t v54 = v10 & (v52 >> 63);
              uint64_t v55 = v11 & (v53 >> 63);
              uint64_t v56 = v55 + v53;
              if (v54 + v52 >= v10) {
                uint64_t v57 = v10;
              }
              else {
                uint64_t v57 = 0;
              }
              if (v56 >= v11) {
                uint64_t v58 = v11;
              }
              else {
                uint64_t v58 = 0;
              }
              uint64_t v49 = (v54 + (v51 >> 24) - v57) >> 32;
              uint64_t v50 = (v55 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 24) - v58) >> 32;
            }
            unsigned int v59 = 0xFFFF;
            unsigned int v60 = 0xFFFF;
            unsigned int v61 = 0xFFFF;
            if (v4)
            {
              uint64_t v62 = v50 << v101;
              v63 = (unsigned __int16 *)(v42 + 2 * (v50 << v101) + v102);
              unint64_t v64 = *(void *)(result + 40);
              if (v15 < (unint64_t)v63) {
                v63 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v63 < v64) {
                v63 = *(unsigned __int16 **)(result + 40);
              }
              unsigned int v59 = bswap32(*v63) >> 16;
              unint64_t v65 = v42 + (int)v49 * (uint64_t)v103 + v102;
              if (v15 >= v65) {
                v66 = (unsigned __int16 *)(v42 + (int)v49 * (uint64_t)v103 + v102);
              }
              else {
                v66 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v66 < v64) {
                v66 = *(unsigned __int16 **)(result + 40);
              }
              unsigned int v60 = bswap32(*v66) >> 16;
              v67 = (unsigned __int16 *)(v65 + 2 * v62);
              if (v15 < (unint64_t)v67) {
                v67 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v67 < v64) {
                v67 = *(unsigned __int16 **)(result + 40);
              }
              unsigned int v61 = bswap32(*v67) >> 16;
            }
            int v68 = interpolate_1616[v94];
            unsigned int v69 = v44 - ((v68 & v44) >> (v94 + 1)) + ((v68 & v60) >> (v94 + 1));
            int v70 = (v45 >> 28) & 3;
            unsigned int v44 = v69
                - ((v69 & interpolate_1616[v70]) >> (v70 + 1))
                + (((v59 - ((v68 & v59) >> (v94 + 1)) + ((v68 & v61) >> (v94 + 1))) & interpolate_1616[v70]) >> (v70 + 1));
            uint64_t v7 = v95;
            break;
        }
      }
    }
    else
    {
      uint64_t v42 = 0;
      unsigned int v44 = 0xFFFF;
      if (v5) {
        goto LABEL_56;
      }
    }
    *(unsigned char *)(v13 + 1) = BYTE1(v44);
    *(unsigned char *)(v14 + 1) = v27 >> 22;
    if (a4 == 1) {
      return result;
    }
    uint64_t v83 = 0;
    a2 += v8;
    uint64_t v84 = v97 - a2;
    a3 += v9;
    uint64_t v85 = v98 - a3;
    while ((((a2 - v6) | v84 | (v16 + a3) | v85) & 0x8000000000000000) == 0)
    {
      if (v12)
      {
        uint64_t v86 = a2;
        HIDWORD(v87) = HIDWORD(a3);
        if (!v4) {
          goto LABEL_127;
        }
      }
      else
      {
        uint64_t v89 = (v10 & ((v25 + v99) >> 63)) + v25 + v99;
        uint64_t v90 = (v11 & ((v33 + v100) >> 63)) + v33 + v100;
        if (v89 >= v10) {
          uint64_t v91 = v10;
        }
        else {
          uint64_t v91 = 0;
        }
        uint64_t v87 = v89 - v91;
        if (v90 >= v11) {
          uint64_t v92 = v11;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v86 = v90 - v92;
        uint64_t v33 = v86;
        uint64_t v25 = v87;
        if (!v4)
        {
LABEL_127:
          unsigned int v44 = 0xFFFF;
          if (!v5) {
            goto LABEL_129;
          }
          goto LABEL_128;
        }
      }
      uint64_t v42 = v4 + SHIDWORD(v87) * (uint64_t)v103 + 2 * (v86 >> 32 << v101);
      v88 = (unsigned __int16 *)(v42 + v102);
      if (v15 < v42 + v102) {
        v88 = (unsigned __int16 *)v15;
      }
      if ((unint64_t)v88 < *(void *)(result + 40)) {
        v88 = *(unsigned __int16 **)(result + 40);
      }
      unsigned int v44 = bswap32(*v88) >> 16;
      if (!v5) {
        goto LABEL_129;
      }
LABEL_128:
      unsigned int v45 = *(_DWORD *)(v5 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
      if ((v45 & 0xF) != 0)
      {
        v14 += v83 + 1;
        v13 += v83 + 1;
        a4 += ~v83;
        unsigned int v27 = -1;
        goto LABEL_58;
      }
LABEL_129:
      *(unsigned char *)(v13 + v83 + 2) = BYTE1(v44);
      uint64_t v93 = v14 + v83++;
      *(unsigned char *)(v93 + 2) = -1;
      a2 += v8;
      v84 -= v8;
      a3 += v9;
      v85 -= v9;
      if (a4 - 1 == v83) {
        return result;
      }
    }
    v14 += v83 + 1;
    v13 += v83 + 1;
    a4 += ~v83;
    if (!a4) {
      return result;
    }
  }
  --a4;
  a2 += v8;
  a3 += v9;
  ++v13;
  *(unsigned char *)++uint64_t v14 = 0;
  if (a4) {
    goto LABEL_13;
  }
  return result;
}

uint64_t A8_sample_alpha16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  int v103 = *(_DWORD *)(result + 28);
  if (v4)
  {
    uint64_t v5 = *(void *)(result + 176);
    uint64_t v6 = *(void *)(result + 64);
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v8 = *(void *)(result + 112);
    uint64_t v9 = *(void *)(result + 120);
    uint64_t v11 = *(void *)(result + 48);
    uint64_t v10 = *(void *)(result + 56);
    BOOL v12 = v11 == 0;
    if (v11)
    {
      uint64_t v100 = *(void *)(result + 112);
      if (v8 > v11) {
        uint64_t v100 = v8 % v11;
      }
    }
    else
    {
      uint64_t v100 = 0;
    }
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v98 = *(void *)(result + 88);
    if (v10)
    {
      if (v9 <= v10) {
        uint64_t v99 = *(void *)(result + 120);
      }
      else {
        uint64_t v99 = v9 % v10;
      }
    }
    else
    {
      uint64_t v99 = 0;
    }
  }
  else
  {
    uint64_t v99 = 0;
    uint64_t v100 = 0;
    uint64_t v11 = 0;
    uint64_t v5 = 0;
    uint64_t v10 = 0;
    uint64_t v6 = *(void *)(result + 64);
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v98 = *(void *)(result + 88);
    BOOL v12 = 1;
    uint64_t v8 = *(void *)(result + 112);
    uint64_t v9 = *(void *)(result + 120);
  }
  uint64_t v13 = *(void *)(result + 152) - 1;
  uint64_t v14 = *(void *)(result + 144) - 1;
  char v101 = *(unsigned char *)(result + 248);
  unint64_t v15 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v103)
      + 2 * ((*(_DWORD *)(result + 256) - 1) << v101);
  int v96 = *(_DWORD *)(result + 188);
  uint64_t v102 = 2 * *(_DWORD *)(result + 252);
  uint64_t v16 = -v7;
  while (1)
  {
LABEL_13:
    if (a3 >= v7)
    {
      if (a3 <= v98)
      {
        uint64_t v25 = 0;
        uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v27 = 0x3FFFFFFF;
        uint64_t v28 = a3;
      }
      else
      {
        uint64_t v21 = *(void *)(result + 216);
        uint64_t v22 = *(void *)(result + 224) + v98;
        uint64_t v23 = v22 - a3 + (v21 >> 1);
        if (v23 < 1) {
          break;
        }
        if (v23 >= v21) {
          LODWORD(v24) = 0x3FFFFFFF;
        }
        else {
          unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
        }
        unsigned int v27 = v24 | v96;
        uint64_t v28 = v22 - 0x1000000;
        uint64_t v25 = a3 - (v22 - 0x1000000);
        uint64_t v26 = 448;
      }
    }
    else
    {
      uint64_t v17 = *(void *)(result + 216);
      uint64_t v18 = v7 - *(void *)(result + 224);
      uint64_t v19 = a3 - v18 + (v17 >> 1);
      if (v19 < 1) {
        break;
      }
      if (v19 >= v17) {
        LODWORD(v20) = 0x3FFFFFFF;
      }
      else {
        unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
      }
      unsigned int v27 = v20 | v96;
      uint64_t v28 = v18 + 0x1000000;
      uint64_t v25 = a3 - (v18 + 0x1000000);
      uint64_t v26 = 512;
    }
    if (a2 >= v6)
    {
      if (a2 <= v97)
      {
        uint64_t v33 = 0;
        uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v32 = a2;
      }
      else
      {
        uint64_t v35 = *(void *)(result + 192);
        uint64_t v36 = *(void *)(result + 200) + v97;
        uint64_t v37 = v36 - a2 + (v35 >> 1);
        if (v37 < 1) {
          break;
        }
        if (v37 < v35) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v96;
        }
        uint64_t v32 = v36 - 0x1000000;
        uint64_t v33 = a2 - (v36 - 0x1000000);
        uint64_t v34 = 28;
      }
    }
    else
    {
      uint64_t v29 = *(void *)(result + 192);
      uint64_t v30 = v6 - *(void *)(result + 200);
      uint64_t v31 = a2 - v30 + (v29 >> 1);
      if (v31 < 1) {
        break;
      }
      if (v31 < v29) {
        unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v96;
      }
      uint64_t v32 = v30 + 0x1000000;
      uint64_t v33 = a2 - (v30 + 0x1000000);
      uint64_t v34 = 32;
    }
    if (v27 < 0x400000) {
      break;
    }
    if (!v12)
    {
      uint64_t v38 = (v10 & ((v28 % v10) >> 63)) + v28 % v10;
      uint64_t v39 = (v11 & ((v32 % v11) >> 63)) + v32 % v11;
      if (v38 >= v10) {
        uint64_t v40 = v10;
      }
      else {
        uint64_t v40 = 0;
      }
      uint64_t v28 = v38 - v40;
      if (v39 >= v11) {
        uint64_t v41 = v11;
      }
      else {
        uint64_t v41 = 0;
      }
      uint64_t v32 = v39 - v41;
      v25 += v28;
      v33 += v32;
    }
    if (v4)
    {
      uint64_t v42 = v4 + SHIDWORD(v28) * (uint64_t)v103 + 2 * (v32 >> 32 << v101);
      double v43 = (unsigned __int16 *)(v42 + v102);
      if (v15 < v42 + v102) {
        double v43 = (unsigned __int16 *)v15;
      }
      if ((unint64_t)v43 < *(void *)(result + 40)) {
        double v43 = *(unsigned __int16 **)(result + 40);
      }
      unsigned int v44 = *v43;
      if (v5)
      {
LABEL_56:
        unsigned int v45 = *(_DWORD *)(v5 + (v34 | v26));
LABEL_58:
        int v46 = v45 & 0xF;
        uint64_t v47 = v45 >> 8;
        int v48 = HIBYTE(v45) & 3;
        switch(v46)
        {
          case 1:
            LODWORD(v71) = SBYTE1(v45);
            if (!v12)
            {
              uint64_t v72 = v25 + ((uint64_t)(char)v47 << 32);
              uint64_t v73 = v10 & (v72 >> 63);
              if (v73 + v72 >= v10) {
                uint64_t v74 = v10;
              }
              else {
                uint64_t v74 = 0;
              }
              uint64_t v71 = (v73 + ((uint64_t)(char)v47 << 32) - v74) >> 32;
            }
            int v75 = 0xFFFF;
            if (v4)
            {
              v76 = (unsigned __int16 *)(v42 + (int)v71 * (uint64_t)v103 + v102);
              if (v15 < (unint64_t)v76) {
                v76 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v76 < *(void *)(result + 40)) {
                v76 = *(unsigned __int16 **)(result + 40);
              }
              int v75 = *v76;
            }
            unsigned int v44 = v44
                - ((interpolate_1616[v48] & v44) >> (v48 + 1))
                + ((interpolate_1616[v48] & v75) >> (v48 + 1));
            break;
          case 2:
            uint64_t v77 = SBYTE2(v45);
            if (!v12)
            {
              uint64_t v78 = v33 + ((uint64_t)SBYTE2(v45) << 32);
              uint64_t v79 = v11 & (v78 >> 63);
              if (v79 + v78 >= v11) {
                uint64_t v80 = v11;
              }
              else {
                uint64_t v80 = 0;
              }
              uint64_t v77 = (v79 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 24) - v80) >> 32;
            }
            int v81 = 0xFFFF;
            if (v4)
            {
              v82 = (unsigned __int16 *)(v42 + 2 * (v77 << v101) + v102);
              if (v15 < (unint64_t)v82) {
                v82 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v82 < *(void *)(result + 40)) {
                v82 = *(unsigned __int16 **)(result + 40);
              }
              int v81 = *v82;
            }
            unsigned int v44 = v44
                - ((interpolate_1616[(v45 >> 28) & 3] & v44) >> (((v45 >> 28) & 3) + 1))
                + ((interpolate_1616[(v45 >> 28) & 3] & v81) >> (((v45 >> 28) & 3) + 1));
            break;
          case 3:
            int v94 = HIBYTE(v45) & 3;
            uint64_t v95 = v7;
            LODWORD(v49) = SBYTE1(v45);
            uint64_t v50 = SBYTE2(v45);
            if (!v12)
            {
              uint64_t v51 = v47 << 56;
              int64_t v52 = (unint64_t)HIWORD(v45) << 56;
              uint64_t v53 = v25 + ((uint64_t)SBYTE1(v45) << 32);
              uint64_t v54 = v33 + (v52 >> 24);
              uint64_t v55 = v10 & (v53 >> 63);
              uint64_t v56 = v11 & (v54 >> 63);
              uint64_t v57 = v56 + v54;
              if (v55 + v53 >= v10) {
                uint64_t v58 = v10;
              }
              else {
                uint64_t v58 = 0;
              }
              if (v57 >= v11) {
                uint64_t v59 = v11;
              }
              else {
                uint64_t v59 = 0;
              }
              uint64_t v49 = (v55 + (v51 >> 24) - v58) >> 32;
              uint64_t v50 = (v56 + (v52 >> 24) - v59) >> 32;
            }
            int v60 = 0xFFFF;
            int v61 = 0xFFFF;
            int v62 = 0xFFFF;
            if (v4)
            {
              uint64_t v63 = v50 << v101;
              unint64_t v64 = (unsigned __int16 *)(v42 + 2 * (v50 << v101) + v102);
              unint64_t v65 = *(void *)(result + 40);
              if (v15 < (unint64_t)v64) {
                unint64_t v64 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v64 < v65) {
                unint64_t v64 = *(unsigned __int16 **)(result + 40);
              }
              int v60 = *v64;
              unint64_t v66 = v42 + (int)v49 * (uint64_t)v103 + v102;
              if (v15 >= v66) {
                v67 = (unsigned __int16 *)(v42 + (int)v49 * (uint64_t)v103 + v102);
              }
              else {
                v67 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v67 < v65) {
                v67 = *(unsigned __int16 **)(result + 40);
              }
              int v61 = *v67;
              int v68 = (unsigned __int16 *)(v66 + 2 * v63);
              if (v15 < (unint64_t)v68) {
                int v68 = (unsigned __int16 *)v15;
              }
              if ((unint64_t)v68 < v65) {
                int v68 = *(unsigned __int16 **)(result + 40);
              }
              int v62 = *v68;
            }
            int v69 = interpolate_1616[v94];
            int v70 = (v45 >> 28) & 3;
            unsigned int v44 = v44
                - ((v69 & v44) >> (v94 + 1))
                + ((v69 & v61) >> (v94 + 1))
                - (((v44 - ((v69 & v44) >> (v94 + 1)) + ((v69 & v61) >> (v94 + 1))) & interpolate_1616[v70]) >> (v70 + 1))
                + (((v60 - ((v69 & v60) >> (v94 + 1)) + ((v69 & v62) >> (v94 + 1))) & interpolate_1616[v70]) >> (v70 + 1));
            uint64_t v7 = v95;
            break;
        }
      }
    }
    else
    {
      uint64_t v42 = 0;
      unsigned int v44 = 0xFFFF;
      if (v5) {
        goto LABEL_56;
      }
    }
    *(unsigned char *)(v13 + 1) = BYTE1(v44);
    *(unsigned char *)(v14 + 1) = v27 >> 22;
    if (a4 == 1) {
      return result;
    }
    uint64_t v83 = 0;
    a2 += v8;
    uint64_t v84 = v97 - a2;
    a3 += v9;
    uint64_t v85 = v98 - a3;
    while ((((a2 - v6) | v84 | (v16 + a3) | v85) & 0x8000000000000000) == 0)
    {
      if (v12)
      {
        uint64_t v86 = a2;
        HIDWORD(v87) = HIDWORD(a3);
        if (!v4) {
          goto LABEL_127;
        }
      }
      else
      {
        uint64_t v89 = (v10 & ((v25 + v99) >> 63)) + v25 + v99;
        uint64_t v90 = (v11 & ((v33 + v100) >> 63)) + v33 + v100;
        if (v89 >= v10) {
          uint64_t v91 = v10;
        }
        else {
          uint64_t v91 = 0;
        }
        uint64_t v87 = v89 - v91;
        if (v90 >= v11) {
          uint64_t v92 = v11;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v86 = v90 - v92;
        uint64_t v33 = v86;
        uint64_t v25 = v87;
        if (!v4)
        {
LABEL_127:
          unsigned int v44 = 0xFFFF;
          if (!v5) {
            goto LABEL_129;
          }
          goto LABEL_128;
        }
      }
      uint64_t v42 = v4 + SHIDWORD(v87) * (uint64_t)v103 + 2 * (v86 >> 32 << v101);
      v88 = (unsigned __int16 *)(v42 + v102);
      if (v15 < v42 + v102) {
        v88 = (unsigned __int16 *)v15;
      }
      if ((unint64_t)v88 < *(void *)(result + 40)) {
        v88 = *(unsigned __int16 **)(result + 40);
      }
      unsigned int v44 = *v88;
      if (!v5) {
        goto LABEL_129;
      }
LABEL_128:
      unsigned int v45 = *(_DWORD *)(v5 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
      if ((v45 & 0xF) != 0)
      {
        v14 += v83 + 1;
        v13 += v83 + 1;
        a4 += ~v83;
        unsigned int v27 = -1;
        goto LABEL_58;
      }
LABEL_129:
      *(unsigned char *)(v13 + v83 + 2) = BYTE1(v44);
      uint64_t v93 = v14 + v83++;
      *(unsigned char *)(v93 + 2) = -1;
      a2 += v8;
      v84 -= v8;
      a3 += v9;
      v85 -= v9;
      if (a4 - 1 == v83) {
        return result;
      }
    }
    v14 += v83 + 1;
    v13 += v83 + 1;
    a4 += ~v83;
    if (!a4) {
      return result;
    }
  }
  --a4;
  a2 += v8;
  a3 += v9;
  ++v13;
  *(unsigned char *)++uint64_t v14 = 0;
  if (a4) {
    goto LABEL_13;
  }
  return result;
}

uint64_t A8_sample_ALPHAF(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  uint64_t v5 = *(int *)(result + 28);
  if (v4)
  {
    uint64_t v6 = *(void *)(result + 176);
    uint64_t v7 = *(void *)(result + 64);
    uint64_t v8 = *(void *)(result + 72);
    uint64_t v99 = *(void *)(result + 88);
    uint64_t v9 = *(void *)(result + 112);
    uint64_t v10 = *(void *)(result + 120);
    uint64_t v12 = *(void *)(result + 48);
    uint64_t v11 = *(void *)(result + 56);
    BOOL v13 = v12 == 0;
    if (v12)
    {
      uint64_t v102 = *(void *)(result + 112);
      if (v9 > v12) {
        uint64_t v102 = v9 % v12;
      }
    }
    else
    {
      uint64_t v102 = 0;
    }
    uint64_t v97 = *(void *)(result + 80);
    if (v11)
    {
      if (v10 <= v11) {
        uint64_t v101 = *(void *)(result + 120);
      }
      else {
        uint64_t v101 = v10 % v11;
      }
    }
    else
    {
      uint64_t v101 = 0;
    }
  }
  else
  {
    uint64_t v101 = 0;
    uint64_t v102 = 0;
    uint64_t v12 = 0;
    uint64_t v6 = 0;
    uint64_t v11 = 0;
    uint64_t v7 = *(void *)(result + 64);
    uint64_t v8 = *(void *)(result + 72);
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v99 = *(void *)(result + 88);
    BOOL v13 = 1;
    uint64_t v9 = *(void *)(result + 112);
    uint64_t v10 = *(void *)(result + 120);
  }
  uint64_t v14 = *(void *)(result + 152) - 1;
  uint64_t v15 = *(void *)(result + 144) - 1;
  char v16 = *(unsigned char *)(result + 248);
  unint64_t v17 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 4 * ((*(_DWORD *)(result + 256) - 1) << v16);
  uint64_t v18 = 4 * *(_DWORD *)(result + 252);
  int v96 = *(_DWORD *)(result + 188);
  uint64_t v98 = v7;
  uint64_t v19 = -v7;
  uint64_t v100 = v8;
  uint64_t v20 = -v8;
  while (1)
  {
LABEL_13:
    if (a3 >= v100)
    {
      if (a3 <= v99)
      {
        uint64_t v29 = 0;
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        uint64_t v33 = v98;
      }
      else
      {
        uint64_t v25 = *(void *)(result + 216);
        uint64_t v26 = *(void *)(result + 224) + v99;
        uint64_t v27 = v26 - a3 + (v25 >> 1);
        if (v27 < 1) {
          break;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(result + 232) * v27) >> 32;
        }
        uint64_t v33 = v98;
        unsigned int v31 = v28 | v96;
        uint64_t v32 = v26 - 0x1000000;
        uint64_t v29 = a3 - (v26 - 0x1000000);
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(result + 216);
      uint64_t v22 = v100 - *(void *)(result + 224);
      uint64_t v23 = a3 - v22 + (v21 >> 1);
      if (v23 < 1) {
        break;
      }
      if (v23 >= v21) {
        LODWORD(v24) = 0x3FFFFFFF;
      }
      else {
        unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
      }
      uint64_t v33 = v98;
      unsigned int v31 = v24 | v96;
      uint64_t v32 = v22 + 0x1000000;
      uint64_t v29 = a3 - (v22 + 0x1000000);
      uint64_t v30 = 512;
    }
    if (a2 >= v33)
    {
      if (a2 <= v97)
      {
        uint64_t v38 = 0;
        uint64_t v39 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v37 = a2;
      }
      else
      {
        uint64_t v40 = *(void *)(result + 192);
        uint64_t v41 = *(void *)(result + 200) + v97;
        uint64_t v42 = v41 - a2 + (v40 >> 1);
        if (v42 < 1) {
          break;
        }
        if (v42 < v40) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v96;
        }
        uint64_t v37 = v41 - 0x1000000;
        uint64_t v38 = a2 - (v41 - 0x1000000);
        uint64_t v39 = 28;
      }
    }
    else
    {
      uint64_t v34 = *(void *)(result + 192);
      uint64_t v35 = v33 - *(void *)(result + 200);
      uint64_t v36 = a2 - v35 + (v34 >> 1);
      if (v36 < 1) {
        break;
      }
      if (v36 < v34) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v96;
      }
      uint64_t v37 = v35 + 0x1000000;
      uint64_t v38 = a2 - (v35 + 0x1000000);
      uint64_t v39 = 32;
    }
    if (v31 < 0x400000) {
      break;
    }
    if (!v13)
    {
      uint64_t v43 = (v11 & ((v32 % v11) >> 63)) + v32 % v11;
      uint64_t v44 = (v12 & ((v37 % v12) >> 63)) + v37 % v12;
      if (v43 >= v11) {
        uint64_t v45 = v11;
      }
      else {
        uint64_t v45 = 0;
      }
      uint64_t v32 = v43 - v45;
      if (v44 >= v12) {
        uint64_t v46 = v12;
      }
      else {
        uint64_t v46 = 0;
      }
      uint64_t v37 = v44 - v46;
      v29 += v32;
      v38 += v37;
    }
    if (v4)
    {
      uint64_t v47 = v4 + SHIDWORD(v32) * (uint64_t)(int)v5 + 4 * (v37 >> 32 << v16);
      int v48 = (unsigned int *)(v47 + v18);
      if (v17 < v47 + v18) {
        int v48 = (unsigned int *)v17;
      }
      if ((unint64_t)v48 < *(void *)(result + 40)) {
        int v48 = *(unsigned int **)(result + 40);
      }
      float v49 = COERCE_FLOAT(bswap32(*v48));
      if (!v6) {
        goto LABEL_106;
      }
    }
    else
    {
      uint64_t v47 = 0;
      float v49 = 1.0;
      if (!v6) {
        goto LABEL_106;
      }
    }
    unsigned int v50 = *(_DWORD *)(v6 + (v39 | v30));
LABEL_58:
    int v51 = v50 & 0xF;
    unsigned int v52 = v50 >> 8;
    unsigned int v53 = HIBYTE(v50) & 3;
    if (v51 == 1)
    {
      LODWORD(v72) = SBYTE1(v50);
      if (!v13)
      {
        uint64_t v73 = v29 + ((uint64_t)(char)v52 << 32);
        uint64_t v74 = v11 & (v73 >> 63);
        if (v74 + v73 >= v11) {
          uint64_t v75 = v11;
        }
        else {
          uint64_t v75 = 0;
        }
        uint64_t v72 = (v74 + ((uint64_t)(char)v52 << 32) - v75) >> 32;
      }
      float v76 = 1.0;
      if (v4)
      {
        uint64_t v77 = (unsigned int *)(v47 + (int)v72 * (uint64_t)(int)v5 + v18);
        if (v17 < (unint64_t)v77) {
          uint64_t v77 = (unsigned int *)v17;
        }
        if ((unint64_t)v77 < *(void *)(result + 40)) {
          uint64_t v77 = *(unsigned int **)(result + 40);
        }
        float v76 = COERCE_FLOAT(bswap32(*v77));
      }
      float v78 = interpolate_af[v53];
    }
    else
    {
      if (v51 != 2)
      {
        if (v51 == 3)
        {
          LODWORD(v54) = SBYTE1(v50);
          uint64_t v55 = SBYTE2(v50);
          if (!v13)
          {
            uint64_t v56 = v29 + ((uint64_t)SBYTE1(v50) << 32);
            uint64_t v57 = v38 + ((uint64_t)SBYTE2(v50) << 32);
            uint64_t v95 = v5;
            uint64_t v58 = v11 & (v56 >> 63);
            uint64_t v59 = v12 & (v57 >> 63);
            uint64_t v60 = v59 + v57;
            if (v58 + v56 >= v11) {
              uint64_t v61 = v11;
            }
            else {
              uint64_t v61 = 0;
            }
            if (v60 >= v12) {
              uint64_t v62 = v12;
            }
            else {
              uint64_t v62 = 0;
            }
            uint64_t v63 = v58 + ((uint64_t)SBYTE1(v50) << 32);
            uint64_t v5 = v95;
            uint64_t v54 = (v63 - v61) >> 32;
            uint64_t v55 = (v59 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v62) >> 32;
          }
          float v64 = 1.0;
          float v65 = 1.0;
          if (v4)
          {
            unint64_t v66 = (unsigned int *)(v47 + 4 * (v55 << v16) + v18);
            unint64_t v67 = *(void *)(result + 40);
            if (v17 >= (unint64_t)v66) {
              int v68 = v66;
            }
            else {
              int v68 = (unsigned int *)v17;
            }
            if ((unint64_t)v68 < v67) {
              int v68 = *(unsigned int **)(result + 40);
            }
            float v64 = COERCE_FLOAT(bswap32(*v68));
            int v69 = (unsigned int *)((char *)v66 + (int)v54 * (uint64_t)(int)v5);
            if (v17 < (unint64_t)v69) {
              int v69 = (unsigned int *)v17;
            }
            if ((unint64_t)v69 < v67) {
              int v69 = *(unsigned int **)(result + 40);
            }
            float v65 = COERCE_FLOAT(bswap32(*v69));
          }
          float v70 = interpolate_af[HIBYTE(v50) & 3];
          float v71 = interpolate_af[(v50 >> 28) & 3];
          float v49 = (float)((float)((float)(v49 - (float)(v49 * v70)) + (float)(v64 * v70))
                      - (float)((float)((float)(v49 - (float)(v49 * v70)) + (float)(v64 * v70)) * v71))
              + (float)((float)((float)(v64 - (float)(v64 * v70)) + (float)(v65 * v70)) * v71);
        }
        goto LABEL_106;
      }
      uint64_t v79 = SBYTE2(v50);
      if (!v13)
      {
        uint64_t v80 = v38 + ((uint64_t)SBYTE2(v50) << 32);
        uint64_t v81 = v12 & (v80 >> 63);
        if (v81 + v80 >= v12) {
          uint64_t v82 = v12;
        }
        else {
          uint64_t v82 = 0;
        }
        uint64_t v79 = (v81 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v82) >> 32;
      }
      float v76 = 1.0;
      if (v4)
      {
        uint64_t v83 = (unsigned int *)(v47 + 4 * (v79 << v16) + v18);
        if (v17 < (unint64_t)v83) {
          uint64_t v83 = (unsigned int *)v17;
        }
        if ((unint64_t)v83 < *(void *)(result + 40)) {
          uint64_t v83 = *(unsigned int **)(result + 40);
        }
        float v76 = COERCE_FLOAT(bswap32(*v83));
      }
      float v78 = interpolate_af[(v50 >> 28) & 3];
    }
    float v49 = (float)(v49 - (float)(v49 * v78)) + (float)(v76 * v78);
LABEL_106:
    *(unsigned char *)(v14 + 1) = (int)((float)(v49 * 255.0) + 0.5);
    *(unsigned char *)(v15 + 1) = v31 >> 22;
    if (a4 == 1) {
      return result;
    }
    uint64_t v84 = 0;
    a2 += v9;
    uint64_t v85 = v97 - a2;
    a3 += v10;
    uint64_t v86 = v99 - a3;
    while ((((v19 + a2) | v85 | (v20 + a3) | v86) & 0x8000000000000000) == 0)
    {
      if (v13)
      {
        uint64_t v87 = a2;
        HIDWORD(v88) = HIDWORD(a3);
        if (!v4) {
          goto LABEL_124;
        }
      }
      else
      {
        uint64_t v90 = (v11 & ((v29 + v101) >> 63)) + v29 + v101;
        uint64_t v91 = (v12 & ((v38 + v102) >> 63)) + v38 + v102;
        if (v90 >= v11) {
          uint64_t v92 = v11;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v88 = v90 - v92;
        if (v91 >= v12) {
          uint64_t v93 = v12;
        }
        else {
          uint64_t v93 = 0;
        }
        uint64_t v87 = v91 - v93;
        uint64_t v38 = v87;
        uint64_t v29 = v88;
        if (!v4)
        {
LABEL_124:
          float v49 = 1.0;
          if (!v6) {
            goto LABEL_126;
          }
          goto LABEL_125;
        }
      }
      uint64_t v47 = v4 + SHIDWORD(v88) * (uint64_t)(int)v5 + 4 * (v87 >> 32 << v16);
      uint64_t v89 = (unsigned int *)(v47 + v18);
      if (v17 < v47 + v18) {
        uint64_t v89 = (unsigned int *)v17;
      }
      if ((unint64_t)v89 < *(void *)(result + 40)) {
        uint64_t v89 = *(unsigned int **)(result + 40);
      }
      float v49 = COERCE_FLOAT(bswap32(*v89));
      if (!v6) {
        goto LABEL_126;
      }
LABEL_125:
      unsigned int v50 = *(_DWORD *)(v6 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
      if ((v50 & 0xF) != 0)
      {
        v15 += v84 + 1;
        v14 += v84 + 1;
        a4 += ~v84;
        unsigned int v31 = -1;
        goto LABEL_58;
      }
LABEL_126:
      *(unsigned char *)(v14 + v84 + 2) = (int)((float)(v49 * 255.0) + 0.5);
      uint64_t v94 = v15 + v84++;
      a2 += v9;
      *(unsigned char *)(v94 + 2) = -1;
      v85 -= v9;
      a3 += v10;
      v86 -= v10;
      if (a4 - 1 == v84) {
        return result;
      }
    }
    v15 += v84 + 1;
    v14 += v84 + 1;
    a4 += ~v84;
    if (!a4) {
      return result;
    }
  }
  --a4;
  a2 += v9;
  a3 += v10;
  ++v14;
  *(unsigned char *)++uint64_t v15 = 0;
  if (a4) {
    goto LABEL_13;
  }
  return result;
}

uint64_t A8_sample_ALPHAf(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  uint64_t v5 = *(int *)(result + 28);
  if (v4)
  {
    uint64_t v6 = *(void *)(result + 176);
    uint64_t v7 = *(void *)(result + 64);
    uint64_t v8 = *(void *)(result + 72);
    uint64_t v99 = *(void *)(result + 88);
    uint64_t v9 = *(void *)(result + 112);
    uint64_t v10 = *(void *)(result + 120);
    uint64_t v12 = *(void *)(result + 48);
    uint64_t v11 = *(void *)(result + 56);
    BOOL v13 = v12 == 0;
    if (v12)
    {
      uint64_t v102 = *(void *)(result + 112);
      if (v9 > v12) {
        uint64_t v102 = v9 % v12;
      }
    }
    else
    {
      uint64_t v102 = 0;
    }
    uint64_t v97 = *(void *)(result + 80);
    if (v11)
    {
      if (v10 <= v11) {
        uint64_t v101 = *(void *)(result + 120);
      }
      else {
        uint64_t v101 = v10 % v11;
      }
    }
    else
    {
      uint64_t v101 = 0;
    }
  }
  else
  {
    uint64_t v101 = 0;
    uint64_t v102 = 0;
    uint64_t v12 = 0;
    uint64_t v6 = 0;
    uint64_t v11 = 0;
    uint64_t v7 = *(void *)(result + 64);
    uint64_t v8 = *(void *)(result + 72);
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v99 = *(void *)(result + 88);
    BOOL v13 = 1;
    uint64_t v9 = *(void *)(result + 112);
    uint64_t v10 = *(void *)(result + 120);
  }
  uint64_t v14 = *(void *)(result + 152) - 1;
  uint64_t v15 = *(void *)(result + 144) - 1;
  char v16 = *(unsigned char *)(result + 248);
  unint64_t v17 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 4 * ((*(_DWORD *)(result + 256) - 1) << v16);
  uint64_t v18 = 4 * *(_DWORD *)(result + 252);
  int v96 = *(_DWORD *)(result + 188);
  uint64_t v98 = v7;
  uint64_t v19 = -v7;
  uint64_t v100 = v8;
  uint64_t v20 = -v8;
  while (1)
  {
LABEL_13:
    if (a3 >= v100)
    {
      if (a3 <= v99)
      {
        uint64_t v29 = 0;
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        uint64_t v33 = v98;
      }
      else
      {
        uint64_t v25 = *(void *)(result + 216);
        uint64_t v26 = *(void *)(result + 224) + v99;
        uint64_t v27 = v26 - a3 + (v25 >> 1);
        if (v27 < 1) {
          break;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(result + 232) * v27) >> 32;
        }
        uint64_t v33 = v98;
        unsigned int v31 = v28 | v96;
        uint64_t v32 = v26 - 0x1000000;
        uint64_t v29 = a3 - (v26 - 0x1000000);
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(result + 216);
      uint64_t v22 = v100 - *(void *)(result + 224);
      uint64_t v23 = a3 - v22 + (v21 >> 1);
      if (v23 < 1) {
        break;
      }
      if (v23 >= v21) {
        LODWORD(v24) = 0x3FFFFFFF;
      }
      else {
        unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
      }
      uint64_t v33 = v98;
      unsigned int v31 = v24 | v96;
      uint64_t v32 = v22 + 0x1000000;
      uint64_t v29 = a3 - (v22 + 0x1000000);
      uint64_t v30 = 512;
    }
    if (a2 >= v33)
    {
      if (a2 <= v97)
      {
        uint64_t v38 = 0;
        uint64_t v39 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v37 = a2;
      }
      else
      {
        uint64_t v40 = *(void *)(result + 192);
        uint64_t v41 = *(void *)(result + 200) + v97;
        uint64_t v42 = v41 - a2 + (v40 >> 1);
        if (v42 < 1) {
          break;
        }
        if (v42 < v40) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v96;
        }
        uint64_t v37 = v41 - 0x1000000;
        uint64_t v38 = a2 - (v41 - 0x1000000);
        uint64_t v39 = 28;
      }
    }
    else
    {
      uint64_t v34 = *(void *)(result + 192);
      uint64_t v35 = v33 - *(void *)(result + 200);
      uint64_t v36 = a2 - v35 + (v34 >> 1);
      if (v36 < 1) {
        break;
      }
      if (v36 < v34) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v96;
      }
      uint64_t v37 = v35 + 0x1000000;
      uint64_t v38 = a2 - (v35 + 0x1000000);
      uint64_t v39 = 32;
    }
    if (v31 < 0x400000) {
      break;
    }
    if (!v13)
    {
      uint64_t v43 = (v11 & ((v32 % v11) >> 63)) + v32 % v11;
      uint64_t v44 = (v12 & ((v37 % v12) >> 63)) + v37 % v12;
      if (v43 >= v11) {
        uint64_t v45 = v11;
      }
      else {
        uint64_t v45 = 0;
      }
      uint64_t v32 = v43 - v45;
      if (v44 >= v12) {
        uint64_t v46 = v12;
      }
      else {
        uint64_t v46 = 0;
      }
      uint64_t v37 = v44 - v46;
      v29 += v32;
      v38 += v37;
    }
    if (v4)
    {
      uint64_t v47 = v4 + SHIDWORD(v32) * (uint64_t)(int)v5 + 4 * (v37 >> 32 << v16);
      int v48 = (float *)(v47 + v18);
      if (v17 < v47 + v18) {
        int v48 = (float *)v17;
      }
      if ((unint64_t)v48 < *(void *)(result + 40)) {
        int v48 = *(float **)(result + 40);
      }
      float v49 = *v48;
      if (!v6) {
        goto LABEL_106;
      }
    }
    else
    {
      uint64_t v47 = 0;
      float v49 = 1.0;
      if (!v6) {
        goto LABEL_106;
      }
    }
    unsigned int v50 = *(_DWORD *)(v6 + (v39 | v30));
LABEL_58:
    int v51 = v50 & 0xF;
    unsigned int v52 = v50 >> 8;
    int v53 = HIBYTE(v50) & 3;
    if (v51 == 1)
    {
      LODWORD(v72) = SBYTE1(v50);
      if (!v13)
      {
        uint64_t v73 = v29 + ((uint64_t)(char)v52 << 32);
        uint64_t v74 = v11 & (v73 >> 63);
        if (v74 + v73 >= v11) {
          uint64_t v75 = v11;
        }
        else {
          uint64_t v75 = 0;
        }
        uint64_t v72 = (v74 + ((uint64_t)(char)v52 << 32) - v75) >> 32;
      }
      float v76 = 1.0;
      if (v4)
      {
        uint64_t v77 = (float *)(v47 + (int)v72 * (uint64_t)(int)v5 + v18);
        if (v17 < (unint64_t)v77) {
          uint64_t v77 = (float *)v17;
        }
        if ((unint64_t)v77 < *(void *)(result + 40)) {
          uint64_t v77 = *(float **)(result + 40);
        }
        float v76 = *v77;
      }
      float v78 = interpolate_af[v53];
    }
    else
    {
      if (v51 != 2)
      {
        if (v51 == 3)
        {
          LODWORD(v54) = SBYTE1(v50);
          uint64_t v55 = SBYTE2(v50);
          if (!v13)
          {
            uint64_t v56 = v29 + ((uint64_t)SBYTE1(v50) << 32);
            uint64_t v57 = v38 + ((uint64_t)SBYTE2(v50) << 32);
            uint64_t v95 = v5;
            uint64_t v58 = v11 & (v56 >> 63);
            uint64_t v59 = v12 & (v57 >> 63);
            uint64_t v60 = v59 + v57;
            if (v58 + v56 >= v11) {
              uint64_t v61 = v11;
            }
            else {
              uint64_t v61 = 0;
            }
            if (v60 >= v12) {
              uint64_t v62 = v12;
            }
            else {
              uint64_t v62 = 0;
            }
            uint64_t v63 = v58 + ((uint64_t)SBYTE1(v50) << 32);
            uint64_t v5 = v95;
            uint64_t v54 = (v63 - v61) >> 32;
            uint64_t v55 = (v59 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v62) >> 32;
          }
          float v64 = 1.0;
          float v65 = 1.0;
          if (v4)
          {
            unint64_t v66 = (float *)(v47 + 4 * (v55 << v16) + v18);
            unint64_t v67 = *(void *)(result + 40);
            if (v17 >= (unint64_t)v66) {
              int v68 = v66;
            }
            else {
              int v68 = (float *)v17;
            }
            if ((unint64_t)v68 < v67) {
              int v68 = *(float **)(result + 40);
            }
            float v64 = *v68;
            int v69 = (float *)((char *)v66 + (int)v54 * (uint64_t)(int)v5);
            if (v17 < (unint64_t)v69) {
              int v69 = (float *)v17;
            }
            if ((unint64_t)v69 < v67) {
              int v69 = *(float **)(result + 40);
            }
            float v65 = *v69;
          }
          float v70 = interpolate_af[HIBYTE(v50) & 3];
          float v71 = interpolate_af[(v50 >> 28) & 3];
          float v49 = (float)((float)((float)(v49 - (float)(v49 * v70)) + (float)(v64 * v70))
                      - (float)((float)((float)(v49 - (float)(v49 * v70)) + (float)(v64 * v70)) * v71))
              + (float)((float)((float)(v64 - (float)(v64 * v70)) + (float)(v65 * v70)) * v71);
        }
        goto LABEL_106;
      }
      uint64_t v79 = SBYTE2(v50);
      if (!v13)
      {
        uint64_t v80 = v38 + ((uint64_t)SBYTE2(v50) << 32);
        uint64_t v81 = v12 & (v80 >> 63);
        if (v81 + v80 >= v12) {
          uint64_t v82 = v12;
        }
        else {
          uint64_t v82 = 0;
        }
        uint64_t v79 = (v81 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v82) >> 32;
      }
      float v76 = 1.0;
      if (v4)
      {
        uint64_t v83 = (float *)(v47 + 4 * (v79 << v16) + v18);
        if (v17 < (unint64_t)v83) {
          uint64_t v83 = (float *)v17;
        }
        if ((unint64_t)v83 < *(void *)(result + 40)) {
          uint64_t v83 = *(float **)(result + 40);
        }
        float v76 = *v83;
      }
      float v78 = interpolate_af[(v50 >> 28) & 3];
    }
    float v49 = (float)(v49 - (float)(v49 * v78)) + (float)(v76 * v78);
LABEL_106:
    *(unsigned char *)(v14 + 1) = (int)((float)(v49 * 255.0) + 0.5);
    *(unsigned char *)(v15 + 1) = v31 >> 22;
    if (a4 == 1) {
      return result;
    }
    uint64_t v84 = 0;
    a2 += v9;
    uint64_t v85 = v97 - a2;
    a3 += v10;
    uint64_t v86 = v99 - a3;
    while ((((v19 + a2) | v85 | (v20 + a3) | v86) & 0x8000000000000000) == 0)
    {
      if (v13)
      {
        uint64_t v87 = a2;
        HIDWORD(v88) = HIDWORD(a3);
        if (!v4) {
          goto LABEL_124;
        }
      }
      else
      {
        uint64_t v90 = (v11 & ((v29 + v101) >> 63)) + v29 + v101;
        uint64_t v91 = (v12 & ((v38 + v102) >> 63)) + v38 + v102;
        if (v90 >= v11) {
          uint64_t v92 = v11;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v88 = v90 - v92;
        if (v91 >= v12) {
          uint64_t v93 = v12;
        }
        else {
          uint64_t v93 = 0;
        }
        uint64_t v87 = v91 - v93;
        uint64_t v38 = v87;
        uint64_t v29 = v88;
        if (!v4)
        {
LABEL_124:
          float v49 = 1.0;
          if (!v6) {
            goto LABEL_126;
          }
          goto LABEL_125;
        }
      }
      uint64_t v47 = v4 + SHIDWORD(v88) * (uint64_t)(int)v5 + 4 * (v87 >> 32 << v16);
      uint64_t v89 = (float *)(v47 + v18);
      if (v17 < v47 + v18) {
        uint64_t v89 = (float *)v17;
      }
      if ((unint64_t)v89 < *(void *)(result + 40)) {
        uint64_t v89 = *(float **)(result + 40);
      }
      float v49 = *v89;
      if (!v6) {
        goto LABEL_126;
      }
LABEL_125:
      unsigned int v50 = *(_DWORD *)(v6 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
      if ((v50 & 0xF) != 0)
      {
        v15 += v84 + 1;
        v14 += v84 + 1;
        a4 += ~v84;
        unsigned int v31 = -1;
        goto LABEL_58;
      }
LABEL_126:
      *(unsigned char *)(v14 + v84 + 2) = (int)((float)(v49 * 255.0) + 0.5);
      uint64_t v94 = v15 + v84++;
      a2 += v9;
      *(unsigned char *)(v94 + 2) = -1;
      v85 -= v9;
      a3 += v10;
      v86 -= v10;
      if (a4 - 1 == v84) {
        return result;
      }
    }
    v15 += v84 + 1;
    v14 += v84 + 1;
    a4 += ~v84;
    if (!a4) {
      return result;
    }
  }
  --a4;
  a2 += v9;
  a3 += v10;
  ++v14;
  *(unsigned char *)++uint64_t v15 = 0;
  if (a4) {
    goto LABEL_13;
  }
  return result;
}

uint64_t A8_sample_ALPHAf16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  uint64_t v5 = *(int *)(result + 28);
  if (v4)
  {
    uint64_t v6 = *(void *)(result + 176);
    uint64_t v7 = *(void *)(result + 64);
    uint64_t v8 = *(void *)(result + 72);
    uint64_t v111 = *(void *)(result + 88);
    uint64_t v9 = *(void *)(result + 112);
    uint64_t v10 = *(void *)(result + 120);
    uint64_t v12 = *(void *)(result + 48);
    uint64_t v11 = *(void *)(result + 56);
    BOOL v13 = v12 == 0;
    if (v12)
    {
      uint64_t v114 = *(void *)(result + 112);
      if (v9 > v12) {
        uint64_t v114 = v9 % v12;
      }
    }
    else
    {
      uint64_t v114 = 0;
    }
    uint64_t v109 = *(void *)(result + 80);
    if (v11)
    {
      if (v10 <= v11) {
        uint64_t v113 = *(void *)(result + 120);
      }
      else {
        uint64_t v113 = v10 % v11;
      }
    }
    else
    {
      uint64_t v113 = 0;
    }
  }
  else
  {
    uint64_t v113 = 0;
    uint64_t v114 = 0;
    uint64_t v12 = 0;
    uint64_t v6 = 0;
    uint64_t v11 = 0;
    uint64_t v7 = *(void *)(result + 64);
    uint64_t v8 = *(void *)(result + 72);
    uint64_t v109 = *(void *)(result + 80);
    uint64_t v111 = *(void *)(result + 88);
    BOOL v13 = 1;
    uint64_t v9 = *(void *)(result + 112);
    uint64_t v10 = *(void *)(result + 120);
  }
  uint64_t v14 = *(void *)(result + 152) - 1;
  uint64_t v15 = *(void *)(result + 144) - 1;
  char v16 = *(unsigned char *)(result + 248);
  unint64_t v17 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * ((*(_DWORD *)(result + 256) - 1) << v16);
  uint64_t v18 = 2 * *(_DWORD *)(result + 252);
  int v108 = *(_DWORD *)(result + 188);
  uint64_t v110 = v7;
  uint64_t v19 = -v7;
  uint64_t v112 = v8;
  uint64_t v20 = -v8;
  while (1)
  {
LABEL_13:
    if (a3 >= v112)
    {
      if (a3 <= v111)
      {
        uint64_t v29 = 0;
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        uint64_t v33 = v110;
      }
      else
      {
        uint64_t v25 = *(void *)(result + 216);
        uint64_t v26 = *(void *)(result + 224) + v111;
        uint64_t v27 = v26 - a3 + (v25 >> 1);
        if (v27 < 1) {
          break;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(result + 232) * v27) >> 32;
        }
        uint64_t v33 = v110;
        unsigned int v31 = v28 | v108;
        uint64_t v32 = v26 - 0x1000000;
        uint64_t v29 = a3 - (v26 - 0x1000000);
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(result + 216);
      uint64_t v22 = v112 - *(void *)(result + 224);
      uint64_t v23 = a3 - v22 + (v21 >> 1);
      if (v23 < 1) {
        break;
      }
      if (v23 >= v21) {
        LODWORD(v24) = 0x3FFFFFFF;
      }
      else {
        unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
      }
      uint64_t v33 = v110;
      unsigned int v31 = v24 | v108;
      uint64_t v32 = v22 + 0x1000000;
      uint64_t v29 = a3 - (v22 + 0x1000000);
      uint64_t v30 = 512;
    }
    if (a2 >= v33)
    {
      if (a2 <= v109)
      {
        uint64_t v38 = 0;
        uint64_t v39 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v37 = a2;
      }
      else
      {
        uint64_t v40 = *(void *)(result + 192);
        uint64_t v41 = *(void *)(result + 200) + v109;
        uint64_t v42 = v41 - a2 + (v40 >> 1);
        if (v42 < 1) {
          break;
        }
        if (v42 < v40) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v108;
        }
        uint64_t v37 = v41 - 0x1000000;
        uint64_t v38 = a2 - (v41 - 0x1000000);
        uint64_t v39 = 28;
      }
    }
    else
    {
      uint64_t v34 = *(void *)(result + 192);
      uint64_t v35 = v33 - *(void *)(result + 200);
      uint64_t v36 = a2 - v35 + (v34 >> 1);
      if (v36 < 1) {
        break;
      }
      if (v36 < v34) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v108;
      }
      uint64_t v37 = v35 + 0x1000000;
      uint64_t v38 = a2 - (v35 + 0x1000000);
      uint64_t v39 = 32;
    }
    if (v31 < 0x400000) {
      break;
    }
    if (!v13)
    {
      uint64_t v43 = (v11 & ((v32 % v11) >> 63)) + v32 % v11;
      uint64_t v44 = (v12 & ((v37 % v12) >> 63)) + v37 % v12;
      if (v43 >= v11) {
        uint64_t v45 = v11;
      }
      else {
        uint64_t v45 = 0;
      }
      uint64_t v32 = v43 - v45;
      if (v44 >= v12) {
        uint64_t v46 = v12;
      }
      else {
        uint64_t v46 = 0;
      }
      uint64_t v37 = v44 - v46;
      v29 += v32;
      v38 += v37;
    }
    if (v4)
    {
      uint64_t v47 = v4 + SHIDWORD(v32) * (uint64_t)(int)v5 + 2 * (v37 >> 32 << v16);
      int v48 = (__int16 *)(v47 + v18);
      if (v17 < v47 + v18) {
        int v48 = (__int16 *)v17;
      }
      if ((unint64_t)v48 < *(void *)(result + 40)) {
        int v48 = *(__int16 **)(result + 40);
      }
      _H1 = *v48;
      if (!v6) {
        goto LABEL_107;
      }
    }
    else
    {
      uint64_t v47 = 0;
      _H1 = COERCE_UNSIGNED_INT(1.0);
      if (!v6) {
        goto LABEL_107;
      }
    }
    unsigned int v50 = *(_DWORD *)(v6 + (v39 | v30));
LABEL_58:
    int v51 = v50 & 0xF;
    unsigned int v52 = v50 >> 8;
    int v53 = HIBYTE(v50) & 3;
    switch(v51)
    {
      case 1:
        LODWORD(v80) = SBYTE1(v50);
        if (!v13)
        {
          uint64_t v81 = v29 + ((uint64_t)(char)v52 << 32);
          uint64_t v82 = v11 & (v81 >> 63);
          if (v82 + v81 >= v11) {
            uint64_t v83 = v11;
          }
          else {
            uint64_t v83 = 0;
          }
          uint64_t v80 = (v82 + ((uint64_t)(char)v52 << 32) - v83) >> 32;
        }
        _H2 = COERCE_UNSIGNED_INT(1.0);
        if (v4)
        {
          uint64_t v85 = (__int16 *)(v47 + (int)v80 * (uint64_t)(int)v5 + v18);
          if (v17 < (unint64_t)v85) {
            uint64_t v85 = (__int16 *)v17;
          }
          if ((unint64_t)v85 < *(void *)(result + 40)) {
            uint64_t v85 = *(__int16 **)(result + 40);
          }
          _H2 = *v85;
        }
        float v86 = interpolate_af[v53];
LABEL_105:
        __asm
        {
          FCVT            S1, H1
          FCVT            S2, H2
        }
        _S1 = (float)(_S1 - (float)(_S1 * v86)) + (float)(_S2 * v86);
LABEL_106:
        __asm { FCVT            H1, S1 }
        break;
      case 2:
        uint64_t v87 = SBYTE2(v50);
        if (!v13)
        {
          uint64_t v88 = v38 + ((uint64_t)SBYTE2(v50) << 32);
          uint64_t v89 = v12 & (v88 >> 63);
          if (v89 + v88 >= v12) {
            uint64_t v90 = v12;
          }
          else {
            uint64_t v90 = 0;
          }
          uint64_t v87 = (v89 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v90) >> 32;
        }
        _H2 = COERCE_UNSIGNED_INT(1.0);
        if (v4)
        {
          uint64_t v91 = (__int16 *)(v47 + 2 * (v87 << v16) + v18);
          if (v17 < (unint64_t)v91) {
            uint64_t v91 = (__int16 *)v17;
          }
          if ((unint64_t)v91 < *(void *)(result + 40)) {
            uint64_t v91 = *(__int16 **)(result + 40);
          }
          _H2 = *v91;
        }
        float v86 = interpolate_af[(v50 >> 28) & 3];
        goto LABEL_105;
      case 3:
        LODWORD(v54) = SBYTE1(v50);
        uint64_t v55 = SBYTE2(v50);
        if (!v13)
        {
          uint64_t v56 = v29 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v57 = v38 + ((uint64_t)SBYTE2(v50) << 32);
          uint64_t v107 = v5;
          uint64_t v58 = v11 & (v56 >> 63);
          uint64_t v59 = v12 & (v57 >> 63);
          uint64_t v60 = v59 + v57;
          if (v58 + v56 >= v11) {
            uint64_t v61 = v11;
          }
          else {
            uint64_t v61 = 0;
          }
          if (v60 >= v12) {
            uint64_t v62 = v12;
          }
          else {
            uint64_t v62 = 0;
          }
          uint64_t v63 = v58 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v5 = v107;
          uint64_t v54 = (v63 - v61) >> 32;
          uint64_t v55 = (v59 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v62) >> 32;
        }
        _H2 = COERCE_UNSIGNED_INT(1.0);
        _H3 = COERCE_UNSIGNED_INT(1.0);
        if (v4)
        {
          unint64_t v66 = (__int16 *)(v47 + 2 * (v55 << v16) + v18);
          unint64_t v67 = *(void *)(result + 40);
          if (v17 >= (unint64_t)v66) {
            int v68 = v66;
          }
          else {
            int v68 = (__int16 *)v17;
          }
          if ((unint64_t)v68 < v67) {
            int v68 = *(__int16 **)(result + 40);
          }
          _H2 = *v68;
          int v69 = (__int16 *)((char *)v66 + (int)v54 * (uint64_t)(int)v5);
          if (v17 < (unint64_t)v69) {
            int v69 = (__int16 *)v17;
          }
          if ((unint64_t)v69 < v67) {
            int v69 = *(__int16 **)(result + 40);
          }
          _H3 = *v69;
        }
        float v70 = interpolate_af[HIBYTE(v50) & 3];
        float v71 = interpolate_af[(v50 >> 28) & 3];
        __asm
        {
          FCVT            S1, H1
          FCVT            S2, H2
          FCVT            S3, H3
        }
        _S1 = (float)((float)((float)(_S1 - (float)(_S1 * v70)) + (float)(_S2 * v70))
                    - (float)((float)((float)(_S1 - (float)(_S1 * v70)) + (float)(_S2 * v70)) * v71))
            + (float)((float)((float)(_S2 - (float)(_S2 * v70)) + (float)(_S3 * v70)) * v71);
        goto LABEL_106;
    }
LABEL_107:
    __asm { FCVT            S1, H1 }
    *(unsigned char *)(v14 + 1) = (int)((float)(_S1 * 255.0) + 0.5);
    *(unsigned char *)(v15 + 1) = v31 >> 22;
    if (a4 == 1) {
      return result;
    }
    uint64_t v95 = 0;
    a2 += v9;
    uint64_t v96 = v109 - a2;
    a3 += v10;
    uint64_t v97 = v111 - a3;
    while ((((v19 + a2) | v96 | (v20 + a3) | v97) & 0x8000000000000000) == 0)
    {
      if (v13)
      {
        uint64_t v98 = a2;
        HIDWORD(v99) = HIDWORD(a3);
        if (!v4) {
          goto LABEL_125;
        }
      }
      else
      {
        uint64_t v101 = (v11 & ((v29 + v113) >> 63)) + v29 + v113;
        uint64_t v102 = (v12 & ((v38 + v114) >> 63)) + v38 + v114;
        if (v101 >= v11) {
          uint64_t v103 = v11;
        }
        else {
          uint64_t v103 = 0;
        }
        uint64_t v99 = v101 - v103;
        if (v102 >= v12) {
          uint64_t v104 = v12;
        }
        else {
          uint64_t v104 = 0;
        }
        uint64_t v98 = v102 - v104;
        uint64_t v38 = v98;
        uint64_t v29 = v99;
        if (!v4)
        {
LABEL_125:
          _H1 = COERCE_UNSIGNED_INT(1.0);
          if (!v6) {
            goto LABEL_127;
          }
          goto LABEL_126;
        }
      }
      uint64_t v47 = v4 + SHIDWORD(v99) * (uint64_t)(int)v5 + 2 * (v98 >> 32 << v16);
      uint64_t v100 = (__int16 *)(v47 + v18);
      if (v17 < v47 + v18) {
        uint64_t v100 = (__int16 *)v17;
      }
      if ((unint64_t)v100 < *(void *)(result + 40)) {
        uint64_t v100 = *(__int16 **)(result + 40);
      }
      _H1 = *v100;
      if (!v6) {
        goto LABEL_127;
      }
LABEL_126:
      unsigned int v50 = *(_DWORD *)(v6 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
      if ((v50 & 0xF) != 0)
      {
        v15 += v95 + 1;
        v14 += v95 + 1;
        a4 += ~v95;
        unsigned int v31 = -1;
        goto LABEL_58;
      }
LABEL_127:
      __asm { FCVT            S1, H1 }
      *(unsigned char *)(v14 + v95 + 2) = (int)((float)(_S1 * 255.0) + 0.5);
      uint64_t v106 = v15 + v95++;
      a2 += v9;
      *(unsigned char *)(v106 + 2) = -1;
      v96 -= v9;
      a3 += v10;
      v97 -= v10;
      if (a4 - 1 == v95) {
        return result;
      }
    }
    v15 += v95 + 1;
    v14 += v95 + 1;
    a4 += ~v95;
    if (!a4) {
      return result;
    }
  }
  --a4;
  a2 += v9;
  a3 += v10;
  ++v14;
  *(unsigned char *)++uint64_t v15 = 0;
  if (a4) {
    goto LABEL_13;
  }
  return result;
}

uint64_t A8_mark_pixelmask(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 136);
  if (!v2) {
    return result;
  }
  int v3 = *(_DWORD *)(result + 4);
  int v4 = *(_DWORD *)(result + 8);
  uint64_t v5 = v3;
  uint64_t v6 = *(int *)(result + 28);
  uint64_t v8 = *(unsigned char **)(result + 88);
  uint64_t v7 = *(void *)(result + 96);
  unint64_t v9 = *(void *)(result + 40) + *(int *)(result + 12) + *(int *)(result + 16) * (uint64_t)(int)v6;
  uint64_t v10 = *(int *)(result + 124);
  uint64_t v11 = v2 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v10;
  uint64_t v13 = *(int *)(result + 56);
  int v12 = *(_DWORD *)(result + 60);
  uint64_t v14 = *(int *)(result + 76);
  if (*(unsigned __int8 *)(result + 1) << 8 == 256)
  {
    v8 += v13 + (int)v14 * (uint64_t)v12;
    if (v14 == v6 && (uint64_t)(v9 - (void)v8) >= 1)
    {
      if ((uint64_t)(v9 - (void)v8) <= v3)
      {
        uint64_t v64 = v3 - 1;
        v9 += v64;
        v8 += v64;
        v11 += v64;
        int v17 = -1;
        goto LABEL_8;
      }
      uint64_t v15 = v4 - 1;
      char v16 = &v8[v14 * v15];
      if (v9 <= (unint64_t)&v16[v3 - 1])
      {
        v9 += v6 * v15;
        uint64_t v6 = -v6;
        uint64_t v14 = -v14;
        v11 += v10 * v15;
        uint64_t v10 = -v10;
        int v17 = 1;
        uint64_t v8 = v16;
        goto LABEL_8;
      }
    }
    int v17 = 1;
LABEL_8:
    int v18 = 0;
    uint64_t v5 = v17 * v3;
    BOOL v19 = v7 != 0;
    uint64_t v20 = v10 - v5;
    uint64_t v21 = v6 - v5;
    unint64_t v22 = -1;
    int v23 = v14;
    goto LABEL_12;
  }
  int v23 = *(_DWORD *)(result + 64);
  int v18 = *(_DWORD *)(result + 68);
  BOOL v19 = v7 != 0;
  uint64_t v20 = v10 - v3;
  uint64_t v21 = v6 - v3;
  if (v8)
  {
    int v24 = 0;
    uint64_t v25 = &v8[v18 * (uint64_t)(int)v14];
    uint64_t v26 = &v8[(int)v14 * (uint64_t)(v12 % v18)];
    uint64_t v8 = &v26[(int)v13 % v23];
    unint64_t v22 = (unint64_t)&v26[v23];
    int v17 = 1;
    uint64_t v27 = v8;
    goto LABEL_13;
  }
  unint64_t v22 = 0;
  int v17 = 1;
LABEL_12:
  uint64_t v25 = 0;
  uint64_t v27 = 0;
  v14 -= v5;
  int v24 = 1;
LABEL_13:
  uint64_t result = *(void *)(result + 48);
  switch(a2)
  {
    case 0:
      do
      {
        uint64_t v65 = 0;
        int v66 = v3;
        do
        {
          int v67 = *(unsigned __int8 *)(v11 + v65);
          if (*(unsigned char *)(v11 + v65))
          {
            if (v67 == 255)
            {
              LOBYTE(v68) = 0;
            }
            else
            {
              uint64_t result = *(unsigned __int8 *)(v9 + v65);
              int v68 = result - ((result * v67 + ((result * v67) >> 8) + 1) >> 8);
            }
            *(unsigned char *)(v9 + v65) = v68;
          }
          v65 += v17;
          --v66;
        }
        while (v66);
        v11 += v65 + v20;
        v9 += v65 + v21;
        --v4;
      }
      while (v4);
      return result;
    case 1:
      goto LABEL_37;
    case 2:
      goto LABEL_15;
    case 3:
      uint64_t v69 = v17;
      uint64_t v70 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v71 = 0;
        int v72 = v3;
        do
        {
          int v73 = *(unsigned __int8 *)(v11 + v71);
          if (*(unsigned char *)(v11 + v71))
          {
            if (v73 == 255)
            {
              int v74 = *v8;
              unsigned int v75 = (*(unsigned __int8 *)(v9 + v71) ^ 0xFF) * v74;
              unsigned int v76 = v74 - ((v75 + (v75 >> 8) + 1) >> 8);
            }
            else
            {
              int v77 = *(unsigned __int8 *)(v9 + v71);
              unsigned int v78 = (v77 * v73 + ((v77 * v73) >> 8) + 1) >> 8;
              unsigned int v76 = (v77 * (v73 ^ 0xFF)
                   + v78 * *v8
                   + ((v77 * (v73 ^ 0xFF) + v78 * *v8) >> 8)
                   + 1) >> 8;
            }
            *(unsigned char *)(v9 + v71) = v76;
          }
          uint64_t v79 = &v8[v69];
          if ((unint64_t)v79 >= v22) {
            uint64_t v80 = v70;
          }
          else {
            uint64_t v80 = 0;
          }
          uint64_t v8 = &v79[v80];
          v71 += v69;
          --v72;
        }
        while (v72);
        v11 += v71 + v20;
        v9 += v71 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v81 = result;
        }
        else {
          uint64_t v81 = 0;
        }
        uint64_t v82 = &v27[v14 + v81];
        unint64_t v83 = v22 + v14 + v81;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v82;
          uint64_t v27 = v82;
          unint64_t v22 = v83;
        }
        --v4;
      }
      while (v4);
      return result;
    case 4:
      uint64_t v84 = v17;
      uint64_t v85 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v86 = 0;
        int v87 = v3;
        do
        {
          int v88 = *(unsigned __int8 *)(v11 + v86);
          if (*(unsigned char *)(v11 + v86))
          {
            if (v88 == 255)
            {
              unsigned int v89 = *v8
                  - ((*(unsigned __int8 *)(v9 + v86) * *v8
                    + ((*(unsigned __int8 *)(v9 + v86) * *v8) >> 8)
                    + 1) >> 8);
            }
            else
            {
              int v90 = *(unsigned __int8 *)(v9 + v86);
              unsigned int v91 = ((v90 ^ 0xFF) * v88 + (((v90 ^ 0xFFu) * v88) >> 8) + 1) >> 8;
              unsigned int v89 = (v90 * (v88 ^ 0xFF)
                   + v91 * *v8
                   + ((v90 * (v88 ^ 0xFF) + v91 * *v8) >> 8)
                   + 1) >> 8;
            }
            *(unsigned char *)(v9 + v86) = v89;
          }
          uint64_t v92 = &v8[v84];
          if ((unint64_t)v92 >= v22) {
            uint64_t v93 = v85;
          }
          else {
            uint64_t v93 = 0;
          }
          uint64_t v8 = &v92[v93];
          v86 += v84;
          --v87;
        }
        while (v87);
        v11 += v86 + v20;
        v9 += v86 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v94 = result;
        }
        else {
          uint64_t v94 = 0;
        }
        uint64_t v95 = &v27[v14 + v94];
        unint64_t v96 = v22 + v14 + v94;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v95;
          uint64_t v27 = v95;
          unint64_t v22 = v96;
        }
        --v4;
      }
      while (v4);
      return result;
    case 5:
      do
      {
        uint64_t v97 = 0;
        int v98 = v3;
        do
        {
          uint64_t result = *(unsigned __int8 *)(v11 + v97);
          if (*(unsigned char *)(v11 + v97))
          {
            uint64_t result = (255 * *(unsigned __int8 *)(v9 + v97)
                    + ((255 * *(unsigned __int8 *)(v9 + v97)) >> 8)
                    + 1) >> 8;
            *(unsigned char *)(v9 + v97) = (unsigned __int16)(255 * *(unsigned __int8 *)(v9 + v97)
                                                    + ((255 * *(unsigned __int8 *)(v9 + v97)) >> 8)
                                                    + 1) >> 8;
          }
          v97 += v17;
          --v98;
        }
        while (v98);
        v11 += v17 * (unint64_t)(v3 - 1) + v17 + v20;
        v9 += v97 + v21;
        --v4;
      }
      while (v4);
      return result;
    case 6:
      uint64_t v99 = v17;
      uint64_t v100 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v101 = 0;
        int v102 = v3;
        do
        {
          int v103 = *(unsigned __int8 *)(v11 + v101);
          if (*(unsigned char *)(v11 + v101))
          {
            int v104 = *(unsigned __int8 *)(v9 + v101);
            if ((_BYTE)v104 != 0xFF)
            {
              if (~(_BYTE)v104 == 255)
              {
                unsigned int v105 = *v8
                     - ((*v8 * (v103 ^ 0xFF) + ((*v8 * (v103 ^ 0xFFu)) >> 8) + 1) >> 8);
              }
              else
              {
                unsigned int v106 = ((~(_BYTE)v104 * v103
                       + ((~(_BYTE)v104 * v103) >> 8)
                       + 1) >> 8)
                     * *v8;
                unsigned int v105 = v104 + ((v106 + (v106 >> 8) + 1) >> 8);
              }
              *(unsigned char *)(v9 + v101) = v105;
            }
          }
          uint64_t v107 = &v8[v99];
          if ((unint64_t)v107 >= v22) {
            uint64_t v108 = v100;
          }
          else {
            uint64_t v108 = 0;
          }
          uint64_t v8 = &v107[v108];
          v101 += v99;
          --v102;
        }
        while (v102);
        v11 += v101 + v20;
        v9 += v101 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v109 = result;
        }
        else {
          uint64_t v109 = 0;
        }
        uint64_t v110 = &v27[v14 + v109];
        unint64_t v111 = v22 + v14 + v109;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v110;
          uint64_t v27 = v110;
          unint64_t v22 = v111;
        }
        --v4;
      }
      while (v4);
      return result;
    case 7:
      uint64_t v112 = v17;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v113 = 0;
        int v114 = v3;
        do
        {
          int v115 = *(unsigned __int8 *)(v11 + v113);
          if (*(unsigned char *)(v11 + v113))
          {
            if (v115 == 255)
            {
              unsigned int v116 = *(unsigned __int8 *)(v9 + v113)
                   - (((*v8 ^ 0xFF) * *(unsigned __int8 *)(v9 + v113)
                     + (((*v8 ^ 0xFF) * *(unsigned __int8 *)(v9 + v113)) >> 8)
                     + 1) >> 8);
            }
            else
            {
              unsigned int v117 = *v8 * v115 + ((*v8 * v115) >> 8) + 1;
              unsigned int v116 = (((v115 ^ 0xFF) + (v117 >> 8)) * *(unsigned __int8 *)(v9 + v113)
                    + ((((v115 ^ 0xFF) + (v117 >> 8)) * *(unsigned __int8 *)(v9 + v113)) >> 8)
                    + 1) >> 8;
            }
            *(unsigned char *)(v9 + v113) = v116;
          }
          v118 = &v8[v112];
          if ((unint64_t)v118 >= v22) {
            uint64_t v119 = -(uint64_t)v23;
          }
          else {
            uint64_t v119 = 0;
          }
          uint64_t v8 = &v118[v119];
          v113 += v112;
          --v114;
        }
        while (v114);
        v11 += v113 + v20;
        v9 += v113 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v120 = result;
        }
        else {
          uint64_t v120 = 0;
        }
        v121 = &v27[v14 + v120];
        unint64_t v122 = v22 + v14 + v120;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v121;
          uint64_t v27 = v121;
          unint64_t v22 = v122;
        }
        --v4;
      }
      while (v4);
      return result;
    case 8:
      uint64_t v123 = v17;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v124 = 0;
        int v125 = v3;
        do
        {
          int v126 = *(unsigned __int8 *)(v11 + v124);
          if (*(unsigned char *)(v11 + v124))
          {
            if (v126 == 255) {
              unsigned int v127 = *v8;
            }
            else {
              unsigned int v127 = (*v8 * v126 + ((*v8 * v126) >> 8) + 1) >> 8;
            }
            *(unsigned char *)(v9 + v124) -= (unsigned __int16)(v127 * *(unsigned __int8 *)(v9 + v124)
                                                      + ((v127 * *(unsigned __int8 *)(v9 + v124)) >> 8)
                                                      + 1) >> 8;
          }
          v128 = &v8[v123];
          if ((unint64_t)v128 >= v22) {
            uint64_t v129 = -(uint64_t)v23;
          }
          else {
            uint64_t v129 = 0;
          }
          uint64_t v8 = &v128[v129];
          v124 += v123;
          --v125;
        }
        while (v125);
        v11 += v124 + v20;
        v9 += v124 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v130 = result;
        }
        else {
          uint64_t v130 = 0;
        }
        v131 = &v27[v14 + v130];
        unint64_t v132 = v22 + v14 + v130;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v131;
          uint64_t v27 = v131;
          unint64_t v22 = v132;
        }
        --v4;
      }
      while (v4);
      return result;
    case 9:
      uint64_t v133 = v17;
      uint64_t v134 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v135 = 0;
        int v136 = v3;
        do
        {
          char v137 = *(unsigned char *)(v11 + v135);
          if (v137)
          {
            char v138 = ~v137;
            unsigned __int8 v139 = *v8
                 - ((unsigned __int16)(*v8 * ~v137
                                     + ((*v8 * ~v137) >> 8)
                                     + 1) >> 8);
            *(unsigned char *)(v9 + v135) = (unsigned __int16)(v139 * (*(unsigned __int8 *)(v9 + v135) ^ 0xFF)
                                                     + (v139 + v138) * *(unsigned __int8 *)(v9 + v135)
                                                     + ((v139 * (*(unsigned __int8 *)(v9 + v135) ^ 0xFF)
                                                       + (v139 + v138)
                                                       * *(unsigned __int8 *)(v9 + v135)) >> 8)
                                                     + 1) >> 8;
          }
          v140 = &v8[v133];
          if ((unint64_t)v140 >= v22) {
            uint64_t v141 = v134;
          }
          else {
            uint64_t v141 = 0;
          }
          uint64_t v8 = &v140[v141];
          v135 += v133;
          --v136;
        }
        while (v136);
        v11 += v135 + v20;
        v9 += v135 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v142 = result;
        }
        else {
          uint64_t v142 = 0;
        }
        v143 = &v27[v14 + v142];
        unint64_t v144 = v22 + v14 + v142;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v143;
          uint64_t v27 = v143;
          unint64_t v22 = v144;
        }
        --v4;
      }
      while (v4);
      return result;
    case 10:
      uint64_t v145 = v17;
      uint64_t v146 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v147 = 0;
        int v148 = v3;
        do
        {
          if (*(unsigned char *)(v11 + v147))
          {
            unsigned int v149 = *v8
                 - ((*v8 * (*(unsigned __int8 *)(v11 + v147) ^ 0xFF)
                   + ((*v8 * (*(unsigned __int8 *)(v11 + v147) ^ 0xFFu)) >> 8)
                   + 1) >> 8);
            *(unsigned char *)(v9 + v147) = (unsigned __int16)(v149 * (*(unsigned __int8 *)(v9 + v147) ^ 0xFF)
                                                     + ~(_BYTE)v149 * *(unsigned __int8 *)(v9 + v147)
                                                     + ((v149
                                                       * (*(unsigned __int8 *)(v9 + v147) ^ 0xFF)
                                                       + ~(_BYTE)v149
                                                       * *(unsigned __int8 *)(v9 + v147)) >> 8)
                                                     + 1) >> 8;
          }
          v150 = &v8[v145];
          if ((unint64_t)v150 >= v22) {
            uint64_t v151 = v146;
          }
          else {
            uint64_t v151 = 0;
          }
          uint64_t v8 = &v150[v151];
          v147 += v145;
          --v148;
        }
        while (v148);
        v11 += v147 + v20;
        v9 += v147 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v152 = result;
        }
        else {
          uint64_t v152 = 0;
        }
        v153 = &v27[v14 + v152];
        unint64_t v154 = v22 + v14 + v152;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v153;
          uint64_t v27 = v153;
          unint64_t v22 = v154;
        }
        --v4;
      }
      while (v4);
      return result;
    case 11:
      uint64_t v155 = v17;
      uint64_t v156 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v157 = 0;
        int v158 = v3;
        do
        {
          if (*(unsigned char *)(v11 + v157))
          {
            unsigned int v159 = *(unsigned __int8 *)(v9 + v157)
                 + (*v8
                                   - ((unsigned __int16)(*v8
                                                       * (*(unsigned __int8 *)(v11 + v157) ^ 0xFF)
                                                       + ((*v8
                                                         * (*(unsigned __int8 *)(v11 + v157) ^ 0xFFu)) >> 8)
                                                       + 1) >> 8));
            if (v159 >= 0xFF) {
              LOBYTE(v159) = -1;
            }
            *(unsigned char *)(v9 + v157) = v159;
          }
          v160 = &v8[v155];
          if ((unint64_t)v160 >= v22) {
            uint64_t v161 = v156;
          }
          else {
            uint64_t v161 = 0;
          }
          uint64_t v8 = &v160[v161];
          v157 += v155;
          --v158;
        }
        while (v158);
        v11 += v157 + v20;
        v9 += v157 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v162 = result;
        }
        else {
          uint64_t v162 = 0;
        }
        v163 = &v27[v14 + v162];
        unint64_t v164 = v22 + v14 + v162;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v163;
          uint64_t v27 = v163;
          unint64_t v22 = v164;
        }
        --v4;
      }
      while (v4);
      return result;
    case 12:
      uint64_t v165 = v17;
      uint64_t v166 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      do
      {
        uint64_t v167 = 0;
        int v168 = v3;
        do
        {
          if (*(unsigned char *)(v11 + v167))
          {
            unsigned int v169 = *(unsigned __int8 *)(v9 + v167)
                 + (*v8
                                   - ((unsigned __int16)(*v8
                                                       * (*(unsigned __int8 *)(v11 + v167) ^ 0xFF)
                                                       + ((*v8
                                                         * (*(unsigned __int8 *)(v11 + v167) ^ 0xFFu)) >> 8)
                                                       + 1) >> 8));
            if (v169 >= 0xFF) {
              LOBYTE(v169) = -1;
            }
            *(unsigned char *)(v9 + v167) = v169;
          }
          v170 = &v8[v165];
          if ((unint64_t)v170 >= v22) {
            uint64_t v171 = v166;
          }
          else {
            uint64_t v171 = 0;
          }
          uint64_t v8 = &v170[v171];
          v167 += v165;
          --v168;
        }
        while (v168);
        v11 += v167 + v20;
        v9 += v167 + v21;
        if (&v27[v14] >= v25) {
          uint64_t v172 = result;
        }
        else {
          uint64_t v172 = 0;
        }
        v173 = &v27[v14 + v172];
        unint64_t v174 = v22 + v14 + v172;
        v8 += v14;
        if (!v24)
        {
          uint64_t v8 = v173;
          uint64_t v27 = v173;
          unint64_t v22 = v174;
        }
        --v4;
      }
      while (v4);
      return result;
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
      if (!v19)
      {
LABEL_37:
        if (result) {
          char v42 = v19;
        }
        else {
          char v42 = 1;
        }
        uint64_t v43 = v17;
        uint64_t v44 = -(uint64_t)v23;
        uint64_t result = -(v14 * v18);
        if (v42)
        {
          do
          {
            uint64_t v45 = 0;
            int v46 = v3;
            do
            {
              int v47 = *(unsigned __int8 *)(v11 + v45);
              if (*(unsigned char *)(v11 + v45))
              {
                if (v47 == 255) {
                  LOBYTE(v48) = *v8;
                }
                else {
                  unsigned int v48 = (*v8 * v47
                }
                       + *(unsigned __int8 *)(v9 + v45) * (v47 ^ 0xFF)
                       + ((*v8 * v47 + *(unsigned __int8 *)(v9 + v45) * (v47 ^ 0xFFu)) >> 8)
                       + 1) >> 8;
                *(unsigned char *)(v9 + v45) = v48;
              }
              float v49 = &v8[v43];
              if ((unint64_t)v49 >= v22) {
                uint64_t v50 = -(uint64_t)v23;
              }
              else {
                uint64_t v50 = 0;
              }
              uint64_t v8 = &v49[v50];
              v45 += v43;
              --v46;
            }
            while (v46);
            v11 += v45 + v20;
            v9 += v45 + v21;
            if (&v27[v14] >= v25) {
              uint64_t v51 = result;
            }
            else {
              uint64_t v51 = 0;
            }
            unsigned int v52 = &v27[v14 + v51];
            unint64_t v53 = v22 + v14 + v51;
            v8 += v14;
            if (!v24)
            {
              uint64_t v8 = v52;
              uint64_t v27 = v52;
              unint64_t v22 = v53;
            }
            --v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            uint64_t v54 = 0;
            int v55 = v3;
            do
            {
              int v56 = *(unsigned __int8 *)(v11 + v54);
              if (*(unsigned char *)(v11 + v54))
              {
                if (v56 == 255)
                {
                  LOBYTE(v57) = *v8;
                }
                else
                {
                  int v58 = *(unsigned __int8 *)(v9 + v54) * (v56 ^ 0xFF);
                  unsigned int v57 = (v58 + *v8 * v56 + ((v58 + *v8 * v56) >> 8) + 1) >> 8;
                }
                *(unsigned char *)(v9 + v54) = v57;
              }
              uint64_t v59 = &v8[v43];
              if ((unint64_t)v59 >= v22) {
                uint64_t v60 = v44;
              }
              else {
                uint64_t v60 = 0;
              }
              uint64_t v8 = &v59[v60];
              v54 += v43;
              --v55;
            }
            while (v55);
            v11 += v54 + v20;
            v9 += v54 + v21;
            if (&v27[v14] >= v25) {
              uint64_t v61 = result;
            }
            else {
              uint64_t v61 = 0;
            }
            uint64_t v62 = &v27[v14 + v61];
            unint64_t v63 = v22 + v14 + v61;
            v8 += v14;
            if (!v24)
            {
              uint64_t v8 = v62;
              uint64_t v27 = v62;
              unint64_t v22 = v63;
            }
            --v4;
          }
          while (v4);
        }
        return result;
      }
LABEL_15:
      uint64_t v28 = v17;
      uint64_t v29 = -(uint64_t)v23;
      uint64_t result = -(v14 * v18);
      break;
    default:
      return result;
  }
  do
  {
    uint64_t v30 = 0;
    int v31 = v3;
    do
    {
      int v32 = *(unsigned __int8 *)(v11 + v30);
      if (!*(unsigned char *)(v11 + v30)) {
        goto LABEL_26;
      }
      if (v32 == 255)
      {
        int v33 = *v8;
        if (!*v8) {
          goto LABEL_26;
        }
        if (v33 == 255) {
          goto LABEL_25;
        }
        unsigned int v34 = *(unsigned __int8 *)(v9 + v30) * (v33 ^ 0xFF);
      }
      else
      {
        int v35 = *v8;
        unsigned int v36 = v35 * (v32 ^ 0xFF) + ((v35 * (v32 ^ 0xFFu)) >> 8) + 1;
        if (v35 == BYTE1(v36)) {
          goto LABEL_26;
        }
        int v33 = v35 - (v36 >> 8);
        unsigned int v34 = *(unsigned __int8 *)(v9 + v30) * ~(_BYTE)v33;
      }
      v33 += (v34 + (v34 >> 8) + 1) >> 8;
LABEL_25:
      *(unsigned char *)(v9 + v30) = v33;
LABEL_26:
      uint64_t v37 = &v8[v28];
      if ((unint64_t)v37 >= v22) {
        uint64_t v38 = v29;
      }
      else {
        uint64_t v38 = 0;
      }
      uint64_t v8 = &v37[v38];
      v30 += v28;
      --v31;
    }
    while (v31);
    v11 += v30 + v20;
    v9 += v30 + v21;
    if (&v27[v14] >= v25) {
      uint64_t v39 = result;
    }
    else {
      uint64_t v39 = 0;
    }
    uint64_t v40 = &v27[v14 + v39];
    unint64_t v41 = v22 + v14 + v39;
    v8 += v14;
    if (!v24)
    {
      uint64_t v8 = v40;
      uint64_t v27 = v40;
      unint64_t v22 = v41;
    }
    --v4;
  }
  while (v4);
  return result;
}

void A8_mark_image_OPAQUE(uint64_t a1, uint64_t a2, float a3)
{
  int v4 = (int)(float)((float)(int)(float)(a3 * 255.0) + 0.5);
  int v5 = *(_DWORD *)(a1 + 4);
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v13 = v6;
  int v14 = v5;
  uint64_t v7 = *(int **)(a1 + 136);
  if (v7)
  {
    int v8 = *(_DWORD *)(a1 + 104);
    LODWORD(v15) = *(_DWORD *)(a1 + 108);
    HIDWORD(v15) = v8;
    shape_enum_clip_alloc(a1, a2, v7, 1, 1, 1, v8, v15, v5, v6);
    uint64_t v10 = v9;
    if (v9) {
      goto LABEL_5;
    }
  }
  int v11 = 0;
  int v12 = 0;
  uint64_t v10 = 0;
  uint64_t v15 = 0;
  while (1)
  {
    CGBlt_fillBytes(v5, v6, 16843009 * v4, (char *)(*(void *)(a1 + 40)+ (*(int *)(a1 + 16) + (uint64_t)v12) * *(int *)(a1 + 28)+ *(int *)(a1 + 12)+ (uint64_t)v11), *(_DWORD *)(a1 + 28));
    if (!v10) {
      break;
    }
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v10, (int *)&v15 + 1, &v15, &v14, &v13))
    {
      free(v10);
      return;
    }
    int v12 = v15;
    int v11 = HIDWORD(v15);
    unsigned int v6 = v13;
    int v5 = v14;
  }
}

uint64_t A8_image_mark_RGB32(uint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = a2[1];
  int v72 = *a2;
  int v8 = *(unsigned int **)(result + 32);
  if (*(void *)(result + 40)) {
    int v9 = 0;
  }
  else {
    int v9 = 255;
  }
  uint64_t v10 = (unsigned char *)*((void *)a2 + 2);
  uint64_t v71 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 15);
  uint64_t v11 = *((void *)a2 + 16);
  uint64_t v13 = *((void *)a2 + 7);
  uint64_t v70 = *((void *)a2 + 9);
  uint64_t v14 = *((void *)a2 + 5) + v70 * a4;
  uint64_t v15 = (char *)v8
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  if (*(void *)(result + 176))
  {
    uint64_t v68 = *((void *)a2 + 11);
    uint64_t v67 = *((void *)a2 + 13);
    char v16 = (unsigned int *)(v15 - 4);
    uint64_t v66 = a5;
    uint64_t v65 = v11 + 16 * a3 + 8;
    int v69 = a5;
    do
    {
      if (((v67 - v14) | (v14 - v68)) < 0)
      {
        uint64_t v18 = 0;
        int v19 = 0;
      }
      else
      {
        unint64_t v17 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        if (v17 - 7 >= 9) {
          uint64_t v18 = -v12;
        }
        else {
          uint64_t v18 = v12;
        }
        int v19 = weights_21383[v17] & 0xF;
      }
      uint64_t v20 = *(void *)(result + 32) + (v14 >> v13) * v12;
      if (v72 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v21 = (uint64_t *)v65;
          uint64_t v22 = v66;
          do
          {
            uint64_t v23 = *(v21 - 1);
            uint64_t v24 = *v21;
            uint64_t v25 = v20 + v23;
            if ((unint64_t)v16 >= v20 + v23) {
              uint64_t v26 = (unsigned int *)(v20 + v23);
            }
            else {
              uint64_t v26 = v16;
            }
            if (v8 > v26) {
              uint64_t v26 = v8;
            }
            unsigned int v27 = bswap32(*v26);
            if ((v24 & 0xF) != 0)
            {
              uint64_t v28 = (unsigned int *)(v25 + (v24 >> 4));
              if (v16 < v28) {
                uint64_t v28 = v16;
              }
              if (v8 > v28) {
                uint64_t v28 = v8;
              }
              unsigned int v29 = bswap32(*v28);
              if (v19)
              {
                uint64_t v30 = (unsigned int *)(v25 + v18);
                if (v16 >= v30) {
                  int v31 = v30;
                }
                else {
                  int v31 = v16;
                }
                if (v8 > v31) {
                  int v31 = v8;
                }
                unsigned int v32 = bswap32(*v31);
                int v33 = (unsigned int *)((char *)v30 + (v24 >> 4));
                if (v16 < v33) {
                  int v33 = v16;
                }
                if (v8 > v33) {
                  int v33 = v8;
                }
                int v34 = BLEND8_21385[v19];
                unsigned int v27 = v27 - ((v34 & v27) >> v19) + ((v34 & v32) >> v19);
                unsigned int v29 = v29 - ((v34 & v29) >> v19) + ((bswap32(*v33) & v34) >> v19);
              }
              unsigned int v27 = v27
                  - ((BLEND8_21385[*v21 & 0xF] & v27) >> (*v21 & 0xF))
                  + ((BLEND8_21385[*v21 & 0xF] & v29) >> (*v21 & 0xF));
            }
            else if (v19)
            {
              int v35 = (unsigned int *)(v25 + v18);
              if ((unint64_t)v16 < v25 + v18) {
                int v35 = v16;
              }
              if (v8 > v35) {
                int v35 = v8;
              }
              unsigned int v27 = v27 - ((BLEND8_21385[v19] & v27) >> v19) + ((bswap32(*v35) & BLEND8_21385[v19]) >> v19);
            }
            unsigned int v36 = __ROL4__(v27, v7) | v9;
            if (v6 != 255) {
              unsigned int v36 = (v36 * v6 + ((v36 * v6) >> 8) + 1) >> 8;
            }
            v21 += 2;
            *v10++ = v36;
            --v22;
          }
          while (v22);
        }
      }
      else if (a5 >= 1)
      {
        uint64_t v38 = (uint64_t *)v65;
        uint64_t v37 = v66;
        do
        {
          uint64_t v39 = *(v38 - 1);
          uint64_t v40 = *v38;
          uint64_t v41 = v20 + v39;
          if ((unint64_t)v16 >= v20 + v39) {
            char v42 = (unsigned int *)(v20 + v39);
          }
          else {
            char v42 = v16;
          }
          if (v8 > v42) {
            char v42 = v8;
          }
          unsigned int v43 = bswap32(*v42);
          if ((v40 & 0xF) != 0)
          {
            uint64_t v44 = (unsigned int *)(v41 + (v40 >> 4));
            if (v16 < v44) {
              uint64_t v44 = v16;
            }
            if (v8 > v44) {
              uint64_t v44 = v8;
            }
            unsigned int v45 = bswap32(*v44);
            if (v19)
            {
              if ((unint64_t)v16 >= v41 + v18) {
                int v46 = (unsigned int *)(v41 + v18);
              }
              else {
                int v46 = v16;
              }
              if (v8 > v46) {
                int v46 = v8;
              }
              unsigned int v47 = bswap32(*v46);
              unsigned int v48 = (unsigned int *)(v41 + v18 + (v40 >> 4));
              if (v16 < v48) {
                unsigned int v48 = v16;
              }
              if (v8 > v48) {
                unsigned int v48 = v8;
              }
              int v49 = BLEND8_21385[v19];
              unsigned int v43 = v43 - ((v49 & v43) >> v19) + ((v49 & v47) >> v19);
              unsigned int v45 = v45 - ((v49 & v45) >> v19) + ((bswap32(*v48) & v49) >> v19);
            }
            unsigned int v43 = v43
                - ((BLEND8_21385[*v38 & 0xF] & v43) >> (*v38 & 0xF))
                + ((BLEND8_21385[*v38 & 0xF] & v45) >> (*v38 & 0xF));
          }
          else if (v19)
          {
            uint64_t v50 = (unsigned int *)(v41 + v18);
            if ((unint64_t)v16 < v41 + v18) {
              uint64_t v50 = v16;
            }
            if (v8 > v50) {
              uint64_t v50 = v8;
            }
            unsigned int v43 = v43 - ((BLEND8_21385[v19] & v43) >> v19) + ((bswap32(*v50) & BLEND8_21385[v19]) >> v19);
          }
          unsigned int v51 = __ROL4__(v43, v7) | v9;
          if (v6 != 255) {
            unsigned int v51 = (v51 * v6 + ((v51 * v6) >> 8) + 1) >> 8;
          }
          if ((_BYTE)v51)
          {
            if (v51 != 255) {
              v51 += (~(_BYTE)v51 * *v10
            }
                    + ((~(_BYTE)v51 * *v10) >> 8)
                    + 1) >> 8;
            *uint64_t v10 = v51;
          }
          v38 += 2;
          ++v10;
          --v37;
        }
        while (v37);
      }
      v10 += v71;
      v14 += v70;
      --a6;
      a5 = v69;
    }
    while (a6);
  }
  else
  {
    unsigned int v52 = (uint64_t *)(v11 + 16 * a3);
    unint64_t v53 = (unsigned int *)(v15 - 4);
    do
    {
      uint64_t v54 = *(void *)(result + 32) + (v14 >> v13) * v12;
      if (v72 == 1)
      {
        if (a5 >= 1)
        {
          int v55 = v52;
          uint64_t v56 = a5;
          do
          {
            uint64_t v57 = *v55;
            v55 += 2;
            int v58 = (unsigned int *)(v54 + v57);
            if ((unint64_t)v53 < v54 + v57) {
              int v58 = v53;
            }
            if (*(void *)(result + 32) > (unint64_t)v58) {
              int v58 = *(unsigned int **)(result + 32);
            }
            unsigned int v59 = __ROL4__(bswap32(*v58), v7) | v9;
            if (v6 != 255) {
              unsigned int v59 = (v59 * v6 + ((v59 * v6) >> 8) + 1) >> 8;
            }
            *v10++ = v59;
            --v56;
          }
          while (v56);
        }
      }
      else
      {
        uint64_t v60 = v52;
        uint64_t v61 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v62 = *v60;
            v60 += 2;
            unint64_t v63 = (unsigned int *)(v54 + v62);
            if ((unint64_t)v53 < v54 + v62) {
              unint64_t v63 = v53;
            }
            if (*(void *)(result + 32) > (unint64_t)v63) {
              unint64_t v63 = *(unsigned int **)(result + 32);
            }
            unsigned int v64 = __ROL4__(bswap32(*v63), v7) | v9;
            if (v6 != 255) {
              unsigned int v64 = (v64 * v6 + ((v64 * v6) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v64)
            {
              if (v64 != 255) {
                v64 += (~(_BYTE)v64 * *v10
              }
                      + ((~(_BYTE)v64 * *v10) >> 8)
                      + 1) >> 8;
              *uint64_t v10 = v64;
            }
            ++v10;
            --v61;
          }
          while (v61);
        }
      }
      v10 += v71;
      v14 += v70;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t A8_image_mark_RGB24(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = *a2;
  int v8 = (unsigned char *)*((void *)a2 + 2);
  uint64_t v9 = *((void *)a2 + 3) - a5;
  unsigned int v10 = 255 * v6 + ((255 * v6) >> 8) + 1;
  unsigned int v11 = v10 >> 8;
  int v12 = (v10 >> 8) ^ 0xFF;
  if (v6 == 255) {
    LOBYTE(v11) = -1;
  }
  if (!*(void *)(result + 176))
  {
    while (1)
    {
      if (v7 == 1)
      {
        if (a5 >= 1)
        {
          int v16 = a5;
          do
          {
            *v8++ = v11;
            --v16;
          }
          while (v16);
        }
        goto LABEL_30;
      }
      int v17 = a5;
      if (a5 >= 1) {
        break;
      }
LABEL_30:
      v8 += v9;
      if (!--a6) {
        return result;
      }
    }
    while (v6 != 255)
    {
      if (BYTE1(v10))
      {
        unsigned int v18 = ((v12 * *v8 + ((v12 * *v8) >> 8) + 1) >> 8) + (v10 >> 8);
LABEL_28:
        *int v8 = v18;
      }
      ++v8;
      if (!--v17) {
        goto LABEL_30;
      }
    }
    LOBYTE(v18) = -1;
    goto LABEL_28;
  }
  do
  {
    if (v7 != 1)
    {
      int v14 = a5;
      if (a5 < 1) {
        goto LABEL_16;
      }
      while (v6 != 255)
      {
        if (BYTE1(v10))
        {
          unsigned int v15 = ((v12 * *v8 + ((v12 * *v8) >> 8) + 1) >> 8) + (v10 >> 8);
LABEL_14:
          *int v8 = v15;
        }
        ++v8;
        if (!--v14) {
          goto LABEL_16;
        }
      }
      LOBYTE(v15) = -1;
      goto LABEL_14;
    }
    if (a5 >= 1)
    {
      int v13 = a5;
      do
      {
        *v8++ = v11;
        --v13;
      }
      while (v13);
    }
LABEL_16:
    v8 += v9;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t A8_image_mark_W8(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = *a2;
  int v8 = (unsigned char *)*((void *)a2 + 2);
  uint64_t v9 = *((void *)a2 + 3) - a5;
  unsigned int v10 = 255 * v6 + ((255 * v6) >> 8) + 1;
  unsigned int v11 = v10 >> 8;
  int v12 = (v10 >> 8) ^ 0xFF;
  if (v6 == 255) {
    LOBYTE(v11) = -1;
  }
  if (!*(void *)(result + 176))
  {
    while (1)
    {
      if (v7 == 1)
      {
        if (a5 >= 1)
        {
          int v16 = a5;
          do
          {
            *v8++ = v11;
            --v16;
          }
          while (v16);
        }
        goto LABEL_30;
      }
      int v17 = a5;
      if (a5 >= 1) {
        break;
      }
LABEL_30:
      v8 += v9;
      if (!--a6) {
        return result;
      }
    }
    while (v6 != 255)
    {
      if (BYTE1(v10))
      {
        unsigned int v18 = ((v12 * *v8 + ((v12 * *v8) >> 8) + 1) >> 8) + (v10 >> 8);
LABEL_28:
        *int v8 = v18;
      }
      ++v8;
      if (!--v17) {
        goto LABEL_30;
      }
    }
    LOBYTE(v18) = -1;
    goto LABEL_28;
  }
  do
  {
    if (v7 != 1)
    {
      int v14 = a5;
      if (a5 < 1) {
        goto LABEL_16;
      }
      while (v6 != 255)
      {
        if (BYTE1(v10))
        {
          unsigned int v15 = ((v12 * *v8 + ((v12 * *v8) >> 8) + 1) >> 8) + (v10 >> 8);
LABEL_14:
          *int v8 = v15;
        }
        ++v8;
        if (!--v14) {
          goto LABEL_16;
        }
      }
      LOBYTE(v15) = -1;
      goto LABEL_14;
    }
    if (a5 >= 1)
    {
      int v13 = a5;
      do
      {
        *v8++ = v11;
        --v13;
      }
      while (v13);
    }
LABEL_16:
    v8 += v9;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t A8_shade_custom_A(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  float v6 = *(float *)(*(void *)(result + 272) + 4);
  float v7 = v6 * (float)a2;
  float v8 = v6 * (float)a3;
  float32x2_t v9 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), v8), v9, v7));
  float32x4_t v10 = *(float32x4_t *)(result + 304);
  float v11 = *(float *)(result + 336);
  float v12 = *(float *)(result + 348);
  float v13 = *(float *)(result + 344);
  float v14 = *(float *)(result + 356);
  int v16 = *(unsigned char **)(result + 144);
  unsigned int v15 = *(unsigned char **)(result + 152);
  uint64_t v18 = *(void *)(result + 368);
  int v17 = *(_WORD **)(result + 376);
  int v19 = *(_DWORD *)(result + 48);
  uint64_t v20 = result + 368;
  uint64_t v21 = *(void *)(result + 360);
  uint64_t v22 = v18 + (((unint64_t)a3 >> 4) & 0xF0);
  uint64_t v23 = ((unint64_t)a2 >> 8) & 0xF;
  BOOL v24 = v18 == 0;
  int v25 = 15;
  if (v24)
  {
    int v25 = 0;
    uint64_t v23 = 0;
  }
  else
  {
    uint64_t v20 = v22;
  }
  do
  {
    float32x4_t v26 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v10, v26))), vmovn_s32(vcgtq_f32(v26, v10))), 0xFuLL))) & 1) == 0)
    {
      unsigned int v27 = (_WORD *)(v21
                    + 2 * (int)(float)(v14 * (float)(*(float *)&a6.i32[1] - v12)) * v19
                    + 2 * (int)(float)(v13 * (float)(*(float *)a6.i32 - v11)));
LABEL_8:
      *unsigned int v15 = (unsigned __int16)(*(unsigned __int8 *)(v20 + v23) + *v27) >> 8;
      LOBYTE(v27) = -1;
      goto LABEL_9;
    }
    unsigned int v27 = v17;
    if (v17) {
      goto LABEL_8;
    }
LABEL_9:
    uint64_t v23 = (v23 + 1) & v25;
    *(float32x2_t *)a6.i8 = vadd_f32(v9, *(float32x2_t *)a6.i8);
    ++v15;
    *v16++ = (_BYTE)v27;
    --a4;
  }
  while (a4);
  return result;
}

void A8_shade_conic_A(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(void *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(void *)&a1[34] + 4) * (float)a2));
  float v8 = a1[42].f32[0];
  float v9 = a1[43].f32[0];
  float v10 = a1[38].f32[0];
  float v12 = (unsigned char *)a1[18];
  float v11 = (unsigned char *)a1[19];
  float32x2_t v14 = a1[45];
  float32x2_t v13 = a1[46];
  if (v13) {
    int v15 = 15;
  }
  else {
    int v15 = 0;
  }
  if (v13) {
    uint64_t v16 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v16 = 0;
  }
  if (v13) {
    int v17 = (float32x2_t *)(*(void *)&v13 + (((unint64_t)a3 >> 4) & 0xF0));
  }
  else {
    int v17 = a1 + 46;
  }
  float v18 = a1[38].f32[1] - v10;
  do
  {
    __n128 v27 = a6;
    float v19 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v18))
                - v8);
    signed int v20 = vcvtms_s32_f32(v19);
    float v21 = ceilf(v19);
    unsigned int v22 = vcvtms_s32_f32(v9 + v19);
    float v23 = (float)((float)(v19 - (float)(int)floorf(v19)) * 255.0) + 0.5;
    if (v19 < 0.0) {
      signed int v20 = v22;
    }
    int v24 = (int)v23;
    float v25 = ceilf(v19 - v9);
    if (v19 <= v9) {
      float v26 = v21;
    }
    else {
      float v26 = v25;
    }
    a6.n128_u64[1] = v27.n128_u64[1];
    *v11++ = (unsigned __int16)(v17->u8[v16]
                              + (unsigned __int16)((v24 * *(unsigned __int16 *)(*(void *)&v14 + 2 * (int)v26)
                                                  + (255 - v24)
                                                  * *(unsigned __int16 *)(*(void *)&v14 + 2 * v20)) >> 8)) >> 8;
    uint64_t v16 = (v16 + 1) & v15;
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v27.n128_u64[0]);
    *v12++ = -1;
    --a4;
  }
  while (a4);
}

void A8_shade_radial_A(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  int v5 = *(float **)(a1 + 400);
  float v6 = *(float *)(a1 + 280);
  float v7 = *(float *)(a1 + 284);
  float v8 = *(float *)(*(void *)(a1 + 272) + 4);
  float v9 = v8 * (float)(uint64_t)a2;
  float v10 = v8 * (float)(uint64_t)a3;
  float v11 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v10) + (float)(v6 * v9));
  float v12 = *(float *)(a1 + 300) + (float)((float)(v10 * *(float *)(a1 + 292)) + (float)(v7 * v9));
  float v13 = *(float *)(a1 + 336);
  float v14 = *(float *)(a1 + 344);
  float v15 = *(float *)(a1 + 304);
  float v16 = *(float *)(a1 + 308);
  unint64_t v17 = *(unsigned int *)(a1 + 324);
  float v18 = v5[2];
  float v19 = v5[4];
  float v20 = v5[5];
  float v21 = v5[7];
  uint64_t v24 = a1 + 144;
  unsigned int v22 = *(unsigned char **)(a1 + 144);
  float v23 = *(unsigned char **)(v24 + 8);
  float v25 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v26 = *(void *)(a1 + 360);
  uint64_t v27 = (a2 >> 8) & 0xF;
  if (v18 != 0.0 || v21 != 0.0 || v7 != 0.0)
  {
    unsigned int v37 = *(_DWORD *)(a1 + 320);
    float v38 = v5[3];
    float v39 = v5[6];
    float v40 = v5[8];
    uint64_t v41 = a1 + 368;
    uint64_t v42 = *(void *)(a1 + 368);
    uint64_t v43 = v42 + ((a3 >> 4) & 0xF0);
    BOOL v44 = v42 == 0;
    int v45 = 15;
    if (v44)
    {
      int v45 = 0;
      uint64_t v46 = 0;
    }
    else
    {
      uint64_t v46 = (a2 >> 8) & 0xF;
    }
    if (!v44) {
      uint64_t v41 = v43;
    }
    float v47 = -v39;
    float v48 = v16 - v15;
    while (1)
    {
      float v49 = v47 + (float)((float)(v11 + v11) * v18);
      float v50 = (float)((float)(v12 * v12) + (float)(v11 * v11)) - v21;
      if (v20 == 0.0)
      {
        float v57 = v50 / v49;
      }
      else
      {
        float v51 = (float)((float)(v20 * -4.0) * v50) + (float)(v49 * v49);
        if (v51 < 0.0) {
          goto LABEL_53;
        }
        float v52 = sqrtf(v51);
        float v53 = v40 * (float)(v49 - v52);
        float v54 = v49 + v52;
        float v55 = v40 * v54;
        BOOL v56 = (float)(v40 * v54) <= v53;
        if ((float)(v40 * v54) <= v53) {
          float v57 = v40 * v54;
        }
        else {
          float v57 = v53;
        }
        if (v56) {
          float v55 = v53;
        }
        if (v55 < 0.0)
        {
          BOOL v58 = v55 < v38;
LABEL_39:
          unsigned int v59 = v37;
          if (v58) {
            goto LABEL_53;
          }
LABEL_40:
          if ((v59 & 0x80000000) == 0) {
            goto LABEL_52;
          }
          goto LABEL_53;
        }
        if (v55 <= 1.0)
        {
          float v60 = v15 + (float)(v55 * v48);
          goto LABEL_51;
        }
        if ((v17 & 0x80000000) == 0)
        {
          unsigned int v59 = v17;
          if (v55 <= v19)
          {
LABEL_52:
            uint64_t v61 = (_WORD *)(v26 + 2 * v59);
LABEL_54:
            *float v23 = (unsigned __int16)(*(unsigned __int8 *)(v41 + v46) + *v61) >> 8;
            LOBYTE(v61) = -1;
            goto LABEL_55;
          }
        }
      }
      if (v57 < 0.0)
      {
        BOOL v58 = v57 < v38;
        goto LABEL_39;
      }
      if (v57 > 1.0)
      {
        unsigned int v59 = v17;
        if (v57 > v19) {
          goto LABEL_53;
        }
        goto LABEL_40;
      }
      float v60 = v15 + (float)(v57 * v48);
LABEL_51:
      unsigned int v59 = (int)(float)(v14 * (float)(v60 - v13));
      if ((v59 & 0x80000000) == 0) {
        goto LABEL_52;
      }
LABEL_53:
      uint64_t v61 = v25;
      if (v25) {
        goto LABEL_54;
      }
LABEL_55:
      uint64_t v46 = (v46 + 1) & v45;
      float v11 = v6 + v11;
      float v12 = v7 + v12;
      ++v23;
      *v22++ = (_BYTE)v61;
      if (!--a4) {
        return;
      }
    }
  }
  uint64_t v28 = a1 + 368;
  uint64_t v29 = *(void *)(a1 + 368);
  BOOL v30 = v29 == 0;
  if (v29) {
    uint64_t v31 = v29 + ((a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v31 = v28;
  }
  if (v30) {
    LODWORD(v32) = 0;
  }
  else {
    LODWORD(v32) = (BYTE1(a2) + 1) & 0xF;
  }
  if (v30)
  {
    LODWORD(v27) = 0;
    int v33 = 0;
  }
  else
  {
    int v33 = 15;
  }
  float v34 = v12 * v12;
  float v35 = -v20;
  if (v34 <= (float)-v20)
  {
    float v62 = fabsf(v5[8]);
    float v63 = v20 * -4.0;
    float v64 = v16 - v15;
    int v65 = a4 + 2;
    while (1)
    {
      float v66 = v34 + (float)(v11 * v11);
      float v67 = v6 + v11;
      float v68 = v34 + (float)(v67 * v67);
      if (v66 <= v35 || v68 <= v35)
      {
        float v70 = sqrtf(v63 * v68);
        float v71 = v62 * sqrtf(v63 * v66);
        float v72 = v62 * v70;
        unint64_t v73 = (int)(float)(v14 * (float)((float)(v15 + (float)(v71 * v64)) - v13));
        unint64_t v74 = (int)(float)(v14 * (float)((float)(v15 + (float)((float)(v62 * v70) * v64)) - v13));
        if (v71 > 1.0 || v72 > 1.0)
        {
          if (v71 <= 1.0)
          {
            if ((v73 & 0x80000000) != 0) {
              goto LABEL_70;
            }
          }
          else if (v71 > v19 || (unint64_t v73 = v17, (v17 & 0x80000000) != 0))
          {
LABEL_70:
            unint64_t v73 = (unint64_t)v25;
            if (!v25)
            {
LABEL_82:
              if (v72 <= 1.0)
              {
                if ((v74 & 0x80000000) != 0) {
                  goto LABEL_85;
                }
              }
              else if (v72 > v19 || (unint64_t v74 = v17, (v17 & 0x80000000) != 0))
              {
LABEL_85:
                if (!v25)
                {
                  char v80 = 0;
                  goto LABEL_91;
                }
                __int16 v78 = *v25;
                uint64_t v79 = v32;
                goto LABEL_89;
              }
              __int16 v78 = *(_WORD *)(v26 + 2 * v74);
              uint64_t v79 = v32;
LABEL_89:
              __int16 v77 = *(unsigned __int8 *)(v31 + v79) + v78;
              goto LABEL_90;
            }
LABEL_81:
            *float v23 = (unsigned __int16)(*(unsigned __int8 *)(v31 + v27) + *(_WORD *)v73) >> 8;
            LOBYTE(v73) = -1;
            goto LABEL_82;
          }
          unint64_t v73 = v26 + 2 * v73;
          goto LABEL_81;
        }
        __int16 v77 = *(unsigned __int8 *)(v31 + v32) + *(_WORD *)(v26 + 2 * (int)v74);
        LODWORD(v73) = (*(unsigned __int8 *)(v31 + v27)
                      + *(unsigned __int16 *)(v26 + 2 * (int)v73)) >> 8;
      }
      else
      {
        if ((v17 & 0x80000000) != 0)
        {
          if (!v25)
          {
            char v80 = 0;
            LOBYTE(v73) = 0;
            goto LABEL_91;
          }
          int v76 = *v25;
        }
        else
        {
          int v76 = *(unsigned __int16 *)(v26 + 2 * v17);
        }
        __int16 v77 = *(unsigned __int8 *)(v31 + v32) + (_WORD)v76;
        LODWORD(v73) = (*(unsigned __int8 *)(v31 + v27) + v76) >> 8;
      }
      *float v23 = v73;
      LOBYTE(v73) = -1;
LABEL_90:
      v23[1] = HIBYTE(v77);
      char v80 = -1;
LABEL_91:
      float v11 = v6 + v67;
      LOBYTE(v27) = (v27 + 1) & v33;
      LOBYTE(v32) = (v32 + 1) & v33;
      v23 += 2;
      *unsigned int v22 = v73;
      v22[1] = v80;
      v22 += 2;
      v65 -= 2;
      if (v65 <= 2) {
        return;
      }
    }
  }
  if (v25 || (v17 & 0x80000000) == 0)
  {
    uint64_t v81 = (__int16 *)(v26 + 2 * v17);
    if ((v17 & 0x80000000) == 0) {
      uint64_t v82 = v81;
    }
    else {
      uint64_t v82 = (__int16 *)v25;
    }
    __int16 v83 = *v82;
    int v84 = a4 + 4;
    do
    {
      __int16 v85 = *(unsigned __int8 *)(v31 + v32) + v83;
      *float v23 = (unsigned __int16)(*(unsigned __int8 *)(v31 + v27) + v83) >> 8;
      uint64_t v27 = (v27 + 1) & v33;
      v23[1] = HIBYTE(v85);
      uint64_t v32 = (v32 + 1) & v33;
      __int16 v86 = *(unsigned __int8 *)(v31 + v32) + v83;
      v23[2] = (unsigned __int16)(*(unsigned __int8 *)(v31 + v27) + v83) >> 8;
      v23[3] = HIBYTE(v86);
      *(_DWORD *)unsigned int v22 = -1;
      v22 += 4;
      v23 += 4;
      v84 -= 4;
    }
    while (v84 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v36 = 4;
    }
    else {
      int v36 = a4;
    }
    bzero(v22, ((a4 - v36 + 3) & 0xFFFFFFFC) + 4);
  }
}

void CPPDFGraphicStateReleaseElements(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 64);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = *(const void **)(a1 + 256);
  if (v3) {
    CFRelease(v3);
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 264));
  int v4 = *(const void **)(a1 + 272);
  if (v4) {
    CFRelease(v4);
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 280));
  *(void *)(a1 + 280) = 0;
  int v5 = *(void **)(a1 + 248);
}

uint64_t PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair::formatText(PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  if (*((unsigned char *)this + 20)) {
    PB::TextFormatter::format(a2, "flags");
  }
  if (*((void *)this + 1)) {
    PB::TextFormatter::format();
  }

  return MEMORY[0x1F4147498](a2);
}

uint64_t PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  if (*(void *)(this + 8)) {
    this = PB::Writer::write();
  }
  if (*(unsigned char *)(v3 + 20))
  {
    return PB::Writer::writeVarInt(a2);
  }
  return this;
}

uint64_t PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair::readFrom(PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair *this, PB::Reader *a2)
{
  unint64_t v2 = *((void *)a2 + 1);
  unint64_t v3 = *((void *)a2 + 2);
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)a2 + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_24;
        }
      }
LABEL_20:
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v11 >> 3) == 2)
      {
        *((unsigned char *)this + 20) |= 1u;
        unint64_t v20 = *((void *)a2 + 1);
        unint64_t v21 = *((void *)a2 + 2);
        uint64_t v22 = *(void *)a2;
        if (v20 > 0xFFFFFFFFFFFFFFF5 || v20 + 10 > v21)
        {
          char v28 = 0;
          unsigned int v29 = 0;
          uint64_t v25 = 0;
          if (v21 <= v20) {
            unint64_t v21 = *((void *)a2 + 1);
          }
          while (1)
          {
            if (v21 == v20)
            {
              LODWORD(v25) = 0;
              *((unsigned char *)a2 + 24) = 1;
              goto LABEL_43;
            }
            unint64_t v30 = v20 + 1;
            char v31 = *(unsigned char *)(v22 + v20);
            *((void *)a2 + 1) = v30;
            v25 |= (unint64_t)(v31 & 0x7F) << v28;
            if ((v31 & 0x80) == 0) {
              break;
            }
            v28 += 7;
            unint64_t v20 = v30;
            BOOL v14 = v29++ > 8;
            if (v14)
            {
LABEL_39:
              LODWORD(v25) = 0;
              goto LABEL_43;
            }
          }
          if (*((unsigned char *)a2 + 24)) {
            LODWORD(v25) = 0;
          }
        }
        else
        {
          char v23 = 0;
          unsigned int v24 = 0;
          uint64_t v25 = 0;
          while (1)
          {
            unint64_t v26 = v20 + 1;
            *((void *)a2 + 1) = v20 + 1;
            char v27 = *(unsigned char *)(v22 + v20);
            v25 |= (unint64_t)(v27 & 0x7F) << v23;
            if ((v27 & 0x80) == 0) {
              break;
            }
            v23 += 7;
            unint64_t v20 = v26;
            BOOL v14 = v24++ > 8;
            if (v14) {
              goto LABEL_39;
            }
          }
        }
LABEL_43:
        *((_DWORD *)this + 4) = v25;
      }
      else
      {
        if ((v11 >> 3) == 1) {
          operator new();
        }
LABEL_24:
        uint64_t result = PB::Reader::skip(a2);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)a2 + 1);
      unint64_t v3 = *((void *)a2 + 2);
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)a2 + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14) {
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair::~PBFontNameAndDescriptorFlagsPair(PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair *this)
{
  PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair::~PBFontNameAndDescriptorFlagsPair(this);

  JUMPOUT(0x18532A2A0);
}

{
  uint64_t v2;
  uint64_t vars8;

  unint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_1ED0946D0;
  *((void *)this + 1) = 0;
  if (v2) {
    std::default_delete<std::string>::operator()[abi:fe180100](v2);
  }

  PB::Base::~Base(this);
}

atomic_uint *CGGlyphBitmapRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

void CGGlyphBitmapRelease(void *a1)
{
  if (a1)
  {
    if (atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(a1);
    }
  }
}

UInt8 *CGGlyphBitmapCreateWithPath(UInt8 *a1, int a2, uint64_t a3, int a4, double *a5)
{
  return CGGlyphBitmapCreateWithPathAndDilation(a1, a2, a3, a4, a5);
}

void CGGlyphBitmapWriteToFile(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  bzero(__str, 0x401uLL);
  __filename = 0;
  if (CGGetTempDirPath_predicate != -1) {
    dispatch_once(&CGGetTempDirPath_predicate, &__block_literal_global_119);
  }
  snprintf(__str, 0x400uLL, "%s%s", &CGGetTempDirPath_tempDirPath, "glyphbitmap");
  unint64_t v2 = "bmi=0x0.br2";
  int v3 = *(_DWORD *)(a1 + 28);
  if (v3 == 16) {
    unint64_t v2 = "bmi=0x00001000.br2";
  }
  asprintf(&__filename, "%s_%d_%d_w=%d,h=%d,rb=%d,cs=0,bpc=%d,%s", __str, *(unsigned __int16 *)(a1 + 4), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 32), v3, v2);
  int v4 = fopen(__filename, "w");
  free(__filename);
  if (v4)
  {
    fwrite((const void *)(a1 + 40), *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 24), v4);
    fclose(v4);
  }
}

void DoPdfForm(uint64_t a1, CGPDFStream *a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 2056) <= 0xF9u && a2 != 0)
  {
    int v5 = (CGPDFDictionary *)*((void *)a2 + 6);
    if (v5)
    {
      CPPDFContextSaveGState(a1);
      CGPDFArrayRef value = 0;
      if (CGPDFDictionaryGetArray(v5, "Matrix", &value))
      {
        size_t v8 = 0;
        char v9 = v36;
        while (CGPDFArrayGetNumber(value, v8, v9))
        {
          ++v8;
          ++v9;
          if (v8 == 6)
          {
            unsigned int v10 = *(float64x2_t **)(a1 + 40);
            float64x2_t v11 = v10[1];
            float64x2_t v12 = v10[2];
            float64x2_t v13 = vaddq_f64(v10[3], vmlaq_n_f64(vmulq_laneq_f64(v12, v38, 1), v11, v38.f64[0]));
            float64x2_t v14 = vmlaq_n_f64(vmulq_laneq_f64(v12, v37, 1), v11, v37.f64[0]);
            v10[1] = vmlaq_n_f64(vmulq_laneq_f64(v12, *(float64x2_t *)v36, 1), v11, v36[0]);
            v10[2] = v14;
            v10[3] = v13;
            break;
          }
        }
      }
      if (CGPDFDictionaryGetArray(v5, "BBox", &value))
      {
        size_t v15 = 0;
        unsigned int v16 = v36;
        while (CGPDFArrayGetNumber(value, v15, v16))
        {
          ++v15;
          ++v16;
          if (v15 == 4)
          {
            CGFloat v17 = v36[0];
            CGFloat v18 = v36[1];
            CGFloat v19 = v37.f64[0] - v36[0];
            CGFloat v20 = v37.f64[1] - v36[1];
            uint64_t v21 = *(void *)(*(void *)(a1 + 40) + 64);
            Mutable = CGPathCreateMutable();
            uint64_t v23 = *(void *)(a1 + 40);
            *(void *)(v23 + 64) = Mutable;
            v40.origin.x = v17;
            v40.origin.y = v18;
            v40.size.width = v19;
            v40.size.height = v20;
            CGPathAddRect(Mutable, (const CGAffineTransform *)(v23 + 16), v40);
            CPPDFContextAddClip(a1, 1);
            CPPDFContextAddPathToClip(a1, 0);
            uint64_t v24 = *(void *)(a1 + 40);
            uint64_t v25 = *(const void **)(v24 + 64);
            if (v25)
            {
              CFRelease(v25);
              uint64_t v24 = *(void *)(a1 + 40);
            }
            *(void *)(v24 + 64) = v21;
            break;
          }
        }
      }
      unint64_t v26 = CGPDFOperatorTableCreate();
      char v27 = v26;
      if (a3) {
        AddLazyPdfOperators();
      }
      else {
        AddPdfOperators(v26);
      }
      CGPDFDictionaryRef streamResources = 0;
      if (CGPDFDictionaryGetDictionary(v5, "Resources", &streamResources))
      {
        char v28 = CGPDFContentStreamCreateWithStream(a2, streamResources, *(CGPDFContentStreamRef *)(a1 + 8 * (*(_DWORD *)(a1 + 2056) - 1) + 56));
        if (v28)
        {
          unsigned int v29 = v28;
          uint64_t v30 = *(unsigned int *)(a1 + 2056);
          *(_DWORD *)(a1 + 2056) = v30 + 1;
          *(void *)(a1 + 8 * v30 + 56) = v28;
          CGPDFScannerRef v31 = CGPDFScannerCreate(v28, v27, (void *)a1);
          if (v31)
          {
            uint64_t v32 = v31;
            *(unsigned char *)(*(void *)(a1 + 40) + 8) = 1;
            CPPDFContextSaveGState(a1);
            *(unsigned char *)(*(void *)(a1 + 40) + 8) = 0;
            CGPDFScannerScan(v32);
            CPPDFContextRestoreGState(a1);
            uint64_t v33 = *(void *)(a1 + 40);
            if (v33) {
              *(unsigned char *)(v33 + 8) = 0;
            }
            --*(_DWORD *)(a1 + 2056);
            CFRelease(v32);
          }
          CFRelease(v29);
        }
      }
      if (v27) {
        CFRelease(v27);
      }
      CPPDFContextRestoreGState(a1);
    }
  }
}

void SetColor(CGPDFScanner *scanner, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v4 = (uint64_t *)(a2 + 40);
  uint64_t v5 = 264;
  if (a3) {
    uint64_t v5 = 280;
  }
  float v6 = *(CGColorSpace **)(*(void *)(a2 + 40) + v5);
  if (!v6)
  {
    CGPDFObjectRef Resource = 0;
LABEL_28:
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
    *(_OWORD *)name = xmmword_1852950E0;
    long long v22 = unk_1852950F0;
    CGColorRef v10 = CGColorCreate(DeviceRGB, (const CGFloat *)name);
    CGColorSpaceRelease(DeviceRGB);
    goto LABEL_29;
  }
  uint64_t v8 = *((void *)v6 + 3);
  if (*(_DWORD *)(v8 + 28) != 6)
  {
    CGPDFObjectRef Resource = 0;
    CGColorRef v10 = 0;
    goto LABEL_21;
  }
  float v6 = **(CGColorSpace ***)(v8 + 96);
  if (v6)
  {
LABEL_15:
    CGColorRef v10 = 0;
  }
  else
  {
    char v9 = (uint64_t *)(a2 + 40);
    do
    {
      char v9 = (uint64_t *)*v9;
      if (!v9)
      {
        float v6 = 0;
        goto LABEL_15;
      }
    }
    while (!*((unsigned char *)v9 + 8));
    CGColorRef v10 = (CGColorRef)v9[32];
    if (v10) {
      CFRetain((CFTypeRef)v9[32]);
    }
    float v6 = 0;
  }
  name[0] = 0;
  CGPDFObjectRef Resource = 0;
  if (CGPDFScannerPopName(scanner, (const char **)name))
  {
    float64x2_t v12 = (CGPDFContentStream *)*((void *)scanner + 7);
    if (!v12)
    {
      CGPDFObjectRef Resource = 0;
      if (!v6)
      {
LABEL_27:
        if (v10) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }
      goto LABEL_20;
    }
    CGPDFObjectRef Resource = CGPDFContentStreamGetResource(v12, "Pattern", name[0]);
  }
  if (!v6) {
    goto LABEL_27;
  }
LABEL_20:
  uint64_t v8 = *((void *)v6 + 3);
LABEL_21:
  uint64_t v13 = *(void *)(v8 + 48);
  if (!v13) {
    goto LABEL_27;
  }
  float64x2_t v14 = (CGFloat *)malloc_type_calloc(v13 + 1, 8uLL, 0x100004000313F17uLL);
  v14[v13] = 1.0;
  uint64_t v15 = v13 - 1;
  do
  {
    name[0] = 0;
    if (!CGPDFScannerPopNumber(scanner, (CGPDFReal *)name)) {
      break;
    }
    v14[v15--] = *(CGFloat *)name;
  }
  while (v15 != -1);
  CGColorRef v10 = CGColorCreate(v6, v14);
  free(v14);
LABEL_29:
  uint64_t v17 = *v4;
  if (a3)
  {
    CGFloat v18 = *(const void **)(v17 + 272);
    if (v18)
    {
      CFRelease(v18);
      uint64_t v17 = *v4;
    }
    *(void *)(v17 + 272) = v10;
    CGFloat v19 = (CGPDFObjectRef *)(v17 + 384);
  }
  else
  {
    CGFloat v20 = *(const void **)(v17 + 256);
    if (v20)
    {
      CFRelease(v20);
      uint64_t v17 = *v4;
    }
    *(void *)(v17 + 256) = v10;
    CGFloat v19 = (CGPDFObjectRef *)(v17 + 376);
  }
  *CGFloat v19 = Resource;
  *(unsigned char *)(v17 + 9) = 1;
}

void ShowText(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  double v149 = fabs(sqrt(fabs((*(double *)(v2 + 96) * *(double *)(v2 + 32) + *(double *)(v2 + 88) * *(double *)(v2 + 16))* (*(double *)(v2 + 112) * *(double *)(v2 + 40) + *(double *)(v2 + 104) * *(double *)(v2 + 24))- (*(double *)(v2 + 96) * *(double *)(v2 + 40) + *(double *)(v2 + 88) * *(double *)(v2 + 24))* (*(double *)(v2 + 112) * *(double *)(v2 + 32) + *(double *)(v2 + 104) * *(double *)(v2 + 16))))* *(double *)(v2 + 216));
  if (v149 < 0.00100000005) {
    return;
  }
  uint64_t v4 = a1;
  uint64_t v5 = *(void **)(v2 + 248);
  [v5 ascent];
  double v7 = v6;
  [v5 descent];
  double v9 = v8;
  CGColorRef v10 = *(double **)(v4 + 40);
  double v11 = v10[27];
  double v12 = v10[25];
  double v13 = v10[29];
  uint64_t v162 = v5;
  float64x2_t v14 = (atomic_ullong *)[v5 cgPDFFont];
  ROSUnicodeunint64_t CMap = 0;
  long long v182 = 0u;
  long long v183 = 0u;
  long long v180 = 0u;
  long long v181 = 0u;
  long long v177 = 0u;
  uint64_t v178 = 0;
  Encoding = CGPDFFontGetEncoding(v14);
  v179 = Encoding;
  Advances = CGPDFFontGetAdvances((void ***)v14);
  *(void *)&long long v180 = Advances;
  BYTE8(v180) = 1;
  unsigned int v16 = (const CGAffineTransform *)(v14 + 7);
  if (!v14) {
    unsigned int v16 = &CGAffineTransformIdentity;
  }
  long long v17 = *(_OWORD *)&v16->c;
  long long v181 = *(_OWORD *)&v16->a;
  long long v182 = v17;
  long long v183 = *(_OWORD *)&v16->tx;
  v185 = 0;
  uint64_t v186 = v4;
  uint64_t v147 = (uint64_t)v14;
  if (Encoding)
  {
    ROSUnicodeunint64_t CMap = 0;
    if (a2)
    {
      if (*(void *)(a2 + 24))
      {
        decrypt_string(a2);
        uint64_t v18 = *(void *)(a2 + 24);
        uint64_t v148 = a2 + 80;
        uint64_t v178 = a2 + 80;
        if (v18) {
          decrypt_string(a2);
        }
      }
      else
      {
        uint64_t v148 = a2 + 80;
        uint64_t v178 = a2 + 80;
      }
      char v137 = 0;
      uint64_t v139 = 0;
      v140 = 0;
      uint64_t CIDsForText = *(void *)(a2 + 72);
    }
    else
    {
      char v137 = 0;
      uint64_t v139 = 0;
      v140 = 0;
      uint64_t v148 = 0;
      uint64_t CIDsForText = 0;
      uint64_t v178 = 0;
    }
    BOOL v22 = 1;
    goto LABEL_36;
  }
  *((void *)&v177 + 1) = 0;
  unint64_t CMap = CGPDFFontGetCMap((unint64_t)v14);
  uint64_t v20 = CMap;
  BOOL v22 = !CMap
     || !cmap_vtable
     || (uint64_t v21 = *(uint64_t (**)(void))(cmap_vtable + 40)) == 0
     || v21(*(void *)(CMap + 16)) == 0;
  BYTE8(v180) = v22;
  if (a2)
  {
    if (*(void *)(a2 + 24))
    {
      decrypt_string(a2);
      uint64_t v23 = (unsigned char *)(a2 + 80);
      if (*(void *)(a2 + 24)) {
        decrypt_string(a2);
      }
    }
    else
    {
      uint64_t v23 = (unsigned char *)(a2 + 80);
    }
    a2 = *(void *)(a2 + 72);
  }
  else
  {
    uint64_t v23 = 0;
  }
  uint64_t v25 = malloc_type_malloc(2 * a2, 0x1000040BDFB0063uLL);
  uint64_t CIDsForText = CGPDFCMapGetCIDsForText(v20, v23, a2, (uint64_t)v25, 0, v26);
  if (CIDsForText)
  {
    *((void *)&v177 + 1) = v25;
  }
  else
  {
    free(v25);
    uint64_t v25 = 0;
  }
  ROSUnicodeunint64_t CMap = CGPDFFontGetToUnicodeCMap((uint64_t)v14);
  uint64_t v139 = ROSUnicodeCMap;
  v140 = v25;
  if (!ROSUnicodeCMap)
  {
    ROSUnicodeunint64_t CMap = (uint64_t)CGPDFFontGetROSUnicodeCMap((char *)v14);
    uint64_t v139 = ROSUnicodeCMap;
    if (!ROSUnicodeCMap)
    {
      char v137 = 0;
      uint64_t v139 = 0;
      goto LABEL_35;
    }
  }
  if (!cmap_vtable
    || (char v27 = *(uint64_t (**)(void))(cmap_vtable + 56)) == 0
    || (unint64_t v28 = v27(*(void *)(v139 + 16)), v28 < 2))
  {
    char v137 = 0;
LABEL_35:
    uint64_t v148 = 0;
    goto LABEL_36;
  }
  uint64_t v148 = 0;
  char v137 = malloc_type_malloc(2 * v28, 0x1000040BDFB0063uLL);
  v185 = v137;
LABEL_36:
  double v29 = *((double *)&v181 + 1);
  double v30 = *(double *)&v182;
  double v31 = *((double *)&v183 + 1);
  double v32 = *(double *)&v183;
  double v33 = -(*(double *)&v182 - *(double *)&v181 * 0.0);
  if (!v22)
  {
    double v31 = *((double *)&v182 + 1) * 0.0 + *((double *)&v181 + 1) * 0.0 + *((double *)&v183 + 1);
    double v32 = *(double *)&v183 + *(double *)&v182 * 0.0 + *(double *)&v181 * 0.0;
  }
  double v159 = *((double *)&v182 + 1);
  double v160 = *(double *)&v181;
  if (v22) {
    double v34 = *((double *)&v182 + 1);
  }
  else {
    double v34 = *((double *)&v181 + 1) + *((double *)&v182 + 1) * 0.0;
  }
  if (v22)
  {
    double v33 = *(double *)&v181;
  }
  else
  {
    double v30 = *(double *)&v181 + *(double *)&v182 * 0.0;
    double v29 = -(*((double *)&v182 + 1) - *((double *)&v181 + 1) * 0.0);
  }
  if (CIDsForText)
  {
    uint64_t v35 = 0;
    uint64_t v133 = 0;
    BOOL v165 = 0;
    unsigned __int8 v36 = 0;
    double v37 = v11 * (v12 / 100.0);
    double v38 = v149 * v7 - v9 * v149;
    double v145 = v29 * v11 + v33 * 0.0;
    double v146 = v29 * 0.0 + v33 * v37;
    double v143 = v34 * v11 + v30 * 0.0;
    double v144 = v34 * 0.0 + v30 * v37;
    double v141 = v11 * v31 + v32 * 0.0 + v13;
    double v142 = v31 * 0.0 + v32 * v37 + 0.0;
    double v138 = fabs(v38);
    double v39 = -v38;
    uint64_t v134 = v4 + 2064;
    double v40 = --(v9 * v149);
    if (v38 >= 0.0) {
      double v39 = v149 * v7 - v9 * v149;
    }
    else {
      double v40 = v149 * v7;
    }
    double v135 = v40;
    CGFloat rect = v39;
    uint64_t v156 = v4;
    unint64_t v153 = CIDsForText;
    unint64_t v154 = Encoding;
    BOOL v155 = v22;
    do
    {
      int v176 = 0;
      LOBYTE(bboxes.origin.x) = 0;
      if (Encoding)
      {
        unint64_t v41 = *(unsigned __int8 *)(v148 + v35);
        HIWORD(v176) = *(unsigned __int8 *)(v148 + v35);
        v187.a = 0.0;
        UnicodesForIndeCGFloat x = (unsigned __int16 *)CGPDFEncodingGetUnicodesForIndex((uint64_t)Encoding, v41, &v187);
        LOBYTE(bboxes.origin.x) = CPFontEnumeratorIsKnownRenderedChar(*(uint64_t *)&v187.a, UnicodesForIndex);
        if (!*(void *)&v187.a) {
          goto LABEL_53;
        }
        if (*(void *)&v187.a == 1)
        {
          LODWORD(v41) = *UnicodesForIndex;
LABEL_53:
          LOWORD(v176) = v41;
          goto LABEL_62;
        }
        LODWORD(v41) = CPFontEnumeratorProcessMultiUnicodes((uint64_t)&v177, *(uint64_t *)&v187.a, UnicodesForIndex);
        LOWORD(v176) = v41;
        if (v41) {
          LOBYTE(bboxes.origin.x) = CPFontEnumeratorIsKnownRenderedChar(1, (unsigned __int16 *)&v176);
        }
      }
      else
      {
        uint64_t v43 = (unsigned __int16)v140[v35];
        HIWORD(v176) = v140[v35];
        if (v139)
        {
          BOOL v44 = (unsigned __int16 *)v137;
          if (!v137) {
            BOOL v44 = (unsigned __int16 *)&v187;
          }
          LODWORD(v41) = CPFontEnumeratorGetUnicharForCID((uint64_t)&v177, v43, v44, (BOOL *)&bboxes);
          LOWORD(v176) = v41;
        }
        else
        {
          LODWORD(v41) = 0;
        }
      }
LABEL_62:
      unint64_t v45 = HIWORD(v176);
      double HorizontalAdvance = CGPDFAdvancesGetHorizontalAdvance((uint64_t)Advances, HIWORD(v176));
      double VerticalAdvance = CGPDFAdvancesGetVerticalAdvance((uint64_t)Advances, v45, (uint64_t)&v187);
      *(void *)&long long v177 = v35 + 1;
      int x_low = LOBYTE(bboxes.origin.x);
      BOOL v49 = LOBYTE(bboxes.origin.x) != 0;
      float v50 = *(float64x2_t **)(v4 + 40);
      double v52 = v50[5].f64[1];
      double v51 = v50[6].f64[0];
      double v53 = v50[6].f64[1];
      double v54 = v50[7].f64[0];
      double v56 = v50[7].f64[1];
      double v55 = v50[8].f64[0];
      float64x2_t v167 = v50[2];
      float64x2_t v170 = v50[1];
      int v57 = v41 & 0xFFFFFF7F;
      float64x2_t v163 = v50[3];
      if ((v41 & 0xFFFFFF7F) == 0x20)
      {
        char v58 = 1;
      }
      else
      {
        if (v41 > 0x7F) {
          int v59 = __maskrune(v41, 0x4000uLL);
        }
        else {
          int v59 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v41 + 60) & 0x4000;
        }
        if (v59) {
          BOOL v60 = 1;
        }
        else {
          BOOL v60 = v41 == 65532;
        }
        char v58 = v60;
      }
      memset(&bboxes, 0, sizeof(bboxes));
      CGGlyph glyphs = 0;
      BOOL v61 = 0;
      if ([v162 getGlyphs:&glyphs forCodes:(char *)&v176 + 2 count:1])
      {
        Font = (CGFont *)CGPDFFontGetFont(v147);
        if (Font && (float v63 = Font, CGFontGetGlyphBBoxes(Font, &glyphs, 1uLL, &bboxes)))
        {
          BOOL v61 = bboxes.size.height <= 0.00000011920929 && bboxes.size.width <= 0.00000011920929;
          font_info = get_font_info(v63);
          if (font_info) {
            int v65 = font_info[2];
          }
          else {
            int v65 = 0;
          }
          v173.b = 0.0;
          v173.c = 0.0;
          v173.a = v149 / (double)v65;
          v173.d = v173.a;
          v173.tCGFloat x = 0.0;
          v173.tdouble y = 0.0;
          CGRect bboxes = CGRectApplyAffineTransform(bboxes, &v173);
        }
        else
        {
          BOOL v61 = 0;
        }
      }
      double v66 = HorizontalAdvance * v160;
      double v67 = VerticalAdvance * v159;
      if ((v58 & 1) == 0)
      {
        double v150 = v66;
        double v151 = v56;
        double v152 = v55;
        if (((x_low != 0) & v36) == 1)
        {
          uint64_t v4 = v156;
          if (*(double *)(*(void *)(v156 + 40) + 184) == 0.0) {
            int v75 = v165;
          }
          else {
            int v75 = -1;
          }
        }
        else
        {
          int v75 = -1;
          uint64_t v4 = v156;
        }
        BOOL v69 = v155;
        float64x2_t v78 = vmlaq_n_f64(vmulq_n_f64(v167, v145 * v54 + v146 * v51), v170, v145 * v53 + v146 * v52);
        float64x2_t v79 = vmlaq_n_f64(vmulq_n_f64(v167, v143 * v54 + v144 * v51), v170, v143 * v53 + v144 * v52);
        float64x2_t v80 = vmulq_f64(v78, (float64x2_t)vextq_s8((int8x16_t)v79, (int8x16_t)v79, 8uLL));
        unsigned __int8 v81 = vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v80, 1), v80)).u8[0];
        double v82 = v78.f64[1];
        double v84 = v78.f64[1];
        double v83 = v78.f64[0];
        double v166 = VerticalAdvance * v159;
        float64x2_t v157 = v78;
        float64x2_t v158 = v79;
        if (v78.f64[1] == 0.0)
        {
          double v85 = 0.0;
          if ((v78.f64[0] <= 0.0) | v81 & 1)
          {
            double v84 = v78.f64[1];
            double v83 = v78.f64[0];
            if (v78.f64[0] != 0.0) {
              goto LABEL_105;
            }
            double v83 = v79.f64[1];
            if (v79.f64[0] != 0.0 || v79.f64[1] != 0.0)
            {
              double v84 = -v79.f64[0];
              goto LABEL_105;
            }
          }
        }
        else
        {
LABEL_105:
          double v86 = fabs(v83);
          double v87 = fabs(v84);
          if (v86 >= v87) {
            double v88 = v84;
          }
          else {
            double v88 = v83;
          }
          if (v86 >= v87) {
            double v89 = v83;
          }
          else {
            double v89 = v84;
          }
          long double v90 = atan(v88 / v89);
          float64x2_t v78 = v157;
          double v67 = v166;
          double v91 = v90 * 57.2957795;
          if (v86 < v87) {
            double v91 = 90.0 - v91;
          }
          char v92 = v81 ^ 1;
          if (v89 >= 0.0) {
            char v92 = v81;
          }
          double v93 = v91 + 180.0;
          if ((v92 & 1) == 0) {
            double v93 = v91;
          }
          if (v93 < 0.0) {
            double v93 = v93 + 360.0;
          }
          if (v93 >= 360.0) {
            double v93 = 0.0;
          }
          double v94 = fabs(v93);
          BOOL v95 = v94 <= INFINITY;
          if (v94 >= INFINITY) {
            double v96 = 0.0;
          }
          else {
            double v96 = v93;
          }
          float64x2_t v79 = v158;
          if (v95) {
            double v85 = v96;
          }
          else {
            double v85 = v93;
          }
          if (v85 < 0.0 || v85 >= 360.0) {
            __assert_rtn("CPRotationDegreesFromTransform", "CPGeometry.m", 111, "0. <= degrees && degrees < 360.");
          }
        }
        float64x2_t v97 = vaddq_f64(v163, vmlaq_n_f64(vmulq_n_f64(v167, v54 * v141 + v142 * v51 + v152), v170, v151 + v53 * v141 + v142 * v52));
        float64x2_t v98 = vaddq_f64(v97, vmlaq_f64(vmulq_f64(v79, (float64x2_t)0), (float64x2_t)0, v78));
        float64x2_t v171 = v98;
        if (v85 <= 0.1 || 360.0 - v85 <= 0.1)
        {
          bboxes.origin = (CGPoint)vaddq_f64(v98, (float64x2_t)bboxes.origin);
          double v85 = 0.0;
          float64x2_t v103 = v98;
        }
        else
        {
          float64x2_t v168 = v97;
          __double2 v99 = __sincos_stret(v85 * -3.14159265 / 180.0);
          double v67 = v166;
          v100.f64[0] = v157.f64[0] * v99.__cosval - v99.__sinval * v82;
          v100.f64[1] = v82 * v99.__cosval + v157.f64[0] * v99.__sinval;
          v101.f64[0] = vmlad_n_f64(vmuld_lane_f64(-v99.__sinval, v158, 1), v99.__cosval, v158.f64[0]);
          v101.f64[1] = vmlad_n_f64(vmuld_lane_f64(v99.__cosval, v158, 1), v99.__sinval, v158.f64[0]);
          v102.f64[0] = vmlad_n_f64(vmuld_lane_f64(-v99.__sinval, v168, 1), v99.__cosval, v168.f64[0]) + 0.0;
          v102.f64[1] = vmlad_n_f64(vmuld_lane_f64(v99.__cosval, v168, 1), v99.__sinval, v168.f64[0]) + 0.0;
          float64x2_t v103 = vaddq_f64(v102, vmlaq_f64(vmulq_f64(v101, (float64x2_t)0), (float64x2_t)0, v100));
          bboxes.origin = (CGPoint)vaddq_f64(v103, (float64x2_t)bboxes.origin);
        }
        double v66 = v150;
        BOOL v68 = 0;
        CGRect v172 = bboxes;
        double v104 = v149 * v150;
        if (v155)
        {
          double v105 = v149 * v67;
        }
        else
        {
          double v104 = -(v149 * v67);
          double v105 = 0.0;
        }
        if (v81) {
          double v106 = -v104;
        }
        else {
          double v106 = v104;
        }
        unsigned __int8 v36 = v49;
        if (fabs(v103.f64[0]) != INFINITY)
        {
          float64_t v107 = v103.f64[1];
          unsigned __int8 v36 = v49;
          if (fabs(v103.f64[1]) != INFINITY)
          {
            unsigned __int8 v36 = v49;
            if (fabs(v104) != INFINITY)
            {
              unsigned __int8 v36 = v49;
              if (fabs(v105) != INFINITY)
              {
                unsigned __int8 v36 = v49;
                if (v138 != INFINITY)
                {
                  __int16 v108 = HIWORD(v176);
                  if (v106 >= 0.0) {
                    double v109 = -0.0;
                  }
                  else {
                    double v109 = v106;
                  }
                  if (v106 >= 0.0) {
                    double v110 = v106;
                  }
                  else {
                    double v110 = -v106;
                  }
                  if (x_low || (BOOL v68 = !v61))
                  {
                    if (*(void *)(v4 + 2264))
                    {
                      unsigned __int8 v36 = v49;
                      BOOL v68 = 0;
                      if (fabs(v85) != INFINITY)
                      {
                        CGFloat x = v103.f64[0] + v109;
                        BOOL v112 = 360.0 - v85 > 0.1 && v85 > 0.1;
                        CGFloat height = rect;
                        double v114 = v103.f64[1] + v135;
                        CGFloat width = v110;
                        double y = v103.f64[1] + v135;
                        double v169 = v103.f64[0] + v109;
                        float64_t v164 = v103.f64[0];
                        if (v112)
                        {
                          CGFloat v117 = v110;
                          __int16 v118 = HIWORD(v176);
                          __double2 v119 = __sincos_stret(v85 * 0.0174532925);
                          v187.tCGFloat x = 0.0;
                          v187.tdouble y = 0.0;
                          v187.a = v119.__cosval;
                          v187.b = v119.__sinval;
                          v187.c = -v119.__sinval;
                          v187.d = v119.__cosval;
                          v188.origin.CGFloat x = v169;
                          v188.origin.double y = v114;
                          v188.size.CGFloat width = v117;
                          v188.size.CGFloat height = rect;
                          CGRect v189 = CGRectApplyAffineTransform(v188, &v187);
                          __int16 v108 = v118;
                          double v110 = v117;
                          double v67 = v166;
                          CGFloat x = v189.origin.x;
                          double y = v189.origin.y;
                          CGFloat width = v189.size.width;
                          CGFloat height = v189.size.height;
                        }
                        BOOL v68 = 0;
                        unsigned __int8 v36 = v49;
                        if (fabs(*(double *)v4) != INFINITY)
                        {
                          double v121 = *(double *)(v4 + 8);
                          unsigned __int8 v36 = v49;
                          if (fabs(v121) != INFINITY)
                          {
                            double v122 = *(double *)(v4 + 16);
                            unsigned __int8 v36 = v49;
                            if (fabs(v122) != INFINITY)
                            {
                              double v123 = *(double *)(v4 + 24);
                              unsigned __int8 v36 = v49;
                              if (fabs(v123) != INFINITY)
                              {
                                __int16 v124 = v108;
                                double v125 = v110;
                                double v120 = *(double *)v4;
                                if (CGRectIntersectsRect(*(CGRect *)(&v121 - 1), *(CGRect *)&x)
                                  && primitiveBufferMemoryCheck(v4, v134))
                                {
                                  uint64_t v126 = *(void *)(v4 + 2072);
                                  *(double *)uint64_t v126 = v169;
                                  *(double *)(v126 + 8) = v114;
                                  *(double *)(v126 + 16) = v125;
                                  *(CGFloat *)(v126 + 24) = rect;
                                  *(CGRect *)(v126 + 32) = v172;
                                  *(void *)(v126 + 64) = 0;
                                  *(_WORD *)(v126 + 72) = v41;
                                  *(_WORD *)(v126 + 74) = v124;
                                  *(_DWORD *)(v126 + 76) = 0;
                                  *(float64_t *)(v126 + 80) = v164;
                                  *(float64_t *)(v126 + 88) = v107;
                                  *(float64x2_t *)(v126 + 96) = v171;
                                  *(double *)(v126 + 112) = v171.f64[0] + v109;
                                  *(double *)(v126 + 120) = v171.f64[1] + v135;
                                  *(double *)(v126 + 128) = v125;
                                  *(CGFloat *)(v126 + 136) = rect;
                                  *(double *)(v126 + 144) = v106;
                                  *(double *)(v126 + 152) = v105;
                                  *(void *)(v126 + 160) = 0;
                                  *(double *)(v126 + 168) = v85;
                                  *(_DWORD *)(v126 + 176) = v75;
                                  *(_DWORD *)(v126 + 188) = 0;
                                  *(void *)(v126 + 180) = 0;
                                  if (v112) {
                                    ++*(_DWORD *)(v4 + 2280);
                                  }
                                  *(_DWORD *)(v126 + 68) = *(_DWORD *)(v4 + 2272);
                                  uint64_t v127 = *(void *)(v4 + 40);
                                  int v128 = *(_DWORD *)(v127 + 80);
                                  *(_DWORD *)(v126 + 64) = v128;
                                  Style = v133;
                                  if (!v133)
                                  {
                                    Style = *(unsigned __int8 **)(v4 + 2256);
                                    if (!Style || *(unsigned char *)(v127 + 9))
                                    {
                                      Style = CPPDFStyleListGetStyle(v4);
                                      int v128 = *(_DWORD *)(*(void *)(v4 + 40) + 80);
                                    }
                                  }
                                  double v67 = v166;
                                  *(void *)(v126 + 160) = Style;
                                  *(_DWORD *)(v126 + 64) = v128;
                                  uint64_t v130 = *(void *)(v4 + 2344);
                                  uint64_t v133 = Style;
                                  if (v130 && (uint64_t v131 = *(void *)(v130 + 16)) != 0)
                                  {
                                    uint64_t CurrentMCID = TaggedParser::GetCurrentMCID(v131, *(CGPDFPage **)(v4 + 2288));
                                    double v67 = v166;
                                  }
                                  else
                                  {
                                    uint64_t CurrentMCID = -1;
                                  }
                                  *(void *)(v126 + 184) = CurrentMCID;
                                  *(void *)(v4 + 2072) = v126 + 192;
                                  *(_DWORD *)(*(void *)(v4 + 2264) + 4 * (*(_DWORD *)(v4 + 2272))++) = 2;
                                  BOOL v68 = 0;
                                  unsigned __int8 v36 = v49;
                                }
                                else
                                {
                                  BOOL v68 = 0;
                                  unsigned __int8 v36 = v49;
                                  double v67 = v166;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    else
                    {
                      unsigned __int8 v36 = v49;
                      BOOL v68 = 0;
                    }
                  }
                  else
                  {
                    unsigned __int8 v36 = 0;
                  }
                }
              }
            }
          }
        }
        goto LABEL_86;
      }
      v36 &= v57 == 32 && !v165;
      BOOL v68 = v57 == 32;
      uint64_t v4 = v156;
      BOOL v69 = v155;
LABEL_86:
      BOOL v165 = v68;
      uint64_t v70 = *(void *)(v4 + 40);
      double v71 = *(double *)(v70 + 216);
      double v72 = *(double *)(v70 + 184);
      if (v69)
      {
        double v73 = v72 + v66 * v71;
        unint64_t v74 = v153;
        Encoding = v154;
        if (HIWORD(v176) == 32) {
          double v73 = v73 + *(double *)(v70 + 192);
        }
        double v77 = v73 * (*(double *)(v70 + 200) / 100.0);
        double v76 = 0.0;
      }
      else
      {
        double v76 = v72 + v67 * v71;
        double v77 = 0.0;
        unint64_t v74 = v153;
        Encoding = v154;
        if (HIWORD(v176) == 32) {
          double v76 = v76 + *(double *)(v70 + 192);
        }
      }
      *(float64x2_t *)(v70 + 120) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(v70 + 120), *(float64x2_t *)(v70 + 88), v77), *(float64x2_t *)(v70 + 104), v76);
      ++v35;
    }
    while (v74 > v35);
  }
  if (!Encoding)
  {
    free(v140);
    free(v185);
  }
}

uint64_t AdjustPosition(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  double v10 = a2 / -1000.0 * *(double *)(v3 + 216);
  uint64_t result = [*(id *)(v3 + 248) isHorizontal];
  uint64_t v5 = *(void *)(a1 + 40);
  float64x2_t v6 = *(float64x2_t *)(v5 + 88);
  float64x2_t v7 = *(float64x2_t *)(v5 + 104);
  float64x2_t v8 = *(float64x2_t *)(v5 + 120);
  if (result) {
    float64x2_t v9 = vmlaq_f64(vmlaq_n_f64(v8, v6, v10), (float64x2_t)0, v7);
  }
  else {
    float64x2_t v9 = vmlaq_n_f64(vmlaq_f64(v8, (float64x2_t)0, v6), v7, v10);
  }
  *(float64x2_t *)(v5 + 120) = v9;
  return result;
}

void *CGPDFRStateCreate()
{
  v0 = malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v0) {
    void *v0 = CGPDFGStateCreate();
  }
  return v0;
}

void *CGPDFRStateCreateCopy(long long **a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2) {
    void *v2 = CGPDFGStateCreateCopy(*a1);
  }
  return v2;
}

void CGPDFRStateRelease(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[1];
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)v2[1];
        if (v3)
        {
          CGPDFGStateReleaseProperties((void *)v2[1]);
          free(v3);
        }
        uint64_t v2 = (void *)*v2;
      }
      while (v2);
      uint64_t v4 = (void *)a1[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = (void *)*v4;
          free(v4);
          uint64_t v4 = v5;
        }
        while (v5);
      }
    }
    float64x2_t v6 = (void *)*a1;
    if (*a1)
    {
      CGPDFGStateReleaseProperties((void *)*a1);
      free(v6);
    }
    free(a1);
  }
}

uint64_t CGPDFRStateGetGState(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

long long **CGPDFRStateSetGState(long long **result, long long *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = *result;
    if (*result != a2)
    {
      if (v4)
      {
        CGPDFGStateReleaseProperties(*result);
        free(v4);
      }
      uint64_t result = (long long **)CGPDFGStateCreateCopy(a2);
      void *v3 = result;
    }
  }
  return result;
}

void CGPDFRStateGSave(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
    }
    else
    {
      Copdouble y = CGPDFGStateCreateCopy(*(long long **)a1);
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v4 = v3;
      v4[1] = Copy;
      *(void *)(a1 + 8) = v4;
    }
  }
}

void CGPDFRStateGRestore(uint64_t a1)
{
  if (!a1) {
    return;
  }
  if (*(void *)(a1 + 16))
  {
LABEL_4:
    pdf_error(v2);
    return;
  }
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (!v3)
  {
    uint64_t v2 = "warning: gstate stack underflow.";
    goto LABEL_4;
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    CGPDFGStateReleaseProperties(*(void **)a1);
    free(v4);
    uint64_t v3 = *(uint64_t **)(a1 + 8);
  }
  uint64_t v5 = *v3;
  *(void *)a1 = v3[1];
  free(v3);
  *(void *)(a1 + 8) = v5;
}

char *CGPDFShadingType2Init(CGPDFDictionary *a1, void *a2, _OWORD *a3)
{
  uint64_t v5 = a1;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1) {
    a1 = (CGPDFDictionary *)*((void *)a1 + 5);
  }
  if (CGColorSpaceGetType(a1) == 7)
  {
    return 0;
  }
  float64x2_t v6 = malloc_type_calloc(1uLL, 0x40uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (!v6) {
    return 0;
  }
  CGPDFObjectRef value = 0;
  *a2 = v6;
  *a3 = CGPDFShadingType2Init_type2_callbacks;
  if (v5) {
    uint64_t v5 = (CGPDFDictionary *)*((void *)v5 + 3);
  }
  if (!CGPDFDictionaryGetNumbers(v5, "Coords", (uint64_t)v10, (CGPDFArray *)4))
  {
    return 0;
  }
  long long v7 = v10[1];
  *float64x2_t v6 = v10[0];
  v6[1] = v7;
  if (!CGPDFDictionaryGetNumbers(v5, "Domain", (uint64_t)(v6 + 2), (CGPDFArray *)2)) {
    v6[2] = xmmword_1850CD8C0;
  }
  if (!CGPDFDictionaryGetObject(v5, "Function", &value))
  {
    return 0;
  }
  uint64_t result = CGPDFShadingCreateShadingFunction((uint64_t)value, 1uLL);
  *((void *)v6 + 6) = result;
  if (result)
  {
    if (!CGPDFDictionaryGetBooleans(v5, "Extend", (uint64_t)v6 + 56, (CGPDFArray *)2)) {
      *((_WORD *)v6 + 28) = 0;
    }
    return (char *)1;
  }
  return result;
}

void type2_release_info(int a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (const void *)a2[6];
    if (v3) {
      CFRelease(v3);
    }
    free(a2);
  }
}

uint64_t type2_create_shading(CGRect *a1, uint64_t a2)
{
  uint64_t v3 = &CGRectNull;
  p_CGFloat height = &CGRectNull.size.height;
  p_CGFloat y = &CGRectNull.origin.y;
  p_size = &CGRectNull.size;
  if (a1)
  {
    p_size = &a1[2].size;
    p_CGFloat y = &a1[2].origin.y;
    uint64_t v3 = a1 + 2;
    p_CGFloat height = &a1[2].size.height;
  }
  double v7 = *p_height;
  double x = v3->origin.x;
  double v9 = *p_y;
  double width = p_size->width;
  v19[0] = *(void *)&v3->origin.x;
  *(double *)&v19[1] = v9;
  *(double *)&v19[2] = width;
  *(double *)&v19[3] = v7;
  if (a1)
  {
    CGFloat y = a1[1].origin.y;
    a1 = *(CGRect **)&a1[1].size.width;
  }
  else
  {
    CGFloat y = 0.0;
  }
  Components = CGColorGetComponents((CGColorRef)a1);
  if (v7 == 1.79769313e308 && width == 1.79769313e308 && v9 == -8.98846567e307 && x == -8.98846567e307) {
    long long v17 = 0;
  }
  else {
    long long v17 = v19;
  }
  return CGShadingCreateAxialInternal(*(void **)&y, (uint64_t)Components, (uint64_t)v17, (double *)(a2 + 32), *(void **)(a2 + 48), *(unsigned char *)(a2 + 56) != 0, *(unsigned char *)(a2 + 57) != 0, v13, *(double *)a2, *(double *)(a2 + 8), *(double *)(a2 + 16), *(double *)(a2 + 24));
}

void ascii_hex_filter_finalize(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

unint64_t ascii_hex_filter_refill(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 8)) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = a3 == 0;
  }
  if (!v8)
  {
    unint64_t v12 = 0;
    char v13 = 0;
    char v14 = 0;
    do
    {
LABEL_7:
      unsigned int v15 = CGPDFSourceGetc(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
      if (v15 == -1) {
        unsigned int v16 = 62;
      }
      else {
        unsigned int v16 = v15;
      }
    }
    while (v16 <= 0x20 && ((1 << v16) & 0x100003601) != 0);
    switch(v16)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        char v18 = -48;
        goto LABEL_19;
      case '>':
        *(unsigned char *)(a1 + 8) = 1;
        if (v13) {
          *(unsigned char *)(a2 + v12++) = 16 * v14;
        }
        return v12;
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        char v18 = -55;
        goto LABEL_19;
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        char v18 = -87;
LABEL_19:
        char v14 = (v16 + v18) | (16 * v14);
        if (v13) {
          *(unsigned char *)(a2 + v12++) = v14;
        }
        ++v13;
        if (v12 >= a3) {
          return v12;
        }
        goto LABEL_7;
      default:
        pdf_error("ASCIIHexDecode: invalid character 0x%02x encountered in stream.", v16);
        unint64_t v12 = 0;
        *(unsigned char *)(a1 + 8) = 1;
        return v12;
    }
  }
  return 0;
}

uint64_t ascii_hex_filter_rewind(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  return CGPDFSourceRewind(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t CGContextDelegateCreateFilter(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = CGContextDelegateCreateWithCallbacks(a1, filter_vtable, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = v9;
  if (v9)
  {
    CGContextDelegateSetNext(v9, a2);
    for (uint64_t i = 0; i != 20; ++i)
    {
      if (a2)
      {
        uint64_t v17 = names[i];
        callback_address = (void *)get_callback_address((uint64_t)a2, v17, (uint64_t)"CGContextDelegateImplementsCallback", v11, v12, v13, v14, v15);
        if (!callback_address || !*callback_address)
        {
          CGFloat v19 = (void *)get_callback_address(v10, v17, (uint64_t)"CGContextDelegateSetCallback", v11, v12, v13, v14, v15);
          if (v19) {
            *CGFloat v19 = 0;
          }
        }
      }
    }
  }
  return v10;
}

uint64_t filter_DrawLayer(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 216);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_GetLayer(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0 && (v2 = *(uint64_t (**)(void))(v1 + 208)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t filter_EndLayer(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0 && (v2 = *(uint64_t (**)(void))(v1 + 200)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t filter_BeginLayer(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0 && (v2 = *(uint64_t (**)(void))(v1 + 192)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t filter_DrawWindowContents(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 176);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_Operation(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 168);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_EndPage(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 160);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_BeginPage(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 152);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawImageFromRect(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 144);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawImages(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 136);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawDisplayList(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 128);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawConicGradient(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 120);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawRadialGradient(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 112);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawLinearGradient(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 104);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawShading(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 96);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawGlyphs(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 88);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawImage(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 80);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

uint64_t filter_DrawPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  if (a1) {
    a1 = *(void *)(a1 + 16);
  }
  return CGContextDelegateDrawPath(a1, a2, a3, a4, a5);
}

uint64_t filter_DrawRects(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (result)
    {
      uint64_t v1 = *(uint64_t (**)(void))(result + 64);
      if (v1) {
        return v1();
      }
      else {
        return 1006;
      }
    }
  }
  return result;
}

void filter_DrawLines(uint64_t a1, uint64_t a2, uint64_t a3, const CGPoint *a4, unint64_t a5)
{
  if (a1) {
    a1 = *(void *)(a1 + 16);
  }
  CGContextDelegateDrawLines(a1, a2, a3, a4, a5);
}

double filter_GetBounds(uint64_t a1, __n128 a2, __n128 a3)
{
  if (!a1) {
    return INFINITY;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return INFINITY;
  }
  uint64_t v4 = *(void (**)(__n128, __n128, double))(v3 + 48);
  if (!v4) {
    return -8.98846567e307;
  }
  v4(a2, a3, 0.0);
  return result;
}

CGFloat filter_GetTransform@<D0>(uint64_t a1@<X0>, CGAffineTransform *a2@<X8>)
{
  if (a1 && (uint64_t v2 = *(void *)(a1 + 16)) != 0 && (v3 = *(void (**)(void))(v2 + 40)) != 0)
  {
    v3();
  }
  else
  {
    *a2 = CGAffineTransformIdentity;
    return CGAffineTransformIdentity.tx;
  }
  return result;
}

uint64_t filter_GetColorTransform(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0 && (v2 = *(uint64_t (**)(void))(v1 + 32)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

double CGColorMatrixMakeIdentity@<D0>(_OWORD *a1@<X8>)
{
  *a1 = CGColorMatrixMakeIdentity_identity;
  a1[1] = unk_185295180;
  double result = 0.0;
  a1[2] = xmmword_185295190;
  return result;
}

__n128 CGColorMatrixMake@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v2 = 0;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  do
  {
    __n128 result = *(__n128 *)(a1 + v2 * 16);
    a2[v2++] = result;
  }
  while (v2 != 3);
  return result;
}

BOOL CGColorMatrixIsIdentity(uint64_t a1)
{
  BOOL v1 = 0;
  unint64_t v2 = 0;
LABEL_2:
  uint64_t v3 = 0;
  while (1)
  {
    float v4 = v2 == v3 ? 1.0 : 0.0;
    if (*(float *)(a1 + 4 * v3) != v4) {
      return v1;
    }
    if (++v3 == 4)
    {
      BOOL v1 = v2 > 1;
      a1 += 16;
      if (++v2 != 3) {
        goto LABEL_2;
      }
      return 1;
    }
  }
}

float CGColorMatrixConcat@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = *a1;
  float v4 = a1[1];
  float v5 = a2[4];
  float v6 = a2[5];
  float v7 = *a2;
  float v8 = a2[1];
  float v9 = a2[8];
  float v10 = a2[9];
  float v11 = a1[2];
  float v12 = a1[3];
  float v13 = (float)((float)(v4 * v6) + (float)(*a1 * v8)) + (float)(v11 * v10);
  *a3 = (float)((float)(v4 * v5) + (float)(*a1 * *a2)) + (float)(v11 * v9);
  a3[1] = v13;
  float v14 = a2[6];
  float v15 = a2[7];
  float v16 = a2[2];
  float v17 = a2[3];
  float v18 = a2[10];
  float v19 = a2[11];
  a3[2] = (float)((float)(v4 * v14) + (float)(v3 * v16)) + (float)(v11 * v18);
  a3[3] = v12 + (float)((float)((float)(v4 * v15) + (float)(v3 * v17)) + (float)(v11 * v19));
  float v20 = a1[4];
  float v21 = a1[5];
  float v22 = a1[6];
  float v23 = a1[7];
  a3[4] = (float)((float)(v5 * v21) + (float)(v20 * v7)) + (float)(v22 * v9);
  a3[5] = (float)((float)(v6 * v21) + (float)(v20 * v8)) + (float)(v22 * v10);
  a3[6] = (float)((float)(v14 * v21) + (float)(v20 * v16)) + (float)(v22 * v18);
  a3[7] = (float)((float)((float)(v15 * v21) + (float)(v20 * v17)) + (float)(v22 * v19)) + v23;
  float v24 = a1[8];
  float v25 = a1[9];
  float v26 = (float)(v5 * v25) + (float)(v24 * v7);
  float v27 = a1[10];
  float v28 = a1[11];
  a3[8] = v26 + (float)(v27 * v9);
  a3[9] = (float)((float)(v6 * v25) + (float)(v24 * v8)) + (float)(v27 * v10);
  float v29 = (float)((float)(v14 * v25) + (float)(v24 * v16)) + (float)(v27 * v18);
  float result = (float)((float)((float)(v15 * v25) + (float)(v24 * v17)) + (float)(v27 * v19)) + v28;
  a3[10] = v29;
  a3[11] = result;
  return result;
}

void type0_release(void **a1)
{
  if (a1)
  {
    free(a1[1]);
    free(a1[3]);
    free(a1[6]);
    free(a1[4]);
    free(a1[5]);
    free(a1[10]);
    free(a1);
  }
}

__CFDictionary *copy_pdf_description_20616(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  float v3 = Mutable;
  if (Mutable)
  {
    CGCFDictionarySetInteger(Mutable, @"/FunctionType", 0);
    CFMutableArrayRef v4 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (!v4) {
      goto LABEL_26;
    }
    float v5 = v4;
    if ((*(void *)a1 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    {
      unint64_t v6 = 0;
      do
        CGCFArrayAppendCGFloat(v5, *(double *)(*(void *)(a1 + 8) + 8 * v6++));
      while (v6 < 2 * *(void *)a1);
    }
    CFDictionarySetValue(v3, @"/Domain", v5);
    CFRelease(v5);
    CFMutableArrayRef v7 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (!v7) {
      goto LABEL_26;
    }
    float v8 = v7;
    if ((*(void *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL) != 0)
    {
      unint64_t v9 = 0;
      do
        CGCFArrayAppendCGFloat(v8, *(double *)(*(void *)(a1 + 24) + 8 * v9++));
      while (v9 < 2 * *(void *)(a1 + 16));
    }
    CFDictionarySetValue(v3, @"/Range", v8);
    CFRelease(v8);
    CFMutableArrayRef v10 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (!v10) {
      goto LABEL_26;
    }
    float v11 = v10;
    if (*(void *)a1)
    {
      unint64_t v12 = 0;
      do
        CGCFArrayAppendCGFloat(v11, (double)*(uint64_t *)(*(void *)(a1 + 48) + 8 * v12++));
      while (v12 < *(void *)a1);
    }
    CFDictionarySetValue(v3, @"/Size", v11);
    CFRelease(v11);
    CGCFDictionarySetInteger(v3, @"/BitsPerSample", *(_DWORD *)(a1 + 56));
    CGCFDictionarySetInteger(v3, @"/Order", *(_DWORD *)(a1 + 64));
    CFMutableArrayRef v13 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (!v13) {
      goto LABEL_26;
    }
    float v14 = v13;
    if ((*(void *)a1 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    {
      unint64_t v15 = 0;
      do
        CGCFArrayAppendCGFloat(v14, *(double *)(*(void *)(a1 + 40) + 8 * v15++));
      while (v15 < 2 * *(void *)a1);
    }
    CFDictionarySetValue(v3, @"/Encode", v14);
    CFRelease(v14);
    CFMutableArrayRef v16 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (!v16) {
      goto LABEL_26;
    }
    float v17 = v16;
    if ((*(void *)(a1 + 16) & 0x7FFFFFFFFFFFFFFFLL) != 0)
    {
      unint64_t v18 = 0;
      do
        CGCFArrayAppendCGFloat(v17, *(double *)(*(void *)(a1 + 32) + 8 * v18++));
      while (v18 < 2 * *(void *)(a1 + 16));
    }
    CFDictionarySetValue(v3, @"/Decode", v17);
    CFRelease(v17);
    CFDataRef v19 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(const UInt8 **)(a1 + 80), *(void *)(a1 + 72));
    if (v19)
    {
      CFDataRef v20 = v19;
      CFDictionarySetValue(v3, @"/%Stream", v19);
    }
    else
    {
LABEL_26:
      CFDataRef v20 = v3;
      float v3 = 0;
    }
    CFRelease(v20);
  }
  return v3;
}

void type0_evaluate(unint64_t *a1, uint64_t a2, double *a3, __n128 a4)
{
  v33[1] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return;
  }
  size_t v7 = MEMORY[0x1F4188790](8 * *a1, a4);
  CFMutableArrayRef v10 = (double *)((char *)v32 - v9);
  float v11 = (double *)((char *)v32 - v9);
  if (v7 >= 0x101)
  {
    float v11 = (double *)malloc_type_malloc(v7, 0x88E2DEAEuLL);
    if (!v11) {
      return;
    }
  }
  size_t v12 = MEMORY[0x1F4188790](8 * a1[2], v8);
  unint64_t v15 = (double *)((char *)v32 - v14);
  CFMutableArrayRef v16 = (double *)((char *)v32 - v14);
  if (v12 < 0x101 || (CFMutableArrayRef v16 = (double *)malloc_type_malloc(v12, 0x93D7FB6FuLL)) != 0)
  {
    unint64_t v17 = *a1;
    if (!*a1) {
      goto LABEL_15;
    }
    uint64_t v18 = 0;
    unint64_t v19 = a1[6];
    CFDataRef v20 = (double *)(a1[5] + 8);
    float v21 = (double *)(a1[1] + 8);
    v13.n128_u64[0] = 0;
    do
    {
      v11[v18] = fmin(fmax(*(v20 - 1) + (*(double *)(a2 + 8 * v18) - *(v21 - 1)) * (*v20 - *(v20 - 1)) / (*v21 - *(v21 - 1)), 0.0), (double)(*(void *)(v19 + 8 * v18) - 1));
      ++v18;
      v20 += 2;
      v21 += 2;
    }
    while (v17 != v18);
    if (v17 == 1)
    {
      v32[0] = v15;
      v32[1] = v32;
      unint64_t v22 = a1[2];
      if (v22)
      {
        uint64_t v23 = 0;
        unint64_t v24 = (int)*v11;
        double v25 = *v11 - (double)v24;
        do
        {
          v33[0] = v24;
          unsigned int v26 = lookup(a1, v23, v33);
          v33[0] = v24 + 1;
          v16[v23] = v25 * (double)lookup(a1, v23, v33) + (1.0 - v25) * (double)v26;
          ++v23;
        }
        while (v22 != v23);
      }
      unint64_t v15 = (double *)v32[0];
      if (!v22)
      {
LABEL_18:
        if (v11 != v10) {
          free(v11);
        }
        if (v16 != v15)
        {
          double v31 = v16;
LABEL_22:
          free(v31);
          return;
        }
        return;
      }
    }
    else
    {
LABEL_15:
      multilinear_interpolate(a1, (uint64_t)v11, (uint64_t)v16, v13);
      unint64_t v22 = a1[2];
      if (!v22) {
        goto LABEL_18;
      }
    }
    double v27 = (double)(0xFFFFFFFF >> -*((unsigned char *)a1 + 56));
    float v28 = (double *)(a1[4] + 8);
    float v29 = v16;
    do
    {
      double v30 = *v29++;
      *a3++ = *(v28 - 1) + v30 * (*v28 - *(v28 - 1)) / v27;
      v28 += 2;
      --v22;
    }
    while (v22);
    goto LABEL_18;
  }
  if (v11 != v10)
  {
    double v31 = v11;
    goto LABEL_22;
  }
}

uint64_t lookup(void *a1, uint64_t a2, unint64_t *a3)
{
  if (!a1[9]) {
    return 0;
  }
  float v3 = (void *)a1[6];
  unint64_t v4 = 0;
  uint64_t v5 = *a1 - 1;
  if (*a1 != 1)
  {
    unint64_t v6 = &v3[*a1 - 1];
    do
    {
      unint64_t v7 = a3[v5];
      if (v7 >= *v6 - 1) {
        unint64_t v7 = *v6 - 1;
      }
      uint64_t v8 = *--v6;
      unint64_t v4 = (v7 + v4) * v8;
      --v5;
    }
    while (v5);
  }
  unint64_t v9 = *v3 - 1;
  if (*a3 < v9) {
    unint64_t v9 = *a3;
  }
  uint64_t v10 = a2 + (v9 + v4) * a1[2];
  unint64_t v11 = a1[7];
  char v12 = v10 * v11;
  __n128 v13 = (unsigned __int8 *)(a1[10] + ((v10 * v11) >> 3));
  unint64_t v14 = v12 & 7;
  if ((v12 & 7) != 0)
  {
    unsigned int v16 = *v13++;
    unsigned int v15 = v16;
    unint64_t v14 = 8 - v14;
  }
  else
  {
    unsigned int v15 = 0;
  }
  while (v14 < v11)
  {
    int v18 = *v13++;
    unsigned int v15 = v18 | (v15 << 8);
    v14 += 8;
  }
  return (v15 >> (v14 - v11)) & (0xFFFFFFFF >> -(char)v11);
}

void multilinear_interpolate(unint64_t *a1, uint64_t a2, uint64_t a3, __n128 a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  size_t v7 = MEMORY[0x1F4188790](8 * *a1, a4);
  unint64_t v45 = (double *)((char *)&v43 - v9);
  if (v8 <= 0x1FFFFFFFFFFFFFFELL) {
    unint64_t v11 = (double *)((char *)&v43 - v9);
  }
  else {
    unint64_t v11 = 0;
  }
  if (v8 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000082)
  {
    unint64_t v11 = (double *)malloc_type_malloc(v7, 0x8A5F7193uLL);
    size_t v7 = 8 * *a1;
  }
  size_t v12 = MEMORY[0x1F4188790](v7, v10);
  BOOL v44 = (char *)&v43 - v14;
  if (v13 <= 0x1FFFFFFFFFFFFFFELL) {
    unsigned int v16 = (char *)&v43 - v14;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v13 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000082)
  {
    unsigned int v16 = (char *)malloc_type_malloc(v12, 0x2E60A1F8uLL);
    size_t v12 = 8 * *a1;
  }
  size_t v17 = MEMORY[0x1F4188790](v12, v15);
  float v21 = (unint64_t *)((char *)&v43 - v19);
  if (v20 <= 0x1FFFFFFFFFFFFFFELL) {
    unint64_t v22 = (unint64_t *)((char *)&v43 - v19);
  }
  else {
    unint64_t v22 = 0;
  }
  if (v20 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000082)
  {
    unint64_t v22 = (unint64_t *)malloc_type_malloc(v17, 0xE110B0B5uLL);
    unint64_t v18 = *a1;
  }
  if (v18)
  {
    unint64_t v23 = 0;
    do
    {
      double v24 = *(double *)(a2 + 8 * v23);
      unint64_t v25 = (int)v24;
      *(void *)&v16[8 * v23] = v25;
      v11[v23++] = v24 - (double)v25;
      unint64_t v26 = *a1;
    }
    while (v23 < *a1);
  }
  else
  {
    unint64_t v26 = 0;
  }
  if (a1[2])
  {
    unint64_t v27 = 0;
    do
    {
      unint64_t v28 = 0;
      double v29 = 0.0;
      do
      {
        if (v26)
        {
          unint64_t v30 = 0;
          do
          {
            v22[v30] = *(void *)&v16[8 * v30] + ((v28 >> v30) & 1);
            ++v30;
            unint64_t v26 = *a1;
          }
          while (v30 < *a1);
          double v31 = (double)lookup(a1, v27, v22);
          if (v26)
          {
            double v32 = v22;
            double v33 = (uint64_t *)v16;
            double v34 = v11;
            unint64_t v35 = v26;
            do
            {
              uint64_t v37 = *v32++;
              uint64_t v36 = v37;
              uint64_t v39 = *v33++;
              uint64_t v38 = v39;
              double v40 = *v34++;
              double v41 = v40;
              double v42 = 1.0 - v40;
              if (v36 == v38) {
                double v41 = v42;
              }
              double v31 = v31 * v41;
              --v35;
            }
            while (v35);
          }
        }
        else
        {
          double v31 = (double)lookup(a1, v27, v22);
        }
        double v29 = v29 + v31;
        ++v28;
      }
      while (v28 < (1 << v26));
      *(double *)(a3 + 8 * v27++) = v29;
    }
    while (v27 < a1[2]);
  }
  if (v11 != v45) {
    free(v11);
  }
  if (v16 != v44) {
    free(v16);
  }
  if (v22 != v21) {
    free(v22);
  }
}

uint64_t CGPDFStructureElementCreate(int a1)
{
  if (CGPDFStructureElementGetTypeID(void)::onceToken != -1) {
    dispatch_once(&CGPDFStructureElementGetTypeID(void)::onceToken, &__block_literal_global_20644);
  }
  uint64_t cftype = pdf_create_cftype();
  uint64_t v3 = cftype;
  if (cftype)
  {
    *(_DWORD *)(cftype + 16) = a1;
    *(_OWORD *)(cftype + 24) = 0u;
    *(_OWORD *)(cftype + 40) = 0u;
    *(void *)(cftype + 56) = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    *(void *)(v3 + 64) = 0;
  }
  return v3;
}

void sub_185049880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 + 32);
  std::vector<std::variant<applesauce::CF::ObjectRef<CGPDFStructureElement *>,applesauce::CF::ObjectRef<CGPDFMarkedContentItem *>>>::__destroy_vector::operator()[abi:fe180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t ___ZL30CGPDFStructureElementGetTypeIDv_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFStructureElementGetTypeID(void)::CGPDFStructureElementType);
  CGPDFStructureElementGetTypeID(void)::typeID = result;
  return result;
}

void CGPDFStructureElementFinalize(id *a1)
{
  unint64_t v2 = a1 + 4;
  std::vector<std::variant<applesauce::CF::ObjectRef<CGPDFStructureElement *>,applesauce::CF::ObjectRef<CGPDFMarkedContentItem *>>>::__destroy_vector::operator()[abi:fe180100](&v2);
}

CFTypeRef CGPDFStructureElementRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void CGPDFStructureElementRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void CGPDFStructureElementSetTitle(uint64_t a1, void *a2)
{
}

void CGPDFStructureElementSetLanguageIdentifier(uint64_t a1, void *a2)
{
}

void CGPDFStructureElementSetAlternativeText(uint64_t a1, void *a2)
{
}

void CGPDFStructureElementSetExpansionText(uint64_t a1, void *a2)
{
}

void CGPDFStructureElementSetActualText(uint64_t a1, void *a2)
{
}

uint64_t CGPDFStructureElementAddStructureElement(uint64_t *a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (cf[3])
  {
    CGPostError((uint64_t)"%s: Cannot add structure element child to structure element. The child already has a parent", (uint64_t)cf, a3, a4, a5, a6, a7, a8, (char)"AddChild");
    return 1001;
  }
  else
  {
    cf[3] = a1 + 2;
    CFTypeRef v10 = CFRetain(cf);
    CFTypeRef v11 = v10;
    unint64_t v12 = a1[6];
    unint64_t v13 = a1[5];
    if (v13 >= v12)
    {
      uint64_t v15 = a1[4];
      uint64_t v16 = (uint64_t)(v13 - v15) >> 4;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 60) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v18 = v12 - v15;
      if (v18 >> 3 > v17) {
        unint64_t v17 = v18 >> 3;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      v22[4] = a1 + 6;
      if (v19) {
        unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v19);
      }
      else {
        uint64_t v20 = 0;
      }
      unint64_t v21 = v19 + 16 * v16;
      v22[0] = v19;
      v22[1] = v21;
      v22[3] = v19 + 16 * v20;
      *(void *)unint64_t v21 = v11;
      *(_DWORD *)(v21 + 8) = 0;
      v22[2] = v21 + 16;
      std::vector<std::variant<applesauce::CF::ObjectRef<CGPDFStructureElement *>,applesauce::CF::ObjectRef<CGPDFMarkedContentItem *>>>::__swap_out_circular_buffer(a1 + 4, v22);
      uint64_t v14 = a1[5];
      std::__split_buffer<std::variant<applesauce::CF::ObjectRef<CGPDFStructureElement *>,applesauce::CF::ObjectRef<CGPDFMarkedContentItem *>>>::~__split_buffer((uint64_t)v22);
    }
    else
    {
      *(void *)unint64_t v13 = v10;
      *(_DWORD *)(v13 + 8) = 0;
      uint64_t v14 = v13 + 16;
    }
    uint64_t result = 0;
    a1[5] = v14;
  }
  return result;
}

void sub_185049AA8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFStructureElementAddMarkedContentItem(uint64_t *a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (cf[6])
  {
    CGPostError((uint64_t)"%s: Cannot add marked content item child to structure element. The child already has a parent", (uint64_t)cf, a3, a4, a5, a6, a7, a8, (char)"AddChild");
    return 1001;
  }
  else
  {
    cf[6] = a1;
    CFTypeRef v10 = CFRetain(cf);
    CFTypeRef v11 = v10;
    unint64_t v12 = a1[6];
    unint64_t v13 = a1[5];
    if (v13 >= v12)
    {
      uint64_t v15 = a1[4];
      uint64_t v16 = (uint64_t)(v13 - v15) >> 4;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 60) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v18 = v12 - v15;
      if (v18 >> 3 > v17) {
        unint64_t v17 = v18 >> 3;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      v22[4] = a1 + 6;
      if (v19) {
        unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v19);
      }
      else {
        uint64_t v20 = 0;
      }
      unint64_t v21 = v19 + 16 * v16;
      v22[0] = v19;
      v22[1] = v21;
      v22[3] = v19 + 16 * v20;
      *(void *)unint64_t v21 = v11;
      *(_DWORD *)(v21 + 8) = 1;
      v22[2] = v21 + 16;
      std::vector<std::variant<applesauce::CF::ObjectRef<CGPDFStructureElement *>,applesauce::CF::ObjectRef<CGPDFMarkedContentItem *>>>::__swap_out_circular_buffer(a1 + 4, v22);
      uint64_t v14 = a1[5];
      std::__split_buffer<std::variant<applesauce::CF::ObjectRef<CGPDFStructureElement *>,applesauce::CF::ObjectRef<CGPDFMarkedContentItem *>>>::~__split_buffer((uint64_t)v22);
    }
    else
    {
      *(void *)unint64_t v13 = v10;
      *(_DWORD *)(v13 + 8) = 1;
      uint64_t v14 = v13 + 16;
    }
    uint64_t result = 0;
    a1[5] = v14;
  }
  return result;
}

void sub_185049BF0(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFSelectionGetTypeID()
{
  uint64_t result = CGPDFSelectionGetTypeID::id;
  if (!CGPDFSelectionGetTypeID::id)
  {
    uint64_t result = _CFRuntimeRegisterClass();
    CGPDFSelectionGetTypeID::id = result;
  }
  return result;
}

CFStringRef _CGPDFSelectionCopyDebugDesc(uint64_t *a1)
{
  String = CGPDFSelectionCreateString(a1);
  if (String)
  {
    uint64_t v3 = String;
    uint64_t v4 = a1[3];
    if (!v4) {
      goto LABEL_8;
    }
    if (*(unsigned char *)(v4 + 40)) {
      CPIndexSetNormalize(a1[3]);
    }
    if (*(void *)(v4 + 16) == 1)
    {
      uint64_t Range = CPIndexSetGetRange(a1[3], 0);
      uint64_t v7 = v6;
      CFAllocatorRef v8 = CFGetAllocator(a1);
      CFStringRef v9 = CFStringCreateWithFormat(v8, 0, @"<CGPDFSelection (%p): range = [%ld,%ld>"), a1, Range, v7);
    }
    else
    {
LABEL_8:
      CFAllocatorRef v12 = CFGetAllocator(a1);
      CFStringRef v9 = CFStringCreateWithFormat(v12, 0, @"<CGPDFSelection (%p): {multiple ranges}>", a1);
    }
    CFStringRef v13 = v9;
    CFRelease(v3);
    return v13;
  }
  else
  {
    CFAllocatorRef v10 = CFGetAllocator(a1);
    return CFStringCreateWithFormat(v10, 0, @"<CGPDFSelection (%p): {empty}>", a1);
  }
}

uint64_t *CGPDFSelectionCreateString(uint64_t *a1)
{
  StringForStringRanges = a1;
  if (a1)
  {
    if (a1[23] == a1[24])
    {
      return 0;
    }
    else
    {
      Selection::cacheStringRanges((Selection *)(a1 + 21));
      CGPDFPageCopyPageLayoutWithCTLD(StringForStringRanges[21], 1);
      uint64_t v3 = v2;
      uint64_t v4 = (StringForStringRanges[27] - StringForStringRanges[26]) >> 4;
      v6[0] = StringForStringRanges[26];
      v6[1] = v4;
      StringForStringRanges = (uint64_t *)PageLayout::CreateStringForStringRanges((uint64_t)v2 + 16, (uint64_t)v6);
      if (v3) {
        CFRelease(v3);
      }
    }
  }
  return StringForStringRanges;
}

void sub_18504A208(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CGPDFSelectionFinalize(char *a1)
{
  if (a1[160])
  {
    unint64_t v2 = (void *)*((void *)a1 + 29);
    if (v2)
    {
      *((void *)a1 + 30) = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)*((void *)a1 + 26);
    if (v3)
    {
      *((void *)a1 + 27) = v3;
      operator delete(v3);
    }
    uint64_t v4 = (void *)*((void *)a1 + 23);
    if (v4)
    {
      *((void *)a1 + 24) = v4;
      operator delete(v4);
    }
    uint64_t v5 = (const void *)*((void *)a1 + 21);
    if (v5) {
      CFRelease(v5);
    }
  }
  uint64_t v6 = (const void *)*((void *)a1 + 2);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)a1 + 3);
  if (v7) {
    CFRelease(v7);
  }
  CFAllocatorRef v8 = (const void *)*((void *)a1 + 4);
  if (v8) {
    CFRelease(v8);
  }
  *((void *)a1 + 6) = 0;
  CFStringRef v9 = (void *)*((void *)a1 + 7);
  if (v9) {
    free(v9);
  }
  CFAllocatorRef v10 = (void *)*((void *)a1 + 8);
  if (v10) {
    free(v10);
  }
  CFTypeRef v11 = (void *)*((void *)a1 + 9);
  if (v11) {
    free(v11);
  }
  CFAllocatorRef v12 = (void *)*((void *)a1 + 10);
  if (v12) {
    free(v12);
  }

  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 96));
}

CFTypeRef CGPDFSelectionRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void CGPDFSelectionRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void *CGPDFSelectionCreateBetweenPointsWithOptions(uint64_t a1, int a2, double a3, double a4, double a5, double a6)
{
  if (a1)
  {
    CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
    if (v11)
    {
      CFAllocatorRef v12 = (id *)v11;
      SelectionForStringuint64_t Range = 0;
      if ((a2 - 6) <= 0xFFFFFFFC && *(void *)(v11 + 48) != *(void *)(v11 + 56))
      {
        uint64_t v14 = (const void **)(v11 + 16);
        int v15 = *(unsigned __int8 *)(v11 + 24);
        PageLayout::getTextRangeIndex(v11 + 16, 0, 0, a3, a4);
        int64_t v17 = v16;
        PageLayout::getTextRangeIndex((uint64_t)(v12 + 2), 0, 0, a5, a6);
        int64_t v19 = v18;
        BOOL v21 = v17 == -1 || v18 == -1;
        if (v15)
        {
          if (!v21)
          {
            unint64_t v22 = PageLayout::convertRTLTextRangeIndexToStringRangeIndex(v12 + 2, v17);
            unint64_t v23 = PageLayout::convertRTLTextRangeIndexToStringRangeIndex(v12 + 2, v19);
            double v24 = v23;
            if ((uint64_t)v23 >= (uint64_t)v22) {
              double v25 = a3;
            }
            else {
              double v25 = a5;
            }
            if ((uint64_t)v23 >= (uint64_t)v22) {
              double v26 = a4;
            }
            else {
              double v26 = a6;
            }
            PageLayout::getTextRangeIndex((uint64_t)(v12 + 2), a2, 0, v25, v26);
            unint64_t v28 = v27;
            if ((uint64_t)v24 >= (uint64_t)v22) {
              double v29 = a5;
            }
            else {
              double v29 = a3;
            }
            if ((uint64_t)v24 >= (uint64_t)v22) {
              double v30 = a6;
            }
            else {
              double v30 = a4;
            }
            PageLayout::getTextRangeIndex((uint64_t)(v12 + 2), a2, 1u, v29, v30);
            unint64_t v32 = v31;
            double v33 = (char *)PageLayout::convertRTLTextRangeIndexToStringRangeIndex(v12 + 2, v28);
            v62.length = (char *)PageLayout::convertRTLTextRangeIndexToStringRangeIndex(v12 + 2, v32) - v33;
            v62.location = (CFIndex)v33;
            SelectionForStringuint64_t Range = PageLayout::CreateSelectionForStringRange(v12 + 2, v62);
            goto LABEL_42;
          }
        }
        else if (!v21)
        {
          double v34 = v18 >= v17 ? a3 : a5;
          double v35 = v18 >= v17 ? a4 : a6;
          PageLayout::getTextRangeIndex((uint64_t)(v12 + 2), a2, 0, v34, v35);
          uint64_t v37 = v36;
          uint64_t v39 = v38;
          double v40 = v19 >= v17 ? a5 : a3;
          double v41 = v19 >= v17 ? a6 : a4;
          PageLayout::getTextRangeIndex((uint64_t)(v12 + 2), a2, 1u, v40, v41);
          uint64_t v43 = v42;
          if (v42 != v39)
          {
            unint64_t v45 = (void *)CGPDFSelectionCreateWithPage(*v14);
            SelectionForStringuint64_t Range = v45;
            uint64_t v46 = v43 - v39;
            float v48 = (void *)v45[24];
            unint64_t v47 = v45[25];
            if ((unint64_t)v48 >= v47)
            {
              uint64_t v50 = v45[23];
              unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v48 - v50) >> 3);
              unint64_t v52 = v51 + 1;
              if (v51 + 1 > 0xAAAAAAAAAAAAAAALL) {
                std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
              }
              unint64_t v53 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v47 - v50) >> 3);
              if (2 * v53 > v52) {
                unint64_t v52 = 2 * v53;
              }
              if (v53 >= 0x555555555555555) {
                unint64_t v54 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v54 = v52;
              }
              double v55 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v54);
              double v56 = &v55[24 * v51];
              char v58 = &v55[24 * v57];
              *(void *)double v56 = v37;
              *((void *)v56 + 1) = v39;
              *((void *)v56 + 2) = v46;
              BOOL v49 = v56 + 24;
              BOOL v60 = (char *)SelectionForStringRange[23];
              int v59 = (char *)SelectionForStringRange[24];
              if (v59 != v60)
              {
                do
                {
                  long long v61 = *(_OWORD *)(v59 - 24);
                  *((void *)v56 - 1) = *((void *)v59 - 1);
                  *(_OWORD *)(v56 - 24) = v61;
                  v56 -= 24;
                  v59 -= 24;
                }
                while (v59 != v60);
                int v59 = (char *)SelectionForStringRange[23];
              }
              SelectionForStringRange[23] = v56;
              SelectionForStringRange[24] = v49;
              SelectionForStringRange[25] = v58;
              if (v59) {
                operator delete(v59);
              }
            }
            else
            {
              void *v48 = v37;
              v48[1] = v39;
              BOOL v49 = v48 + 3;
              v48[2] = v46;
            }
            SelectionForStringRange[24] = v49;
            Selection::Normalize((Selection *)(SelectionForStringRange + 21));
            goto LABEL_42;
          }
        }
        SelectionForStringuint64_t Range = 0;
      }
LABEL_42:
      CFRelease(v12);
      return SelectionForStringRange;
    }
  }
  return 0;
}

void sub_18504A5F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t CGPDFSelectionCreateDirectionalSelection(uint64_t a1, double a2, double a3, double a4, double a5)
{
  if (!a1) {
    return 0;
  }
  CFTypeRef v9 = CGPDFPageCopyLayout(a1);
  if (!v9) {
    return 0;
  }
  CFAllocatorRef v10 = v9;
  uint64_t DirectionalSelection = CGPDFLayoutCreateDirectionalSelection((uint64_t)v9, a2, a3, a4, a5);
  CFRelease(v10);
  return DirectionalSelection;
}

void sub_18504A690(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void *CGPDFSelectionCreateFromIndexToPoint(uint64_t a1, CFIndex a2, double a3, double a4)
{
  if (!a1) {
    return 0;
  }
  uint64_t v6 = CGPDFSelectionCreateToPointWithOptions(a1, 0, a3, a4);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  uint64_t v8 = v6[24];
  if (v8 == v6[23] || (uint64_t v9 = *(void *)(v8 - 16) + *(void *)(v8 - 8), v9 <= a2)) {
    CFAllocatorRef v10 = 0;
  }
  else {
    CFAllocatorRef v10 = CGPDFSelectionCreateForRange(a1, a2, v9 - a2);
  }
  CFRelease(v7);
  return v10;
}

void sub_18504A738(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFSelection *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void *CGPDFSelectionCreateToPointWithOptions(uint64_t a1, int a2, double a3, double a4)
{
  if (!a1) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  SelectionForStringuint64_t Range = 0;
  if ((a2 - 6) <= 0xFFFFFFFC && *(void *)(v7 + 48) != *(void *)(v7 + 56))
  {
    PageLayout::getTextRangeIndex(v7 + 16, a2, 1u, a3, a4);
    unint64_t v11 = v10;
    if (v10 == -1)
    {
      SelectionForStringuint64_t Range = 0;
    }
    else if (*(unsigned char *)(v8 + 24))
    {
      v29.length = (CFIndex)PageLayout::convertRTLTextRangeIndexToStringRangeIndex((void *)(v8 + 16), v10);
      v29.location = 0;
      SelectionForStringuint64_t Range = PageLayout::CreateSelectionForStringRange((id *)(v8 + 16), v29);
    }
    else
    {
      CFAllocatorRef v12 = (void *)CGPDFSelectionCreateWithPage(*(const void **)(v8 + 16));
      SelectionForStringuint64_t Range = v12;
      uint64_t v14 = (void *)v12[24];
      unint64_t v13 = v12[25];
      if ((unint64_t)v14 >= v13)
      {
        uint64_t v16 = v12[23];
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v14 - v16) >> 3);
        unint64_t v18 = v17 + 1;
        if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v16) >> 3);
        if (2 * v19 > v18) {
          unint64_t v18 = 2 * v19;
        }
        if (v19 >= 0x555555555555555) {
          unint64_t v20 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v20 = v18;
        }
        BOOL v21 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v20);
        unint64_t v22 = &v21[24 * v17];
        double v24 = &v21[24 * v23];
        *(void *)unint64_t v22 = 0;
        *((void *)v22 + 1) = 0;
        *((void *)v22 + 2) = v11;
        int v15 = v22 + 24;
        double v26 = (char *)SelectionForStringRange[23];
        double v25 = (char *)SelectionForStringRange[24];
        if (v25 != v26)
        {
          do
          {
            long long v27 = *(_OWORD *)(v25 - 24);
            *((void *)v22 - 1) = *((void *)v25 - 1);
            *(_OWORD *)(v22 - 24) = v27;
            v22 -= 24;
            v25 -= 24;
          }
          while (v25 != v26);
          double v25 = (char *)SelectionForStringRange[23];
        }
        SelectionForStringRange[23] = v22;
        SelectionForStringRange[24] = v15;
        SelectionForStringRange[25] = v24;
        if (v25) {
          operator delete(v25);
        }
      }
      else
      {
        *uint64_t v14 = 0;
        v14[1] = 0;
        int v15 = v14 + 3;
        v14[2] = v11;
      }
      SelectionForStringRange[24] = v15;
      Selection::Normalize((Selection *)(SelectionForStringRange + 21));
    }
  }
  CFRelease((CFTypeRef)v8);
  return SelectionForStringRange;
}

void sub_18504A928(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

unint64_t CGPDFSelectionGetNumberOfTextRanges(unint64_t result)
{
  if (result) {
    return 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(result + 192) - *(void *)(result + 184)) >> 3);
  }
  return result;
}

uint64_t CGPDFSelectionGetTextRange(uint64_t a1, unint64_t a2)
{
  if (a1 && (uint64_t v2 = *(void *)(a1 + 184), 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 192) - v2) >> 3) > a2)) {
    return *(void *)(v2 + 24 * a2 + 8);
  }
  else {
    return -1;
  }
}

void *CGPDFSelectionCreateForRange(uint64_t a1, CFIndex a2, CFIndex a3)
{
  if (!a1) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (const void *)v5;
  v9.location = a2;
  v9.length = a3;
  SelectionForTextuint64_t Range = PageLayout::CreateSelectionForTextRange((PageLayout *)(v5 + 16), v9);
  CFRelease(v6);
  return SelectionForTextRange;
}

void sub_18504AA14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **applesauce::CF::ObjectRef<CGPDFSelection *>::~ObjectRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *CGPDFSelectionCreateFromPointToIndex(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v4 = (void *)a1;
  if (a1)
  {
    uint64_t v6 = CGPDFSelectionCreateFromPointWithOptions(a1, 0, a3, a4);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = v6[23];
      if (v6[24] == v8 || (CFIndex v9 = *(void *)(v8 + 8), a2 <= v9)) {
        uint64_t v4 = 0;
      }
      else {
        uint64_t v4 = CGPDFSelectionCreateForRange((uint64_t)v4, v9, a2 - v9);
      }
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

void sub_18504AAF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFSelection *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void *CGPDFSelectionCreateFromPointWithOptions(uint64_t a1, int a2, double a3, double a4)
{
  if (!a1) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  SelectionForStringuint64_t Range = 0;
  if ((a2 - 6) <= 0xFFFFFFFC && *(void *)(v7 + 48) != *(void *)(v7 + 56))
  {
    PageLayout::getTextRangeIndex(v7 + 16, a2, 0, a3, a4);
    unint64_t v12 = v11;
    if (v11 == -1)
    {
      SelectionForStringuint64_t Range = 0;
    }
    else if (*(unsigned char *)(v8 + 24))
    {
      unint64_t v13 = PageLayout::convertRTLTextRangeIndexToStringRangeIndex((void *)(v8 + 16), v11);
      v33.length = [*(id *)(v8 + 40) length] - (void)v13;
      v33.location = (CFIndex)v13;
      SelectionForStringuint64_t Range = PageLayout::CreateSelectionForStringRange((id *)(v8 + 16), v33);
    }
    else
    {
      uint64_t v14 = v10;
      int v15 = (void *)CGPDFSelectionCreateWithPage(*(const void **)(v8 + 16));
      SelectionForStringuint64_t Range = v15;
      unint64_t v16 = ((uint64_t)(*(void *)(v8 + 128) - *(void *)(v8 + 120)) >> 5) - v12;
      unint64_t v18 = (void *)v15[24];
      unint64_t v17 = v15[25];
      if ((unint64_t)v18 >= v17)
      {
        uint64_t v20 = v15[23];
        unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v18 - v20) >> 3);
        unint64_t v22 = v21 + 1;
        if (v21 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - v20) >> 3);
        if (2 * v23 > v22) {
          unint64_t v22 = 2 * v23;
        }
        if (v23 >= 0x555555555555555) {
          unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v24 = v22;
        }
        double v25 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v24);
        double v26 = &v25[24 * v21];
        unint64_t v28 = &v25[24 * v27];
        *(void *)double v26 = v14;
        *((void *)v26 + 1) = v12;
        *((void *)v26 + 2) = v16;
        unint64_t v19 = v26 + 24;
        double v30 = (char *)SelectionForStringRange[23];
        CFRange v29 = (char *)SelectionForStringRange[24];
        if (v29 != v30)
        {
          do
          {
            long long v31 = *(_OWORD *)(v29 - 24);
            *((void *)v26 - 1) = *((void *)v29 - 1);
            *(_OWORD *)(v26 - 24) = v31;
            v26 -= 24;
            v29 -= 24;
          }
          while (v29 != v30);
          CFRange v29 = (char *)SelectionForStringRange[23];
        }
        SelectionForStringRange[23] = v26;
        SelectionForStringRange[24] = v19;
        SelectionForStringRange[25] = v28;
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        void *v18 = v14;
        v18[1] = v12;
        unint64_t v19 = v18 + 3;
        v18[2] = v16;
      }
      SelectionForStringRange[24] = v19;
      Selection::Normalize((Selection *)(SelectionForStringRange + 21));
    }
  }
  CFRelease((CFTypeRef)v8);
  return SelectionForStringRange;
}

void sub_18504AD08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t CGPDFSelectionCreateBetweenRangeAndPoint(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6)
{
  if (!a1) {
    return 0;
  }
  CFTypeRef v11 = CGPDFPageCopyLayout(a1);
  if (!v11) {
    return 0;
  }
  unint64_t v12 = v11;
  uint64_t SelectionBetweenRangeAndPoint = CGPDFLayoutCreateSelectionBetweenRangeAndPoint((uint64_t)v11, a2, a3, a4, a5, a6);
  CFRelease(v12);
  return SelectionBetweenRangeAndPoint;
}

void sub_18504ADB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void *CGPDFSelectionCreateAtPointWithOptions(uint64_t a1, int a2, double a3, double a4)
{
  if (!a1) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  CFIndex v9 = 0;
  if ((a2 - 6) > 0xFFFFFFFC || *(void *)(v7 + 48) == *(void *)(v7 + 56))
  {
LABEL_52:
    CFRelease((CFTypeRef)v8);
    return v9;
  }
  PageLayout::getTextRangeIndex(v7 + 16, a2, 2u, a3, a4);
  unint64_t v12 = v11;
  if (v11 == -1)
  {
LABEL_12:
    CFIndex v9 = 0;
    goto LABEL_52;
  }
  unint64_t v13 = v10;
  uint64_t result = (void *)CGPDFSelectionCreateWithPage(*(const void **)(v8 + 16));
  CFIndex v9 = result;
  if (a2 != 2)
  {
    if (a2 == 1)
    {
      Worduint64_t Range = PageLayout::getWordRange((void *)(v8 + 16), v13, v12);
      unint64_t v23 = WordRange;
      unint64_t v24 = v22;
      double v26 = (unint64_t *)v9[24];
      unint64_t v25 = v9[25];
      if ((unint64_t)v26 < v25)
      {
        *double v26 = v13;
        v26[1] = (unint64_t)WordRange;
        uint64_t v20 = v26 + 3;
        v26[2] = v22;
        goto LABEL_51;
      }
      uint64_t v39 = v9[23];
      unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v26 - v39) >> 3);
      unint64_t v41 = v40 + 1;
      if (v40 + 1 <= 0xAAAAAAAAAAAAAAALL)
      {
        unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - v39) >> 3);
        if (2 * v42 > v41) {
          unint64_t v41 = 2 * v42;
        }
        if (v42 >= 0x555555555555555) {
          unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v43 = v41;
        }
        BOOL v44 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v43);
        CFRange v33 = (unint64_t *)&v44[24 * v40];
        double v35 = &v44[24 * v45];
        *CFRange v33 = v13;
        v33[1] = (unint64_t)v23;
        unint64_t v33[2] = v24;
        uint64_t v20 = v33 + 3;
        uint64_t v46 = (char *)v9[23];
        uint64_t v36 = (char *)v9[24];
        if (v36 == v46) {
          goto LABEL_49;
        }
        do
        {
          long long v47 = *(_OWORD *)(v36 - 24);
          *(v33 - 1) = *((void *)v36 - 1);
          *(_OWORD *)(v33 - 3) = v47;
          v33 -= 3;
          v36 -= 24;
        }
        while (v36 != v46);
        goto LABEL_48;
      }
      goto LABEL_54;
    }
    if (!a2)
    {
      unint64_t v16 = (unint64_t *)result[24];
      unint64_t v15 = result[25];
      if ((unint64_t)v16 < v15)
      {
        *unint64_t v16 = v13;
        v16[1] = v12;
        v16[2] = 1;
LABEL_16:
        uint64_t v20 = v16 + 3;
LABEL_51:
        v9[24] = v20;
        Selection::Normalize((Selection *)(v9 + 21));
        goto LABEL_52;
      }
      uint64_t v27 = result[23];
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - v27) >> 3);
      unint64_t v29 = v28 + 1;
      if (v28 + 1 <= 0xAAAAAAAAAAAAAAALL)
      {
        unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - v27) >> 3);
        if (2 * v30 > v29) {
          unint64_t v29 = 2 * v30;
        }
        if (v30 >= 0x555555555555555) {
          unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v31 = v29;
        }
        unint64_t v32 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v31);
        CFRange v33 = (unint64_t *)&v32[24 * v28];
        double v35 = &v32[24 * v34];
        *CFRange v33 = v13;
        v33[1] = v12;
        unint64_t v33[2] = 1;
        uint64_t v20 = v33 + 3;
        uint64_t v37 = (char *)v9[23];
        uint64_t v36 = (char *)v9[24];
        if (v36 == v37) {
          goto LABEL_49;
        }
        do
        {
          long long v38 = *(_OWORD *)(v36 - 24);
          *(v33 - 1) = *((void *)v36 - 1);
          *(_OWORD *)(v33 - 3) = v38;
          v33 -= 3;
          v36 -= 24;
        }
        while (v36 != v37);
LABEL_48:
        uint64_t v36 = (char *)v9[23];
LABEL_49:
        v9[23] = v33;
        v9[24] = v20;
        v9[25] = v35;
        if (v36) {
          operator delete(v36);
        }
        goto LABEL_51;
      }
      goto LABEL_54;
    }
    goto LABEL_12;
  }
  uint64_t v17 = *(void *)(v8 + 48);
  if (0x8E38E38E38E38E39 * ((*(void *)(v8 + 56) - v17) >> 3) > v13)
  {
    unint64_t v18 = (_OWORD *)(v17 + 72 * v13);
    unint64_t v16 = (unint64_t *)result[24];
    unint64_t v19 = result[25];
    if ((unint64_t)v16 < v19)
    {
      *unint64_t v16 = v13;
      *(_OWORD *)(v16 + 1) = *v18;
      goto LABEL_16;
    }
    uint64_t v48 = result[23];
    unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - v48) >> 3);
    unint64_t v50 = v49 + 1;
    if (v49 + 1 <= 0xAAAAAAAAAAAAAAALL)
    {
      unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v48) >> 3);
      if (2 * v51 > v50) {
        unint64_t v50 = 2 * v51;
      }
      if (v51 >= 0x555555555555555) {
        unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v52 = v50;
      }
      if (v52) {
        unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v52);
      }
      else {
        uint64_t v53 = 0;
      }
      CFRange v33 = (unint64_t *)(v52 + 24 * v49);
      double v35 = (char *)(v52 + 24 * v53);
      *CFRange v33 = v13;
      *(_OWORD *)(v33 + 1) = *v18;
      uint64_t v20 = v33 + 3;
      unint64_t v54 = (char *)v9[23];
      uint64_t v36 = (char *)v9[24];
      if (v36 == v54) {
        goto LABEL_49;
      }
      do
      {
        long long v55 = *(_OWORD *)(v36 - 24);
        *(v33 - 1) = *((void *)v36 - 1);
        *(_OWORD *)(v33 - 3) = v55;
        v33 -= 3;
        v36 -= 24;
      }
      while (v36 != v54);
      goto LABEL_48;
    }
LABEL_54:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
  }
  __break(1u);
  return result;
}

void sub_18504B170(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void CGPDFSelectionCreateIntersectingRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  if (a1) {
    CGPDFSelectionCreateInRect(a1, a2, a3, a4, a5);
  }
}

void CGPDFSelectionCreateInRect(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(double *)&v55[16] = a4;
  *(double *)&v55[24] = a5;
  *(double *)long long v55 = a2;
  *(double *)&v55[8] = a3;
  if (a1)
  {
    CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
    if (v5)
    {
      uint64_t v6 = (void *)v5;
      uint64_t v7 = (void *)CGPDFSelectionCreateWithPage(*(const void **)(v5 + 16));
      uint64_t v8 = v6[6];
      if (v6[7] == v8) {
        goto LABEL_50;
      }
      unint64_t v9 = 0;
      unint64_t v54 = 0;
      while (1)
      {
        uint64_t v10 = v8 + 72 * v9;
        __double2 v11 = __sincos_stret(*(double *)(v10 + 56));
        CGRect v59 = *(CGRect *)(v10 + 24);
        v56.a = v11.__cosval;
        v56.b = v11.__sinval;
        v56.c = -v11.__sinval;
        v56.d = v11.__cosval;
        v56.tCGFloat x = 0.0;
        v56.tdouble y = 0.0;
        CGRect v64 = CGRectApplyAffineTransform(v59, &v56);
        if (!CGRectIntersectsRect(*(CGRect *)v55, v64)) {
          goto LABEL_49;
        }
        uint64_t v12 = *(void *)(v10 + 8);
        if (v12 < 1) {
          goto LABEL_49;
        }
        uint64_t v13 = 0;
        unint64_t v14 = *(void *)v10;
        uint64_t v15 = -1;
        unint64_t v16 = *(void *)v10;
        do
        {
          uint64_t v17 = v6[15];
          if (v16 >= (v6[16] - v17) >> 5)
          {
            __break(1u);
            return;
          }
          CGRect v60 = *(CGRect *)(v17 + 32 * v16);
          v57.a = v11.__cosval;
          v57.b = v11.__sinval;
          v57.c = -v11.__sinval;
          v57.d = v11.__cosval;
          v57.tCGFloat x = 0.0;
          v57.tdouble y = 0.0;
          CGRect v61 = CGRectApplyAffineTransform(v60, &v57);
          CGFloat x = v61.origin.x;
          double y = v61.origin.y;
          CGFloat width = v61.size.width;
          double height = v61.size.height;
          if (v61.size.width < 0.0 || v61.size.height < 0.0)
          {
            CGRect v62 = CGRectStandardize(v61);
            double v23 = v62.origin.x + v62.size.width * 0.5;
            v62.origin.CGFloat x = x;
            v62.origin.double y = y;
            v62.size.CGFloat width = width;
            double v22 = 0.5;
            v62.size.double height = height;
            CGRect v63 = CGRectStandardize(v62);
            double y = v63.origin.y;
            double height = v63.size.height;
          }
          else
          {
            double v22 = 0.5;
            double v23 = v61.origin.x + v61.size.width * 0.5;
          }
          v58.double y = y + height * v22;
          v58.CGFloat x = v23;
          if (CGRectContainsPoint(*(CGRect *)v55, v58))
          {
            if (v15 != -1)
            {
              if (v13 + v15 == v16)
              {
                ++v13;
                goto LABEL_32;
              }
              unint64_t v25 = (unint64_t *)v7[24];
              unint64_t v24 = v7[25];
              if ((unint64_t)v25 >= v24)
              {
                uint64_t v27 = v7[23];
                unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v25 - v27) >> 3);
                unint64_t v29 = v28 + 1;
                if (v28 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_52;
                }
                unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v27) >> 3);
                if (2 * v30 > v29) {
                  unint64_t v29 = 2 * v30;
                }
                if (v30 >= 0x555555555555555) {
                  unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v31 = v29;
                }
                unint64_t v32 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v31);
                uint64_t v34 = (unint64_t *)&v32[24 * v28];
                *uint64_t v34 = v54;
                v34[1] = v15;
                v34[2] = v13;
                uint64_t v36 = (char *)v7[23];
                double v35 = (char *)v7[24];
                uint64_t v37 = v34;
                if (v35 != v36)
                {
                  do
                  {
                    long long v38 = *(_OWORD *)(v35 - 24);
                    *(v37 - 1) = *((void *)v35 - 1);
                    *(_OWORD *)(v37 - 3) = v38;
                    v37 -= 3;
                    v35 -= 24;
                  }
                  while (v35 != v36);
                  double v35 = (char *)v7[23];
                }
                double v26 = v34 + 3;
                v7[23] = v37;
                v7[24] = v34 + 3;
                v7[25] = &v32[24 * v33];
                if (v35) {
                  operator delete(v35);
                }
              }
              else
              {
                unint64_t *v25 = v54;
                v25[1] = v15;
                double v26 = v25 + 3;
                v25[2] = v13;
              }
              v7[24] = v26;
              unint64_t v14 = *(void *)v10;
              uint64_t v12 = *(void *)(v10 + 8);
            }
            uint64_t v15 = v16;
            uint64_t v13 = 1;
            unint64_t v54 = v9;
          }
LABEL_32:
          ++v16;
        }
        while ((uint64_t)v16 < (uint64_t)(v12 + v14));
        if (v15 != -1)
        {
          unint64_t v40 = (unint64_t *)v7[24];
          unint64_t v39 = v7[25];
          if ((unint64_t)v40 >= v39)
          {
            uint64_t v42 = v7[23];
            unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v40 - v42) >> 3);
            unint64_t v44 = v43 + 1;
            if (v43 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_52:
            }
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
            unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - v42) >> 3);
            if (2 * v45 > v44) {
              unint64_t v44 = 2 * v45;
            }
            if (v45 >= 0x555555555555555) {
              unint64_t v46 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v46 = v44;
            }
            long long v47 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v46);
            unint64_t v49 = (unint64_t *)&v47[24 * v43];
            *unint64_t v49 = v54;
            v49[1] = v15;
            v49[2] = v13;
            unint64_t v51 = (char *)v7[23];
            unint64_t v50 = (char *)v7[24];
            unint64_t v52 = v49;
            if (v50 != v51)
            {
              do
              {
                long long v53 = *(_OWORD *)(v50 - 24);
                *(v52 - 1) = *((void *)v50 - 1);
                *(_OWORD *)(v52 - 3) = v53;
                v52 -= 3;
                v50 -= 24;
              }
              while (v50 != v51);
              unint64_t v50 = (char *)v7[23];
            }
            unint64_t v41 = v49 + 3;
            v7[23] = v52;
            v7[24] = v49 + 3;
            v7[25] = &v47[24 * v48];
            if (v50) {
              operator delete(v50);
            }
          }
          else
          {
            *unint64_t v40 = v54;
            v40[1] = v15;
            unint64_t v41 = v40 + 3;
            v40[2] = v13;
          }
          v7[24] = v41;
        }
LABEL_49:
        ++v9;
        uint64_t v8 = v6[6];
        if (v9 >= 0x8E38E38E38E38E39 * ((v6[7] - v8) >> 3))
        {
LABEL_50:
          Selection::Normalize((Selection *)(v7 + 21));
          CFRelease(v6);
          return;
        }
      }
    }
  }
}

void sub_18504B648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void CGPDFSelectionCreateInPath(uint64_t a1, CGPathRef path)
{
  if (a1)
  {
    PathBoundingBoCGFloat x = CGPathGetPathBoundingBox(path);
    CGPDFSelectionCreateInRect(a1, PathBoundingBox.origin.x, PathBoundingBox.origin.y, PathBoundingBox.size.width, PathBoundingBox.size.height);
  }
}

uint64_t CGPDFSelectionCreateForQuadPoints(uint64_t a1, double *a2, int a3)
{
  if (!a1) {
    return 0;
  }
  CFTypeRef v5 = CGPDFPageCopyLayout(a1);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t SelectionForQuadPoints = CGPDFLayoutCreateSelectionForQuadPoints((uint64_t)v5, a2, a3);
  CFRelease(v6);
  return SelectionForQuadPoints;
}

void sub_18504B718(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void *CGPDFSelectionCreateForEntirePage(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (void *)v1;
  uint64_t v3 = (void *)CGPDFSelectionCreateWithPage(*(const void **)(v1 + 16));
  uint64_t v4 = v3;
  uint64_t v5 = (uint64_t)(v2[16] - v2[15]) >> 5;
  uint64_t v7 = (void *)v3[24];
  unint64_t v6 = v3[25];
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = v3[23];
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - v9) >> 3);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v9) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    unint64_t v14 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v13);
    uint64_t v15 = &v14[24 * v10];
    uint64_t v17 = &v14[24 * v16];
    *(void *)uint64_t v15 = 0;
    *((void *)v15 + 1) = 0;
    *((void *)v15 + 2) = v5;
    uint64_t v8 = v15 + 24;
    unint64_t v19 = (char *)v4[23];
    unint64_t v18 = (char *)v4[24];
    if (v18 != v19)
    {
      do
      {
        long long v20 = *(_OWORD *)(v18 - 24);
        *((void *)v15 - 1) = *((void *)v18 - 1);
        *(_OWORD *)(v15 - 24) = v20;
        v15 -= 24;
        v18 -= 24;
      }
      while (v18 != v19);
      unint64_t v18 = (char *)v4[23];
    }
    v4[23] = v15;
    v4[24] = v8;
    v4[25] = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    uint64_t v8 = v7 + 3;
    v7[2] = v5;
  }
  v4[24] = v8;
  CFRelease(v2);
  return v4;
}

void sub_18504B87C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void *CGPDFSelectionCreateForStringRange(uint64_t a1, CFIndex a2, CFIndex a3)
{
  if (!a1) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v5) {
    return 0;
  }
  unint64_t v6 = v5;
  v9.location = a2;
  v9.length = a3;
  SelectionForStringuint64_t Range = PageLayout::CreateSelectionForStringRange(v5 + 2, v9);
  CFRelease(v6);
  return SelectionForStringRange;
}

void sub_18504B908(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t CGPDFSelectionCreateFromSelection(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (!CGPDFSelectionGetTypeID::id) {
    CGPDFSelectionGetTypeID::id = _CFRuntimeRegisterClass();
  }
  uint64_t cftype = pdf_create_cftype();
  if (cftype)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3) {
      CFRetain(*(CFTypeRef *)(a1 + 16));
    }
    *(void *)(cftype + 16) = v3;
    uint64_t v4 = *(void *)(a1 + 168);
    if (v4) {
      CFRetain(*(CFTypeRef *)(a1 + 168));
    }
    uint64_t v5 = *(void *)(a1 + 176);
    *(_OWORD *)(cftype + 184) = 0u;
    *(void *)(cftype + 168) = v4;
    *(void *)(cftype + 176) = v5;
    *(void *)(cftype + 248) = 0;
    *(_OWORD *)(cftype + 216) = 0u;
    *(_OWORD *)(cftype + 232) = 0u;
    *(_OWORD *)(cftype + 200) = 0u;
    *(unsigned char *)(cftype + 256) = 1;
    *(_DWORD *)(cftype + 260) = 0;
    uint64_t v7 = *(long long **)(a1 + 184);
    unint64_t v6 = *(long long **)(a1 + 192);
    CFRange v9 = (void **)(cftype + 184);
    while (v7 != v6)
    {
      std::back_insert_iterator<std::vector<std::pair<unsigned long,CFRange>>>::operator=[abi:fe180100](&v9, v7);
      uint64_t v7 = (long long *)((char *)v7 + 24);
    }
    *(unsigned char *)(cftype + 160) = 1;
  }
  return cftype;
}

void sub_18504BA08(_Unwind_Exception *exception_object)
{
  uint64_t v4 = (void *)v1[29];
  if (v4)
  {
    v1[30] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)v1[26];
  if (v5)
  {
    v1[27] = v5;
    operator delete(v5);
  }
  unint64_t v6 = *v2;
  if (*v2)
  {
    v1[24] = v6;
    operator delete(v6);
  }
  uint64_t v7 = (const void *)v1[21];
  if (v7) {
    CFRelease(v7);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFSelectionGetPage(uint64_t result)
{
  if (result) {
    return *(void *)(result + 168);
  }
  return result;
}

uint64_t CGPDFSelectionCreateContainingSelection()
{
  return 0;
}

uint64_t CGPDFSelectionCreateWithPage(const void *a1)
{
  if (!a1) {
    return 0;
  }
  if (!CGPDFSelectionGetTypeID::id) {
    CGPDFSelectionGetTypeID::id = _CFRuntimeRegisterClass();
  }
  uint64_t cftype = pdf_create_cftype();
  if (cftype)
  {
    CFRetain(a1);
    *(void *)(cftype + 16) = a1;
    CFRetain(a1);
    *(void *)(cftype + 168) = a1;
    *(_OWORD *)(cftype + 176) = 0u;
    *(_OWORD *)(cftype + 192) = 0u;
    *(_OWORD *)(cftype + 208) = 0u;
    *(_OWORD *)(cftype + 224) = 0u;
    *(_OWORD *)(cftype + 240) = 0u;
    *(unsigned char *)(cftype + 256) = 1;
    *(_DWORD *)(cftype + 260) = 0;
    *(unsigned char *)(cftype + 160) = 1;
  }
  return cftype;
}

uint64_t CGPDFSelectionCreateWithIndexSet(const void *a1, unsigned char *a2)
{
  if (!a1) {
    return 0;
  }
  if (!CGPDFSelectionGetTypeID::id) {
    CGPDFSelectionGetTypeID::id = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    CFRetain(a1);
    *(void *)(Instance + 16) = a1;
    if (a2)
    {
      if (a2[40]) {
        CPIndexSetNormalize((uint64_t)a2);
      }
      CFTypeRef v5 = CFRetain(a2);
    }
    else
    {
      CFTypeRef v5 = 0;
    }
    *(void *)(Instance + 24) = v5;
    *(void *)(Instance + 32) = 0;
    *(void *)(Instance + 40) = -1;
    *(void *)(Instance + 48) = -1;
    *(_OWORD *)(Instance + 56) = 0u;
    *(_OWORD *)(Instance + 72) = 0u;
    *(void *)(Instance + 88) = 0;
    uint64_t v71 = 0;
    long long v69 = 0u;
    *(_OWORD *)__p = 0u;
    *(_OWORD *)double v67 = 0u;
    *(_OWORD *)BOOL v68 = 0u;
    *(_OWORD *)cf = 0u;
    LOBYTE(v72) = 1;
    HIDWORD(v72) = 0;
    unint64_t v6 = *(const void **)(Instance + 168);
    *(void *)(Instance + 168) = 0;
    if (v6)
    {
      CFRelease(v6);
      CFTypeRef v7 = cf[1];
    }
    else
    {
      CFTypeRef v7 = 0;
    }
    *(void *)(Instance + 176) = v7;
    if ((CFTypeRef *)(Instance + 168) == cf) {
      goto LABEL_80;
    }
    uint64_t v8 = *(char **)(Instance + 184);
    unint64_t v10 = (char *)v67[0];
    CFRange v9 = (char *)v67[1];
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (((char *)v67[1] - (char *)v67[0]) >> 3);
    uint64_t v12 = *(void *)(Instance + 200);
    if (0xAAAAAAAAAAAAAAABLL * ((v12 - (uint64_t)v8) >> 3) >= v11)
    {
      unint64_t v19 = *(unsigned char **)(Instance + 192);
      if (0xAAAAAAAAAAAAAAABLL * ((v19 - v8) >> 3) < v11)
      {
        long long v20 = (char *)v67[0] + 8 * ((v19 - v8) >> 3);
        if (v19 != v8)
        {
          do
          {
            *(void *)uint64_t v8 = *(void *)v10;
            *(_OWORD *)(v8 + 8) = *(_OWORD *)(v10 + 8);
            v10 += 24;
            v8 += 24;
          }
          while (v10 != v20);
          uint64_t v8 = *(char **)(Instance + 192);
        }
        unint64_t v21 = v8;
        if (v20 != v9)
        {
          unint64_t v21 = v8;
          do
          {
            long long v22 = *(_OWORD *)v20;
            *((void *)v21 + 2) = *((void *)v20 + 2);
            *(_OWORD *)unint64_t v21 = v22;
            v21 += 24;
            v20 += 24;
          }
          while (v20 != v9);
        }
        uint64_t v23 = v21 - v8;
LABEL_39:
        unint64_t v24 = *(char **)(Instance + 208);
        *(void *)(Instance + 192) = &v8[v23];
        unint64_t v25 = (char *)v68[1];
        double v26 = (char *)v69;
        size_t v27 = v69 - (unint64_t)v68[1];
        unint64_t v28 = (uint64_t)(v69 - (unint64_t)v68[1]) >> 4;
        uint64_t v29 = *(void *)(Instance + 224);
        if (v28 <= (v29 - (uint64_t)v24) >> 4)
        {
          unint64_t v32 = *(unsigned char **)(Instance + 216);
          unint64_t v33 = (v32 - v24) >> 4;
          if (v33 < v28)
          {
            uint64_t v34 = (char *)v68[1] + 16 * v33;
            if (v32 != v24)
            {
              memmove(v24, v68[1], v32 - v24);
              unint64_t v24 = *(char **)(Instance + 216);
            }
            size_t v27 = v26 - v34;
            if (v26 == v34)
            {
LABEL_57:
              uint64_t v37 = *(char **)(Instance + 232);
              *(void *)(Instance + 216) = &v24[v27];
              unint64_t v39 = __p[0];
              long long v38 = __p[1];
              unint64_t v40 = 0xCCCCCCCCCCCCCCCDLL * (((char *)__p[1] - (char *)__p[0]) >> 4);
              uint64_t v41 = *(void *)(Instance + 248);
              if (0xCCCCCCCCCCCCCCCDLL * ((v41 - (uint64_t)v37) >> 4) >= v40)
              {
                unint64_t v45 = (char **)(Instance + 240);
                unint64_t v52 = *(char **)(Instance + 240);
                if (0xCCCCCCCCCCCCCCCDLL * ((v52 - v37) >> 4) < v40)
                {
                  long long v53 = (char *)__p[0] + 16 * ((v52 - v37) >> 4);
                  if (v52 != v37)
                  {
                    do
                    {
                      long long v54 = v39[1];
                      *(_OWORD *)uint64_t v37 = *v39;
                      *((_OWORD *)v37 + 1) = v54;
                      long long v55 = v39[2];
                      long long v56 = v39[4];
                      *((_OWORD *)v37 + 3) = v39[3];
                      *((_OWORD *)v37 + 4) = v56;
                      *((_OWORD *)v37 + 2) = v55;
                      v39 += 5;
                      v37 += 80;
                    }
                    while (v39 != v53);
                    uint64_t v37 = *v45;
                  }
                  CGAffineTransform v57 = v37;
                  if (v53 != v38)
                  {
                    CGAffineTransform v57 = v37;
                    do
                    {
                      *(_OWORD *)CGAffineTransform v57 = *v53;
                      long long v58 = v53[1];
                      long long v59 = v53[2];
                      long long v60 = v53[4];
                      *((_OWORD *)v57 + 3) = v53[3];
                      *((_OWORD *)v57 + 4) = v60;
                      *((_OWORD *)v57 + 1) = v58;
                      *((_OWORD *)v57 + 2) = v59;
                      v53 += 5;
                      v57 += 80;
                    }
                    while (v53 != v38);
                  }
                  int64_t v51 = v57 - v37;
                  goto LABEL_79;
                }
                long long v47 = v37;
                while (v39 != v38)
                {
                  long long v63 = v39[1];
                  *(_OWORD *)long long v47 = *v39;
                  *((_OWORD *)v47 + 1) = v63;
                  long long v64 = v39[2];
                  long long v65 = v39[4];
                  *((_OWORD *)v47 + 3) = v39[3];
                  *((_OWORD *)v47 + 4) = v65;
                  *((_OWORD *)v47 + 2) = v64;
                  v47 += 80;
                  v39 += 5;
                }
              }
              else
              {
                if (v37)
                {
                  *(void *)(Instance + 240) = v37;
                  operator delete(v37);
                  uint64_t v41 = 0;
                  *(void *)(Instance + 232) = 0;
                  *(void *)(Instance + 240) = 0;
                  *(void *)(Instance + 248) = 0;
                }
                if (v40 > 0x333333333333333) {
                  goto LABEL_95;
                }
                unint64_t v42 = 0xCCCCCCCCCCCCCCCDLL * (v41 >> 4);
                uint64_t v43 = 2 * v42;
                if (2 * v42 <= v40) {
                  uint64_t v43 = v40;
                }
                unint64_t v44 = v42 >= 0x199999999999999 ? 0x333333333333333 : v43;
                if (v44 > 0x333333333333333) {
LABEL_95:
                }
                  std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                uint64_t v37 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::pair<CGRect,CGAffineTransform>>>(v44);
                *(void *)(Instance + 240) = v37;
                unint64_t v45 = (char **)(Instance + 240);
                *(void *)(Instance + 232) = v37;
                *(void *)(Instance + 248) = &v37[80 * v46];
                long long v47 = v37;
                if (v39 != v38)
                {
                  long long v47 = v37;
                  do
                  {
                    *(_OWORD *)long long v47 = *v39;
                    long long v48 = v39[1];
                    long long v49 = v39[2];
                    long long v50 = v39[4];
                    *((_OWORD *)v47 + 3) = v39[3];
                    *((_OWORD *)v47 + 4) = v50;
                    *((_OWORD *)v47 + 1) = v48;
                    *((_OWORD *)v47 + 2) = v49;
                    v39 += 5;
                    v47 += 80;
                  }
                  while (v39 != v38);
                }
              }
              int64_t v51 = v47 - v37;
LABEL_79:
              void *v45 = &v37[v51];
LABEL_80:
              CGRect v61 = __p[0];
              *(void *)(Instance + 256) = v72;
              if (v61)
              {
                __p[1] = v61;
                operator delete(v61);
              }
              if (v68[1])
              {
                *(void **)&long long v69 = v68[1];
                operator delete(v68[1]);
              }
              if (v67[0])
              {
                v67[1] = v67[0];
                operator delete(v67[0]);
              }
              if (cf[0]) {
                CFRelease(cf[0]);
              }
              pthread_mutex_init((pthread_mutex_t *)(Instance + 96), 0);
              return Instance;
            }
            double v35 = v24;
            uint64_t v36 = v34;
LABEL_56:
            memmove(v35, v36, v27);
            goto LABEL_57;
          }
        }
        else
        {
          if (v24)
          {
            *(void *)(Instance + 216) = v24;
            operator delete(v24);
            uint64_t v29 = 0;
            *(void *)(Instance + 208) = 0;
            *(void *)(Instance + 216) = 0;
            *(void *)(Instance + 224) = 0;
          }
          if ((v27 & 0x8000000000000000) != 0) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v30 = v29 >> 3;
          if (v29 >> 3 <= v28) {
            uint64_t v30 = v28;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v30;
          }
          std::vector<CFRange>::__vallocate[abi:fe180100]((void *)(Instance + 208), v31);
          unint64_t v24 = *(char **)(Instance + 216);
        }
        if (v26 == v25) {
          goto LABEL_57;
        }
        double v35 = v24;
        uint64_t v36 = v25;
        goto LABEL_56;
      }
      uint64_t v17 = *(char **)(Instance + 184);
      while (v10 != v9)
      {
        *(void *)uint64_t v17 = *(void *)v10;
        *(_OWORD *)(v17 + 8) = *(_OWORD *)(v10 + 8);
        v17 += 24;
        v10 += 24;
      }
    }
    else
    {
      if (v8)
      {
        *(void *)(Instance + 192) = v8;
        operator delete(v8);
        uint64_t v12 = 0;
        *(void *)(Instance + 184) = 0;
        *(void *)(Instance + 192) = 0;
        *(void *)(Instance + 200) = 0;
      }
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_94;
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (v12 >> 3);
      uint64_t v14 = 2 * v13;
      if (2 * v13 <= v11) {
        uint64_t v14 = v11;
      }
      unint64_t v15 = v13 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v14;
      if (v15 > 0xAAAAAAAAAAAAAAALL) {
LABEL_94:
      }
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      uint64_t v8 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v15);
      *(void *)(Instance + 184) = v8;
      *(void *)(Instance + 192) = v8;
      *(void *)(Instance + 200) = &v8[24 * v16];
      uint64_t v17 = v8;
      while (v10 != v9)
      {
        long long v18 = *(_OWORD *)v10;
        *((void *)v17 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v17 = v18;
        v17 += 24;
        v10 += 24;
      }
    }
    uint64_t v23 = v17 - v8;
    goto LABEL_39;
  }
  return Instance;
}

void sub_18504C0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void Selection::~Selection(Selection *this)
{
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    *((void *)this + 9) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    *((void *)this + 6) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 2);
  if (v4)
  {
    *((void *)this + 3) = v4;
    operator delete(v4);
  }
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
}

BOOL CGPDFSelectionIsOfType(uint64_t a1, int a2)
{
  if (a1 && (uint64_t v4 = CGPDFPageCopyLayout(*(void *)(a1 + 16))) != 0)
  {
    CFTypeRef v5 = v4;
    uint64_t v6 = *(void *)(a1 + 24);
    if (!v6) {
      goto LABEL_12;
    }
    if (*(unsigned char *)(v6 + 40)) {
      CPIndexSetNormalize(*(void *)(a1 + 24));
    }
    unint64_t v7 = *(void *)(v6 + 16);
    if (v7)
    {
      BOOL v8 = 0;
      for (i = 0; i != v7; BOOL v8 = i >= v7)
      {
        uint64_t Range = CPIndexSetGetRange(*(void *)(a1 + 24), i);
        if ((CGPDFLayoutRangeIsOfType(v5, Range, v11, a2) & 1) == 0) {
          break;
        }
        ++i;
      }
    }
    else
    {
LABEL_12:
      BOOL v8 = 1;
    }
    CFRelease(v5);
  }
  else
  {
    return 0;
  }
  return v8;
}

void sub_18504C200(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

double CGPDFSelectionGetBounds(uint64_t a1)
{
  CGFloat width = 0.0;
  if (!a1) {
    return INFINITY;
  }
  Selection::cacheRectsAndTransforms((os_unfair_lock_s *)(a1 + 168));
  uint64_t v4 = *(void *)(a1 + 232);
  uint64_t v3 = *(void *)(a1 + 240);
  if (v4 == v3) {
    return INFINITY;
  }
  double x = INFINITY;
  CGFloat y = INFINITY;
  CGFloat height = 0.0;
  do
  {
    CGRect v11 = *(CGRect *)v4;
    long long v8 = *(_OWORD *)(v4 + 48);
    *(_OWORD *)&v10.a = *(_OWORD *)(v4 + 32);
    *(_OWORD *)&v10.c = v8;
    *(_OWORD *)&v10.tdouble x = *(_OWORD *)(v4 + 64);
    CGRect v14 = CGRectApplyAffineTransform(v11, &v10);
    v12.origin.double x = x;
    v12.origin.CGFloat y = y;
    v12.size.CGFloat width = width;
    v12.size.CGFloat height = height;
    CGRect v13 = CGRectUnion(v12, v14);
    double x = v13.origin.x;
    CGFloat y = v13.origin.y;
    CGFloat width = v13.size.width;
    CGFloat height = v13.size.height;
    v4 += 80;
  }
  while (v4 != v3);
  return x;
}

uint64_t CGPDFSelectionGetLength(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (!v1) {
      return 0;
    }
    if (*(unsigned char *)(v1 + 40)) {
      CPIndexSetNormalize(*(void *)(result + 24));
    }
    uint64_t v2 = *(void *)(v1 + 16);
    if (v2 >= 1)
    {
      uint64_t result = 0;
      uint64_t v3 = (uint64_t *)(*(void *)(v1 + 32) + 8);
      do
      {
        uint64_t v4 = *v3;
        v3 += 2;
        result += v4;
        --v2;
      }
      while (v2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFSelectionSetClientProperty(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 176) = a2;
  }
  return result;
}

uint64_t CGPDFSelectionGetClientProperty(uint64_t result)
{
  if (result) {
    return *(void *)(result + 176);
  }
  return result;
}

void CGPDFSelectionGetTextMatrixAtIndex(uint64_t a1@<X0>, uint64_t a2@<X1>, CGAffineTransform *a3@<X8>)
{
  *a3 = CGAffineTransformIdentity;
  if (a1)
  {
    LayoutIndedouble x = CGPDFSelectionGetLayoutIndex((CGPDFSelection *)a1, a2);
    CFTypeRef v6 = CGPDFPageCopyLayout(*(void *)(a1 + 16));
    CGPDFLayoutGetTextMatrix((uint64_t)v6, LayoutIndex, (uint64_t)a3);
    if (v6) {
      CFRelease(v6);
    }
  }
}

uint64_t CGPDFSelectionGetLayoutIndex(CGPDFSelection *a1, uint64_t a2)
{
  uint64_t v2 = *((void *)a1 + 3);
  if (!v2) {
    return 0;
  }
  if (*(unsigned char *)(v2 + 40)) {
    CPIndexSetNormalize(*((void *)a1 + 3));
  }
  uint64_t v5 = *(void *)(v2 + 16);
  if (v5 < 1) {
    return 0;
  }
  uint64_t v6 = 0;
  while (1)
  {
    uint64_t Range = CPIndexSetGetRange(*((void *)a1 + 3), v6);
    if (a2 <= v8) {
      break;
    }
    ++v6;
    a2 -= v8;
    if (v5 == v6) {
      return 0;
    }
  }
  return Range + a2;
}

CGPDFSelection *CGPDFSelectionGetCGFontAtIndex(CGPDFSelection *a1, uint64_t a2)
{
  CGFont = a1;
  if (a1)
  {
    LayoutIndedouble x = CGPDFSelectionGetLayoutIndex(a1, a2);
    CFTypeRef v4 = CGPDFPageCopyLayout(*((void *)CGFont + 2));
    CGFont = (CGPDFSelection *)CGPDFLayoutGetCGFont((uint64_t)v4, LayoutIndex);
    if (v4) {
      CFRelease(v4);
    }
  }
  return CGFont;
}

CGPDFSelection *CGPDFSelectionGetGlyphAtIndex(CGPDFSelection *a1, uint64_t a2)
{
  Glyph = a1;
  if (a1)
  {
    LayoutIndedouble x = CGPDFSelectionGetLayoutIndex(a1, a2);
    CFTypeRef v4 = CGPDFPageCopyLayout(*((void *)Glyph + 2));
    Glyph = (CGPDFSelection *)CGPDFLayoutGetGlyph((uint64_t)v4, LayoutIndex);
    if (v4) {
      CFRelease(v4);
    }
  }
  return Glyph;
}

void CGPDFSelectionBufferUnicodeAndCharacterBounds(uint64_t a1, _WORD *a2, uint64_t a3)
{
  if (a1)
  {
    CFTypeRef v6 = CGPDFPageCopyLayout(*(void *)(a1 + 16));
    if (v6)
    {
      unint64_t v7 = v6;
      uint64_t v8 = *(void *)(a1 + 24);
      if (v8)
      {
        if (*(unsigned char *)(v8 + 40)) {
          CPIndexSetNormalize(*(void *)(a1 + 24));
        }
        uint64_t v9 = *(void *)(v8 + 16);
        if (v9 >= 1)
        {
          uint64_t v10 = 0;
          CGRect v11 = a2;
          uint64_t v12 = a3;
          do
          {
            uint64_t Range = CPIndexSetGetRange(*(void *)(a1 + 24), v10);
            uint64_t v15 = v14;
            CGPDFLayoutBufferUnicodeAndBoundsForRange((uint64_t)v7, v11, v12, Range, v14);
            if (a2) {
              uint64_t v16 = v15;
            }
            else {
              uint64_t v16 = 0;
            }
            v11 += v16;
            if (a3) {
              uint64_t v17 = v15;
            }
            else {
              uint64_t v17 = 0;
            }
            v12 += 32 * v17;
            ++v10;
          }
          while (v9 != v10);
        }
      }
      CFRelease(v7);
    }
  }
}

os_unfair_lock_s *CGPDFSelectionGetNumberOfRectsAndTransforms(os_unfair_lock_s *result)
{
  if (result)
  {
    uint64_t v1 = result;
    Selection::cacheRectsAndTransforms(result + 42);
    return (os_unfair_lock_s *)(0xCCCCCCCCCCCCCCCDLL
                              * ((uint64_t)(*(void *)&v1[60]._os_unfair_lock_opaque
                                         - *(void *)&v1[58]._os_unfair_lock_opaque) >> 4));
  }
  return result;
}

uint64_t CGPDFSelectionGetRectAndTransform(uint64_t a1, unint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a1)
  {
    Selection::cacheRectsAndTransforms((os_unfair_lock_s *)(a1 + 168));
    uint64_t v8 = *(void *)(a1 + 232);
    if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 240) - v8) >> 4) <= a2)
    {
      *(CGRect *)a3 = CGRectNull;
      uint64_t v10 = &CGAffineTransformIdentity;
    }
    else
    {
      uint64_t v9 = (_OWORD *)(v8 + 80 * a2);
      long long v11 = *v9;
      long long v12 = v9[1];
      uint64_t v10 = (const CGAffineTransform *)(v9 + 2);
      *(_OWORD *)a3 = v11;
      *(_OWORD *)(a3 + 16) = v12;
    }
    long long v13 = *(_OWORD *)&v10->a;
    long long v14 = *(_OWORD *)&v10->tx;
    a4[1] = *(_OWORD *)&v10->c;
    a4[2] = v14;
    *a4 = v13;
  }
  return 0;
}

void CGPDFSelectionEnumerateRectsAndTransforms(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    Selection::cacheRectsAndTransforms((os_unfair_lock_s *)(a1 + 168));
    uint64_t v4 = *(void *)(a1 + 240) - *(void *)(a1 + 232);
    if (v4 >= 1)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      uint64_t v7 = v4 / 80;
      do
      {
        Selection::cacheRectsAndTransforms((os_unfair_lock_s *)(a1 + 168));
        uint64_t v12 = *(void *)(a1 + 232);
        if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 240) - v12) >> 4) <= v6)
        {
          v11.n128_u64[0] = 0;
          v9.n128_u64[0] = 0x7FF0000000000000;
          v10.n128_u64[0] = 0;
          v8.n128_u64[0] = 0x7FF0000000000000;
          long long v14 = &CGAffineTransformIdentity;
        }
        else
        {
          long long v13 = (void *)(v12 + v5);
          v8.n128_u64[0] = *v13;
          v9.n128_u64[0] = v13[1];
          v10.n128_u64[0] = v13[2];
          v11.n128_u64[0] = v13[3];
          long long v14 = (const CGAffineTransform *)(v13 + 4);
        }
        long long v15 = *(_OWORD *)&v14->a;
        long long v16 = *(_OWORD *)&v14->tx;
        v17[1] = *(_OWORD *)&v14->c;
        v17[2] = v16;
        v17[0] = v15;
        (*((void (**)(id, _OWORD *, void, __n128, __n128, __n128, __n128))v3 + 2))(v3, v17, 0, v8, v9, v10, v11);
        ++v6;
        v5 += 80;
      }
      while (v7 != v6);
    }
  }
}

void sub_18504C838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CGPDFSelectionGetRangeForRectIndex(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 184);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(result + 192) - v2) >> 3) <= a2) {
      return -1;
    }
    else {
      return *(void *)(v2 + 24 * a2 + 8);
    }
  }
  return result;
}

uint64_t *CGPDFSelectionCreateAttributedString(uint64_t *a1)
{
  AttributedStringForStringRanges = a1;
  if (a1)
  {
    if (a1[23] == a1[24])
    {
      return 0;
    }
    else
    {
      Selection::cacheStringRanges((Selection *)(a1 + 21));
      CGPDFPageCopyPageLayoutWithCTLD(AttributedStringForStringRanges[21], 1);
      id v3 = v2;
      uint64_t v4 = (AttributedStringForStringRanges[27] - AttributedStringForStringRanges[26]) >> 4;
      v6[0] = AttributedStringForStringRanges[26];
      v6[1] = v4;
      AttributedStringForStringRanges = (uint64_t *)PageLayout::CreateAttributedStringForStringRanges((uint64_t)v2 + 16, (uint64_t)v6);
      if (v3) {
        CFRelease(v3);
      }
    }
  }
  return AttributedStringForStringRanges;
}

void sub_18504C920(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFSelectionGetFirstIndex(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  uint64_t v1 = *(void *)(a1 + 184);
  if (*(void *)(a1 + 192) == v1) {
    return -1;
  }
  else {
    return *(void *)(v1 + 8);
  }
}

uint64_t CGPDFSelectionGetLastIndex(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  uint64_t v1 = *(void *)(a1 + 192);
  if (v1 == *(void *)(a1 + 184)) {
    return -1;
  }
  else {
    return *(void *)(v1 - 8) + *(void *)(v1 - 16);
  }
}

uint64_t CGPDFSelectionGetStartIndex(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  uint64_t v1 = *(void *)(a1 + 184);
  if (*(void *)(a1 + 192) == v1) {
    return -1;
  }
  else {
    return *(void *)(v1 + 8);
  }
}

uint64_t CGPDFSelectionGetEndIndex(uint64_t a1)
{
  if (a1) {
    return CGPDFSelectionGetLastIndex(a1);
  }
  else {
    return -1;
  }
}

void CGPDFSelectionGetStartCursorXPosition(CGPDFSelection *a1, BOOL *a2)
{
}

void CGPDFSelectionGetCursorXPosition(CGPDFSelection *a1, int a2, BOOL *a3)
{
  CGFloat v6 = 0.0;
  if (a1)
  {
    if (a2)
    {
      uint64_t v10 = *((void *)a1 + 23);
      if (*((void *)a1 + 24) == v10) {
        return;
      }
      LastIndedouble x = *(void *)(v10 + 8);
    }
    else
    {
      LastIndedouble x = CGPDFSelectionGetLastIndex((uint64_t)a1);
    }
    if (LastIndex != -1)
    {
      *a3 = 0;
      CGPDFPageCopyPageLayoutWithCTLD(*((void *)a1 + 2), 1);
      if (v12)
      {
        if (LastIndex < (uint64_t)(v12[16] - v12[15]) >> 5)
        {
          uint64_t v13 = v12[18];
          if (LastIndex >= (v12[19] - v13) >> 5)
          {
            __break(1u);
            return;
          }
          long long v14 = (CGFloat *)(v13 + 32 * LastIndex);
          CGFloat v6 = *v14;
          CGFloat v5 = v14[1];
          double v3 = v14[2];
          double v4 = v14[3];
        }
        CFRelease(v12);
      }
      BOOL v15 = v3 < 0.0;
      if (v4 < 0.0) {
        BOOL v15 = 1;
      }
      if (a2)
      {
        if (v15)
        {
          v16.origin.double x = v6;
          v16.origin.CGFloat y = v5;
          v16.size.CGFloat width = v3;
          v16.size.CGFloat height = v4;
          CGRectStandardize(v16);
        }
      }
      else if (v15)
      {
        v17.origin.double x = v6;
        v17.origin.CGFloat y = v5;
        v17.size.CGFloat width = v3;
        v17.size.CGFloat height = v4;
        CGRectStandardize(v17);
      }
    }
  }
}

void CGPDFSelectionGetEndCursorXPosition(CGPDFSelection *a1, BOOL *a2)
{
}

uint64_t CGPDFSelectionGetNumberOfStringRanges(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    Selection::cacheStringRanges((Selection *)(result + 168));
    return (uint64_t)(*(void *)(v1 + 216) - *(void *)(v1 + 208)) >> 4;
  }
  return result;
}

uint64_t CGPDFSelectionGetStringRange(void *a1, unint64_t a2)
{
  if (!a1) {
    return -1;
  }
  if (a1[23] == a1[24]) {
    return -1;
  }
  Selection::cacheStringRanges((Selection *)(a1 + 21));
  uint64_t v4 = a1[26];
  if (a2 >= (a1[27] - v4) >> 4) {
    return -1;
  }
  return *(void *)(v4 + 16 * a2);
}

void CGPDFSelectionAddSelection(uint64_t a1, uint64_t a2)
{
  if (a1 && a1 != a2 && *(void *)(a2 + 184) != *(void *)(a2 + 192))
  {
    unint64_t v52 = 0;
    long long v53 = 0;
    double v3 = *(long long **)(a1 + 192);
    uint64_t v4 = *(long long **)(a1 + 184);
    *(void *)(a1 + 184) = 0;
    *(void *)(a1 + 192) = 0;
    *(void *)(a1 + 200) = 0;
    uint64_t v6 = *(void *)(a2 + 184);
    uint64_t v5 = *(void *)(a2 + 192);
    uint64_t v7 = &v52;
    uint64_t v54 = 0;
    long long v55 = &v52;
    __p = v4;
    if (v4 != v3)
    {
      __n128 v8 = v4;
      while (1)
      {
        if (v6 == v5)
        {
          long long v56 = v55;
          while (v8 != v3)
          {
            std::back_insert_iterator<std::vector<std::pair<unsigned long,CFRange>>>::operator=[abi:fe180100](&v56, v8);
            __n128 v8 = (long long *)((char *)v8 + 24);
          }
          goto LABEL_22;
        }
        if (*(void *)v6 == *(void *)v8)
        {
          uint64_t v9 = *(void *)(v6 + 8);
          uint64_t v10 = *((void *)v8 + 1);
          BOOL v11 = v9 < v10;
          if (v9 == v10) {
            BOOL v11 = *(void *)(v6 + 16) < *((void *)v8 + 2);
          }
          if (v11)
          {
LABEL_13:
            std::back_insert_iterator<std::vector<std::pair<unsigned long,CFRange>>>::operator=[abi:fe180100](&v55, (long long *)v6);
            v6 += 24;
            goto LABEL_14;
          }
        }
        else if (*(void *)v6 < *(void *)v8)
        {
          goto LABEL_13;
        }
        std::back_insert_iterator<std::vector<std::pair<unsigned long,CFRange>>>::operator=[abi:fe180100](&v55, v8);
        __n128 v8 = (long long *)((char *)v8 + 24);
LABEL_14:
        if (v8 == v3)
        {
          uint64_t v7 = v55;
          break;
        }
      }
    }
    long long v56 = v7;
    while (v6 != v5)
    {
      std::back_insert_iterator<std::vector<std::pair<unsigned long,CFRange>>>::operator=[abi:fe180100](&v56, (long long *)v6);
      v6 += 24;
    }
LABEL_22:
    if (v52 == v53)
    {
      __break(1u);
    }
    else
    {
      uint64_t v13 = *(void *)v52;
      uint64_t v12 = *((void *)v52 + 1);
      uint64_t v14 = *((void *)v52 + 2);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 260));
      BOOL v15 = v53;
      int64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((char *)v53 - (unsigned char *)v52) >> 3);
      if (v16 >= 1) {
        int64_t v16 = 1;
      }
      CGRect v17 = (uint64_t *)((char *)v52 + 24 * v16);
      if (v17 != v53)
      {
        do
        {
          uint64_t v18 = v14 + v12;
          uint64_t v19 = v17[1];
          if (v14 + v12 >= v19)
          {
            uint64_t v23 = v17[2] + v19;
            if (v18 <= v23) {
              uint64_t v18 = v23;
            }
            uint64_t v14 = v18 - v12;
          }
          else
          {
            unint64_t v21 = *(void **)(a1 + 192);
            unint64_t v20 = *(void *)(a1 + 200);
            if ((unint64_t)v21 >= v20)
            {
              uint64_t v24 = *(void *)(a1 + 184);
              unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v21 - v24) >> 3);
              unint64_t v26 = v25 + 1;
              if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
                std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
              }
              unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v24) >> 3);
              if (2 * v27 > v26) {
                unint64_t v26 = 2 * v27;
              }
              if (v27 >= 0x555555555555555) {
                unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v28 = v26;
              }
              uint64_t v29 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v28);
              unint64_t v31 = &v29[24 * v25];
              *(void *)unint64_t v31 = v13;
              *((void *)v31 + 1) = v12;
              *((void *)v31 + 2) = v14;
              unint64_t v33 = *(char **)(a1 + 184);
              unint64_t v32 = *(char **)(a1 + 192);
              uint64_t v34 = v31;
              if (v32 != v33)
              {
                do
                {
                  long long v35 = *(_OWORD *)(v32 - 24);
                  *((void *)v34 - 1) = *((void *)v32 - 1);
                  *(_OWORD *)(v34 - 24) = v35;
                  v34 -= 24;
                  v32 -= 24;
                }
                while (v32 != v33);
                unint64_t v32 = *(char **)(a1 + 184);
              }
              long long v22 = v31 + 24;
              *(void *)(a1 + 184) = v34;
              *(void *)(a1 + 192) = v31 + 24;
              *(void *)(a1 + 200) = &v29[24 * v30];
              if (v32) {
                operator delete(v32);
              }
            }
            else
            {
              *unint64_t v21 = v13;
              v21[1] = v12;
              long long v22 = v21 + 3;
              v21[2] = v14;
            }
            *(void *)(a1 + 192) = v22;
            uint64_t v13 = *v17;
            uint64_t v12 = v17[1];
            uint64_t v14 = v17[2];
          }
          v17 += 3;
        }
        while (v17 != v15);
      }
      uint64_t v37 = *(void **)(a1 + 192);
      unint64_t v36 = *(void *)(a1 + 200);
      if ((unint64_t)v37 >= v36)
      {
        uint64_t v39 = *(void *)(a1 + 184);
        unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v37 - v39) >> 3);
        unint64_t v41 = v40 + 1;
        if (v40 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - v39) >> 3);
        if (2 * v42 > v41) {
          unint64_t v41 = 2 * v42;
        }
        if (v42 >= 0x555555555555555) {
          unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v43 = v41;
        }
        unint64_t v44 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v43);
        unint64_t v45 = &v44[24 * v40];
        long long v47 = &v44[24 * v46];
        *(void *)unint64_t v45 = v13;
        *((void *)v45 + 1) = v12;
        *((void *)v45 + 2) = v14;
        long long v38 = v45 + 24;
        long long v49 = *(char **)(a1 + 184);
        long long v48 = *(char **)(a1 + 192);
        if (v48 != v49)
        {
          do
          {
            long long v50 = *(_OWORD *)(v48 - 24);
            *((void *)v45 - 1) = *((void *)v48 - 1);
            *(_OWORD *)(v45 - 24) = v50;
            v45 -= 24;
            v48 -= 24;
          }
          while (v48 != v49);
          long long v48 = *(char **)(a1 + 184);
        }
        *(void *)(a1 + 184) = v45;
        *(void *)(a1 + 192) = v38;
        *(void *)(a1 + 200) = v47;
        if (v48) {
          operator delete(v48);
        }
      }
      else
      {
        *uint64_t v37 = v13;
        v37[1] = v12;
        long long v38 = v37 + 3;
        v37[2] = v14;
      }
      *(void *)(a1 + 192) = v38;
      *(unsigned char *)(a1 + 256) = 1;
      *(void *)(a1 + 240) = *(void *)(a1 + 232);
      Selection::Normalize((Selection *)(a1 + 168));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 260));
      if (__p) {
        operator delete(__p);
      }
      if (v52)
      {
        long long v53 = (uint64_t *)v52;
        operator delete(v52);
      }
    }
  }
}

void sub_18504CF60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, void *__p, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t CGPDFSelectionSubtractSelection(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  if (!a2) {
    return result;
  }
  uint64_t v2 = *(void *)(a2 + 24);
  if (!v2) {
    return result;
  }
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 24);
  if (!v4) {
    goto LABEL_58;
  }
  if (*(unsigned char *)(v4 + 40)) {
    CPIndexSetNormalize(*(void *)(result + 24));
  }
  if (*(unsigned char *)(v2 + 40)) {
    CPIndexSetNormalize(v2);
  }
  if (*(uint64_t *)(v2 + 16) < 1) {
    goto LABEL_58;
  }
  uint64_t v5 = 0;
  do
  {
    uint64_t v6 = *(void *)(v4 + 16);
    if (!v6) {
      break;
    }
    uint64_t v7 = (uint64_t *)(*(void *)(v2 + 32) + 16 * v5);
    uint64_t v9 = *v7;
    uint64_t v8 = v7[1];
    if (*(unsigned char *)(v4 + 40))
    {
      CPIndexSetNormalize(v4);
      uint64_t v6 = *(void *)(v4 + 16);
    }
    uint64_t v10 = *(uint64_t **)(v4 + 32);
    uint64_t v11 = *v10;
    uint64_t v12 = v8 + v9;
    BOOL v13 = v12 <= *v10 || v6 < 1;
    if (v13) {
      goto LABEL_56;
    }
    char v14 = 0;
    uint64_t v15 = v6;
    uint64_t v16 = 1;
    CGRect v17 = *(uint64_t **)(v4 + 32);
    while (2)
    {
      uint64_t v18 = v17 + 1;
      if (v15 <= v16) {
        uint64_t v19 = v16;
      }
      else {
        uint64_t v19 = v15;
      }
      uint64_t v20 = 2 * v16;
      uint64_t v21 = v19 + 1;
      while (1)
      {
        uint64_t v22 = *v18 + v11;
        if (v22 <= v9) {
          goto LABEL_36;
        }
        if (v12 <= v11) {
          goto LABEL_47;
        }
        if (v9 <= v11 && v22 <= v12) {
          break;
        }
        BOOL v23 = v9 <= v11;
        if (v22 > v12 && v9 <= v11)
        {
          unint64_t v25 = &v10[v20];
          *(v25 - 2) = v12;
          *(v25 - 1) = v22 - v12;
          goto LABEL_47;
        }
        if (v22 > v12) {
          BOOL v23 = 1;
        }
        if (v23)
        {
          BOOL v13 = v9 <= v11;
          uint64_t v26 = v9 - v11;
          if (!v13)
          {
            uint64_t v27 = v22 - v12;
            if (v22 > v12)
            {
              if (v15 == *(void *)(v4 + 24))
              {
                uint64_t v10 = (uint64_t *)malloc_type_realloc(v10, 16 * v15 + 16, 0x1000040451B5BE8uLL);
                uint64_t v15 = *(void *)(v4 + 16);
                ++*(void *)(v4 + 24);
                *(void *)(v4 + 32) = v10;
              }
              *(void *)(v4 + 16) = v15 + 1;
              unint64_t v28 = &v10[2 * v16];
              *(v28 - 2) = v11;
              *(v28 - 1) = v26;
              uint64_t v29 = &v10[2 * *(void *)(v4 + 16)];
              *(v29 - 2) = v12;
              *(v29 - 1) = v27;
              *(unsigned char *)(v4 + 40) = 1;
            }
          }
LABEL_47:
          uint64_t v15 = *(void *)(v4 + 16);
          uint64_t v6 = v15;
          if ((v14 & 1) == 0) {
            goto LABEL_56;
          }
          goto LABEL_48;
        }
        v10[v20 - 1] = v9 - v11;
LABEL_36:
        if (v16 < v6)
        {
          ++v16;
          uint64_t v18 = &v10[v20 + 1];
          uint64_t v11 = v10[v20];
          v20 += 2;
          if (v21 != v16) {
            continue;
          }
        }
        goto LABEL_47;
      }
      *(_OWORD *)&v10[2 * v16 - 2] = CPIndexSetNullRange;
      uint64_t v15 = *(void *)(v4 + 16);
      if (v16 < v6)
      {
        uint64_t v10 = *(uint64_t **)(v4 + 32);
        CGRect v17 = &v10[2 * v16];
        uint64_t v11 = *v17;
        char v14 = 1;
        BOOL v13 = v16++ < v15;
        if (v13) {
          continue;
        }
      }
      break;
    }
LABEL_48:
    uint64_t v30 = (char *)malloc_type_malloc(16 * v15, 0x1000040451B5BE8uLL);
    uint64_t v31 = *(void *)(v4 + 16);
    unint64_t v32 = *(uint64_t **)(v4 + 32);
    if (v31 < 1)
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v33 = 0;
      uint64_t v6 = 0;
      uint64_t v34 = v32 + 1;
      do
      {
        uint64_t v35 = *(v34 - 1);
        if ((v35 & 0x8000000000000000) == 0)
        {
          uint64_t v36 = *v34;
          uint64_t v37 = &v30[16 * v6++];
          *(void *)uint64_t v37 = v35;
          *((void *)v37 + 1) = v36;
          uint64_t v31 = *(void *)(v4 + 16);
        }
        ++v33;
        v34 += 2;
      }
      while (v33 < v31);
    }
    free(v32);
    *(void *)(v4 + 32) = v30;
    *(void *)(v4 + 16) = v6;
LABEL_56:
    if (!v6) {
      break;
    }
    CPIndexSetNormalize(v4);
    ++v5;
  }
  while (v5 < *(void *)(v2 + 16));
LABEL_58:
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 96));
  *(void *)(v3 + 40) = -1;
  long long v38 = *(const void **)(v3 + 32);
  if (v38) {
    CFRelease(v38);
  }
  *(void *)(v3 + 32) = 0;
  uint64_t v39 = *(void **)(v3 + 56);
  if (v39)
  {
    free(v39);
    *(void *)(v3 + 56) = 0;
  }
  unint64_t v40 = *(void **)(v3 + 64);
  if (v40)
  {
    free(v40);
    *(void *)(v3 + 64) = 0;
  }
  unint64_t v41 = *(void **)(v3 + 72);
  if (v41)
  {
    free(v41);
    *(void *)(v3 + 72) = 0;
  }
  unint64_t v42 = *(void **)(v3 + 80);
  if (v42)
  {
    free(v42);
    *(void *)(v3 + 80) = 0;
  }
  *(void *)(v3 + 48) = -1;

  return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 96));
}

void CGPDFSelectionExtendAtStart(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && *(void *)(a1 + 184) != *(void *)(a1 + 192))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 260));
    *(unsigned char *)(a1 + 256) = 1;
    *(void *)(a1 + 240) = *(void *)(a1 + 232);
    uint64_t v4 = *(void **)(a1 + 184);
    uint64_t v5 = *(void **)(a1 + 192);
    if (v4 == v5)
    {
      __break(1u);
    }
    else
    {
      if (a2 < 1)
      {
        uint64_t v9 = v4[2];
        if (v9 <= -a2)
        {
          v4[1] += v9;
          v4[2] = 0;
          while (1)
          {
            uint64_t v10 = v4 + 3;
            if (v4 + 3 == v5) {
              break;
            }
            v4 += 3;
            *(v4 - 3) = *v10;
            *((_OWORD *)v4 - 1) = *(_OWORD *)(v4 + 1);
          }
          *(void *)(a1 + 192) = v4;
        }
        else
        {
          v4[1] -= a2;
          v4[2] = v9 + a2;
        }
      }
      else
      {
        uint64_t v6 = v4[1];
        if (v6 >= a2) {
          uint64_t v7 = a2;
        }
        else {
          uint64_t v7 = v4[1];
        }
        uint64_t v8 = v4[2] + v7;
        v4[1] = v6 - v7;
        v4[2] = v8;
      }
      Selection::Normalize((Selection *)(a1 + 168));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 260));
    }
  }
}

void sub_18504D410(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CGPDFSelectionExtendAtEnd(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && *(void *)(a1 + 184) != *(void *)(a1 + 192))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 260));
    *(unsigned char *)(a1 + 256) = 1;
    *(void *)(a1 + 240) = *(void *)(a1 + 232);
    CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 168), 1);
    uint64_t v5 = *(void *)(a1 + 192);
    if (*(void *)(a1 + 184) == v5)
    {
      __break(1u);
    }
    else
    {
      uint64_t v6 = v4;
      if (a2 < 1)
      {
        uint64_t v10 = *(void *)(v5 - 8);
        if (v10 <= -a2)
        {
          uint64_t v11 = 0;
          *(void *)(a1 + 192) = v5 - 24;
        }
        else
        {
          uint64_t v11 = v10 + a2;
        }
        *(void *)(v5 - 8) = v11;
      }
      else
      {
        uint64_t v7 = *(void *)(v5 - 8);
        uint64_t v8 = v7 + *(void *)(v5 - 16);
        if (((uint64_t)(v4[16] - v4[15]) >> 5) - v8 >= a2) {
          uint64_t v9 = a2;
        }
        else {
          uint64_t v9 = ((uint64_t)(v4[16] - v4[15]) >> 5) - v8;
        }
        *(void *)(v5 - 8) = v9 + v7;
      }
      Selection::Normalize((Selection *)(a1 + 168));
      if (v6) {
        CFRelease(v6);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 260));
    }
  }
}

void sub_18504D53C(_Unwind_Exception *a1)
{
  if (v2) {
    CFRelease(v2);
  }
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t *CGPDFSelectionCreateSelectionsByLine(uint64_t *a1)
{
  uint64_t v1 = a1;
  v31[16] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:0xAAAAAAAAAAAAAAABLL * ((a1[24] - a1[23]) >> 3)];
    id v30 = v2;
    if (v1[23] == v1[24])
    {
      uint64_t v22 = v2;
      uint64_t v1 = v22;
    }
    else
    {
      CGPDFPageCopyPageLayoutWithCTLD(v1[21], 1);
      uint64_t v4 = v3;
      uint64_t v29 = CGPDFSelectionCreateWithPage((const void *)v1[21]);
      uint64_t v5 = (unint64_t *)v1[23];
      if (v5 == (unint64_t *)v1[24]) {
LABEL_29:
      }
        __break(1u);
      uint64_t v6 = 0;
      unint64_t v28 = *v5;
      v31[0] = v1 + 21;
      v31[1] = &v29;
      v31[2] = &v28;
      v31[3] = &v30;
      uint64_t v7 = -1;
      uint64_t v8 = -1;
      do
      {
        unint64_t v9 = *v5;
        uint64_t v10 = v5[1];
        uint64_t v11 = v5[2];
        if (v8 != -1) {
          Selection::CreateSelectionsByLine(void)const::$_0::operator()((uint64_t)v31, v7, v8, v6);
        }
        uint64_t v12 = v4[6];
        if (0x8E38E38E38E38E39 * ((v4[7] - v12) >> 3) <= v9) {
          goto LABEL_29;
        }
        uint64_t v13 = v11 + v10;
        uint64_t v14 = *(void *)(v12 + 72 * v9 + 8) + *(void *)(v12 + 72 * v9);
        if (v11 + v10 <= v14)
        {
          uint64_t v6 = v11;
          uint64_t v8 = v10;
        }
        else
        {
          uint64_t v15 = 72 * v9;
          do
          {
            uint64_t v8 = v14;
            Selection::CreateSelectionsByLine(void)const::$_0::operator()((uint64_t)v31, v9++, v10, v14 - v10);
            uint64_t v16 = v4[6];
            if (0x8E38E38E38E38E39 * ((v4[7] - v16) >> 3) <= v9) {
              goto LABEL_29;
            }
            uint64_t v14 = *(void *)(v16 + v15 + 80) + *(void *)(v16 + v15 + 72);
            v15 += 72;
            uint64_t v10 = v8;
          }
          while (v13 > v14);
          uint64_t v6 = v13 - v8;
        }
        uint64_t v7 = v9;
        v5 += 3;
      }
      while (v5 != (unint64_t *)v1[24]);
      Selection::CreateSelectionsByLine(void)const::$_0::operator()((uint64_t)v31, v9, v8, v6);
      CGRect v17 = (void *)v29;
      [v30 addObject:v29];

      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      id v18 = v30;
      uint64_t v19 = [v18 countByEnumeratingWithState:&v24 objects:v31 count:16];
      if (v19)
      {
        uint64_t v20 = *(void *)v25;
        do
        {
          for (uint64_t i = 0; i != v19; ++i)
          {
            if (*(void *)v25 != v20) {
              objc_enumerationMutation(v18);
            }
            Selection::Normalize((Selection *)(*(void *)(*((void *)&v24 + 1) + 8 * i) + 168));
          }
          uint64_t v19 = [v18 countByEnumeratingWithState:&v24 objects:v31 count:16];
        }
        while (v19);

        uint64_t v22 = (uint64_t *)v30;
        uint64_t v1 = v22;
        if (!v4) {
          goto LABEL_27;
        }
      }
      else
      {

        uint64_t v1 = (uint64_t *)v30;
      }
      CFRelease(v4);
      uint64_t v22 = (uint64_t *)v30;
    }
LABEL_27:
  }
  return v1;
}

void sub_18504D834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL CGPDFSelectionIsEmpty(uint64_t a1)
{
  return !a1 || *(void *)(a1 + 184) == *(void *)(a1 + 192);
}

BOOL CGPDFSelectionEqualToSelection(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1 && a2)
  {
    if (*(unsigned char *)(a1 + 160) && *(unsigned char *)(a2 + 160))
    {
      uint64_t v6 = a1 + 184;
      uint64_t v4 = *(char **)(a1 + 184);
      uint64_t v5 = *(char **)(v6 + 8);
      uint64_t v7 = *(void **)(a2 + 184);
      if (v5 - v4 == *(void *)(a2 + 192) - (void)v7)
      {
        if (v4 != v5)
        {
          BOOL result = 1;
          while (*(void *)v4 == *v7)
          {
            if (*((void *)v4 + 1) != v7[1] || *((void *)v4 + 2) != v7[2]) {
              break;
            }
            v4 += 24;
            v7 += 3;
            if (v4 == v5) {
              return result;
            }
          }
          return 0;
        }
        return 1;
      }
      return 0;
    }
    if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
      return 0;
    }
    uint64_t v9 = *(void *)(a1 + 24);
    uint64_t v10 = *(void *)(a2 + 24);
    if (v9 == v10) {
      return 1;
    }
    BOOL result = 0;
    if (v9 && v10)
    {
      if (*(unsigned char *)(v9 + 40)) {
        CPIndexSetNormalize(v9);
      }
      uint64_t v11 = *(void *)(v9 + 16);
      if (*(unsigned char *)(v10 + 40)) {
        CPIndexSetNormalize(v10);
      }
      if (*(void *)(v10 + 16) != v11) {
        return 0;
      }
      uint64_t v12 = v11 - 1;
      if (v11 < 1) {
        return 1;
      }
      uint64_t v13 = 0;
      do
      {
        uint64_t Range = CPIndexSetGetRange(v9, v13);
        uint64_t v16 = v15;
        BOOL result = Range == CPIndexSetGetRange(v10, v13) && v16 == v17;
      }
      while (result && v12 != v13++);
    }
  }
  return result;
}

uint64_t CGPDFSelectionGetContainingNode(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!a1) {
    goto LABEL_14;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 != -1) {
    goto LABEL_13;
  }
  uint64_t v4 = (uint64_t *)CGPDFPageCopyLayout(*(void *)(a1 + 16));
  if (!v4)
  {
LABEL_14:
    uint64_t v3 = -1;
    goto LABEL_13;
  }
  uint64_t v5 = v4;
  uint64_t v6 = v4[13];
  uint64_t v7 = *(void *)(a1 + 184);
  uint64_t v8 = *(void *)(a1 + 192) - v7;
  if (v8 < 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = v8 / 24;
    uint64_t v12 = (uint64_t *)(v7 + 16);
    do
    {
      uint64_t v9 = CPRangeUnion(v9, v10, *(v12 - 1), *v12);
      uint64_t v10 = v13;
      v12 += 3;
      --v11;
    }
    while (v11);
  }
  NodeContainingTextuint64_t Range = CGPDFNodeGetNodeContainingTextRange(v6, v9, v10);
  if (NodeContainingTextRange) {
    uint64_t v15 = NodeContainingTextRange;
  }
  else {
    uint64_t v15 = -1;
  }
  *(void *)(a1 + 40) = v15;
  CFRelease(v5);
  uint64_t v3 = *(void *)(a1 + 40);
LABEL_13:
  pthread_mutex_unlock(v2);
  return v3;
}

BOOL CGPDFSelectionGetContentRect(uint64_t a1)
{
  return a1 != 0;
}

uint64_t *CGPDFSelectionIsWord(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = result[23];
    uint64_t v2 = result[24];
    if (v2 - v1 == 24)
    {
      if (v2 == v1)
      {
        uint64_t v4 = 0;
        unint64_t v3 = -1;
      }
      else
      {
        unint64_t v3 = *(void *)(v1 + 8);
        uint64_t v4 = *(void *)(v1 + 16);
      }
      CGPDFPageCopyPageLayoutWithCTLD(result[21], 1);
      uint64_t v6 = (const void *)v5;
      uint64_t v7 = (void *)(v5 + 16);
      LineIndedouble x = PageLayout::getLineIndex(*(PageLayout **)(v5 + 48), *(PageLayout **)(v5 + 56), v3);
      Worduint64_t Range = PageLayout::getWordRange(v7, LineIndex, v3);
      uint64_t v11 = v10;
      CFRelease(v6);
      return (uint64_t *)((void *)v3 == WordRange && v4 == v11);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_18504DBF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t CGPDFSelectionIsStandaloneGraphic()
{
  return 0;
}

BOOL CGPDFSelectionIsWithinLayout(uint64_t a1)
{
  return a1 != 0;
}

uint64_t CGPDFSelectionIsWithinParagraph(uint64_t a1)
{
  CFTypeRef v2 = CGPDFPageCopyLayout(*(void *)(a1 + 16));
  ContainingNode = (_DWORD *)CGPDFSelectionGetContainingNode(a1);
  if (!ContainingNode || (uint64_t v4 = 0, (*ContainingNode - 515) >= 3) && *ContainingNode != 1538) {
    uint64_t v4 = 1;
  }
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

void sub_18504DC98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void *CGTriangleMeshCreate(void *a1, const void *a2)
{
  uint64_t v4 = malloc_type_malloc(0x58uLL, 0x2062DE7BuLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *(_DWORD *)uint64_t v4 = 1;
    if (a1)
    {
      CFRetain(a1);
      v5[2] = a1;
      if (!a2)
      {
        v5[3] = 0;
        uint64_t v6 = *(void *)(a1[3] + 48);
LABEL_7:
        v5[1] = v6;
        v5[4] = 8 * v6 + 16;
        *(_OWORD *)(v5 + 5) = 0u;
        *(_OWORD *)(v5 + 7) = 0u;
        *(_OWORD *)(v5 + 9) = 0u;
        return v5;
      }
    }
    else
    {
      v4[2] = 0;
      if (!a2)
      {
        uint64_t v6 = 0;
        v4[3] = 0;
        goto LABEL_7;
      }
    }
    CFRetain(a2);
    v5[3] = a2;
    uint64_t v6 = 1;
    goto LABEL_7;
  }
  return v5;
}

atomic_uint *CGTriangleMeshRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

void CGTriangleMeshRelease(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 16));
    CFTypeRef v2 = *(const void **)(a1 + 24);
    if (v2) {
      CFRelease(v2);
    }
    free(*(void **)(a1 + 56));
    free(*(void **)(a1 + 80));
    free((void *)a1);
  }
}

uint64_t CGTriangleMeshGetColorSpace(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t CGTriangleMeshGetNumberOfComponents(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t CGTriangleMeshAddTriangle(uint64_t result, float64x2_t *a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    if (a3)
    {
      if (a4)
      {
        uint64_t v7 = result;
        BOOL result = (uint64_t)add_triangle(result);
        if (result)
        {
          uint64_t v8 = result;
          uint64_t v9 = 0;
          uint64_t v10 = (float64_t *)(a3 + 8);
          do
          {
            BOOL result = add_point(v7, a2, (uint64_t *)(a4 + 8 * *(void *)(v7 + 8) * v9), *(v10 - 1), *v10);
            *(void *)(v8 + 8 * v9++) = result;
            v10 += 2;
          }
          while (v9 != 3);
        }
      }
    }
  }
  return result;
}

char *add_triangle(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2 == *(void *)(a1 + 64))
  {
    uint64_t v3 = 2 * v2 + 6;
    BOOL result = (char *)malloc_type_realloc(*(void **)(a1 + 80), 24 * v3, 0x7492344AuLL);
    if (!result) {
      return result;
    }
    *(void *)(a1 + 80) = result;
    *(void *)(a1 + 64) = v3;
    uint64_t v2 = *(void *)(a1 + 72);
  }
  else
  {
    BOOL result = *(char **)(a1 + 80);
  }
  *(void *)(a1 + 72) = v2 + 1;
  result += 24 * v2;
  return result;
}

uint64_t add_point(uint64_t a1, float64x2_t *a2, uint64_t *a3, float64_t a4, float64_t a5)
{
  if (!a3) {
    return -1;
  }
  uint64_t v5 = a3;
  uint64_t result = *(void *)(a1 + 40);
  if (result == *(void *)(a1 + 48))
  {
    double v17 = a5;
    double v18 = a4;
    uint64_t v9 = 2 * result + 18;
    uint64_t v10 = (char *)malloc_type_realloc(*(void **)(a1 + 56), *(void *)(a1 + 32) * v9, 0x7492344AuLL);
    if (!v10) {
      return -1;
    }
    uint64_t v11 = v10;
    *(void *)(a1 + 48) = v9;
    *(void *)(a1 + 56) = v10;
    uint64_t result = *(void *)(a1 + 40);
    a5 = v17;
    a4 = v18;
  }
  else
  {
    uint64_t v11 = *(char **)(a1 + 56);
  }
  *(void *)(a1 + 40) = result + 1;
  uint64_t v12 = *(void *)(a1 + 32) * result;
  v13.f64[0] = a4;
  v13.f64[1] = a5;
  if (a2) {
    float64x2_t v13 = vaddq_f64(a2[2], vmlaq_n_f64(vmulq_laneq_f64(a2[1], v13, 1), *a2, a4));
  }
  *(float64x2_t *)&v11[v12] = v13;
  uint64_t v14 = *(void *)(a1 + 8);
  if (v14)
  {
    uint64_t v15 = &v11[v12 + 16];
    do
    {
      uint64_t v16 = *v5++;
      *(void *)uint64_t v15 = v16;
      v15 += 8;
      --v14;
    }
    while (v14);
  }
  return result;
}

uint64_t CGTriangleMeshAddTriangleWithTrianglePoints(uint64_t result, float64x2_t *a2, uint64_t a3)
{
  if (result)
  {
    if (a3)
    {
      uint64_t v5 = result;
      uint64_t result = (uint64_t)add_triangle(result);
      if (result)
      {
        uint64_t v6 = result;
        for (uint64_t i = 0; i != 24; i += 8)
        {
          uint64_t result = add_point(v5, a2, (uint64_t *)(*(void *)(a3 + i) + 16), **(float64_t **)(a3 + i), *(float64_t *)(*(void *)(a3 + i) + 8));
          *(void *)(v6 + i) = result;
        }
      }
    }
  }
  return result;
}

void *CGTriangleMeshAddTriangleWithRelativePoint(void *result, float64x2_t *a2, int a3, uint64_t *a4, float64_t a5, float64_t a6)
{
  if (result)
  {
    if (a4)
    {
      uint64_t v7 = (uint64_t)result;
      uint64_t v8 = result[9];
      if (v8)
      {
        uint64_t result = add_triangle((uint64_t)result);
        if (result)
        {
          float64x2_t v13 = result;
          uint64_t v14 = *(void *)(v7 + 80) + 24 * v8 - 24;
          uint64_t v15 = (void *)v14;
          if (a3 != 1)
          {
            if (a3) {
              return result;
            }
            uint64_t v15 = (void *)(*(void *)(v7 + 80) + 24 * v8 - 16);
          }
          char *result = *v15;
          result[1] = *(void *)(v14 + 16);
          uint64_t result = (void *)add_point(v7, a2, a4, a5, a6);
          v13[2] = result;
        }
      }
    }
  }
  return result;
}

uint64_t CGTriangleMeshGetCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 72);
  }
  return result;
}

void *CGTriangleMeshGetTriangleAtIndex(void *result, unint64_t a2, uint64_t a3)
{
  if (result && a3 && result[9] > a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = result[10] + 24 * a2;
    uint64_t v5 = result[4];
    do
    {
      *(void *)(a3 + v3) = result[7] + v5 * *(void *)(v4 + v3);
      v3 += 8;
    }
    while (v3 != 24);
  }
  return result;
}

uint64_t CGTriangleMeshPrint(uint64_t a1, FILE *a2)
{
  fprintf(a2, "mesh %p: colorspace %p ; function %p\n",
    (const void *)a1,
    *(const void **)(a1 + 16),
    *(const void **)(a1 + 24));
  fprintf(a2, "  point size: %zu\n", *(void *)(a1 + 32));
  fprintf(a2, "  point count: %zu\n", *(void *)(a1 + 40));
  if (*(void *)(a1 + 40))
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = (double *)(*(void *)(a1 + 56) + *(void *)(a1 + 32) * v4);
      fprintf(a2, "    point %zu: (%g, %g)(", v4, *v5, v5[1]);
      if (*(void *)(a1 + 8))
      {
        unint64_t v6 = 0;
        uint64_t v7 = v5 + 2;
        do
          fprintf(a2, "%g ", v7[v6++]);
        while (v6 < *(void *)(a1 + 8));
      }
      fwrite(")\n", 2uLL, 1uLL, a2);
      ++v4;
    }
    while (v4 < *(void *)(a1 + 40));
  }
  uint64_t result = fprintf(a2, "  triangle count: %zu\n", *(void *)(a1 + 72));
  if (*(void *)(a1 + 72))
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      uint64_t result = fprintf(a2, "    triangle %zu: (%zu, %zu, %zu)\n", v10++, *(void *)(*(void *)(a1 + 80) + v9), *(void *)(*(void *)(a1 + 80) + v9 + 8), *(void *)(*(void *)(a1 + 80) + v9 + 16));
      v9 += 24;
    }
    while (v10 < *(void *)(a1 + 72));
  }
  return result;
}

uint64_t CGGetMD5DigestOfBytes(unsigned __int8 *a1, char *a2, unint64_t a3)
{
  memset(&v7, 0, sizeof(v7));
  CC_MD5_Init(&v7);
  md5_update(&v7, a2, a3);
  return CC_MD5_Final(a1, &v7);
}

CC_MD5_CTX *CGDigesterCreateMD5()
{
  v0 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
  CC_MD5_Init(v0);
  return v0;
}

CC_MD5_CTX *CGDigesterAddBytes(CC_MD5_CTX *c, char *data, unint64_t a3)
{
  if (c) {
    return md5_update(c, data, a3);
  }
  return c;
}

CC_MD5_CTX *CGDigesterGetDigest(CC_MD5_CTX *c, unsigned __int8 *md)
{
  if (c) {
    return (CC_MD5_CTX *)CC_MD5_Final(md, c);
  }
  return c;
}

xmlChar *CG::DisplayListXMLHelper::parseAttributesFromNode(xmlChar *this, _xmlNode *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = this + 8;
  properties = a2->properties;
  if (properties)
  {
    unint64_t v4 = (uint64_t **)this;
    uint64_t v5 = (uint64_t (**)(xmlChar *))MEMORY[0x1E4FBA9D0];
    do
    {
      this = xmlNodeListGetString(a2->doc, properties->children, 1);
      unint64_t v6 = this;
      if (this)
      {
        std::string::basic_string[abi:fe180100]<0>(v11, (char *)this);
        std::string::basic_string[abi:fe180100]<0>(__p, (char *)properties->name);
        float64x2_t v13 = __p;
        CC_MD5_CTX v7 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v4, __p, (_OWORD **)&v13);
        uint64_t v8 = (char *)v7 + 56;
        if (*((char *)v7 + 79) < 0) {
          operator delete(*(void **)v8);
        }
        *(_OWORD *)uint64_t v8 = *(_OWORD *)v11;
        *((void *)v8 + 2) = v12;
        HIBYTE(v12) = 0;
        LOBYTE(v11[0]) = 0;
        if (v10 < 0)
        {
          operator delete(__p[0]);
          if (SHIBYTE(v12) < 0) {
            operator delete(v11[0]);
          }
        }
        this = (xmlChar *)(*v5)(v6);
      }
      properties = properties->next;
    }
    while (properties);
  }
  return this;
}

void sub_18504E5D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*v21);
  _Unwind_Resume(a1);
}

_OWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void *a2, _OWORD **a3)
{
  uint64_t v5 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v13, a2);
  unint64_t v6 = *v5;
  if (!*v5)
  {
    CC_MD5_CTX v7 = (uint64_t **)v5;
    unint64_t v6 = operator new(0x50uLL);
    v11[1] = a1 + 1;
    uint64_t v8 = *a3;
    uint64_t v9 = *((void *)*a3 + 2);
    void v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    *uint64_t v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    *((void *)v6 + 8) = 0;
    *((void *)v6 + 9) = 0;
    *((void *)v6 + 7) = 0;
    char v12 = 1;
    std::__tree<unsigned long>::__insert_node_at(a1, v13, v7, (uint64_t *)v6);
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:fe180100]((uint64_t)v11);
  }
  return v6;
}

uint64_t CG::DisplayListXMLHelper::parseFormatFromAttributes(uint64_t a1, char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::string::basic_string[abi:fe180100]<0>(__p, a2);
  uint64_t v11 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, __p);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if ((void *)(a1 + 8) == v11) {
    return 0;
  }
  __p[0] = &a9;
  char v12 = (const char *)(v11 + 7);
  if (*((char *)v11 + 79) < 0) {
    char v12 = *(const char **)v12;
  }
  return vsscanf(v12, a3, (va_list)__p[0]);
}

void *CG::DisplayListXMLHelper::parseStringFromAttributes(uint64_t a1, char *a2)
{
  std::string::basic_string[abi:fe180100]<0>(__p, a2);
  uint64_t v3 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if ((void *)(a1 + 8) == v3) {
    return 0;
  }
  uint64_t result = v3 + 7;
  if (*((char *)v3 + 79) < 0) {
    return (void *)*result;
  }
  return result;
}

uint64_t CG::DisplayListXMLHelper::parseBoolFromAttributes(uint64_t a1, char *a2, char *a3)
{
  std::string::basic_string[abi:fe180100]<0>(&__p, a2);
  uint64_t v5 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, &__p);
  if ((char)v38 < 0) {
    operator delete(__p);
  }
  if ((void *)(a1 + 8) == v5) {
    return 0;
  }
  char v6 = (const void **)(v5 + 7);
  std::string::basic_string[abi:fe180100]<0>(&__p, "true");
  uint64_t v7 = *((unsigned __int8 *)v5 + 79);
  if ((v7 & 0x80u) == 0) {
    uint64_t v8 = *((unsigned __int8 *)v5 + 79);
  }
  else {
    uint64_t v8 = v5[8];
  }
  uint64_t v9 = v38;
  int v10 = (char)v38;
  if ((v38 & 0x80u) != 0) {
    uint64_t v9 = v37;
  }
  if (v8 != v9)
  {
    BOOL v20 = 0;
    if (((char)v38 & 0x80000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_30;
  }
  if ((v38 & 0x80u) == 0) {
    p_p = (unsigned __int8 *)&__p;
  }
  else {
    p_p = (unsigned __int8 *)__p;
  }
  if ((v7 & 0x80) != 0)
  {
    BOOL v20 = memcmp(*v6, p_p, v5[8]) == 0;
    goto LABEL_26;
  }
  if (*((unsigned char *)v5 + 79))
  {
    uint64_t v12 = v7 - 1;
    uint64_t v13 = (unsigned __int8 *)(v5 + 7);
    do
    {
      int v15 = *v13++;
      int v14 = v15;
      int v17 = *p_p++;
      int v16 = v17;
      BOOL v18 = v12-- != 0;
      char v19 = v18;
      BOOL v20 = v14 == v16;
    }
    while (v14 == v16 && (v19 & 1) != 0);
LABEL_26:
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_27;
    }
LABEL_30:
    operator delete(__p);
    if (v20) {
      goto LABEL_28;
    }
LABEL_31:
    std::string::basic_string[abi:fe180100]<0>(&__p, "false");
    uint64_t v23 = *((unsigned __int8 *)v5 + 79);
    size_t v24 = v5[8];
    if ((v23 & 0x80u) == 0) {
      uint64_t v25 = *((unsigned __int8 *)v5 + 79);
    }
    else {
      uint64_t v25 = v5[8];
    }
    uint64_t v26 = v38;
    int v27 = (char)v38;
    if ((v38 & 0x80u) != 0) {
      uint64_t v26 = v37;
    }
    if (v25 == v26)
    {
      if ((v38 & 0x80u) == 0) {
        unint64_t v28 = (unsigned __int8 *)&__p;
      }
      else {
        unint64_t v28 = (unsigned __int8 *)__p;
      }
      if ((v23 & 0x80) != 0)
      {
        BOOL v35 = memcmp(*v6, v28, v24) == 0;
        goto LABEL_52;
      }
      if (v23)
      {
        uint64_t v29 = v23 - 1;
        do
        {
          int v31 = *(unsigned __int8 *)v6;
          char v6 = (const void **)((char *)v6 + 1);
          int v30 = v31;
          int v33 = *v28++;
          int v32 = v33;
          BOOL v18 = v29-- != 0;
          char v34 = v18;
          BOOL v35 = v30 == v32;
        }
        while (v30 == v32 && (v34 & 1) != 0);
LABEL_52:
        if ((v27 & 0x80000000) == 0) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }
      BOOL v35 = 1;
      if (((char)v38 & 0x80000000) == 0)
      {
LABEL_54:
        char v22 = 0;
        uint64_t result = 0;
        if (!v35) {
          return result;
        }
        goto LABEL_55;
      }
    }
    else
    {
      BOOL v35 = 0;
      if (((char)v38 & 0x80000000) == 0) {
        goto LABEL_54;
      }
    }
LABEL_53:
    operator delete(__p);
    goto LABEL_54;
  }
  BOOL v20 = 1;
  if ((char)v38 < 0) {
    goto LABEL_30;
  }
LABEL_27:
  if (!v20) {
    goto LABEL_31;
  }
LABEL_28:
  char v22 = 1;
LABEL_55:
  *a3 = v22;
  return 1;
}

BOOL CG::DisplayListXMLHelper::parsePointFromAttributes(uint64_t a1, char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = 0;
  uint64_t v9 = CG::DisplayListXMLHelper::parseFormatFromAttributes(a1, a2, "{%lg, %lg}", a4, a5, a6, a7, a8, (uint64_t)&v11);
  if (v9)
  {
    *a3 = v11;
    a3[1] = 0;
  }
  return v9 != 0;
}

uint64_t CG::DisplayListXMLHelper::parseRectFromAttributes(uint64_t a1, char *a2, uint64_t a3)
{
  std::string::basic_string[abi:fe180100]<0>(__p, a2);
  char v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, __p);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if ((void *)(a1 + 8) == v6) {
    return 0;
  }
  uint64_t v7 = (const char *)(v6 + 7);
  if (*((char *)v6 + 79) < 0) {
    uint64_t v7 = *(const char **)v7;
  }
  if (!strcmp(v7, "rectNull"))
  {
    int v15 = &CGRectNull;
LABEL_14:
    CGSize size = v15->size;
    *(CGPoint *)a3 = v15->origin;
    *(CGSize *)(a3 + 16) = size;
    return 1;
  }
  if (!strcmp(v7, "rectInfinite"))
  {
    int v15 = &CGRectInfinite;
    goto LABEL_14;
  }
  __p[0] = 0;
  BOOL v13 = CG::DisplayListXMLHelper::parseFormatFromAttributes(a1, a2, "{%lg, %lg}, {%lg, %lg}", v8, v9, v10, v11, v12, (uint64_t)__p) == 4;
  uint64_t result = v13;
  if (v13)
  {
    *(void **)a3 = __p[0];
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
  }
  return result;
}

BOOL CG::DisplayListXMLHelper::parseAffineTransformFromAttributes(uint64_t a1, char *a2, uint64_t a3)
{
  std::string::basic_string[abi:fe180100]<0>(v14, a2);
  uint64_t v11 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, v14);
  if (v15 < 0) {
    operator delete(v14[0]);
  }
  if ((void *)(a1 + 8) == v11) {
    return 0;
  }
  v14[0] = 0;
  BOOL v12 = CG::DisplayListXMLHelper::parseFormatFromAttributes(a1, a2, "[%lg %lg %lg %lg %lg %lg]", v6, v7, v8, v9, v10, (uint64_t)v14) == 6;
  BOOL result = v12;
  if (v12)
  {
    *(void **)a3 = v14[0];
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0;
  }
  return result;
}

unint64_t CG::DisplayListXMLHelper::parseColorComponentsFromAttributes(uint64_t a1, uint64_t a2)
{
  std::string::basic_string[abi:fe180100]<0>(__p, "components");
  unint64_t v4 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, __p);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  if ((void *)(a1 + 8) == v4) {
    return 0;
  }
  boost::char_separator<char,std::char_traits<char>>::char_separator((uint64_t)&v32, "() ");
  boost::tokenizer<boost::char_separator<char,std::char_traits<char>>,std::__wrap_iter<char const*>,std::string>::tokenizer<std::string>((uint64_t)v27, v4 + 7, &v32);
  boost::tokenizer<boost::char_separator<char,std::char_traits<char>>,std::__wrap_iter<char const*>,std::string>::begin((uint64_t)__p, (uint64_t)v27);
  for (unint64_t i = 0; ; ++i)
  {
    boost::tokenizer<boost::char_separator<char,std::char_traits<char>>,std::__wrap_iter<char const*>,std::string>::end((uint64_t)&v10, (uint64_t)v27);
    if (!v16 || !v25)
    {
      BOOL v7 = v16 == v25;
      goto LABEL_10;
    }
    if (v14 == v23)
    {
      BOOL v7 = v15 == v24;
LABEL_10:
      int v6 = v7;
      goto LABEL_13;
    }
    int v6 = 0;
LABEL_13:
    if (i > 5) {
      int v8 = 1;
    }
    else {
      int v8 = v6;
    }
    if (v18 < 0) {
      operator delete(v17);
    }
    if (v13 < 0) {
      operator delete(v12);
    }
    if (v11 < 0) {
      operator delete(v10);
    }
    if (v8) {
      break;
    }
    if (!v25) {
      __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
    }
    *(double *)(a2 + 8 * i) = std::stod(&v26, 0);
    boost::token_iterator<boost::char_separator<char,std::char_traits<char>>,std::__wrap_iter<char const*>,std::string>::increment((uint64_t)__p);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  if (v31 < 0) {
    operator delete(v30);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (v35 < 0) {
    operator delete(v34);
  }
  if (v33 < 0) {
    operator delete((void *)v32);
  }
  return i;
}

void sub_18504EECC(_Unwind_Exception *a1)
{
  boost::tokenizer<boost::char_separator<char,std::char_traits<char>>,std::__wrap_iter<char const*>,std::string>::~tokenizer(v1 - 192);
  boost::char_separator<char,std::char_traits<char>>::~char_separator(v1 - 112);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CG20DisplayListXMLHelper37parseCompositeOperationFromAttributesERKNSt3__13mapINS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEES8_NS1_4lessIS8_EENS6_INS1_4pairIKS8_S8_EEEEEEPKcR20CGCompositeOperation_block_invoke(uint64_t a1, const char **a2, const char **a3)
{
  return strcmp(*a2, *a3);
}

BOOL CG::DisplayListXMLHelper::parseColorRenderingIntentFromAttributes(uint64_t a1, char *a2, _DWORD *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:fe180100]<0>(&__p, a2);
  uint64_t v5 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, &__p);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  if ((void *)(a1 + 8) == v5)
  {
    return 0;
  }
  else
  {
    __p = "default";
    char v13 = "absColormetric";
    int v14 = 1;
    uint64_t v15 = "relColormetric";
    int v16 = 2;
    int v17 = "perceptual";
    int v18 = 3;
    int v12 = 0;
    char v19 = "saturation";
    int v20 = 4;
    int v6 = (const char *)(v5 + 7);
    if (*((char *)v5 + 79) < 0) {
      int v6 = *(const char **)v6;
    }
    unint64_t v7 = 0;
    BOOL v8 = 1;
    for (unint64_t i = &__p; strcmp(v6, (const char *)*i); i += 2)
    {
      BOOL v8 = v7 < 4;
      if (++v7 == 5) {
        return 0;
      }
    }
    *a3 = *((_DWORD *)&__p + 4 * v7 + 2);
  }
  return v8;
}

BOOL CG::DisplayListXMLHelper::parseInterpolationQualityFromAttributes(uint64_t a1, char *a2, _DWORD *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:fe180100]<0>(&__p, a2);
  uint64_t v5 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, &__p);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  if ((void *)(a1 + 8) == v5)
  {
    return 0;
  }
  else
  {
    __p = "default";
    char v13 = "none";
    int v14 = 1;
    uint64_t v15 = "low";
    int v16 = 2;
    int v17 = "medium";
    int v18 = 4;
    int v12 = 0;
    char v19 = "high";
    int v20 = 3;
    int v6 = (const char *)(v5 + 7);
    if (*((char *)v5 + 79) < 0) {
      int v6 = *(const char **)v6;
    }
    unint64_t v7 = 0;
    BOOL v8 = 1;
    for (unint64_t i = &__p; strcmp(v6, (const char *)*i); i += 2)
    {
      BOOL v8 = v7 < 4;
      if (++v7 == 5) {
        return 0;
      }
    }
    *a3 = *((_DWORD *)&__p + 4 * v7 + 2);
  }
  return v8;
}

BOOL CG::DisplayListXMLHelper::parseTextDrawingModeFromAttributes(uint64_t a1, _DWORD *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:fe180100]<0>(&__p, "textDrawingMode");
  unint64_t v4 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, &__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p);
  }
  if ((void *)(a1 + 8) == v4)
  {
    return 0;
  }
  else
  {
    __p = "fill";
    int v12 = "stroke";
    int v13 = 1;
    int v14 = "fillStroke";
    int v15 = 2;
    int v16 = "invisible";
    int v17 = 3;
    int v18 = "fillCLip";
    int v19 = 4;
    int v20 = "strokeClip";
    int v21 = 5;
    char v22 = "fillStrokeClip";
    int v23 = 6;
    int v11 = 0;
    uint64_t v24 = "clip";
    int v25 = 7;
    uint64_t v5 = (const char *)(v4 + 7);
    if (*((char *)v4 + 79) < 0) {
      uint64_t v5 = *(const char **)v5;
    }
    unint64_t v6 = 0;
    BOOL v7 = 1;
    for (unint64_t i = &__p; strcmp(v5, (const char *)*i); i += 2)
    {
      BOOL v7 = v6 < 7;
      if (++v6 == 8) {
        return 0;
      }
    }
    *a2 = *((_DWORD *)&__p + 4 * v6 + 2);
  }
  return v7;
}

BOOL CG::DisplayListXMLHelper::parsePathDrawingModeFromAttributes(uint64_t a1, _DWORD *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:fe180100]<0>(&__p, "drawingMode");
  unint64_t v4 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::find<std::string>(a1, &__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p);
  }
  if ((void *)(a1 + 8) == v4)
  {
    return 0;
  }
  else
  {
    __p = "fill";
    int v12 = "eofill";
    int v13 = 1;
    int v14 = "stroke";
    int v15 = 2;
    int v16 = "fillStroke";
    int v17 = 3;
    int v11 = 0;
    int v18 = "eoFillStroke";
    int v19 = 4;
    uint64_t v5 = (const char *)(v4 + 7);
    if (*((char *)v4 + 79) < 0) {
      uint64_t v5 = *(const char **)v5;
    }
    unint64_t v6 = 0;
    BOOL v7 = 1;
    for (unint64_t i = &__p; strcmp(v5, (const char *)*i); i += 2)
    {
      BOOL v7 = v6 < 4;
      if (++v6 == 5) {
        return 0;
      }
    }
    *a2 = *((_DWORD *)&__p + 4 * v6 + 2);
  }
  return v7;
}

uint64_t CG::DisplayListXMLHelper::parseCGPathFromNode(CG::DisplayListXMLHelper *this, _xmlNode *a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (!v2 || *(_DWORD *)(v2 + 8) != 3) {
    return 0;
  }
  uint64_t String = (uint64_t)xmlNodeListGetString(*(xmlDocPtr *)(v2 + 64), (const xmlNode *)v2, 1);
  if (String)
  {
    id v4 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    uint64_t v5 = [NSString stringWithUTF8String:String];
    CFDataRef v6 = (const __CFData *)[v4 initWithBase64EncodedString:v5 options:1];

    uint64_t String = CGPathCreateWithData(v6);
  }
  return String;
}

void sub_18504F59C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CG::DisplayListXMLHelper::parseCGFloatArrayFromElement(uint64_t a1, xmlChar *str2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      while (xmlStrcmp(*(const xmlChar **)(v3 + 16), str2))
      {
        uint64_t v3 = *(void *)(v3 + 48);
        if (!v3) {
          return;
        }
      }
      for (uint64_t i = *(void *)(v3 + 24); i; uint64_t i = *(void *)(i + 48))
      {
        if (*(_DWORD *)(i + 8) == 1 && !xmlStrcmp(*(const xmlChar **)(i + 16), (const xmlChar *)"mem"))
        {
          uint64_t String = xmlNodeListGetString(*(xmlDocPtr *)(i + 64), *(const xmlNode **)(i + 24), 1);
          if (String)
          {
            double v8 = atof((const char *)String);
            double v9 = v8;
            int v11 = *(double **)(a3 + 8);
            unint64_t v10 = *(void *)(a3 + 16);
            if ((unint64_t)v11 >= v10)
            {
              int v13 = *(double **)a3;
              uint64_t v14 = ((uint64_t)v11 - *(void *)a3) >> 3;
              unint64_t v15 = v14 + 1;
              if ((unint64_t)(v14 + 1) >> 61) {
                std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
              }
              uint64_t v16 = v10 - (void)v13;
              if (v16 >> 2 > v15) {
                unint64_t v15 = v16 >> 2;
              }
              if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v17 = v15;
              }
              if (v17)
              {
                unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v17);
                int v13 = *(double **)a3;
                int v11 = *(double **)(a3 + 8);
              }
              else
              {
                uint64_t v18 = 0;
              }
              int v19 = (double *)(v17 + 8 * v14);
              *int v19 = v9;
              int v12 = v19 + 1;
              while (v11 != v13)
              {
                uint64_t v20 = *((void *)v11-- - 1);
                *((void *)v19-- - 1) = v20;
              }
              *(void *)a3 = v19;
              *(void *)(a3 + 8) = v12;
              *(void *)(a3 + 16) = v17 + 8 * v18;
              if (v13) {
                operator delete(v13);
              }
            }
            else
            {
              *int v11 = v8;
              int v12 = v11 + 1;
            }
            *(void *)(a3 + 8) = v12;
          }
        }
      }
    }
  }
}

void CG::DisplayListXMLHelper::addStringToAttributes(uint64_t **a1, char *a2, char *__s)
{
  std::string::basic_string[abi:fe180100]<0>(v9, __s);
  std::string::basic_string[abi:fe180100]<0>(__p, a2);
  int v11 = __p;
  uint64_t v5 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p, (_OWORD **)&v11);
  CFDataRef v6 = (char *)v5 + 56;
  if (*((char *)v5 + 79) < 0) {
    operator delete(*(void **)v6);
  }
  *(_OWORD *)CFDataRef v6 = *(_OWORD *)v9;
  *((void *)v6 + 2) = v10;
  HIBYTE(v10) = 0;
  LOBYTE(v9[0]) = 0;
  if (v8 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v10) < 0) {
      operator delete(v9[0]);
    }
  }
}

void sub_18504F7C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void CG::DisplayListXMLHelper::addFormatToAttributes(uint64_t **a1, char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v21 = &a9;
  int v12 = vsnprintf(0, 0, a3, &a9) + 1;
  uint64_t v24 = 0;
  if (v12 >= 0x101) {
    operator new[]();
  }
  int v21 = &a9;
  vsnprintf(v23, v12, a3, &a9);
  int v13 = v24;
  if (v24) {
    uint64_t v14 = v24;
  }
  else {
    uint64_t v14 = v23;
  }
  std::string::basic_string[abi:fe180100]<0>(v19, v14);
  std::string::basic_string[abi:fe180100]<0>(__p, a2);
  char v22 = __p;
  unint64_t v15 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p, (_OWORD **)&v22);
  uint64_t v16 = (char *)v15 + 56;
  if (*((char *)v15 + 79) < 0) {
    operator delete(*(void **)v16);
  }
  *(_OWORD *)uint64_t v16 = *(_OWORD *)v19;
  *((void *)v16 + 2) = v20;
  HIBYTE(v20) = 0;
  LOBYTE(v19[0]) = 0;
  if (v18 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[0]);
    }
  }
  if (v13) {
    MEMORY[0x18532A2A0](v13, 0x1000C4077774924);
  }
}

void sub_18504F974(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void CG::DisplayListXMLHelper::addBoolToAttributes(uint64_t **a1, char *a2, int a3)
{
  if (a3) {
    uint64_t v5 = "true";
  }
  else {
    uint64_t v5 = "false";
  }
  std::string::basic_string[abi:fe180100]<0>(v10, v5);
  std::string::basic_string[abi:fe180100]<0>(__p, a2);
  int v12 = __p;
  CFDataRef v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(a1, __p, (_OWORD **)&v12);
  BOOL v7 = (char *)v6 + 56;
  if (*((char *)v6 + 79) < 0) {
    operator delete(*(void **)v7);
  }
  *(_OWORD *)BOOL v7 = *(_OWORD *)v10;
  *((void *)v7 + 2) = v11;
  HIBYTE(v11) = 0;
  LOBYTE(v10[0]) = 0;
  if (v9 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v11) < 0) {
      operator delete(v10[0]);
    }
  }
}

void sub_18504FA98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void CG::DisplayListXMLHelper::addRectToAttributes(uint64_t **a1, char *a2, float64x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float64x2_t v8 = *a3;
  if (a3->f64[0] == INFINITY || a3->f64[1] == INFINITY)
  {
    uint64_t v10 = "rectNull";
  }
  else
  {
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v8, (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL)), (int32x4_t)vceqq_f64(a3[1], (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL)))))))
    {
      CG::DisplayListXMLHelper::addFormatToAttributes(a1, a2, "{%.17lg, %.17lg}, {%.17lg, %.17lg}", a4, a5, a6, a7, a8, SLOBYTE(v8.f64[0]));
      return;
    }
    uint64_t v10 = "rectInfinite";
  }

  CG::DisplayListXMLHelper::addStringToAttributes(a1, a2, v10);
}

void CG::DisplayListXMLHelper::appendFormatToString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_18504FC40(_Unwind_Exception *a1)
{
  MEMORY[0x18532A280](v1, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void CG::DisplayListXMLHelper::writeAttributes(void *a1, xmlTextWriterPtr writer)
{
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      if (*((char *)v3 + 55) < 0) {
        std::string::__init_copy_ctor_external(&v11, (const std::string::value_type *)v3[4], v3[5]);
      }
      else {
        std::string v11 = *(std::string *)(v3 + 4);
      }
      if (*((char *)v3 + 79) < 0) {
        std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v3[7], v3[8]);
      }
      else {
        std::string __p = *(std::string *)(v3 + 7);
      }
      if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v5 = &v11;
      }
      else {
        uint64_t v5 = (std::string *)v11.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      xmlTextWriterWriteAttribute(writer, (const xmlChar *)v5, (const xmlChar *)p_p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v11.__r_.__value_.__l.__data_);
      }
      BOOL v7 = (void *)v3[1];
      if (v7)
      {
        do
        {
          float64x2_t v8 = v7;
          BOOL v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          float64x2_t v8 = (void *)v3[2];
          BOOL v9 = *v8 == (void)v3;
          uint64_t v3 = v8;
        }
        while (!v9);
      }
      uint64_t v3 = v8;
    }
    while (v8 != v2);
  }
}

void sub_18504FD8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL CG::DisplayListXMLHelper::writeCGPath(CG::DisplayListXMLHelper *this, const CGPath *a2, _xmlTextWriter *a3)
{
  BOOL v3 = 0;
  if (this && a2)
  {
    CFMutableDataRef EncodedData = CGPathCreateEncodedData(this, 0);
    if (EncodedData)
    {
      CFMutableDataRef v6 = EncodedData;
      BOOL v7 = [(__CFData *)EncodedData base64EncodedStringWithOptions:33];
      float64x2_t v8 = v7;
      if (v7) {
        BOOL v3 = xmlTextWriterWriteRaw(a2, (const xmlChar *)[v7 UTF8String]) >= 0;
      }
      else {
        BOOL v3 = 0;
      }

      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_18504FE6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  applesauce::CF::ObjectRef<__CFData const*>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL CG::DisplayListXMLHelper::writeCGFloatArray(xmlChar *name, double **a2, xmlTextWriterPtr writer)
{
  int started = xmlTextWriterStartElement(writer, name);
  if ((started & 0x80000000) == 0)
  {
    CFMutableDataRef v6 = *a2;
    BOOL v7 = a2[1];
    if (*a2 != v7)
    {
      do
      {
        double v8 = *v6;
        if ((xmlTextWriterStartElement(writer, (const xmlChar *)"mem") & 0x80000000) == 0)
        {
          xmlTextWriterWriteFormatRaw(writer, "%g", v8);
          xmlTextWriterEndElement(writer);
        }
        ++v6;
      }
      while (v6 != v7);
    }
    int started = xmlTextWriterEndElement(writer);
  }
  return started >= 0;
}

void PDFPropertyListRelease(_DWORD *a1)
{
  if (a1)
  {
    if ((*a1)-- == 1)
    {
      if (a1[11] == 1)
      {
        BOOL v3 = (const void *)*((void *)a1 + 6);
        if (v3) {
          CFRelease(v3);
        }
      }
      free(*((void **)a1 + 13));
      free(a1);
    }
  }
}

_DWORD *CGPDFEncodingCreate(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if ((*(_DWORD *)(a1 + 200) - 2) >= 4)
  {
    return 0;
  }
  uint64_t v2 = malloc_type_calloc(1uLL, 0x40uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *(void *)uint64_t v2 = a1;
  v2[2] = 0;
  BOOL v3 = v2 + 2;
  get_base_encoding_from_dict(*(CGPDFDictionary **)(a1 + 16), v2 + 2);
  int v4 = v2[2];
  if (v4) {
    goto LABEL_22;
  }
  uint64_t v5 = *(void *)v2;
  if (!*(void *)v2) {
    goto LABEL_14;
  }
  if (*(_DWORD *)(v5 + 200) != 5)
  {
    if (*(_DWORD *)(v5 + 40))
    {
      if (!CGPDFFontIsEmbedded(v5))
      {
LABEL_19:
        int v4 = 1;
        goto LABEL_21;
      }
      uint64_t v5 = *(void *)v2;
    }
LABEL_14:
    unint64_t FontDescriptor = CGPDFFontGetFontDescriptor(v5);
    if (FontDescriptor)
    {
      if ((*(unsigned char *)(FontDescriptor + 40) & 0x20) != 0) {
        int v4 = 1;
      }
      else {
        int v4 = -1;
      }
      goto LABEL_21;
    }
    pdf_error("missing or invalid /Flags entry; assuming standard encoding.");
    goto LABEL_19;
  }
  unint64_t v6 = CGPDFFontGetFontDescriptor(v5);
  if (v6 && get_base_encoding_from_dict(*(CGPDFDictionary **)(v6 + 32), v2 + 2))
  {
    int v4 = *v3;
    goto LABEL_22;
  }
  int v4 = -1;
LABEL_21:
  int *v3 = v4;
LABEL_22:
  uint64_t v8 = *(void *)v2;
  if (v4 == 1 && v8 != 0)
  {
    int v11 = *(_DWORD *)(v8 + 40);
    if (v11 == 13)
    {
      int v12 = 5;
    }
    else
    {
      if (v11 != 14)
      {
LABEL_34:
        CGPDFInteger v21 = 0;
        char v22 = 0;
        CGPDFDictionaryRef value = 0;
        arraCGFloat y = 0;
        goto LABEL_35;
      }
      int v12 = 6;
    }
    int *v3 = v12;
    goto LABEL_34;
  }
  CGPDFInteger v21 = 0;
  char v22 = 0;
  CGPDFDictionaryRef value = 0;
  arraCGFloat y = 0;
  if (!v8)
  {
    uint64_t v10 = 0;
    goto LABEL_36;
  }
LABEL_35:
  uint64_t v10 = *(CGPDFDictionary **)(v8 + 16);
LABEL_36:
  if (CGPDFDictionaryGetDictionary(v10, "Encoding", &value) && CGPDFDictionaryGetArray(value, "Differences", &array))
  {
    int v13 = malloc_type_calloc(1uLL, 0x800uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    *((void *)v2 + 4) = v13;
    if (array)
    {
      uint64_t v14 = *((void *)array + 2);
      if (v14)
      {
        unint64_t v15 = 0;
        for (size_t i = 0; i != v14; ++i)
        {
          if (CGPDFArrayGetInteger(array, i, &v21))
          {
            unint64_t v15 = v21;
          }
          else if (CGPDFArrayGetName(array, i, (const char **)&v22) && v15 <= 0xFF && v22)
          {
            *(void *)(*((void *)v2 + 4) + 8 * v15++) = v22;
          }
        }
      }
    }
  }
  int v17 = *(_DWORD *)(a1 + 40);
  if (v17) {
    *((unsigned char *)v2 + 48) = v17 == 14;
  }
  return v2;
}

BOOL get_base_encoding_from_dict(CGPDFDictionary *a1, _DWORD *a2)
{
  CGPDFDictionaryRef dict = 0;
  CGPDFDictionaryRef value = 0;
  if (CGPDFDictionaryGetName(a1, "Encoding", (const char **)&value)
    || (BOOL result = CGPDFDictionaryGetDictionary(a1, "Encoding", &dict))
    && (BOOL result = CGPDFDictionaryGetName(dict, "BaseEncoding", (const char **)&value)))
  {
    *a2 = CGPDFGetBaseEncodingForName((uint64_t)value);
    return 1;
  }
  return result;
}

void CGPDFEncodingRelease(uint64_t a1)
{
  if (a1)
  {
    free(*(void **)(a1 + 56));
    free(*(void **)(a1 + 40));
    free(*(void **)(a1 + 32));
    free_builtin_names(*(char **)(a1 + 16));
    free((void *)a1);
  }
}

void free_builtin_names(char *a1)
{
  if (a1)
  {
    for (uint64_t i = 0; i != 2048; i += 8)
      free(*(void **)&a1[i]);
    free(a1);
  }
}

_OWORD *CGPDFEncodingGetGlyphVector(uint64_t *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t Font = CGPDFFontGetFont(*a1);
  if (*a1) {
    int v3 = *(_DWORD *)(*a1 + 200);
  }
  else {
    int v3 = 0;
  }
  explicit = (_OWORD *)atomic_load_explicit(a1 + 5, memory_order_acquire);
  if (!explicit)
  {
    explicit = malloc_type_malloc(0x200uLL, 0x566C45D1uLL);
    __CFSetLastAllocationEventName();
    if ((v3 - 2) < 2)
    {
      CGPDFFontIsEmbedded(*a1);
      get_type1_glyph_vector((size_t)a1, Font, 0, (uint64_t)explicit);
    }
    else
    {
      if (v3 != 4)
      {
        if (v3 == 5)
        {
          uint64_t v5 = 0;
          int16x8_t v6 = (int16x8_t)xmmword_1850CD7D0;
          v7.i64[0] = 0x8000800080008;
          v7.i64[1] = 0x8000800080008;
          do
          {
            explicit[v5] = v6;
            int16x8_t v6 = vaddq_s16(v6, v7);
            ++v5;
          }
          while (v5 != 32);
        }
        else
        {
          explicit[30] = 0u;
          explicit[31] = 0u;
          explicit[28] = 0u;
          explicit[29] = 0u;
          explicit[26] = 0u;
          explicit[27] = 0u;
          explicit[24] = 0u;
          explicit[25] = 0u;
          explicit[22] = 0u;
          explicit[23] = 0u;
          explicit[20] = 0u;
          explicit[21] = 0u;
          explicit[18] = 0u;
          explicit[19] = 0u;
          explicit[16] = 0u;
          explicit[17] = 0u;
          explicit[14] = 0u;
          explicit[15] = 0u;
          explicit[12] = 0u;
          explicit[13] = 0u;
          explicit[10] = 0u;
          explicit[11] = 0u;
          explicit[8] = 0u;
          explicit[9] = 0u;
          explicit[6] = 0u;
          explicit[7] = 0u;
          explicit[4] = 0u;
          explicit[5] = 0u;
          explicit[2] = 0u;
          explicit[3] = 0u;
          _OWORD *explicit = 0u;
          explicit[1] = 0u;
        }
        goto LABEL_39;
      }
      BOOL IsEmbedded = CGPDFFontIsEmbedded(*a1);
      if (IsEmbedded)
      {
        CGPDFDictionaryRef value = 0;
        BOOL v9 = *a1 ? *(CGPDFDictionary **)(*a1 + 16) : 0;
        if (CGPDFDictionaryGetName(v9, "Encoding", (const char **)&value))
        {
          uint64_t v10 = value;
          if (!strcmp(value, "Identity-H") || !strcmp(v10, "Identity-V"))
          {
            uint64_t v14 = 0;
            int16x8_t v15 = (int16x8_t)xmmword_1850CD7D0;
            v16.i64[0] = 0x8000800080008;
            v16.i64[1] = 0x8000800080008;
            do
            {
              explicit[v14] = v15;
              int16x8_t v15 = vaddq_s16(v15, v16);
              ++v14;
            }
            while (v14 != 32);
LABEL_39:
            int v17 = 0;
            atomic_compare_exchange_strong(a1 + 5, (unint64_t *)&v17, (unint64_t)explicit);
            if (v17)
            {
              free(explicit);
              explicit = v17;
            }
            goto LABEL_41;
          }
        }
      }
      get_truetype_glyph_vector((uint64_t)a1, Font, IsEmbedded, 0, explicit);
    }
    if (!CGPDFFontIsEmbedded(*a1))
    {
      CGPDFDictionaryRef value = "space";
      __int16 v29 = 0;
      if (Font)
      {
        (*(void (**)(void, char **, __int16 *, uint64_t))(*(void *)(Font + 16) + 280))(*(void *)(Font + 112), &value, &v29, 1);
        __int16 v11 = v29;
        if (v29)
        {
          for (uint64_t i = 0; i != 512; i += 8)
          {
            int16x4_t v13 = vceqz_s16(*(int16x4_t *)((char *)explicit + i));
            if (v13.i8[0]) {
              *(_WORD *)((char *)explicit + i) = v11;
            }
            if (v13.i8[2]) {
              *(_WORD *)((char *)explicit + i + 2) = v11;
            }
            if (v13.i8[4]) {
              *(_WORD *)((char *)explicit + i + 4) = v11;
            }
            if (v13.i8[6]) {
              *(_WORD *)((char *)explicit + i + 6) = v11;
            }
          }
        }
      }
    }
    goto LABEL_39;
  }
LABEL_41:
  if (v3 == 4)
  {
    uint64_t v18 = CGPDFFontGetFont(*a1);
    if (v18)
    {
      int v19 = (void *)v18;
      unint64_t v20 = 0;
      CGPDFDictionaryRef value = 0;
      do
      {
        UnicodesForIndedouble x = (unsigned __int16 *)CGPDFEncodingGetUnicodesForIndex((uint64_t)a1, v20, &value);
        unsigned int v22 = *((unsigned __int16 *)explicit + v20);
        int v23 = value;
        unimap = get_unimap(v19);
        if (v23 == (char *)1)
        {
          uint64_t v25 = (atomic_ullong *)(unimap + 2);
          uint64_t v26 = (char *)atomic_load_explicit((atomic_ullong *volatile)unimap + 2, memory_order_acquire);
          if (!v26)
          {
            uint64_t v26 = (char *)malloc_type_calloc(1uLL, 0x208uLL, 0x1080040036EC52CuLL);
            int v27 = 0;
            *(_WORD *)uint64_t v26 = -1;
            atomic_compare_exchange_strong(v25, (unint64_t *)&v27, (unint64_t)v26);
            if (v27)
            {
              CGFontIndexMapRelease(v26);
              uint64_t v26 = v27;
            }
          }
          CGFontIndexMapAddIndex((unsigned __int16 *)v26, v22, *UnicodesForIndex);
        }
        ++v20;
      }
      while (v20 != 256);
    }
  }
  return explicit;
}

void get_truetype_glyph_vector(uint64_t a1, uint64_t a2, int a3, int a4, _WORD *a5)
{
  if (a3)
  {
    lookup_glyphs_by_cmap(a1, a2, a5);
    return;
  }
  unint64_t FontDescriptor = CGPDFFontGetFontDescriptor(*(void *)a1);
  if (FontDescriptor && ((*(unsigned __int8 *)(FontDescriptor + 40) >> 5) & 1) != 0
    || (int v10 = *(_DWORD *)(a1 + 8), (v10 & 0xFFFFFFFE) == 2))
  {
    lookup_glyphs_by_cmap_nonsymbolic(a1, a2, a5);
    return;
  }
  if (v10 == -1) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = v10 - 1;
  }
  if (v11 > 6) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (uint64_t)*(&off_1E52CBD08 + v11);
  }
  uint64_t v13 = 0;
  uint64_t v14 = MEMORY[0x1E4F14390];
  do
  {
    uint64_t v15 = *(void *)(a1 + 32);
    if (!v15 || (int16x8_t v16 = *(const char **)(v15 + 8 * v13)) == 0)
    {
      if (!v12)
      {
        int16x8_t v16 = 0;
        goto LABEL_28;
      }
      int16x8_t v16 = *(const char **)(v12 + 8 * v13);
    }
    if (a4)
    {
      if (v16)
      {
        if (strlen(v16) == 1)
        {
          uint64_t v17 = *(unsigned __int8 *)v16;
          if ((v17 - 97) <= 0x19)
          {
            v22[0] = *(_DWORD *)(v14 + 4 * v17 + 2108);
            v22[1] = 0;
            int16x8_t v16 = v22;
          }
        }
      }
    }
LABEL_28:
    uint64_t v24 = v16;
    __int16 v23 = 0;
    if (a2)
    {
      (*(void (**)(void, const char **, __int16 *, uint64_t))(*(void *)(a2 + 16) + 280))(*(void *)(a2 + 112), &v24, &v23, 1);
      __int16 v18 = v23;
    }
    else
    {
      __int16 v18 = 0;
    }
    a5[v13++] = v18;
  }
  while (v13 != 256);
  if (!*a5)
  {
    uint64_t v19 = 1;
    while (v19 != 256)
    {
      uint64_t v20 = v19;
      if (a5[v19++])
      {
        if ((unint64_t)(v20 - 1) < 0xFF) {
          return;
        }
        break;
      }
    }
    lookup_glyphs_by_cmap(a1, a2, a5);
  }
}

size_t get_type1_glyph_vector(size_t result, uint64_t a2, int a3, uint64_t a4)
{
  size_t v7 = result;
  int v8 = *(_DWORD *)(result + 8);
  if (v8 != -1)
  {
    unsigned int v9 = v8 - 1;
    if (v9 > 6) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = (uint64_t)*(&off_1E52CBD08 + v9);
    }
    uint64_t v17 = 0;
    uint64_t v18 = MEMORY[0x1E4F14390];
    while (1)
    {
      uint64_t v19 = *(void *)(v7 + 32);
      if (v19)
      {
        uint64_t v20 = *(const char **)(v19 + 8 * v17);
        if (v20) {
          goto LABEL_25;
        }
      }
      if (v10) {
        break;
      }
      uint64_t v20 = 0;
LABEL_31:
      uint64_t v26 = v20;
      __int16 v25 = 0;
      if (a2)
      {
        BOOL result = (*(uint64_t (**)(void, const char **, __int16 *, uint64_t))(*(void *)(a2 + 16) + 280))(*(void *)(a2 + 112), &v26, &v25, 1);
        __int16 v22 = v25;
      }
      else
      {
        __int16 v22 = 0;
      }
      *(_WORD *)(a4 + 2 * v17++) = v22;
      if (v17 == 256) {
        return result;
      }
    }
    uint64_t v20 = *(const char **)(v10 + 8 * v17);
LABEL_25:
    if (a3)
    {
      if (v20)
      {
        BOOL result = strlen(v20);
        if (result == 1)
        {
          uint64_t v21 = *(unsigned __int8 *)v20;
          if ((v21 - 97) <= 0x19)
          {
            char v23 = *(_DWORD *)(v18 + 4 * v21 + 2108);
            char v24 = 0;
            uint64_t v20 = &v23;
          }
        }
      }
    }
    goto LABEL_31;
  }
  if (a2) {
    BOOL result = (*(uint64_t (**)(void, uint64_t))(*(void *)(a2 + 16) + 240))(*(void *)(a2 + 112), a4);
  }
  if (*(void *)(v7 + 32))
  {
    uint64_t v11 = 0;
    uint64_t v12 = MEMORY[0x1E4F14390];
    do
    {
      uint64_t v13 = *(void *)(v7 + 32);
      uint64_t v14 = *(const char **)(v13 + 8 * v11);
      if (v14)
      {
        if (a3)
        {
          BOOL result = strlen(*(const char **)(v13 + 8 * v11));
          if (result == 1)
          {
            uint64_t v15 = *(unsigned __int8 *)v14;
            if ((v15 - 97) <= 0x19)
            {
              char v23 = *(_DWORD *)(v12 + 4 * v15 + 2108);
              char v24 = 0;
              uint64_t v14 = &v23;
            }
          }
        }
        uint64_t v26 = v14;
        __int16 v25 = 0;
        if (a2)
        {
          BOOL result = (*(uint64_t (**)(void, const char **, __int16 *, uint64_t))(*(void *)(a2 + 16) + 280))(*(void *)(a2 + 112), &v26, &v25, 1);
          __int16 v16 = v25;
        }
        else
        {
          __int16 v16 = 0;
        }
        *(_WORD *)(a4 + 2 * v11) = v16;
      }
      ++v11;
    }
    while (v11 != 256);
  }
  return result;
}

uint64_t CGPDFEncodingGetUnicodesForIndex(uint64_t a1, unint64_t a2, void *a3)
{
  unichar_info = get_unichar_info(a1);
  if (a2 <= 0xFF && unichar_info)
  {
    if (a2) {
      uint64_t v6 = unichar_info[a2];
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v8 = unichar_info[a2 + 1];
    if (a3) {
      *a3 = v8 - v6;
    }
    if (v8 == v6) {
      return 0;
    }
    else {
      return (uint64_t)unichar_info + 2 * v6 + 2056;
    }
  }
  else
  {
    uint64_t result = 0;
    if (a3) {
      *a3 = 0;
    }
  }
  return result;
}

void *get_unichar_info(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 56), memory_order_acquire);
  if (!explicit)
  {
    uint64_t v3 = CGPDFFontGetToUnicodeCMap(*(void *)a1);
    unsigned int v4 = *(_DWORD *)(a1 + 8) - 1;
    if (v4 > 6) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = (uint64_t)*(&off_1E52CBD40 + v4);
    }
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    for (unint64_t i = 0; i != 256; ++i)
    {
      if (!v3
        || !cmap_vtable
        || (unsigned int v9 = *(uint64_t (**)(void, void, void))(cmap_vtable + 64)) == 0
        || (unichars_for_indedouble x = v9(*(void *)(v3 + 16), (unsigned __int16)i, 0)) == 0)
      {
        unichars_for_indedouble x = get_unichars_for_index(a1, v5, i, 0);
      }
      if (v6 <= unichars_for_index) {
        unint64_t v6 = unichars_for_index;
      }
      v7 += unichars_for_index;
    }
    explicit = malloc_type_calloc(1uLL, 2 * v7 + 2056, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    void *explicit = v6;
    uint64_t v13 = explicit + 257;
    do
    {
      if (!v3
        || !cmap_vtable
        || (uint64_t v14 = *(uint64_t (**)(void, void, _WORD *))(cmap_vtable + 64)) == 0
        || (uint64_t v15 = v14(*(void *)(v3 + 16), (unsigned __int16)v12, v13)) == 0)
      {
        uint64_t v15 = get_unichars_for_index(a1, v5, v12, v13);
      }
      v13 += v15;
      v11 += v15;
      explicit[++v12] = v11;
    }
    while (v12 != 256);
    uint64_t v16 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v16, (unint64_t)explicit);
    if (v16)
    {
      free(explicit);
      return (void *)v16;
    }
  }
  return explicit;
}

uint64_t get_unichars_for_index(uint64_t a1, uint64_t a2, unint64_t a3, _WORD *a4)
{
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (!v6 || !*(void *)(v6 + 8 * a3))
    {
      if (!a4) {
        return 1;
      }
      __int16 v10 = *(_WORD *)(a2 + 2 * a3);
LABEL_13:
      *a4 = v10;
      return 1;
    }
  }
  NameForIndedouble x = (char *)CGPDFEncodingGetNameForIndex(a1, a3);
  uint64_t v8 = NameForIndex;
  if (*(unsigned char *)(a1 + 24))
  {
    if (NameForIndex)
    {
      if (strcmp(NameForIndex, ".notdef"))
      {
        if (strlen(v8) >= 3)
        {
          __int16 v9 = digit_to_int(v8[1]);
          __int16 v10 = digit_to_int(v8[2]) + 16 * v9;
          if (v10)
          {
            if (!a4) {
              return 1;
            }
            goto LABEL_13;
          }
        }
      }
    }
    return 0;
  }
  else
  {
    int v12 = *(unsigned __int8 *)(a1 + 48);
    return CGPDFGetUnicharsForGlyphName(NameForIndex, v12, a4);
  }
}

uint64_t CGPDFEncodingGetNameForIndex(uint64_t a1, unint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2 <= 0xFF)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      if (!v5 || (uint64_t result = *(void *)(v5 + 8 * a2)) == 0)
      {
        int v6 = *(_DWORD *)(a1 + 8);
        if (v6 != -1)
        {
          unsigned int v7 = v6 - 1;
          if (v7 <= 6)
          {
            explicit = (char *)*(&off_1E52CBD08 + v7);
            goto LABEL_9;
          }
          return 0;
        }
        explicit = (char *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 16), memory_order_acquire);
        if (!explicit)
        {
          if (!*(void *)a1) {
            return 0;
          }
          int v9 = *(_DWORD *)(*(void *)a1 + 200);
          if ((v9 - 2) > 2) {
            return 0;
          }
          explicit = (char *)malloc_type_calloc(1uLL, 0x800uLL, 0x33BCE901uLL);
          __CFSetLastAllocationEventName();
          if (v9 == 4)
          {
            for (uint64_t i = 0; i != 256; ++i)
            {
              uint64_t v11 = CGPDFEncodingVectorMacRoman[i];
              size_t v12 = strlen(v11);
              uint64_t v13 = (char *)malloc_type_malloc(v12 + 1, 0x566C45D1uLL);
              __CFSetLastAllocationEventName();
              *(void *)&explicit[i * 8] = v13;
              strcpy(v13, v11);
            }
          }
          else
          {
            get_builtin_type1_names(*(void *)a1, (uint64_t)explicit, (unsigned char *)(a1 + 24));
          }
          uint64_t v14 = 0;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 16), (unint64_t *)&v14, (unint64_t)explicit);
          if (v14)
          {
            free_builtin_names(explicit);
            explicit = v14;
          }
        }
LABEL_9:
        if (explicit) {
          return *(void *)&explicit[8 * a2];
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t digit_to_int(unsigned int a1)
{
  if (a1 <= 0x7F)
  {
    int v2 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * a1 + 60);
    if ((v2 & 0x400) == 0)
    {
      if ((v2 & 0x10000) == 0) {
        return 0;
      }
      uint64_t v4 = (unsigned __int16)v2 & 0x8000;
      goto LABEL_10;
    }
    return a1 - 48;
  }
  if (__maskrune_l(a1, 0x400uLL, 0)) {
    return a1 - 48;
  }
  uint64_t result = __maskrune_l(a1, 0x10000uLL, 0);
  if (!result) {
    return result;
  }
  uint64_t v4 = __maskrune_l(a1, 0x8000uLL, 0);
LABEL_10:
  if (v4) {
    int v5 = -55;
  }
  else {
    int v5 = -87;
  }
  return v5 + a1;
}

void get_builtin_type1_names(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  int v27 = a3;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t Font = CGPDFFontGetFont(a1);
  uint64_t v6 = Font;
  if (Font)
  {
    (*(void (**)(void, _WORD *))(*(void *)(Font + 16) + 240))(*(void *)(Font + 112), v28);
    uint64_t Font = (*(uint64_t (**)(void))(*(void *)(v6 + 16) + 288))(*(void *)(v6 + 112));
  }
  uint64_t v26 = (uint64_t)&v26;
  size_t v7 = Font + 1;
  MEMORY[0x1F4188790](Font, v5);
  __int16 v10 = (char *)&v26 - v9;
  if (v7 == -1) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = (char *)&v26 - v9;
  }
  if (v8 >= 0x82) {
    uint64_t v11 = (char *)malloc_type_malloc(v7, 0xB36A7E2uLL);
  }
  for (uint64_t i = 0; i != 256; ++i)
  {
    if (v6
      && ((*(uint64_t (**)(void, void, char *, size_t))(*(void *)(v6 + 16) + 296))(*(void *)(v6 + 112), (unsigned __int16)v28[i], v11, v7) & 1) != 0)
    {
      size_t v13 = strlen(v11);
      uint64_t v14 = (char *)malloc_type_malloc(v13 + 1, 0x566C45D1uLL);
      __CFSetLastAllocationEventName();
      *(void *)(a2 + 8 * i) = v14;
      strcpy(v14, v11);
    }
    else
    {
      *(void *)(a2 + 8 * i) = 0;
    }
  }
  if (v11 != v10) {
    free(v11);
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  char v17 = 1;
  uint64_t v18 = MEMORY[0x1E4F14390];
  while (1)
  {
    uint64_t v19 = *(const char **)(a2 + v15);
    if (v19)
    {
      if (strcmp(*(const char **)(a2 + v15), ".notdef")) {
        break;
      }
    }
    uint64_t v20 = v16;
LABEL_36:
    v15 += 8;
    uint64_t v16 = v20;
    if (v15 == 2048)
    {
      LOBYTE(v21) = v17 ^ 1;
      goto LABEL_39;
    }
  }
  if (strlen(v19) != 3) {
    goto LABEL_38;
  }
  uint64_t v20 = *v19;
  if (!(_BYTE)v16)
  {
    if ((v20 & 0x80000000) != 0) {
      uint64_t v21 = __maskrune_l(*v19, 0x100uLL, 0);
    }
    else {
      uint64_t v21 = *(_DWORD *)(v18 + 4 * v20 + 60) & 0x100;
    }
    if (!v21) {
      goto LABEL_39;
    }
LABEL_28:
    unsigned int v22 = v19[1];
    if ((v22 & 0x80000000) != 0)
    {
      int v23 = __maskrune_l(v22, 0x10000uLL, 0);
      LOBYTE(v21) = v23;
      if (!v23) {
        goto LABEL_39;
      }
    }
    else
    {
      LODWORD(v21) = *(_DWORD *)(v18 + 4 * v22 + 60) & 0x10000;
      if (!v21) {
        goto LABEL_39;
      }
    }
    unsigned int v24 = v19[2];
    if ((v24 & 0x80000000) != 0) {
      uint64_t v25 = __maskrune_l(v24, 0x10000uLL, 0);
    }
    else {
      uint64_t v25 = *(_DWORD *)(v18 + 4 * v24 + 60) & 0x10000;
    }
    char v17 = 0;
    LOBYTE(v21) = 0;
    if (!v25) {
      goto LABEL_39;
    }
    goto LABEL_36;
  }
  uint64_t v20 = v16;
  if (*(unsigned __int8 *)v19 == v16) {
    goto LABEL_28;
  }
LABEL_38:
  LOBYTE(v21) = 0;
LABEL_39:
  *int v27 = v21 & 1;
}

void lookup_glyphs_by_cmap(uint64_t a1, uint64_t a2, _WORD *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unint64_t FontDescriptor = CGPDFFontGetFontDescriptor(*(void *)a1);
  if ((!FontDescriptor || (*(unsigned char *)(FontDescriptor + 40) & 0x20) == 0) && (*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) != 2)
  {
    size_t v7 = (__int16 *)malloc_type_calloc(1uLL, 0x208uLL, 0x1080040036EC52CuLL);
    *size_t v7 = 0;
    if (a2)
    {
      if ((*(unsigned int (**)(void, uint64_t, void, __int16 *))(*(void *)(a2 + 16) + 248))(*(void *)(a2 + 112), 3, 0, v7))
      {
        _3_0_cmap_prefidouble x = get_3_0_cmap_prefix(v7);
        uint64_t v9 = 0;
        int16x8_t v10 = (int16x8_t)xmmword_1850CD7D0;
        int8x16_t v11 = (int8x16_t)vdupq_n_s16(_3_0_cmap_prefix);
        v12.i64[0] = 0x8000800080008;
        v12.i64[1] = 0x8000800080008;
        do
        {
          *(int8x16_t *)&v16[v9] = vorrq_s8(v11, (int8x16_t)v10);
          int16x8_t v10 = vaddq_s16(v10, v12);
          v9 += 8;
        }
        while (v9 != 256);
        CGFontIndexMapGetValues(v7, v16, 256, a3);
        goto LABEL_24;
      }
      if ((*(unsigned int (**)(void, uint64_t, void, __int16 *))(*(void *)(a2 + 16) + 248))(*(void *)(a2 + 112), 1, 0, v7))
      {
        for (uint64_t i = 0; i != 256; ++i)
        {
          if (v7)
          {
            if (v7 == (__int16 *)-1)
            {
              __int16 v14 = i;
            }
            else
            {
              unint64_t v15 = atomic_load((unint64_t *)&v7[4 * ((unsigned __int16)i >> 10) + 4]);
              if (v15) {
                __int16 v14 = *(_WORD *)(v15 + 2 * i);
              }
              else {
                __int16 v14 = *v7;
              }
            }
          }
          else
          {
            __int16 v14 = -1;
          }
          a3[i] = v14;
        }
        goto LABEL_24;
      }
    }
    lookup_glyphs_by_cmap_nonsymbolic(a1, a2, a3);
LABEL_24:
    CGFontIndexMapRelease((char *)v7);
    return;
  }

  lookup_glyphs_by_cmap_nonsymbolic(a1, a2, a3);
}

void lookup_glyphs_by_cmap_nonsymbolic(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *(_DWORD *)(a1 + 8) - 1;
  if (v6 > 6) {
    bzero(v47, 0x800uLL);
  }
  else {
    memcpy(v47, *(&off_1E52CBD08 + v6), sizeof(v47));
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7)
  {
    for (uint64_t i = 0; i != 2048; i += 16)
    {
      int64x2_t v9 = *(int64x2_t *)(v7 + i);
      int32x2_t v10 = vmovn_s64(vtstq_s64(v9, v9));
      if (v10.i8[0]) {
        *(void *)&v47[i] = v9.i64[0];
      }
      if (v10.i8[4]) {
        *(void *)&v47[i + 8] = v9.i64[1];
      }
    }
  }
  for (uint64_t j = 0; j != 128; ++j)
  {
    int32x2_t v12 = vmovn_s64(vceqzq_s64(*(int64x2_t *)&v47[j * 16]));
    long long v13 = CGPDFEncodingVectorStandard[j];
    if (v12.i8[0]) {
      *(void *)&v47[j * 16] = v13;
    }
    if (v12.i8[4]) {
      *(void *)&v47[j * 16 + 8] = *((void *)&v13 + 1);
    }
  }
  __int16 v14 = (__int16 *)malloc_type_calloc(1uLL, 0x208uLL, 0x1080040036EC52CuLL);
  *__int16 v14 = 0;
  if (!a2) {
    goto LABEL_64;
  }
  if ((*(unsigned int (**)(void, uint64_t, uint64_t, __int16 *))(*(void *)(a2 + 16) + 248))(*(void *)(a2 + 112), 3, 1, v14))
  {
    uint64_t v15 = 0;
    char v16 = 0;
    while (1)
    {
      uint64_t v17 = *(char **)&v47[8 * v15];
      if (!v17 || CGPDFGetUnicharsForGlyphName(*(char **)&v47[8 * v15], 0, 0) != 1) {
        break;
      }
      LOWORD(v46) = 0;
      CGPDFGetUnicharsForGlyphName(v17, 0, &v46);
      int v18 = (unsigned __int16)v46;
      if (v14 == (__int16 *)-1) {
        goto LABEL_32;
      }
      if (v14)
      {
        unint64_t v19 = atomic_load((unint64_t *)((char *)v14 + (((unint64_t)(unsigned __int16)v46 >> 7) & 0x1F8)
                                                           + 8));
        if (v19) {
          int v18 = *(unsigned __int16 *)(v19 + 2 * (v46 & 0x3FF));
        }
        else {
          int v18 = (unsigned __int16)*v14;
        }
LABEL_32:
        *((_WORD *)a3 + v15) = v18;
        if (v18) {
          goto LABEL_27;
        }
LABEL_26:
        char v16 = 1;
        goto LABEL_27;
      }
      *((_WORD *)a3 + v15) = -1;
LABEL_27:
      if (++v15 == 256)
      {
        if (v16)
        {
          uint64_t v24 = CGPDFFontGetToUnicodeCMap(*(void *)a1);
          if (v24)
          {
            uint64_t v26 = v24;
            if (cmap_vtable && (int v27 = *(uint64_t (**)(void))(cmap_vtable + 56)) != 0) {
              uint64_t v28 = v27(*(void *)(v24 + 16));
            }
            else {
              uint64_t v28 = 0;
            }
            uint64_t v35 = MEMORY[0x1F4188790](v28, v25);
            unsigned __int8 v38 = (unsigned __int16 *)&v44[-v37];
            if (v36 <= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v39 = (unsigned __int16 *)&v44[-v37];
            }
            else {
              uint64_t v39 = 0;
            }
            if (v36 - 0x7FFFFFFFFFFFFFFFLL >= 0x8000000000000022) {
              uint64_t v39 = (unsigned __int16 *)malloc_type_malloc(2 * v35, 0x32E87CC9uLL);
            }
            for (uint64_t k = 0; k != 256; ++k)
            {
              if (!*((_WORD *)a3 + k))
              {
                if (cmap_vtable)
                {
                  unint64_t v41 = *(uint64_t (**)(void, void, unsigned __int16 *))(cmap_vtable + 64);
                  if (v41)
                  {
                    if (v41(*(void *)(v26 + 16), (unsigned __int16)k, v39))
                    {
                      if (v14)
                      {
                        unint64_t v42 = *v39;
                        if (v14 != (__int16 *)-1)
                        {
                          unint64_t v43 = atomic_load((unint64_t *)((char *)v14 + ((v42 >> 7) & 0x1F8) + 8));
                          if (v43) {
                            LOWORD(v42) = *(_WORD *)(v43 + 2 * (v42 & 0x3FF));
                          }
                          else {
                            LOWORD(v42) = *v14;
                          }
                        }
                      }
                      else
                      {
                        LOWORD(v42) = -1;
                      }
                      *((_WORD *)a3 + k) = v42;
                    }
                  }
                }
              }
            }
            if (v39 != v38) {
              free(v39);
            }
          }
        }
        goto LABEL_65;
      }
    }
    *((_WORD *)a3 + v15) = 0;
    goto LABEL_26;
  }
  if (!(*(unsigned int (**)(void, uint64_t, void, __int16 *))(*(void *)(a2 + 16) + 248))(*(void *)(a2 + 112), 3, 0, v14))
  {
    if ((*(unsigned int (**)(void, uint64_t, void, __int16 *))(*(void *)(a2 + 16) + 248))(*(void *)(a2 + 112), 1, 0, v14))
    {
      uint64_t v29 = 0;
      while (1)
      {
        int v30 = *(const char **)&v47[8 * v29];
        if (v30)
        {
          uint64_t v31 = 0;
          while (strcmp(v30, CGPDFEncodingVectorMacRoman[v31]))
          {
            if (++v31 == 256) {
              goto LABEL_55;
            }
          }
          if (v14)
          {
            if (v14 != (__int16 *)-1)
            {
              unint64_t v32 = atomic_load((unint64_t *)&v14[4 * ((unsigned __int16)v31 >> 10) + 4]);
              if (v32) {
                LOWORD(v31) = *(_WORD *)(v32 + 2 * (v31 & 0x3FF));
              }
              else {
                LOWORD(v31) = *v14;
              }
            }
          }
          else
          {
            LOWORD(v31) = -1;
          }
        }
        else
        {
LABEL_55:
          LOWORD(v31) = 0;
        }
        *((_WORD *)a3 + v29++) = v31;
        if (v29 == 256) {
          goto LABEL_65;
        }
      }
    }
LABEL_64:
    a3[30] = 0u;
    a3[31] = 0u;
    a3[28] = 0u;
    a3[29] = 0u;
    a3[26] = 0u;
    a3[27] = 0u;
    a3[24] = 0u;
    a3[25] = 0u;
    a3[22] = 0u;
    a3[23] = 0u;
    a3[20] = 0u;
    a3[21] = 0u;
    a3[18] = 0u;
    a3[19] = 0u;
    a3[16] = 0u;
    a3[17] = 0u;
    a3[14] = 0u;
    a3[15] = 0u;
    a3[12] = 0u;
    a3[13] = 0u;
    a3[10] = 0u;
    a3[11] = 0u;
    a3[8] = 0u;
    a3[9] = 0u;
    a3[6] = 0u;
    a3[7] = 0u;
    a3[4] = 0u;
    a3[5] = 0u;
    a3[2] = 0u;
    a3[3] = 0u;
    *a3 = 0u;
    a3[1] = 0u;
    goto LABEL_65;
  }
  _3_0_cmap_prefidouble x = get_3_0_cmap_prefix(v14);
  for (uint64_t m = 0; m != 256; ++m)
  {
    if (v14)
    {
      unsigned __int16 v22 = _3_0_cmap_prefix | m;
      if (v14 != (__int16 *)-1)
      {
        unint64_t v23 = atomic_load((unint64_t *)&v14[4 * (v22 >> 10) + 4]);
        if (v23) {
          unsigned __int16 v22 = *(_WORD *)(v23 + 2 * ((_3_0_cmap_prefix | (unsigned __int16)m) & 0x3FF));
        }
        else {
          unsigned __int16 v22 = *v14;
        }
      }
    }
    else
    {
      unsigned __int16 v22 = -1;
    }
    *((_WORD *)a3 + m) = v22;
  }
LABEL_65:
  CGFontIndexMapRelease((char *)v14);
  for (uint64_t n = 0; n != 256; ++n)
  {
    if (!*((_WORD *)a3 + n) && *(void *)&v47[8 * n])
    {
      uint64_t v46 = *(void *)&v47[8 * n];
      __int16 v45 = 0;
      if (a2)
      {
        (*(void (**)(void, uint64_t *, __int16 *, uint64_t))(*(void *)(a2 + 16) + 280))(*(void *)(a2 + 112), &v46, &v45, 1);
        __int16 v34 = v45;
      }
      else
      {
        __int16 v34 = 0;
      }
      *((_WORD *)a3 + n) = v34;
    }
  }
}

uint64_t get_3_0_cmap_prefix(__int16 *a1)
{
  uint64_t v2 = 0;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  v3.i64[0] = 0x8000800080008;
  v3.i64[1] = 0x8000800080008;
  int8x16_t v21 = (int8x16_t)vdupq_n_s64(1uLL);
  while (1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = get_3_0_cmap_prefix_prefix[v2];
    int8x16_t v6 = (int8x16_t)vdupq_n_s16(v5);
    int16x8_t v7 = (int16x8_t)xmmword_1850CD7D0;
    do
    {
      *(int8x16_t *)&v23[v4] = vorrq_s8(v6, (int8x16_t)v7);
      int16x8_t v7 = vaddq_s16(v7, v3);
      v4 += 8;
    }
    while (v4 != 256);
    CGFontIndexMapGetValues(a1, v23, 256, v22);
    uint64_t v8 = 0;
    int64x2_t v9 = 0uLL;
    int64x2_t v10 = 0uLL;
    int64x2_t v11 = 0uLL;
    int64x2_t v12 = 0uLL;
    do
    {
      uint16x8_t v13 = (uint16x8_t)vtstq_s16(*(int16x8_t *)&v22[v8], *(int16x8_t *)&v22[v8]);
      uint32x4_t v14 = vmovl_u16(*(uint16x4_t *)v13.i8);
      v15.i64[0] = v14.u32[0];
      v15.i64[1] = v14.u32[1];
      int64x2_t v16 = (int64x2_t)vandq_s8(v15, v21);
      v15.i64[0] = v14.u32[2];
      v15.i64[1] = v14.u32[3];
      int64x2_t v17 = (int64x2_t)vandq_s8(v15, v21);
      uint32x4_t v18 = vmovl_high_u16(v13);
      v15.i64[0] = v18.u32[0];
      v15.i64[1] = v18.u32[1];
      int64x2_t v19 = (int64x2_t)vandq_s8(v15, v21);
      v15.i64[0] = v18.u32[2];
      v15.i64[1] = v18.u32[3];
      int64x2_t v12 = vaddq_s64(v12, (int64x2_t)vandq_s8(v15, v21));
      int64x2_t v11 = vaddq_s64(v11, v19);
      int64x2_t v10 = vaddq_s64(v10, v17);
      int64x2_t v9 = vaddq_s64(v9, v16);
      v8 += 8;
    }
    while (v8 != 256);
    if (vaddvq_s64(vaddq_s64(vaddq_s64(v9, v11), vaddq_s64(v10, v12)))) {
      break;
    }
    ++v2;
    v3.i64[0] = 0x8000800080008;
    v3.i64[1] = 0x8000800080008;
    if (v2 == 4) {
      return 0;
    }
  }
  return v5;
}

uint64_t CGPDFEncodingGetGlyphVectorWithFont(size_t a1, uint64_t a2, int a3, _WORD *a4)
{
  if (*(void *)a1)
  {
    int v4 = *(_DWORD *)(*(void *)a1 + 200);
    if ((v4 - 2) < 2)
    {
      get_type1_glyph_vector(a1, a2, a3, (uint64_t)a4);
      return 1;
    }
    if (v4 == 4)
    {
      get_truetype_glyph_vector(a1, a2, 0, a3, a4);
      return 1;
    }
  }
  return 0;
}

void *CGPDFEncodingGetUnicodeMaxLength(uint64_t a1)
{
  uint64_t result = get_unichar_info(a1);
  if (result) {
    return (void *)*result;
  }
  return result;
}

BOOL CGFontQuantumEqualToQuantum(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t defaults_setup_21123()
{
  int v2 = 0;
  int v1 = 0;
  if (get_integer_property("CGFontQX", (const void *(*)(const char *))copy_local_domain_value, &v2))QX = v2; {
  uint64_t result = get_integer_property("CGFontQY", (const void *(*)(const char *))copy_local_domain_value, &v1);
  }
  if (result) {
    QY = v1;
  }
  return result;
}

uint64_t CGFontGetGlyphPositions(uint64_t result, uint64_t a2, float64x2_t *a3, float64x2_t *a4)
{
  if (a2)
  {
    float64x2_t v4 = *a3;
    float64x2_t v5 = a3[1];
    float64x2_t v6 = a3[2];
    int16x8_t v7 = (double *)(result + 8);
    float64x2_t v8 = (float64x2_t)vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
    do
    {
      *a4++ = vaddq_f64(vaddq_f64(v6, vmlaq_n_f64(vmulq_n_f64(v5, *v7), v4, *(v7 - 1))), v8);
      v7 += 2;
      --a2;
    }
    while (a2);
  }
  return result;
}

void CGPDFHintTableSet::~CGPDFHintTableSet(CGPDFHintTableSet *this)
{
  CGPDFHintTableSet::~CGPDFHintTableSet(this);

  JUMPOUT(0x18532A2A0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_1ED093868;
  int v2 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    MEMORY[0x18532A2A0](v2, 0x1000C40451B5BE8);
  }
  int16x8_t v3 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v3) {
    MEMORY[0x18532A2A0](v3, 0x1000C40451B5BE8);
  }
  float64x2_t v4 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v4) {
    std::default_delete<CGSharedObjectHintTable>::operator()[abi:fe180100](v4);
  }
  std::unique_ptr<CGPageOffsetHintTable>::reset[abi:fe180100]((uint64_t *)this + 8, 0);
}

uint64_t std::default_delete<CGSharedObjectHintTable>::operator()[abi:fe180100](uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = *(void **)(result + 32);
    if (v2)
    {
      *(void *)(v1 + 40) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x18532A2A0);
  }
  return result;
}

uint64_t *std::unique_ptr<CGPageOffsetHintTable>::reset[abi:fe180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  void *result = a2;
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 48);
    if (v3)
    {
      uint64_t v4 = *(void *)(v2 + 56);
      float64x2_t v5 = *(void **)(v2 + 48);
      if (v4 != v3)
      {
        do
        {
          float64x2_t v6 = *(void **)(v4 - 40);
          if (v6)
          {
            *(void *)(v4 - 32) = v6;
            operator delete(v6);
          }
          v4 -= 64;
        }
        while (v4 != v3);
        float64x2_t v5 = *(void **)(v2 + 48);
      }
      *(void *)(v2 + 56) = v3;
      operator delete(v5);
    }
    JUMPOUT(0x18532A2A0);
  }
  return result;
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<CGPageOffsetHintTablePageEntry>>(unint64_t a1)
{
  if (a1 >> 58) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(a1 << 6);
}

uint64_t *std::vector<CGPageOffsetHintTablePageEntry>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 64;
      long long v6 = *(_OWORD *)(v3 - 64);
      *(_DWORD *)(v4 - 48) = *(_DWORD *)(v3 - 48);
      *(_OWORD *)(v4 - 64) = v6;
      *(void *)(v4 - 32) = 0;
      *(void *)(v4 - 24) = 0;
      *(void *)(v4 - 40) = 0;
      *(_OWORD *)(v4 - 40) = *(_OWORD *)(v3 - 40);
      *(void *)(v4 - 24) = *(void *)(v3 - 24);
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 32) = 0;
      *(void *)(v3 - 24) = 0;
      *(_OWORD *)(v4 - 16) = *(_OWORD *)(v3 - 16);
      v4 -= 64;
      v3 -= 64;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v7 = *result;
  void *result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<CGPageOffsetHintTablePageEntry>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 64;
    uint64_t v4 = *(void **)(v2 - 40);
    if (v4)
    {
      *(void *)(v2 - 32) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 64;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<CGSharedObjectGroupEntry>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4)
  {
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(a2);
    uint64_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF0];
    uint64_t v7 = &v4[16 * v6];
    uint64_t v9 = (char *)*a1;
    uint64_t v8 = (char *)a1[1];
    int64x2_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        *((_OWORD *)v10 - 1) = *((_OWORD *)v8 - 1);
        v10 -= 16;
        v8 -= 16;
      }
      while (v8 != v9);
      uint64_t v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t CGPDFHintTableSet::rangeCheck(uint64_t this, uint64_t a2, uint64_t a3)
{
  if (this < a2 || this > a3)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:fe180100](exception);
    __cxa_throw(exception, (struct type_info *)off_1E529EE58, MEMORY[0x1E4FBA1B8]);
  }
  return this;
}

void sub_1850520A0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void CGPDFHintTableSet::readGenericHintTable(CGPDFHintTableSet *this, const __CFData *a2, CFDataRef theData, uint64_t a4)
{
  BytePtr = CFDataGetBytePtr(theData);
  if (BytePtr)
  {
    uint64_t v7 = &BytePtr[a4];
    uint64_t v8 = CFDataGetBytePtr(theData);
    if (&v8[CFDataGetLength(theData)] - v7 > 15) {
      operator new();
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:fe180100](exception, "Insufficient data size");
  }
  else
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:fe180100](exception, "CFDataGetBytePtr(hint_data) returned NULL");
  }
  __cxa_throw(exception, (struct type_info *)off_1E529EE60, MEMORY[0x1E4FBA1C0]);
}

void sub_1850521FC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::domain_error::domain_error[abi:fe180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4C8] + 16);
  return result;
}

_DWORD *CGPDFHintTableSet::copyFromBuf(_DWORD *this, unsigned int *a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  unint64_t v4 = *(void *)a2 + 4;
  if (v4 > (unint64_t)a3)
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::length_error::length_error[abi:fe180100](exception, "not enough data");
    __cxa_throw(exception, (struct type_info *)off_1E529EE68, MEMORY[0x1E4FBA1C8]);
  }
  *this = bswap32(**(_DWORD **)a2);
  *(void *)a2 = v4;
  return this;
}

void sub_1850522E0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_WORD *CGPDFHintTableSet::copyFromBuf(_WORD *this, unsigned __int16 *a2, const unsigned __int8 **a3, const unsigned __int8 *a4)
{
  unint64_t v4 = *(void *)a2 + 2;
  if (v4 > (unint64_t)a3)
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::length_error::length_error[abi:fe180100](exception, "not enough data");
    __cxa_throw(exception, (struct type_info *)off_1E529EE68, MEMORY[0x1E4FBA1C8]);
  }
  *this = bswap32(**(unsigned __int16 **)a2) >> 16;
  *(void *)a2 = v4;
  return this;
}

void sub_18505236C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::runtime_error *std::range_error::range_error[abi:fe180100](std::runtime_error *a1)
{
  uint64_t result = std::runtime_error::runtime_error(a1, "rangeCheck failure");
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
  return result;
}

uint64_t ___ZN17CGPDFHintTableSet23writeSharedObjectsTableEP14CGDataConsumerx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)(*(void *)(*(void *)(result + 32) + 72) + 40) != *(void *)(*(void *)(*(void *)(result + 32) + 72)
                                                                                       + 32))
      operator new[]();
  }
  return result;
}

void sub_1850525A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t ___ZN17CGPDFHintTableSet23writeSharedObjectsTableEP14CGDataConsumerx_block_invoke_2(uint64_t a1, _DWORD *a2)
{
  return (*a2 - *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 72) + 20));
}

uint64_t ___ZN17CGPDFHintTableSet23writeSharedObjectsTableEP14CGDataConsumerx_block_invoke_4()
{
  return 0;
}

uint64_t ___ZN17CGPDFHintTableSet23writeSharedObjectsTableEP14CGDataConsumerx_block_invoke_3()
{
  return 0;
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(void *)(*(void *)(*(void *)(result + 32) + 64) + 56) != *(void *)(*(void *)(*(void *)(result + 32) + 64)
                                                                                       + 48))
      operator new[]();
  }
  return result;
}

void sub_1850527D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_2(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(*(void *)(result + 32) + 64);
    uint64_t v3 = *(void *)(v2 + 48);
    uint64_t v4 = *(void *)(v2 + 56);
    if (v3 != v4)
    {
      uint64_t v5 = 0;
      do
      {
        v5 += (uint64_t)(*(void *)(v3 + 32) - *(void *)(v3 + 24)) >> 3;
        v3 += 64;
      }
      while (v3 != v4);
      if (v5) {
        operator new[]();
      }
    }
  }
  return result;
}

void sub_185052A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_3(uint64_t a1, _DWORD *a2)
{
  return (*a2 - **(_DWORD **)(*(void *)(a1 + 32) + 64));
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_4(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a2 + 4) - *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 64) + 12));
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_9(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 16);
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_8(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 12);
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_7(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 4);
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_6(uint64_t a1, unsigned int *a2)
{
  return *a2;
}

uint64_t ___ZN17CGPDFHintTableSet21writePageOffsetsTableEP14CGDataConsumerx_block_invoke_5(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int16 *)(a2 + 8);
}

CFDictionaryRef __get_provider_options_block_invoke()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"kCGImagePreferGPUForColorConversion";
  values = (void *)*MEMORY[0x1E4F1CFC8];
  CFDictionaryRef result = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  get_provider_options_options_singletouint64_t n = (uint64_t)result;
  return result;
}

CFStringRef _CPIndexSetCopyDebugDesc(void *cf)
{
  uint64_t v2 = cf[2];
  if (v2 == 1)
  {
    CFAllocatorRef v5 = CFGetAllocator(cf);
    return CFStringCreateWithFormat(v5, 0, @"<CPIndexSet = 1 range (%.1ld, %.1ld]>"), *(void *)cf[4], *(void *)(cf[4] + 8);
  }
  else if (v2)
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    return CFStringCreateWithFormat(v6, 0, @"<CPIndexSet = %ld ranges>", cf[2]);
  }
  else
  {
    CFAllocatorRef v3 = CFGetAllocator(cf);
    return CFStringCreateCopy(v3, @"<CPIndexSet = empty>");
  }
}

void _CPIndexSetFinalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2) {
    free(v2);
  }
  *(void *)(a1 + 32) = 0;
}

int64x2_t *CPIndexSetCreateWithRange(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if ((a1 & 0x8000000000000000) == 0 && (a2 & 0x8000000000000000) == 0)
  {
    if (!CPIndexSetGetTypeID_id) {
      CPIndexSetGetTypeID_id = _CFRuntimeRegisterClass();
    }
    uint64_t Instance = (int64x2_t *)_CFRuntimeCreateInstance();
    uint64_t v2 = Instance;
    if (Instance)
    {
      Instance[1] = vdupq_n_s64(1uLL);
      CFAllocatorRef v6 = malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
      v2[2].i64[0] = (uint64_t)v6;
      *CFAllocatorRef v6 = a1;
      v6[1] = a2;
      v2[2].i8[8] = 0;
    }
  }
  return v2;
}

void CPIndexSetNormalize(uint64_t a1)
{
  int64_t v2 = *(void *)(a1 + 16);
  if (v2 < 2)
  {
    if (v2 != 1) {
      goto LABEL_35;
    }
  }
  else
  {
    qsort(*(void **)(a1 + 32), v2, 0x10uLL, (int (__cdecl *)(const void *, const void *))sortRangesByLocation);
  }
  int64_t v3 = 0;
  uint64_t v4 = *(uint64_t **)(a1 + 32);
  while (1)
  {
    uint64_t v5 = *v4;
    v4 += 2;
    if ((v5 & 0x8000000000000000) == 0) {
      break;
    }
    if (v2 == ++v3)
    {
      int64_t v3 = v2;
      break;
    }
  }
  if (v3)
  {
    BOOL v6 = v2 <= v3;
    v2 -= v3;
    if (!v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 16 * v3;
      int64_t v9 = v2;
      do
      {
        *(_OWORD *)(*(void *)(a1 + 32) + v7) = *(_OWORD *)(*(void *)(a1 + 32) + v7 + v8);
        v7 += 16;
        --v9;
      }
      while (v9);
    }
    *(void *)(a1 + 16) = v2;
  }
  if (v2 >= 2)
  {
    uint64_t v10 = 0;
    while (1)
    {
      int64_t v11 = v10 + 1;
      if (v10 + 1 < v2) {
        break;
      }
LABEL_33:
      ++v10;
      if (v11 >= v2)
      {
        *(void *)(a1 + 16) = v2;
        goto LABEL_35;
      }
    }
    int64x2_t v12 = (uint64_t *)(*(void *)(a1 + 32) + 16 * v10);
    uint64_t v14 = *v12;
    uint64_t v13 = v12[1];
    int64_t v15 = v10 + 1;
    while (1)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      int64x2_t v17 = (uint64_t *)(v16 + 16 * v15);
      uint64_t v19 = *v17;
      uint64_t v18 = v17[1];
      if (v14 == v19) {
        break;
      }
      if (v19 <= v13 + v14)
      {
        uint64_t v23 = v18 + v19;
        if (v23 > v13 + v14)
        {
          uint64_t v13 = v23 - v14;
          uint64_t v24 = (uint64_t *)(v16 + 16 * v10);
          v24[1] = v13;
          uint64_t v14 = *v24;
        }
        if (v15 + 1 < v2)
        {
          int64_t v25 = ~v15 + v2;
          uint64_t v26 = 16 * v15;
          do
          {
            *(_OWORD *)(*(void *)(a1 + 32) + v26) = *(_OWORD *)(*(void *)(a1 + 32) + v26 + 16);
            v26 += 16;
            --v25;
          }
          while (v25);
        }
        goto LABEL_31;
      }
      ++v15;
LABEL_32:
      if (v15 >= v2) {
        goto LABEL_33;
      }
    }
    if (v18 > v13)
    {
      uint64_t v20 = (uint64_t *)(v16 + 16 * v10);
      v20[1] = v18;
      uint64_t v14 = *v20;
      uint64_t v13 = v18;
    }
    if (v15 + 1 < v2)
    {
      int64_t v21 = ~v15 + v2;
      uint64_t v22 = 16 * v15;
      do
      {
        *(_OWORD *)(*(void *)(a1 + 32) + v22) = *(_OWORD *)(*(void *)(a1 + 32) + v22 + 16);
        v22 += 16;
        --v21;
      }
      while (v21);
    }
LABEL_31:
    --v2;
    goto LABEL_32;
  }
LABEL_35:
  *(unsigned char *)(a1 + 40) = 0;
}

uint64_t sortRangesByLocation(void *a1, void *a2)
{
  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

uint64_t CPIndexSetGetFirstIndex(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  if (*(unsigned char *)(a1 + 40)) {
    CPIndexSetNormalize(a1);
  }
  if (*(uint64_t *)(a1 + 16) < 1) {
    return -1;
  }
  else {
    return **(void **)(a1 + 32);
  }
}

uint64_t CPIndexSetGetLastIndex(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  if (*(unsigned char *)(a1 + 40)) {
    CPIndexSetNormalize(a1);
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 < 1) {
    return -1;
  }
  else {
    return *(void *)(*(void *)(a1 + 32) + 16 * v2 - 16) + *(void *)(*(void *)(a1 + 32) + 16 * v2 - 8) - 1;
  }
}

uint64_t CPIndexSetGetRange(uint64_t a1, uint64_t a2)
{
  uint64_t result = -1;
  if (a1 && (a2 & 0x8000000000000000) == 0)
  {
    if (*(unsigned char *)(a1 + 40)) {
      CPIndexSetNormalize(a1);
    }
    if (*(void *)(a1 + 16) <= a2) {
      return -1;
    }
    else {
      return *(void *)(*(void *)(a1 + 32) + 16 * a2);
    }
  }
  return result;
}

void CPIndexSetAddRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && (a2 & 0x8000000000000000) == 0 && (a3 & 0x8000000000000000) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 24);
    if (v6 >= v7)
    {
      *(void *)(a1 + 24) = v7 + 1;
      int64_t v9 = (char *)malloc_type_malloc(16 * (v7 + 1), 0x1000040451B5BE8uLL);
      uint64_t v8 = v9;
      if (*(uint64_t *)(a1 + 16) >= 1)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        do
        {
          *(_OWORD *)&v9[v10] = *(_OWORD *)(*(void *)(a1 + 32) + v10);
          ++v11;
          v10 += 16;
        }
        while (v11 < *(void *)(a1 + 16));
      }
      free(*(void **)(a1 + 32));
      *(void *)(a1 + 32) = v8;
      uint64_t v6 = *(void *)(a1 + 16);
    }
    else
    {
      uint64_t v8 = *(char **)(a1 + 32);
    }
    int64x2_t v12 = &v8[16 * v6];
    *(void *)int64x2_t v12 = a2;
    *((void *)v12 + 1) = a3;
    ++*(void *)(a1 + 16);
    *(unsigned char *)(a1 + 40) = 1;
  }
}

uint64_t get_unichars_for_glyph()
{
  return FPFontGetUnicharsForGlyph();
}

uint64_t can_create_ps_subset(uint64_t a1)
{
  return MEMORY[0x1F4119BA0](*(void *)(a1 + 8));
}

uint64_t create_ps_encoding(uint64_t a1)
{
  return MEMORY[0x1F4119C40](*(void *)(a1 + 8));
}

uint64_t create_ps_definition(uint64_t a1)
{
  return MEMORY[0x1F4119C48](*(void *)(a1 + 8));
}

uint64_t create_subset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6)
{
  unint64_t IndexVectorSize = CGFontIndexSetGetIndexVectorSize(a4);
  int NumberOfGlyphs = FPFontGetNumberOfGlyphs();
  if (IndexVectorSize <= (((NumberOfGlyphs + 31) >> 3) & 0x3FFCuLL)) {
    size_t v10 = ((NumberOfGlyphs + 31) >> 3) & 0x3FFCLL;
  }
  else {
    size_t v10 = IndexVectorSize;
  }
  uint64_t v11 = malloc_type_calloc(1uLL, v10, 0x13679333uLL);
  CGFontIndexSetGetIndexVector(a4, v11);
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, 0);
  uint64_t FontSubset = FPFontCreateFontSubset();
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count)
  {
    CFIndex v15 = Count;
    for (CFIndex i = 0; i != v15; ++i)
    {
      ValueAtIndedouble x = (unsigned __int16)CFArrayGetValueAtIndex(Mutable, i);
      CGFontIndexMapAddIndex(a6, ValueAtIndex, i);
    }
  }
  CFRelease(Mutable);
  free(v11);
  return FontSubset;
}

uint64_t get_subset_format(uint64_t a1)
{
  return MEMORY[0x1F4119DE8](*(void *)(a1 + 8));
}

uint64_t get_glyph_vertical_offsets(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1) {
    BOOL v4 = a2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  BOOL v5 = v4 || a4 == 0;
  int v6 = v5;
  if (!v5)
  {
    uint64_t v7 = a3;
    if (a3)
    {
      uint64_t v8 = a2;
      int64_t v9 = (void *)(a4 + 8);
      do
      {
        v8 += 2;
        FPFontGetGlyphVerticalTranslate();
        *(v9 - 1) = v10;
        *int64_t v9 = v11;
        v9 += 2;
        --v7;
      }
      while (v7);
    }
  }
  return v6 ^ 1u;
}

uint64_t get_glyph_vertical_advances(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = 0;
  if (a1)
  {
    int v6 = a4;
    if (a4)
    {
      uint64_t v7 = a3;
      uint64_t v8 = a2;
      if (a2 || !a3)
      {
        if (a3)
        {
          do
          {
            v8 += 2;
            FPFontGetGlyphIdealVerticalAdvanceWidth();
            *v6++ = (int)v9;
            --v7;
          }
          while (v7);
        }
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

BOOL get_glyph_name_for_glyph(uint64_t a1, uint64_t a2, char *a3, CFIndex a4)
{
  CFStringRef v6 = (const __CFString *)FPFontCopyGlyphNameForGlyph();
  if (!v6) {
    return 0;
  }
  CFStringRef v7 = v6;
  BOOL v8 = CFStringGetCString(v6, a3, a4, 0x600u) != 0;
  CFRelease(v7);
  return v8;
}

uint64_t get_glyph_name_max_length(uint64_t a1)
{
  return MEMORY[0x1F4119CC0](*(void *)(a1 + 8));
}

uint64_t get_glyphs_for_glyph_names(uint64_t a1)
{
  return MEMORY[0x1F4119CE8](*(void *)(a1 + 8));
}

uint64_t get_glyphs_X_o(uint64_t a1)
{
  return MEMORY[0x1F4119CF8](*(void *)(a1 + 8));
}

uint64_t get_cids_for_glyphs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4119C70](*(void *)(a1 + 8), a2, a4, a3);
}

uint64_t get_glyphs_for_cids(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4119CD0](*(void *)(a1 + 8), a2, a4, a3);
}

uint64_t get_truetype_encoding(uint64_t a1, int a2, int a3)
{
  if (a2 == 3 || a2 == 1 && !a3) {
    return MEMORY[0x1F4119D38](*(void *)(a1 + 8), (unsigned __int16)a2, (unsigned __int16)a3);
  }
  else {
    return 0;
  }
}

uint64_t get_type1_encoding(uint64_t a1)
{
  return MEMORY[0x1F4119D40](*(void *)(a1 + 8));
}

uint64_t copy_registry_ordering_supplement(uint64_t a1)
{
  return MEMORY[0x1F4119BF8](*(void *)(a1 + 8));
}

uint64_t copy_family_name(uint64_t a1)
{
  return MEMORY[0x1F4119BB0](*(void *)(a1 + 8));
}

uint64_t copy_full_name(uint64_t a1)
{
  return MEMORY[0x1F4119BB8](*(void *)(a1 + 8));
}

double get_stems(uint64_t a1, double *a2, double *a3)
{
  *a2 = (double)(int)FPFontGetStemV();
  double result = (double)(int)FPFontGetStemH();
  *a3 = result;
  return result;
}

double get_vertical_metrics(uint64_t a1, _OWORD *a2)
{
  if (FPFontGetVMetrics())
  {
    double result = 0.0;
    *a2 = 0u;
  }
  return result;
}

uint64_t get_font_info_21350(uint64_t a1, uint64_t a2)
{
  memset(v5, 0, 40);
  uint64_t FontInfo = FPFontGetFontInfo();
  if (FontInfo)
  {
    *(void *)a2 = *(void *)&v5[0];
    *(_WORD *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 8) = *(_OWORD *)((char *)v5 + 8);
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 56) = 0;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)&v5[1] + 8);
    *(unsigned char *)(a2 + 104) = FPFontIsBitmapOnly();
  }
  return FontInfo;
}

atomic_ullong *retain_private_data(atomic_ullong *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1uLL, memory_order_relaxed);
  }
  return result;
}

CFArrayRef create_private_data_array_from_data()
{
  CFArrayRef result = (const __CFArray *)FPFontCreateFontsFromData();
  if (result)
  {
    CFArrayRef v1 = result;
    private_data_array_with_parser_fonts = create_private_data_array_with_parser_fonts(result);
    CFRelease(v1);
    return private_data_array_with_parser_fonts;
  }
  return result;
}

__CFArray *create_private_data_array_with_parser_fonts(const __CFArray *a1)
{
  uint64_t Count = CFArrayGetCount(a1);
  CFArrayRef Mutable = CFArrayCreateMutable(0, Count, &xt_font_cfarray_callbacks);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFArrayGetValueAtIndex(a1, i);
      uint64_t v5 = FPFontRetain();
      CFStringRef v6 = malloc_type_calloc(1uLL, 0x20uLL, 0x1060040D8C947D5uLL);
      *CFStringRef v6 = 1;
      v6[1] = v5;
      CFArrayAppendValue(Mutable, v6);
      xt_font_release((uint64_t)v6);
    }
  }
  return Mutable;
}

uint64_t create_private_data_with_name()
{
  return 0;
}

uint64_t create_private_data_with_platform_font()
{
  return 0;
}

void *create_private_data_with_parser_font()
{
  uint64_t v0 = FPFontRetain();
  CFArrayRef result = malloc_type_calloc(1uLL, 0x20uLL, 0x1060040D8C947D5uLL);
  void *result = 1;
  result[1] = v0;
  return result;
}

uint64_t get_font_finder()
{
  return font_finder;
}

int *rgba32_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t v72 = *(void *)(a1 + 80);
  int v75 = *(int **)(a1 + 88);
  uint64_t v82 = *(void *)(a1 + 112);
  uint64_t v81 = *(void *)(a1 + 120);
  int v71 = *(_DWORD *)(a1 + 188);
  uint64_t v16 = (int *)(*(void *)(a1 + 152) - 4);
  uint64_t v76 = *(void *)(a1 + 144) - 1;
  int v79 = *(_DWORD *)(a1 + 24);
  uint64_t v80 = *(void *)(a1 + 40);
  uint64_t v77 = *(void *)(a1 + 32);
  unint64_t v17 = v77 + ((*(_DWORD *)(a1 + 260) - 1) * v79) + 4 * (4 * *(_DWORD *)(a1 + 256)) - 16;
  uint64_t v73 = *(void *)(a1 + 64);
  uint64_t v74 = *(void *)(a1 + 72);
  unint64_t v78 = v17;
  while (1)
  {
    if (a3 >= v74)
    {
      CFArrayRef result = v75;
      if (a3 <= (uint64_t)v75)
      {
        uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v30 = 0x3FFFFFFF;
        HIDWORD(v31) = HIDWORD(a3);
        int v21 = a4;
        uint64_t v22 = v73;
      }
      else
      {
        uint64_t v25 = *(void *)(a1 + 216);
        uint64_t v26 = (char *)v75 + *(void *)(a1 + 224);
        uint64_t v27 = (uint64_t)&v26[(v25 >> 1) - a3];
        int v21 = a4;
        uint64_t v22 = v73;
        if (v27 < 1) {
          goto LABEL_34;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(a1 + 232) * v27) >> 32;
        }
        unsigned int v30 = v71 | v28;
        uint64_t v31 = v26 - 0x1000000;
        uint64_t v29 = 448;
      }
    }
    else
    {
      uint64_t v18 = *(void *)(a1 + 216);
      uint64_t v19 = v74 - *(void *)(a1 + 224);
      uint64_t v20 = a3 - v19 + (v18 >> 1);
      int v21 = a4;
      uint64_t v22 = v73;
      CFArrayRef result = v75;
      if (v20 < 1) {
        goto LABEL_34;
      }
      if (v20 >= v18) {
        LODWORD(v24) = 0x3FFFFFFF;
      }
      else {
        unint64_t v24 = (unint64_t)(*(void *)(a1 + 232) * v20) >> 32;
      }
      unsigned int v30 = v71 | v24;
      uint64_t v31 = (char *)(v19 + 0x1000000);
      uint64_t v29 = 512;
    }
    if (a2 >= v22)
    {
      if (a2 <= v72)
      {
        uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v35 = a2;
      }
      else
      {
        uint64_t v37 = *(void *)(a1 + 192);
        uint64_t v38 = *(void *)(a1 + 200) + v72;
        uint64_t v39 = v38 - a2 + (v37 >> 1);
        if (v39 < 1) {
          goto LABEL_34;
        }
        if (v39 < v37) {
          unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v39) >> 32) >> 15)) | v71;
        }
        uint64_t v35 = v38 - 0x1000000;
        uint64_t v36 = 28;
      }
    }
    else
    {
      uint64_t v32 = *(void *)(a1 + 192);
      uint64_t v33 = v22 - *(void *)(a1 + 200);
      uint64_t v34 = a2 - v33 + (v32 >> 1);
      if (v34 < 1) {
        goto LABEL_34;
      }
      if (v34 < v32) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v34) >> 32) >> 15)) | v71;
      }
      uint64_t v35 = v33 + 0x1000000;
      uint64_t v36 = 32;
    }
    if (v30 >= 0x400000) {
      break;
    }
LABEL_34:
    int v44 = v21 - 1;
    a2 += v82;
    a3 += v81;
    ++v16;
    *(unsigned char *)++uint64_t v76 = 0;
LABEL_35:
    a4 = v44;
    if (!v44) {
      return result;
    }
  }
  unint64_t v40 = v77 + SHIDWORD(v31) * (uint64_t)v79 + 16 * (v35 >> 32);
  unint64_t v41 = *(float32x2_t **)(a1 + 32);
  if (v17 >= v40) {
    unint64_t v42 = (float32x2_t *)v40;
  }
  else {
    unint64_t v42 = (float32x2_t *)v17;
  }
  if (v42 < v41) {
    unint64_t v42 = *(float32x2_t **)(a1 + 32);
  }
  if (v80) {
    float v43 = v42[1].f32[1];
  }
  else {
    float v43 = 1.0;
  }
  float32x2_t v45 = *v42;
  float v46 = v42[1].f32[0];
  if (v15)
  {
    unsigned int v47 = *(_DWORD *)(v15 + (v36 | v29));
LABEL_41:
    int v48 = v47 & 0xF;
    int v49 = HIBYTE(v47) & 3;
    if (v48 == 1)
    {
      CGAffineTransform v57 = (float32x2_t *)(v40 + SBYTE1(v47) * (uint64_t)v79);
      if (v17 < (unint64_t)v57) {
        CGAffineTransform v57 = (float32x2_t *)v17;
      }
      if (v57 >= v41) {
        unint64_t v41 = v57;
      }
      float32x2_t v58 = *v41;
      float v59 = v41[1].f32[0];
      float v60 = 1.0;
      if (v80) {
        float v60 = v41[1].f32[1];
      }
      CGRect v61 = &interpolate_rgbaf_21353[4 * v49];
    }
    else
    {
      if (v48 != 2)
      {
        if (v48 == 3)
        {
          uint64_t v50 = SBYTE1(v47) * (uint64_t)v79;
          uint64_t v51 = 16 * SBYTE2(v47);
          unint64_t v52 = (float32x2_t *)(v40 + v51);
          if (v17 < v40 + v51) {
            unint64_t v52 = (float32x2_t *)v17;
          }
          if (v52 < v41) {
            unint64_t v52 = v41;
          }
          float32x2_t v53 = *v52;
          if (v80)
          {
            float v54 = v52[1].f32[1];
            long long v55 = (float32x2_t *)(v40 + v50 + v51);
            if (v17 < (unint64_t)v55) {
              long long v55 = (float32x2_t *)v17;
            }
            if (v55 >= v41) {
              unint64_t v41 = v55;
            }
            float v56 = v41[1].f32[1];
          }
          else
          {
            long long v63 = (float32x2_t *)(v40 + v50 + v51);
            if (v17 < (unint64_t)v63) {
              long long v63 = (float32x2_t *)v17;
            }
            if (v63 >= v41) {
              unint64_t v41 = v63;
            }
            float v54 = 1.0;
            float v56 = 1.0;
          }
          v11.i32[0] = interpolate_rgbaf_21353[4 * v49 + 3];
          v12.i32[0] = interpolate_rgbaf_21353[4 * ((v47 >> 28) & 3) + 3];
          float v46 = (float)((float)((float)(v46 - (float)(v46 * v11.f32[0])) + (float)(v52[1].f32[0] * v11.f32[0]))
                      - (float)((float)((float)(v46 - (float)(v46 * v11.f32[0])) + (float)(v52[1].f32[0] * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v52[1].f32[0] - (float)(v52[1].f32[0] * v11.f32[0]))
                              + (float)(v41[1].f32[0] * v11.f32[0]))
                      * v12.f32[0]);
          float32x2_t v64 = vmla_n_f32(vmls_lane_f32(v45, v45, v11, 0), v53, v11.f32[0]);
          float32x2_t v45 = vmla_n_f32(vmls_lane_f32(v64, v64, v12, 0), vmla_n_f32(vmls_lane_f32(v53, v53, v11, 0), *v41, v11.f32[0]), v12.f32[0]);
          float v43 = (float)((float)((float)(v43 - (float)(v43 * v11.f32[0])) + (float)(v54 * v11.f32[0]))
                      - (float)((float)((float)(v43 - (float)(v43 * v11.f32[0])) + (float)(v54 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v54 - (float)(v54 * v11.f32[0])) + (float)(v56 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_75;
      }
      CGRect v62 = (float32x2_t *)(v40 + ((uint64_t)((unint64_t)HIWORD(v47) << 56) >> 52));
      if (v17 < (unint64_t)v62) {
        CGRect v62 = (float32x2_t *)v17;
      }
      if (v62 >= v41) {
        unint64_t v41 = v62;
      }
      float32x2_t v58 = *v41;
      float v59 = v41[1].f32[0];
      float v60 = 1.0;
      if (v80) {
        float v60 = v41[1].f32[1];
      }
      CGRect v61 = &interpolate_rgbaf_21353[4 * ((v47 >> 28) & 3)];
    }
    LODWORD(a11) = v61[3];
    float32x2_t v45 = vmla_n_f32(vmls_lane_f32(v45, v45, *(float32x2_t *)&a11, 0), v58, *(float *)&a11);
    float v46 = (float)(v46 - (float)(v46 * *(float *)&a11)) + (float)(v59 * *(float *)&a11);
    float v43 = (float)(v43 - (float)(v43 * *(float *)&a11)) + (float)(v60 * *(float *)&a11);
  }
LABEL_75:
  uint64_t v65 = 0;
  ++v16;
  int v70 = v21;
  int v66 = v21 - 1;
  a3 += v81;
  unint64_t v67 = (unint64_t)result - a3;
  a2 += v82;
  uint64_t v68 = v72 - a2;
  while (1)
  {
    CFArrayRef result = RGBAF_21354(v16, v45.f32[0], v45.f32[1], v46, v43);
    *(unsigned char *)(v76 + 1 + v65) = v30 >> 22;
    unint64_t v17 = v78;
    if (v66 == v65) {
      return result;
    }
    if (((v67 | v68 | (a3 - v74) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v76 += v65 + 1;
      int v44 = ~v65 + v70;
      goto LABEL_35;
    }
    unint64_t v40 = v77 + SHIDWORD(a3) * (uint64_t)v79 + 16 * (a2 >> 32);
    unint64_t v41 = *(float32x2_t **)(a1 + 32);
    if (v78 >= v40) {
      unint64_t v69 = v77 + SHIDWORD(a3) * (uint64_t)v79 + 16 * (a2 >> 32);
    }
    else {
      unint64_t v69 = v78;
    }
    if (v69 < (unint64_t)v41) {
      unint64_t v69 = *(void *)(a1 + 32);
    }
    if (v80) {
      float v43 = *(float *)(v69 + 12);
    }
    else {
      float v43 = 1.0;
    }
    float32x2_t v45 = *(float32x2_t *)v69;
    float v46 = *(float *)(v69 + 8);
    if (v15)
    {
      unsigned int v47 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v47 & 0xF) != 0)
      {
        CFArrayRef result = v75;
        v76 += v65 + 1;
        int v21 = ~v65 + v70;
        unsigned int v30 = -1;
        goto LABEL_41;
      }
    }
    ++v16;
    ++v65;
    a3 += v81;
    v67 -= v81;
    a2 += v82;
    v68 -= v82;
    unsigned int v30 = -1;
  }
}

int *RGBAF_21354(int *result, float a2, float a3, float a4, float a5)
{
  if (a5 <= 0.0)
  {
    int v9 = 0;
  }
  else
  {
    int v5 = (int)(float)((float)(a5 * 255.0) + 0.5);
    if (a5 > 1.0)
    {
      int v5 = 255;
      a5 = 1.0;
    }
    int v6 = (int)(float)((float)(a2 * 255.0) + 0.5);
    if (a2 < 0.0) {
      int v6 = 0;
    }
    if (a2 > a5) {
      int v6 = v5;
    }
    int v7 = (int)(float)((float)(a3 * 255.0) + 0.5);
    if (a3 < 0.0) {
      int v7 = 0;
    }
    if (a3 > a5) {
      int v7 = v5;
    }
    int v8 = (int)(float)((float)(a4 * 255.0) + 0.5);
    if (a4 < 0.0) {
      int v8 = 0;
    }
    if (a4 > a5) {
      int v8 = v5;
    }
    int v9 = (v6 << 24) | (v7 << 16) | (v8 << 8) | v5;
  }
  int *result = v9;
  return result;
}

int *rgba32_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t v71 = *(void *)(a1 + 80);
  uint64_t v74 = *(int **)(a1 + 88);
  uint64_t v81 = *(void *)(a1 + 112);
  uint64_t v80 = *(void *)(a1 + 120);
  int v70 = *(_DWORD *)(a1 + 188);
  uint64_t v16 = (int *)(*(void *)(a1 + 152) - 4);
  uint64_t v75 = *(void *)(a1 + 144) - 1;
  uint64_t v79 = *(void *)(a1 + 40);
  uint64_t v76 = *(void *)(a1 + 32);
  int v77 = *(_DWORD *)(a1 + 24);
  unint64_t v78 = v76 + ((*(_DWORD *)(a1 + 260) - 1) * v77) + 4 * (4 * *(_DWORD *)(a1 + 256)) - 16;
  uint64_t v72 = *(void *)(a1 + 72);
  uint64_t v73 = *(void *)(a1 + 64);
  while (1)
  {
    if (a3 >= v72)
    {
      CFArrayRef result = v74;
      if (a3 <= (uint64_t)v74)
      {
        uint64_t v28 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v29 = 0x3FFFFFFF;
        HIDWORD(v30) = HIDWORD(a3);
        int v20 = a4;
        uint64_t v22 = v73;
      }
      else
      {
        uint64_t v24 = *(void *)(a1 + 216);
        uint64_t v25 = (char *)v74 + *(void *)(a1 + 224);
        uint64_t v26 = (uint64_t)&v25[(v24 >> 1) - a3];
        int v20 = a4;
        uint64_t v22 = v73;
        if (v26 < 1) {
          goto LABEL_33;
        }
        if (v26 >= v24) {
          LODWORD(v27) = 0x3FFFFFFF;
        }
        else {
          unint64_t v27 = (unint64_t)(*(void *)(a1 + 232) * v26) >> 32;
        }
        unsigned int v29 = v70 | v27;
        unsigned int v30 = v25 - 0x1000000;
        uint64_t v28 = 448;
      }
    }
    else
    {
      uint64_t v17 = *(void *)(a1 + 216);
      uint64_t v18 = v72 - *(void *)(a1 + 224);
      uint64_t v19 = a3 - v18 + (v17 >> 1);
      int v20 = a4;
      uint64_t v22 = v73;
      CFArrayRef result = v74;
      if (v19 < 1) {
        goto LABEL_33;
      }
      if (v19 >= v17) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(a1 + 232) * v19) >> 32;
      }
      unsigned int v29 = v70 | v23;
      unsigned int v30 = (char *)(v18 + 0x1000000);
      uint64_t v28 = 512;
    }
    if (a2 >= v22)
    {
      if (a2 <= v71)
      {
        uint64_t v35 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v34 = a2;
      }
      else
      {
        uint64_t v36 = *(void *)(a1 + 192);
        uint64_t v37 = *(void *)(a1 + 200) + v71;
        uint64_t v38 = v37 - a2 + (v36 >> 1);
        if (v38 < 1) {
          goto LABEL_33;
        }
        if (v38 < v36) {
          unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v38) >> 32) >> 15)) | v70;
        }
        uint64_t v34 = v37 - 0x1000000;
        uint64_t v35 = 28;
      }
    }
    else
    {
      uint64_t v31 = *(void *)(a1 + 192);
      uint64_t v32 = v22 - *(void *)(a1 + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 < 1) {
        goto LABEL_33;
      }
      if (v33 < v31) {
        unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v33) >> 32) >> 15)) | v70;
      }
      uint64_t v34 = v32 + 0x1000000;
      uint64_t v35 = 32;
    }
    if (v29 >= 0x400000) {
      break;
    }
LABEL_33:
    int v43 = v20 - 1;
    a2 += v81;
    a3 += v80;
    ++v16;
    *(unsigned char *)++uint64_t v75 = 0;
LABEL_34:
    a4 = v43;
    if (!v43) {
      return result;
    }
  }
  unint64_t v39 = v76 + SHIDWORD(v30) * (uint64_t)v77 + 16 * (v34 >> 32);
  unint64_t v40 = *(int8x8_t **)(a1 + 32);
  unint64_t v41 = (int8x8_t *)v78;
  if (v78 >= v39) {
    unint64_t v41 = (int8x8_t *)v39;
  }
  if (v41 < v40) {
    unint64_t v41 = *(int8x8_t **)(a1 + 32);
  }
  if (v79) {
    float v42 = COERCE_FLOAT(bswap32(v41[1].u32[1]));
  }
  else {
    float v42 = 1.0;
  }
  float32x2_t v44 = (float32x2_t)vrev32_s8(*v41);
  float v45 = COERCE_FLOAT(bswap32(v41[1].u32[0]));
  if (v15)
  {
    unsigned int v46 = *(_DWORD *)(v15 + (v35 | v28));
LABEL_40:
    int v47 = v46 & 0xF;
    int v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      float32x2_t v58 = (int8x8_t *)(v39 + SBYTE1(v46) * (uint64_t)v77);
      if (v78 < (unint64_t)v58) {
        float32x2_t v58 = (int8x8_t *)v78;
      }
      if (v58 >= v40) {
        unint64_t v40 = v58;
      }
      float32x2_t v59 = (float32x2_t)vrev32_s8(*v40);
      float v60 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
      float v61 = 1.0;
      if (v79) {
        float v61 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
      }
      CGRect v62 = &interpolate_rgbaf_21353[4 * v48];
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          int v49 = (int8x8_t *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 52));
          if (v78 < (unint64_t)v49) {
            int v49 = (int8x8_t *)v78;
          }
          if (v49 < v40) {
            int v49 = v40;
          }
          float32x2_t v50 = (float32x2_t)vrev32_s8(*v49);
          float v51 = COERCE_FLOAT(bswap32(v49[1].u32[0]));
          float v52 = 1.0;
          float v53 = 1.0;
          if (v79) {
            float v53 = COERCE_FLOAT(bswap32(v49[1].u32[1]));
          }
          unint64_t v54 = v39 + SBYTE1(v46) * (uint64_t)v77 + 16 * SBYTE2(v46);
          if (v78 < v54) {
            unint64_t v54 = v78;
          }
          if (v54 >= (unint64_t)v40) {
            unint64_t v40 = (int8x8_t *)v54;
          }
          float32x2_t v55 = (float32x2_t)vrev32_s8(*v40);
          float v56 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
          if (v79) {
            float v52 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
          }
          v11.i32[0] = interpolate_rgbaf_21353[4 * v48 + 3];
          v12.i32[0] = interpolate_rgbaf_21353[4 * ((v46 >> 28) & 3) + 3];
          float v45 = (float)((float)((float)(v45 - (float)(v45 * v11.f32[0])) + (float)(v51 * v11.f32[0]))
                      - (float)((float)((float)(v45 - (float)(v45 * v11.f32[0])) + (float)(v51 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v51 - (float)(v51 * v11.f32[0])) + (float)(v56 * v11.f32[0])) * v12.f32[0]);
          float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v44, v44, v11, 0), v50, v11.f32[0]);
          float32x2_t v44 = vmla_n_f32(vmls_lane_f32(v57, v57, v12, 0), vmla_n_f32(vmls_lane_f32(v50, v50, v11, 0), v55, v11.f32[0]), v12.f32[0]);
          float v42 = (float)((float)((float)(v42 - (float)(v42 * v11.f32[0])) + (float)(v53 * v11.f32[0]))
                      - (float)((float)((float)(v42 - (float)(v42 * v11.f32[0])) + (float)(v53 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v53 - (float)(v53 * v11.f32[0])) + (float)(v52 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_71;
      }
      long long v63 = (int8x8_t *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 52));
      if (v78 < (unint64_t)v63) {
        long long v63 = (int8x8_t *)v78;
      }
      if (v63 >= v40) {
        unint64_t v40 = v63;
      }
      float32x2_t v59 = (float32x2_t)vrev32_s8(*v40);
      float v60 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
      float v61 = 1.0;
      if (v79) {
        float v61 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
      }
      CGRect v62 = &interpolate_rgbaf_21353[4 * ((v46 >> 28) & 3)];
    }
    LODWORD(a11) = v62[3];
    float32x2_t v44 = vmla_n_f32(vmls_lane_f32(v44, v44, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
    float v45 = (float)(v45 - (float)(v45 * *(float *)&a11)) + (float)(v60 * *(float *)&a11);
    float v42 = (float)(v42 - (float)(v42 * *(float *)&a11)) + (float)(v61 * *(float *)&a11);
  }
LABEL_71:
  uint64_t v64 = 0;
  ++v16;
  int v69 = v20;
  int v65 = v20 - 1;
  a3 += v80;
  unint64_t v66 = (unint64_t)result - a3;
  a2 += v81;
  uint64_t v67 = v71 - a2;
  while (1)
  {
    CFArrayRef result = RGBAF_21354(v16, v44.f32[0], v44.f32[1], v45, v42);
    *(unsigned char *)(v75 + 1 + v64) = v29 >> 22;
    if (v65 == v64) {
      return result;
    }
    if (((v66 | v67 | (a3 - v72) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v75 += v64 + 1;
      int v43 = ~v64 + v69;
      goto LABEL_34;
    }
    unint64_t v39 = v76 + SHIDWORD(a3) * (uint64_t)v77 + 16 * (a2 >> 32);
    unint64_t v40 = *(int8x8_t **)(a1 + 32);
    uint64_t v68 = (int8x8_t *)v78;
    if (v78 >= v39) {
      uint64_t v68 = (int8x8_t *)(v76 + SHIDWORD(a3) * (uint64_t)v77 + 16 * (a2 >> 32));
    }
    if (v68 < v40) {
      uint64_t v68 = *(int8x8_t **)(a1 + 32);
    }
    if (v79) {
      float v42 = COERCE_FLOAT(bswap32(v68[1].u32[1]));
    }
    else {
      float v42 = 1.0;
    }
    float32x2_t v44 = (float32x2_t)vrev32_s8(*v68);
    float v45 = COERCE_FLOAT(bswap32(v68[1].u32[0]));
    if (v15)
    {
      unsigned int v46 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        CFArrayRef result = v74;
        v75 += v64 + 1;
        int v20 = ~v64 + v69;
        unsigned int v29 = -1;
        goto LABEL_40;
      }
    }
    ++v16;
    ++v64;
    a3 += v80;
    v66 -= v80;
    a2 += v81;
    v67 -= v81;
    unsigned int v29 = -1;
  }
}

int *rgba32_sample_RGBf(int *result, unint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v12 = *((void *)result + 22);
  uint64_t v59 = *((void *)result + 10);
  uint64_t v62 = *((void *)result + 11);
  uint64_t v67 = *((void *)result + 15);
  uint64_t v68 = *((void *)result + 14);
  uint64_t v13 = (int *)(*((void *)result + 19) - 4);
  uint64_t v63 = *((void *)result + 18) - 1;
  uint64_t v64 = *((void *)result + 4);
  int v65 = result[6];
  int v69 = result;
  int v58 = result[47];
  unint64_t v66 = v64 + ((result[65] - 1) * v65) + 4 * (3 * result[64]) - 16;
  uint64_t v60 = *((void *)result + 8);
  uint64_t v61 = *((void *)result + 9);
  while (1)
  {
    if ((uint64_t)a3 >= v61)
    {
      if ((uint64_t)a3 <= v62)
      {
        uint64_t v24 = (a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        int v17 = a4;
        uint64_t v18 = v60;
      }
      else
      {
        uint64_t v20 = *((void *)v69 + 27);
        uint64_t v21 = *((void *)v69 + 28) + v62;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        int v17 = a4;
        uint64_t v18 = v60;
        if (v22 < 1) {
          goto LABEL_33;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*((void *)v69 + 29) * v22) >> 32;
        }
        unsigned int v25 = v58 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v14 = *((void *)v69 + 27);
      uint64_t v15 = v61 - *((void *)v69 + 28);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      int v17 = a4;
      uint64_t v18 = v60;
      if (v16 < 1) {
        goto LABEL_33;
      }
      if (v16 >= v14) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*((void *)v69 + 29) * v16) >> 32;
      }
      unsigned int v25 = v58 | v19;
      uint64_t v26 = v15 + 0x1000000;
      uint64_t v24 = 512;
    }
    if ((uint64_t)a2 >= v18)
    {
      if ((uint64_t)a2 <= v59)
      {
        uint64_t v31 = (a2 >> 26) & 0x3C;
        HIDWORD(v30) = HIDWORD(a2);
      }
      else
      {
        uint64_t v32 = *((void *)v69 + 24);
        uint64_t v33 = *((void *)v69 + 25) + v59;
        uint64_t v34 = v33 - a2 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_33;
        }
        if (v34 < v32) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v69 + 26) * v34) >> 32) >> 15)) | v58;
        }
        uint64_t v30 = v33 - 0x1000000;
        uint64_t v31 = 28;
      }
    }
    else
    {
      uint64_t v27 = *((void *)v69 + 24);
      uint64_t v28 = v18 - *((void *)v69 + 25);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 < 1) {
        goto LABEL_33;
      }
      if (v29 < v27) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v69 + 26) * v29) >> 32) >> 15)) | v58;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
    }
    if (v25 >= 0x400000) {
      break;
    }
LABEL_33:
    int v41 = v17 - 1;
    a2 += v68;
    a3 += v67;
    ++v13;
    *(unsigned char *)++uint64_t v63 = 0;
LABEL_34:
    a4 = v41;
    if (!v41) {
      return result;
    }
  }
  unint64_t v35 = v64 + SHIDWORD(v26) * (uint64_t)v65 + 12 * SHIDWORD(v30);
  uint64_t v36 = (float32x2_t *)*((void *)v69 + 4);
  uint64_t v37 = (float32x2_t *)v66;
  if (v66 >= v35) {
    uint64_t v37 = (float32x2_t *)v35;
  }
  if (v37 < v36) {
    uint64_t v37 = (float32x2_t *)*((void *)v69 + 4);
  }
  float32x2_t v38 = *v37;
  float v39 = v37[1].f32[0];
  if (!v12) {
    goto LABEL_36;
  }
  unsigned int v40 = *(_DWORD *)(v12 + (v31 | v24));
LABEL_38:
  int v42 = v40 & 0xF;
  int v43 = HIBYTE(v40) & 3;
  if (v42 == 1)
  {
    int v48 = (float32x2_t *)(v35 + SBYTE1(v40) * (uint64_t)v65);
    if (v66 < (unint64_t)v48) {
      int v48 = (float32x2_t *)v66;
    }
    if (v48 >= v36) {
      uint64_t v36 = v48;
    }
    float v49 = v36[1].f32[0];
    float32x2_t v50 = &interpolate_rgbaf_21353[4 * v43];
    goto LABEL_61;
  }
  if (v42 == 2)
  {
    float v51 = (float32x2_t *)(v35 + 12 * SBYTE2(v40));
    if (v66 < (unint64_t)v51) {
      float v51 = (float32x2_t *)v66;
    }
    if (v51 >= v36) {
      uint64_t v36 = v51;
    }
    float v49 = v36[1].f32[0];
    float32x2_t v50 = &interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3)];
LABEL_61:
    LODWORD(a8) = v50[3];
    float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a8, 0), *v36, *(float *)&a8);
    float v39 = (float)(v39 - (float)(v39 * *(float *)&a8)) + (float)(v49 * *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 + (float)(1.0 - *(float *)&a8);
    goto LABEL_62;
  }
  if (v42 != 3)
  {
LABEL_36:
    LODWORD(a8) = 1.0;
    goto LABEL_62;
  }
  float32x2_t v44 = (float32x2_t *)(v35 + 12 * SBYTE2(v40));
  if (v66 >= (unint64_t)v44) {
    float v45 = v44;
  }
  else {
    float v45 = (float32x2_t *)v66;
  }
  if (v45 < v36) {
    float v45 = v36;
  }
  unsigned int v46 = (float32x2_t *)((char *)v44 + SBYTE1(v40) * (uint64_t)v65);
  if (v66 < (unint64_t)v46) {
    unsigned int v46 = (float32x2_t *)v66;
  }
  if (v46 >= v36) {
    uint64_t v36 = v46;
  }
  LODWORD(a9) = interpolate_rgbaf_21353[4 * v43 + 3];
  LODWORD(a10) = interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3) + 3];
  float v39 = (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v45[1].f32[0] * *(float *)&a9))
              - (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v45[1].f32[0] * *(float *)&a9))
                      * *(float *)&a10))
      + (float)((float)((float)(v45[1].f32[0] - (float)(v45[1].f32[0] * *(float *)&a9))
                      + (float)(v36[1].f32[0] * *(float *)&a9))
              * *(float *)&a10);
  float32x2_t v47 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a9, 0), *v45, *(float *)&a9);
  float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v47, v47, *(float32x2_t *)&a10, 0), vmla_n_f32(vmls_lane_f32(*v45, *v45, *(float32x2_t *)&a9, 0), *v36, *(float *)&a9), *(float *)&a10);
  *(float *)&a8 = (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9))
                        - (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10))
                + (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10);
LABEL_62:
  uint64_t v52 = 0;
  ++v13;
  int v57 = v17;
  int v53 = v17 - 1;
  a3 += v67;
  uint64_t v54 = v62 - a3;
  a2 += v68;
  uint64_t v55 = v59 - a2;
  while (1)
  {
    CFArrayRef result = RGBAF_21354(v13, v38.f32[0], v38.f32[1], v39, *(float *)&a8);
    *(unsigned char *)(v63 + 1 + v52) = v25 >> 22;
    if (v53 == v52) {
      return result;
    }
    if (((v54 | v55 | (a3 - v61) | (a2 - v60)) & 0x8000000000000000) != 0)
    {
      v63 += v52 + 1;
      int v41 = ~v52 + v57;
      goto LABEL_34;
    }
    unint64_t v35 = v64 + SHIDWORD(a3) * (uint64_t)v65 + 12 * SHIDWORD(a2);
    uint64_t v36 = (float32x2_t *)*((void *)v69 + 4);
    unint64_t v56 = v66;
    if (v66 >= v35) {
      unint64_t v56 = v64 + SHIDWORD(a3) * (uint64_t)v65 + 12 * SHIDWORD(a2);
    }
    if (v56 < (unint64_t)v36) {
      unint64_t v56 = *((void *)v69 + 4);
    }
    float32x2_t v38 = *(float32x2_t *)v56;
    float v39 = *(float *)(v56 + 8);
    if (v12)
    {
      unsigned int v40 = *(_DWORD *)(v12 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v63 += v52 + 1;
        int v17 = ~v52 + v57;
        unsigned int v25 = -1;
        goto LABEL_38;
      }
    }
    ++v52;
    ++v13;
    a3 += v67;
    v54 -= v67;
    a2 += v68;
    v55 -= v68;
    LODWORD(a8) = 1.0;
    unsigned int v25 = -1;
  }
}

int *rgba32_sample_RGBF(int *result, unint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v12 = *((void *)result + 22);
  uint64_t v60 = *((void *)result + 10);
  uint64_t v63 = *((void *)result + 11);
  uint64_t v68 = *((void *)result + 15);
  uint64_t v69 = *((void *)result + 14);
  uint64_t v13 = (int *)(*((void *)result + 19) - 4);
  uint64_t v64 = *((void *)result + 18) - 1;
  uint64_t v65 = *((void *)result + 4);
  int v66 = result[6];
  int v70 = result;
  int v59 = result[47];
  unint64_t v67 = v65 + ((result[65] - 1) * v66) + 4 * (3 * result[64]) - 16;
  uint64_t v61 = *((void *)result + 8);
  uint64_t v62 = *((void *)result + 9);
  while (1)
  {
    if ((uint64_t)a3 >= v62)
    {
      if ((uint64_t)a3 <= v63)
      {
        uint64_t v24 = (a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        int v17 = a4;
        uint64_t v18 = v61;
      }
      else
      {
        uint64_t v20 = *((void *)v70 + 27);
        uint64_t v21 = *((void *)v70 + 28) + v63;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        int v17 = a4;
        uint64_t v18 = v61;
        if (v22 < 1) {
          goto LABEL_33;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*((void *)v70 + 29) * v22) >> 32;
        }
        unsigned int v25 = v59 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v14 = *((void *)v70 + 27);
      uint64_t v15 = v62 - *((void *)v70 + 28);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      int v17 = a4;
      uint64_t v18 = v61;
      if (v16 < 1) {
        goto LABEL_33;
      }
      if (v16 >= v14) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*((void *)v70 + 29) * v16) >> 32;
      }
      unsigned int v25 = v59 | v19;
      uint64_t v26 = v15 + 0x1000000;
      uint64_t v24 = 512;
    }
    if ((uint64_t)a2 >= v18)
    {
      if ((uint64_t)a2 <= v60)
      {
        uint64_t v31 = (a2 >> 26) & 0x3C;
        HIDWORD(v30) = HIDWORD(a2);
      }
      else
      {
        uint64_t v32 = *((void *)v70 + 24);
        uint64_t v33 = *((void *)v70 + 25) + v60;
        uint64_t v34 = v33 - a2 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_33;
        }
        if (v34 < v32) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v70 + 26) * v34) >> 32) >> 15)) | v59;
        }
        uint64_t v30 = v33 - 0x1000000;
        uint64_t v31 = 28;
      }
    }
    else
    {
      uint64_t v27 = *((void *)v70 + 24);
      uint64_t v28 = v18 - *((void *)v70 + 25);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 < 1) {
        goto LABEL_33;
      }
      if (v29 < v27) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v70 + 26) * v29) >> 32) >> 15)) | v59;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
    }
    if (v25 >= 0x400000) {
      break;
    }
LABEL_33:
    int v41 = v17 - 1;
    a2 += v69;
    a3 += v68;
    ++v13;
    *(unsigned char *)++uint64_t v64 = 0;
LABEL_34:
    a4 = v41;
    if (!v41) {
      return result;
    }
  }
  unint64_t v35 = v65 + SHIDWORD(v26) * (uint64_t)v66 + 12 * SHIDWORD(v30);
  uint64_t v36 = (int8x8_t *)*((void *)v70 + 4);
  uint64_t v37 = (int8x8_t *)v67;
  if (v67 >= v35) {
    uint64_t v37 = (int8x8_t *)v35;
  }
  if (v37 < v36) {
    uint64_t v37 = (int8x8_t *)*((void *)v70 + 4);
  }
  float32x2_t v38 = (float32x2_t)vrev32_s8(*v37);
  float v39 = COERCE_FLOAT(bswap32(v37[1].u32[0]));
  if (!v12) {
    goto LABEL_36;
  }
  unsigned int v40 = *(_DWORD *)(v12 + (v31 | v24));
LABEL_38:
  int v42 = v40 & 0xF;
  int v43 = HIBYTE(v40) & 3;
  if (v42 == 1)
  {
    float v49 = (int8x8_t *)(v35 + SBYTE1(v40) * (uint64_t)v66);
    if (v67 < (unint64_t)v49) {
      float v49 = (int8x8_t *)v67;
    }
    if (v49 >= v36) {
      uint64_t v36 = v49;
    }
    float v50 = COERCE_FLOAT(bswap32(v36[1].u32[0]));
    float v51 = &interpolate_rgbaf_21353[4 * v43];
    goto LABEL_61;
  }
  if (v42 == 2)
  {
    uint64_t v52 = (int8x8_t *)(v35 + 12 * SBYTE2(v40));
    if (v67 < (unint64_t)v52) {
      uint64_t v52 = (int8x8_t *)v67;
    }
    if (v52 >= v36) {
      uint64_t v36 = v52;
    }
    float v50 = COERCE_FLOAT(bswap32(v36[1].u32[0]));
    float v51 = &interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3)];
LABEL_61:
    LODWORD(a8) = v51[3];
    float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a8, 0), (float32x2_t)vrev32_s8(*v36), *(float *)&a8);
    float v39 = (float)(v39 - (float)(v39 * *(float *)&a8)) + (float)(v50 * *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 + (float)(1.0 - *(float *)&a8);
    goto LABEL_62;
  }
  if (v42 != 3)
  {
LABEL_36:
    LODWORD(a8) = 1.0;
    goto LABEL_62;
  }
  float32x2_t v44 = (int8x8_t *)(v35 + 12 * SBYTE2(v40));
  if (v67 >= (unint64_t)v44) {
    float v45 = v44;
  }
  else {
    float v45 = (int8x8_t *)v67;
  }
  if (v45 < v36) {
    float v45 = v36;
  }
  float v46 = COERCE_FLOAT(bswap32(v45[1].u32[0]));
  float32x2_t v47 = (int8x8_t *)((char *)v44 + SBYTE1(v40) * (uint64_t)v66);
  if (v67 < (unint64_t)v47) {
    float32x2_t v47 = (int8x8_t *)v67;
  }
  if (v47 >= v36) {
    uint64_t v36 = v47;
  }
  LODWORD(a9) = interpolate_rgbaf_21353[4 * v43 + 3];
  LODWORD(a10) = interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3) + 3];
  float v39 = (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v46 * *(float *)&a9))
              - (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v46 * *(float *)&a9))
                      * *(float *)&a10))
      + (float)((float)((float)(v46 - (float)(v46 * *(float *)&a9))
                      + (float)(COERCE_FLOAT(bswap32(v36[1].u32[0])) * *(float *)&a9))
              * *(float *)&a10);
  a8 = COERCE_DOUBLE(vrev32_s8(*v45));
  float32x2_t v48 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a9, 0), *(float32x2_t *)&a8, *(float *)&a9);
  float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v48, v48, *(float32x2_t *)&a10, 0), vmla_n_f32(vmls_lane_f32(*(float32x2_t *)&a8, *(float32x2_t *)&a8, *(float32x2_t *)&a9, 0), (float32x2_t)vrev32_s8(*v36), *(float *)&a9), *(float *)&a10);
  *(float *)&a8 = (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9))
                        - (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10))
                + (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10);
LABEL_62:
  uint64_t v53 = 0;
  ++v13;
  int v58 = v17;
  int v54 = v17 - 1;
  a3 += v68;
  uint64_t v55 = v63 - a3;
  a2 += v69;
  uint64_t v56 = v60 - a2;
  while (1)
  {
    CFArrayRef result = RGBAF_21354(v13, v38.f32[0], v38.f32[1], v39, *(float *)&a8);
    *(unsigned char *)(v64 + 1 + v53) = v25 >> 22;
    if (v54 == v53) {
      return result;
    }
    if (((v55 | v56 | (a3 - v62) | (a2 - v61)) & 0x8000000000000000) != 0)
    {
      v64 += v53 + 1;
      int v41 = ~v53 + v58;
      goto LABEL_34;
    }
    unint64_t v35 = v65 + SHIDWORD(a3) * (uint64_t)v66 + 12 * SHIDWORD(a2);
    uint64_t v36 = (int8x8_t *)*((void *)v70 + 4);
    int v57 = (int8x8_t *)v67;
    if (v67 >= v35) {
      int v57 = (int8x8_t *)(v65 + SHIDWORD(a3) * (uint64_t)v66 + 12 * SHIDWORD(a2));
    }
    if (v57 < v36) {
      int v57 = (int8x8_t *)*((void *)v70 + 4);
    }
    float32x2_t v38 = (float32x2_t)vrev32_s8(*v57);
    float v39 = COERCE_FLOAT(bswap32(v57[1].u32[0]));
    if (v12)
    {
      unsigned int v40 = *(_DWORD *)(v12 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v64 += v53 + 1;
        int v17 = ~v53 + v58;
        unsigned int v25 = -1;
        goto LABEL_38;
      }
    }
    ++v53;
    ++v13;
    a3 += v68;
    v55 -= v68;
    a2 += v69;
    v56 -= v69;
    LODWORD(a8) = 1.0;
    unsigned int v25 = -1;
  }
}

uint64_t rgba32_sample_rgba64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v74 = *(void *)(result + 80);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v72 = *(_DWORD *)(result + 188);
  uint64_t v10 = *(void *)(result + 152) - 4;
  uint64_t v11 = *(void *)(result + 144) - 1;
  uint64_t v12 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = 0xFF00000000000000;
  }
  unint64_t v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v73 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v7;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_37;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v72 | v22;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v6 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_37;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v72 | v18;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v73) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v73 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v72;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 4;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v74)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_29;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v74;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_37;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v72;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_29:
  if (v24 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v34 = v12 + SHIDWORD(v25) * (uint64_t)v4;
  uint64_t v35 = v29 >> 32;
  unint64_t v36 = v34 + 8 * v35;
  uint64_t v37 = *(unint64_t **)(result + 32);
  if (v14 >= v36) {
    float32x2_t v38 = (unint64_t *)(v34 + 8 * v35);
  }
  else {
    float32x2_t v38 = (unint64_t *)v14;
  }
  if (v38 < v37) {
    float32x2_t v38 = *(unint64_t **)(result + 32);
  }
  unint64_t v39 = *v38;
  if (!v5) {
    goto LABEL_69;
  }
  unsigned int v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_40:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      int v59 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v59) {
        int v59 = (unint64_t *)v14;
      }
      if (v59 < v37) {
        int v59 = v37;
      }
      unint64_t v60 = interpolate_16161616_21355[v42];
      char v61 = v42 + 1;
      unint64_t v57 = v39 - ((v60 & v39) >> v61);
      unint64_t v62 = (v60 & *v59) >> v61;
LABEL_68:
      unint64_t v39 = v57 + v62;
      break;
    case 2:
      uint64_t v63 = (unint64_t *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 53));
      if (v14 < (unint64_t)v63) {
        uint64_t v63 = (unint64_t *)v14;
      }
      if (v63 < v37) {
        uint64_t v63 = v37;
      }
      int v64 = (v40 >> 28) & 3;
      uint64_t v65 = interpolate_16161616_21355[v64];
      char v56 = v64 + 1;
      unint64_t v57 = v39 - ((v65 & v39) >> v56);
      unint64_t v58 = v65 & *v63;
LABEL_67:
      unint64_t v62 = v58 >> v56;
      goto LABEL_68;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v40) << 56;
      float32x2_t v44 = (unint64_t *)(v36 + (v43 >> 53));
      if (v14 < (unint64_t)v44) {
        float32x2_t v44 = (unint64_t *)v14;
      }
      if (v44 < v37) {
        float32x2_t v44 = v37;
      }
      unint64_t v45 = *v44;
      unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46) {
        float32x2_t v47 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      }
      else {
        float32x2_t v47 = (unint64_t *)v14;
      }
      if (v47 < v37) {
        float32x2_t v47 = v37;
      }
      unint64_t v48 = *v47;
      float v49 = (unint64_t *)(v46 + (v43 >> 53));
      if (v14 < (unint64_t)v49) {
        float v49 = (unint64_t *)v14;
      }
      if (v49 < v37) {
        float v49 = v37;
      }
      unint64_t v50 = interpolate_16161616_21355[v42];
      char v51 = v42 + 1;
      unint64_t v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      unint64_t v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      int v54 = (v40 >> 28) & 3;
      unint64_t v55 = interpolate_16161616_21355[v54];
      char v56 = v54 + 1;
      unint64_t v57 = v52 - ((v52 & v55) >> v56);
      unint64_t v58 = v53 & v55;
      goto LABEL_67;
  }
LABEL_69:
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  a3 += v9;
  uint64_t v68 = v7 - a3;
  a2 += v8;
  uint64_t v69 = v74 - a2;
  while (1)
  {
    *(_DWORD *)(v10 + 4 + 4 * v66) = ((v39 | v13) >> 56) | (BYTE1(v39) << 24) | (BYTE3(v39) << 16) | WORD2(v39) & 0xFF00;
    *(unsigned char *)(v11 + 1 + v66) = v24 >> 22;
    if (a4 - 1 == v66) {
      return result;
    }
    if (((v68 | v69 | (a3 - v6) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      uint64_t v10 = v10 - v67 + 4;
      v11 += v66 + 1;
      a4 += ~v66;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v70 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v36 = v70 + 8 * (a2 >> 32);
    uint64_t v37 = *(unint64_t **)(result + 32);
    if (v14 >= v36) {
      uint64_t v71 = (unint64_t *)(v70 + 8 * (a2 >> 32));
    }
    else {
      uint64_t v71 = (unint64_t *)v14;
    }
    if (v71 < v37) {
      uint64_t v71 = *(unint64_t **)(result + 32);
    }
    unint64_t v39 = *v71;
    if (v5)
    {
      unsigned int v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        uint64_t v10 = v10 - v67 + 4;
        v11 += v66 + 1;
        a4 += ~v66;
        unsigned int v24 = -1;
        goto LABEL_40;
      }
    }
    v67 -= 4;
    ++v66;
    a3 += v9;
    v68 -= v9;
    a2 += v8;
    v69 -= v8;
    unsigned int v24 = -1;
  }
}

uint64_t rgba32_sample_RGBA64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v73 = *(void *)(result + 80);
  uint64_t v72 = *(void *)(result + 88);
  uint64_t v7 = *(void *)(result + 112);
  uint64_t v8 = *(void *)(result + 120);
  int v70 = *(_DWORD *)(result + 188);
  uint64_t v9 = *(void *)(result + 152) - 4;
  uint64_t v10 = *(void *)(result + 144) - 1;
  uint64_t v11 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = 0xFF00000000000000;
  }
  unint64_t v13 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v71 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v72)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v71;
        uint64_t v26 = v73;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v72;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_37;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v71;
        uint64_t v26 = v73;
        unsigned int v23 = v70 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v6 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_37;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v71;
      uint64_t v26 = v73;
      unsigned int v23 = v70 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v25 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v70;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v7;
    a3 += v8;
    v9 += 4;
    *(unsigned char *)++uint64_t v10 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v26)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_29;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v26;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_37;
  }
  if (v34 < v32) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v70;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_29:
  if (v23 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v35 = v11 + SHIDWORD(v24) * (uint64_t)v4;
  uint64_t v36 = v30 >> 32;
  unint64_t v37 = v35 + 8 * v36;
  float32x2_t v38 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v37) {
    unint64_t v39 = (unsigned __int16 *)(v35 + 8 * v36);
  }
  else {
    unint64_t v39 = (unsigned __int16 *)v13;
  }
  if (v39 < v38) {
    unint64_t v39 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
  if (v5)
  {
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v22));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        int v59 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v13 < (unint64_t)v59) {
          int v59 = (unsigned __int16 *)v13;
        }
        if (v59 < v38) {
          int v59 = v38;
        }
        uint64_t v60 = interpolate_16161616_21355[v43];
        char v61 = v43 + 1;
        unint64_t v57 = v40 - ((v60 & v40) >> v61);
        unint64_t v58 = ((((unint64_t)(bswap32(v59[2]) >> 16) << 32) | ((unint64_t)(bswap32(v59[3]) >> 16) << 48) | bswap32(v59[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v59) >> 16)) & v60) >> v61;
LABEL_62:
        unint64_t v40 = v57 + v58;
        break;
      case 2:
        unint64_t v62 = (unsigned __int16 *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 53));
        if (v13 < (unint64_t)v62) {
          unint64_t v62 = (unsigned __int16 *)v13;
        }
        if (v62 < v38) {
          unint64_t v62 = v38;
        }
        int v63 = (v41 >> 28) & 3;
        unint64_t v40 = v40
            - ((interpolate_16161616_21355[v63] & v40) >> (v63 + 1))
            + (((((unint64_t)(bswap32(v62[2]) >> 16) << 32) | ((unint64_t)(bswap32(v62[3]) >> 16) << 48) | bswap32(v62[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v62) >> 16)) & interpolate_16161616_21355[v63]) >> (v63 + 1));
        break;
      case 3:
        int64_t v44 = (unint64_t)HIWORD(v41) << 56;
        unint64_t v45 = (unsigned __int16 *)(v37 + (v44 >> 53));
        if (v13 < (unint64_t)v45) {
          unint64_t v45 = (unsigned __int16 *)v13;
        }
        if (v45 < v38) {
          unint64_t v45 = v38;
        }
        unint64_t v46 = ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | ((unint64_t)(bswap32(v45[3]) >> 16) << 48) | bswap32(v45[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v45) >> 16);
        unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v13 >= v47) {
          unint64_t v48 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        }
        else {
          unint64_t v48 = (unsigned __int16 *)v13;
        }
        if (v48 < v38) {
          unint64_t v48 = v38;
        }
        unint64_t v49 = ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | ((unint64_t)(bswap32(v48[3]) >> 16) << 48) | bswap32(v48[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v48) >> 16);
        unint64_t v50 = (unsigned __int16 *)(v47 + (v44 >> 53));
        if (v13 < (unint64_t)v50) {
          unint64_t v50 = (unsigned __int16 *)v13;
        }
        if (v50 < v38) {
          unint64_t v50 = v38;
        }
        uint64_t v51 = interpolate_16161616_21355[v43];
        char v52 = v43 + 1;
        unint64_t v53 = v40 - ((v51 & v40) >> v52) + ((v49 & v51) >> v52);
        unint64_t v54 = v46
            - ((v51 & v46) >> v52)
            + (((((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16)) & v51) >> v52);
        int v55 = (v41 >> 28) & 3;
        uint64_t v56 = interpolate_16161616_21355[v55];
        LOBYTE(v55) = v55 + 1;
        unint64_t v57 = v53 - ((v53 & v56) >> v55);
        unint64_t v58 = (v54 & v56) >> v55;
        goto LABEL_62;
    }
  }
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  a3 += v8;
  uint64_t v66 = v72 - a3;
  a2 += v7;
  uint64_t v67 = v73 - a2;
  while (1)
  {
    *(_DWORD *)(v9 + 4 + 4 * v65) = ((v40 | v12) >> 56) | (BYTE1(v40) << 24) | (BYTE3(v40) << 16) | WORD2(v40) & 0xFF00;
    *(unsigned char *)(v10 + 1 + v65) = v23 >> 22;
    if (a4 - 1 == v65) {
      return result;
    }
    if (((v66 | v67 | (a3 - v6) | (a2 - v71)) & 0x8000000000000000) != 0)
    {
      v10 += v65 + 1;
      uint64_t v9 = v9 - v64 + 4;
      a4 += ~v65;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v68 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v37 = v68 + 8 * (a2 >> 32);
    float32x2_t v38 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v37) {
      uint64_t v69 = (unsigned __int16 *)(v68 + 8 * (a2 >> 32));
    }
    else {
      uint64_t v69 = (unsigned __int16 *)v13;
    }
    if (v69 < v38) {
      uint64_t v69 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v40 = ((unint64_t)(bswap32(v69[2]) >> 16) << 32) | ((unint64_t)(bswap32(v69[3]) >> 16) << 48) | bswap32(v69[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v69) >> 16);
    if (v5)
    {
      unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v10 += v65 + 1;
        uint64_t v9 = v9 - v64 + 4;
        a4 += ~v65;
        unsigned int v23 = -1;
        goto LABEL_40;
      }
    }
    ++v65;
    v64 -= 4;
    a3 += v8;
    v66 -= v8;
    a2 += v7;
    v67 -= v7;
    unsigned int v23 = -1;
  }
}

uint64_t rgba32_sample_rgb48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v69 = *(void *)(result + 64);
  uint64_t v70 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v68 = *(_DWORD *)(result + 188);
  unint64_t v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v69;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v8;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_34;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v69;
        unsigned int v23 = v68 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v7 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_34;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v69;
      unsigned int v23 = v68 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v25 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v68;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v70)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v70;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v68;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v23 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v29 >> 32;
  uint64_t v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  unint64_t v36 = v35 + 6 * (int)v34;
  unint64_t v37 = *(unsigned int **)(result + 32);
  if (v13 >= v36) {
    float32x2_t v38 = (unsigned int *)(v35 + 6 * (int)v34);
  }
  else {
    float32x2_t v38 = (unsigned int *)v13;
  }
  if (v38 < v37) {
    float32x2_t v38 = *(unsigned int **)(result + 32);
  }
  unint64_t v39 = *v38 | ((unint64_t)*((unsigned __int16 *)v38 + 2) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      unint64_t v57 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57) {
        unint64_t v57 = (unsigned int *)v13;
      }
      if (v57 < v37) {
        unint64_t v57 = v37;
      }
      uint64_t v58 = interpolate_16161616_21355[v42];
      char v59 = v42 + 1;
      unint64_t v56 = v39 - ((v58 & v39) >> v59);
      unint64_t v60 = ((*v57 | ((unint64_t)*((unsigned __int16 *)v57 + 2) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      unint64_t v39 = v56 + v60;
      break;
    case 2:
      char v61 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61) {
        char v61 = (unsigned int *)v13;
      }
      if (v61 < v37) {
        char v61 = v37;
      }
      unint64_t v52 = *v61 | ((unint64_t)*((unsigned __int16 *)v61 + 2) << 32) | 0xFFFF000000000000;
      int v62 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v62];
      char v55 = v62 + 1;
      unint64_t v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      unint64_t v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      int v43 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43) {
        int v43 = (unsigned int *)v13;
      }
      if (v43 < v37) {
        int v43 = v37;
      }
      unint64_t v44 = *v43 | ((unint64_t)*((unsigned __int16 *)v43 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45) {
        unint64_t v46 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned int *)v13;
      }
      if (v46 < v37) {
        unint64_t v46 = v37;
      }
      unint64_t v47 = *v46 | ((unint64_t)*((unsigned __int16 *)v46 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v48 = (unsigned int *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48) {
        unint64_t v48 = (unsigned int *)v13;
      }
      if (v48 < v37) {
        unint64_t v48 = v37;
      }
      uint64_t v49 = interpolate_16161616_21355[v42];
      char v50 = v42 + 1;
      unint64_t v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      unint64_t v52 = v44
          - ((v49 & v44) >> v50)
          + (((*v48 | ((unint64_t)*((unsigned __int16 *)v48 + 2) << 32) | 0xFFFF000000000000) & v49) >> v50);
      int v53 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v53];
      char v55 = v53 + 1;
      unint64_t v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  a3 += v10;
  uint64_t v65 = v8 - a3;
  a2 += v9;
  uint64_t v66 = v70 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = HIBYTE(v39) | (BYTE1(v39) << 24) | (BYTE3(v39) << 16) | WORD2(v39) & 0xFF00;
    *(unsigned char *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v65 | v66 | (a3 - v7) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      uint64_t v11 = v11 - v63 + 4;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v36 = v4 + SHIDWORD(a3) * (uint64_t)v5 + 6 * SHIDWORD(a2);
    unint64_t v37 = *(unsigned int **)(result + 32);
    if (v13 >= v36) {
      uint64_t v67 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v5 + 6 * SHIDWORD(a2));
    }
    else {
      uint64_t v67 = (unsigned int *)v13;
    }
    if (v67 < v37) {
      uint64_t v67 = *(unsigned int **)(result + 32);
    }
    unint64_t v39 = *v67 | ((unint64_t)*((unsigned __int16 *)v67 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        uint64_t v11 = v11 - v63 + 4;
        a4 += ~v64;
        unsigned int v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    unsigned int v23 = -1;
  }
}

uint64_t rgba32_sample_RGB48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v70 = *(void *)(result + 64);
  uint64_t v71 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v69 = *(_DWORD *)(result + 188);
  unint64_t v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v70;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v8;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_34;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v70;
        unsigned int v23 = v69 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v7 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_34;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v70;
      unsigned int v23 = v69 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v25 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v69;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v71)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v71;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v69;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v23 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v29 >> 32;
  uint64_t v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  unint64_t v36 = v35 + 6 * (int)v34;
  unint64_t v37 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v36) {
    float32x2_t v38 = (unsigned __int16 *)(v35 + 6 * (int)v34);
  }
  else {
    float32x2_t v38 = (unsigned __int16 *)v13;
  }
  if (v38 < v37) {
    float32x2_t v38 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v39 = (bswap32(*v38) >> 16) | ((unint64_t)(bswap32(v38[1]) >> 16) << 16) | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      unint64_t v57 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57) {
        unint64_t v57 = (unsigned __int16 *)v13;
      }
      if (v57 < v37) {
        unint64_t v57 = v37;
      }
      uint64_t v58 = interpolate_16161616_21355[v42];
      char v59 = v42 + 1;
      unint64_t v56 = v39 - ((v58 & v39) >> v59);
      unint64_t v60 = (((bswap32(*v57) >> 16) | ((unint64_t)(bswap32(v57[1]) >> 16) << 16) | ((unint64_t)(bswap32(v57[2]) >> 16) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      unint64_t v39 = v56 + v60;
      break;
    case 2:
      char v61 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61) {
        char v61 = (unsigned __int16 *)v13;
      }
      if (v61 < v37) {
        char v61 = v37;
      }
      unint64_t v52 = (bswap32(*v61) >> 16) | ((unint64_t)(bswap32(v61[1]) >> 16) << 16) | ((unint64_t)(bswap32(v61[2]) >> 16) << 32) | 0xFFFF000000000000;
      int v62 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v62];
      char v55 = v62 + 1;
      unint64_t v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      unint64_t v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      int v43 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43) {
        int v43 = (unsigned __int16 *)v13;
      }
      if (v43 < v37) {
        int v43 = v37;
      }
      unint64_t v44 = (bswap32(*v43) >> 16) | ((unint64_t)(bswap32(v43[1]) >> 16) << 16) | ((unint64_t)(bswap32(v43[2]) >> 16) << 32) | 0xFFFF000000000000;
      unint64_t v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45) {
        unint64_t v46 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned __int16 *)v13;
      }
      if (v46 < v37) {
        unint64_t v46 = v37;
      }
      unint64_t v47 = (bswap32(*v46) >> 16) | ((unint64_t)(bswap32(v46[1]) >> 16) << 16) | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | 0xFFFF000000000000;
      unint64_t v48 = (unsigned __int16 *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48) {
        unint64_t v48 = (unsigned __int16 *)v13;
      }
      if (v48 < v37) {
        unint64_t v48 = v37;
      }
      uint64_t v49 = interpolate_16161616_21355[v42];
      char v50 = v42 + 1;
      unint64_t v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      unint64_t v52 = v44
          - ((v49 & v44) >> v50)
          + ((((bswap32(*v48) >> 16) | ((unint64_t)(bswap32(v48[1]) >> 16) << 16) | ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | 0xFFFF000000000000) & v49) >> v50);
      int v53 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v53];
      char v55 = v53 + 1;
      unint64_t v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  a3 += v10;
  uint64_t v65 = v8 - a3;
  a2 += v9;
  uint64_t v66 = v71 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = HIBYTE(v39) | (BYTE1(v39) << 24) | (BYTE3(v39) << 16) | WORD2(v39) & 0xFF00;
    *(unsigned char *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v65 | v66 | (a3 - v7) | (a2 - v70)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      uint64_t v11 = v11 - v63 + 4;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v67 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    unint64_t v36 = v67 + 6 * SHIDWORD(a2);
    unint64_t v37 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v36) {
      int v68 = (unsigned __int16 *)(v67 + 6 * SHIDWORD(a2));
    }
    else {
      int v68 = (unsigned __int16 *)v13;
    }
    if (v68 < v37) {
      int v68 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v39 = (bswap32(*v68) >> 16) | ((unint64_t)(bswap32(v68[1]) >> 16) << 16) | ((unint64_t)(bswap32(v68[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        uint64_t v11 = v11 - v63 + 4;
        a4 += ~v64;
        unsigned int v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    unsigned int v23 = -1;
  }
}

uint64_t rgba32_sample_cmyk32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v85 = *(_DWORD *)(result + 188);
  uint64_t v91 = *(void *)(result + 152) - 4;
  uint64_t v89 = *(void *)(result + 88);
  uint64_t v90 = *(void *)(result + 144) - 1;
  if (v5) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 0xFF00000000;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  uint64_t v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  unint64_t v15 = v4 + (v12 * v6) + 4 * v13 - 8;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v86 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v86;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v89;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v86;
        unsigned int v25 = v85 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v88 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v86;
      unsigned int v25 = v85 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v85;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v90 = 0;
    v91 += 4;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v87)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v87;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v85;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  unint64_t v38 = v4 + (int)v36 * (uint64_t)v6 + 4 * v37;
  unint64_t v39 = *(unsigned int **)(result + 32);
  if (v15 >= v38) {
    unsigned int v40 = (unsigned int *)(v4 + (int)v36 * (uint64_t)v6 + 4 * v37);
  }
  else {
    unsigned int v40 = (unsigned int *)v15;
  }
  if (v40 < v39) {
    unsigned int v40 = *(unsigned int **)(result + 32);
  }
  unint64_t v41 = *v40;
  if (!v5)
  {
    unint64_t v42 = 0;
    if (!v8) {
      goto LABEL_103;
    }
LABEL_46:
    unsigned int v45 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    int v46 = v45 & 0xF;
    int v47 = HIBYTE(v45) & 3;
    if (v46 == 1)
    {
      uint64_t v64 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      if (v15 < (unint64_t)v64) {
        uint64_t v64 = (unsigned int *)v15;
      }
      if (v64 < v39) {
        uint64_t v64 = v39;
      }
      unint64_t v65 = *v64;
      if (v5)
      {
        uint64_t v66 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
        if (v14 < v66) {
          uint64_t v66 = v14;
        }
        if ((unint64_t)v66 < *(void *)(result + 40)) {
          uint64_t v66 = *(unsigned __int8 **)(result + 40);
        }
        v65 |= (unint64_t)*v66 << 32;
      }
      uint64_t v67 = interpolate_cif10a[v47];
      char v68 = v47 + 1;
      unint64_t v69 = v41 - ((v67 & v41) >> v68);
      unint64_t v70 = (v67 & v65) >> v68;
    }
    else
    {
      if (v46 != 2)
      {
        if (v46 == 3)
        {
          int64_t v48 = (unint64_t)HIWORD(v45) << 56;
          uint64_t v49 = (unsigned int *)(v38 + (v48 >> 54));
          if (v15 < (unint64_t)v49) {
            uint64_t v49 = (unsigned int *)v15;
          }
          if (v49 < v39) {
            uint64_t v49 = v39;
          }
          unint64_t v50 = *v49;
          unint64_t v51 = v38 + SBYTE1(v45) * (uint64_t)v6;
          if (v15 >= v51) {
            unint64_t v52 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
          }
          else {
            unint64_t v52 = (unsigned int *)v15;
          }
          if (v52 < v39) {
            unint64_t v52 = v39;
          }
          unint64_t v53 = *v52;
          uint64_t v54 = (unsigned int *)(v51 + (v48 >> 54));
          if (v15 < (unint64_t)v54) {
            uint64_t v54 = (unsigned int *)v15;
          }
          if (v54 < v39) {
            uint64_t v54 = v39;
          }
          unint64_t v55 = *v54;
          if (v5)
          {
            unint64_t v56 = (unsigned __int8 *)(v42 + SBYTE2(v45));
            unint64_t v57 = *(void *)(result + 40);
            if (v14 < v56) {
              unint64_t v56 = v14;
            }
            if ((unint64_t)v56 < v57) {
              unint64_t v56 = *(unsigned __int8 **)(result + 40);
            }
            v50 |= (unint64_t)*v56 << 32;
            unint64_t v58 = v42 + SBYTE1(v45) * (uint64_t)v7;
            if ((unint64_t)v14 >= v58) {
              char v59 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
            }
            else {
              char v59 = v14;
            }
            if ((unint64_t)v59 < v57) {
              char v59 = *(unsigned __int8 **)(result + 40);
            }
            v53 |= (unint64_t)*v59 << 32;
            unint64_t v60 = (unsigned __int8 *)(v58 + SBYTE2(v45));
            if (v14 < v60) {
              unint64_t v60 = v14;
            }
            if ((unint64_t)v60 < v57) {
              unint64_t v60 = *(unsigned __int8 **)(result + 40);
            }
            v55 |= (unint64_t)*v60 << 32;
          }
          uint64_t v61 = interpolate_cif10a[v47];
          char v62 = v47 + 1;
          unint64_t v63 = v41 - ((v61 & v41) >> v62) + ((v61 & v53) >> v62);
          unint64_t v41 = v63
              - ((v63 & interpolate_cif10a[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1))
              + (((v50 - ((v61 & v50) >> v62) + ((v61 & v55) >> v62)) & interpolate_cif10a[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      uint64_t v71 = (unsigned int *)(v38 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 54));
      if (v15 < (unint64_t)v71) {
        uint64_t v71 = (unsigned int *)v15;
      }
      if (v71 < v39) {
        uint64_t v71 = v39;
      }
      unint64_t v72 = *v71;
      if (v5)
      {
        uint64_t v73 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v73) {
          uint64_t v73 = v14;
        }
        if ((unint64_t)v73 < *(void *)(result + 40)) {
          uint64_t v73 = *(unsigned __int8 **)(result + 40);
        }
        v72 |= (unint64_t)*v73 << 32;
      }
      int v74 = (v45 >> 28) & 3;
      uint64_t v75 = interpolate_cif10a[v74];
      LOBYTE(v74) = v74 + 1;
      unint64_t v69 = v41 - ((v75 & v41) >> v74);
      unint64_t v70 = (v75 & v72) >> v74;
    }
    unint64_t v41 = v69 + v70;
    goto LABEL_103;
  }
  unint64_t v42 = v5 + (int)v36 * (uint64_t)v7 + v37;
  int v43 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v42) {
    unint64_t v44 = (unsigned __int8 *)v42;
  }
  else {
    unint64_t v44 = v14;
  }
  if (v44 >= v43) {
    int v43 = v44;
  }
  v41 |= (unint64_t)*v43 << 32;
  if (v8) {
    goto LABEL_46;
  }
LABEL_103:
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  a3 += v9;
  uint64_t v78 = v89 - a3;
  a2 += v10;
  uint64_t v79 = v87 - a2;
  while (1)
  {
    unsigned int v80 = ((v41 | v11) >> 32);
    int8x8_t v81 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vmax_s32(vsub_s32(vdup_n_s32(v80), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v41), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), vdup_n_s32(v41))), 0), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
    *(_DWORD *)(v91 + 4 + 4 * v76) = v81.i32[0] | (((v80 - (BYTE3(v41) + v41)) & ~((int)(v80 - (BYTE3(v41) + v41)) >> 31)) << 24) | v80 | v81.i32[1];
    *(unsigned char *)(v90 + 1 + v76) = v25 >> 22;
    if (a4 - 1 == v76) {
      return result;
    }
    if ((v78 | v79 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v76 + 1;
      uint64_t v91 = v91 - v77 + 4;
      a4 += ~v76;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32);
    unint64_t v39 = *(unsigned int **)(result + 32);
    if (v15 >= v38) {
      uint64_t v82 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v82 = (unsigned int *)v15;
    }
    if (v82 < v39) {
      uint64_t v82 = *(unsigned int **)(result + 32);
    }
    unint64_t v41 = *v82;
    if (v5)
    {
      unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      double v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42) {
        unint64_t v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      }
      else {
        unint64_t v84 = (unint64_t)v14;
      }
      if (v84 >= (unint64_t)v83) {
        double v83 = (unsigned __int8 *)v84;
      }
      v41 |= (unint64_t)*v83 << 32;
    }
    if (v8)
    {
      unsigned int v45 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        v90 += v76 + 1;
        uint64_t v91 = v91 - v77 + 4;
        a4 += ~v76;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v77 -= 4;
    ++v76;
    a3 += v9;
    v78 -= v9;
    a2 += v10;
    v79 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t rgba32_sample_CMYK32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v85 = *(_DWORD *)(result + 188);
  uint64_t v91 = *(void *)(result + 152) - 4;
  uint64_t v89 = *(void *)(result + 88);
  uint64_t v90 = *(void *)(result + 144) - 1;
  if (v5) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 0xFF00000000;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  uint64_t v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  unint64_t v15 = v4 + (v12 * v6) + 4 * v13 - 8;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v86 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v86;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v89;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v86;
        unsigned int v25 = v85 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v88 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v86;
      unsigned int v25 = v85 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v85;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v90 = 0;
    v91 += 4;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v87)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v87;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v85;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  unint64_t v38 = v4 + (int)v36 * (uint64_t)v6 + 4 * v37;
  unint64_t v39 = *(unsigned int **)(result + 32);
  if (v15 >= v38) {
    unsigned int v40 = (unsigned int *)(v4 + (int)v36 * (uint64_t)v6 + 4 * v37);
  }
  else {
    unsigned int v40 = (unsigned int *)v15;
  }
  if (v40 < v39) {
    unsigned int v40 = *(unsigned int **)(result + 32);
  }
  unint64_t v41 = bswap32(*v40);
  if (!v5)
  {
    unint64_t v42 = 0;
    if (!v8) {
      goto LABEL_103;
    }
LABEL_46:
    unsigned int v45 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    int v46 = v45 & 0xF;
    int v47 = HIBYTE(v45) & 3;
    if (v46 == 1)
    {
      uint64_t v64 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      if (v15 < (unint64_t)v64) {
        uint64_t v64 = (unsigned int *)v15;
      }
      if (v64 < v39) {
        uint64_t v64 = v39;
      }
      unint64_t v65 = bswap32(*v64);
      if (v5)
      {
        uint64_t v66 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
        if (v14 < v66) {
          uint64_t v66 = v14;
        }
        if ((unint64_t)v66 < *(void *)(result + 40)) {
          uint64_t v66 = *(unsigned __int8 **)(result + 40);
        }
        v65 |= (unint64_t)*v66 << 32;
      }
      uint64_t v67 = interpolate_cif10a[v47];
      char v68 = v47 + 1;
      unint64_t v69 = v41 - ((v67 & v41) >> v68);
      unint64_t v70 = (v67 & v65) >> v68;
    }
    else
    {
      if (v46 != 2)
      {
        if (v46 == 3)
        {
          int64_t v48 = (unint64_t)HIWORD(v45) << 56;
          uint64_t v49 = (unsigned int *)(v38 + (v48 >> 54));
          if (v15 < (unint64_t)v49) {
            uint64_t v49 = (unsigned int *)v15;
          }
          if (v49 < v39) {
            uint64_t v49 = v39;
          }
          unint64_t v50 = bswap32(*v49);
          unint64_t v51 = v38 + SBYTE1(v45) * (uint64_t)v6;
          if (v15 >= v51) {
            unint64_t v52 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
          }
          else {
            unint64_t v52 = (unsigned int *)v15;
          }
          if (v52 < v39) {
            unint64_t v52 = v39;
          }
          unint64_t v53 = bswap32(*v52);
          uint64_t v54 = (unsigned int *)(v51 + (v48 >> 54));
          if (v15 < (unint64_t)v54) {
            uint64_t v54 = (unsigned int *)v15;
          }
          if (v54 < v39) {
            uint64_t v54 = v39;
          }
          unint64_t v55 = bswap32(*v54);
          if (v5)
          {
            unint64_t v56 = (unsigned __int8 *)(v42 + SBYTE2(v45));
            unint64_t v57 = *(void *)(result + 40);
            if (v14 < v56) {
              unint64_t v56 = v14;
            }
            if ((unint64_t)v56 < v57) {
              unint64_t v56 = *(unsigned __int8 **)(result + 40);
            }
            v50 |= (unint64_t)*v56 << 32;
            unint64_t v58 = v42 + SBYTE1(v45) * (uint64_t)v7;
            if ((unint64_t)v14 >= v58) {
              char v59 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
            }
            else {
              char v59 = v14;
            }
            if ((unint64_t)v59 < v57) {
              char v59 = *(unsigned __int8 **)(result + 40);
            }
            v53 |= (unint64_t)*v59 << 32;
            unint64_t v60 = (unsigned __int8 *)(v58 + SBYTE2(v45));
            if (v14 < v60) {
              unint64_t v60 = v14;
            }
            if ((unint64_t)v60 < v57) {
              unint64_t v60 = *(unsigned __int8 **)(result + 40);
            }
            v55 |= (unint64_t)*v60 << 32;
          }
          uint64_t v61 = interpolate_cif10a[v47];
          char v62 = v47 + 1;
          unint64_t v63 = v41 - ((v61 & v41) >> v62) + ((v61 & v53) >> v62);
          unint64_t v41 = v63
              - ((v63 & interpolate_cif10a[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1))
              + (((v50 - ((v61 & v50) >> v62) + ((v61 & v55) >> v62)) & interpolate_cif10a[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      uint64_t v71 = (unsigned int *)(v38 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 54));
      if (v15 < (unint64_t)v71) {
        uint64_t v71 = (unsigned int *)v15;
      }
      if (v71 < v39) {
        uint64_t v71 = v39;
      }
      unint64_t v72 = bswap32(*v71);
      if (v5)
      {
        uint64_t v73 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v73) {
          uint64_t v73 = v14;
        }
        if ((unint64_t)v73 < *(void *)(result + 40)) {
          uint64_t v73 = *(unsigned __int8 **)(result + 40);
        }
        v72 |= (unint64_t)*v73 << 32;
      }
      int v74 = (v45 >> 28) & 3;
      uint64_t v75 = interpolate_cif10a[v74];
      LOBYTE(v74) = v74 + 1;
      unint64_t v69 = v41 - ((v75 & v41) >> v74);
      unint64_t v70 = (v75 & v72) >> v74;
    }
    unint64_t v41 = v69 + v70;
    goto LABEL_103;
  }
  unint64_t v42 = v5 + (int)v36 * (uint64_t)v7 + v37;
  int v43 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v42) {
    unint64_t v44 = (unsigned __int8 *)v42;
  }
  else {
    unint64_t v44 = v14;
  }
  if (v44 >= v43) {
    int v43 = v44;
  }
  v41 |= (unint64_t)*v43 << 32;
  if (v8) {
    goto LABEL_46;
  }
LABEL_103:
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  a3 += v9;
  uint64_t v78 = v89 - a3;
  a2 += v10;
  uint64_t v79 = v87 - a2;
  while (1)
  {
    unsigned int v80 = ((v41 | v11) >> 32);
    int8x8_t v81 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vmax_s32(vsub_s32(vdup_n_s32(v80), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v41), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), vdup_n_s32(v41))), 0), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
    *(_DWORD *)(v91 + 4 + 4 * v76) = v81.i32[0] | (((v80 - (BYTE3(v41) + v41)) & ~((int)(v80 - (BYTE3(v41) + v41)) >> 31)) << 24) | v80 | v81.i32[1];
    *(unsigned char *)(v90 + 1 + v76) = v25 >> 22;
    if (a4 - 1 == v76) {
      return result;
    }
    if ((v78 | v79 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v76 + 1;
      uint64_t v91 = v91 - v77 + 4;
      a4 += ~v76;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32);
    unint64_t v39 = *(unsigned int **)(result + 32);
    if (v15 >= v38) {
      uint64_t v82 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v82 = (unsigned int *)v15;
    }
    if (v82 < v39) {
      uint64_t v82 = *(unsigned int **)(result + 32);
    }
    unint64_t v41 = bswap32(*v82);
    if (v5)
    {
      unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      double v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42) {
        unint64_t v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      }
      else {
        unint64_t v84 = (unint64_t)v14;
      }
      if (v84 >= (unint64_t)v83) {
        double v83 = (unsigned __int8 *)v84;
      }
      v41 |= (unint64_t)*v83 << 32;
    }
    if (v8)
    {
      unsigned int v45 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        v90 += v76 + 1;
        uint64_t v91 = v91 - v77 + 4;
        a4 += ~v76;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v77 -= 4;
    ++v76;
    a3 += v9;
    v78 -= v9;
    a2 += v10;
    v79 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t rgba32_sample_argb32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 64);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v76 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = -16777216;
  }
  int v75 = *(_DWORD *)(result + 188);
  unint64_t v15 = v13 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v7)
      {
        if ((uint64_t)a3 <= v8)
        {
          uint64_t v24 = (a3 >> 22) & 0x3C0;
          unsigned int v25 = 0x3FFFFFFF;
          HIDWORD(v26) = HIDWORD(a3);
        }
        else
        {
          uint64_t v20 = *(void *)(result + 216);
          uint64_t v21 = *(void *)(result + 224) + v8;
          uint64_t v22 = v21 - a3 + (v20 >> 1);
          if (v22 < 1) {
            goto LABEL_37;
          }
          if (v22 >= v20) {
            LODWORD(v23) = 0x3FFFFFFF;
          }
          else {
            unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
          }
          unsigned int v25 = v75 | v23;
          uint64_t v26 = v21 - 0x1000000;
          uint64_t v24 = 448;
        }
      }
      else
      {
        uint64_t v16 = *(void *)(result + 216);
        uint64_t v17 = v7 - *(void *)(result + 224);
        uint64_t v18 = a3 - v17 + (v16 >> 1);
        if (v18 < 1) {
          goto LABEL_37;
        }
        if (v18 >= v16) {
          LODWORD(v19) = 0x3FFFFFFF;
        }
        else {
          unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
        }
        unsigned int v25 = v75 | v19;
        uint64_t v26 = v17 + 0x1000000;
        uint64_t v24 = 512;
      }
      if (a2 >= v6) {
        break;
      }
      uint64_t v27 = *(void *)(result + 192);
      uint64_t v28 = v6 - *(void *)(result + 200);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 >= 1)
      {
        if (v29 < v27) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v75;
        }
        uint64_t v30 = v28 + 0x1000000;
        uint64_t v31 = 32;
        goto LABEL_29;
      }
LABEL_37:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v76)
    {
      uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v30 = a2;
      goto LABEL_29;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = *(void *)(result + 200) + v76;
    uint64_t v34 = v33 - a2 + (v32 >> 1);
    if (v34 < 1) {
      goto LABEL_37;
    }
    if (v34 < v32) {
      unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v75;
    }
    uint64_t v30 = v33 - 0x1000000;
    uint64_t v31 = 28;
LABEL_29:
    if (v25 < 0x400000) {
      goto LABEL_37;
    }
    uint64_t v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
    uint64_t v36 = v30 >> 32;
    unint64_t v37 = v35 + 4 * v36;
    unint64_t v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37) {
      unint64_t v39 = (unsigned int *)(v35 + 4 * v36);
    }
    else {
      unint64_t v39 = (unsigned int *)v15;
    }
    if (v39 < v38) {
      unint64_t v39 = *(unsigned int **)(result + 32);
    }
    unsigned int v40 = *v39;
    if (!v5) {
      goto LABEL_69;
    }
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        unint64_t v60 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v15 < (unint64_t)v60) {
          unint64_t v60 = (unsigned int *)v15;
        }
        if (v60 < v38) {
          unint64_t v60 = v38;
        }
        unsigned int v61 = interpolate_8888_21358[v43];
        char v62 = v43 + 1;
        unsigned int v58 = v40 - ((v61 & v40) >> v62);
        unsigned int v63 = (v61 & *v60) >> v62;
        goto LABEL_68;
      case 2:
        uint64_t v64 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
        if (v15 < (unint64_t)v64) {
          uint64_t v64 = (unsigned int *)v15;
        }
        if (v64 < v38) {
          uint64_t v64 = v38;
        }
        int v65 = (v41 >> 28) & 3;
        int v66 = interpolate_8888_21358[v65];
        char v57 = v65 + 1;
        unsigned int v58 = v40 - ((v66 & v40) >> v57);
        unsigned int v59 = v66 & *v64;
        goto LABEL_67;
      case 3:
        int64_t v44 = (unint64_t)HIWORD(v41) << 56;
        unsigned int v45 = (unsigned int *)(v37 + (v44 >> 54));
        if (v15 < (unint64_t)v45) {
          unsigned int v45 = (unsigned int *)v15;
        }
        if (v45 < v38) {
          unsigned int v45 = v38;
        }
        unsigned int v46 = *v45;
        unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v15 >= v47) {
          int64_t v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        }
        else {
          int64_t v48 = (unsigned int *)v15;
        }
        if (v48 < v38) {
          int64_t v48 = v38;
        }
        unsigned int v49 = *v48;
        unint64_t v50 = (unsigned int *)(v47 + (v44 >> 54));
        if (v15 < (unint64_t)v50) {
          unint64_t v50 = (unsigned int *)v15;
        }
        if (v50 < v38) {
          unint64_t v50 = v38;
        }
        unsigned int v51 = interpolate_8888_21358[v43];
        char v52 = v43 + 1;
        unsigned int v53 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
        unsigned int v54 = v46 - ((v51 & v46) >> v52) + ((v51 & *v50) >> v52);
        int v55 = (v41 >> 28) & 3;
        int v56 = interpolate_8888_21358[v55];
        char v57 = v55 + 1;
        unsigned int v58 = v53 - ((v53 & v56) >> v57);
        unsigned int v59 = v54 & v56;
LABEL_67:
        unsigned int v63 = v59 >> v57;
LABEL_68:
        unsigned int v40 = v58 + v63;
        break;
    }
LABEL_69:
    HIDWORD(v67) = v40 | v14;
    LODWORD(v67) = v40 | v14;
    *(_DWORD *)(v11 + 4) = v67 >> 24;
    *(unsigned char *)(v12 + 1) = v25 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v68 = 0;
    a2 += v9;
    uint64_t v69 = v76 - a2;
    a3 += v10;
    uint64_t v70 = v8 - a3;
    uint64_t v71 = -4;
    while (((v70 | v69 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) == 0)
    {
      uint64_t v72 = v13 + SHIDWORD(a3) * (uint64_t)v4;
      unint64_t v37 = v72 + 4 * (a2 >> 32);
      unint64_t v38 = *(unsigned int **)(result + 32);
      if (v15 >= v37) {
        uint64_t v73 = (unsigned int *)(v72 + 4 * (a2 >> 32));
      }
      else {
        uint64_t v73 = (unsigned int *)v15;
      }
      if (v73 < v38) {
        uint64_t v73 = *(unsigned int **)(result + 32);
      }
      unsigned int v40 = *v73;
      if (v5)
      {
        unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v41 & 0xF) != 0)
        {
          v12 += v68 + 1;
          v11 -= v71;
          a4 += ~v68;
          unsigned int v25 = -1;
          goto LABEL_40;
        }
      }
      HIDWORD(v74) = v40 | v14;
      LODWORD(v74) = v40 | v14;
      *(_DWORD *)(v11 + 4 * v68 + 8) = v74 >> 24;
      *(unsigned char *)(v12 + v68++ + 2) = -1;
      v71 -= 4;
      a2 += v9;
      v69 -= v9;
      a3 += v10;
      v70 -= v10;
      if (a4 - 1 == v68) {
        return result;
      }
    }
    v12 += v68 + 1;
    v11 -= v71;
    a4 += ~v68;
  }
  while (a4);
  return result;
}

uint64_t rgba32_sample_ARGB32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 64);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v73 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = -16777216;
  }
  int v72 = *(_DWORD *)(result + 188);
  unint64_t v15 = v13 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v7)
      {
        if ((uint64_t)a3 <= v8)
        {
          uint64_t v24 = (a3 >> 22) & 0x3C0;
          unsigned int v25 = 0x3FFFFFFF;
          HIDWORD(v26) = HIDWORD(a3);
        }
        else
        {
          uint64_t v20 = *(void *)(result + 216);
          uint64_t v21 = *(void *)(result + 224) + v8;
          uint64_t v22 = v21 - a3 + (v20 >> 1);
          if (v22 < 1) {
            goto LABEL_37;
          }
          if (v22 >= v20) {
            LODWORD(v23) = 0x3FFFFFFF;
          }
          else {
            unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
          }
          unsigned int v25 = v72 | v23;
          uint64_t v26 = v21 - 0x1000000;
          uint64_t v24 = 448;
        }
      }
      else
      {
        uint64_t v16 = *(void *)(result + 216);
        uint64_t v17 = v7 - *(void *)(result + 224);
        uint64_t v18 = a3 - v17 + (v16 >> 1);
        if (v18 < 1) {
          goto LABEL_37;
        }
        if (v18 >= v16) {
          LODWORD(v19) = 0x3FFFFFFF;
        }
        else {
          unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
        }
        unsigned int v25 = v72 | v19;
        uint64_t v26 = v17 + 0x1000000;
        uint64_t v24 = 512;
      }
      if (a2 >= v6) {
        break;
      }
      uint64_t v27 = *(void *)(result + 192);
      uint64_t v28 = v6 - *(void *)(result + 200);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 >= 1)
      {
        if (v29 < v27) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v72;
        }
        uint64_t v30 = v28 + 0x1000000;
        uint64_t v31 = 32;
        goto LABEL_29;
      }
LABEL_37:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v73)
    {
      uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v30 = a2;
      goto LABEL_29;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = *(void *)(result + 200) + v73;
    uint64_t v34 = v33 - a2 + (v32 >> 1);
    if (v34 < 1) {
      goto LABEL_37;
    }
    if (v34 < v32) {
      unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v72;
    }
    uint64_t v30 = v33 - 0x1000000;
    uint64_t v31 = 28;
LABEL_29:
    if (v25 < 0x400000) {
      goto LABEL_37;
    }
    uint64_t v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
    uint64_t v36 = v30 >> 32;
    unint64_t v37 = v35 + 4 * v36;
    unint64_t v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37) {
      unint64_t v39 = (unsigned int *)(v35 + 4 * v36);
    }
    else {
      unint64_t v39 = (unsigned int *)v15;
    }
    if (v39 < v38) {
      unint64_t v39 = *(unsigned int **)(result + 32);
    }
    unsigned int v40 = bswap32(*v39);
    if (!v5) {
      goto LABEL_69;
    }
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        char v57 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v15 < (unint64_t)v57) {
          char v57 = (unsigned int *)v15;
        }
        if (v57 < v38) {
          char v57 = v38;
        }
        int v58 = interpolate_8888_21358[v43];
        char v59 = v43 + 1;
        unsigned int v60 = v40 - ((v58 & v40) >> v59);
        unsigned int v61 = (bswap32(*v57) & v58) >> v59;
        goto LABEL_68;
      case 2:
        char v62 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
        if (v15 < (unint64_t)v62) {
          char v62 = (unsigned int *)v15;
        }
        if (v62 < v38) {
          char v62 = v38;
        }
        unsigned int v53 = bswap32(*v62);
        int v54 = (v41 >> 28) & 3;
        int v55 = interpolate_8888_21358[v54];
        unsigned int v56 = v55 & v40;
        goto LABEL_67;
      case 3:
        int64_t v44 = (unint64_t)HIWORD(v41) << 56;
        unsigned int v45 = (unsigned int *)(v37 + (v44 >> 54));
        if (v15 < (unint64_t)v45) {
          unsigned int v45 = (unsigned int *)v15;
        }
        if (v45 < v38) {
          unsigned int v45 = v38;
        }
        unsigned int v46 = bswap32(*v45);
        unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v15 >= v47) {
          int64_t v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        }
        else {
          int64_t v48 = (unsigned int *)v15;
        }
        if (v48 < v38) {
          int64_t v48 = v38;
        }
        unsigned int v49 = bswap32(*v48);
        unint64_t v50 = (unsigned int *)(v47 + (v44 >> 54));
        if (v15 < (unint64_t)v50) {
          unint64_t v50 = (unsigned int *)v15;
        }
        if (v50 < v38) {
          unint64_t v50 = v38;
        }
        int v51 = interpolate_8888_21358[v43];
        char v52 = v43 + 1;
        unsigned int v40 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
        unsigned int v53 = v46 - ((v51 & v46) >> v52) + ((bswap32(*v50) & v51) >> v52);
        int v54 = (v41 >> 28) & 3;
        int v55 = interpolate_8888_21358[v54];
        unsigned int v56 = v40 & v55;
LABEL_67:
        char v63 = v54 + 1;
        unsigned int v60 = v40 - (v56 >> v63);
        unsigned int v61 = (v53 & v55) >> v63;
LABEL_68:
        unsigned int v40 = v60 + v61;
        break;
    }
LABEL_69:
    HIDWORD(v64) = v40 | v14;
    LODWORD(v64) = v40 | v14;
    *(_DWORD *)(v11 + 4) = v64 >> 24;
    *(unsigned char *)(v12 + 1) = v25 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v65 = 0;
    a2 += v9;
    uint64_t v66 = v73 - a2;
    a3 += v10;
    uint64_t v67 = v8 - a3;
    uint64_t v68 = -4;
    while (((v67 | v66 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) == 0)
    {
      uint64_t v69 = v13 + SHIDWORD(a3) * (uint64_t)v4;
      unint64_t v37 = v69 + 4 * (a2 >> 32);
      unint64_t v38 = *(unsigned int **)(result + 32);
      if (v15 >= v37) {
        uint64_t v70 = (unsigned int *)(v69 + 4 * (a2 >> 32));
      }
      else {
        uint64_t v70 = (unsigned int *)v15;
      }
      if (v70 < v38) {
        uint64_t v70 = *(unsigned int **)(result + 32);
      }
      unsigned int v40 = bswap32(*v70);
      if (v5)
      {
        unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v41 & 0xF) != 0)
        {
          v12 += v65 + 1;
          v11 -= v68;
          a4 += ~v65;
          unsigned int v25 = -1;
          goto LABEL_40;
        }
      }
      HIDWORD(v71) = v40 | v14;
      LODWORD(v71) = v40 | v14;
      *(_DWORD *)(v11 + 4 * v65 + 8) = v71 >> 24;
      *(unsigned char *)(v12 + v65++ + 2) = -1;
      v68 -= 4;
      a2 += v9;
      v66 -= v9;
      a3 += v10;
      v67 -= v10;
      if (a4 - 1 == v65) {
        return result;
      }
    }
    v12 += v65 + 1;
    v11 -= v68;
    a4 += ~v65;
  }
  while (a4);
  return result;
}

uint64_t rgba32_sample_rgba32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v109 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v109 = v5 % v6;
    }
  }
  else
  {
    uint64_t v109 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v108 = v11;
  }
  else
  {
    uint64_t v108 = 0;
  }
  uint64_t v104 = *(void *)(result + 80);
  uint64_t v105 = *(void *)(result + 64);
  uint64_t v106 = *(void *)(result + 88);
  uint64_t v107 = *(void *)(result + 72);
  int v103 = *(_DWORD *)(result + 188);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = 255;
  }
  unint64_t v15 = v9 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  uint64_t v16 = -*(void *)(result + 64);
  uint64_t v17 = -*(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 < v107)
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v107 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_55;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v28 = v103 | v21;
        uint64_t v29 = v19 + 0x1000000;
        uint64_t v26 = a3 - (v19 + 0x1000000);
        uint64_t v27 = 512;
        goto LABEL_25;
      }
      if (a3 <= v106)
      {
        uint64_t v26 = 0;
        uint64_t v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v28 = 0x3FFFFFFF;
        uint64_t v29 = a3;
LABEL_25:
        uint64_t v30 = v105;
        goto LABEL_28;
      }
      uint64_t v22 = *(void *)(result + 216);
      uint64_t v23 = *(void *)(result + 224) + v106;
      uint64_t v24 = v23 - a3 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_55;
      }
      if (v24 >= v22) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
      }
      uint64_t v30 = v105;
      unsigned int v28 = v103 | v25;
      uint64_t v29 = v23 - 0x1000000;
      uint64_t v26 = a3 - (v23 - 0x1000000);
      uint64_t v27 = 448;
LABEL_28:
      if (a2 >= v30) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v30 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v103;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = a2 - (v32 + 0x1000000);
        uint64_t v36 = 32;
        goto LABEL_39;
      }
LABEL_55:
      --a4;
      a2 += v5;
      a3 += v10;
      v12 += 4;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v104)
    {
      uint64_t v35 = 0;
      uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_39;
    }
    uint64_t v37 = *(void *)(result + 192);
    uint64_t v38 = *(void *)(result + 200) + v104;
    uint64_t v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1) {
      goto LABEL_55;
    }
    if (v39 < v37) {
      unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v103;
    }
    uint64_t v34 = v38 - 0x1000000;
    uint64_t v35 = a2 - (v38 - 0x1000000);
    uint64_t v36 = 28;
LABEL_39:
    if (v28 < 0x400000) {
      goto LABEL_55;
    }
    if (v6)
    {
      uint64_t v40 = (v7 & ((v29 % v7) >> 63)) + v29 % v7;
      uint64_t v41 = (v6 & ((v34 % v6) >> 63)) + v34 % v6;
      if (v40 >= v7) {
        uint64_t v42 = v7;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v29 = v40 - v42;
      if (v41 >= v6) {
        uint64_t v43 = v6;
      }
      else {
        uint64_t v43 = 0;
      }
      uint64_t v34 = v41 - v43;
      v26 += v29;
      v35 += v34;
    }
    uint64_t v44 = v9 + SHIDWORD(v29) * (uint64_t)v4;
    uint64_t v45 = v34 >> 32;
    unint64_t v46 = v44 + 4 * v45;
    unint64_t v47 = *(unsigned int **)(result + 32);
    if (v15 >= v46) {
      int64_t v48 = (unsigned int *)(v44 + 4 * v45);
    }
    else {
      int64_t v48 = (unsigned int *)v15;
    }
    if (v48 < v47) {
      int64_t v48 = *(unsigned int **)(result + 32);
    }
    unsigned int v49 = *v48;
    if (!v8) {
      goto LABEL_104;
    }
    unsigned int v50 = *(_DWORD *)(v8 + (v36 | v27));
LABEL_58:
    int v51 = v50 & 0xF;
    uint64_t v52 = v50 >> 8;
    int v53 = HIBYTE(v50) & 3;
    switch(v51)
    {
      case 1:
        LODWORD(v77) = SBYTE1(v50);
        if (v6)
        {
          uint64_t v78 = v52 << 56;
          uint64_t v79 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v80 = v7 & (v79 >> 63);
          if (v80 + v79 >= v7) {
            uint64_t v81 = v7;
          }
          else {
            uint64_t v81 = 0;
          }
          uint64_t v77 = (v80 + (v78 >> 24) - v81) >> 32;
        }
        uint64_t v82 = (unsigned int *)(v46 + (int)v77 * (uint64_t)v4);
        if (v15 < (unint64_t)v82) {
          uint64_t v82 = (unsigned int *)v15;
        }
        if (v82 < v47) {
          uint64_t v82 = v47;
        }
        int v83 = interpolate_8888_21358[v53];
        char v84 = v53 + 1;
        unsigned int v75 = v49 - ((v83 & v49) >> v84);
        unsigned int v76 = (v83 & *v82) >> v84;
        goto LABEL_93;
      case 2:
        uint64_t v85 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v86 = v35 + ((uint64_t)SBYTE2(v50) << 32);
          uint64_t v87 = v6 & (v86 >> 63);
          if (v87 + v86 >= v6) {
            uint64_t v88 = v6;
          }
          else {
            uint64_t v88 = 0;
          }
          uint64_t v85 = (v87 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v88) >> 32;
        }
        uint64_t v89 = (unsigned int *)(v46 + 4 * v85);
        if (v15 < (unint64_t)v89) {
          uint64_t v89 = (unsigned int *)v15;
        }
        if (v89 < v47) {
          uint64_t v89 = v47;
        }
        unsigned int v49 = v49
            - ((interpolate_8888_21358[(v50 >> 28) & 3] & v49) >> (((v50 >> 28) & 3) + 1))
            + ((interpolate_8888_21358[(v50 >> 28) & 3] & *v89) >> (((v50 >> 28) & 3) + 1));
        break;
      case 3:
        int v102 = HIBYTE(v50) & 3;
        LODWORD(v54) = SBYTE1(v50);
        uint64_t v55 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v101 = v52 << 56;
          int64_t v56 = (unint64_t)HIWORD(v50) << 56;
          uint64_t v57 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v58 = v35 + (v56 >> 24);
          uint64_t v59 = v7 & (v57 >> 63);
          uint64_t v60 = v6 & (v58 >> 63);
          uint64_t v61 = v60 + v58;
          if (v59 + v57 >= v7) {
            uint64_t v62 = v7;
          }
          else {
            uint64_t v62 = 0;
          }
          if (v61 >= v6) {
            uint64_t v63 = v6;
          }
          else {
            uint64_t v63 = 0;
          }
          uint64_t v54 = (v59 + (v101 >> 24) - v62) >> 32;
          uint64_t v55 = (v60 + (v56 >> 24) - v63) >> 32;
        }
        unint64_t v64 = (unsigned int *)(v46 + 4 * v55);
        if (v15 < (unint64_t)v64) {
          unint64_t v64 = (unsigned int *)v15;
        }
        if (v64 < v47) {
          unint64_t v64 = v47;
        }
        unsigned int v65 = *v64;
        unint64_t v66 = v46 + (int)v54 * (uint64_t)v4;
        if (v15 >= v66) {
          uint64_t v67 = (unsigned int *)(v46 + (int)v54 * (uint64_t)v4);
        }
        else {
          uint64_t v67 = (unsigned int *)v15;
        }
        if (v67 < v47) {
          uint64_t v67 = v47;
        }
        unsigned int v68 = *v67;
        uint64_t v69 = (unsigned int *)(v66 + 4 * v55);
        if (v15 < (unint64_t)v69) {
          uint64_t v69 = (unsigned int *)v15;
        }
        if (v69 < v47) {
          uint64_t v69 = v47;
        }
        int v70 = interpolate_8888_21358[v102];
        unsigned int v71 = v49 - ((v70 & v49) >> (v102 + 1)) + ((v70 & v68) >> (v102 + 1));
        unsigned int v72 = v65 - ((v70 & v65) >> (v102 + 1)) + ((v70 & *v69) >> (v102 + 1));
        int v73 = (v50 >> 28) & 3;
        int v74 = interpolate_8888_21358[v73];
        LOBYTE(v73) = v73 + 1;
        unsigned int v75 = v71 - ((v71 & v74) >> v73);
        unsigned int v76 = (v72 & v74) >> v73;
LABEL_93:
        unsigned int v49 = v75 + v76;
        break;
    }
LABEL_104:
    *(_DWORD *)(v12 + 4) = v49 | v14;
    *(unsigned char *)(v13 + 1) = v28 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v90 = 0;
    a2 += v5;
    uint64_t v91 = v104 - a2;
    a3 += v10;
    uint64_t v92 = v106 - a3;
    uint64_t v93 = -4;
    while (((v92 | v91 | (v17 + a3) | (v16 + a2)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v94 = (v7 & ((v26 + v108) >> 63)) + v26 + v108;
        uint64_t v95 = (v6 & ((v35 + v109) >> 63)) + v35 + v109;
        if (v94 >= v7) {
          uint64_t v96 = v7;
        }
        else {
          uint64_t v96 = 0;
        }
        uint64_t v97 = v94 - v96;
        if (v95 >= v6) {
          uint64_t v98 = v6;
        }
        else {
          uint64_t v98 = 0;
        }
        uint64_t v99 = v95 - v98;
        uint64_t v35 = v99;
        uint64_t v26 = v97;
      }
      else
      {
        uint64_t v99 = a2;
        HIDWORD(v97) = HIDWORD(a3);
      }
      unint64_t v46 = v9 + SHIDWORD(v97) * (uint64_t)v4 + 4 * (v99 >> 32);
      unint64_t v47 = *(unsigned int **)(result + 32);
      if (v15 >= v46) {
        float64x2_t v100 = (unsigned int *)v46;
      }
      else {
        float64x2_t v100 = (unsigned int *)v15;
      }
      if (v100 < v47) {
        float64x2_t v100 = *(unsigned int **)(result + 32);
      }
      unsigned int v49 = *v100;
      if (v8)
      {
        unsigned int v50 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v50 & 0xF) != 0)
        {
          v13 += v90 + 1;
          v12 -= v93;
          a4 += ~v90;
          unsigned int v28 = -1;
          goto LABEL_58;
        }
      }
      *(_DWORD *)(v12 + 4 * v90 + 8) = v49 | v14;
      *(unsigned char *)(v13 + v90++ + 2) = -1;
      v93 -= 4;
      a2 += v5;
      v91 -= v5;
      a3 += v10;
      v92 -= v10;
      if (a4 - 1 == v90) {
        return result;
      }
    }
    v13 += v90 + 1;
    v12 -= v93;
    a4 += ~v90;
  }
  while (a4);
  return result;
}

uint64_t rgba32_sample_RGBA32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v109 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v109 = v5 % v6;
    }
  }
  else
  {
    uint64_t v109 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v108 = v11;
  }
  else
  {
    uint64_t v108 = 0;
  }
  uint64_t v104 = *(void *)(result + 80);
  uint64_t v105 = *(void *)(result + 64);
  uint64_t v106 = *(void *)(result + 88);
  uint64_t v107 = *(void *)(result + 72);
  int v103 = *(_DWORD *)(result + 188);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = 255;
  }
  unint64_t v15 = v9 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  uint64_t v16 = -*(void *)(result + 64);
  uint64_t v17 = -*(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 < v107)
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v107 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_55;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v28 = v103 | v21;
        uint64_t v29 = v19 + 0x1000000;
        uint64_t v26 = a3 - (v19 + 0x1000000);
        uint64_t v27 = 512;
        goto LABEL_25;
      }
      if (a3 <= v106)
      {
        uint64_t v26 = 0;
        uint64_t v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v28 = 0x3FFFFFFF;
        uint64_t v29 = a3;
LABEL_25:
        uint64_t v30 = v105;
        goto LABEL_28;
      }
      uint64_t v22 = *(void *)(result + 216);
      uint64_t v23 = *(void *)(result + 224) + v106;
      uint64_t v24 = v23 - a3 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_55;
      }
      if (v24 >= v22) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
      }
      uint64_t v30 = v105;
      unsigned int v28 = v103 | v25;
      uint64_t v29 = v23 - 0x1000000;
      uint64_t v26 = a3 - (v23 - 0x1000000);
      uint64_t v27 = 448;
LABEL_28:
      if (a2 >= v30) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v30 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v103;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = a2 - (v32 + 0x1000000);
        uint64_t v36 = 32;
        goto LABEL_39;
      }
LABEL_55:
      --a4;
      a2 += v5;
      a3 += v10;
      v12 += 4;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v104)
    {
      uint64_t v35 = 0;
      uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_39;
    }
    uint64_t v37 = *(void *)(result + 192);
    uint64_t v38 = *(void *)(result + 200) + v104;
    uint64_t v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1) {
      goto LABEL_55;
    }
    if (v39 < v37) {
      unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v103;
    }
    uint64_t v34 = v38 - 0x1000000;
    uint64_t v35 = a2 - (v38 - 0x1000000);
    uint64_t v36 = 28;
LABEL_39:
    if (v28 < 0x400000) {
      goto LABEL_55;
    }
    if (v6)
    {
      uint64_t v40 = (v7 & ((v29 % v7) >> 63)) + v29 % v7;
      uint64_t v41 = (v6 & ((v34 % v6) >> 63)) + v34 % v6;
      if (v40 >= v7) {
        uint64_t v42 = v7;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v29 = v40 - v42;
      if (v41 >= v6) {
        uint64_t v43 = v6;
      }
      else {
        uint64_t v43 = 0;
      }
      uint64_t v34 = v41 - v43;
      v26 += v29;
      v35 += v34;
    }
    uint64_t v44 = v9 + SHIDWORD(v29) * (uint64_t)v4;
    uint64_t v45 = v34 >> 32;
    unint64_t v46 = v44 + 4 * v45;
    unint64_t v47 = *(unsigned int **)(result + 32);
    if (v15 >= v46) {
      int64_t v48 = (unsigned int *)(v44 + 4 * v45);
    }
    else {
      int64_t v48 = (unsigned int *)v15;
    }
    if (v48 < v47) {
      int64_t v48 = *(unsigned int **)(result + 32);
    }
    unsigned int v49 = bswap32(*v48);
    if (!v8) {
      goto LABEL_104;
    }
    unsigned int v50 = *(_DWORD *)(v8 + (v36 | v27));
LABEL_58:
    int v51 = v50 & 0xF;
    uint64_t v52 = v50 >> 8;
    int v53 = HIBYTE(v50) & 3;
    switch(v51)
    {
      case 1:
        LODWORD(v77) = SBYTE1(v50);
        if (v6)
        {
          uint64_t v78 = v52 << 56;
          uint64_t v79 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v80 = v7 & (v79 >> 63);
          if (v80 + v79 >= v7) {
            uint64_t v81 = v7;
          }
          else {
            uint64_t v81 = 0;
          }
          uint64_t v77 = (v80 + (v78 >> 24) - v81) >> 32;
        }
        uint64_t v82 = (unsigned int *)(v46 + (int)v77 * (uint64_t)v4);
        if (v15 < (unint64_t)v82) {
          uint64_t v82 = (unsigned int *)v15;
        }
        if (v82 < v47) {
          uint64_t v82 = v47;
        }
        int v83 = interpolate_8888_21358[v53];
        char v84 = v53 + 1;
        unsigned int v75 = v49 - ((v83 & v49) >> v84);
        unsigned int v76 = (bswap32(*v82) & v83) >> v84;
        goto LABEL_93;
      case 2:
        uint64_t v85 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v86 = v35 + ((uint64_t)SBYTE2(v50) << 32);
          uint64_t v87 = v6 & (v86 >> 63);
          if (v87 + v86 >= v6) {
            uint64_t v88 = v6;
          }
          else {
            uint64_t v88 = 0;
          }
          uint64_t v85 = (v87 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v88) >> 32;
        }
        uint64_t v89 = (unsigned int *)(v46 + 4 * v85);
        if (v15 < (unint64_t)v89) {
          uint64_t v89 = (unsigned int *)v15;
        }
        if (v89 < v47) {
          uint64_t v89 = v47;
        }
        unsigned int v49 = v49
            - ((interpolate_8888_21358[(v50 >> 28) & 3] & v49) >> (((v50 >> 28) & 3) + 1))
            + ((bswap32(*v89) & interpolate_8888_21358[(v50 >> 28) & 3]) >> (((v50 >> 28) & 3) + 1));
        break;
      case 3:
        int v102 = HIBYTE(v50) & 3;
        LODWORD(v54) = SBYTE1(v50);
        uint64_t v55 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v101 = v52 << 56;
          int64_t v56 = (unint64_t)HIWORD(v50) << 56;
          uint64_t v57 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v58 = v35 + (v56 >> 24);
          uint64_t v59 = v7 & (v57 >> 63);
          uint64_t v60 = v6 & (v58 >> 63);
          uint64_t v61 = v60 + v58;
          if (v59 + v57 >= v7) {
            uint64_t v62 = v7;
          }
          else {
            uint64_t v62 = 0;
          }
          if (v61 >= v6) {
            uint64_t v63 = v6;
          }
          else {
            uint64_t v63 = 0;
          }
          uint64_t v54 = (v59 + (v101 >> 24) - v62) >> 32;
          uint64_t v55 = (v60 + (v56 >> 24) - v63) >> 32;
        }
        unint64_t v64 = (unsigned int *)(v46 + 4 * v55);
        if (v15 < (unint64_t)v64) {
          unint64_t v64 = (unsigned int *)v15;
        }
        if (v64 < v47) {
          unint64_t v64 = v47;
        }
        unsigned int v65 = bswap32(*v64);
        unint64_t v66 = v46 + (int)v54 * (uint64_t)v4;
        if (v15 >= v66) {
          uint64_t v67 = (unsigned int *)(v46 + (int)v54 * (uint64_t)v4);
        }
        else {
          uint64_t v67 = (unsigned int *)v15;
        }
        if (v67 < v47) {
          uint64_t v67 = v47;
        }
        unsigned int v68 = bswap32(*v67);
        uint64_t v69 = (unsigned int *)(v66 + 4 * v55);
        if (v15 < (unint64_t)v69) {
          uint64_t v69 = (unsigned int *)v15;
        }
        if (v69 < v47) {
          uint64_t v69 = v47;
        }
        int v70 = interpolate_8888_21358[v102];
        unsigned int v71 = v49 - ((v70 & v49) >> (v102 + 1)) + ((v70 & v68) >> (v102 + 1));
        unsigned int v72 = v65 - ((v70 & v65) >> (v102 + 1)) + ((bswap32(*v69) & v70) >> (v102 + 1));
        int v73 = (v50 >> 28) & 3;
        int v74 = interpolate_8888_21358[v73];
        LOBYTE(v73) = v73 + 1;
        unsigned int v75 = v71 - ((v71 & v74) >> v73);
        unsigned int v76 = (v72 & v74) >> v73;
LABEL_93:
        unsigned int v49 = v75 + v76;
        break;
    }
LABEL_104:
    *(_DWORD *)(v12 + 4) = v49 | v14;
    *(unsigned char *)(v13 + 1) = v28 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v90 = 0;
    a2 += v5;
    uint64_t v91 = v104 - a2;
    a3 += v10;
    uint64_t v92 = v106 - a3;
    uint64_t v93 = -4;
    while (((v92 | v91 | (v17 + a3) | (v16 + a2)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v94 = (v7 & ((v26 + v108) >> 63)) + v26 + v108;
        uint64_t v95 = (v6 & ((v35 + v109) >> 63)) + v35 + v109;
        if (v94 >= v7) {
          uint64_t v96 = v7;
        }
        else {
          uint64_t v96 = 0;
        }
        uint64_t v97 = v94 - v96;
        if (v95 >= v6) {
          uint64_t v98 = v6;
        }
        else {
          uint64_t v98 = 0;
        }
        uint64_t v99 = v95 - v98;
        uint64_t v35 = v99;
        uint64_t v26 = v97;
      }
      else
      {
        uint64_t v99 = a2;
        HIDWORD(v97) = HIDWORD(a3);
      }
      unint64_t v46 = v9 + SHIDWORD(v97) * (uint64_t)v4 + 4 * (v99 >> 32);
      unint64_t v47 = *(unsigned int **)(result + 32);
      if (v15 >= v46) {
        float64x2_t v100 = (unsigned int *)v46;
      }
      else {
        float64x2_t v100 = (unsigned int *)v15;
      }
      if (v100 < v47) {
        float64x2_t v100 = *(unsigned int **)(result + 32);
      }
      unsigned int v49 = bswap32(*v100);
      if (v8)
      {
        unsigned int v50 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v50 & 0xF) != 0)
        {
          v13 += v90 + 1;
          v12 -= v93;
          a4 += ~v90;
          unsigned int v28 = -1;
          goto LABEL_58;
        }
      }
      *(_DWORD *)(v12 + 4 * v90 + 8) = v49 | v14;
      *(unsigned char *)(v13 + v90++ + 2) = -1;
      v93 -= 4;
      a2 += v5;
      v91 -= v5;
      a3 += v10;
      v92 -= v10;
      if (a4 - 1 == v90) {
        return result;
      }
    }
    v13 += v90 + 1;
    v12 -= v93;
    a4 += ~v90;
  }
  while (a4);
  return result;
}

uint64_t rgba32_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 64);
  uint64_t v8 = *(void *)(result + 72);
  uint64_t v9 = *(void *)(result + 88);
  uint64_t v72 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v11 = *(void *)(result + 120);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  int v71 = *(_DWORD *)(result + 188);
  unint64_t v14 = v4 + (3 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v5) - 3;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v8)
      {
        if ((uint64_t)a3 <= v9)
        {
          uint64_t v23 = (a3 >> 22) & 0x3C0;
          unsigned int v24 = 0x3FFFFFFF;
          HIDWORD(v25) = HIDWORD(a3);
        }
        else
        {
          uint64_t v19 = *(void *)(result + 216);
          uint64_t v20 = *(void *)(result + 224) + v9;
          uint64_t v21 = v20 - a3 + (v19 >> 1);
          if (v21 < 1) {
            goto LABEL_34;
          }
          if (v21 >= v19) {
            LODWORD(v22) = 0x3FFFFFFF;
          }
          else {
            unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
          }
          unsigned int v24 = v71 | v22;
          uint64_t v25 = v20 - 0x1000000;
          uint64_t v23 = 448;
        }
      }
      else
      {
        uint64_t v15 = *(void *)(result + 216);
        uint64_t v16 = v8 - *(void *)(result + 224);
        uint64_t v17 = a3 - v16 + (v15 >> 1);
        if (v17 < 1) {
          goto LABEL_34;
        }
        if (v17 >= v15) {
          LODWORD(v18) = 0x3FFFFFFF;
        }
        else {
          unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
        }
        unsigned int v24 = v71 | v18;
        uint64_t v25 = v16 + 0x1000000;
        uint64_t v23 = 512;
      }
      if (a2 >= v7) {
        break;
      }
      uint64_t v26 = *(void *)(result + 192);
      uint64_t v27 = v7 - *(void *)(result + 200);
      uint64_t v28 = a2 - v27 + (v26 >> 1);
      if (v28 >= 1)
      {
        if (v28 < v26) {
          unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v71;
        }
        uint64_t v29 = v27 + 0x1000000;
        uint64_t v30 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v10;
      a3 += v11;
      v12 += 4;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v72)
    {
      uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v29 = a2;
      goto LABEL_26;
    }
    uint64_t v31 = *(void *)(result + 192);
    uint64_t v32 = *(void *)(result + 200) + v72;
    uint64_t v33 = v32 - a2 + (v31 >> 1);
    if (v33 < 1) {
      goto LABEL_34;
    }
    if (v33 < v31) {
      unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v71;
    }
    uint64_t v29 = v32 - 0x1000000;
    uint64_t v30 = 28;
LABEL_26:
    if (v24 < 0x400000) {
      goto LABEL_34;
    }
    uint64_t v34 = v4 + SHIDWORD(v25) * (uint64_t)v5;
    uint64_t v35 = 3 * (v29 >> 32);
    uint64_t v36 = v34 + v35;
    uint64_t v37 = *(unsigned __int8 **)(result + 32);
    if (v14 >= v34 + v35) {
      uint64_t v38 = (unsigned __int8 *)(v34 + v35);
    }
    else {
      uint64_t v38 = (unsigned __int8 *)v14;
    }
    if (v38 < v37) {
      uint64_t v38 = *(unsigned __int8 **)(result + 32);
    }
    int v39 = (v38[1] << 16) | (*v38 << 24) | (v38[2] << 8) | 0xFF;
    if (!v6) {
      goto LABEL_66;
    }
    unsigned int v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
    int v41 = v40 & 0xF;
    int v42 = HIBYTE(v40) & 3;
    switch(v41)
    {
      case 1:
        uint64_t v58 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
        if (v14 < (unint64_t)v58) {
          uint64_t v58 = (unsigned __int8 *)v14;
        }
        if (v58 < v37) {
          uint64_t v58 = v37;
        }
        unsigned int v59 = interpolate_8888_21358[v42];
        char v60 = v42 + 1;
        unsigned int v57 = v39 - ((v59 & v39) >> v60);
        unsigned int v61 = (((v58[1] << 16) | (*v58 << 24) | (v58[2] << 8) | 0xFF) & v59) >> v60;
        goto LABEL_65;
      case 2:
        uint64_t v62 = (unsigned __int8 *)(v36 + 3 * SBYTE2(v40));
        if (v14 < (unint64_t)v62) {
          uint64_t v62 = (unsigned __int8 *)v14;
        }
        if (v62 < v37) {
          uint64_t v62 = v37;
        }
        int v53 = (v62[1] << 16) | (*v62 << 24) | (v62[2] << 8) | 0xFF;
        int v63 = (v40 >> 28) & 3;
        unsigned int v55 = interpolate_8888_21358[v63];
        char v56 = v63 + 1;
        unsigned int v57 = v39 - ((v55 & v39) >> v56);
        goto LABEL_64;
      case 3:
        uint64_t v43 = 3 * SBYTE2(v40);
        uint64_t v44 = (unsigned __int8 *)(v36 + v43);
        if (v14 < v36 + v43) {
          uint64_t v44 = (unsigned __int8 *)v14;
        }
        if (v44 < v37) {
          uint64_t v44 = v37;
        }
        unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v5;
        if (v14 >= v46) {
          unint64_t v47 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
        }
        else {
          unint64_t v47 = (unsigned __int8 *)v14;
        }
        if (v47 < v37) {
          unint64_t v47 = v37;
        }
        int v48 = (v47[1] << 16) | (*v47 << 24) | (v47[2] << 8) | 0xFF;
        unsigned int v49 = (unsigned __int8 *)(v46 + v43);
        if (v14 < (unint64_t)v49) {
          unsigned int v49 = (unsigned __int8 *)v14;
        }
        if (v49 < v37) {
          unsigned int v49 = v37;
        }
        unsigned int v50 = interpolate_8888_21358[v42];
        char v51 = v42 + 1;
        unsigned int v52 = v39 - ((v50 & v39) >> v51) + ((v48 & v50) >> v51);
        int v45 = (v44[1] << 16) | (*v44 << 24) | (v44[2] << 8) | 0xFF;
        int v53 = v45 - ((v50 & v45) >> v51) + ((((v49[1] << 16) | (*v49 << 24) | (v49[2] << 8) | 0xFF) & v50) >> v51);
        int v54 = (v40 >> 28) & 3;
        unsigned int v55 = interpolate_8888_21358[v54];
        char v56 = v54 + 1;
        unsigned int v57 = v52 - ((v52 & v55) >> v56);
LABEL_64:
        unsigned int v61 = (v53 & v55) >> v56;
LABEL_65:
        int v39 = v57 + v61;
        break;
    }
LABEL_66:
    *(_DWORD *)(v12 + 4) = v39;
    *(unsigned char *)(v13 + 1) = v24 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v64 = 0;
    a2 += v10;
    uint64_t v65 = v72 - a2;
    a3 += v11;
    uint64_t v66 = v9 - a3;
    uint64_t v67 = -4;
    while (((v66 | v65 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) == 0)
    {
      uint64_t v68 = v4 + SHIDWORD(a3) * (uint64_t)v5;
      uint64_t v69 = 3 * (a2 >> 32);
      uint64_t v36 = v68 + v69;
      uint64_t v37 = *(unsigned __int8 **)(result + 32);
      if (v14 >= v68 + v69) {
        int v70 = (unsigned __int8 *)(v68 + v69);
      }
      else {
        int v70 = (unsigned __int8 *)v14;
      }
      if (v70 < v37) {
        int v70 = *(unsigned __int8 **)(result + 32);
      }
      int v39 = (v70[1] << 16) | (*v70 << 24) | (v70[2] << 8) | 0xFF;
      if (v6)
      {
        unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v40 & 0xF) != 0)
        {
          v13 += v64 + 1;
          v12 -= v67;
          a4 += ~v64;
          unsigned int v24 = -1;
          goto LABEL_37;
        }
      }
      *(_DWORD *)(v12 + 4 * v64 + 8) = v39;
      *(unsigned char *)(v13 + v64++ + 2) = -1;
      v67 -= 4;
      a2 += v10;
      v65 -= v10;
      a3 += v11;
      v66 -= v11;
      if (a4 - 1 == v64) {
        return result;
      }
    }
    v13 += v64 + 1;
    v12 -= v67;
    a4 += ~v64;
  }
  while (a4);
  return result;
}

uint64_t rgba32_sample_rgb555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v91 = *(void *)(result + 152) - 4;
  uint64_t v89 = *(void *)(result + 88);
  uint64_t v90 = *(void *)(result + 144) - 1;
  if (v5) {
    int v11 = 0;
  }
  else {
    int v11 = -16777216;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  int v85 = *(_DWORD *)(result + 188);
  unint64_t v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  unint64_t v15 = v4 + (v12 * v6) + 2 * v13 - 4;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v86 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v86;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v89;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v86;
        unsigned int v25 = v85 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v88 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v86;
      unsigned int v25 = v85 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v85;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v90 = 0;
    v91 += 4;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v87)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v87;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v85;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  uint64_t v38 = v4 + (int)v36 * (uint64_t)v6;
  unint64_t v39 = v38 + 2 * v37;
  unsigned int v40 = *(unsigned __int16 **)(result + 32);
  if (v15 >= v39) {
    int v41 = (unsigned __int16 *)(v38 + 2 * v37);
  }
  else {
    int v41 = (unsigned __int16 *)v15;
  }
  if (v41 < v40) {
    int v41 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v42 = *v41;
  if (!v5)
  {
    unint64_t v43 = 0;
    if (!v8) {
      goto LABEL_103;
    }
LABEL_46:
    unsigned int v46 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    int v47 = v46 & 0xF;
    int v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      uint64_t v65 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
      if (v15 < (unint64_t)v65) {
        uint64_t v65 = (unsigned __int16 *)v15;
      }
      if (v65 < v40) {
        uint64_t v65 = v40;
      }
      unsigned int v66 = *v65;
      if (v5)
      {
        uint64_t v67 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
        if (v14 < v67) {
          uint64_t v67 = v14;
        }
        if ((unint64_t)v67 < *(void *)(result + 40)) {
          uint64_t v67 = *(unsigned __int8 **)(result + 40);
        }
        v66 |= *v67 << 24;
      }
      int v68 = interpolate_8555_21359[v48];
      char v69 = v48 + 1;
      unsigned int v70 = v42 - ((v68 & v42) >> v69);
      unsigned int v71 = (v68 & v66) >> v69;
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          int64_t v49 = (unint64_t)HIWORD(v46) << 56;
          unsigned int v50 = (unsigned __int16 *)(v39 + (v49 >> 55));
          if (v15 < (unint64_t)v50) {
            unsigned int v50 = (unsigned __int16 *)v15;
          }
          if (v50 < v40) {
            unsigned int v50 = v40;
          }
          unsigned int v51 = *v50;
          unint64_t v52 = v39 + SBYTE1(v46) * (uint64_t)v6;
          if (v15 >= v52) {
            int v53 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
          }
          else {
            int v53 = (unsigned __int16 *)v15;
          }
          if (v53 < v40) {
            int v53 = v40;
          }
          unsigned int v54 = *v53;
          unsigned int v55 = (unsigned __int16 *)(v52 + (v49 >> 55));
          if (v15 < (unint64_t)v55) {
            unsigned int v55 = (unsigned __int16 *)v15;
          }
          if (v55 < v40) {
            unsigned int v55 = v40;
          }
          unsigned int v56 = *v55;
          if (v5)
          {
            unsigned int v57 = (unsigned __int8 *)(v43 + SBYTE2(v46));
            unint64_t v58 = *(void *)(result + 40);
            if (v14 < v57) {
              unsigned int v57 = v14;
            }
            if ((unint64_t)v57 < v58) {
              unsigned int v57 = *(unsigned __int8 **)(result + 40);
            }
            v51 |= *v57 << 24;
            unint64_t v59 = v43 + SBYTE1(v46) * (uint64_t)v7;
            if ((unint64_t)v14 >= v59) {
              char v60 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
            }
            else {
              char v60 = v14;
            }
            if ((unint64_t)v60 < v58) {
              char v60 = *(unsigned __int8 **)(result + 40);
            }
            v54 |= *v60 << 24;
            unsigned int v61 = (unsigned __int8 *)(v59 + SBYTE2(v46));
            if (v14 < v61) {
              unsigned int v61 = v14;
            }
            if ((unint64_t)v61 < v58) {
              unsigned int v61 = *(unsigned __int8 **)(result + 40);
            }
            v56 |= *v61 << 24;
          }
          int v62 = interpolate_8555_21359[v48];
          char v63 = v48 + 1;
          unsigned int v64 = v42 - ((v62 & v42) >> v63) + ((v62 & v54) >> v63);
          unsigned int v42 = v64
              - ((v64 & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1))
              + (((v51 - ((v62 & v51) >> v63) + ((v62 & v56) >> v63)) & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      uint64_t v72 = (unsigned __int16 *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 55));
      if (v15 < (unint64_t)v72) {
        uint64_t v72 = (unsigned __int16 *)v15;
      }
      if (v72 < v40) {
        uint64_t v72 = v40;
      }
      unsigned int v73 = *v72;
      if (v5)
      {
        int v74 = (unsigned __int8 *)(v43 + SBYTE2(v46));
        if (v14 < v74) {
          int v74 = v14;
        }
        if ((unint64_t)v74 < *(void *)(result + 40)) {
          int v74 = *(unsigned __int8 **)(result + 40);
        }
        v73 |= *v74 << 24;
      }
      int v75 = (v46 >> 28) & 3;
      int v76 = interpolate_8555_21359[v75];
      LOBYTE(v75) = v75 + 1;
      unsigned int v70 = v42 - ((v76 & v42) >> v75);
      unsigned int v71 = (v76 & v73) >> v75;
    }
    unsigned int v42 = v70 + v71;
    goto LABEL_103;
  }
  unint64_t v43 = v5 + (int)v36 * (uint64_t)v7 + v37;
  uint64_t v44 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v43) {
    int v45 = (unsigned __int8 *)v43;
  }
  else {
    int v45 = v14;
  }
  if (v45 >= v44) {
    uint64_t v44 = v45;
  }
  v42 |= *v44 << 24;
  if (v8) {
    goto LABEL_46;
  }
LABEL_103:
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  a3 += v9;
  uint64_t v79 = v89 - a3;
  a2 += v10;
  uint64_t v80 = v87 - a2;
  while (1)
  {
    unsigned int v81 = (v42 << 14) & 0xF80000 | ((v42 >> 10) << 27) | ((v42 & 0x1F) << 11);
    *(_DWORD *)(v91 + 4 + 4 * v77) = (v81 >> 5) & 0x3F3F3F3F | ((v11 | (v42 >> 5) | v42) >> 24) | v81;
    *(unsigned char *)(v90 + 1 + v77) = v25 >> 22;
    if (a4 - 1 == v77) {
      return result;
    }
    if ((v79 | v80 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v77 + 1;
      uint64_t v91 = v91 - v78 + 4;
      a4 += ~v77;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v39 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32);
    unsigned int v40 = *(unsigned __int16 **)(result + 32);
    if (v15 >= v39) {
      uint64_t v82 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32));
    }
    else {
      uint64_t v82 = (unsigned __int16 *)v15;
    }
    if (v82 < v40) {
      uint64_t v82 = *(unsigned __int16 **)(result + 32);
    }
    unsigned int v42 = *v82;
    if (v5)
    {
      unint64_t v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      int v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v43) {
        unint64_t v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      }
      else {
        unint64_t v84 = (unint64_t)v14;
      }
      if (v84 >= (unint64_t)v83) {
        int v83 = (unsigned __int8 *)v84;
      }
      v42 |= *v83 << 24;
    }
    if (v8)
    {
      unsigned int v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v90 += v77 + 1;
        uint64_t v91 = v91 - v78 + 4;
        a4 += ~v77;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v78 -= 4;
    ++v77;
    a3 += v9;
    v79 -= v9;
    a2 += v10;
    v80 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t rgba32_sample_RGB555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v91 = *(void *)(result + 152) - 4;
  uint64_t v89 = *(void *)(result + 88);
  uint64_t v90 = *(void *)(result + 144) - 1;
  if (v5) {
    int v11 = 0;
  }
  else {
    int v11 = -16777216;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  int v85 = *(_DWORD *)(result + 188);
  unint64_t v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  unint64_t v15 = v4 + (v12 * v6) + 2 * v13 - 4;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v86 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v86;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v89;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v86;
        unsigned int v25 = v85 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v88 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v86;
      unsigned int v25 = v85 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v85;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v90 = 0;
    v91 += 4;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v87)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v87;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v85;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  uint64_t v38 = v4 + (int)v36 * (uint64_t)v6;
  unint64_t v39 = v38 + 2 * v37;
  unsigned int v40 = *(unsigned __int16 **)(result + 32);
  if (v15 >= v39) {
    int v41 = (unsigned __int16 *)(v38 + 2 * v37);
  }
  else {
    int v41 = (unsigned __int16 *)v15;
  }
  if (v41 < v40) {
    int v41 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v42 = bswap32(*v41) >> 16;
  if (!v5)
  {
    unint64_t v43 = 0;
    if (!v8) {
      goto LABEL_103;
    }
LABEL_46:
    unsigned int v46 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    int v47 = v46 & 0xF;
    int v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      uint64_t v65 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
      if (v15 < (unint64_t)v65) {
        uint64_t v65 = (unsigned __int16 *)v15;
      }
      if (v65 < v40) {
        uint64_t v65 = v40;
      }
      unsigned int v66 = bswap32(*v65) >> 16;
      if (v5)
      {
        uint64_t v67 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
        if (v14 < v67) {
          uint64_t v67 = v14;
        }
        if ((unint64_t)v67 < *(void *)(result + 40)) {
          uint64_t v67 = *(unsigned __int8 **)(result + 40);
        }
        v66 |= *v67 << 24;
      }
      int v68 = interpolate_8555_21359[v48];
      char v69 = v48 + 1;
      unsigned int v70 = v42 - ((v68 & v42) >> v69);
      unsigned int v71 = (v68 & v66) >> v69;
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          int64_t v49 = (unint64_t)HIWORD(v46) << 56;
          unsigned int v50 = (unsigned __int16 *)(v39 + (v49 >> 55));
          if (v15 < (unint64_t)v50) {
            unsigned int v50 = (unsigned __int16 *)v15;
          }
          if (v50 < v40) {
            unsigned int v50 = v40;
          }
          unsigned int v51 = bswap32(*v50) >> 16;
          unint64_t v52 = v39 + SBYTE1(v46) * (uint64_t)v6;
          if (v15 >= v52) {
            int v53 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
          }
          else {
            int v53 = (unsigned __int16 *)v15;
          }
          if (v53 < v40) {
            int v53 = v40;
          }
          unsigned int v54 = bswap32(*v53) >> 16;
          unsigned int v55 = (unsigned __int16 *)(v52 + (v49 >> 55));
          if (v15 < (unint64_t)v55) {
            unsigned int v55 = (unsigned __int16 *)v15;
          }
          if (v55 < v40) {
            unsigned int v55 = v40;
          }
          unsigned int v56 = bswap32(*v55) >> 16;
          if (v5)
          {
            unsigned int v57 = (unsigned __int8 *)(v43 + SBYTE2(v46));
            unint64_t v58 = *(void *)(result + 40);
            if (v14 < v57) {
              unsigned int v57 = v14;
            }
            if ((unint64_t)v57 < v58) {
              unsigned int v57 = *(unsigned __int8 **)(result + 40);
            }
            v51 |= *v57 << 24;
            unint64_t v59 = v43 + SBYTE1(v46) * (uint64_t)v7;
            if ((unint64_t)v14 >= v59) {
              char v60 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
            }
            else {
              char v60 = v14;
            }
            if ((unint64_t)v60 < v58) {
              char v60 = *(unsigned __int8 **)(result + 40);
            }
            v54 |= *v60 << 24;
            unsigned int v61 = (unsigned __int8 *)(v59 + SBYTE2(v46));
            if (v14 < v61) {
              unsigned int v61 = v14;
            }
            if ((unint64_t)v61 < v58) {
              unsigned int v61 = *(unsigned __int8 **)(result + 40);
            }
            v56 |= *v61 << 24;
          }
          int v62 = interpolate_8555_21359[v48];
          char v63 = v48 + 1;
          unsigned int v64 = v42 - ((v62 & v42) >> v63) + ((v62 & v54) >> v63);
          unsigned int v42 = v64
              - ((v64 & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1))
              + (((v51 - ((v62 & v51) >> v63) + ((v62 & v56) >> v63)) & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      uint64_t v72 = (unsigned __int16 *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 55));
      if (v15 < (unint64_t)v72) {
        uint64_t v72 = (unsigned __int16 *)v15;
      }
      if (v72 < v40) {
        uint64_t v72 = v40;
      }
      unsigned int v73 = bswap32(*v72) >> 16;
      if (v5)
      {
        int v74 = (unsigned __int8 *)(v43 + SBYTE2(v46));
        if (v14 < v74) {
          int v74 = v14;
        }
        if ((unint64_t)v74 < *(void *)(result + 40)) {
          int v74 = *(unsigned __int8 **)(result + 40);
        }
        v73 |= *v74 << 24;
      }
      int v75 = (v46 >> 28) & 3;
      int v76 = interpolate_8555_21359[v75];
      LOBYTE(v75) = v75 + 1;
      unsigned int v70 = v42 - ((v76 & v42) >> v75);
      unsigned int v71 = (v76 & v73) >> v75;
    }
    unsigned int v42 = v70 + v71;
    goto LABEL_103;
  }
  unint64_t v43 = v5 + (int)v36 * (uint64_t)v7 + v37;
  uint64_t v44 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v43) {
    int v45 = (unsigned __int8 *)v43;
  }
  else {
    int v45 = v14;
  }
  if (v45 >= v44) {
    uint64_t v44 = v45;
  }
  v42 |= *v44 << 24;
  if (v8) {
    goto LABEL_46;
  }
LABEL_103:
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  a3 += v9;
  uint64_t v79 = v89 - a3;
  a2 += v10;
  uint64_t v80 = v87 - a2;
  while (1)
  {
    unsigned int v81 = (v42 << 14) & 0xF80000 | ((v42 >> 10) << 27) | ((v42 & 0x1F) << 11);
    *(_DWORD *)(v91 + 4 + 4 * v77) = (v81 >> 5) & 0x3F3F3F3F | ((v11 | (v42 >> 5) | v42) >> 24) | v81;
    *(unsigned char *)(v90 + 1 + v77) = v25 >> 22;
    if (a4 - 1 == v77) {
      return result;
    }
    if ((v79 | v80 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v77 + 1;
      uint64_t v91 = v91 - v78 + 4;
      a4 += ~v77;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v39 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32);
    unsigned int v40 = *(unsigned __int16 **)(result + 32);
    if (v15 >= v39) {
      uint64_t v82 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32));
    }
    else {
      uint64_t v82 = (unsigned __int16 *)v15;
    }
    if (v82 < v40) {
      uint64_t v82 = *(unsigned __int16 **)(result + 32);
    }
    unsigned int v42 = bswap32(*v82) >> 16;
    if (v5)
    {
      unint64_t v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      int v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v43) {
        unint64_t v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      }
      else {
        unint64_t v84 = (unint64_t)v14;
      }
      if (v84 >= (unint64_t)v83) {
        int v83 = (unsigned __int8 *)v84;
      }
      v42 |= *v83 << 24;
    }
    if (v8)
    {
      unsigned int v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v90 += v77 + 1;
        uint64_t v91 = v91 - v78 + 4;
        a4 += ~v77;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v78 -= 4;
    ++v77;
    a3 += v9;
    v79 -= v9;
    a2 += v10;
    v80 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t rgba32_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v90 = *(void *)(result + 80);
  uint64_t v92 = *(void *)(result + 88);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  if (v5) {
    int v13 = 0;
  }
  else {
    int v13 = -16777216;
  }
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  uint64_t v16 = (unsigned __int8 *)(v5 + (v15 - 1) + (v14 * v7));
  int v89 = *(_DWORD *)(result + 188);
  unint64_t v17 = v4 + v15 + (v14 * v6) - 1;
  uint64_t v91 = *(void *)(result + 64);
  uint64_t v93 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v93)
      {
        if (a3 <= v92)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
          uint64_t v29 = v91;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v92;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_43;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          uint64_t v29 = v91;
          unsigned int v27 = v89 | v25;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v93 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_43;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v29 = v91;
        unsigned int v27 = v89 | v21;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v29) {
        break;
      }
      uint64_t v30 = *(void *)(result + 192);
      uint64_t v31 = v29 - *(void *)(result + 200);
      uint64_t v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v89;
        }
        uint64_t v33 = v31 + 0x1000000;
        uint64_t v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 4;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v90)
    {
      uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v33 = a2;
      goto LABEL_29;
    }
    uint64_t v35 = *(void *)(result + 192);
    uint64_t v36 = *(void *)(result + 200) + v90;
    uint64_t v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1) {
      goto LABEL_43;
    }
    if (v37 < v35) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v89;
    }
    uint64_t v33 = v36 - 0x1000000;
    uint64_t v34 = 28;
LABEL_29:
    if (v27 < 0x400000) {
      goto LABEL_43;
    }
    uint64_t v38 = v28 >> 32;
    uint64_t v39 = v4 + (int)v38 * (uint64_t)v6;
    unint64_t v40 = v39 + (v33 >> 32);
    int v41 = *(unsigned __int8 **)(result + 32);
    if (v17 >= v40) {
      unsigned int v42 = (unsigned __int8 *)(v39 + (v33 >> 32));
    }
    else {
      unsigned int v42 = (unsigned __int8 *)v17;
    }
    if (v42 < v41) {
      unsigned int v42 = *(unsigned __int8 **)(result + 32);
    }
    unsigned int v43 = *v42;
    if (v5)
    {
      unint64_t v44 = v5 + (int)v38 * (uint64_t)v7 + (v33 >> 32);
      int v45 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v44) {
        unsigned int v46 = (unsigned __int8 *)v44;
      }
      else {
        unsigned int v46 = v16;
      }
      if (v46 >= v45) {
        int v45 = v46;
      }
      v43 |= *v45 << 24;
      if (!v8) {
        goto LABEL_104;
      }
    }
    else
    {
      unint64_t v44 = 0;
      if (!v8) {
        goto LABEL_104;
      }
    }
    unsigned int v47 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    int v48 = v47 & 0xF;
    int v49 = HIBYTE(v47) & 3;
    switch(v48)
    {
      case 1:
        unsigned int v70 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        if (v17 < (unint64_t)v70) {
          unsigned int v70 = (unsigned __int8 *)v17;
        }
        if (v70 < v41) {
          unsigned int v70 = v41;
        }
        unsigned int v71 = *v70;
        if (v5)
        {
          uint64_t v72 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          if (v16 < v72) {
            uint64_t v72 = v16;
          }
          if ((unint64_t)v72 < *(void *)(result + 40)) {
            uint64_t v72 = *(unsigned __int8 **)(result + 40);
          }
          v71 |= *v72 << 24;
        }
        int v73 = interpolate_8888_21358[v49];
        char v74 = v49 + 1;
        unsigned int v68 = v43 - ((v73 & v43) >> v74);
        unsigned int v75 = (v73 & v71) >> v74;
        goto LABEL_103;
      case 2:
        int v76 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v76) {
          int v76 = (unsigned __int8 *)v17;
        }
        if (v76 < v41) {
          int v76 = v41;
        }
        int v77 = *v76;
        if (v5)
        {
          uint64_t v78 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          if (v16 < v78) {
            uint64_t v78 = v16;
          }
          if ((unint64_t)v78 < *(void *)(result + 40)) {
            uint64_t v78 = *(unsigned __int8 **)(result + 40);
          }
          v77 |= *v78 << 24;
        }
        int v79 = (v47 >> 28) & 3;
        int v80 = interpolate_8888_21358[v79];
        char v67 = v79 + 1;
        unsigned int v68 = v43 - ((v80 & v43) >> v67);
        unsigned int v69 = v80 & v77;
        goto LABEL_102;
      case 3:
        unsigned int v50 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v50) {
          unsigned int v50 = (unsigned __int8 *)v17;
        }
        if (v50 < v41) {
          unsigned int v50 = v41;
        }
        unsigned int v51 = *v50;
        unint64_t v52 = v40 + SBYTE1(v47) * (uint64_t)v6;
        if (v17 >= v52) {
          int v53 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        }
        else {
          int v53 = (unsigned __int8 *)v17;
        }
        if (v53 < v41) {
          int v53 = v41;
        }
        unsigned int v88 = *v53;
        unsigned int v54 = (unsigned __int8 *)(v52 + SBYTE2(v47));
        if (v17 < (unint64_t)v54) {
          unsigned int v54 = (unsigned __int8 *)v17;
        }
        if (v54 < v41) {
          unsigned int v54 = v41;
        }
        unsigned int v55 = *v54;
        if (v5)
        {
          unsigned int v56 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          unint64_t v57 = *(void *)(result + 40);
          if (v16 < v56) {
            unsigned int v56 = v16;
          }
          if ((unint64_t)v56 < v57) {
            unsigned int v56 = *(unsigned __int8 **)(result + 40);
          }
          v51 |= *v56 << 24;
          unint64_t v58 = v44 + SBYTE1(v47) * (uint64_t)v7;
          if ((unint64_t)v16 >= v58) {
            unint64_t v59 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          }
          else {
            unint64_t v59 = v16;
          }
          if ((unint64_t)v59 < v57) {
            unint64_t v59 = *(unsigned __int8 **)(result + 40);
          }
          v88 |= *v59 << 24;
          char v60 = (unsigned __int8 *)(v58 + SBYTE2(v47));
          if (v16 < v60) {
            char v60 = v16;
          }
          if ((unint64_t)v60 < v57) {
            char v60 = *(unsigned __int8 **)(result + 40);
          }
          v55 |= *v60 << 24;
        }
        int v61 = interpolate_8888_21358[v49];
        char v62 = v49 + 1;
        unsigned int v63 = v43 - ((v61 & v43) >> v62) + ((v61 & v88) >> v62);
        unsigned int v64 = v51 - ((v61 & v51) >> v62) + ((v61 & v55) >> v62);
        int v65 = (v47 >> 28) & 3;
        int v66 = interpolate_8888_21358[v65];
        char v67 = v65 + 1;
        unsigned int v68 = v63 - ((v63 & v66) >> v67);
        unsigned int v69 = v64 & v66;
LABEL_102:
        unsigned int v75 = v69 >> v67;
LABEL_103:
        unsigned int v43 = v68 + v75;
        break;
    }
LABEL_104:
    *(_DWORD *)(v11 + 4) = bswap32(v43 & 0xFF0000FF | v13) | (v43 << 16) | (v43 << 8);
    *(unsigned char *)(v12 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v81 = 0;
    a2 += v10;
    uint64_t v82 = v90 - a2;
    a3 += v9;
    uint64_t v83 = v92 - a3;
    uint64_t v84 = -4;
    while (((v83 | v82 | (a3 - v93) | (a2 - v91)) & 0x8000000000000000) == 0)
    {
      unint64_t v40 = v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32);
      int v41 = *(unsigned __int8 **)(result + 32);
      if (v17 >= v40) {
        int v85 = (unsigned __int8 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32));
      }
      else {
        int v85 = (unsigned __int8 *)v17;
      }
      if (v85 < v41) {
        int v85 = *(unsigned __int8 **)(result + 32);
      }
      unsigned int v43 = *v85;
      if (v5)
      {
        unint64_t v44 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        uint64_t v86 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v44) {
          unint64_t v87 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        }
        else {
          unint64_t v87 = (unint64_t)v16;
        }
        if (v87 >= (unint64_t)v86) {
          uint64_t v86 = (unsigned __int8 *)v87;
        }
        v43 |= *v86 << 24;
      }
      if (v8)
      {
        unsigned int v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v47 & 0xF) != 0)
        {
          v12 += v81 + 1;
          v11 -= v84;
          a4 += ~v81;
          unsigned int v27 = -1;
          goto LABEL_48;
        }
      }
      *(_DWORD *)(v11 + 4 * v81 + 8) = bswap32(v43 & 0xFF0000FF | v13) | (v43 << 16) | (v43 << 8);
      *(unsigned char *)(v12 + v81++ + 2) = -1;
      v84 -= 4;
      a2 += v10;
      v82 -= v10;
      a3 += v9;
      v83 -= v9;
      if (a4 - 1 == v81) {
        return result;
      }
    }
    v12 += v81 + 1;
    v11 -= v84;
    a4 += ~v81;
  }
  while (a4);
  return result;
}

unint64_t PDM_21362(unsigned int a1, int a2)
{
  unsigned int v2 = ((a1 >> 8) & 0xFF00FF) * (a2 ^ 0xFF) + 8388736;
  uint64_t v3 = ((((((a1 & 0xFF00FF) * (a2 ^ 0xFF) + 8388736) >> 8) & 0xFF00FF) + (a1 & 0xFF00FF) * (a2 ^ 0xFF) + 8388736) >> 8) & 0xFF00FF | (((v2 >> 8) & 0xFF00FF) + v2) & 0xFF00FF00;
  unint64_t v4 = (((a1 | ((unint64_t)a1 << 40)) >> 8) & 0xFF00FF00FF00FFLL | 0x100010001000100)
     - (((v3 | (unint64_t)(v3 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  return (((v4 & 0x100010001000100) - ((v4 & 0x100010001000100) >> 8)) & v4 | ((((v4 & 0x100010001000100)
                                                                                   - ((v4 & 0x100010001000100) >> 8)) & v4) << 40)) >> 32;
}

unsigned int *DMplusDM_21363(unsigned int *result, unsigned int a2, int a3, unsigned int a4, int a5)
{
  unsigned int v5 = (unsigned __int16)(BYTE1(a4) * (_WORD)a5) + (unsigned __int16)(BYTE1(a2) * (_WORD)a3);
  unsigned int v6 = ((((a4 >> 8) & 0xFF00FF) * a5) >> 16) + ((((a2 >> 8) & 0xFF00FF) * a3) >> 16);
  if (v5 >= 0xFE79) {
    unsigned int v5 = 65145;
  }
  if (v6 >= 0xFE79) {
    unsigned int v6 = 65145;
  }
  unsigned int v7 = (a2 & 0xFF00FF) * a3;
  unsigned int v8 = (unsigned __int16)(a4 * (_WORD)a5) + (unsigned __int16)v7;
  unsigned int v9 = (((a4 & 0xFF00FF) * a5) >> 16) + HIWORD(v7);
  if (v8 >= 0xFE79) {
    int v10 = 65145;
  }
  else {
    int v10 = v8;
  }
  if (v9 >= 0xFE79) {
    int v11 = 65145;
  }
  else {
    int v11 = v9;
  }
  int *result = ((((((v10 | (v11 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v10 | (v11 << 16)) + 8388736) >> 8) & 0xFF00FF | (((((v5 | (v6 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v5 | (v6 << 16)) + 8388736) & 0xFF00FF00;
  return result;
}

_DWORD *DplusDM_21364(_DWORD *result, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v4 = ((((((a3 & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF) + (a3 & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF | ((((((a3 >> 8) & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF) + ((a3 >> 8) & 0xFF00FF) * a4 + 8388736) & 0xFF00FF00;
  unint64_t v5 = (((v4 | (unint64_t)(v4 << 40)) >> 8) & 0xFF00FF00FF00FFLL)
     + (((a2 | ((unint64_t)a2 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  int *result = ((((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) | v5) & 0xFF00FF00FF00FFLL | (((((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) | v5) & 0xFF00FF00FF00FFLL) << 40)) >> 32;
  return result;
}

int32x2_t DAplusdDA_21365(_DWORD *a1, int a2, int a3, int a4, int a5, uint64x2_t a6)
{
  a6.i32[0] = a4 & 0xFFFFFF00;
  a6.i16[3] = (a4 & 0xFFFFFF00) >> 8;
  a6.i32[2] = a2 & 0xFFFFFF00;
  a6.i16[7] = (a2 & 0xFFFFFF00) >> 8;
  v6.i64[0] = ((16843008 * a5) | ((unint64_t)(unsigned __int16)(257 * a5) << 48)) >> 8;
  v6.i64[1] = ((16843008 * a3) | ((unint64_t)(unsigned __int16)(257 * a3) << 48)) >> 8;
  v7.i64[0] = 0xFF00FF00FF00FFLL;
  v7.i64[1] = 0xFF00FF00FF00FFLL;
  int8x16_t v8 = (int8x16_t)vsubq_s64((int64x2_t)(*(_OWORD *)&vandq_s8(v6, v7) | __PAIR128__(0x100010001000100, 0x100010001000100)), (int64x2_t)vandq_s8((int8x16_t)vshrq_n_u64(a6, 8uLL), v7));
  int64x2_t v9 = (int64x2_t)vandq_s8((int8x16_t)vsubq_s64((int64x2_t)(*(_OWORD *)&v8 & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00)), (int64x2_t)vshrq_n_u64((uint64x2_t)(*(_OWORD *)&v8 & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00)), 8uLL)), v8);
  int64x2_t v10 = (int64x2_t)vorrq_s8((int8x16_t)vshlq_n_s64(v9, 0x28uLL), (int8x16_t)v9);
  *(int32x2_t *)v6.i8 = vshrn_n_s64(v10, 0x20uLL);
  v10.i64[0] = *(void *)&vmovn_s64((int64x2_t)vshrq_n_u64((uint64x2_t)v10, 0x28uLL)) & 0xFFFF00FFFFFF00FFLL;
  int32x2_t result = vadd_s32(*(int32x2_t *)v10.i8, vdup_lane_s32(*(int32x2_t *)v10.i8, 1));
  unsigned __int32 v12 = (v6.i32[0] & 0xFF00FF | a5) + (v6.i32[1] & 0xFF00FF | a3);
  unsigned __int32 v13 = (result.i32[0] << 8) & 0xFF00FF00 | v12 & 0xFF00FF | (15 * ((v12 >> 8) & 0x10001 | result.i32[0] & 0x1000100)) | (240 * ((v12 >> 8) & 0x10001 | result.i32[0] & 0x1000100));
  uint64_t v14 = (unsigned __int16)(v13 << 8) | (v13 << 16) & 0xFFFFFF | (v13 << 24);
  unint64_t v15 = (((v14 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)(v14 >> 8) << 48)) >> 8) & 0xFF00FF00FF00FFLL | 0x100010001000100)
      - (((v13 & 0xFFFFFF00 | ((unint64_t)(unsigned __int16)((v13 & 0xFFFFFF00) >> 8) << 48)) >> 8) & 0xFFFF00FFFFFF00FFLL);
  *a1 = (v12 | (15 * (BYTE1(v12) & 1)) | (-16 * (BYTE1(v12) & 1))) | ((((v15 & 0x100010001000100)
                                                                                       - ((v15 & 0x100010001000100) >> 8)) & v15 | ((((v15 & 0x100010001000100) - ((v15 & 0x100010001000100) >> 8)) & v15) << 40)) >> 32);
  return result;
}

uint64_t PDAmultiplyPDA_21366(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int32x2_t v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  double v5 = COERCE_DOUBLE(vmul_s32(vadd_s32(vdup_n_s32(a4 ^ 0xFFu), v4), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)));
  unsigned int v6 = ((a4 ^ 0xFF) + HIBYTE(a3)) * HIBYTE(a1);
  double v7 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v5, v4, vdup_n_s32(a2 ^ 0xFFu)));
  if (a2 != 255)
  {
    v6 += HIBYTE(a3) * (a2 ^ 0xFF);
    double v5 = v7;
  }
  int v8 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v9 = v6 + 128;
  if (v6 >> 7 >= 0x1FD) {
    unsigned int v9 = 65152;
  }
  unsigned int v10 = (v9 + (v9 >> 8)) >> 8;
  if (HIDWORD(v5) >> 7 >= 0x1FD) {
    unsigned int v11 = 65152;
  }
  else {
    unsigned int v11 = HIDWORD(v5) + 128;
  }
  unsigned int v12 = v11 + (v11 >> 8);
  if (v8 >= 65152) {
    unsigned int v13 = 65152;
  }
  else {
    unsigned int v13 = v8 + 128;
  }
  unsigned int v14 = v13 + (v13 >> 8);
  int v15 = (257 * LODWORD(v5) + 32896) & 0xFF0000;
  if (LODWORD(v5) >> 7 >= 0x1FD) {
    int v15 = 16711680;
  }
  return v15 & 0xFFFF00 | BYTE1(v14) | (v10 << 24) | v12 & 0xFF00;
}

uint64_t PDAscreenPDA_21367(unsigned int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4 = HIBYTE(a3) * (HIBYTE(a1) ^ 0xFF) - HIBYTE(a1) + (HIBYTE(a1) << 8);
  unsigned int v5 = BYTE2(a3) * (BYTE2(a1) ^ 0xFF) - BYTE2(a1) + (BYTE2(a1) << 8);
  unsigned int v6 = BYTE1(a3) * (BYTE1(a1) ^ 0xFF) - BYTE1(a1) + (BYTE1(a1) << 8);
  int v7 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v8 = v4 + 128;
  if (v4 >> 7 >= 0x1FD) {
    unsigned int v8 = 65152;
  }
  unsigned int v9 = (v8 + (v8 >> 8)) >> 8;
  if (v6 >> 7 >= 0x1FD) {
    unsigned int v10 = 65152;
  }
  else {
    unsigned int v10 = v6 + 128;
  }
  unsigned int v11 = v10 + (v10 >> 8);
  if (v7 >= 65152) {
    unsigned int v12 = 65152;
  }
  else {
    unsigned int v12 = v7 + 128;
  }
  unsigned int v13 = v12 + (v12 >> 8);
  if (v5 >> 7 >= 0x1FD) {
    int v14 = 16711680;
  }
  else {
    int v14 = (257 * v5 + 32896) & 0xFF0000;
  }
  return v14 & 0xFF0000 | (v9 << 24) | v11 & 0xFF00 | BYTE1(v13);
}

uint64_t PDAoverlayPDA_21368(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = HIBYTE(a1);
  unsigned int v5 = BYTE2(a1);
  unsigned int v6 = BYTE1(a1);
  unsigned int v7 = HIBYTE(a3);
  unsigned int v8 = BYTE2(a3);
  unsigned int v9 = BYTE1(a3);
  if (HIBYTE(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  int v10 = 2 * v4 * v7;
  if (BYTE2(a3) >= a4) {
    unsigned int v8 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v5 = a2;
  }
  int v11 = 2 * v5 * v8;
  if (BYTE1(a3) >= a4) {
    unsigned int v9 = a4;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v6 = a2;
  }
  int v12 = 2 * v6 * v9;
  int v13 = a4 * a2;
  unsigned int v14 = (a2 + 1) >> 1;
  unsigned int v15 = a4 + 255;
  unsigned int v16 = a2 + 255;
  int v17 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  int v18 = a4 ^ 0xFF;
  int v19 = a2 ^ 0xFF;
  int v20 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  if (v4 < v14) {
    int v21 = v20;
  }
  else {
    int v21 = v17;
  }
  int v22 = v15 * v5 + v8 * v16 - (v13 + v11);
  int v23 = v8 * v19 + v18 * v5 + v11;
  if (v5 < v14) {
    int v24 = v23;
  }
  else {
    int v24 = v22;
  }
  if (v6 < v14) {
    int v25 = v9 * v19 + v18 * v6 + v12;
  }
  else {
    int v25 = v15 * v6 + v9 * v16 - (v13 + v12);
  }
  int v26 = 255 * (a4 + a2) - v13;
  if (v21 >= 65152) {
    unsigned int v27 = 65152;
  }
  else {
    unsigned int v27 = v21 + 128;
  }
  unsigned int v28 = v27 + (v27 >> 8);
  if (v25 >= 65152) {
    unsigned int v29 = 65152;
  }
  else {
    unsigned int v29 = v25 + 128;
  }
  unsigned int v30 = v29 + (v29 >> 8);
  if (v26 >= 65152) {
    unsigned int v31 = 65152;
  }
  else {
    unsigned int v31 = v26 + 128;
  }
  unsigned int v32 = (v28 << 16) | ((v31 + (v31 >> 8)) >> 8);
  if (v24 >= 65152) {
    int v33 = 16711680;
  }
  else {
    int v33 = (257 * v24 + 32896) & 0xFF0000;
  }
  return v32 & 0xFF0000FF | v33 | v30 & 0xFF00;
}

uint64_t PDAlightenPDA_21369(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  v4.i32[0] = HIBYTE(a3);
  v4.i32[1] = BYTE2(a3);
  int32x2_t v5 = vdup_n_s32(a4);
  int32x2_t v6 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v5);
  v7.i32[0] = HIBYTE(a1);
  v7.i32[1] = BYTE2(a1);
  int32x2_t v8 = vdup_n_s32(a2);
  int32x2_t v9 = (int32x2_t)vmin_u32(v7, (uint32x2_t)v8);
  double v10 = COERCE_DOUBLE(vmax_u32((uint32x2_t)vmul_s32(v6, v8), (uint32x2_t)vmul_s32(v9, v5)));
  if (BYTE1(a3) >= a4) {
    unsigned int v11 = a4;
  }
  else {
    unsigned int v11 = BYTE1(a3);
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v12 = a2;
  }
  else {
    unsigned int v12 = BYTE1(a1);
  }
  int v13 = v12 * a4;
  if (v11 * a2 > v12 * a4) {
    int v13 = v11 * a2;
  }
  double v14 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, vdup_n_s32(a4 ^ 0xFF), v9));
  int v15 = v13 + (a4 ^ 0xFF) * v12;
  if (a4 == 255) {
    int v15 = v13;
  }
  else {
    double v10 = v14;
  }
  double v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, v6, vdup_n_s32(a2 ^ 0xFF)));
  unsigned int v17 = v15 + v11 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    unsigned int v17 = v15;
    double v18 = v10;
  }
  else
  {
    double v18 = v16;
  }
  int v19 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v20 = LODWORD(v18) + 128;
  if (LODWORD(v18) >> 7 >= 0x1FD) {
    unsigned int v20 = 65152;
  }
  unsigned int v21 = (v20 + (v20 >> 8)) >> 8;
  if (v17 >> 7 >= 0x1FD) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v17 + 128;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v19 >= 65152) {
    unsigned int v24 = 65152;
  }
  else {
    unsigned int v24 = v19 + 128;
  }
  unsigned int v25 = v24 + (v24 >> 8);
  if (HIDWORD(v18) >> 7 >= 0x1FD) {
    int v26 = 16711680;
  }
  else {
    int v26 = (257 * HIDWORD(v18) + 32896) & 0xFF0000;
  }
  return v26 & 0xFFFF00 | BYTE1(v25) | (v21 << 24) | v23 & 0xFF00;
}

uint64_t PDAdarkenPDA_21370(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  v4.i32[0] = HIBYTE(a3);
  v4.i32[1] = BYTE2(a3);
  int32x2_t v5 = vdup_n_s32(a4);
  int32x2_t v6 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v5);
  v7.i32[0] = HIBYTE(a1);
  v7.i32[1] = BYTE2(a1);
  int32x2_t v8 = vdup_n_s32(a2);
  int32x2_t v9 = (int32x2_t)vmin_u32(v7, (uint32x2_t)v8);
  double v10 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vmul_s32(v6, v8), (uint32x2_t)vmul_s32(v9, v5)));
  if (BYTE1(a3) >= a4) {
    unsigned int v11 = a4;
  }
  else {
    unsigned int v11 = BYTE1(a3);
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v12 = a2;
  }
  else {
    unsigned int v12 = BYTE1(a1);
  }
  int v13 = v12 * a4;
  if (v11 * a2 < v12 * a4) {
    int v13 = v11 * a2;
  }
  double v14 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, vdup_n_s32(a4 ^ 0xFF), v9));
  int v15 = v13 + (a4 ^ 0xFF) * v12;
  if (a4 == 255) {
    int v15 = v13;
  }
  else {
    double v10 = v14;
  }
  double v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, v6, vdup_n_s32(a2 ^ 0xFF)));
  unsigned int v17 = v15 + v11 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    unsigned int v17 = v15;
    double v18 = v10;
  }
  else
  {
    double v18 = v16;
  }
  int v19 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v20 = LODWORD(v18) + 128;
  if (LODWORD(v18) >> 7 >= 0x1FD) {
    unsigned int v20 = 65152;
  }
  unsigned int v21 = (v20 + (v20 >> 8)) >> 8;
  if (v17 >> 7 >= 0x1FD) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v17 + 128;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v19 >= 65152) {
    unsigned int v24 = 65152;
  }
  else {
    unsigned int v24 = v19 + 128;
  }
  unsigned int v25 = v24 + (v24 >> 8);
  if (HIDWORD(v18) >> 7 >= 0x1FD) {
    int v26 = 16711680;
  }
  else {
    int v26 = (257 * HIDWORD(v18) + 32896) & 0xFF0000;
  }
  return v26 & 0xFFFF00 | BYTE1(v25) | (v21 << 24) | v23 & 0xFF00;
}

uint64_t PDAcolordodgePDA_21371(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = HIBYTE(a3);
  int v5 = a4 * a4;
  if (HIBYTE(a1) >= a2) {
    unsigned int v6 = a2;
  }
  else {
    unsigned int v6 = HIBYTE(a1);
  }
  if (v4 >= a4) {
    unsigned int v7 = a4;
  }
  else {
    unsigned int v7 = HIBYTE(a3);
  }
  if (v6)
  {
    if (v4 >= a4) {
      int v8 = 65025;
    }
    else {
      int v8 = (int)(v5 * v6) / (int)(a4 - v7);
    }
  }
  else
  {
    int v8 = 0;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v9 = a2;
  }
  else {
    unsigned int v9 = BYTE2(a1);
  }
  if (BYTE2(a3) >= a4) {
    unsigned int v10 = a4;
  }
  else {
    unsigned int v10 = BYTE2(a3);
  }
  if (v9)
  {
    if (BYTE2(a3) >= a4) {
      int v11 = 65025;
    }
    else {
      int v11 = (int)(v5 * v9) / (int)(a4 - v10);
    }
  }
  else
  {
    int v11 = 0;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v12 = a2;
  }
  else {
    unsigned int v12 = BYTE1(a1);
  }
  if (BYTE1(a3) >= a4) {
    unsigned int v13 = a4;
  }
  else {
    unsigned int v13 = BYTE1(a3);
  }
  if (v12)
  {
    if (BYTE1(a3) >= a4) {
      int v14 = 65025;
    }
    else {
      int v14 = (int)(v5 * v12) / (int)(a4 - v13);
    }
  }
  else
  {
    int v14 = 0;
  }
  unsigned int v15 = v8 + (a4 ^ 0xFF) * v6;
  unsigned int v16 = v11 + (a4 ^ 0xFF) * v9;
  if (a4 == 255)
  {
    unsigned int v15 = v8;
    int v17 = v11;
  }
  else
  {
    int v17 = v16;
  }
  if (a4 != 255) {
    v14 += (a4 ^ 0xFF) * v12;
  }
  int v18 = v15 + v7 * (a2 ^ 0xFF);
  int v19 = v17 + v10 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    int v18 = v15;
    int v20 = v17;
  }
  else
  {
    int v20 = v19;
  }
  if (a2 == 255) {
    int v21 = v14;
  }
  else {
    int v21 = v14 + v13 * (a2 ^ 0xFF);
  }
  int v22 = 255 * (a4 + a2) - a4 * a2;
  if (v18 >= v22) {
    int v18 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v20 >= v22) {
    int v20 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v21 >= v22) {
    int v21 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v18 >= 65152) {
    unsigned int v23 = 65152;
  }
  else {
    unsigned int v23 = v18 + 128;
  }
  unsigned int v24 = (v23 + (v23 >> 8)) >> 8;
  if (v21 >= 65152) {
    unsigned int v25 = 65152;
  }
  else {
    unsigned int v25 = v21 + 128;
  }
  unsigned int v26 = v25 + (v25 >> 8);
  if (v22 >= 65152) {
    unsigned int v27 = 65152;
  }
  else {
    unsigned int v27 = v22 + 128;
  }
  unsigned int v28 = v27 + (v27 >> 8);
  if (v20 >= 65152) {
    int v29 = 16711680;
  }
  else {
    int v29 = (257 * v20 + 32896) & 0xFF0000;
  }
  return v29 & 0xFFFF00 | BYTE1(v28) | (v24 << 24) | v26 & 0xFF00;
}

uint64_t PDAcolorburnPDA_21372(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = HIBYTE(a1);
  unsigned int v5 = BYTE2(a1);
  unsigned int v6 = BYTE1(a1);
  unsigned int v7 = BYTE2(a3);
  signed int v8 = BYTE1(a3);
  int v9 = a4 * a2;
  if (HIBYTE(a3) >= a4) {
    signed int v10 = a4;
  }
  else {
    signed int v10 = HIBYTE(a3);
  }
  if (v4 >= a2) {
    unsigned int v11 = a2;
  }
  else {
    unsigned int v11 = v4;
  }
  if (v7 >= a4) {
    int v12 = a4;
  }
  else {
    int v12 = v7;
  }
  if (v5 >= a2) {
    unsigned int v13 = a2;
  }
  else {
    unsigned int v13 = v5;
  }
  if (v8 >= a4) {
    signed int v8 = a4;
  }
  if (v6 >= a2) {
    unsigned int v14 = a2;
  }
  else {
    unsigned int v14 = v6;
  }
  int v15 = v9 + (a4 ^ 0xFF) * v11;
  if (a4 == 255)
  {
    int v15 = a4 * a2;
    int v16 = 255 * a2;
  }
  else
  {
    int v16 = v9 + (a4 ^ 0xFF) * v13;
  }
  if (a4 == 255) {
    int v17 = 255 * a2;
  }
  else {
    int v17 = v9 + (a4 ^ 0xFF) * v14;
  }
  unsigned int v18 = v15 + v10 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    unsigned int v18 = v15;
    unsigned int v19 = v16;
  }
  else
  {
    unsigned int v19 = v16 + v12 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    unsigned int v20 = v17;
  }
  else {
    unsigned int v20 = v17 + v8 * (a2 ^ 0xFF);
  }
  if (v4 < a2)
  {
    if (v10) {
      unsigned int v18 = (v18 - (int)(a4 * a4 * (a2 - v11)) / v10) & ~((int)(v18 - (int)(a4 * a4 * (a2 - v11)) / v10) >> 31);
    }
    else {
      unsigned int v18 = 0;
    }
  }
  if (v5 < a2)
  {
    if (v12) {
      unsigned int v19 = (v19 - (int)(a4 * a4 * (a2 - v13)) / v12) & ~((int)(v19 - (int)(a4 * a4 * (a2 - v13)) / v12) >> 31);
    }
    else {
      unsigned int v19 = 0;
    }
  }
  if (v6 < a2)
  {
    if (v8) {
      unsigned int v20 = (v20 - (int)(a4 * a4 * (a2 - v14)) / v8) & ~((int)(v20 - (int)(a4 * a4 * (a2 - v14)) / v8) >> 31);
    }
    else {
      unsigned int v20 = 0;
    }
  }
  int v21 = 255 * (a4 + a2) - v9;
  unsigned int v22 = v18 + 128;
  if (v18 >> 7 >= 0x1FD) {
    unsigned int v22 = 65152;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v20 >> 7 >= 0x1FD) {
    unsigned int v24 = 65152;
  }
  else {
    unsigned int v24 = v20 + 128;
  }
  unsigned int v25 = v24 + (v24 >> 8);
  if (v21 >= 65152) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v21 + 128;
  }
  unsigned int v27 = (v23 << 16) | ((v26 + (v26 >> 8)) >> 8);
  if (v19 >> 7 >= 0x1FD) {
    int v28 = 16711680;
  }
  else {
    int v28 = (257 * v19 + 32896) & 0xFF0000;
  }
  return v27 & 0xFF0000FF | v28 | v25 & 0xFF00;
}

uint64_t PDAhardlightPDA_21373(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = HIBYTE(a1);
  unsigned int v5 = BYTE2(a1);
  unsigned int v6 = BYTE1(a1);
  unsigned int v7 = HIBYTE(a3);
  unsigned int v8 = BYTE2(a3);
  unsigned int v9 = BYTE1(a3);
  if (HIBYTE(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  int v10 = 2 * v4 * v7;
  if (BYTE2(a3) >= a4) {
    unsigned int v8 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v5 = a2;
  }
  int v11 = 2 * v5 * v8;
  if (BYTE1(a3) >= a4) {
    unsigned int v9 = a4;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v6 = a2;
  }
  int v12 = 2 * v6 * v9;
  int v13 = a4 * a2;
  unsigned int v14 = (a4 + 1) >> 1;
  int v15 = a4 ^ 0xFF;
  int v16 = a2 ^ 0xFF;
  int v17 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  unsigned int v18 = a4 + 255;
  unsigned int v19 = a2 + 255;
  int v20 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  if (v7 <= v14) {
    int v20 = v17;
  }
  int v21 = v8 * v16 + v15 * v5 + v11;
  int v22 = v18 * v5 + v8 * v19 - (v13 + v11);
  if (v8 <= v14) {
    int v22 = v21;
  }
  int v23 = v9 * v16 + v15 * v6 + v12;
  int v24 = v18 * v6 + v9 * v19 - (v13 + v12);
  if (v9 <= v14) {
    int v24 = v23;
  }
  int v25 = 255 * (a4 + a2) - v13;
  if (v20 >= 65152) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v20 + 128;
  }
  unsigned int v27 = v26 + (v26 >> 8);
  if (v24 >= 65152) {
    unsigned int v28 = 65152;
  }
  else {
    unsigned int v28 = v24 + 128;
  }
  unsigned int v29 = v28 + (v28 >> 8);
  if (v25 >= 65152) {
    unsigned int v30 = 65152;
  }
  else {
    unsigned int v30 = v25 + 128;
  }
  unsigned int v31 = (v27 << 16) | ((v30 + (v30 >> 8)) >> 8);
  if (v22 >= 65152) {
    int v32 = 16711680;
  }
  else {
    int v32 = (257 * v22 + 32896) & 0xFF0000;
  }
  return v31 & 0xFF0000FF | v32 | v29 & 0xFF00;
}

uint64_t PDAsoftlightPDA_21374(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = HIBYTE(a1);
  unsigned int v5 = HIBYTE(a3);
  if (HIBYTE(a3) >= a4) {
    unsigned int v5 = a4;
  }
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  unsigned int v6 = BYTE1(a3);
  unsigned int v7 = BYTE2(a3);
  unsigned int v8 = BYTE1(a1);
  unsigned int v9 = BYTE2(a1);
  int v10 = (int)(v4 * v4 * (2 * v5 - a4)) / (int)a2;
  int v11 = (2 * v4 * v5 - v10) & ~((int)(2 * v4 * v5 - v10) >> 31);
  if (BYTE2(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v9 = a2;
  }
  int v12 = (int)(v9 * v9 * (2 * v7 - a4)) / (int)a2;
  int v13 = (2 * v9 * v7 - v12) & ~((int)(2 * v9 * v7 - v12) >> 31);
  if (BYTE1(a3) >= a4) {
    unsigned int v6 = a4;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v8 = a2;
  }
  int v14 = 2 * v8 * v6 - (int)(v8 * v8 * (2 * v6 - a4)) / (int)a2;
  int v15 = v14 & ~(v14 >> 31);
  unsigned int v16 = v11 + (a4 ^ 0xFF) * v4;
  int v17 = v13 + v9 * (a4 ^ 0xFF);
  int v18 = v15 + v8 * (a4 ^ 0xFF);
  if (a4 == 255)
  {
    unsigned int v16 = v11;
    int v17 = v13;
    int v18 = v15;
  }
  unsigned int v19 = v16 + v5 * (a2 ^ 0xFF);
  unsigned int v20 = v17 + v7 * (a2 ^ 0xFF);
  unsigned int v21 = v18 + v6 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    unsigned int v22 = v17;
  }
  else
  {
    unsigned int v16 = v19;
    unsigned int v22 = v20;
  }
  if (a2 == 255) {
    unsigned int v21 = v18;
  }
  int v23 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v24 = v16 + 128;
  if (v16 >> 7 >= 0x1FD) {
    unsigned int v24 = 65152;
  }
  unsigned int v25 = (v24 + (v24 >> 8)) >> 8;
  if (v21 >> 7 >= 0x1FD) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v21 + 128;
  }
  unsigned int v27 = v26 + (v26 >> 8);
  if (v23 >= 65152) {
    unsigned int v28 = 65152;
  }
  else {
    unsigned int v28 = v23 + 128;
  }
  unsigned int v29 = v28 + (v28 >> 8);
  if (v22 >> 7 >= 0x1FD) {
    int v30 = 16711680;
  }
  else {
    int v30 = (257 * v22 + 32896) & 0xFF0000;
  }
  return v30 & 0xFFFF00 | BYTE1(v29) | (v25 << 24) | v27 & 0xFF00;
}

uint64_t PDAdifferencePDA_21375(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = HIBYTE(a1);
  unsigned int v5 = HIBYTE(a3);
  int32x2_t v6 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)vdup_n_s32(a4));
  int32x2_t v7 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)vdup_n_s32(a2));
  int32x2_t v8 = vmul_s32((int32x2_t)__PAIR64__(v6.u32[1], v7.u32[0]), (int32x2_t)__PAIR64__(a2, a4));
  int32x2_t v9 = vrev64_s32((int32x2_t)__PAIR64__(a2, a4));
  if (HIBYTE(a3) >= a4) {
    unsigned int v5 = a4;
  }
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  unsigned int v10 = v5 + v4;
  int v11 = v4 * a4;
  int v12 = v5 * a2;
  int v14 = v11 - v12;
  BOOL v13 = v11 - v12 < 0;
  int v15 = 255 * v10 - v12 - v11;
  if (v13) {
    int v16 = -v14;
  }
  else {
    int v16 = v14;
  }
  int v17 = v15 + v16;
  int v18 = 255 * (a4 + a2) - a4 * a2;
  if (v17 >= 65152) {
    unsigned int v19 = 65152;
  }
  else {
    unsigned int v19 = v17 + 128;
  }
  unsigned int v20 = (v19 + (v19 >> 8)) >> 8;
  int32x2_t v21 = vadd_s32(v6, v7);
  v6.i32[1] = v7.i32[1];
  int32x2_t v22 = vmul_s32(v6, v9);
  uint32x2_t v23 = (uint32x2_t)__PAIR64__(v8.u32[1], v22.u32[0]);
  int32x2_t v24 = vneg_s32(v8);
  v8.i32[1] = v22.i32[1];
  int32x2_t v25 = (int32x2_t)vaba_u32((uint32x2_t)vsub_s32(vmla_s32(v24, v21, (int32x2_t)0xFF000000FFLL), v22), v23, (uint32x2_t)v8);
  int32x2_t v26 = vcgt_s32(vdup_n_s32(0xFE80u), v25);
  unsigned int v27 = v25.i32[0] + 128;
  if ((v26.i8[0] & 1) == 0) {
    unsigned int v27 = 65152;
  }
  unsigned int v28 = v27 + (v27 >> 8);
  if (v18 >= 65152) {
    unsigned int v29 = 65152;
  }
  else {
    unsigned int v29 = v18 + 128;
  }
  unsigned int v30 = v29 + (v29 >> 8);
  int v31 = (257 * v25.i32[1] + 32896) & 0xFF0000;
  if ((v26.i8[4] & 1) == 0) {
    int v31 = 16711680;
  }
  return v31 & 0xFFFF00 | BYTE1(v30) | v28 & 0xFF00 | (v20 << 24);
}

uint64_t PDAexclusionPDA_21376(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = HIBYTE(a1);
  unsigned int v5 = BYTE2(a1);
  unsigned int v6 = BYTE1(a1);
  unsigned int v7 = HIBYTE(a3);
  if (HIBYTE(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  int v8 = 255 * (v7 + v4) - 2 * v4 * v7;
  if (BYTE2(a3) >= a4) {
    unsigned int v9 = a4;
  }
  else {
    unsigned int v9 = BYTE2(a3);
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v5 = a2;
  }
  int v10 = 255 * (v9 + v5) - 2 * v5 * v9;
  if (BYTE1(a3) >= a4) {
    unsigned int v11 = a4;
  }
  else {
    unsigned int v11 = BYTE1(a3);
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v6 = a2;
  }
  int v12 = 255 * (v11 + v6) - 2 * v6 * v11;
  int v13 = 255 * (a4 + a2) - a4 * a2;
  if (v8 >= 65152) {
    unsigned int v14 = 65152;
  }
  else {
    unsigned int v14 = v8 + 128;
  }
  unsigned int v15 = (v14 + (v14 >> 8)) >> 8;
  if (v12 >= 65152) {
    unsigned int v16 = 65152;
  }
  else {
    unsigned int v16 = v12 + 128;
  }
  unsigned int v17 = v16 + (v16 >> 8);
  if (v13 >= 65152) {
    unsigned int v18 = 65152;
  }
  else {
    unsigned int v18 = v13 + 128;
  }
  unsigned int v19 = v18 + (v18 >> 8);
  if (v10 >= 65152) {
    int v20 = 16711680;
  }
  else {
    int v20 = (257 * v10 + 32896) & 0xFF0000;
  }
  return v20 & 0xFF0000 | v17 & 0xFF00 | BYTE1(v19) | (v15 << 24);
}

uint64_t PDAhuePDA_21377(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = HIBYTE(a1);
  uint32x2_t v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  unsigned int v6 = HIBYTE(a3);
  uint32x2_t v7 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  if (HIBYTE(a3) >= a4) {
    unsigned int v6 = a4;
  }
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  int32x2_t v8 = vdup_n_s32(a4);
  double v9 = COERCE_DOUBLE(vmin_u32(v7, (uint32x2_t)v8));
  int32x2_t v10 = vdup_n_s32(a2);
  double v11 = COERCE_DOUBLE(vmin_u32(v5, (uint32x2_t)v10));
  int v12 = (a4 ^ 0xFF) * v4;
  double v13 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFF), *(int32x2_t *)&v11));
  uint32x2_t v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v11, v8);
  double v15 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL));
  if (a4 == 255)
  {
    int v12 = 0;
    unsigned int v16 = v4;
  }
  else
  {
    unsigned int v16 = (v4 * a4 + 128 + ((v4 * a4 + 128) >> 8)) >> 8;
  }
  if (a4 == 255)
  {
    double v13 = 0.0;
    *(double *)&int32x2_t v17 = v11;
  }
  else
  {
    *(double *)&int32x2_t v17 = v15;
  }
  double v18 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v13, *(int32x2_t *)&v9, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v19 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v9, v10);
  double v20 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v19, v19, 8uLL), 8uLL));
  if (a2 == 255) {
    int v21 = v12;
  }
  else {
    int v21 = v12 + v6 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    *(double *)&int32x2_t v22 = v13;
  }
  else
  {
    unsigned int v6 = (v6 * a2 + 128 + ((v6 * a2 + 128) >> 8)) >> 8;
    double v9 = v20;
    *(double *)&int32x2_t v22 = v18;
  }
  *(_DWORD *)unsigned int v55 = v6;
  *(double *)&v55[4] = v9;
  uint64_t v23 = v6 < LODWORD(v9);
  uint64_t v24 = v6 >= LODWORD(v9);
  if (SHIDWORD(v9) >= *(_DWORD *)((unint64_t)v55 | (4 * v24)))
  {
    int v26 = *(_DWORD *)((unint64_t)v55 | (4 * v23));
    uint64_t v25 = v24;
    if (SHIDWORD(v9) <= v26) {
      uint64_t v24 = 2;
    }
    else {
      uint64_t v24 = v23;
    }
    if (SHIDWORD(v9) > v26) {
      uint64_t v23 = 2;
    }
  }
  else
  {
    uint64_t v25 = 2;
  }
  int v27 = *(_DWORD *)&v55[4 * v23];
  int v28 = *(_DWORD *)&v55[4 * v25];
  BOOL v29 = __OFSUB__(v27, v28);
  int v30 = v27 - v28;
  if ((v30 < 0) ^ v29 | (v30 == 0))
  {
    *(_DWORD *)&v55[4 * v23] = 0;
    *(_DWORD *)&v55[4 * v24] = 0;
  }
  else
  {
    unsigned int v31 = v17.i32[0];
    if (v16 >= v17.i32[0]) {
      unsigned int v32 = v17.i32[0];
    }
    else {
      unsigned int v32 = v16;
    }
    if (v16 > v17.i32[0]) {
      unsigned int v31 = v16;
    }
    if (v17.i32[1] <= v31) {
      __int32 v33 = v31;
    }
    else {
      __int32 v33 = v17.i32[1];
    }
    if (v17.i32[1] >= v32) {
      unsigned int v31 = v33;
    }
    else {
      unsigned int v32 = v17.u32[1];
    }
    unsigned int v34 = v31 - v32;
    *(_DWORD *)&v55[4 * v23] = v34;
    *(_DWORD *)&v55[4 * v24] = ((*(_DWORD *)&v55[4 * v24] - *(_DWORD *)&v55[4 * v25]) * ((int)(v34 << 16) / v30) + 0x8000) >> 16;
  }
  signed int v35 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  *(_DWORD *)&v55[4 * v25] = 0;
  int32x2_t v36 = vmul_s32(vsub_s32(v17, *(int32x2_t *)&v55[4]), (int32x2_t)0x1C00000097);
  int v37 = v36.i32[0] + 77 * (v16 - *(_DWORD *)v55) + v36.i32[1];
  int32x2_t v38 = vadd_s32(vdup_n_s32((v37 + 128) >> 8), *(int32x2_t *)v55);
  int v39 = *(_DWORD *)&v55[8] + ((v37 + 128) >> 8);
  if (v37 != (char)v37)
  {
    if (*(int *)v55 >= *(int *)&v55[4]) {
      int v40 = v38.i32[1];
    }
    else {
      int v40 = v38.i32[0];
    }
    if (*(int *)v55 >= *(int *)&v55[4]) {
      signed int v41 = v38.i32[0];
    }
    else {
      signed int v41 = v38.i32[1];
    }
    if (v39 <= v41) {
      int v42 = v41;
    }
    else {
      int v42 = *(_DWORD *)&v55[8] + ((v37 + 128) >> 8);
    }
    if (v39 >= v40) {
      int v43 = v40;
    }
    else {
      int v43 = *(_DWORD *)&v55[8] + ((v37 + 128) >> 8);
    }
    if (v39 >= v40) {
      signed int v41 = v42;
    }
    if (v41 > v35 || v43 < 0)
    {
      unsigned int v44 = (77 * v38.i32[0] + 151 * v38.i32[1] + 28 * v39 + 128) >> 8;
      if (v37 > -129)
      {
        signed int v45 = v41 - v44;
        if (v41 == v44) {
          goto LABEL_61;
        }
        int v46 = v35 - v44;
      }
      else
      {
        signed int v45 = v44 - v43;
        if (v44 == v43) {
          goto LABEL_61;
        }
        int v46 = (77 * v38.i32[0] + 151 * v38.i32[1] + 28 * v39 + 128) >> 8;
      }
      int32x2_t v47 = vdup_n_s32(v44);
      unsigned int v48 = (v46 << 16) / v45;
      int v39 = v44 + ((int)(v48 * (v39 - v44) + 0x8000) >> 16);
      int32x2_t v38 = vsra_n_s32(v47, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v48), vsub_s32(v38, v47)), 0x10uLL);
    }
  }
LABEL_61:
  unsigned int v49 = v22.i32[1] + 128;
  if ((unsigned __int32)v22.i32[1] >> 7 >= 0x1FD) {
    unsigned int v49 = 65152;
  }
  int32x2_t v50 = vdup_lane_s32(v22, 0);
  v50.i32[0] = v21;
  int8x8_t v51 = (int8x8_t)vdup_n_s32(0xFE80u);
  uint32x2_t v52 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)v51, (uint32x2_t)v50), (int8x8_t)vadd_s32(v50, (int32x2_t)0x8000000080), v51);
  uint32x2_t v53 = vshl_u32(vsra_n_u32((uint32x2_t)v38, vsra_n_u32(v52, v52, 8uLL), 8uLL), (uint32x2_t)0x1000000018);
  return v53.i32[0] | ((_WORD)v49 + (unsigned __int16)(v49 >> 8) + ((_WORD)v39 << 8)) & 0xFF00 | (a4 + a2 - v35) | v53.i32[1] & 0xFF0000u;
}

uint64_t PDAsaturationPDA_21378(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint32x2_t v4 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  uint32x2_t v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  if (HIBYTE(a3) >= a4) {
    unsigned int v6 = a4;
  }
  else {
    unsigned int v6 = HIBYTE(a3);
  }
  if (HIBYTE(a1) >= a2) {
    unsigned int v7 = a2;
  }
  else {
    unsigned int v7 = HIBYTE(a1);
  }
  int32x2_t v8 = vdup_n_s32(a4);
  double v9 = COERCE_DOUBLE(vmin_u32(v5, (uint32x2_t)v8));
  int32x2_t v10 = vdup_n_s32(a2);
  int32x2_t v11 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v10);
  if (a4 == 255)
  {
    int v12 = 0;
    int32x2_t v13 = 0;
  }
  else
  {
    int v12 = (a4 ^ 0xFF) * v7;
    unsigned int v7 = (v7 * a4 + 128 + ((v7 * a4 + 128) >> 8)) >> 8;
    int32x2_t v13 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v11);
    uint32x2_t v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v11, v8);
    int32x2_t v11 = (int32x2_t)vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL);
  }
  double v15 = COERCE_DOUBLE(vrev64_s32(v13));
  double v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v15, *(int32x2_t *)&v9, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v17 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v9, v10);
  double v18 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v17, v17, 8uLL), 8uLL));
  if (a2 == 255)
  {
    unsigned int v19 = v6;
  }
  else
  {
    v12 += v6 * (a2 ^ 0xFF);
    unsigned int v19 = (v6 * a2 + 128 + ((v6 * a2 + 128) >> 8)) >> 8;
  }
  if (a2 == 255)
  {
    double v18 = v9;
    *(double *)&int32x2_t v20 = v15;
  }
  else
  {
    *(double *)&int32x2_t v20 = v16;
  }
  *(_DWORD *)unsigned int v49 = v7;
  *(int32x2_t *)&v49[4] = v11;
  uint64_t v21 = v7 < v11.i32[0];
  uint64_t v22 = v7 >= v11.i32[0];
  if (v11.i32[1] >= *(_DWORD *)((unint64_t)v49 | (4 * v22)))
  {
    uint64_t v23 = v7 >= v11.i32[0];
    if (v11.i32[1] <= *(_DWORD *)((unint64_t)v49 | (4 * v21))) {
      uint64_t v22 = 2;
    }
    else {
      uint64_t v22 = v7 < v11.i32[0];
    }
    if (v11.i32[1] > *(_DWORD *)((unint64_t)v49 | (4 * v21))) {
      uint64_t v21 = 2;
    }
  }
  else
  {
    uint64_t v23 = 2;
  }
  int v24 = *(_DWORD *)&v49[4 * v21];
  int v25 = *(_DWORD *)&v49[4 * v23];
  BOOL v26 = __OFSUB__(v24, v25);
  int v27 = v24 - v25;
  if ((v27 < 0) ^ v26 | (v27 == 0))
  {
    *(_DWORD *)&v49[4 * v21] = 0;
    *(_DWORD *)&v49[4 * v22] = 0;
  }
  else
  {
    if (v19 >= HIDWORD(v18)) {
      unsigned int v28 = HIDWORD(v18);
    }
    else {
      unsigned int v28 = v19;
    }
    if (v19 <= HIDWORD(v18)) {
      unsigned int v19 = HIDWORD(v18);
    }
    unsigned int v29 = LODWORD(v18);
    if (LODWORD(v18) <= v19) {
      unsigned int v30 = v19;
    }
    else {
      unsigned int v30 = LODWORD(v18);
    }
    if (LODWORD(v18) >= v28)
    {
      unsigned int v29 = v28;
      unsigned int v19 = v30;
    }
    unsigned int v31 = v19 - v29;
    *(_DWORD *)&v49[4 * v21] = v31;
    *(_DWORD *)&v49[4 * v22] = ((*(_DWORD *)&v49[4 * v22] - *(_DWORD *)&v49[4 * v23]) * ((int)(v31 << 16) / v27) + 0x8000) >> 16;
  }
  signed int v32 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  *(_DWORD *)&v49[4 * v23] = 0;
  int v33 = 77 * (v7 - *(_DWORD *)v49) + 151 * (v11.i32[0] - *(_DWORD *)&v49[4]) + 28 * (v11.i32[1] - *(_DWORD *)&v49[8]);
  int32x2_t v34 = vadd_s32(vdup_n_s32((v33 + 128) >> 8), *(int32x2_t *)v49);
  int v35 = *(_DWORD *)&v49[8] + ((v33 + 128) >> 8);
  if (v33 != (char)v33)
  {
    int v36 = *(int *)v49 >= *(int *)&v49[4] ? v34.i32[1] : v34.i32[0];
    int v37 = *(int *)v49 >= *(int *)&v49[4] ? v34.i32[0] : v34.i32[1];
    int v38 = v35 <= v37 ? v37 : *(_DWORD *)&v49[8] + ((v33 + 128) >> 8);
    if (v35 >= v36) {
      int v37 = v38;
    }
    else {
      int v36 = *(_DWORD *)&v49[8] + ((v33 + 128) >> 8);
    }
    if (v37 > v32 || v36 < 0)
    {
      unsigned int v39 = (77 * v34.i32[0] + 151 * v34.i32[1] + 28 * v35 + 128) >> 8;
      if (v33 > -129)
      {
        signed int v40 = v37 - v39;
        if (v37 == v39) {
          goto LABEL_57;
        }
        int v41 = v32 - v39;
      }
      else
      {
        signed int v40 = v39 - v36;
        if (v39 == v36) {
          goto LABEL_57;
        }
        int v41 = (77 * v34.i32[0] + 151 * v34.i32[1] + 28 * v35 + 128) >> 8;
      }
      int32x2_t v42 = vdup_n_s32(v39);
      unsigned int v43 = (v41 << 16) / v40;
      int v35 = v39 + ((int)(v43 * (v35 - v39) + 0x8000) >> 16);
      int32x2_t v34 = vsra_n_s32(v42, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v43), vsub_s32(v34, v42)), 0x10uLL);
    }
  }
LABEL_57:
  unsigned int v44 = v20.i32[0] + 128;
  if ((unsigned __int32)v20.i32[0] >> 7 >= 0x1FD) {
    unsigned int v44 = 65152;
  }
  v20.i32[0] = v12;
  int8x8_t v45 = (int8x8_t)vdup_n_s32(0xFE80u);
  uint32x2_t v46 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)v45, (uint32x2_t)v20), (int8x8_t)vadd_s32(v20, (int32x2_t)0x8000000080), v45);
  uint32x2_t v47 = vshl_u32(vsra_n_u32((uint32x2_t)v34, vsra_n_u32(v46, v46, 8uLL), 8uLL), (uint32x2_t)0x1000000018);
  return v47.i32[0] | ((_WORD)v44 + (unsigned __int16)(v44 >> 8) + ((_WORD)v35 << 8)) & 0xFF00 | (a4 + a2 - v32) | v47.i32[1] & 0xFF0000u;
}

uint64_t PDAluminosityPDA_21379(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint32x2_t v4 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  uint32x2_t v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  if (HIBYTE(a3) >= a4) {
    unsigned int v6 = a4;
  }
  else {
    unsigned int v6 = HIBYTE(a3);
  }
  int32x2_t v7 = vdup_n_s32(a4);
  if (HIBYTE(a1) >= a2) {
    unsigned int v8 = a2;
  }
  else {
    unsigned int v8 = HIBYTE(a1);
  }
  int32x2_t v9 = vdup_n_s32(a2);
  int32x2_t v10 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v9);
  if (a4 == 255)
  {
    unsigned int v13 = 0;
    int32x2_t v12 = 0;
  }
  else
  {
    int32x2_t v11 = vdup_lane_s32(v10, 0);
    v11.i32[0] = v8;
    unsigned int v8 = (v8 * a4 + 128 + ((v8 * a4 + 128) >> 8)) >> 8;
    int32x2_t v12 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v11);
    unsigned int v13 = (a4 ^ 0xFF) * v10.i32[1];
    uint32x2_t v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v10, v7);
    int32x2_t v10 = (int32x2_t)vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL);
  }
  int32x2_t v15 = (int32x2_t)vmin_u32(v5, (uint32x2_t)v7);
  if (a2 != 255)
  {
    int32x2_t v16 = vdup_lane_s32(v15, 0);
    v16.i32[0] = v6;
    unsigned int v6 = (v6 * a2 + 128 + ((v6 * a2 + 128) >> 8)) >> 8;
    int32x2_t v12 = vmla_s32(v12, v16, vdup_n_s32(a2 ^ 0xFF));
    v13 += v15.i32[1] * (a2 ^ 0xFF);
    uint32x2_t v17 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v15, v9);
    int32x2_t v15 = (int32x2_t)vshr_n_u32(vsra_n_u32(v17, v17, 8uLL), 8uLL);
  }
  int32x2_t v18 = vmul_s32(vsub_s32(v15, v10), (int32x2_t)0x1C00000097);
  signed __int32 v19 = vadd_s32(v18, vdup_lane_s32(v18, 1)).u32[0] + 77 * (v6 - v8);
  int32x2_t v20 = vdup_lane_s32(v10, 0);
  v20.i32[0] = v8;
  signed int v21 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int32x2_t v22 = vadd_s32(vdup_n_s32((v19 + 128) >> 8), v20);
  int v23 = v10.i32[1] + ((v19 + 128) >> 8);
  if (v19 != (char)v19)
  {
    BOOL v24 = v8 >= v10.i32[0];
    if (v8 >= v10.i32[0]) {
      int v25 = v22.i32[1];
    }
    else {
      int v25 = v22.i32[0];
    }
    if (v24) {
      signed int v26 = v22.i32[0];
    }
    else {
      signed int v26 = v22.i32[1];
    }
    if (v23 <= v26) {
      int v27 = v26;
    }
    else {
      int v27 = v10.i32[1] + ((v19 + 128) >> 8);
    }
    if (v23 >= v25) {
      int v28 = v25;
    }
    else {
      int v28 = v10.i32[1] + ((v19 + 128) >> 8);
    }
    if (v23 >= v25) {
      signed int v26 = v27;
    }
    if (v26 > v21 || v28 < 0)
    {
      unsigned int v29 = (77 * v22.i32[0] + 151 * v22.i32[1] + 28 * v23 + 128) >> 8;
      if (v19 > -129)
      {
        signed int v30 = v26 - v29;
        if (v26 == v29) {
          goto LABEL_35;
        }
        int v31 = v21 - v29;
      }
      else
      {
        signed int v30 = v29 - v28;
        if (v29 == v28) {
          goto LABEL_35;
        }
        int v31 = (77 * v22.i32[0] + 151 * v22.i32[1] + 28 * v23 + 128) >> 8;
      }
      int32x2_t v32 = vdup_n_s32(v29);
      unsigned int v33 = (v31 << 16) / v30;
      int v23 = v29 + ((int)(v33 * (v23 - v29) + 0x8000) >> 16);
      int32x2_t v22 = vsra_n_s32(v32, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v33), vsub_s32(v22, v32)), 0x10uLL);
    }
  }
LABEL_35:
  unsigned __int8 v34 = a4 + a2 - v21;
  unsigned int v35 = v13 + 128;
  if (v13 >> 7 >= 0x1FD) {
    unsigned int v35 = 65152;
  }
  int8x8_t v36 = (int8x8_t)vdup_n_s32(0xFE80u);
  uint32x2_t v37 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)v36, (uint32x2_t)v12), (int8x8_t)vadd_s32(v12, (int32x2_t)0x8000000080), v36);
  uint32x2_t v38 = vshl_u32(vsra_n_u32((uint32x2_t)v22, vsra_n_u32(v37, v37, 8uLL), 8uLL), (uint32x2_t)0x1000000018);
  return v38.i32[0] | ((_WORD)v35 + (unsigned __int16)(v35 >> 8) + ((_WORD)v23 << 8)) & 0xFF00 | v34 | v38.i32[1] & 0xFF0000u;
}

uint64_t PDAtranspose_huePDA_21380(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = HIBYTE(a1);
  int32x2_t v5 = vdup_n_s32(a4);
  int32x2_t v6 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v5);
  int32x2_t v7 = vdup_n_s32(a2);
  double v8 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7));
  if (HIBYTE(a3) >= a4) {
    unsigned int v9 = a4;
  }
  else {
    unsigned int v9 = HIBYTE(a3);
  }
  if (v4 >= a2) {
    unsigned int v4 = a2;
  }
  double v10 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFF), *(int32x2_t *)&v8));
  uint32x2_t v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v8, v5);
  double v12 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL));
  if (a4 == 255) {
    int v13 = 0;
  }
  else {
    int v13 = (a4 ^ 0xFF) * v4;
  }
  if (a4 == 255) {
    unsigned int v14 = v4;
  }
  else {
    unsigned int v14 = (v4 * a4 + 128 + ((v4 * a4 + 128) >> 8)) >> 8;
  }
  if (a4 == 255)
  {
    double v10 = 0.0;
    double v15 = v8;
  }
  else
  {
    double v15 = v12;
  }
  double v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, v6, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v17 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v6, v7);
  double v18 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v17, v17, 8uLL), 8uLL));
  unsigned int v19 = v13 + v9 * (a2 ^ 0xFF);
  signed int v20 = (v9 * a2 + 128 + ((v9 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255)
  {
    unsigned int v19 = v13;
    signed int v20 = v9;
    double v21 = v10;
  }
  else
  {
    *(double *)&int32x2_t v6 = v18;
    double v21 = v16;
  }
  int32x2_t v53 = v6;
  signed int v54 = v20;
  unsigned __int8 v22 = vcge_u32((uint32x2_t)v6, (uint32x2_t)vdup_lane_s32(v6, 1)).u8[0];
  uint64_t v23 = v22 & 1;
  uint64_t v24 = (v22 & 1) == 0;
  if (v20 >= *(_DWORD *)((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * v23)))
  {
    BOOL v26 = v20 <= *(_DWORD *)((unint64_t)&v53 | (4 * v24));
    uint64_t v25 = v22 & 1;
    if (v26) {
      uint64_t v23 = 2;
    }
    else {
      uint64_t v23 = (v22 & 1) == 0;
    }
    if (!v26) {
      uint64_t v24 = 2;
    }
  }
  else
  {
    uint64_t v25 = 2;
  }
  __int32 v27 = v53.i32[v24];
  __int32 v28 = v53.i32[v25];
  __int32 v29 = v27 - v28;
  if (v27 <= v28)
  {
    v53.i32[v24] = 0;
    v53.i32[v23] = 0;
    int v30 = LODWORD(v15);
    int v31 = HIDWORD(v15);
  }
  else
  {
    int v30 = LODWORD(v15);
    int v31 = HIDWORD(v15);
    if (LODWORD(v15) >= HIDWORD(v15)) {
      unsigned int v32 = HIDWORD(v15);
    }
    else {
      unsigned int v32 = LODWORD(v15);
    }
    if (LODWORD(v15) <= HIDWORD(v15)) {
      unsigned int v33 = HIDWORD(v15);
    }
    else {
      unsigned int v33 = LODWORD(v15);
    }
    if (v14 <= v33) {
      unsigned int v34 = v33;
    }
    else {
      unsigned int v34 = v14;
    }
    if (v14 >= v32) {
      unsigned int v33 = v34;
    }
    else {
      unsigned int v32 = v14;
    }
    unsigned int v35 = v33 - v32;
    v53.i32[v24] = v35;
    v53.i32[v23] = ((v53.i32[v23] - v53.i32[v25]) * ((int)(v35 << 16) / v29) + 0x8000) >> 16;
  }
  v53.i32[v25] = 0;
  int v36 = 77 * (v30 - v53.i32[0]) + 151 * (v31 - v53.i32[1]) + 28 * (v14 - v54);
  int v37 = v53.i32[0] + ((v36 + 128) >> 8);
  int v38 = v53.i32[1] + ((v36 + 128) >> 8);
  signed int v39 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v40 = v54 + ((v36 + 128) >> 8);
  if (v36 != (char)v36)
  {
    if (v53.i32[0] >= v53.i32[1]) {
      int v41 = v53.i32[1] + ((v36 + 128) >> 8);
    }
    else {
      int v41 = v53.i32[0] + ((v36 + 128) >> 8);
    }
    if (v53.i32[0] >= v53.i32[1]) {
      int v42 = v53.i32[0] + ((v36 + 128) >> 8);
    }
    else {
      int v42 = v53.i32[1] + ((v36 + 128) >> 8);
    }
    if (v40 <= v42) {
      int v43 = v42;
    }
    else {
      int v43 = v54 + ((v36 + 128) >> 8);
    }
    if (v40 >= v41) {
      int v44 = v41;
    }
    else {
      int v44 = v54 + ((v36 + 128) >> 8);
    }
    if (v40 >= v41) {
      int v42 = v43;
    }
    if (v42 > v39 || v44 < 0)
    {
      int v45 = (77 * v37 + 151 * v38 + 28 * v40 + 128) >> 8;
      if (v36 > -129)
      {
        int v46 = v42 - v45;
        if (v42 == v45) {
          goto LABEL_63;
        }
        int v47 = v39 - v45;
      }
      else
      {
        int v46 = v45 - v44;
        if (v45 == v44) {
          goto LABEL_63;
        }
        int v47 = (77 * v37 + 151 * v38 + 28 * v40 + 128) >> 8;
      }
      int v48 = (v47 << 16) / v46;
      int v37 = v45 + ((v48 * (v37 - v45) + 0x8000) >> 16);
      int v38 = v45 + ((v48 * (v38 - v45) + 0x8000) >> 16);
      int v40 = v45 + ((v48 * (v40 - v45) + 0x8000) >> 16);
    }
  }
LABEL_63:
  if (v19 >> 7 >= 0x1FD) {
    unsigned int v49 = 65152;
  }
  else {
    unsigned int v49 = v19 + 128;
  }
  if (HIDWORD(v21) >> 7 >= 0x1FD) {
    unsigned int v50 = 65152;
  }
  else {
    unsigned int v50 = HIDWORD(v21) + 128;
  }
  if (LODWORD(v21) >> 7 >= 0x1FD) {
    unsigned int v51 = 65152;
  }
  else {
    unsigned int v51 = LODWORD(v21) + 128;
  }
  return ((_WORD)v51 + (unsigned __int16)(v51 >> 8) + ((_WORD)v37 << 8)) & 0xFF00 | ((v38 + ((unsigned __int16)(v50 + (v50 >> 8)) >> 8)) << 16) | ((v40 + ((v49 + (v49 >> 8)) >> 8)) << 24) | (a4 + a2 - v39);
}

uint64_t PDAtranspose_saturationPDA_21381(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  int32x2_t v4 = vdup_n_s32(a4);
  double v5 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v4));
  int32x2_t v6 = vdup_n_s32(a2);
  int32x2_t v7 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v6);
  if (HIBYTE(a3) >= a4) {
    unsigned int v8 = a4;
  }
  else {
    unsigned int v8 = HIBYTE(a3);
  }
  if (HIBYTE(a1) >= a2) {
    signed int v9 = a2;
  }
  else {
    signed int v9 = HIBYTE(a1);
  }
  if (a4 == 255)
  {
    unsigned int v12 = 0;
    int32x2_t v10 = 0;
  }
  else
  {
    int32x2_t v10 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v7);
    uint32x2_t v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v7, v4);
    int32x2_t v7 = (int32x2_t)vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL);
    unsigned int v12 = (a4 ^ 0xFF) * v9;
    signed int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
  }
  double v13 = COERCE_DOUBLE(vrev64_s32(v10));
  double v14 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v13, *(int32x2_t *)&v5, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v15 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v5, v6);
  double v16 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v15, v15, 8uLL), 8uLL));
  unsigned int v17 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255) {
    unsigned int v17 = v8;
  }
  else {
    v12 += v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    double v16 = v5;
    double v18 = v13;
  }
  else
  {
    double v18 = v14;
  }
  int32x2_t v47 = v7;
  signed int v48 = v9;
  uint64_t v19 = v7.i32[0] < (unsigned __int32)v7.i32[1];
  uint64_t v20 = v7.i32[0] >= (unsigned __int32)v7.i32[1];
  if (v9 >= *(_DWORD *)((unint64_t)&v47 | (4 * v20)))
  {
    uint64_t v21 = v7.i32[0] >= (unsigned __int32)v7.i32[1];
    if (v9 <= *(_DWORD *)((unint64_t)&v47 | (4 * v19))) {
      uint64_t v20 = 2;
    }
    else {
      uint64_t v20 = v7.i32[0] < (unsigned __int32)v7.i32[1];
    }
    if (v9 > *(_DWORD *)((unint64_t)&v47 | (4 * v19))) {
      uint64_t v19 = 2;
    }
  }
  else
  {
    uint64_t v21 = 2;
  }
  __int32 v22 = v47.i32[v19];
  __int32 v23 = v47.i32[v21];
  BOOL v24 = __OFSUB__(v22, v23);
  int v25 = v22 - v23;
  if ((v25 < 0) ^ v24 | (v25 == 0))
  {
    v47.i32[v19] = 0;
    v47.i32[v20] = 0;
  }
  else
  {
    unsigned int v26 = LODWORD(v16);
    if (HIDWORD(v16) >= LODWORD(v16)) {
      unsigned int v27 = LODWORD(v16);
    }
    else {
      unsigned int v27 = HIDWORD(v16);
    }
    if (HIDWORD(v16) > LODWORD(v16)) {
      unsigned int v26 = HIDWORD(v16);
    }
    if (v17 <= v26) {
      unsigned int v28 = v26;
    }
    else {
      unsigned int v28 = v17;
    }
    if (v17 >= v27)
    {
      unsigned int v17 = v27;
      unsigned int v26 = v28;
    }
    unsigned int v29 = v26 - v17;
    v47.i32[v19] = v29;
    v47.i32[v20] = ((v47.i32[v20] - v47.i32[v21]) * ((int)(v29 << 16) / v25) + 0x8000) >> 16;
  }
  v47.i32[v21] = 0;
  int v30 = 77 * (v7.i32[0] - v47.i32[0]) + 151 * (v7.i32[1] - v47.i32[1]) + 28 * (v9 - v48);
  int v31 = v47.i32[0] + ((v30 + 128) >> 8);
  int v32 = v47.i32[1] + ((v30 + 128) >> 8);
  signed int v33 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v34 = v48 + ((v30 + 128) >> 8);
  if (v30 != (char)v30)
  {
    if (v47.i32[0] >= v47.i32[1]) {
      int v35 = v47.i32[1] + ((v30 + 128) >> 8);
    }
    else {
      int v35 = v47.i32[0] + ((v30 + 128) >> 8);
    }
    if (v47.i32[0] >= v47.i32[1]) {
      int v36 = v47.i32[0] + ((v30 + 128) >> 8);
    }
    else {
      int v36 = v47.i32[1] + ((v30 + 128) >> 8);
    }
    if (v34 <= v36) {
      int v37 = v36;
    }
    else {
      int v37 = v48 + ((v30 + 128) >> 8);
    }
    if (v34 >= v35) {
      int v38 = v35;
    }
    else {
      int v38 = v48 + ((v30 + 128) >> 8);
    }
    if (v34 >= v35) {
      int v36 = v37;
    }
    if (v36 > v33 || v38 < 0)
    {
      int v39 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      if (v30 > -129)
      {
        int v40 = v36 - v39;
        if (v36 == v39) {
          goto LABEL_59;
        }
        int v41 = v33 - v39;
      }
      else
      {
        int v40 = v39 - v38;
        if (v39 == v38) {
          goto LABEL_59;
        }
        int v41 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      }
      int v42 = (v41 << 16) / v40;
      int v31 = v39 + ((v42 * (v31 - v39) + 0x8000) >> 16);
      int v32 = v39 + ((v42 * (v32 - v39) + 0x8000) >> 16);
      int v34 = v39 + ((v42 * (v34 - v39) + 0x8000) >> 16);
    }
  }
LABEL_59:
  if (v12 >> 7 >= 0x1FD) {
    unsigned int v43 = 65152;
  }
  else {
    unsigned int v43 = v12 + 128;
  }
  if (LODWORD(v18) >> 7 >= 0x1FD) {
    unsigned int v44 = 65152;
  }
  else {
    unsigned int v44 = LODWORD(v18) + 128;
  }
  if (HIDWORD(v18) >> 7 >= 0x1FD) {
    unsigned int v45 = 65152;
  }
  else {
    unsigned int v45 = HIDWORD(v18) + 128;
  }
  return ((_WORD)v45 + (unsigned __int16)(v45 >> 8) + ((_WORD)v31 << 8)) & 0xFF00 | ((v32 + ((unsigned __int16)(v44 + (v44 >> 8)) >> 8)) << 16) | ((v34 + ((v43 + (v43 >> 8)) >> 8)) << 24) | (a4 + a2 - v33);
}

uint64_t PDAtranspose_luminosityPDA_21382(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint32x2_t v4 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  unsigned int v5 = HIBYTE(a3);
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vdup_n_s32(a2);
  int32x2_t v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7);
  if (HIBYTE(a3) >= a4) {
    unsigned int v5 = a4;
  }
  if (HIBYTE(a1) >= a2) {
    unsigned int v9 = a2;
  }
  else {
    unsigned int v9 = HIBYTE(a1);
  }
  if (a4 == 255)
  {
    unsigned int v12 = 0;
    int32x2_t v10 = 0;
  }
  else
  {
    int32x2_t v10 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v8);
    uint32x2_t v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v8, v6);
    int32x2_t v8 = (int32x2_t)vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL);
    unsigned int v12 = (a4 ^ 0xFF) * v9;
    unsigned int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
  }
  int32x2_t v13 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v6);
  if (a2 != 255)
  {
    int32x2_t v10 = vmla_s32(v10, v13, vdup_n_s32(a2 ^ 0xFF));
    uint32x2_t v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v13, v7);
    int32x2_t v13 = (int32x2_t)vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL);
    v12 += v5 * (a2 ^ 0xFF);
    unsigned int v5 = (v5 * a2 + 128 + ((v5 * a2 + 128) >> 8)) >> 8;
  }
  int32x2_t v15 = vmul_s32(vsub_s32(v13, v8), (int32x2_t)0x4D00000097);
  int v16 = v15.i32[0] + 28 * (v5 - v9) + v15.i32[1];
  int v17 = v8.i32[1] + ((v16 + 128) >> 8);
  __int32 v18 = v8.i32[0] + ((v16 + 128) >> 8);
  signed int v19 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v20 = v9 + ((v16 + 128) >> 8);
  if (v16 != (char)v16)
  {
    if (v8.i32[1] >= (unsigned __int32)v8.i32[0]) {
      int v21 = v8.i32[0] + ((v16 + 128) >> 8);
    }
    else {
      int v21 = v8.i32[1] + ((v16 + 128) >> 8);
    }
    if (v8.i32[1] >= (unsigned __int32)v8.i32[0]) {
      int v22 = v8.i32[1] + ((v16 + 128) >> 8);
    }
    else {
      int v22 = v8.i32[0] + ((v16 + 128) >> 8);
    }
    if (v20 <= v22) {
      int v23 = v22;
    }
    else {
      int v23 = v20;
    }
    if (v20 >= v21) {
      int v24 = v21;
    }
    else {
      int v24 = v20;
    }
    if (v20 >= v21) {
      int v22 = v23;
    }
    if (v22 > v19 || v24 < 0)
    {
      int v25 = (77 * v17 + 151 * v18 + 28 * v20 + 128) >> 8;
      if (v16 > -129)
      {
        int v26 = v22 - v25;
        if (v22 == v25) {
          goto LABEL_34;
        }
        int v27 = v19 - v25;
      }
      else
      {
        int v26 = v25 - v24;
        if (v25 == v24) {
          goto LABEL_34;
        }
        int v27 = (77 * v17 + 151 * v18 + 28 * v20 + 128) >> 8;
      }
      int v28 = (v27 << 16) / v26;
      int v17 = v25 + ((v28 * (v17 - v25) + 0x8000) >> 16);
      __int32 v18 = v25 + ((v28 * (v18 - v25) + 0x8000) >> 16);
      int v20 = v25 + ((v28 * (v20 - v25) + 0x8000) >> 16);
    }
  }
LABEL_34:
  unsigned __int8 v29 = a4 + a2 - v19;
  unsigned int v30 = v12 + 128;
  if (v12 >> 7 >= 0x1FD) {
    unsigned int v30 = 65152;
  }
  unsigned int v31 = v20 + ((v30 + (v30 >> 8)) >> 8);
  uint32x2_t v32 = vcgt_u32((uint32x2_t)vdup_n_s32(0xFE80u), (uint32x2_t)v10);
  unsigned int v33 = v10.i32[0] + 128;
  if ((v32.i8[0] & 1) == 0) {
    unsigned int v33 = 65152;
  }
  unsigned __int32 v34 = v18 + ((v33 + (v33 >> 8)) >> 8);
  if (v32.i8[4]) {
    unsigned int v35 = v10.i32[1] + 128;
  }
  else {
    unsigned int v35 = 65152;
  }
  return ((_WORD)v35 + (unsigned __int16)(v35 >> 8) + ((_WORD)v17 << 8)) & 0xFF00 | (v34 << 16) | (v31 << 24) | v29;
}

uint64_t rgba32_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(result + 280);
  float v5 = *(float *)(*(void *)(result + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = result + 368;
  uint64_t v10 = *(void *)(result + 368);
  int v11 = 15;
  if (v10) {
    uint64_t v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(result + 284);
  float v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  float v14 = *(float *)(result + 304);
  float v15 = *(float *)(result + 308);
  float v16 = *(float *)(result + 312);
  float v17 = *(float *)(result + 316);
  float v18 = *(float *)(result + 336);
  float v19 = *(float *)(result + 348);
  float v20 = *(float *)(result + 344);
  float v21 = *(float *)(result + 356);
  int v22 = *(unsigned __int16 **)(result + 376);
  uint64_t v23 = *(void *)(result + 360);
  int v24 = 4 * *(_DWORD *)(result + 48);
  if (v10) {
    uint64_t v25 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v25 = 0;
  }
  int v27 = *(char **)(result + 144);
  int v26 = *(unsigned int **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      unsigned int v35 = (unsigned __int16 *)(v23
                               + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19))
                               + 8 * (int)(float)(v20 * (float)(v8 - v18)));
      unsigned __int16 v36 = v35[1];
      int v37 = *(unsigned __int8 *)(v9 + v25);
      int v38 = v35[2];
      int v39 = v35[3];
      int v32 = v37 + *v35;
      __int16 v33 = v37 + v36;
      int v34 = v37 + v38;
      int32x2_t result = (v37 + v39);
      goto LABEL_21;
    }
    if (v22)
    {
      int v31 = *(unsigned __int8 *)(v9 + v25);
      int v32 = v31 + *v22;
      __int16 v33 = v31 + v22[1];
      int v34 = v31 + v22[2];
      int32x2_t result = v31 + v22[3];
LABEL_21:
      *int v26 = (v34 | (v32 << 16)) & 0xFF00FF00 | (HIBYTE(v33) << 16) | BYTE1(result);
      char v40 = -1;
      goto LABEL_22;
    }
    char v40 = 0;
LABEL_22:
    uint64_t v25 = (v25 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    ++v26;
    *v27++ = v40;
    --a4;
  }
  while (a4);
  return result;
}

void rgba32_shade_conic_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = *(void *)(a1 + 368);
  if (v9) {
    uint64_t v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v10 = a1 + 368;
  }
  if (v9) {
    int v11 = 15;
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(a1 + 284);
  float v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  float v32 = *(float *)(a1 + 336);
  float v33 = *(float *)(a1 + 304);
  float v15 = *(float *)(a1 + 344);
  uint64_t v16 = *(void *)(a1 + 360);
  float v18 = *(unsigned char **)(a1 + 144);
  float v17 = *(int **)(a1 + 152);
  if (v9) {
    uint64_t v19 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v19 = 0;
  }
  float v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    float v21 = v15 * (float)((float)(v33 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v32);
    unsigned int v22 = vcvtms_s32_f32(v21);
    float v23 = ceilf(v21);
    float v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    unsigned int v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0) {
      unsigned int v22 = v25;
    }
    float v26 = ceilf(v21 - v15);
    if (v21 <= v15) {
      float v27 = v23;
    }
    else {
      float v27 = v26;
    }
    int v28 = (unsigned __int16 *)(v16 + 2 * (int)(4 * v22));
    int v29 = 255 - (int)v24;
    unsigned int v30 = (unsigned __int16 *)(v16 + 8 * (int)v27);
    int v31 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = ((int)v24 * v30[1] + (v31 << 8) + v29 * v28[1]) & 0xFF0000 | ((_WORD)v31
                                                                         + (unsigned __int16)(((int)v24 * v30[2]
                                                                                             + v29
                                                                                             * v28[2]) >> 8)) & 0xFF00 | (((unsigned __int16)(v31 + (((int)v24 * *v30 + v29 * *v28) >> 8)) >> 8) << 24) | ((unsigned __int16)(v31 + (((int)v24 * v30[3] + v29 * v28[3]) >> 8)) >> 8);
    uint64_t v19 = (v19 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
}

void rgba32_shade_radial_RGB(uint64_t a1, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float v13 = *(float *)(a1 + 280);
  float v14 = *(float *)(a1 + 284);
  float v15 = *(float *)(*(void *)(a1 + 272) + 4);
  float v16 = v15 * (float)a2;
  float v17 = v15 * (float)(uint64_t)a3;
  float v18 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v17) + (float)(v13 * v16));
  float v19 = *(float *)(a1 + 300) + (float)((float)(v17 * *(float *)(a1 + 292)) + (float)(v14 * v16));
  uint64_t v21 = *(void *)(a1 + 400);
  float v22 = *(float *)(a1 + 336);
  float v23 = *(float *)(a1 + 344);
  float v24 = *(float *)(a1 + 304);
  float v25 = *(float *)(a1 + 308);
  int v26 = *(_DWORD *)(a1 + 324);
  LODWORD(a12) = *(_DWORD *)(v21 + 8);
  float v27 = *(float *)(v21 + 16);
  float v28 = *(float *)(v21 + 20);
  float v29 = *(float *)(v21 + 28);
  uint64_t v32 = a1 + 144;
  unsigned int v30 = *(char **)(a1 + 144);
  uint64_t v31 = *(void *)(v32 + 8);
  float v33 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v34 = *(void *)(a1 + 360);
  uint64_t v35 = ((unint64_t)a2 >> 8) & 0xF;
  if (*(float *)&a12 != 0.0 || v29 != 0.0 || v14 != 0.0)
  {
    int v47 = *(_DWORD *)(a1 + 320);
    float v48 = *(float *)(v21 + 12);
    float v49 = *(float *)(v21 + 24);
    float v50 = *(float *)(v21 + 32);
    uint64_t v51 = a1 + 368;
    uint64_t v52 = *(void *)(a1 + 368);
    uint64_t v53 = v52 + ((a3 >> 4) & 0xF0);
    BOOL v39 = v52 == 0;
    int v54 = 15;
    if (v39)
    {
      int v54 = 0;
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v51 = v53;
    }
    float v55 = -v49;
    float v56 = v25 - v24;
    while (1)
    {
      float v57 = v55 + (float)((float)(v18 + v18) * *(float *)&a12);
      float v58 = (float)((float)(v19 * v19) + (float)(v18 * v18)) - v29;
      if (v28 == 0.0)
      {
        float v65 = v58 / v57;
      }
      else
      {
        float v59 = (float)((float)(v28 * -4.0) * v58) + (float)(v57 * v57);
        if (v59 < 0.0) {
          goto LABEL_56;
        }
        float v60 = sqrtf(v59);
        float v61 = v50 * (float)(v57 - v60);
        float v62 = v57 + v60;
        float v63 = v50 * v62;
        BOOL v64 = (float)(v50 * v62) <= v61;
        if ((float)(v50 * v62) <= v61) {
          float v65 = v50 * v62;
        }
        else {
          float v65 = v61;
        }
        if (v64) {
          float v63 = v61;
        }
        if (v63 < 0.0)
        {
          BOOL v66 = v63 < v48;
LABEL_42:
          int v67 = v47;
          if (v66) {
            goto LABEL_56;
          }
LABEL_43:
          if ((v67 & 0x80000000) == 0) {
            goto LABEL_55;
          }
          goto LABEL_56;
        }
        if (v63 <= 1.0)
        {
          float v68 = v24 + (float)(v63 * v56);
          goto LABEL_54;
        }
        if ((v26 & 0x80000000) == 0)
        {
          int v67 = v26;
          if (v63 <= v27)
          {
LABEL_55:
            unsigned int v69 = (unsigned __int16 *)(v34 + 8 * v67);
            unsigned __int16 v70 = v69[1];
            int v71 = *(unsigned __int8 *)(v51 + v35);
            int v72 = v69[2];
            unsigned __int16 v73 = v69[3];
            int v74 = v71 + *v69;
            __int16 v75 = v71 + v70;
            int v76 = v71 + v72;
            __int16 v77 = v71 + v73;
            goto LABEL_58;
          }
        }
      }
      if (v65 < 0.0)
      {
        BOOL v66 = v65 < v48;
        goto LABEL_42;
      }
      if (v65 > 1.0)
      {
        int v67 = v26;
        if (v65 > v27) {
          goto LABEL_56;
        }
        goto LABEL_43;
      }
      float v68 = v24 + (float)(v65 * v56);
LABEL_54:
      int v67 = (int)(float)(v23 * (float)(v68 - v22));
      if ((v67 & 0x80000000) == 0) {
        goto LABEL_55;
      }
LABEL_56:
      if (!v33)
      {
        char v79 = 0;
        goto LABEL_60;
      }
      int v78 = *(unsigned __int8 *)(v51 + v35);
      int v74 = v78 + *v33;
      __int16 v75 = v78 + v33[1];
      int v76 = v78 + v33[2];
      __int16 v77 = v78 + v33[3];
LABEL_58:
      *(_DWORD *)uint64_t v31 = (v76 | (v74 << 16)) & 0xFF00FF00 | (HIBYTE(v75) << 16) | HIBYTE(v77);
      char v79 = -1;
LABEL_60:
      uint64_t v35 = (v35 + 1) & v54;
      float v18 = v13 + v18;
      float v19 = v14 + v19;
      v31 += 4;
      *v30++ = v79;
      if (!--a4) {
        return;
      }
    }
  }
  uint64_t v36 = a1 + 368;
  uint64_t v37 = *(void *)(a1 + 368);
  int v38 = (BYTE1(a2) + 1) & 0xF;
  BOOL v39 = v37 == 0;
  if (v37) {
    uint64_t v40 = v37 + ((a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v40 = v36;
  }
  if (v39) {
    LODWORD(v41) = 0;
  }
  else {
    LODWORD(v41) = v38;
  }
  if (v39) {
    LODWORD(v42) = 0;
  }
  else {
    LODWORD(v42) = v35;
  }
  if (v39) {
    int v43 = 0;
  }
  else {
    int v43 = 15;
  }
  float v44 = v19 * v19;
  float v45 = -v28;
  if (v44 <= (float)-v28)
  {
    float v80 = fabsf(*(float *)(v21 + 32));
    float v81 = v28 * -4.0;
    float v82 = v25 - v24;
    uint64_t v83 = (unsigned __int16 *)(v34 + 8 * v26);
    int v84 = a4 + 2;
    while (1)
    {
      float v85 = v44 + (float)(v18 * v18);
      float v86 = v13 + v18;
      float v87 = v44 + (float)(v86 * v86);
      if (v85 > v45 && v87 > v45)
      {
        if (v26 < 0)
        {
          if (!v33)
          {
            char v121 = 0;
            char v120 = 0;
            goto LABEL_84;
          }
          int v96 = *v33;
          int v97 = v33[1];
          int v98 = v33[2];
          unsigned __int16 v99 = v33[3];
        }
        else
        {
          int v96 = *v83;
          int v97 = v83[1];
          int v98 = v83[2];
          unsigned __int16 v99 = v83[3];
        }
        int v114 = *(unsigned __int8 *)(v40 + v42);
        int v115 = v114 + v96;
        unsigned int v116 = (v114 + v97) >> 8;
        int v117 = v114 + v98;
        __int16 v118 = v114 + v99;
        int v119 = *(unsigned __int8 *)(v40 + v41);
        int v110 = v119 + v96;
        __int16 v111 = v119 + v97;
        int v112 = v119 + v98;
        __int16 v113 = v119 + v99;
        *(_DWORD *)uint64_t v31 = (v117 | (v115 << 16)) & 0xFF00FF00 | (v116 << 16) | HIBYTE(v118);
        goto LABEL_82;
      }
      float v89 = sqrtf(v81 * v87);
      float v90 = v80 * sqrtf(v81 * v85);
      float v91 = v80 * v89;
      int v92 = (int)(float)(v23 * (float)((float)(v24 + (float)(v90 * v82)) - v22));
      int v93 = (int)(float)(v23 * (float)((float)(v24 + (float)((float)(v80 * v89) * v82)) - v22));
      if (v90 <= 1.0 && v91 <= 1.0)
      {
        float64x2_t v100 = (unsigned __int16 *)(v34 + 8 * v92);
        uint64_t v101 = (unsigned __int16 *)(v34 + 8 * v93);
        int v102 = *v101;
        unsigned __int16 v103 = v101[1];
        int v104 = v101[2];
        unsigned __int16 v105 = v101[3];
        LODWORD(v101) = *(unsigned __int8 *)(v40 + v42);
        unsigned int v106 = (v101 + *v100) >> 8;
        unsigned int v107 = (v101 + v100[1]) >> 8;
        __int16 v108 = (_WORD)v101 + v100[2];
        LOWORD(v100) = (_WORD)v101 + v100[3];
        int v109 = *(unsigned __int8 *)(v40 + v41);
        int v110 = v109 + v102;
        __int16 v111 = v109 + v103;
        int v112 = v109 + v104;
        __int16 v113 = v109 + v105;
        *(_DWORD *)uint64_t v31 = v108 & 0xFF00 | (v106 << 24) | (v107 << 16) | BYTE1(v100);
LABEL_82:
        char v120 = -1;
        goto LABEL_83;
      }
      if (v90 <= 1.0)
      {
        if ((v92 & 0x80000000) == 0)
        {
          uint64_t v95 = 4 * v92;
LABEL_88:
          double v122 = (unsigned __int16 *)(v34 + 2 * v95);
          unsigned __int16 v123 = v122[1];
          int v124 = *(unsigned __int8 *)(v40 + v42);
          int v125 = v122[2];
          unsigned __int16 v126 = v122[3];
          int v127 = v124 + *v122;
          __int16 v128 = v124 + v123;
          int v129 = v124 + v125;
          __int16 v130 = v124 + v126;
          goto LABEL_91;
        }
      }
      else if (v90 <= v27)
      {
        uint64_t v95 = 4 * v26;
        if ((v26 & 0x80000000) == 0) {
          goto LABEL_88;
        }
      }
      if (!v33)
      {
        char v120 = 0;
        goto LABEL_92;
      }
      int v131 = *(unsigned __int8 *)(v40 + v42);
      int v127 = v131 + *v33;
      __int16 v128 = v131 + v33[1];
      int v129 = v131 + v33[2];
      __int16 v130 = v131 + v33[3];
LABEL_91:
      *(_DWORD *)uint64_t v31 = (v129 | (v127 << 16)) & 0xFF00FF00 | (HIBYTE(v128) << 16) | HIBYTE(v130);
      char v120 = -1;
LABEL_92:
      if (v91 <= 1.0)
      {
        if (v93 < 0) {
          goto LABEL_99;
        }
        uint64_t v132 = 4 * v93;
      }
      else if (v91 > v27 || (uint64_t v132 = 4 * v26, v26 < 0))
      {
LABEL_99:
        if (!v33)
        {
          char v121 = 0;
          goto LABEL_84;
        }
        int v138 = *(unsigned __int8 *)(v40 + v41);
        int v110 = v138 + *v33;
        __int16 v111 = v138 + v33[1];
        int v112 = v138 + v33[2];
        __int16 v113 = v138 + v33[3];
        goto LABEL_83;
      }
      uint64_t v133 = (unsigned __int16 *)(v34 + 2 * v132);
      unsigned __int16 v134 = v133[1];
      int v135 = *(unsigned __int8 *)(v40 + v41);
      int v136 = v133[2];
      unsigned __int16 v137 = v133[3];
      int v110 = v135 + *v133;
      __int16 v111 = v135 + v134;
      int v112 = v135 + v136;
      __int16 v113 = v135 + v137;
LABEL_83:
      *(_DWORD *)(v31 + 4) = (v112 | (v110 << 16)) & 0xFF00FF00 | (HIBYTE(v111) << 16) | HIBYTE(v113);
      char v121 = -1;
LABEL_84:
      float v18 = v13 + v86;
      LOBYTE(v42) = (v42 + 1) & v43;
      LOBYTE(v41) = (v41 + 1) & v43;
      v31 += 8;
      *unsigned int v30 = v120;
      v30[1] = v121;
      v30 += 2;
      v84 -= 2;
      if (v84 <= 2) {
        return;
      }
    }
  }
  if (v33 || (v26 & 0x80000000) == 0)
  {
    uint64_t v139 = (unsigned __int16 *)(v34 + 8 * v26);
    if (v26 >= 0) {
      v140 = v139;
    }
    else {
      v140 = v33;
    }
    int32x2_t v141 = vdup_n_s32(*v140);
    int32x2_t v142 = vdup_n_s32(v140[2]);
    int32x2_t v143 = vdup_n_s32(v140[1]);
    int32x2_t v144 = vdup_n_s32(v140[3]);
    int v145 = a4 + 4;
    do
    {
      double v146 = (unsigned char *)(v40 + v42);
      uint64_t v42 = (v42 + 1) & v43;
      LOBYTE(a12) = *v146;
      BYTE4(a12) = *(unsigned char *)(v40 + v41);
      int32x2_t v147 = (int32x2_t)vand_s8(*(int8x8_t *)&a12, (int8x8_t)0xFF000000FFLL);
      int8x8_t v148 = vorr_s8(vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v141, v147), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), vand_s8((int8x8_t)vadd_s32(v142, v147), (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v143, v147), 8uLL), (int8x8_t)0xFF000000FF0000), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v144, v147), 8uLL) & 0xFFFFFEFFFFFFFEFFLL)));
      *(int8x8_t *)uint64_t v31 = v148;
      uint64_t v41 = (v41 + 1) & v43;
      v148.i8[0] = *(unsigned char *)(v40 + v42);
      v148.i8[4] = *(unsigned char *)(v40 + v41);
      int32x2_t v149 = (int32x2_t)vand_s8(v148, (int8x8_t)0xFF000000FFLL);
      a12 = COERCE_DOUBLE(vorr_s8(vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v141, v149), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), vand_s8((int8x8_t)vadd_s32(v142, v149), (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v143, v149), 8uLL), (int8x8_t)0xFF000000FF0000), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v144, v149), 8uLL) & 0xFFFFFEFFFFFFFEFFLL))));
      *(double *)(v31 + 8) = a12;
      *(_DWORD *)unsigned int v30 = -1;
      v30 += 4;
      v145 -= 4;
      v31 += 16;
    }
    while (v145 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v46 = 4;
    }
    else {
      int v46 = a4;
    }
    bzero(v30, ((a4 - v46 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t rgba32_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  memset(v48, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  uint64_t v8 = *(unsigned int *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if ((int)v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v31, (uint64_t)v48) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = 134755224;
  unsigned int v19 = *(_DWORD *)a3;
  *((void *)&v31 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 134755224)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (!v20) {
      return 0xFFFFFFFFLL;
    }
    if (v20 <= 0xB)
    {
      LOBYTE(v21) = 0;
      int v22 = 0;
      switch(v20)
      {
        case 2u:
          uint64_t v21 = *((void *)a2 + 12);
          if (v21) {
            goto LABEL_34;
          }
          int v22 = 16;
          break;
        case 5u:
          LOBYTE(v21) = 0;
          int v22 = 24;
          break;
        case 6u:
          goto LABEL_35;
        case 7u:
          LOBYTE(v21) = 0;
          int v22 = 32;
          break;
        case 8u:
          LOBYTE(v21) = 0;
          int v22 = 8;
          break;
        case 9u:
          LOBYTE(v21) = 0;
          int v22 = 40;
          break;
        default:
          goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (v20 <= 0x13)
    {
      if (v20 - 14 < 4)
      {
        LOBYTE(v21) = 0;
LABEL_27:
        int v22 = 0;
LABEL_35:
        *(void *)&long long v31 = *(void *)&RGB8_image_sample[2 * v20 + 2];
        if ((void)v31) {
          goto LABEL_42;
        }
        if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 0x10)
        {
          *(void *)&long long v31 = *(void *)&RGB16_image_sample[2 * v20 + 2];
          if ((void)v31)
          {
            int v18 = 269497256;
            int v23 = 8;
LABEL_41:
            LODWORD(v32) = v23;
LABEL_42:
            DWORD2(v31) = v18;
            if (v21) {
              goto LABEL_60;
            }
            goto LABEL_43;
          }
        }
        *(void *)&long long v31 = *(void *)&RGBF_image_sample[2 * v20 + 2];
        if ((void)v31)
        {
          int v18 = 538981289;
          int v23 = 16;
          goto LABEL_41;
        }
        return 0xFFFFFFFFLL;
      }
      if (v20 == 13 || v20 == 12)
      {
        uint64_t v21 = *((void *)a2 + 12);
        if (!v21) {
          goto LABEL_27;
        }
      }
    }
LABEL_34:
    int v22 = 255;
    LOBYTE(v21) = 1;
    goto LABEL_35;
  }
  if ((void)v42 || (~DWORD1(v32) & 0xC3) != 0) {
    goto LABEL_30;
  }
  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
  if ((v8 - 1) > 1 || (BYTE4(v32) & 4) != 0 || v17.n128_f32[0] != 1.0)
  {
    if (v17.n128_f32[0] >= 1.0) {
      goto LABEL_29;
    }
LABEL_30:
    *(void *)&long long v31 = rgba32_sample_rgba32;
    unsigned int v20 = 7;
    int v22 = 32;
LABEL_43:
    if ((BYTE4(v32) & 7) == 3 && (v8 - 1) <= 1 && (a2[2] == 5 || !a2[2]))
    {
      if (v20 <= 0xB)
      {
        HIDWORD(v24) = v22;
        LODWORD(v24) = v22;
        switch((v24 >> 3))
        {
          case 0u:
            if ((~DWORD1(v32) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_RGBX32((uint64_t)a2, v8, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_RGB32;
            goto LABEL_127;
          case 1u:
            if ((~DWORD1(v32) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_XRGB32((uint64_t)a2, v8, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            int v26 = rgba32_image_mark_RGB32;
            goto LABEL_97;
          case 2u:
            if (v8 == 1 && (BYTE4(v32) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_W8((uint64_t)a2, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_W8;
            goto LABEL_127;
          case 3u:
            if (v8 == 1 && (BYTE4(v32) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_RGB24((uint64_t)a2, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_RGB24;
            goto LABEL_127;
          case 4u:
            if ((~DWORD1(v32) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_rgbx32((uint64_t)a2, v8, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_rgba32;
            goto LABEL_127;
          case 5u:
            if ((~DWORD1(v32) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_xrgb32((uint64_t)a2, v8, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            int v26 = rgba32_image_mark_rgb32;
LABEL_97:
            float v27 = v26;
            uint64_t v28 = (uint64_t)a2;
            int v29 = v8;
            int v30 = 8;
            break;
          default:
            goto LABEL_60;
        }
LABEL_128:
        argb32_image_mark_image(v28, (uint64_t)&v31, v29, v30, (void (*)(void, void))v27);
        return 1;
      }
      if (v20 <= 0x13)
      {
        switch(v20)
        {
          case 0xCu:
            if (v8 == 1 && (BYTE4(v32) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_W16((uint64_t)a2, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_W16;
            goto LABEL_127;
          case 0xDu:
            if (v8 == 1 && (BYTE4(v32) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_w16((uint64_t)a2, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_w16;
            goto LABEL_127;
          case 0xEu:
            if (v8 == 1 && (BYTE4(v32) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_RGB48((uint64_t)a2, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_RGB48;
            goto LABEL_127;
          case 0xFu:
            if (v8 == 1 && (BYTE4(v32) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_rgb48((uint64_t)a2, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_rgb48;
            goto LABEL_127;
          case 0x10u:
            if ((~DWORD1(v32) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_RGBA64((uint64_t)a2, v8, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_RGBA64;
            goto LABEL_127;
          case 0x11u:
            if ((~DWORD1(v32) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              rgba32_mark_image_rgba64((uint64_t)a2, v8, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v14, v15, v16);
              return 1;
            }
            DWORD2(v31) = *(_DWORD *)a3;
            float v25 = rgba32_image_mark_rgba64;
LABEL_127:
            float v27 = v25;
            uint64_t v28 = (uint64_t)a2;
            int v29 = v8;
            int v30 = 0;
            break;
          default:
            goto LABEL_60;
        }
        goto LABEL_128;
      }
    }
LABEL_60:
    rgba32_image_mark((uint64_t)a2, (uint64_t)&v31, v8, v17);
    return 1;
  }
  if (a2[2] != 5 && a2[2])
  {
LABEL_29:
    if (!*(void *)(a3 + 24))
    {
      if ((BYTE4(v32) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      rgba32_mark((uint64_t)a1, v17);
      return 1;
    }
    goto LABEL_30;
  }
  rgba32_mark_image((uint64_t)a2, v8, (uint64_t)v37 >> SBYTE6(v32), *((uint64_t *)&v37 + 1) >> SBYTE7(v32), *((uint64_t *)&v39 + 1) >> SBYTE7(v32), v14, v15, v16);
  return 1;
}

void rgba32_mark_image_W8(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  uint64_t v12 = *(int *)(a1 + 28);
  int v13 = *(_DWORD *)(a1 + 4);
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 8);
  int v22 = v13;
  uint64_t v15 = *(int **)(a1 + 136);
  if (v15)
  {
    int v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    int v18 = v17;
    if (v17) {
      goto LABEL_5;
    }
  }
  int v19 = 0;
  int v20 = 0;
  int v18 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    CGSConvertW8toARGB8888((char *)(*(void *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18) {
      break;
    }
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    int v20 = v23;
    int v19 = HIDWORD(v23);
    uint64_t v14 = v21;
    int v13 = v22;
  }
}

void rgba32_mark_image_RGB24(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  int v40 = a2;
  int v10 = *(_DWORD *)(a1 + 28);
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v42 = v12;
  int v43 = v11;
  int v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    int v44 = *(_DWORD *)(a1 + 108);
    int v45 = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v44, v11, v12);
    int v16 = v15;
    if (v15) {
      goto LABEL_28;
    }
  }
  int v17 = 0;
  int v18 = 0;
  int v16 = 0;
  int v44 = 0;
  int v45 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertBGR888toARGB8888", 142, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertBGR888toARGB8888", 142, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v12);
    }
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * v8) + 3 * (v17 + v40);
    uint64_t v21 = *(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17);
    uint64_t v22 = v19 * (uint64_t)v8;
    uint64_t v23 = v12 - 1;
    uint64_t v24 = v20 + (int)v23 * v22;
    uint64_t v25 = v21 + v23 * v10;
    int v26 = (char *)(v10 < 0 ? v25 : v21);
    size_t v27 = v10 >= 0 ? v10 : -v10;
    size_t v28 = v10 >= 0 ? v22 : -(int)v22;
    int v29 = (char *)(v10 < 0 ? v24 : v20);
    if ((v28 & 0x80000000) != 0)
    {
      int v30 = (char *)malloc_type_malloc((int)v27 * v12, 0x5432FF8EuLL);
      long long v31 = v30;
      if (v12 >= 1)
      {
        for (uint64_t i = 0; i != v12; ++i)
        {
          if (v11 >= 1)
          {
            long long v33 = &v30[i * v27];
            int v34 = v11;
            long long v35 = &v29[i * (int)v28];
            do
            {
              char v36 = *v35;
              char v37 = v35[1];
              char v38 = v35[2];
              *long long v33 = -1;
              v33[1] = v38;
              unint64_t v33[2] = v37;
              v33[3] = v36;
              v35 += 3;
              v33 += 4;
              --v34;
            }
            while (v34);
          }
        }
      }
      CGBlt_copyBytes(4 * v11, v12, v30, v26, v27, v27);
      free(v31);
      int v8 = a4;
      if (!v16) {
        return;
      }
    }
    else
    {
      v48.data = v29;
      v48.CGFloat height = v12;
      v48.CGFloat width = v11;
      v48.rowBytes = v28;
      dest.data = v26;
      dest.CGFloat height = v12;
      dest.CGFloat width = v11;
      dest.rowBytes = v27;
      *(_DWORD *)permuteMap = 16909056;
      vImageConvert_RGB888toARGB8888(&v48, 0, 0xFFu, &dest, 0, 0);
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0);
      if (!v16) {
        return;
      }
    }
LABEL_28:
    if (!shape_enum_clip_next((uint64_t)v16, &v45, &v44, &v43, &v42)) {
      break;
    }
    int v18 = v44;
    int v17 = v45;
    int v12 = v42;
    int v11 = v43;
    if (v43 < 0) {
      goto LABEL_4;
    }
  }
  free(v16);
}

void rgba32_mark_image_RGBX32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v26 = v15;
  int v27 = v14;
  int v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    int v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  int v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    uint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    int v25 = v22 * a5;
    if (v11 == 2)
    {
      CGSBlend8888toARGB8888(v23, v25, v24, v13, v27, v26, 0xE4u, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGSConvertBGRA8888toARGB8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertBGRX8888toARGB8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v27, &v26)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void rgba32_mark_image_rgbx32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v25 = v15;
  int v26 = v14;
  int v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    int v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  int v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    uint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    if (v11 == 2)
    {
      CGSBlend8888toARGB8888(v23, v22 * a5, v24, v13, v26, v25, 0x1Bu, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGBlt_copyBytes(4 * v26, v25, v23, v24, v22 * a5, v13);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertXRGB8888toARGB8888(v23, v22 * a5, v24, v13, v26, v25, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v26, &v25)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void rgba32_mark_image_XRGB32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v26 = v15;
  int v27 = v14;
  int v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    int v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  int v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    uint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    int v25 = v22 * a5;
    if (v11 == 2)
    {
      CGSBlend8888toARGB8888(v23, v25, v24, v13, v27, v26, 0x39u, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGSConvertABGR8888toARGB8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertXBGR8888toARGB8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v27, &v26)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void rgba32_mark_image_xrgb32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v26 = v15;
  int v27 = v14;
  int v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    int v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  int v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    uint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    int v25 = v22 * a5;
    if (v11 == 2)
    {
      CGSBlend8888toARGB8888(v23, v25, v24, v13, v27, v26, 0xC6u, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGSConvertRGBA8888toARGB8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertRGBX8888toARGB8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v27, &v26)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void rgba32_mark_image_W16(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  uint64_t v12 = *(int *)(a1 + 28);
  int v13 = *(_DWORD *)(a1 + 4);
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 8);
  int v22 = v13;
  int v15 = *(int **)(a1 + 136);
  if (v15)
  {
    int v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    int v18 = v17;
    if (v17) {
      goto LABEL_5;
    }
  }
  int v19 = 0;
  int v20 = 0;
  int v18 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    CGSConvertW16toARGB8888(*(void *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + 2 * (v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18) {
      break;
    }
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    int v20 = v23;
    int v19 = HIDWORD(v23);
    uint64_t v14 = v21;
    int v13 = v22;
  }
}

void rgba32_mark_image_w16(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  uint64_t v12 = *(int *)(a1 + 28);
  int v13 = *(_DWORD *)(a1 + 4);
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 8);
  int v22 = v13;
  int v15 = *(int **)(a1 + 136);
  if (v15)
  {
    int v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    int v18 = v17;
    if (v17) {
      goto LABEL_5;
    }
  }
  int v19 = 0;
  int v20 = 0;
  int v18 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    CGSConvertw16toARGB8888(*(void *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + 2 * (v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18) {
      break;
    }
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    int v20 = v23;
    int v19 = HIDWORD(v23);
    uint64_t v14 = v21;
    int v13 = v22;
  }
}

void rgba32_mark_image_RGB48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v37 = a2;
  uint64_t v9 = *(unsigned int *)(a1 + 28);
  uint64_t v10 = (int)v9;
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v41 = v12;
  int v42 = v11;
  int v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v43) = *(_DWORD *)(a1 + 108);
    HIDWORD(v43) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v43, v11, v12);
    int v16 = v15;
    if (v15) {
      goto LABEL_24;
    }
  }
  int v17 = 0;
  int v18 = 0;
  int v16 = 0;
  uint64_t v43 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertBGR16toARGB8888", 422, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertBGR16toARGB8888", 422, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v12);
    }
    int v40 = v16;
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v37);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    uint64_t v22 = v19 * (uint64_t)a4;
    uint64_t v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      uint64_t v24 = v10;
      v21 += v23 * v10;
      uint64_t v25 = v9;
      int v26 = -(int)v9;
    }
    else
    {
      uint64_t v24 = v10;
      uint64_t v25 = v9;
      int v26 = v9;
    }
    unint64_t v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    size_t v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      int v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      size_t v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21) {
        size_t v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0x9712D6FuLL);
      }
    }
    if (v12 >= 1)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (v11 >= 1)
        {
          long long v31 = &v28[i * v26];
          int v32 = v11;
          long long v33 = (char *)(v20 + i * (int)v22);
          do
          {
            char v34 = *v33;
            char v35 = v33[2];
            char v36 = v33[4];
            *long long v31 = -1;
            v31[1] = v36;
            v31[2] = v35;
            v31[3] = v34;
            v33 += 6;
            v31 += 4;
            --v32;
          }
          while (v32);
        }
      }
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    uint64_t v10 = v24;
    uint64_t v9 = v25;
    int v16 = v40;
    if (!v40) {
      break;
    }
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v43 + 1, &v43, &v42, &v41))
    {
      free(v16);
      return;
    }
    int v18 = v43;
    int v17 = HIDWORD(v43);
    int v12 = v41;
    int v11 = v42;
    if (v42 < 0) {
      goto LABEL_4;
    }
  }
}

void rgba32_mark_image_rgb48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v38 = a2;
  uint64_t v9 = *(unsigned int *)(a1 + 28);
  uint64_t v10 = (int)v9;
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v42 = v12;
  int v43 = v11;
  int v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v44) = *(_DWORD *)(a1 + 108);
    HIDWORD(v44) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v44, v11, v12);
    int v16 = v15;
    if (v15) {
      goto LABEL_24;
    }
  }
  int v17 = 0;
  int v18 = 0;
  int v16 = 0;
  uint64_t v44 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertbgr16toARGB8888", 584, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertbgr16toARGB8888", 584, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v12);
    }
    int v41 = v16;
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v38);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    uint64_t v22 = v19 * (uint64_t)a4;
    uint64_t v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      uint64_t v24 = v10;
      v21 += v23 * v10;
      uint64_t v25 = v9;
      int v26 = -(int)v9;
    }
    else
    {
      uint64_t v24 = v10;
      uint64_t v25 = v9;
      int v26 = v9;
    }
    unint64_t v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    size_t v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      int v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      size_t v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21) {
        size_t v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0xF58CBE08uLL);
      }
    }
    if (v12 >= 1)
    {
      uint64_t v30 = 0;
      long long v31 = (char *)(v20 + 5);
      do
      {
        if (v11 >= 1)
        {
          int v32 = &v28[v30 * v26];
          int v33 = v11;
          char v34 = v31;
          do
          {
            char v35 = *(v34 - 4);
            char v36 = *(v34 - 2);
            char v37 = *v34;
            v34 += 6;
            *int v32 = -1;
            v32[1] = v37;
            void v32[2] = v36;
            v32[3] = v35;
            v32 += 4;
            --v33;
          }
          while (v33);
        }
        ++v30;
        v31 += (int)v22;
      }
      while (v30 != v12);
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    uint64_t v10 = v24;
    uint64_t v9 = v25;
    int v16 = v41;
    if (!v41) {
      break;
    }
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v44 + 1, &v44, &v43, &v42))
    {
      free(v16);
      return;
    }
    int v18 = v44;
    int v17 = HIDWORD(v44);
    int v12 = v42;
    int v11 = v43;
    if (v43 < 0) {
      goto LABEL_4;
    }
  }
}

void rgba32_mark_image_RGBA64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v64 = a2;
  int v63 = *(_DWORD *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  int v69 = v10;
  int v70 = v9;
  int v11 = *(int **)(a1 + 136);
  if (v11)
  {
    int v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v71) = *(_DWORD *)(a1 + 108);
    HIDWORD(v71) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v71, v9, v10);
    int v14 = v13;
    if (v13) {
      goto LABEL_50;
    }
  }
  int v15 = 0;
  int v16 = 0;
  int v14 = 0;
  uint64_t v71 = 0;
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 76);
    uint64_t v18 = *(void *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    uint64_t v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    uint64_t v20 = *(void *)(a1 + 48);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + v19 * v63 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    uint64_t v22 = v17 * (uint64_t)v8;
    float v68 = v14;
    if (v64 == 2)
    {
      if (v20) {
        unsigned int v23 = 0;
      }
      else {
        unsigned int v23 = 255;
      }
      if (v10 >= 1)
      {
        int8x16_t v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FF0000;
        v25.i64[1] = 0xFF000000FF0000;
        v26.i64[0] = 0xFF000000FF00;
        v26.i64[1] = 0xFF000000FF00;
        v27.i64[0] = 0xFF000000FFLL;
        v27.i64[1] = 0xFF000000FFLL;
        v28.i64[0] = 0x1000100010001;
        v28.i64[1] = 0x1000100010001;
        do
        {
          int v29 = v9;
          uint64_t v30 = (uint32x4_t *)v21;
          long long v31 = (__int32 *)v18;
          unsigned int v32 = v9;
          if (v9 >= 4)
          {
            do
            {
              v33.i32[0] = v31[1];
              v33.i32[1] = v31[3];
              v33.i32[2] = v31[5];
              v33.i32[3] = v31[7];
              unsigned long long v34 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)v33, 0x10uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
              int v35 = vaddvq_s32((int32x4_t)v34);
              if (v35)
              {
                v36.i32[0] = *v31;
                v36.i32[1] = v31[2];
                v36.i32[2] = v31[4];
                v36.i32[3] = v31[6];
                int32x4_t v37 = (int32x4_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vshlq_n_s32(v33, 8uLL), v26), vorrq_s8((int8x16_t)vshlq_n_s32(v36, 0x18uLL), vandq_s8((int8x16_t)v36, v25))), (int8x16_t)v34);
                if (v35 != 1020)
                {
                  int32x4_t v38 = (int32x4_t)veorq_s8((int8x16_t)v34, v27);
                  v39.i16[0] = v30->u8[0];
                  v39.i16[1] = BYTE2(v30->u32[0]);
                  v39.i16[2] = BYTE4(v30->i64[0]);
                  v39.i16[3] = BYTE6(v30->i64[0]);
                  v39.i16[4] = v30->i64[1];
                  v39.i16[5] = BYTE2(v30->i64[1]);
                  v39.i16[6] = BYTE12(*(unsigned long long *)v30);
                  v39.i16[7] = BYTE14(*(unsigned long long *)v30);
                  int32x4_t v40 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v30, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v38);
                  int32x4_t v41 = vmulq_s32(v39, v38);
                  int32x4_t v37 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v41, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v41, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v37, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v40, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)uint64_t v30 = vorrq_s8((int8x16_t)v37, v24);
              }
              int v29 = v32 - 4;
              v31 += 8;
              ++v30;
              BOOL v42 = v32 > 7;
              v32 -= 4;
            }
            while (v42);
          }
          if (v29 >= 1)
          {
            int v43 = v29 + 1;
            do
            {
              __int32 v44 = v31[1];
              if (BYTE2(v44))
              {
                int v45 = *v31 & 0xFF0000 | (*v31 << 24) | (v31[1] << 8) | BYTE2(v31[1]);
                if (BYTE2(v44) != 255) {
                  v45 += ((((v30->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                }
                          + 65537
                          + ((((v30->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFFu)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v30->i32[0] = v45 | v23;
              }
              uint64_t v30 = (uint32x4_t *)((char *)v30 + 4);
              --v43;
              v31 += 2;
            }
            while (v43 > 1);
          }
          v18 += v22;
          v21 += v63;
          BOOL v42 = v10-- <= 1;
        }
        while (!v42);
      }
    }
    else
    {
      BOOL v46 = 0;
      if (v20) {
        BOOL v46 = *(void *)(a1 + 96) != 0;
      }
      if (v9 < 0) {
        _CGHandleAssert("CGSConvertBGRA16toARGB8888", 454, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v9);
      }
      if (v10 < 0) {
        _CGHandleAssert("CGSConvertBGRA16toARGB8888", 454, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v10);
      }
      uint64_t v47 = v10 - 1;
      if (v63 < 0)
      {
        v18 += (int)v47 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        int v48 = -v63;
        v21 += v47 * v63;
      }
      else
      {
        int v48 = v63;
      }
      unint64_t v49 = v18 + (int)((v22 * v47) & ((int)v22 >> 31));
      float v50 = v21;
      if (v49 <= (unint64_t)&v21[v10 * (uint64_t)v48])
      {
        int v51 = (int)v22 >= 0 ? v22 : -(int)v22;
        float v50 = v21;
        if (v49 + v10 * (uint64_t)v51 >= (unint64_t)v21)
        {
          int v52 = v48;
          uint64_t v53 = (char *)malloc_type_malloc(v10 * (uint64_t)v48, 0xE59009BCuLL);
          int v48 = v52;
          float v50 = v53;
        }
      }
      if (v10 >= 1)
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (v9 >= 1)
          {
            float v55 = &v50[i * v48];
            int v56 = v9;
            float v57 = (char *)(v18 + i * (int)v22);
            do
            {
              char v58 = *v57;
              char v59 = v57[2];
              char v60 = v57[4];
              char v61 = v57[6];
              if (!v46) {
                char v61 = -1;
              }
              char *v55 = v61;
              v55[1] = v60;
              v55[2] = v59;
              v55[3] = v58;
              v57 += 8;
              v55 += 4;
              --v56;
            }
            while (v56);
          }
        }
      }
      int v8 = a5;
      if (v50 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v50, v21, v48, v48);
        free(v50);
      }
    }
    int v14 = v68;
    if (!v68) {
      break;
    }
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v71 + 1, &v71, &v70, &v69))
    {
      free(v14);
      return;
    }
    int v16 = v71;
    int v15 = HIDWORD(v71);
    int v10 = v69;
    int v9 = v70;
  }
}

void rgba32_mark_image_rgba64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v65 = a2;
  int v64 = *(_DWORD *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  int v70 = v10;
  int v71 = v9;
  int v11 = *(int **)(a1 + 136);
  if (v11)
  {
    int v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v72) = *(_DWORD *)(a1 + 108);
    HIDWORD(v72) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v72, v9, v10);
    int v14 = v13;
    if (v13) {
      goto LABEL_50;
    }
  }
  int v15 = 0;
  int v16 = 0;
  int v14 = 0;
  uint64_t v72 = 0;
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 76);
    uint64_t v18 = *(void *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    uint64_t v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    uint64_t v20 = *(void *)(a1 + 48);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + v19 * v64 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    uint64_t v22 = v17 * (uint64_t)v8;
    int v69 = v14;
    if (v65 == 2)
    {
      if (v20) {
        unsigned int v23 = 0;
      }
      else {
        unsigned int v23 = 255;
      }
      if (v10 >= 1)
      {
        int8x16_t v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FF0000;
        v25.i64[1] = 0xFF000000FF0000;
        v26.i64[0] = 0xFF000000FF00;
        v26.i64[1] = 0xFF000000FF00;
        v27.i64[0] = 0xFF000000FFLL;
        v27.i64[1] = 0xFF000000FFLL;
        v28.i64[0] = 0x1000100010001;
        v28.i64[1] = 0x1000100010001;
        do
        {
          int v29 = v9;
          uint64_t v30 = (uint32x4_t *)v21;
          long long v31 = (__int32 *)v18;
          unsigned int v32 = v9;
          if (v9 >= 4)
          {
            do
            {
              v33.i32[0] = v31[1];
              v33.i32[1] = v31[3];
              v33.i32[2] = v31[5];
              v33.i32[3] = v31[7];
              int32x4_t v34 = (int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x18uLL);
              int v35 = vaddvq_s32(v34);
              if (v35)
              {
                v36.i32[0] = *v31;
                v36.i32[1] = v31[2];
                v36.i32[2] = v31[4];
                v36.i32[3] = v31[6];
                int32x4_t v37 = (int32x4_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v36, 0x10uLL) & __PAIR128__(0xFF00FFFFFF00FFFFLL, 0xFF00FFFFFF00FFFFLL)), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v36, 8uLL), v25)), vorrq_s8(vandq_s8(v33, v26), (int8x16_t)v34));
                if (v35 != 1020)
                {
                  int32x4_t v38 = (int32x4_t)veorq_s8((int8x16_t)v34, v27);
                  v39.i16[0] = v30->u8[0];
                  v39.i16[1] = BYTE2(v30->u32[0]);
                  v39.i16[2] = BYTE4(v30->i64[0]);
                  v39.i16[3] = BYTE6(v30->i64[0]);
                  v39.i16[4] = v30->i64[1];
                  v39.i16[5] = BYTE2(v30->i64[1]);
                  v39.i16[6] = BYTE12(*(unsigned long long *)v30);
                  v39.i16[7] = BYTE14(*(unsigned long long *)v30);
                  int32x4_t v40 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v30, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v38);
                  int32x4_t v41 = vmulq_s32(v39, v38);
                  int32x4_t v37 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v41, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v41, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v37, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v40, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)uint64_t v30 = vorrq_s8((int8x16_t)v37, v24);
              }
              int v29 = v32 - 4;
              v31 += 8;
              ++v30;
              BOOL v42 = v32 > 7;
              v32 -= 4;
            }
            while (v42);
          }
          if (v29 >= 1)
          {
            int v43 = v29 + 1;
            do
            {
              unsigned int v44 = HIBYTE(v31[1]);
              if (v44)
              {
                unsigned int v45 = (*v31 << 16) & 0xFF000000 | (*v31 >> 8) & 0xFFFF0000 | v31[1] & 0xFF00 | HIBYTE(v31[1]);
                if (v44 != 255) {
                  v45 += ((((v30->i32[0] & 0xFF00FF) * (v44 ^ 0xFF)
                }
                          + 65537
                          + ((((v30->i32[0] & 0xFF00FF) * (v44 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (v44 ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (v44 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v30->i32[0] = v45 | v23;
              }
              uint64_t v30 = (uint32x4_t *)((char *)v30 + 4);
              --v43;
              v31 += 2;
            }
            while (v43 > 1);
          }
          v18 += v22;
          v21 += v64;
          BOOL v42 = v10-- <= 1;
        }
        while (!v42);
      }
    }
    else
    {
      BOOL v46 = 0;
      if (v20) {
        BOOL v46 = *(void *)(a1 + 96) != 0;
      }
      if (v9 < 0) {
        _CGHandleAssert("CGSConvertbgra16toARGB8888", 616, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v9);
      }
      if (v10 < 0) {
        _CGHandleAssert("CGSConvertbgra16toARGB8888", 616, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v10);
      }
      uint64_t v47 = v10 - 1;
      if (v64 < 0)
      {
        v18 += (int)v47 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        int v48 = -v64;
        v21 += v47 * v64;
      }
      else
      {
        int v48 = v64;
      }
      unint64_t v49 = v18 + (int)((v22 * v47) & ((int)v22 >> 31));
      float v50 = v21;
      if (v49 <= (unint64_t)&v21[v10 * (uint64_t)v48])
      {
        int v51 = (int)v22 >= 0 ? v22 : -(int)v22;
        float v50 = v21;
        if (v49 + v10 * (uint64_t)v51 >= (unint64_t)v21)
        {
          int v52 = v48;
          uint64_t v53 = (char *)malloc_type_malloc(v10 * (uint64_t)v48, 0x3B8016C8uLL);
          int v48 = v52;
          float v50 = v53;
        }
      }
      if (v10 >= 1)
      {
        uint64_t v54 = 0;
        float v55 = (char *)(v18 + 3);
        do
        {
          if (v9 >= 1)
          {
            int v56 = &v50[v54 * v48];
            float v57 = v55;
            int v58 = v9;
            do
            {
              char v59 = *(v57 - 2);
              char v60 = *v57;
              char v61 = v57[2];
              char v62 = v57[4];
              if (!v46) {
                char v62 = -1;
              }
              char *v56 = v62;
              v56[1] = v61;
              v56[2] = v60;
              v56[3] = v59;
              v56 += 4;
              v57 += 8;
              --v58;
            }
            while (v58);
          }
          ++v54;
          v55 += (int)v22;
        }
        while (v54 != v10);
      }
      int v8 = a5;
      if (v50 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v50, v21, v48, v48);
        free(v50);
      }
    }
    int v14 = v69;
    if (!v69) {
      break;
    }
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v72 + 1, &v72, &v71, &v70))
    {
      free(v14);
      return;
    }
    int v16 = v72;
    int v15 = HIDWORD(v72);
    int v10 = v70;
    int v9 = v71;
  }
}

unint64_t rgba32_image_mark_rgba64(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v95 = *a2;
  BOOL v7 = *(char **)(result + 32);
  if (*(void *)(result + 40)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 0xFFFFLL;
  }
  int v9 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v94 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 15);
  uint64_t v10 = *((void *)a2 + 16);
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v91 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 5) + v91 * a4;
  int v14 = &v7[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
          + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  unint64_t v100 = result;
  int v96 = a5;
  char v92 = v12;
  uint64_t v93 = v11;
  if (*(void *)(result + 176))
  {
    uint64_t v88 = ~(-1 << v12);
    uint64_t v89 = *((void *)a2 + 13);
    uint64_t v90 = *((void *)a2 + 11);
    char v87 = v12 - 4;
    int v15 = v14 - 8;
    uint64_t v16 = v8 << 48;
    uint64_t v85 = a5;
    uint64_t v86 = -v11;
    uint64_t v84 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v89 - v13) | (v13 - v90)) < 0)
      {
        int v21 = 0;
        uint64_t v101 = 0;
      }
      else
      {
        uint64_t v17 = ((v13 & (unint64_t)v88) >> v87) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v86;
        if (!v19) {
          uint64_t v20 = v11;
        }
        uint64_t v101 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v100 + 32) + (v13 >> v12) * v11;
      int v98 = a6;
      uint64_t v97 = v13;
      if (v95 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        unsigned int v23 = (uint64_t *)v84;
        uint64_t v24 = v85;
        while (1)
        {
          uint64_t v25 = *(v23 - 1);
          uint64_t v26 = *v23;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v15 >= v22 + v25) {
            int32x4_t v28 = (char *)(v22 + v25);
          }
          else {
            int32x4_t v28 = v15;
          }
          if (v28 < v7) {
            int32x4_t v28 = v7;
          }
          unint64_t v29 = *(void *)v28;
          uint64_t v30 = *v23 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            BOOL v42 = (char *)(v27 + v101);
            if ((unint64_t)v15 < v27 + v101) {
              BOOL v42 = v15;
            }
            if (v42 < v7) {
              BOOL v42 = v7;
            }
            unint64_t v43 = BLEND16_21384[v21];
            unint64_t v40 = v29 - ((v43 & v29) >> v21);
            unint64_t v41 = (v43 & *(void *)v42) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          int32x2_t result = ((v29 | v16) >> 56) | (BYTE1(v29) << 24) | (BYTE3(v29) << 16) | WORD2(v29) & 0xFF00;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          v23 += 2;
          *v9++ = result;
          if (!--v24) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = v26 >> 4;
        unsigned int v32 = (char *)(v27 + (v26 >> 4));
        if (v15 < v32) {
          unsigned int v32 = v15;
        }
        if (v32 < v7) {
          unsigned int v32 = v7;
        }
        unint64_t v33 = *(void *)v32;
        if (v21)
        {
          int32x4_t v34 = (char *)(v27 + v101);
          if (v15 >= v34) {
            int v35 = v34;
          }
          else {
            int v35 = v15;
          }
          if (v35 < v7) {
            int v35 = v7;
          }
          unint64_t v36 = *(void *)v35;
          int32x4_t v37 = &v34[v31];
          if (v15 < v37) {
            int32x4_t v37 = v15;
          }
          if (v37 < v7) {
            int32x4_t v37 = v7;
          }
          unint64_t v38 = BLEND16_21384[v21];
          unint64_t v29 = v29 - ((v38 & v29) >> v21) + ((v38 & v36) >> v21);
          unint64_t v33 = v33 - ((v38 & v33) >> v21) + ((v38 & *(void *)v37) >> v21);
        }
        uint64_t v39 = BLEND16_21384[v30];
        unint64_t v40 = v29 - ((v39 & v29) >> v30);
        unint64_t v41 = (v39 & v33) >> v30;
LABEL_42:
        unint64_t v29 = v40 + v41;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v11 = v93;
      v9 += v94;
      LOBYTE(v12) = v92;
      uint64_t v13 = v97 + v91;
      a6 = v98 - 1;
      a5 = v96;
      if (v98 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    unsigned int v44 = (uint64_t *)v84;
    uint64_t v45 = v85;
    while (1)
    {
      uint64_t v46 = *(v44 - 1);
      uint64_t v47 = *v44;
      uint64_t v48 = v22 + v46;
      if ((unint64_t)v15 >= v22 + v46) {
        unint64_t v49 = (char *)(v22 + v46);
      }
      else {
        unint64_t v49 = v15;
      }
      if (v49 < v7) {
        unint64_t v49 = v7;
      }
      unint64_t v50 = *(void *)v49;
      uint64_t v51 = *v44 & 0xF;
      if ((v47 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v63 = (char *)(v48 + v101);
        if ((unint64_t)v15 < v48 + v101) {
          int v63 = v15;
        }
        if (v63 < v7) {
          int v63 = v7;
        }
        unint64_t v64 = BLEND16_21384[v21];
        unint64_t v61 = v50 - ((v64 & v50) >> v21);
        unint64_t v62 = (v64 & *(void *)v63) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      unsigned int v65 = ((v50 | v16) >> 56) | (BYTE1(v50) << 24) | (BYTE3(v50) << 16);
      unsigned int v66 = v65 | WORD2(v50) & 0xFF00;
      if (v6 != 255)
      {
        int32x2_t result = PDM_21362(v65 | WORD2(v50) & 0xFF00, v6);
        unsigned int v66 = result;
      }
      if ((_BYTE)v66)
      {
        if (v66 == 255) {
          *int v9 = v66;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v9, v66, *v9, ~(_BYTE)v66);
        }
      }
      v44 += 2;
      ++v9;
      if (!--v45) {
        goto LABEL_85;
      }
    }
    uint64_t v52 = v47 >> 4;
    uint64_t v53 = (char *)(v48 + (v47 >> 4));
    if (v15 < v53) {
      uint64_t v53 = v15;
    }
    if (v53 < v7) {
      uint64_t v53 = v7;
    }
    unint64_t v54 = *(void *)v53;
    if (v21)
    {
      float v55 = (char *)(v48 + v101);
      if (v15 >= v55) {
        int v56 = v55;
      }
      else {
        int v56 = v15;
      }
      if (v56 < v7) {
        int v56 = v7;
      }
      unint64_t v57 = *(void *)v56;
      int v58 = &v55[v52];
      if (v15 < v58) {
        int v58 = v15;
      }
      if (v58 < v7) {
        int v58 = v7;
      }
      unint64_t v59 = BLEND16_21384[v21];
      unint64_t v50 = v50 - ((v59 & v50) >> v21) + ((v59 & v57) >> v21);
      unint64_t v54 = v54 - ((v59 & v54) >> v21) + ((v59 & *(void *)v58) >> v21);
    }
    uint64_t v60 = BLEND16_21384[v51];
    unint64_t v61 = v50 - ((v60 & v50) >> v51);
    unint64_t v62 = (v60 & v54) >> v51;
LABEL_77:
    unint64_t v50 = v61 + v62;
    goto LABEL_78;
  }
  int v102 = (uint64_t *)(v10 + 16 * a3);
  int v67 = v14 - 8;
  uint64_t v68 = v8 << 48;
  uint64_t v99 = a5;
  do
  {
    int v69 = *(char **)(v100 + 32);
    int v70 = &v69[(v13 >> v12) * v11];
    uint64_t v71 = v13;
    int v72 = a6;
    if (v95 == 1)
    {
      if (a5 >= 1)
      {
        unsigned __int16 v73 = v102;
        uint64_t v74 = v99;
        do
        {
          uint64_t v75 = *v73;
          v73 += 2;
          int v76 = &v70[v75];
          if (v67 < &v70[v75]) {
            int v76 = v67;
          }
          if (v76 < v69) {
            int v76 = v69;
          }
          int32x2_t result = ((*(void *)v76 | (unint64_t)v68) >> 56) | (BYTE1(*(void *)v76) << 24) | (BYTE3(*(void *)v76) << 16) | HIDWORD(*(void *)v76) & 0xFF00;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          *v9++ = result;
          --v74;
        }
        while (v74);
      }
    }
    else
    {
      __int16 v77 = v102;
      uint64_t v78 = v99;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v79 = *v77;
          v77 += 2;
          float v80 = &v70[v79];
          if (v67 < &v70[v79]) {
            float v80 = v67;
          }
          if ((unint64_t)v80 < *(void *)(v100 + 32)) {
            float v80 = *(char **)(v100 + 32);
          }
          uint64_t v81 = *(void *)v80;
          unsigned int v82 = ((v81 | (unint64_t)v68) >> 56) | (BYTE1(v81) << 24) | (BYTE3(v81) << 16);
          unsigned int v83 = v82 | WORD2(v81) & 0xFF00;
          if (v6 != 255)
          {
            int32x2_t result = PDM_21362(v82 | WORD2(v81) & 0xFF00, v6);
            unsigned int v83 = result;
          }
          if ((_BYTE)v83)
          {
            if (v83 == 255) {
              *int v9 = v83;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v9, v83, *v9, ~(_BYTE)v83);
            }
          }
          ++v9;
          --v78;
        }
        while (v78);
      }
    }
    uint64_t v11 = v93;
    v9 += v94;
    LOBYTE(v12) = v92;
    uint64_t v13 = v71 + v91;
    a6 = v72 - 1;
    a5 = v96;
  }
  while (v72 != 1);
  return result;
}

unint64_t rgba32_image_mark_RGBA64(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v97 = *a2;
  BOOL v7 = *(unsigned __int16 **)(result + 32);
  if (*(void *)(result + 40)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 0xFFFFLL;
  }
  int v9 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v96 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 15);
  uint64_t v10 = *((void *)a2 + 16);
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v93 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 5) + v93 * a4;
  int v14 = (char *)v7
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v101 = result;
  char v94 = v12;
  uint64_t v95 = v11;
  if (*(void *)(result + 176))
  {
    uint64_t v89 = ~(-1 << v12);
    uint64_t v90 = *((void *)a2 + 13);
    uint64_t v91 = *((void *)a2 + 11);
    char v88 = v12 - 4;
    int v15 = (unsigned __int16 *)(v14 - 8);
    uint64_t v16 = v8 << 48;
    uint64_t v86 = a5;
    uint64_t v87 = -v11;
    uint64_t v85 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v90 - v13) | (v13 - v91)) < 0)
      {
        int v21 = 0;
        uint64_t v102 = 0;
      }
      else
      {
        uint64_t v17 = ((v13 & (unint64_t)v89) >> v88) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v87;
        if (!v19) {
          uint64_t v20 = v11;
        }
        uint64_t v102 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v101 + 32) + (v13 >> v12) * v11;
      int v99 = a6;
      uint64_t v98 = v13;
      if (v97 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        unsigned int v23 = (uint64_t *)v85;
        uint64_t v24 = v86;
        while (1)
        {
          uint64_t v25 = *(v23 - 1);
          uint64_t v26 = *v23;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v15 >= v22 + v25) {
            int32x4_t v28 = (unsigned __int16 *)(v22 + v25);
          }
          else {
            int32x4_t v28 = v15;
          }
          if (v28 < v7) {
            int32x4_t v28 = v7;
          }
          unint64_t v29 = ((unint64_t)(bswap32(v28[3]) >> 16) << 48) | ((unint64_t)(bswap32(v28[2]) >> 16) << 32) | bswap32(v28[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v28) >> 16);
          uint64_t v30 = *v23 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            BOOL v42 = (unsigned __int16 *)(v27 + v102);
            if ((unint64_t)v15 < v27 + v102) {
              BOOL v42 = v15;
            }
            if (v42 < v7) {
              BOOL v42 = v7;
            }
            uint64_t v43 = BLEND16_21384[v21];
            unint64_t v40 = v29 - ((v43 & v29) >> v21);
            unint64_t v41 = ((((unint64_t)(bswap32(v42[3]) >> 16) << 48) | ((unint64_t)(bswap32(v42[2]) >> 16) << 32) | bswap32(v42[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v42) >> 16)) & v43) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          int32x2_t result = ((v29 | v16) >> 56) | (BYTE1(v29) << 24) | (BYTE3(v29) << 16) | WORD2(v29) & 0xFF00;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          v23 += 2;
          *v9++ = result;
          if (!--v24) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = v26 >> 4;
        unsigned int v32 = (unsigned __int16 *)(v27 + (v26 >> 4));
        if (v15 < v32) {
          unsigned int v32 = v15;
        }
        if (v32 < v7) {
          unsigned int v32 = v7;
        }
        unint64_t v33 = ((unint64_t)(bswap32(v32[3]) >> 16) << 48) | ((unint64_t)(bswap32(v32[2]) >> 16) << 32) | bswap32(v32[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v32) >> 16);
        if (v21)
        {
          int32x4_t v34 = (unsigned __int16 *)(v27 + v102);
          if (v15 >= v34) {
            int v35 = v34;
          }
          else {
            int v35 = v15;
          }
          if (v35 < v7) {
            int v35 = v7;
          }
          unint64_t v36 = ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
          int32x4_t v37 = (unsigned __int16 *)((char *)v34 + v31);
          if (v15 < v37) {
            int32x4_t v37 = v15;
          }
          if (v37 < v7) {
            int32x4_t v37 = v7;
          }
          uint64_t v38 = BLEND16_21384[v21];
          unint64_t v29 = v29 - ((v38 & v29) >> v21) + ((v36 & v38) >> v21);
          unint64_t v33 = v33
              - ((v38 & v33) >> v21)
              + (((((unint64_t)(bswap32(v37[3]) >> 16) << 48) | ((unint64_t)(bswap32(v37[2]) >> 16) << 32) | bswap32(v37[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v37) >> 16)) & v38) >> v21);
        }
        uint64_t v39 = BLEND16_21384[v30];
        unint64_t v40 = v29 - ((v39 & v29) >> v30);
        unint64_t v41 = (v39 & v33) >> v30;
LABEL_42:
        unint64_t v29 = v40 + v41;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v11 = v95;
      v9 += v96;
      LOBYTE(v12) = v94;
      uint64_t v13 = v98 + v93;
      a6 = v99 - 1;
      if (v99 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    uint64_t v45 = (uint64_t *)v85;
    uint64_t v44 = v86;
    while (1)
    {
      uint64_t v46 = *(v45 - 1);
      uint64_t v47 = *v45;
      uint64_t v48 = v22 + v46;
      if ((unint64_t)v15 >= v22 + v46) {
        unint64_t v49 = (unsigned __int16 *)(v22 + v46);
      }
      else {
        unint64_t v49 = v15;
      }
      if (v49 < v7) {
        unint64_t v49 = v7;
      }
      unint64_t v50 = ((unint64_t)(bswap32(v49[3]) >> 16) << 48) | ((unint64_t)(bswap32(v49[2]) >> 16) << 32) | bswap32(v49[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v49) >> 16);
      uint64_t v51 = *v45 & 0xF;
      if ((v47 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v63 = (unsigned __int16 *)(v48 + v102);
        if ((unint64_t)v15 < v48 + v102) {
          int v63 = v15;
        }
        if (v63 < v7) {
          int v63 = v7;
        }
        uint64_t v64 = BLEND16_21384[v21];
        unint64_t v61 = v50 - ((v64 & v50) >> v21);
        unint64_t v62 = ((((unint64_t)(bswap32(v63[3]) >> 16) << 48) | ((unint64_t)(bswap32(v63[2]) >> 16) << 32) | bswap32(v63[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v63) >> 16)) & v64) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      unsigned int v65 = ((v50 | v16) >> 56) | (BYTE1(v50) << 24) | (BYTE3(v50) << 16);
      unsigned int v66 = v65 | WORD2(v50) & 0xFF00;
      if (v6 != 255)
      {
        int32x2_t result = PDM_21362(v65 | WORD2(v50) & 0xFF00, v6);
        unsigned int v66 = result;
      }
      if ((_BYTE)v66)
      {
        if (v66 == 255) {
          *int v9 = v66;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v9, v66, *v9, ~(_BYTE)v66);
        }
      }
      v45 += 2;
      ++v9;
      if (!--v44) {
        goto LABEL_85;
      }
    }
    uint64_t v52 = v47 >> 4;
    uint64_t v53 = (unsigned __int16 *)(v48 + (v47 >> 4));
    if (v15 < v53) {
      uint64_t v53 = v15;
    }
    if (v53 < v7) {
      uint64_t v53 = v7;
    }
    unint64_t v54 = ((unint64_t)(bswap32(v53[3]) >> 16) << 48) | ((unint64_t)(bswap32(v53[2]) >> 16) << 32) | bswap32(v53[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v53) >> 16);
    if (v21)
    {
      float v55 = (unsigned __int16 *)(v48 + v102);
      if (v15 >= v55) {
        int v56 = v55;
      }
      else {
        int v56 = v15;
      }
      if (v56 < v7) {
        int v56 = v7;
      }
      unint64_t v57 = ((unint64_t)(bswap32(v56[3]) >> 16) << 48) | ((unint64_t)(bswap32(v56[2]) >> 16) << 32) | bswap32(v56[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v56) >> 16);
      int v58 = (unsigned __int16 *)((char *)v55 + v52);
      if (v15 < v58) {
        int v58 = v15;
      }
      if (v58 < v7) {
        int v58 = v7;
      }
      uint64_t v59 = BLEND16_21384[v21];
      unint64_t v50 = v50 - ((v59 & v50) >> v21) + ((v57 & v59) >> v21);
      unint64_t v54 = v54
          - ((v59 & v54) >> v21)
          + (((((unint64_t)(bswap32(v58[3]) >> 16) << 48) | ((unint64_t)(bswap32(v58[2]) >> 16) << 32) | bswap32(v58[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v58) >> 16)) & v59) >> v21);
    }
    uint64_t v60 = BLEND16_21384[v51];
    unint64_t v61 = v50 - ((v60 & v50) >> v51);
    unint64_t v62 = (v60 & v54) >> v51;
LABEL_77:
    unint64_t v50 = v61 + v62;
    goto LABEL_78;
  }
  unsigned __int16 v103 = (uint64_t *)(v10 + 16 * a3);
  int v67 = v14 - 8;
  uint64_t v100 = a5;
  do
  {
    int v68 = a6;
    uint64_t v69 = v13;
    int v70 = *(char **)(v101 + 32);
    uint64_t v71 = &v70[(v13 >> v12) * v11];
    if (v97 == 1)
    {
      if (a5 >= 1)
      {
        int v72 = v103;
        uint64_t v73 = v100;
        do
        {
          uint64_t v74 = *v72;
          v72 += 2;
          uint64_t v75 = &v71[v74];
          if (v67 < &v71[v74]) {
            uint64_t v75 = v67;
          }
          if (v75 < v70) {
            uint64_t v75 = v70;
          }
          HIDWORD(v76) = *(unsigned __int16 *)v75;
          LODWORD(v76) = v8 | (*((_WORD *)v75 + 3) << 8);
          int32x2_t result = (v76 >> 8) | (v75[2] << 16) | (*((_WORD *)v75 + 2) << 8);
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          *v9++ = result;
          --v73;
        }
        while (v73);
      }
    }
    else
    {
      __int16 v77 = v103;
      uint64_t v78 = v100;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v79 = *v77;
          v77 += 2;
          float v80 = &v71[v79];
          if (v67 < &v71[v79]) {
            float v80 = v67;
          }
          if ((unint64_t)v80 < *(void *)(v101 + 32)) {
            float v80 = *(char **)(v101 + 32);
          }
          unsigned __int16 v81 = *((_WORD *)v80 + 2);
          HIDWORD(v82) = *(unsigned __int16 *)v80;
          LODWORD(v82) = v8 | (*((_WORD *)v80 + 3) << 8);
          int v83 = (v82 >> 8) | (v80[2] << 16);
          unsigned int v84 = v83 | (v81 << 8);
          if (v6 != 255)
          {
            int32x2_t result = PDM_21362(v83 | (v81 << 8), v6);
            unsigned int v84 = result;
          }
          if ((_BYTE)v84)
          {
            if (v84 == 255) {
              *int v9 = v84;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v9, v84, *v9, ~(_BYTE)v84);
            }
          }
          ++v9;
          --v78;
        }
        while (v78);
      }
    }
    uint64_t v11 = v95;
    v9 += v96;
    LOBYTE(v12) = v94;
    uint64_t v13 = v69 + v93;
    a6 = v68 - 1;
  }
  while (v68 != 1);
  return result;
}

unint64_t rgba32_image_mark_rgb48(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7 = *((unsigned __int8 *)a2 + 8);
  int v89 = *a2;
  uint64_t v8 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 15);
  uint64_t v9 = *((void *)a2 + 16);
  uint64_t v11 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v12 = *((void *)a2 + 5) + v85 * a4;
  uint64_t v13 = *(unsigned __int16 **)(result + 32);
  int v14 = (char *)v13
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v94 = result;
  char v86 = v11;
  uint64_t v87 = v10;
  if (*(void *)(result + 176))
  {
    uint64_t v83 = *((void *)a2 + 11);
    uint64_t v81 = ~(-1 << v11);
    uint64_t v82 = *((void *)a2 + 13);
    char v80 = v11 - 4;
    int v15 = (unsigned __int16 *)(v14 - 6);
    uint64_t v78 = a5;
    uint64_t v79 = -v10;
    uint64_t v77 = v9 + 16 * a3 + 8;
    while (1)
    {
      int v92 = a6;
      if (((v82 - v12) | (v12 - v83)) < 0)
      {
        int v18 = 0;
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v16 = ((v12 & (unint64_t)v81) >> v80) & 0xF;
        uint64_t v17 = (unint64_t)(v16 - 7) >= 9 ? v79 : v10;
        int v18 = weights_21383[v16] & 0xF;
      }
      uint64_t v19 = *(void *)(v94 + 32) + (v12 >> v11) * v10;
      uint64_t v90 = v12;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v20 = (uint64_t *)v77;
        uint64_t v21 = v78;
        while (1)
        {
          uint64_t v22 = *(v20 - 1);
          uint64_t v23 = *v20;
          uint64_t v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22) {
            uint64_t v25 = (unsigned __int16 *)(v19 + v22);
          }
          else {
            uint64_t v25 = v15;
          }
          if (v25 < v13) {
            uint64_t v25 = v13;
          }
          unint64_t v26 = *v25 | ((unint64_t)*(unsigned int *)(v25 + 1) << 16);
          uint64_t v27 = *v20 & 0xF;
          if ((v23 & 0xF) != 0) {
            break;
          }
          if (v18)
          {
            uint64_t v39 = (unsigned __int16 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17) {
              uint64_t v39 = v15;
            }
            if (v39 < v13) {
              uint64_t v39 = v13;
            }
            uint64_t v40 = BLEND16_21384[v18];
            unint64_t v37 = v26 - ((v40 & v26) >> v18);
            unint64_t v38 = ((*v39 | ((unint64_t)*(unsigned int *)(v39 + 1) << 16)) & v40) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          int32x2_t result = (v26 >> 8) & 0xFF0000 | (BYTE1(v26) << 24) | WORD2(v26) & 0xFF00 | 0xFF;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          v20 += 2;
          *v8++ = result;
          if (!--v21) {
            goto LABEL_83;
          }
        }
        uint64_t v28 = v23 >> 4;
        unint64_t v29 = (unsigned __int16 *)(v24 + (v23 >> 4));
        if (v15 < v29) {
          unint64_t v29 = v15;
        }
        if (v29 < v13) {
          unint64_t v29 = v13;
        }
        unint64_t v30 = *v29 | ((unint64_t)*(unsigned int *)(v29 + 1) << 16);
        if (v18)
        {
          uint64_t v31 = (unsigned __int16 *)(v24 + v17);
          if (v15 >= v31) {
            unsigned int v32 = v31;
          }
          else {
            unsigned int v32 = v15;
          }
          if (v32 < v13) {
            unsigned int v32 = v13;
          }
          unint64_t v33 = *v32 | ((unint64_t)*(unsigned int *)(v32 + 1) << 16);
          int32x4_t v34 = (unsigned __int16 *)((char *)v31 + v28);
          if (v15 < v34) {
            int32x4_t v34 = v15;
          }
          if (v34 < v13) {
            int32x4_t v34 = v13;
          }
          uint64_t v35 = BLEND16_21384[v18];
          unint64_t v26 = v26 - ((v35 & v26) >> v18) + ((v33 & v35) >> v18);
          unint64_t v30 = v30
              - ((v35 & v30) >> v18)
              + (((*v34 | ((unint64_t)*(unsigned int *)(v34 + 1) << 16)) & v35) >> v18);
        }
        uint64_t v36 = BLEND16_21384[v27];
        unint64_t v37 = v26 - ((v36 & v26) >> v27);
        unint64_t v38 = (v36 & v30) >> v27;
LABEL_40:
        unint64_t v26 = v37 + v38;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v10 = v87;
      v8 += v88;
      LOBYTE(v11) = v86;
      uint64_t v12 = v90 + v85;
      --a6;
      if (v92 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    BOOL v42 = (uint64_t *)v77;
    uint64_t v41 = v78;
    while (1)
    {
      uint64_t v43 = *(v42 - 1);
      uint64_t v44 = *v42;
      uint64_t v45 = v19 + v43;
      if ((unint64_t)v15 >= v19 + v43) {
        uint64_t v46 = (unsigned __int16 *)(v19 + v43);
      }
      else {
        uint64_t v46 = v15;
      }
      if (v46 < v13) {
        uint64_t v46 = v13;
      }
      unint64_t v47 = *v46 | ((unint64_t)*(unsigned int *)(v46 + 1) << 16);
      uint64_t v48 = *v42 & 0xF;
      if ((v44 & 0xF) != 0) {
        break;
      }
      if (v18)
      {
        uint64_t v60 = (unsigned __int16 *)(v45 + v17);
        if ((unint64_t)v15 < v45 + v17) {
          uint64_t v60 = v15;
        }
        if (v60 < v13) {
          uint64_t v60 = v13;
        }
        uint64_t v61 = BLEND16_21384[v18];
        unint64_t v58 = v47 - ((v61 & v47) >> v18);
        unint64_t v59 = ((*v60 | ((unint64_t)*(unsigned int *)(v60 + 1) << 16)) & v61) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      unsigned int v62 = (v47 >> 8) & 0xFF0000 | (BYTE1(v47) << 24) | WORD2(v47) & 0xFF00;
      unsigned int v63 = v62 | 0xFF;
      if (v7 != 255)
      {
        int32x2_t result = PDM_21362(v62 | 0xFF, v7);
        unsigned int v63 = result;
      }
      if ((_BYTE)v63)
      {
        if (v63 == 255) {
          *uint64_t v8 = v63;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v8, v63, *v8, ~(_BYTE)v63);
        }
      }
      v42 += 2;
      ++v8;
      if (!--v41) {
        goto LABEL_83;
      }
    }
    uint64_t v49 = v44 >> 4;
    unint64_t v50 = (unsigned __int16 *)(v45 + (v44 >> 4));
    if (v15 < v50) {
      unint64_t v50 = v15;
    }
    if (v50 < v13) {
      unint64_t v50 = v13;
    }
    unint64_t v51 = *v50 | ((unint64_t)*(unsigned int *)(v50 + 1) << 16);
    if (v18)
    {
      uint64_t v52 = (unsigned __int16 *)(v45 + v17);
      if (v15 >= v52) {
        uint64_t v53 = v52;
      }
      else {
        uint64_t v53 = v15;
      }
      if (v53 < v13) {
        uint64_t v53 = v13;
      }
      unint64_t v54 = *v53 | ((unint64_t)*(unsigned int *)(v53 + 1) << 16);
      float v55 = (unsigned __int16 *)((char *)v52 + v49);
      if (v15 < v55) {
        float v55 = v15;
      }
      if (v55 < v13) {
        float v55 = v13;
      }
      uint64_t v56 = BLEND16_21384[v18];
      unint64_t v47 = v47 - ((v56 & v47) >> v18) + ((v54 & v56) >> v18);
      unint64_t v51 = v51 - ((v56 & v51) >> v18) + (((*v55 | ((unint64_t)*(unsigned int *)(v55 + 1) << 16)) & v56) >> v18);
    }
    uint64_t v57 = BLEND16_21384[v48];
    unint64_t v58 = v47 - ((v57 & v47) >> v48);
    unint64_t v59 = (v57 & v51) >> v48;
LABEL_75:
    unint64_t v47 = v58 + v59;
    goto LABEL_76;
  }
  uint64_t v93 = (uint64_t *)(v9 + 16 * a3);
  uint64_t v64 = v14 - 6;
  uint64_t v91 = a5;
  do
  {
    unsigned int v65 = *(char **)(v94 + 32);
    unsigned int v66 = &v65[(v12 >> v11) * v10];
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        int v67 = v93;
        uint64_t v68 = v91;
        do
        {
          uint64_t v69 = *v67;
          v67 += 2;
          int v70 = &v66[v69];
          if (v64 < &v66[v69]) {
            int v70 = v64;
          }
          if (v70 < v65) {
            int v70 = v65;
          }
          int32x2_t result = (*(unsigned __int16 *)v70 << 16) & 0xFF000000 | (HIBYTE(*((_WORD *)v70 + 1)) << 16) | *((unsigned __int16 *)v70 + 2) | 0xFF;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          *v8++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      uint64_t v71 = v93;
      uint64_t v72 = v91;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v73 = *v71;
          v71 += 2;
          uint64_t v74 = &v66[v73];
          if (v64 < &v66[v73]) {
            uint64_t v74 = v64;
          }
          if ((unint64_t)v74 < *(void *)(v94 + 32)) {
            uint64_t v74 = *(char **)(v94 + 32);
          }
          unsigned int v75 = (*(unsigned __int16 *)v74 << 16) & 0xFF000000 | (HIBYTE(*((_WORD *)v74 + 1)) << 16) | *((unsigned __int16 *)v74 + 2);
          unsigned int v76 = v75 | 0xFF;
          if (v7 != 255)
          {
            int32x2_t result = PDM_21362(v75 | 0xFF, v7);
            unsigned int v76 = result;
          }
          if ((_BYTE)v76)
          {
            if (v76 == 255) {
              *uint64_t v8 = v76;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v8, v76, *v8, ~(_BYTE)v76);
            }
          }
          ++v8;
          --v72;
        }
        while (v72);
      }
    }
    uint64_t v10 = v87;
    v8 += v88;
    LOBYTE(v11) = v86;
    v12 += v85;
    --a6;
  }
  while (a6);
  return result;
}

unint64_t rgba32_image_mark_RGB48(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7 = *((unsigned __int8 *)a2 + 8);
  int v91 = *a2;
  uint64_t v8 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v90 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 15);
  uint64_t v9 = *((void *)a2 + 16);
  uint64_t v11 = *((void *)a2 + 7);
  uint64_t v87 = *((void *)a2 + 9);
  uint64_t v12 = *((void *)a2 + 5) + v87 * a4;
  uint64_t v13 = *(unsigned __int16 **)(result + 32);
  int v14 = (char *)v13
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v96 = result;
  char v88 = v11;
  uint64_t v89 = v10;
  if (*(void *)(result + 176))
  {
    uint64_t v85 = *((void *)a2 + 11);
    uint64_t v83 = ~(-1 << v11);
    uint64_t v84 = *((void *)a2 + 13);
    char v82 = v11 - 4;
    int v15 = (unsigned __int16 *)(v14 - 6);
    uint64_t v80 = a5;
    uint64_t v81 = -v10;
    uint64_t v79 = v9 + 16 * a3 + 8;
    while (1)
    {
      int v94 = a6;
      if (((v84 - v12) | (v12 - v85)) < 0)
      {
        int v18 = 0;
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v16 = ((v12 & (unint64_t)v83) >> v82) & 0xF;
        uint64_t v17 = (unint64_t)(v16 - 7) >= 9 ? v81 : v10;
        int v18 = weights_21383[v16] & 0xF;
      }
      uint64_t v19 = *(void *)(v96 + 32) + (v12 >> v11) * v10;
      uint64_t v92 = v12;
      if (v91 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v20 = (uint64_t *)v79;
        uint64_t v21 = v80;
        while (1)
        {
          uint64_t v22 = *(v20 - 1);
          uint64_t v23 = *v20;
          uint64_t v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22) {
            uint64_t v25 = (unsigned __int16 *)(v19 + v22);
          }
          else {
            uint64_t v25 = v15;
          }
          if (v25 < v13) {
            uint64_t v25 = v13;
          }
          unint64_t v26 = bswap32(v25[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v25[2]) >> 16) << 32) | (bswap32(*v25) >> 16);
          uint64_t v27 = *v20 & 0xF;
          if ((v23 & 0xF) != 0) {
            break;
          }
          if (v18)
          {
            uint64_t v39 = (unsigned __int16 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17) {
              uint64_t v39 = v15;
            }
            if (v39 < v13) {
              uint64_t v39 = v13;
            }
            uint64_t v40 = BLEND16_21384[v18];
            unint64_t v37 = v26 - ((v40 & v26) >> v18);
            unint64_t v38 = ((bswap32(v39[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | (bswap32(*v39) >> 16)) & v40) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          int32x2_t result = (v26 >> 8) & 0xFF0000 | (BYTE1(v26) << 24) | WORD2(v26) & 0xFF00 | 0xFF;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          v20 += 2;
          *v8++ = result;
          if (!--v21) {
            goto LABEL_83;
          }
        }
        uint64_t v28 = v23 >> 4;
        unint64_t v29 = (unsigned __int16 *)(v24 + (v23 >> 4));
        if (v15 < v29) {
          unint64_t v29 = v15;
        }
        if (v29 < v13) {
          unint64_t v29 = v13;
        }
        unint64_t v30 = bswap32(v29[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v29[2]) >> 16) << 32) | (bswap32(*v29) >> 16);
        if (v18)
        {
          uint64_t v31 = (unsigned __int16 *)(v24 + v17);
          if (v15 >= v31) {
            unsigned int v32 = v31;
          }
          else {
            unsigned int v32 = v15;
          }
          if (v32 < v13) {
            unsigned int v32 = v13;
          }
          unint64_t v33 = bswap32(v32[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v32[2]) >> 16) << 32) | (bswap32(*v32) >> 16);
          int32x4_t v34 = (unsigned __int16 *)((char *)v31 + v28);
          if (v15 < v34) {
            int32x4_t v34 = v15;
          }
          if (v34 < v13) {
            int32x4_t v34 = v13;
          }
          uint64_t v35 = BLEND16_21384[v18];
          unint64_t v26 = v26 - ((v35 & v26) >> v18) + ((v33 & v35) >> v18);
          unint64_t v30 = v30
              - ((v35 & v30) >> v18)
              + (((bswap32(v34[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v34[2]) >> 16) << 32) | (bswap32(*v34) >> 16)) & v35) >> v18);
        }
        uint64_t v36 = BLEND16_21384[v27];
        unint64_t v37 = v26 - ((v36 & v26) >> v27);
        unint64_t v38 = (v36 & v30) >> v27;
LABEL_40:
        unint64_t v26 = v37 + v38;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v10 = v89;
      v8 += v90;
      LOBYTE(v11) = v88;
      uint64_t v12 = v92 + v87;
      --a6;
      if (v94 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    BOOL v42 = (uint64_t *)v79;
    uint64_t v41 = v80;
    while (1)
    {
      uint64_t v43 = *(v42 - 1);
      uint64_t v44 = *v42;
      uint64_t v45 = v19 + v43;
      if ((unint64_t)v15 >= v19 + v43) {
        uint64_t v46 = (unsigned __int16 *)(v19 + v43);
      }
      else {
        uint64_t v46 = v15;
      }
      if (v46 < v13) {
        uint64_t v46 = v13;
      }
      unint64_t v47 = bswap32(v46[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | (bswap32(*v46) >> 16);
      uint64_t v48 = *v42 & 0xF;
      if ((v44 & 0xF) != 0) {
        break;
      }
      if (v18)
      {
        uint64_t v60 = (unsigned __int16 *)(v45 + v17);
        if ((unint64_t)v15 < v45 + v17) {
          uint64_t v60 = v15;
        }
        if (v60 < v13) {
          uint64_t v60 = v13;
        }
        uint64_t v61 = BLEND16_21384[v18];
        unint64_t v58 = v47 - ((v61 & v47) >> v18);
        unint64_t v59 = ((bswap32(v60[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v60[2]) >> 16) << 32) | (bswap32(*v60) >> 16)) & v61) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      unsigned int v62 = (v47 >> 8) & 0xFF0000 | (BYTE1(v47) << 24) | WORD2(v47) & 0xFF00;
      unsigned int v63 = v62 | 0xFF;
      if (v7 != 255)
      {
        int32x2_t result = PDM_21362(v62 | 0xFF, v7);
        unsigned int v63 = result;
      }
      if ((_BYTE)v63)
      {
        if (v63 == 255) {
          *uint64_t v8 = v63;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v8, v63, *v8, ~(_BYTE)v63);
        }
      }
      v42 += 2;
      ++v8;
      if (!--v41) {
        goto LABEL_83;
      }
    }
    uint64_t v49 = v44 >> 4;
    unint64_t v50 = (unsigned __int16 *)(v45 + (v44 >> 4));
    if (v15 < v50) {
      unint64_t v50 = v15;
    }
    if (v50 < v13) {
      unint64_t v50 = v13;
    }
    unint64_t v51 = bswap32(v50[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v50[2]) >> 16) << 32) | (bswap32(*v50) >> 16);
    if (v18)
    {
      uint64_t v52 = (unsigned __int16 *)(v45 + v17);
      if (v15 >= v52) {
        uint64_t v53 = v52;
      }
      else {
        uint64_t v53 = v15;
      }
      if (v53 < v13) {
        uint64_t v53 = v13;
      }
      unint64_t v54 = bswap32(v53[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v53[2]) >> 16) << 32) | (bswap32(*v53) >> 16);
      float v55 = (unsigned __int16 *)((char *)v52 + v49);
      if (v15 < v55) {
        float v55 = v15;
      }
      if (v55 < v13) {
        float v55 = v13;
      }
      uint64_t v56 = BLEND16_21384[v18];
      unint64_t v47 = v47 - ((v56 & v47) >> v18) + ((v54 & v56) >> v18);
      unint64_t v51 = v51
          - ((v56 & v51) >> v18)
          + (((bswap32(v55[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v55[2]) >> 16) << 32) | (bswap32(*v55) >> 16)) & v56) >> v18);
    }
    uint64_t v57 = BLEND16_21384[v48];
    unint64_t v58 = v47 - ((v57 & v47) >> v48);
    unint64_t v59 = (v57 & v51) >> v48;
LABEL_75:
    unint64_t v47 = v58 + v59;
    goto LABEL_76;
  }
  uint64_t v95 = (uint64_t *)(v9 + 16 * a3);
  uint64_t v64 = v14 - 6;
  uint64_t v93 = a5;
  do
  {
    unsigned int v65 = *(char **)(v96 + 32);
    unsigned int v66 = &v65[(v12 >> v11) * v10];
    if (v91 == 1)
    {
      if (a5 >= 1)
      {
        int v67 = v95;
        uint64_t v68 = v93;
        do
        {
          uint64_t v69 = *v67;
          v67 += 2;
          int v70 = &v66[v69];
          if (v64 < &v66[v69]) {
            int v70 = v64;
          }
          if (v70 < v65) {
            int v70 = v65;
          }
          int32x2_t result = (*(unsigned __int16 *)v70 << 24) | (v70[2] << 16) | (*((_WORD *)v70 + 2) << 8) | 0xFFu;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          *v8++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      uint64_t v71 = v95;
      uint64_t v72 = v93;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v73 = *v71;
          v71 += 2;
          uint64_t v74 = &v66[v73];
          if (v64 < &v66[v73]) {
            uint64_t v74 = v64;
          }
          if ((unint64_t)v74 < *(void *)(v96 + 32)) {
            uint64_t v74 = *(char **)(v96 + 32);
          }
          int v75 = *(unsigned __int16 *)v74;
          int v76 = v74[2];
          unsigned __int16 v77 = *((_WORD *)v74 + 2);
          unsigned int v78 = (v75 << 24) | (v76 << 16) | (v77 << 8) | 0xFF;
          if (v7 != 255)
          {
            int32x2_t result = PDM_21362((v75 << 24) | (v76 << 16) | (v77 << 8) | 0xFFu, v7);
            unsigned int v78 = result;
          }
          if ((_BYTE)v78)
          {
            if (v78 == 255) {
              *uint64_t v8 = v78;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v8, v78, *v8, ~(_BYTE)v78);
            }
          }
          ++v8;
          --v72;
        }
        while (v72);
      }
    }
    uint64_t v10 = v89;
    v8 += v90;
    LOBYTE(v11) = v88;
    v12 += v87;
    --a6;
  }
  while (a6);
  return result;
}

unint64_t rgba32_image_mark_w16(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v88 = *a2;
  int v7 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v87 = *((void *)a2 + 3) - a5;
  uint64_t v9 = *((void *)a2 + 15);
  uint64_t v8 = *((void *)a2 + 16);
  uint64_t v10 = *((void *)a2 + 7);
  uint64_t v84 = *((void *)a2 + 9);
  uint64_t v11 = *((void *)a2 + 5) + v84 * a4;
  uint64_t v12 = *(unsigned __int16 **)(result + 32);
  uint64_t v13 = (char *)v12
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v93 = result;
  int v89 = a5;
  char v85 = v10;
  uint64_t v86 = v9;
  if (*(void *)(result + 176))
  {
    uint64_t v83 = *((void *)a2 + 11);
    uint64_t v81 = ~(-1 << v10);
    uint64_t v82 = *((void *)a2 + 13);
    char v80 = v10 - 4;
    int v14 = (unsigned __int16 *)(v13 - 4);
    uint64_t v78 = a5;
    uint64_t v79 = -v9;
    uint64_t v77 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v82 - v11) | (v11 - v83)) < 0)
      {
        int v17 = 0;
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v15 = ((v11 & (unint64_t)v81) >> v80) & 0xF;
        uint64_t v16 = (unint64_t)(v15 - 7) >= 9 ? v79 : v9;
        int v17 = weights_21383[v15] & 0xF;
      }
      uint64_t v18 = *(void *)(v93 + 32) + (v11 >> v10) * v9;
      int v91 = a6;
      if (v88 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v19 = (uint64_t *)v77;
        uint64_t v20 = v78;
        while (1)
        {
          uint64_t v21 = *(v19 - 1);
          uint64_t v22 = *v19;
          uint64_t v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21) {
            uint64_t v24 = (unsigned __int16 *)(v18 + v21);
          }
          else {
            uint64_t v24 = v14;
          }
          if (v24 < v12) {
            uint64_t v24 = v12;
          }
          unint64_t v25 = *v24;
          uint64_t v26 = *v19 & 0xF;
          if ((v22 & 0xF) != 0) {
            break;
          }
          if (v17)
          {
            unint64_t v38 = (unsigned __int16 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16) {
              unint64_t v38 = v14;
            }
            if (v38 < v12) {
              unint64_t v38 = v12;
            }
            uint64_t v39 = BLEND16_21384[v17];
            __int16 v36 = v25 - ((v39 & v25) >> v17);
            unint64_t v37 = (unint64_t)(unsigned __int16)(v39 & *v38) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          int32x2_t result = (16843008 * BYTE1(v25)) | 0xFFu;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          v19 += 2;
          *v7++ = result;
          if (!--v20) {
            goto LABEL_83;
          }
        }
        uint64_t v27 = v22 >> 4;
        uint64_t v28 = (unsigned __int16 *)(v23 + (v22 >> 4));
        if (v14 < v28) {
          uint64_t v28 = v14;
        }
        if (v28 < v12) {
          uint64_t v28 = v12;
        }
        unint64_t v29 = *v28;
        if (v17)
        {
          unint64_t v30 = (unsigned __int16 *)(v23 + v16);
          if (v14 >= v30) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v14;
          }
          if (v31 < v12) {
            uint64_t v31 = v12;
          }
          unint64_t v32 = *v31;
          unint64_t v33 = (unsigned __int16 *)((char *)v30 + v27);
          if (v14 < v33) {
            unint64_t v33 = v14;
          }
          if (v33 < v12) {
            unint64_t v33 = v12;
          }
          uint64_t v34 = BLEND16_21384[v17];
          LODWORD(v25) = v25 - ((v34 & v25) >> v17) + ((v34 & v32) >> v17);
          LODWORD(v29) = v29 - ((v34 & v29) >> v17) + ((unint64_t)(unsigned __int16)(v34 & *v33) >> v17);
        }
        uint64_t v35 = BLEND16_21384[v26];
        __int16 v36 = v25 - ((unint64_t)(v35 & v25) >> v26);
        unint64_t v37 = (unint64_t)(v35 & v29) >> v26;
LABEL_40:
        LOWORD(v25) = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v9 = v86;
      v7 += v87;
      LOBYTE(v10) = v85;
      v11 += v84;
      a6 = v91 - 1;
      a5 = v89;
      if (v91 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    uint64_t v41 = (uint64_t *)v77;
    uint64_t v40 = v78;
    while (1)
    {
      uint64_t v42 = *(v41 - 1);
      uint64_t v43 = *v41;
      uint64_t v44 = v18 + v42;
      if ((unint64_t)v14 >= v18 + v42) {
        uint64_t v45 = (unsigned __int16 *)(v18 + v42);
      }
      else {
        uint64_t v45 = v14;
      }
      if (v45 < v12) {
        uint64_t v45 = v12;
      }
      unint64_t v46 = *v45;
      uint64_t v47 = *v41 & 0xF;
      if ((v43 & 0xF) != 0) {
        break;
      }
      if (v17)
      {
        unint64_t v59 = (unsigned __int16 *)(v44 + v16);
        if ((unint64_t)v14 < v44 + v16) {
          unint64_t v59 = v14;
        }
        if (v59 < v12) {
          unint64_t v59 = v12;
        }
        uint64_t v60 = BLEND16_21384[v17];
        __int16 v57 = v46 - ((v60 & v46) >> v17);
        unint64_t v58 = (unint64_t)(unsigned __int16)(v60 & *v59) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      int v61 = 16843008 * BYTE1(v46);
      unsigned int v62 = v61 | 0xFF;
      if (v6 != 255)
      {
        int32x2_t result = PDM_21362(v61 | 0xFFu, v6);
        unsigned int v62 = result;
      }
      if ((_BYTE)v62)
      {
        if (v62 == 255) {
          *int v7 = v62;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v7, v62, *v7, ~(_BYTE)v62);
        }
      }
      v41 += 2;
      ++v7;
      if (!--v40) {
        goto LABEL_83;
      }
    }
    uint64_t v48 = v43 >> 4;
    uint64_t v49 = (unsigned __int16 *)(v44 + (v43 >> 4));
    if (v14 < v49) {
      uint64_t v49 = v14;
    }
    if (v49 < v12) {
      uint64_t v49 = v12;
    }
    unint64_t v50 = *v49;
    if (v17)
    {
      unint64_t v51 = (unsigned __int16 *)(v44 + v16);
      if (v14 >= v51) {
        uint64_t v52 = v51;
      }
      else {
        uint64_t v52 = v14;
      }
      if (v52 < v12) {
        uint64_t v52 = v12;
      }
      unint64_t v53 = *v52;
      unint64_t v54 = (unsigned __int16 *)((char *)v51 + v48);
      if (v14 < v54) {
        unint64_t v54 = v14;
      }
      if (v54 < v12) {
        unint64_t v54 = v12;
      }
      uint64_t v55 = BLEND16_21384[v17];
      LODWORD(v46) = v46 - ((v55 & v46) >> v17) + ((v55 & v53) >> v17);
      LODWORD(v50) = v50 - ((v55 & v50) >> v17) + ((unint64_t)(unsigned __int16)(v55 & *v54) >> v17);
    }
    uint64_t v56 = BLEND16_21384[v47];
    __int16 v57 = v46 - ((unint64_t)(v56 & v46) >> v47);
    unint64_t v58 = (unint64_t)(v56 & v50) >> v47;
LABEL_75:
    LOWORD(v46) = v57 + v58;
    goto LABEL_76;
  }
  uint64_t v92 = (uint64_t *)(v8 + 16 * a3);
  unsigned int v63 = v13 - 4;
  uint64_t v90 = a5;
  do
  {
    uint64_t v64 = *(char **)(v93 + 32);
    unsigned int v65 = &v64[(v11 >> v10) * v9];
    int v66 = a6;
    if (v88 == 1)
    {
      if (a5 >= 1)
      {
        int v67 = v92;
        uint64_t v68 = v90;
        do
        {
          uint64_t v69 = *v67;
          v67 += 2;
          int v70 = &v65[v69];
          if (v63 < &v65[v69]) {
            int v70 = v63;
          }
          if (v70 < v64) {
            int v70 = v64;
          }
          int32x2_t result = (HIBYTE(*(unsigned __int16 *)v70) << 16) | (HIBYTE(*(unsigned __int16 *)v70) << 24) | *(unsigned __int16 *)v70 | 0xFFu;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          *v7++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      uint64_t v71 = v92;
      uint64_t v72 = v90;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v73 = *v71;
          v71 += 2;
          uint64_t v74 = &v65[v73];
          if (v63 < &v65[v73]) {
            uint64_t v74 = v63;
          }
          if ((unint64_t)v74 < *(void *)(v93 + 32)) {
            uint64_t v74 = *(char **)(v93 + 32);
          }
          int v75 = (HIBYTE(*(unsigned __int16 *)v74) << 16) | (HIBYTE(*(unsigned __int16 *)v74) << 24) | *(unsigned __int16 *)v74;
          unsigned int v76 = v75 | 0xFF;
          if (v6 != 255)
          {
            int32x2_t result = PDM_21362(v75 | 0xFFu, v6);
            unsigned int v76 = result;
          }
          if ((_BYTE)v76)
          {
            if (v76 == 255) {
              *int v7 = v76;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v7, v76, *v7, ~(_BYTE)v76);
            }
          }
          ++v7;
          --v72;
        }
        while (v72);
      }
    }
    uint64_t v9 = v86;
    v7 += v87;
    LOBYTE(v10) = v85;
    v11 += v84;
    a6 = v66 - 1;
    a5 = v89;
  }
  while (v66 != 1);
  return result;
}

unint64_t rgba32_image_mark_W16(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v92 = *a2;
  int v7 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v91 = *((void *)a2 + 3) - a5;
  uint64_t v9 = *((void *)a2 + 15);
  uint64_t v8 = *((void *)a2 + 16);
  uint64_t v10 = *((void *)a2 + 7);
  uint64_t v88 = *((void *)a2 + 9);
  uint64_t v11 = *((void *)a2 + 5) + v88 * a4;
  uint64_t v12 = *(unsigned __int16 **)(result + 32);
  uint64_t v13 = (char *)v12
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v97 = result;
  int v93 = a5;
  char v89 = v10;
  uint64_t v90 = v9;
  if (*(void *)(result + 176))
  {
    uint64_t v87 = *((void *)a2 + 11);
    uint64_t v85 = ~(-1 << v10);
    uint64_t v86 = *((void *)a2 + 13);
    char v84 = v10 - 4;
    int v14 = (unsigned __int16 *)(v13 - 4);
    uint64_t v82 = a5;
    uint64_t v83 = -v9;
    uint64_t v81 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v86 - v11) | (v11 - v87)) < 0)
      {
        int v17 = 0;
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v15 = ((v11 & (unint64_t)v85) >> v84) & 0xF;
        uint64_t v16 = (unint64_t)(v15 - 7) >= 9 ? v83 : v9;
        int v17 = weights_21383[v15] & 0xF;
      }
      uint64_t v18 = *(void *)(v97 + 32) + (v11 >> v10) * v9;
      int v95 = a6;
      if (v92 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v19 = (uint64_t *)v81;
        uint64_t v20 = v82;
        while (1)
        {
          uint64_t v21 = *(v19 - 1);
          uint64_t v22 = *v19;
          uint64_t v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21) {
            uint64_t v24 = (unsigned __int16 *)(v18 + v21);
          }
          else {
            uint64_t v24 = v14;
          }
          if (v24 < v12) {
            uint64_t v24 = v12;
          }
          unint64_t v25 = bswap32(*v24) >> 16;
          uint64_t v26 = *v19 & 0xF;
          if ((v22 & 0xF) != 0) {
            break;
          }
          if (v17)
          {
            unint64_t v38 = (unsigned __int16 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16) {
              unint64_t v38 = v14;
            }
            if (v38 < v12) {
              unint64_t v38 = v12;
            }
            uint64_t v39 = BLEND16_21384[v17];
            __int16 v36 = v25 - ((v39 & v25) >> v17);
            unint64_t v37 = (v39 & (unint64_t)(bswap32(*v38) >> 16)) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          int32x2_t result = (16843008 * BYTE1(v25)) | 0xFFu;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          v19 += 2;
          *v7++ = result;
          if (!--v20) {
            goto LABEL_83;
          }
        }
        uint64_t v27 = v22 >> 4;
        uint64_t v28 = (unsigned __int16 *)(v23 + (v22 >> 4));
        if (v14 < v28) {
          uint64_t v28 = v14;
        }
        if (v28 < v12) {
          uint64_t v28 = v12;
        }
        unint64_t v29 = bswap32(*v28) >> 16;
        if (v17)
        {
          unint64_t v30 = (unsigned __int16 *)(v23 + v16);
          if (v14 >= v30) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v14;
          }
          if (v31 < v12) {
            uint64_t v31 = v12;
          }
          unint64_t v32 = bswap32(*v31) >> 16;
          unint64_t v33 = (unsigned __int16 *)((char *)v30 + v27);
          if (v14 < v33) {
            unint64_t v33 = v14;
          }
          if (v33 < v12) {
            unint64_t v33 = v12;
          }
          uint64_t v34 = BLEND16_21384[v17];
          LODWORD(v25) = v25 - ((v34 & v25) >> v17) + ((v34 & v32) >> v17);
          LODWORD(v29) = v29 - ((v34 & v29) >> v17) + ((v34 & (unint64_t)(bswap32(*v33) >> 16)) >> v17);
        }
        uint64_t v35 = BLEND16_21384[v26];
        __int16 v36 = v25 - ((unint64_t)(v35 & v25) >> v26);
        unint64_t v37 = (unint64_t)(v35 & v29) >> v26;
LABEL_40:
        LOWORD(v25) = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v9 = v90;
      v7 += v91;
      LOBYTE(v10) = v89;
      v11 += v88;
      a6 = v95 - 1;
      a5 = v93;
      if (v95 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    uint64_t v41 = (uint64_t *)v81;
    uint64_t v40 = v82;
    while (1)
    {
      uint64_t v42 = *(v41 - 1);
      uint64_t v43 = *v41;
      uint64_t v44 = v18 + v42;
      if ((unint64_t)v14 >= v18 + v42) {
        uint64_t v45 = (unsigned __int16 *)(v18 + v42);
      }
      else {
        uint64_t v45 = v14;
      }
      if (v45 < v12) {
        uint64_t v45 = v12;
      }
      unint64_t v46 = bswap32(*v45) >> 16;
      uint64_t v47 = *v41 & 0xF;
      if ((v43 & 0xF) != 0) {
        break;
      }
      if (v17)
      {
        unint64_t v59 = (unsigned __int16 *)(v44 + v16);
        if ((unint64_t)v14 < v44 + v16) {
          unint64_t v59 = v14;
        }
        if (v59 < v12) {
          unint64_t v59 = v12;
        }
        uint64_t v60 = BLEND16_21384[v17];
        __int16 v57 = v46 - ((v60 & v46) >> v17);
        unint64_t v58 = (v60 & (unint64_t)(bswap32(*v59) >> 16)) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      int v61 = 16843008 * BYTE1(v46);
      unsigned int v62 = v61 | 0xFF;
      if (v6 != 255)
      {
        int32x2_t result = PDM_21362(v61 | 0xFFu, v6);
        unsigned int v62 = result;
      }
      if ((_BYTE)v62)
      {
        if (v62 == 255) {
          *int v7 = v62;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v7, v62, *v7, ~(_BYTE)v62);
        }
      }
      v41 += 2;
      ++v7;
      if (!--v40) {
        goto LABEL_83;
      }
    }
    uint64_t v48 = v43 >> 4;
    uint64_t v49 = (unsigned __int16 *)(v44 + (v43 >> 4));
    if (v14 < v49) {
      uint64_t v49 = v14;
    }
    if (v49 < v12) {
      uint64_t v49 = v12;
    }
    unint64_t v50 = bswap32(*v49) >> 16;
    if (v17)
    {
      unint64_t v51 = (unsigned __int16 *)(v44 + v16);
      if (v14 >= v51) {
        uint64_t v52 = v51;
      }
      else {
        uint64_t v52 = v14;
      }
      if (v52 < v12) {
        uint64_t v52 = v12;
      }
      unint64_t v53 = bswap32(*v52) >> 16;
      unint64_t v54 = (unsigned __int16 *)((char *)v51 + v48);
      if (v14 < v54) {
        unint64_t v54 = v14;
      }
      if (v54 < v12) {
        unint64_t v54 = v12;
      }
      uint64_t v55 = BLEND16_21384[v17];
      LODWORD(v46) = v46 - ((v55 & v46) >> v17) + ((v55 & v53) >> v17);
      LODWORD(v50) = v50 - ((v55 & v50) >> v17) + ((v55 & (unint64_t)(bswap32(*v54) >> 16)) >> v17);
    }
    uint64_t v56 = BLEND16_21384[v47];
    __int16 v57 = v46 - ((unint64_t)(v56 & v46) >> v47);
    unint64_t v58 = (unint64_t)(v56 & v50) >> v47;
LABEL_75:
    LOWORD(v46) = v57 + v58;
    goto LABEL_76;
  }
  unint64_t v96 = (uint64_t *)(v8 + 16 * a3);
  unsigned int v63 = v13 - 4;
  uint64_t v94 = a5;
  do
  {
    uint64_t v64 = *(char **)(v97 + 32);
    unsigned int v65 = &v64[(v11 >> v10) * v9];
    int v66 = a6;
    if (v92 == 1)
    {
      if (a5 >= 1)
      {
        int v67 = v96;
        uint64_t v68 = v94;
        do
        {
          uint64_t v69 = *v67;
          v67 += 2;
          int v70 = &v65[v69];
          if (v63 < &v65[v69]) {
            int v70 = v63;
          }
          if (v70 < v64) {
            int v70 = v64;
          }
          unsigned int v71 = bswap32(*(unsigned __int16 *)v70);
          HIDWORD(v72) = HIBYTE(v71);
          LODWORD(v72) = v71;
          HIDWORD(v72) = v72 >> 24;
          LODWORD(v72) = v71;
          int32x2_t result = (v72 >> 16) | 0xFF;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          *v7++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      uint64_t v73 = v96;
      uint64_t v74 = v94;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v75 = *v73;
          v73 += 2;
          unsigned int v76 = &v65[v75];
          if (v63 < &v65[v75]) {
            unsigned int v76 = v63;
          }
          if ((unint64_t)v76 < *(void *)(v97 + 32)) {
            unsigned int v76 = *(char **)(v97 + 32);
          }
          unsigned int v77 = bswap32(*(unsigned __int16 *)v76);
          HIDWORD(v78) = HIBYTE(v77);
          LODWORD(v78) = v77;
          HIDWORD(v78) = v78 >> 24;
          LODWORD(v78) = v77;
          int v79 = v78 >> 16;
          unsigned int v80 = v79 | 0xFF;
          if (v6 != 255)
          {
            int32x2_t result = PDM_21362(v79 | 0xFFu, v6);
            unsigned int v80 = result;
          }
          if ((_BYTE)v80)
          {
            if (v80 == 255) {
              *int v7 = v80;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v7, v80, *v7, ~(_BYTE)v80);
            }
          }
          ++v7;
          --v74;
        }
        while (v74);
      }
    }
    uint64_t v9 = v90;
    v7 += v91;
    LOBYTE(v10) = v89;
    v11 += v88;
    a6 = v66 - 1;
    a5 = v93;
  }
  while (v66 != 1);
  return result;
}

unint64_t rgba32_image_mark_rgb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = a2[1];
  int v89 = *a2;
  uint64_t v8 = *(unsigned int **)(result + 32);
  if (*(void *)(result + 40)) {
    int v9 = 0;
  }
  else {
    int v9 = 255;
  }
  uint64_t v10 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 15);
  uint64_t v11 = *((void *)a2 + 16);
  uint64_t v13 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v14 = *((void *)a2 + 5) + v85 * a4;
  uint64_t v15 = (char *)v8
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v95 = result;
  int v90 = a5;
  char v86 = v13;
  uint64_t v87 = v12;
  if (*(void *)(result + 176))
  {
    uint64_t v82 = ~(-1 << v13);
    uint64_t v83 = *((void *)a2 + 13);
    uint64_t v84 = *((void *)a2 + 11);
    char v81 = v13 - 4;
    uint64_t v80 = -v12;
    uint64_t v16 = (unsigned int *)(v15 - 4);
    uint64_t v78 = v11 + 16 * a3 + 8;
    uint64_t v79 = a5;
    while (1)
    {
      if (((v83 - v14) | (v14 - v84)) < 0)
      {
        int v21 = 0;
        uint64_t v96 = 0;
      }
      else
      {
        uint64_t v17 = ((v14 & (unint64_t)v82) >> v81) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v80;
        if (!v19) {
          uint64_t v20 = v12;
        }
        uint64_t v96 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v95 + 32) + (v14 >> v13) * v12;
      int v93 = a6;
      uint64_t v91 = v14;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v24 = (uint64_t *)v78;
        uint64_t v23 = v79;
        while (1)
        {
          uint64_t v25 = *(v24 - 1);
          uint64_t v26 = *v24;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25) {
            uint64_t v28 = (unsigned int *)(v22 + v25);
          }
          else {
            uint64_t v28 = v16;
          }
          if (v28 < v8) {
            uint64_t v28 = v8;
          }
          unsigned int v29 = *v28;
          char v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            uint64_t v41 = (unsigned int *)(v27 + v96);
            if ((unint64_t)v16 < v27 + v96) {
              uint64_t v41 = v16;
            }
            if (v41 < v8) {
              uint64_t v41 = v8;
            }
            int v42 = BLEND8_21385[v21];
            unsigned int v39 = v29 - ((v42 & v29) >> v21);
            unsigned int v40 = (v42 & *v41) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          int32x2_t result = __ROL4__(v29, v7) | v9;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          v24 += 2;
          *v10++ = result;
          if (!--v23) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = (unsigned int *)(v27 + (v26 >> 4));
        if (v16 < v31) {
          uint64_t v31 = v16;
        }
        if (v31 < v8) {
          uint64_t v31 = v8;
        }
        unsigned int v32 = *v31;
        if (v21)
        {
          unint64_t v33 = (unsigned int *)(v27 + v96);
          if (v16 >= v33) {
            uint64_t v34 = v33;
          }
          else {
            uint64_t v34 = v16;
          }
          if (v34 < v8) {
            uint64_t v34 = v8;
          }
          unsigned int v35 = *v34;
          __int16 v36 = (unsigned int *)((char *)v33 + (v26 >> 4));
          if (v16 < v36) {
            __int16 v36 = v16;
          }
          if (v36 < v8) {
            __int16 v36 = v8;
          }
          int v37 = BLEND8_21385[v21];
          unsigned int v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
          unsigned int v32 = v32 - ((v37 & v32) >> v21) + ((v37 & *v36) >> v21);
        }
        int v38 = BLEND8_21385[*v24 & 0xF];
        unsigned int v39 = v29 - ((v38 & v29) >> v30);
        unsigned int v40 = (v38 & v32) >> v30;
LABEL_42:
        unsigned int v29 = v39 + v40;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v12 = v87;
      v10 += v88;
      LOBYTE(v13) = v86;
      uint64_t v14 = v91 + v85;
      a6 = v93 - 1;
      a5 = v90;
      if (v93 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    uint64_t v43 = (uint64_t *)v78;
    uint64_t v44 = v79;
    while (1)
    {
      uint64_t v45 = *(v43 - 1);
      uint64_t v46 = *v43;
      uint64_t v47 = v22 + v45;
      if ((unint64_t)v16 >= v22 + v45) {
        uint64_t v48 = (unsigned int *)(v22 + v45);
      }
      else {
        uint64_t v48 = v16;
      }
      if (v48 < v8) {
        uint64_t v48 = v8;
      }
      unsigned int v49 = *v48;
      char v50 = v46 & 0xF;
      if ((v46 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v61 = (unsigned int *)(v47 + v96);
        if ((unint64_t)v16 < v47 + v96) {
          int v61 = v16;
        }
        if (v61 < v8) {
          int v61 = v8;
        }
        int v62 = BLEND8_21385[v21];
        unsigned int v59 = v49 - ((v62 & v49) >> v21);
        unsigned int v60 = (v62 & *v61) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      int v63 = __ROL4__(v49, v7);
      unsigned int v64 = v63 | v9;
      if (v6 != 255)
      {
        int32x2_t result = PDM_21362(v63 | v9, v6);
        unsigned int v64 = result;
      }
      if ((_BYTE)v64)
      {
        if (v64 == 255) {
          *uint64_t v10 = v64;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v10, v64, *v10, ~(_BYTE)v64);
        }
      }
      v43 += 2;
      ++v10;
      if (!--v44) {
        goto LABEL_85;
      }
    }
    unint64_t v51 = (unsigned int *)(v47 + (v46 >> 4));
    if (v16 < v51) {
      unint64_t v51 = v16;
    }
    if (v51 < v8) {
      unint64_t v51 = v8;
    }
    unsigned int v52 = *v51;
    if (v21)
    {
      unint64_t v53 = (unsigned int *)(v47 + v96);
      if (v16 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v16;
      }
      if (v54 < v8) {
        unint64_t v54 = v8;
      }
      unsigned int v55 = *v54;
      uint64_t v56 = (unsigned int *)((char *)v53 + (v46 >> 4));
      if (v16 < v56) {
        uint64_t v56 = v16;
      }
      if (v56 < v8) {
        uint64_t v56 = v8;
      }
      int v57 = BLEND8_21385[v21];
      unsigned int v49 = v49 - ((v57 & v49) >> v21) + ((v57 & v55) >> v21);
      unsigned int v52 = v52 - ((v57 & v52) >> v21) + ((v57 & *v56) >> v21);
    }
    int v58 = BLEND8_21385[*v43 & 0xF];
    unsigned int v59 = v49 - ((v58 & v49) >> v50);
    unsigned int v60 = (v58 & v52) >> v50;
LABEL_77:
    unsigned int v49 = v59 + v60;
    goto LABEL_78;
  }
  unsigned int v65 = v15 - 4;
  uint64_t v97 = a5;
  uint64_t v98 = (uint64_t *)(v11 + 16 * a3);
  do
  {
    int v66 = *(char **)(v95 + 32);
    int v67 = &v66[(v14 >> v13) * v12];
    int v94 = a6;
    uint64_t v92 = v14;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v68 = v97;
        uint64_t v69 = v98;
        do
        {
          uint64_t v70 = *v69;
          v69 += 2;
          unsigned int v71 = &v67[v70];
          if (v65 < &v67[v70]) {
            unsigned int v71 = v65;
          }
          if (v71 < v66) {
            unsigned int v71 = v66;
          }
          int32x2_t result = __ROL4__(*(_DWORD *)v71, v7) | v9;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          *v10++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      uint64_t v72 = v97;
      uint64_t v73 = v98;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v74 = *v73;
          v73 += 2;
          uint64_t v75 = &v67[v74];
          if (v65 < &v67[v74]) {
            uint64_t v75 = v65;
          }
          if ((unint64_t)v75 < *(void *)(v95 + 32)) {
            uint64_t v75 = *(char **)(v95 + 32);
          }
          int v76 = __ROL4__(*(_DWORD *)v75, v7);
          unsigned int v77 = v76 | v9;
          if (v6 != 255)
          {
            int32x2_t result = PDM_21362(v76 | v9, v6);
            unsigned int v77 = result;
          }
          if ((_BYTE)v77)
          {
            if (v77 == 255) {
              *uint64_t v10 = v77;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v10, v77, *v10, ~(_BYTE)v77);
            }
          }
          ++v10;
          --v72;
        }
        while (v72);
      }
    }
    uint64_t v12 = v87;
    v10 += v88;
    LOBYTE(v13) = v86;
    uint64_t v14 = v92 + v85;
    a6 = v94 - 1;
    a5 = v90;
  }
  while (v94 != 1);
  return result;
}

unint64_t rgba32_image_mark_rgba32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v89 = *a2;
  int v7 = *(unsigned int **)(result + 32);
  if (*(void *)(result + 40)) {
    int v8 = 0;
  }
  else {
    int v8 = 255;
  }
  int v9 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 15);
  uint64_t v10 = *((void *)a2 + 16);
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 5) + v85 * a4;
  uint64_t v14 = (char *)v7
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v94 = result;
  int v90 = a5;
  char v86 = v12;
  uint64_t v87 = v11;
  if (*(void *)(result + 176))
  {
    uint64_t v84 = *((void *)a2 + 11);
    uint64_t v82 = ~(-1 << v12);
    uint64_t v83 = *((void *)a2 + 13);
    char v81 = v12 - 4;
    uint64_t v15 = (unsigned int *)(v14 - 4);
    uint64_t v79 = a5;
    uint64_t v80 = -v11;
    uint64_t v78 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v83 - v13) | (v13 - v84)) < 0)
      {
        int v20 = 0;
        uint64_t v95 = 0;
      }
      else
      {
        uint64_t v16 = ((v13 & (unint64_t)v82) >> v81) & 0xF;
        char v17 = weights_21383[v16];
        BOOL v18 = (unint64_t)(v16 - 7) >= 9;
        uint64_t v19 = v80;
        if (!v18) {
          uint64_t v19 = v11;
        }
        uint64_t v95 = v19;
        int v20 = v17 & 0xF;
      }
      uint64_t v21 = *(void *)(v94 + 32) + (v13 >> v12) * v11;
      int v92 = a6;
      uint64_t v91 = v13;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v23 = (uint64_t *)v78;
        uint64_t v22 = v79;
        while (1)
        {
          uint64_t v24 = *(v23 - 1);
          uint64_t v25 = *v23;
          uint64_t v26 = v21 + v24;
          if ((unint64_t)v15 >= v21 + v24) {
            uint64_t v27 = (unsigned int *)(v21 + v24);
          }
          else {
            uint64_t v27 = v15;
          }
          if (v27 < v7) {
            uint64_t v27 = v7;
          }
          unsigned int v28 = *v27;
          char v29 = v25 & 0xF;
          if ((v25 & 0xF) != 0) {
            break;
          }
          if (v20)
          {
            unsigned int v40 = (unsigned int *)(v26 + v95);
            if ((unint64_t)v15 < v26 + v95) {
              unsigned int v40 = v15;
            }
            if (v40 < v7) {
              unsigned int v40 = v7;
            }
            int v41 = BLEND8_21385[v20];
            unsigned int v38 = v28 - ((v41 & v28) >> v20);
            unsigned int v39 = (v41 & *v40) >> v20;
            goto LABEL_42;
          }
LABEL_43:
          int32x2_t result = v28 | v8;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          v23 += 2;
          *v9++ = result;
          if (!--v22) {
            goto LABEL_85;
          }
        }
        char v30 = (unsigned int *)(v26 + (v25 >> 4));
        if (v15 < v30) {
          char v30 = v15;
        }
        if (v30 < v7) {
          char v30 = v7;
        }
        unsigned int v31 = *v30;
        if (v20)
        {
          unsigned int v32 = (unsigned int *)(v26 + v95);
          if (v15 >= v32) {
            unint64_t v33 = v32;
          }
          else {
            unint64_t v33 = v15;
          }
          if (v33 < v7) {
            unint64_t v33 = v7;
          }
          unsigned int v34 = *v33;
          unsigned int v35 = (unsigned int *)((char *)v32 + (v25 >> 4));
          if (v15 < v35) {
            unsigned int v35 = v15;
          }
          if (v35 < v7) {
            unsigned int v35 = v7;
          }
          int v36 = BLEND8_21385[v20];
          unsigned int v28 = v28 - ((v36 & v28) >> v20) + ((v36 & v34) >> v20);
          unsigned int v31 = v31 - ((v36 & v31) >> v20) + ((v36 & *v35) >> v20);
        }
        int v37 = BLEND8_21385[*v23 & 0xF];
        unsigned int v38 = v28 - ((v37 & v28) >> v29);
        unsigned int v39 = (v37 & v31) >> v29;
LABEL_42:
        unsigned int v28 = v38 + v39;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v11 = v87;
      v9 += v88;
      LOBYTE(v12) = v86;
      uint64_t v13 = v91 + v85;
      a6 = v92 - 1;
      a5 = v90;
      if (v92 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    uint64_t v43 = (uint64_t *)v78;
    uint64_t v42 = v79;
    while (1)
    {
      uint64_t v44 = *(v43 - 1);
      uint64_t v45 = *v43;
      uint64_t v46 = v21 + v44;
      if ((unint64_t)v15 >= v21 + v44) {
        uint64_t v47 = (unsigned int *)(v21 + v44);
      }
      else {
        uint64_t v47 = v15;
      }
      if (v47 < v7) {
        uint64_t v47 = v7;
      }
      unsigned int v48 = *v47;
      char v49 = v45 & 0xF;
      if ((v45 & 0xF) != 0) {
        break;
      }
      if (v20)
      {
        unsigned int v60 = (unsigned int *)(v46 + v95);
        if ((unint64_t)v15 < v46 + v95) {
          unsigned int v60 = v15;
        }
        if (v60 < v7) {
          unsigned int v60 = v7;
        }
        int v61 = BLEND8_21385[v20];
        unsigned int v58 = v48 - ((v61 & v48) >> v20);
        unsigned int v59 = (v61 & *v60) >> v20;
        goto LABEL_77;
      }
LABEL_78:
      unsigned int v62 = v48 | v8;
      if (v6 != 255)
      {
        int32x2_t result = PDM_21362(v48 | v8, v6);
        unsigned int v62 = result;
      }
      if ((_BYTE)v62)
      {
        if (v62 == 255) {
          *int v9 = v62;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v9, v62, *v9, ~(_BYTE)v62);
        }
      }
      v43 += 2;
      ++v9;
      if (!--v42) {
        goto LABEL_85;
      }
    }
    char v50 = (unsigned int *)(v46 + (v45 >> 4));
    if (v15 < v50) {
      char v50 = v15;
    }
    if (v50 < v7) {
      char v50 = v7;
    }
    unsigned int v51 = *v50;
    if (v20)
    {
      unsigned int v52 = (unsigned int *)(v46 + v95);
      if (v15 >= v52) {
        unint64_t v53 = v52;
      }
      else {
        unint64_t v53 = v15;
      }
      if (v53 < v7) {
        unint64_t v53 = v7;
      }
      unsigned int v54 = *v53;
      unsigned int v55 = (unsigned int *)((char *)v52 + (v45 >> 4));
      if (v15 < v55) {
        unsigned int v55 = v15;
      }
      if (v55 < v7) {
        unsigned int v55 = v7;
      }
      int v56 = BLEND8_21385[v20];
      unsigned int v48 = v48 - ((v56 & v48) >> v20) + ((v56 & v54) >> v20);
      unsigned int v51 = v51 - ((v56 & v51) >> v20) + ((v56 & *v55) >> v20);
    }
    int v57 = BLEND8_21385[*v43 & 0xF];
    unsigned int v58 = v48 - ((v57 & v48) >> v49);
    unsigned int v59 = (v57 & v51) >> v49;
LABEL_77:
    unsigned int v48 = v58 + v59;
    goto LABEL_78;
  }
  uint64_t v96 = (uint64_t *)(v10 + 16 * a3);
  int v63 = v14 - 4;
  uint64_t v93 = a5;
  do
  {
    unsigned int v64 = *(char **)(v94 + 32);
    unsigned int v65 = &v64[(v13 >> v12) * v11];
    uint64_t v66 = v13;
    int v67 = a6;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v68 = v96;
        uint64_t v69 = v93;
        do
        {
          uint64_t v70 = *v68;
          v68 += 2;
          unsigned int v71 = &v65[v70];
          if (v63 < &v65[v70]) {
            unsigned int v71 = v63;
          }
          if (v71 < v64) {
            unsigned int v71 = v64;
          }
          int32x2_t result = *(_DWORD *)v71 | v8;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          *v9++ = result;
          --v69;
        }
        while (v69);
      }
    }
    else
    {
      uint64_t v72 = v96;
      uint64_t v73 = v93;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v74 = *v72;
          v72 += 2;
          uint64_t v75 = &v65[v74];
          if (v63 < &v65[v74]) {
            uint64_t v75 = v63;
          }
          if ((unint64_t)v75 < *(void *)(v94 + 32)) {
            uint64_t v75 = *(char **)(v94 + 32);
          }
          int v76 = *(_DWORD *)v75;
          unsigned int v77 = v76 | v8;
          if (v6 != 255)
          {
            int32x2_t result = PDM_21362(v76 | v8, v6);
            unsigned int v77 = result;
          }
          if ((_BYTE)v77)
          {
            if (v77 == 255) {
              *int v9 = v77;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v9, v77, *v9, ~(_BYTE)v77);
            }
          }
          ++v9;
          --v73;
        }
        while (v73);
      }
    }
    uint64_t v11 = v87;
    v9 += v88;
    LOBYTE(v12) = v86;
    uint64_t v13 = v66 + v85;
    a6 = v67 - 1;
    a5 = v90;
  }
  while (v67 != 1);
  return result;
}

unint64_t rgba32_image_mark_RGB32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = a2[1];
  int v89 = *a2;
  int v8 = *(unsigned int **)(result + 32);
  if (*(void *)(result + 40)) {
    int v9 = 0;
  }
  else {
    int v9 = 255;
  }
  uint64_t v10 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 15);
  uint64_t v11 = *((void *)a2 + 16);
  uint64_t v13 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v14 = *((void *)a2 + 5) + v85 * a4;
  uint64_t v15 = (char *)v8
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v95 = result;
  int v90 = a5;
  char v86 = v13;
  uint64_t v87 = v12;
  if (*(void *)(result + 176))
  {
    uint64_t v82 = ~(-1 << v13);
    uint64_t v83 = *((void *)a2 + 13);
    uint64_t v84 = *((void *)a2 + 11);
    char v81 = v13 - 4;
    uint64_t v80 = -v12;
    uint64_t v16 = (unsigned int *)(v15 - 4);
    uint64_t v78 = v11 + 16 * a3 + 8;
    uint64_t v79 = a5;
    while (1)
    {
      if (((v83 - v14) | (v14 - v84)) < 0)
      {
        int v21 = 0;
        uint64_t v96 = 0;
      }
      else
      {
        uint64_t v17 = ((v14 & (unint64_t)v82) >> v81) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v80;
        if (!v19) {
          uint64_t v20 = v12;
        }
        uint64_t v96 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v95 + 32) + (v14 >> v13) * v12;
      int v93 = a6;
      uint64_t v91 = v14;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v24 = (uint64_t *)v78;
        uint64_t v23 = v79;
        while (1)
        {
          uint64_t v25 = *(v24 - 1);
          uint64_t v26 = *v24;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25) {
            unsigned int v28 = (unsigned int *)(v22 + v25);
          }
          else {
            unsigned int v28 = v16;
          }
          if (v28 < v8) {
            unsigned int v28 = v8;
          }
          unsigned int v29 = bswap32(*v28);
          char v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            int v41 = (unsigned int *)(v27 + v96);
            if ((unint64_t)v16 < v27 + v96) {
              int v41 = v16;
            }
            if (v41 < v8) {
              int v41 = v8;
            }
            int v42 = BLEND8_21385[v21];
            unsigned int v39 = v29 - ((v42 & v29) >> v21);
            unsigned int v40 = (bswap32(*v41) & v42) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          int32x2_t result = __ROL4__(v29, v7) | v9;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          v24 += 2;
          *v10++ = result;
          if (!--v23) {
            goto LABEL_85;
          }
        }
        unsigned int v31 = (unsigned int *)(v27 + (v26 >> 4));
        if (v16 < v31) {
          unsigned int v31 = v16;
        }
        if (v31 < v8) {
          unsigned int v31 = v8;
        }
        unsigned int v32 = bswap32(*v31);
        if (v21)
        {
          unint64_t v33 = (unsigned int *)(v27 + v96);
          if (v16 >= v33) {
            unsigned int v34 = v33;
          }
          else {
            unsigned int v34 = v16;
          }
          if (v34 < v8) {
            unsigned int v34 = v8;
          }
          unsigned int v35 = bswap32(*v34);
          int v36 = (unsigned int *)((char *)v33 + (v26 >> 4));
          if (v16 < v36) {
            int v36 = v16;
          }
          if (v36 < v8) {
            int v36 = v8;
          }
          int v37 = BLEND8_21385[v21];
          unsigned int v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
          unsigned int v32 = v32 - ((v37 & v32) >> v21) + ((bswap32(*v36) & v37) >> v21);
        }
        int v38 = BLEND8_21385[*v24 & 0xF];
        unsigned int v39 = v29 - ((v38 & v29) >> v30);
        unsigned int v40 = (v38 & v32) >> v30;
LABEL_42:
        unsigned int v29 = v39 + v40;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v12 = v87;
      v10 += v88;
      LOBYTE(v13) = v86;
      uint64_t v14 = v91 + v85;
      a6 = v93 - 1;
      a5 = v90;
      if (v93 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    uint64_t v43 = (uint64_t *)v78;
    uint64_t v44 = v79;
    while (1)
    {
      uint64_t v45 = *(v43 - 1);
      uint64_t v46 = *v43;
      uint64_t v47 = v22 + v45;
      if ((unint64_t)v16 >= v22 + v45) {
        unsigned int v48 = (unsigned int *)(v22 + v45);
      }
      else {
        unsigned int v48 = v16;
      }
      if (v48 < v8) {
        unsigned int v48 = v8;
      }
      unsigned int v49 = bswap32(*v48);
      char v50 = v46 & 0xF;
      if ((v46 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v61 = (unsigned int *)(v47 + v96);
        if ((unint64_t)v16 < v47 + v96) {
          int v61 = v16;
        }
        if (v61 < v8) {
          int v61 = v8;
        }
        int v62 = BLEND8_21385[v21];
        unsigned int v59 = v49 - ((v62 & v49) >> v21);
        unsigned int v60 = (bswap32(*v61) & v62) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      int v63 = __ROL4__(v49, v7);
      unsigned int v64 = v63 | v9;
      if (v6 != 255)
      {
        int32x2_t result = PDM_21362(v63 | v9, v6);
        unsigned int v64 = result;
      }
      if ((_BYTE)v64)
      {
        if (v64 == 255) {
          *uint64_t v10 = v64;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v10, v64, *v10, ~(_BYTE)v64);
        }
      }
      v43 += 2;
      ++v10;
      if (!--v44) {
        goto LABEL_85;
      }
    }
    unsigned int v51 = (unsigned int *)(v47 + (v46 >> 4));
    if (v16 < v51) {
      unsigned int v51 = v16;
    }
    if (v51 < v8) {
      unsigned int v51 = v8;
    }
    unsigned int v52 = bswap32(*v51);
    if (v21)
    {
      unint64_t v53 = (unsigned int *)(v47 + v96);
      if (v16 >= v53) {
        unsigned int v54 = v53;
      }
      else {
        unsigned int v54 = v16;
      }
      if (v54 < v8) {
        unsigned int v54 = v8;
      }
      unsigned int v55 = bswap32(*v54);
      int v56 = (unsigned int *)((char *)v53 + (v46 >> 4));
      if (v16 < v56) {
        int v56 = v16;
      }
      if (v56 < v8) {
        int v56 = v8;
      }
      int v57 = BLEND8_21385[v21];
      unsigned int v49 = v49 - ((v57 & v49) >> v21) + ((v57 & v55) >> v21);
      unsigned int v52 = v52 - ((v57 & v52) >> v21) + ((bswap32(*v56) & v57) >> v21);
    }
    int v58 = BLEND8_21385[*v43 & 0xF];
    unsigned int v59 = v49 - ((v58 & v49) >> v50);
    unsigned int v60 = (v58 & v52) >> v50;
LABEL_77:
    unsigned int v49 = v59 + v60;
    goto LABEL_78;
  }
  unsigned int v65 = (unsigned int *)(v15 - 4);
  uint64_t v97 = a5;
  uint64_t v98 = (uint64_t *)(v11 + 16 * a3);
  do
  {
    uint64_t v66 = *(unsigned int **)(v95 + 32);
    int v67 = (char *)v66 + (v14 >> v13) * v12;
    int v94 = a6;
    uint64_t v92 = v14;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v68 = v97;
        uint64_t v69 = v98;
        do
        {
          uint64_t v70 = *v69;
          v69 += 2;
          unsigned int v71 = (unsigned int *)&v67[v70];
          if (v65 < (unsigned int *)&v67[v70]) {
            unsigned int v71 = v65;
          }
          if (v71 < v66) {
            unsigned int v71 = v66;
          }
          int32x2_t result = __ROL4__(bswap32(*v71), v7) | v9;
          if (v6 != 255) {
            int32x2_t result = PDM_21362(result, v6);
          }
          *v10++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      uint64_t v72 = v97;
      uint64_t v73 = v98;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v74 = *v73;
          v73 += 2;
          uint64_t v75 = (unsigned int *)&v67[v74];
          if (v65 < (unsigned int *)&v67[v74]) {
            uint64_t v75 = v65;
          }
          if ((unint64_t)v75 < *(void *)(v95 + 32)) {
            uint64_t v75 = *(unsigned int **)(v95 + 32);
          }
          int v76 = __ROL4__(bswap32(*v75), v7);
          unsigned int v77 = v76 | v9;
          if (v6 != 255)
          {
            int32x2_t result = PDM_21362(v76 | v9, v6);
            unsigned int v77 = result;
          }
          if ((_BYTE)v77)
          {
            if (v77 == 255) {
              *uint64_t v10 = v77;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v10, v77, *v10, ~(_BYTE)v77);
            }
          }
          ++v10;
          --v72;
        }
        while (v72);
      }
    }
    uint64_t v12 = v87;
    v10 += v88;
    LOBYTE(v13) = v86;
    uint64_t v14 = v92 + v85;
    a6 = v94 - 1;
    a5 = v90;
  }
  while (v94 != 1);
  return result;
}

unint64_t rgba32_image_mark_RGB24(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7 = *((unsigned __int8 *)a2 + 8);
  int v86 = *a2;
  int v8 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v85 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 15);
  uint64_t v9 = *((void *)a2 + 16);
  uint64_t v11 = *((void *)a2 + 7);
  uint64_t v82 = *((void *)a2 + 9);
  uint64_t v12 = *((void *)a2 + 5) + v82 * a4;
  uint64_t v13 = *(unsigned __int8 **)(result + 32);
  uint64_t v14 = &v13[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  unint64_t v91 = result;
  char v83 = v11;
  uint64_t v84 = v10;
  if (*(void *)(result + 176))
  {
    uint64_t v80 = *((void *)a2 + 11);
    uint64_t v78 = ~(-1 << v11);
    uint64_t v79 = *((void *)a2 + 13);
    char v77 = v11 - 4;
    uint64_t v15 = v14 - 3;
    uint64_t v75 = a5;
    uint64_t v76 = -v10;
    uint64_t v74 = v9 + 16 * a3 + 8;
    while (1)
    {
      int v89 = a6;
      if (((v79 - v12) | (v12 - v80)) < 0)
      {
        int v18 = 0;
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v16 = ((v12 & (unint64_t)v78) >> v77) & 0xF;
        uint64_t v17 = (unint64_t)(v16 - 7) >= 9 ? v76 : v10;
        int v18 = weights_21383[v16] & 0xF;
      }
      uint64_t v19 = *(void *)(v91 + 32) + (v12 >> v11) * v10;
      uint64_t v87 = v12;
      if (v86 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v20 = (uint64_t *)v74;
        uint64_t v21 = v75;
        while (1)
        {
          uint64_t v22 = *(v20 - 1);
          uint64_t v23 = *v20;
          uint64_t v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22) {
            uint64_t v25 = (unsigned __int8 *)(v19 + v22);
          }
          else {
            uint64_t v25 = v15;
          }
          if (v25 < v13) {
            uint64_t v25 = v13;
          }
          int v26 = (*v25 << 24) | (v25[1] << 16) | (v25[2] << 8);
          char v27 = v23 & 0xF;
          if ((v23 & 0xF) != 0) {
            break;
          }
          if (v18)
          {
            int v38 = (unsigned __int8 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17) {
              int v38 = v15;
            }
            if (v38 < v13) {
              int v38 = v13;
            }
            unsigned int v39 = BLEND8_21385[v18];
            unsigned int v36 = v26 - ((v39 & v26) >> v18);
            unsigned int v37 = (((*v38 << 24) | (v38[1] << 16) | (v38[2] << 8)) & v39) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          int32x2_t result = v26 | 0xFFu;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          v20 += 2;
          *v8++ = result;
          if (!--v21) {
            goto LABEL_83;
          }
        }
        unsigned int v28 = (unsigned __int8 *)(v24 + (v23 >> 4));
        if (v15 < v28) {
          unsigned int v28 = v15;
        }
        if (v28 < v13) {
          unsigned int v28 = v13;
        }
        int v29 = (*v28 << 24) | (v28[1] << 16) | (v28[2] << 8);
        if (v18)
        {
          char v30 = (unsigned __int8 *)(v24 + v17);
          if (v15 >= v30) {
            unsigned int v31 = v30;
          }
          else {
            unsigned int v31 = v15;
          }
          if (v31 < v13) {
            unsigned int v31 = v13;
          }
          int v32 = (*v31 << 24) | (v31[1] << 16) | (v31[2] << 8);
          unint64_t v33 = &v30[v23 >> 4];
          if (v15 < v33) {
            unint64_t v33 = v15;
          }
          if (v33 < v13) {
            unint64_t v33 = v13;
          }
          unsigned int v34 = BLEND8_21385[v18];
          int v26 = v26 - ((v34 & v26) >> v18) + ((v34 & v32) >> v18);
          int v29 = v29 - ((v34 & v29) >> v18) + ((((*v33 << 24) | (v33[1] << 16) | (v33[2] << 8)) & v34) >> v18);
        }
        int v35 = BLEND8_21385[*v20 & 0xF];
        unsigned int v36 = v26 - ((v35 & v26) >> v27);
        unsigned int v37 = (v35 & v29) >> v27;
LABEL_40:
        int v26 = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v10 = v84;
      v8 += v85;
      LOBYTE(v11) = v83;
      uint64_t v12 = v87 + v82;
      --a6;
      if (v89 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    int v41 = (uint64_t *)v74;
    uint64_t v40 = v75;
    while (1)
    {
      uint64_t v42 = *(v41 - 1);
      uint64_t v43 = *v41;
      uint64_t v44 = v19 + v42;
      if ((unint64_t)v15 >= v19 + v42) {
        uint64_t v45 = (unsigned __int8 *)(v19 + v42);
      }
      else {
        uint64_t v45 = v15;
      }
      if (v45 < v13) {
        uint64_t v45 = v13;
      }
      int v46 = (*v45 << 24) | (v45[1] << 16) | (v45[2] << 8);
      char v47 = v43 & 0xF;
      if ((v43 & 0xF) != 0) {
        break;
      }
      if (v18)
      {
        int v58 = (unsigned __int8 *)(v44 + v17);
        if ((unint64_t)v15 < v44 + v17) {
          int v58 = v15;
        }
        if (v58 < v13) {
          int v58 = v13;
        }
        unsigned int v59 = BLEND8_21385[v18];
        unsigned int v56 = v46 - ((v59 & v46) >> v18);
        unsigned int v57 = (((*v58 << 24) | (v58[1] << 16) | (v58[2] << 8)) & v59) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      unsigned int v60 = v46 | 0xFF;
      if (v7 != 255)
      {
        int32x2_t result = PDM_21362(v46 | 0xFFu, v7);
        unsigned int v60 = result;
      }
      if ((_BYTE)v60)
      {
        if (v60 == 255) {
          *int v8 = v60;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v8, v60, *v8, ~(_BYTE)v60);
        }
      }
      v41 += 2;
      ++v8;
      if (!--v40) {
        goto LABEL_83;
      }
    }
    unsigned int v48 = (unsigned __int8 *)(v44 + (v43 >> 4));
    if (v15 < v48) {
      unsigned int v48 = v15;
    }
    if (v48 < v13) {
      unsigned int v48 = v13;
    }
    int v49 = (*v48 << 24) | (v48[1] << 16) | (v48[2] << 8);
    if (v18)
    {
      char v50 = (unsigned __int8 *)(v44 + v17);
      if (v15 >= v50) {
        unsigned int v51 = v50;
      }
      else {
        unsigned int v51 = v15;
      }
      if (v51 < v13) {
        unsigned int v51 = v13;
      }
      int v52 = (*v51 << 24) | (v51[1] << 16) | (v51[2] << 8);
      unint64_t v53 = &v50[v43 >> 4];
      if (v15 < v53) {
        unint64_t v53 = v15;
      }
      if (v53 < v13) {
        unint64_t v53 = v13;
      }
      unsigned int v54 = BLEND8_21385[v18];
      int v46 = v46 - ((v54 & v46) >> v18) + ((v54 & v52) >> v18);
      int v49 = v49 - ((v54 & v49) >> v18) + ((((*v53 << 24) | (v53[1] << 16) | (v53[2] << 8)) & v54) >> v18);
    }
    int v55 = BLEND8_21385[*v41 & 0xF];
    unsigned int v56 = v46 - ((v55 & v46) >> v47);
    unsigned int v57 = (v55 & v49) >> v47;
LABEL_75:
    int v46 = v56 + v57;
    goto LABEL_76;
  }
  int v90 = (uint64_t *)(v9 + 16 * a3);
  int v61 = v14 - 3;
  uint64_t v88 = a5;
  do
  {
    int v62 = *(unsigned __int8 **)(v91 + 32);
    int v63 = &v62[(v12 >> v11) * v10];
    if (v86 == 1)
    {
      if (a5 >= 1)
      {
        unsigned int v64 = v90;
        uint64_t v65 = v88;
        do
        {
          uint64_t v66 = *v64;
          v64 += 2;
          int v67 = &v63[v66];
          if (v61 < &v63[v66]) {
            int v67 = v61;
          }
          if (v67 < v62) {
            int v67 = v62;
          }
          int32x2_t result = (v67[1] << 16) | (*v67 << 24) | (v67[2] << 8) | 0xFFu;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          *v8++ = result;
          --v65;
        }
        while (v65);
      }
    }
    else
    {
      uint64_t v68 = v90;
      uint64_t v69 = v88;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v70 = *v68;
          v68 += 2;
          unsigned int v71 = &v63[v70];
          if (v61 < &v63[v70]) {
            unsigned int v71 = v61;
          }
          if ((unint64_t)v71 < *(void *)(v91 + 32)) {
            unsigned int v71 = *(unsigned __int8 **)(v91 + 32);
          }
          int v72 = (v71[1] << 16) | (*v71 << 24) | (v71[2] << 8);
          unsigned int v73 = v72 | 0xFF;
          if (v7 != 255)
          {
            int32x2_t result = PDM_21362(v72 | 0xFFu, v7);
            unsigned int v73 = result;
          }
          if ((_BYTE)v73)
          {
            if (v73 == 255) {
              *int v8 = v73;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v8, v73, *v8, ~(_BYTE)v73);
            }
          }
          ++v8;
          --v69;
        }
        while (v69);
      }
    }
    uint64_t v10 = v84;
    v8 += v85;
    LOBYTE(v11) = v83;
    v12 += v82;
    --a6;
  }
  while (a6);
  return result;
}

unint64_t rgba32_image_mark_W8(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7 = *((unsigned __int8 *)a2 + 8);
  int v88 = *a2;
  int v8 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v87 = *((void *)a2 + 3) - a5;
  uint64_t v9 = *((void *)a2 + 16);
  uint64_t v10 = *((void *)a2 + 7);
  uint64_t v86 = *((void *)a2 + 9);
  uint64_t v11 = *((void *)a2 + 5) + v86 * a4;
  uint64_t v12 = *(unsigned __int8 **)(result + 32);
  uint64_t v13 = &v12[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  unint64_t v93 = result;
  char v84 = v10;
  uint64_t v85 = *((void *)a2 + 15);
  if (*(void *)(result + 176))
  {
    uint64_t v82 = *((void *)a2 + 11);
    uint64_t v80 = ~(-1 << v10);
    uint64_t v81 = *((void *)a2 + 13);
    char v79 = v10 - 4;
    uint64_t v14 = v13 - 4;
    uint64_t v77 = a5;
    uint64_t v78 = -*((void *)a2 + 15);
    uint64_t v76 = v9 + 16 * a3 + 8;
    while (1)
    {
      int v91 = a6;
      if (((v81 - v11) | (v11 - v82)) < 0)
      {
        int v18 = 0;
        uint64_t v17 = 0;
        int v19 = a5;
        uint64_t v16 = v85;
      }
      else
      {
        uint64_t v15 = ((v11 & (unint64_t)v80) >> v79) & 0xF;
        uint64_t v16 = v85;
        uint64_t v17 = (unint64_t)(v15 - 7) >= 9 ? v78 : v85;
        int v18 = weights_21383[v15] & 0xF;
        int v19 = a5;
      }
      uint64_t v89 = v11;
      uint64_t v20 = *(void *)(v93 + 32) + (v11 >> v84) * v16;
      if (v88 != 1) {
        break;
      }
      if (v19 >= 1)
      {
        uint64_t v21 = (uint64_t *)v76;
        uint64_t v22 = v77;
        while (1)
        {
          uint64_t v23 = *(v21 - 1);
          uint64_t v24 = *v21;
          uint64_t v25 = v20 + v23;
          if ((unint64_t)v14 >= v20 + v23) {
            int v26 = (unsigned __int8 *)(v20 + v23);
          }
          else {
            int v26 = v14;
          }
          if (v26 < v12) {
            int v26 = v12;
          }
          unsigned int v27 = *v26;
          char v28 = v24 & 0xF;
          if ((v24 & 0xF) != 0) {
            break;
          }
          if (v18)
          {
            unsigned int v39 = (unsigned __int8 *)(v25 + v17);
            if ((unint64_t)v14 < v25 + v17) {
              unsigned int v39 = v14;
            }
            if (v39 < v12) {
              unsigned int v39 = v12;
            }
            int v40 = BLEND8_21385[v18];
            unsigned int v37 = v27 - ((v40 & v27) >> v18);
            unsigned int v38 = (v40 & *v39) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          int32x2_t result = (v27 << 24) | (v27 << 16) | (v27 << 8) | 0xFF;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          v21 += 2;
          *v8++ = result;
          if (!--v22) {
            goto LABEL_83;
          }
        }
        int v29 = (unsigned __int8 *)(v25 + (v24 >> 4));
        if (v14 < v29) {
          int v29 = v14;
        }
        if (v29 < v12) {
          int v29 = v12;
        }
        unsigned int v30 = *v29;
        if (v18)
        {
          unsigned int v31 = (unsigned __int8 *)(v25 + v17);
          if (v14 >= v31) {
            int v32 = v31;
          }
          else {
            int v32 = v14;
          }
          if (v32 < v12) {
            int v32 = v12;
          }
          unsigned int v33 = *v32;
          unsigned int v34 = &v31[v24 >> 4];
          if (v14 < v34) {
            unsigned int v34 = v14;
          }
          if (v34 < v12) {
            unsigned int v34 = v12;
          }
          int v35 = BLEND8_21385[v18];
          unsigned int v27 = v27 - ((v35 & v27) >> v18) + ((v35 & v33) >> v18);
          unsigned int v30 = v30 - ((v35 & v30) >> v18) + ((v35 & *v34) >> v18);
        }
        int v36 = BLEND8_21385[*v21 & 0xF];
        unsigned int v37 = v27 - ((v36 & v27) >> v28);
        unsigned int v38 = (v36 & v30) >> v28;
LABEL_40:
        unsigned int v27 = v37 + v38;
        goto LABEL_41;
      }
LABEL_83:
      v8 += v87;
      uint64_t v11 = v89 + v86;
      a6 = v91 - 1;
      if (v91 == 1) {
        return result;
      }
    }
    if (v19 < 1) {
      goto LABEL_83;
    }
    uint64_t v42 = (uint64_t *)v76;
    uint64_t v41 = v77;
    while (1)
    {
      uint64_t v43 = *(v42 - 1);
      uint64_t v44 = *v42;
      uint64_t v45 = v20 + v43;
      if ((unint64_t)v14 >= v20 + v43) {
        int v46 = (unsigned __int8 *)(v20 + v43);
      }
      else {
        int v46 = v14;
      }
      if (v46 < v12) {
        int v46 = v12;
      }
      unsigned int v47 = *v46;
      char v48 = v44 & 0xF;
      if ((v44 & 0xF) != 0) {
        break;
      }
      if (v18)
      {
        unsigned int v59 = (unsigned __int8 *)(v45 + v17);
        if ((unint64_t)v14 < v45 + v17) {
          unsigned int v59 = v14;
        }
        if (v59 < v12) {
          unsigned int v59 = v12;
        }
        int v60 = BLEND8_21385[v18];
        unsigned int v57 = v47 - ((v60 & v47) >> v18);
        unsigned int v58 = (v60 & *v59) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      unsigned int v61 = (v47 << 24) | (v47 << 16) | (v47 << 8) | 0xFF;
      if (v7 != 255)
      {
        int32x2_t result = PDM_21362((v47 << 24) | (v47 << 16) | (v47 << 8) | 0xFF, v7);
        unsigned int v61 = result;
      }
      if ((_BYTE)v61)
      {
        if (v61 == 255) {
          *int v8 = v61;
        }
        else {
          int32x2_t result = (unint64_t)DplusDM_21364(v8, v61, *v8, ~(_BYTE)v61);
        }
      }
      v42 += 2;
      ++v8;
      if (!--v41) {
        goto LABEL_83;
      }
    }
    int v49 = (unsigned __int8 *)(v45 + (v44 >> 4));
    if (v14 < v49) {
      int v49 = v14;
    }
    if (v49 < v12) {
      int v49 = v12;
    }
    unsigned int v50 = *v49;
    if (v18)
    {
      unsigned int v51 = (unsigned __int8 *)(v45 + v17);
      if (v14 >= v51) {
        int v52 = v51;
      }
      else {
        int v52 = v14;
      }
      if (v52 < v12) {
        int v52 = v12;
      }
      unsigned int v53 = *v52;
      unsigned int v54 = &v51[v44 >> 4];
      if (v14 < v54) {
        unsigned int v54 = v14;
      }
      if (v54 < v12) {
        unsigned int v54 = v12;
      }
      int v55 = BLEND8_21385[v18];
      unsigned int v47 = v47 - ((v55 & v47) >> v18) + ((v55 & v53) >> v18);
      unsigned int v50 = v50 - ((v55 & v50) >> v18) + ((v55 & *v54) >> v18);
    }
    int v56 = BLEND8_21385[*v42 & 0xF];
    unsigned int v57 = v47 - ((v56 & v47) >> v48);
    unsigned int v58 = (v56 & v50) >> v48;
LABEL_75:
    unsigned int v47 = v57 + v58;
    goto LABEL_76;
  }
  int v62 = v13 - 4;
  uint64_t v92 = (uint64_t *)(v9 + 16 * a3);
  uint64_t v90 = a5;
  do
  {
    uint64_t v63 = v11;
    unsigned int v64 = *(unsigned __int8 **)(v93 + 32);
    uint64_t v65 = &v64[(v11 >> v84) * v85];
    if (v88 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v66 = v92;
        uint64_t v67 = v90;
        do
        {
          uint64_t v68 = *v66;
          v66 += 2;
          uint64_t v69 = &v65[v68];
          if (v62 < &v65[v68]) {
            uint64_t v69 = v62;
          }
          if (v69 < v64) {
            uint64_t v69 = v64;
          }
          int32x2_t result = (16843008 * *v69) | 0xFFu;
          if (v7 != 255) {
            int32x2_t result = PDM_21362(result, v7);
          }
          *v8++ = result;
          --v67;
        }
        while (v67);
      }
    }
    else
    {
      uint64_t v70 = v92;
      uint64_t v71 = v90;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v72 = *v70;
          v70 += 2;
          unsigned int v73 = &v65[v72];
          if (v62 < &v65[v72]) {
            unsigned int v73 = v62;
          }
          if ((unint64_t)v73 < *(void *)(v93 + 32)) {
            unsigned int v73 = *(unsigned __int8 **)(v93 + 32);
          }
          int v74 = 16843008 * *v73;
          unsigned int v75 = v74 | 0xFF;
          if (v7 != 255)
          {
            int32x2_t result = PDM_21362(v74 | 0xFFu, v7);
            unsigned int v75 = result;
          }
          if ((_BYTE)v75)
          {
            if (v75 == 255) {
              *int v8 = v75;
            }
            else {
              int32x2_t result = (unint64_t)DplusDM_21364(v8, v75, *v8, ~(_BYTE)v75);
            }
          }
          ++v8;
          --v71;
        }
        while (v71);
      }
    }
    v8 += v87;
    uint64_t v11 = v63 + v86;
    --a6;
  }
  while (a6);
  return result;
}

_DWORD *DplusDAM_21386(_DWORD *result, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v5 = ((((((a3 & 0xFF0000 | a4) * a5 + 8388736) >> 8) & 0xFF00FF) + (a3 & 0xFF0000 | a4) * a5 + 8388736) >> 8) & 0xFF00FF | ((((((a3 >> 8) & 0xFF00FF) * a5 + 8388736) >> 8) & 0xFF00FF) + ((a3 >> 8) & 0xFF00FF) * a5 + 8388736) & 0xFF00FF00;
  unint64_t v6 = (((v5 | (unint64_t)(v5 << 40)) >> 8) & 0xFF00FF00FF00FFLL)
     + (((a2 | ((unint64_t)a2 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  int *result = ((((v6 & 0x100010001000100) - ((v6 & 0x100010001000100) >> 8)) | v6) & 0xFF00FF00FF00FFLL | (((((v6 & 0x100010001000100) - ((v6 & 0x100010001000100) >> 8)) | v6) & 0xFF00FF00FF00FFLL) << 40)) >> 32;
  return result;
}

_DWORD *DAM_21387(_DWORD *result, unsigned int a2, int a3, int a4)
{
  unsigned int v4 = ((a2 >> 8) & 0xFF00FF) * (a4 ^ 0xFF) + 8388736;
  unsigned int v5 = (a2 & 0xFF0000 | a3 & 0xFF00FF) * (a4 ^ 0xFF) + 8388736;
  uint64_t v6 = ((((v5 >> 8) & 0xFF00FF) + v5) >> 8) & 0xFF00FF | (((v4 >> 8) & 0xFF00FF) + v4) & 0xFF00FF00;
  unint64_t v7 = (((a2 & 0xFFFFFF00 | a3 | ((unint64_t)(a2 & 0xFFFFFF00 | a3) << 40)) >> 8) & 0xFF00FF00FF00FFLL | 0x100010001000100)
     - (((v6 | (unint64_t)(v6 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  int *result = (((v7 & 0x100010001000100) - ((v7 & 0x100010001000100) >> 8)) & v7 | ((((v7 & 0x100010001000100)
                                                                                      - ((v7 & 0x100010001000100) >> 8)) & v7) << 40)) >> 32;
  return result;
}

void rgba32_mark_pixelmask(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2)
  {
    int v519 = *(_DWORD *)(a1 + 4);
    uint64_t v3 = v519;
    int v521 = *(_DWORD *)(a1 + 8);
    uint64_t v522 = *(void *)(a1 + 48);
    uint64_t v4 = *(void *)(a1 + 88);
    uint64_t v5 = *(void *)(a1 + 96);
    unint64_t v6 = (unint64_t)*(int *)(a1 + 28) >> 2;
    unint64_t v7 = (unsigned int *)(*(void *)(a1 + 40) + 4 * (*(int *)(a1 + 12) + v6 * *(int *)(a1 + 16)));
    uint64_t v8 = *(int *)(a1 + 124);
    uint64_t v9 = (unsigned __int8 *)(v2 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v8);
    uint64_t v10 = *(int *)(a1 + 56);
    uint64_t v11 = *(int *)(a1 + 60);
    unint64_t v12 = *(int *)(a1 + 76);
    if (*(unsigned __int8 *)(a1 + 1) << 8 != 256)
    {
      int v18 = *(_DWORD *)(a1 + 64);
      int v17 = *(_DWORD *)(a1 + 68);
      uint64_t v13 = v12 >> 2;
      BOOL v19 = v5 != 0;
      uint64_t v518 = v8 - v519;
      unint64_t v517 = v6 - v519;
      if (v4)
      {
        int v515 = 0;
        unint64_t v514 = v4 + 4 * v13 * v17;
        uint64_t v516 = v13;
        uint64_t v20 = v4 + 4 * v13 * ((int)v11 % v17);
        uint64_t v14 = (unsigned int *)(v20 + 4 * ((int)v10 % v18));
        unint64_t v21 = v20 + 4 * v18;
        int v16 = 1;
        v520 = v14;
LABEL_16:
        switch(a2)
        {
          case 0:
            uint64_t v22 = v16;
            uint64_t v23 = 4 * v16;
            do
            {
              int v24 = v519;
              do
              {
                int v25 = *v9;
                if (*v9)
                {
                  if (v25 == 255) {
                    unsigned int v26 = 0;
                  }
                  else {
                    unsigned int v26 = PDM_21362(*v7, v25 ^ 0xFFu);
                  }
                  *unint64_t v7 = v26;
                }
                v9 += v22;
                unint64_t v7 = (unsigned int *)((char *)v7 + v23);
                --v24;
              }
              while (v24);
              v9 += v518;
              v7 += v517;
              --v521;
            }
            while (v521);
            return;
          case 1:
            if (v522) {
              char v27 = v19;
            }
            else {
              char v27 = 1;
            }
            uint64_t v28 = v16;
            uint64_t v29 = -(uint64_t)v18;
            uint64_t v30 = -(v516 * v17);
            uint64_t v31 = 4 * v16;
            if (v27)
            {
              do
              {
                int v32 = v519;
                do
                {
                  int v33 = *v9;
                  if (*v9)
                  {
                    if (v33 == 255) {
                      *unint64_t v7 = *v14;
                    }
                    else {
                      DMplusDM_21363(v7, *v14, v33, *v7, v33 ^ 0xFF);
                    }
                  }
                  v9 += v28;
                  unsigned int v34 = &v14[v28];
                  if ((unint64_t)v34 >= v21) {
                    uint64_t v35 = v29;
                  }
                  else {
                    uint64_t v35 = 0;
                  }
                  uint64_t v14 = &v34[v35];
                  unint64_t v7 = (unsigned int *)((char *)v7 + v31);
                  --v32;
                }
                while (v32);
                v9 += v518;
                v7 += v517;
                int v36 = v520;
                unsigned int v37 = &v520[v516];
                if ((unint64_t)v37 >= v514) {
                  uint64_t v38 = v30;
                }
                else {
                  uint64_t v38 = 0;
                }
                unsigned int v39 = &v37[v38];
                uint64_t v40 = v21 + 4 * v38 + 4 * v516;
                if (v515)
                {
                  v14 += v516;
                }
                else
                {
                  unint64_t v21 = v40;
                  int v36 = v39;
                  uint64_t v14 = v39;
                }
                BOOL v41 = v521 == 1;
                v520 = v36;
                --v521;
              }
              while (!v41);
            }
            else
            {
              do
              {
                int v42 = v519;
                do
                {
                  int v43 = *v9;
                  if (*v9)
                  {
                    if (v43 == 255) {
                      *unint64_t v7 = *v14 | 0xFF;
                    }
                    else {
                      DMplusDAM_21388(v7, *v7, v43 ^ 0xFF, *v14, 0xFFu, v43);
                    }
                  }
                  v9 += v28;
                  uint64_t v44 = &v14[v28];
                  if ((unint64_t)v44 >= v21) {
                    uint64_t v45 = v29;
                  }
                  else {
                    uint64_t v45 = 0;
                  }
                  uint64_t v14 = &v44[v45];
                  unint64_t v7 = (unsigned int *)((char *)v7 + v31);
                  --v42;
                }
                while (v42);
                v9 += v518;
                v7 += v517;
                int v46 = v520;
                unsigned int v47 = &v520[v516];
                if ((unint64_t)v47 >= v514) {
                  uint64_t v48 = v30;
                }
                else {
                  uint64_t v48 = 0;
                }
                int v49 = &v47[v48];
                uint64_t v50 = v21 + 4 * v48 + 4 * v516;
                if (v515)
                {
                  v14 += v516;
                }
                else
                {
                  unint64_t v21 = v50;
                  int v46 = v49;
                  uint64_t v14 = v49;
                }
                BOOL v41 = v521 == 1;
                v520 = v46;
                --v521;
              }
              while (!v41);
            }
            return;
          case 2:
            uint64_t v51 = v16;
            uint64_t v52 = -(uint64_t)v18;
            uint64_t v53 = -(v516 * v17);
            uint64_t v54 = 4 * v16;
            while (1)
            {
              int v55 = v519;
              do
              {
                int v56 = *v9;
                if (!*v9) {
                  goto LABEL_78;
                }
                if (v56 == 255)
                {
                  unsigned int v57 = *v14;
                  if (!*v14) {
                    goto LABEL_78;
                  }
                  if (*v14 == 255)
                  {
                    *unint64_t v7 = v57;
                    goto LABEL_78;
                  }
                }
                else
                {
                  unsigned int v58 = PDM_21362(*v14, v56);
                  if (!(_BYTE)v58) {
                    goto LABEL_78;
                  }
                  unsigned int v57 = v58;
                }
                DplusDM_21364(v7, v57, *v7, ~(_BYTE)v57);
LABEL_78:
                v9 += v51;
                unsigned int v59 = &v14[v51];
                if ((unint64_t)v59 >= v21) {
                  uint64_t v60 = v52;
                }
                else {
                  uint64_t v60 = 0;
                }
                uint64_t v14 = &v59[v60];
                unint64_t v7 = (unsigned int *)((char *)v7 + v54);
                --v55;
              }
              while (v55);
              v9 += v518;
              v7 += v517;
              unsigned int v61 = v520;
              int v62 = &v520[v516];
              if ((unint64_t)v62 >= v514) {
                uint64_t v63 = v53;
              }
              else {
                uint64_t v63 = 0;
              }
              unsigned int v64 = &v62[v63];
              uint64_t v65 = v21 + 4 * v63 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v65;
                unsigned int v61 = v64;
                uint64_t v14 = v64;
              }
              BOOL v41 = v521 == 1;
              v520 = v61;
              --v521;
              if (v41) {
                return;
              }
            }
          case 3:
            uint64_t v66 = v16;
            uint64_t v67 = -(uint64_t)v18;
            uint64_t v68 = -(v516 * v17);
            uint64_t v69 = 4 * v16;
            do
            {
              int v70 = v519;
              do
              {
                int v71 = *v9;
                if (*v9)
                {
                  if (v71 == 255)
                  {
                    if (v19) {
                      unsigned __int8 v72 = *v14;
                    }
                    else {
                      unsigned __int8 v72 = -1;
                    }
                    DAM_21387(v7, *v14, v72, *(unsigned __int8 *)v7);
                  }
                  else
                  {
                    if (v19) {
                      unsigned __int8 v73 = *v14;
                    }
                    else {
                      unsigned __int8 v73 = -1;
                    }
                    DMplusDAM_21388(v7, *v7, v71 ^ 0xFF, *v14, v73, (unsigned __int16)(*v7 * (_WORD)v71+ 128+ ((*v7 * v71 + 128) >> 8)) >> 8);
                  }
                }
                v9 += v66;
                int v74 = &v14[v66];
                if ((unint64_t)v74 >= v21) {
                  uint64_t v75 = v67;
                }
                else {
                  uint64_t v75 = 0;
                }
                uint64_t v14 = &v74[v75];
                unint64_t v7 = (unsigned int *)((char *)v7 + v69);
                --v70;
              }
              while (v70);
              v9 += v518;
              v7 += v517;
              uint64_t v76 = v520;
              uint64_t v77 = &v520[v516];
              if ((unint64_t)v77 >= v514) {
                uint64_t v78 = v68;
              }
              else {
                uint64_t v78 = 0;
              }
              char v79 = &v77[v78];
              uint64_t v80 = v21 + 4 * v78 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v80;
                uint64_t v76 = v79;
                uint64_t v14 = v79;
              }
              BOOL v41 = v521 == 1;
              v520 = v76;
              --v521;
            }
            while (!v41);
            return;
          case 4:
            uint64_t v81 = v16;
            uint64_t v82 = -(uint64_t)v18;
            uint64_t v523 = -(v516 * v17);
            uint64_t v83 = 4 * v16;
            do
            {
              int v84 = v519;
              do
              {
                int v85 = *v9;
                if (*v9)
                {
                  if (v85 == 255)
                  {
                    if (v19) {
                      unsigned __int8 v86 = *v14;
                    }
                    else {
                      unsigned __int8 v86 = -1;
                    }
                    DAM_21387(v7, *v14, v86, *(unsigned __int8 *)v7 ^ 0xFF);
                  }
                  else
                  {
                    if (v19) {
                      unsigned __int8 v87 = *v14;
                    }
                    else {
                      unsigned __int8 v87 = -1;
                    }
                    DMplusDAM_21388(v7, *v7, v85 ^ 0xFF, *v14, v87, (unsigned __int16)(~*(unsigned char *)v7 * (_WORD)v85+ 128+ ((~*(unsigned char *)v7 * v85 + 128) >> 8)) >> 8);
                  }
                }
                v9 += v81;
                int v88 = &v14[v81];
                if ((unint64_t)v88 >= v21) {
                  uint64_t v89 = v82;
                }
                else {
                  uint64_t v89 = 0;
                }
                uint64_t v14 = &v88[v89];
                unint64_t v7 = (unsigned int *)((char *)v7 + v83);
                --v84;
              }
              while (v84);
              v9 += v518;
              v7 += v517;
              uint64_t v90 = v520;
              int v91 = &v520[v516];
              uint64_t v92 = v523;
              if ((unint64_t)v91 < v514) {
                uint64_t v92 = 0;
              }
              unint64_t v93 = &v91[v92];
              uint64_t v94 = v21 + 4 * v92 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v94;
                uint64_t v90 = v93;
                uint64_t v14 = v93;
              }
              BOOL v41 = v521 == 1;
              v520 = v90;
              --v521;
            }
            while (!v41);
            return;
          case 5:
            uint64_t v95 = v16;
            uint64_t v96 = -(uint64_t)v18;
            uint64_t v97 = -(v516 * v17);
            uint64_t v98 = 4 * v16;
            do
            {
              int v99 = v519;
              do
              {
                if (*v9)
                {
                  unsigned int v100 = PDM_21362(*v14, *v9);
                  DMplusDM_21363(v7, v100, *v7, *v7, ~(_BYTE)v100);
                }
                v9 += v95;
                unint64_t v101 = &v14[v95];
                if ((unint64_t)v101 >= v21) {
                  uint64_t v102 = v96;
                }
                else {
                  uint64_t v102 = 0;
                }
                uint64_t v14 = &v101[v102];
                unint64_t v7 = (unsigned int *)((char *)v7 + v98);
                --v99;
              }
              while (v99);
              v9 += v518;
              v7 += v517;
              unsigned __int16 v103 = v520;
              int v104 = &v520[v516];
              if ((unint64_t)v104 >= v514) {
                uint64_t v105 = v97;
              }
              else {
                uint64_t v105 = 0;
              }
              unsigned int v106 = &v104[v105];
              uint64_t v107 = v21 + 4 * v105 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v107;
                unsigned __int16 v103 = v106;
                uint64_t v14 = v106;
              }
              BOOL v41 = v521 == 1;
              v520 = v103;
              --v521;
            }
            while (!v41);
            return;
          case 6:
            uint64_t v108 = v16;
            uint64_t v109 = -(uint64_t)v18;
            uint64_t v524 = -(v516 * v17);
            uint64_t v110 = 4 * v16;
            do
            {
              int v111 = v519;
              do
              {
                int v112 = *v9;
                if (*v9 && *v7 != 0xFF)
                {
                  if (~*(unsigned char *)v7 == 255)
                  {
                    if (v19) {
                      unsigned __int8 v113 = *v14;
                    }
                    else {
                      unsigned __int8 v113 = -1;
                    }
                    DAM_21387(v7, *v14, v113, v112);
                  }
                  else
                  {
                    if (v19) {
                      unsigned __int8 v114 = *v14;
                    }
                    else {
                      unsigned __int8 v114 = -1;
                    }
                    DplusDAM_21386(v7, *v7, *v14, v114, (unsigned __int16)(~*(unsigned char *)v7 * (_WORD)v112+ 128+ ((~*(unsigned char *)v7 * v112 + 128) >> 8)) >> 8);
                  }
                }
                v9 += v108;
                int v115 = &v14[v108];
                if ((unint64_t)v115 >= v21) {
                  uint64_t v116 = v109;
                }
                else {
                  uint64_t v116 = 0;
                }
                uint64_t v14 = &v115[v116];
                unint64_t v7 = (unsigned int *)((char *)v7 + v110);
                --v111;
              }
              while (v111);
              v9 += v518;
              v7 += v517;
              int v117 = v520;
              __int16 v118 = &v520[v516];
              uint64_t v119 = v524;
              if ((unint64_t)v118 < v514) {
                uint64_t v119 = 0;
              }
              char v120 = &v118[v119];
              uint64_t v121 = v21 + 4 * v119 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v121;
                int v117 = v120;
                uint64_t v14 = v120;
              }
              BOOL v41 = v521 == 1;
              v520 = v117;
              --v521;
            }
            while (!v41);
            return;
          case 7:
            uint64_t v122 = v16;
            uint64_t v123 = -(uint64_t)v18;
            uint64_t v124 = -(v516 * v17);
            uint64_t v125 = 4 * v16;
            do
            {
              int v126 = v519;
              do
              {
                int v127 = *v9;
                if (*v9)
                {
                  if (v127 == 255) {
                    *unint64_t v7 = PDM_21362(*v7, *(unsigned __int8 *)v14);
                  }
                  else {
                    DMplusDM_21363(v7, *v7, (unsigned __int16)(*(unsigned __int8 *)v14 * (_WORD)v127+ 128+ ((*(unsigned __int8 *)v14 * v127 + 128) >> 8)) >> 8, *v7, v127 ^ 0xFF);
                  }
                }
                v9 += v122;
                __int16 v128 = &v14[v122];
                if ((unint64_t)v128 >= v21) {
                  uint64_t v129 = v123;
                }
                else {
                  uint64_t v129 = 0;
                }
                uint64_t v14 = &v128[v129];
                unint64_t v7 = (unsigned int *)((char *)v7 + v125);
                --v126;
              }
              while (v126);
              v9 += v518;
              v7 += v517;
              __int16 v130 = v520;
              int v131 = &v520[v516];
              if ((unint64_t)v131 >= v514) {
                uint64_t v132 = v124;
              }
              else {
                uint64_t v132 = 0;
              }
              uint64_t v133 = &v131[v132];
              uint64_t v134 = v21 + 4 * v132 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v134;
                __int16 v130 = v133;
                uint64_t v14 = v133;
              }
              BOOL v41 = v521 == 1;
              v520 = v130;
              --v521;
            }
            while (!v41);
            return;
          case 8:
            uint64_t v135 = v16;
            uint64_t v136 = -(uint64_t)v18;
            uint64_t v137 = -(v516 * v17);
            uint64_t v138 = 4 * v16;
            do
            {
              int v139 = v519;
              do
              {
                int v140 = *v9;
                if (*v9)
                {
                  if (v140 == 255) {
                    unsigned int v141 = *v14;
                  }
                  else {
                    unsigned int v141 = (*(unsigned __int8 *)v14 * v140
                  }
                          + 128
                          + ((*(unsigned __int8 *)v14 * v140 + 128) >> 8)) >> 8;
                  *unint64_t v7 = PDM_21362(*v7, ~(_BYTE)v141);
                }
                v9 += v135;
                int32x2_t v142 = &v14[v135];
                if ((unint64_t)v142 >= v21) {
                  uint64_t v143 = v136;
                }
                else {
                  uint64_t v143 = 0;
                }
                uint64_t v14 = &v142[v143];
                unint64_t v7 = (unsigned int *)((char *)v7 + v138);
                --v139;
              }
              while (v139);
              v9 += v518;
              v7 += v517;
              int32x2_t v144 = v520;
              int v145 = &v520[v516];
              if ((unint64_t)v145 >= v514) {
                uint64_t v146 = v137;
              }
              else {
                uint64_t v146 = 0;
              }
              int32x2_t v147 = &v145[v146];
              uint64_t v148 = v21 + 4 * v146 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v148;
                int32x2_t v144 = v147;
                uint64_t v14 = v147;
              }
              BOOL v41 = v521 == 1;
              v520 = v144;
              --v521;
            }
            while (!v41);
            return;
          case 9:
            uint64_t v149 = v16;
            uint64_t v150 = -(uint64_t)v18;
            uint64_t v525 = -(v516 * v17);
            uint64_t v151 = 4 * v16;
            do
            {
              int v152 = v519;
              do
              {
                unsigned __int8 v153 = *v9;
                if (*v9)
                {
                  unsigned int v154 = PDM_21362(*v14, *v9);
                  DMplusDM_21363(v7, v154, ~*(unsigned char *)v7, *v7, (v154 + ~v153));
                }
                v9 += v149;
                BOOL v155 = &v14[v149];
                if ((unint64_t)v155 >= v21) {
                  uint64_t v156 = v150;
                }
                else {
                  uint64_t v156 = 0;
                }
                uint64_t v14 = &v155[v156];
                unint64_t v7 = (unsigned int *)((char *)v7 + v151);
                --v152;
              }
              while (v152);
              v9 += v518;
              v7 += v517;
              float64x2_t v157 = v520;
              float64x2_t v158 = &v520[v516];
              uint64_t v159 = v525;
              if ((unint64_t)v158 < v514) {
                uint64_t v159 = 0;
              }
              double v160 = &v158[v159];
              uint64_t v161 = v21 + 4 * v159 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v161;
                float64x2_t v157 = v160;
                uint64_t v14 = v160;
              }
              BOOL v41 = v521 == 1;
              v520 = v157;
              --v521;
            }
            while (!v41);
            return;
          case 10:
            uint64_t v162 = v16;
            uint64_t v163 = -(uint64_t)v18;
            uint64_t v164 = -(v516 * v17);
            uint64_t v165 = 4 * v16;
            do
            {
              int v166 = v519;
              do
              {
                if (*v9)
                {
                  unsigned int v167 = PDM_21362(*v14, *v9);
                  DMplusDM_21363(v7, v167, ~*(unsigned char *)v7, *v7, ~(_BYTE)v167);
                }
                v9 += v162;
                float64x2_t v168 = &v14[v162];
                if ((unint64_t)v168 >= v21) {
                  uint64_t v169 = v163;
                }
                else {
                  uint64_t v169 = 0;
                }
                uint64_t v14 = &v168[v169];
                unint64_t v7 = (unsigned int *)((char *)v7 + v165);
                --v166;
              }
              while (v166);
              v9 += v518;
              v7 += v517;
              float64x2_t v170 = v520;
              float64x2_t v171 = &v520[v516];
              if ((unint64_t)v171 >= v514) {
                uint64_t v172 = v164;
              }
              else {
                uint64_t v172 = 0;
              }
              CGAffineTransform v173 = &v171[v172];
              uint64_t v174 = v21 + 4 * v172 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v174;
                float64x2_t v170 = v173;
                uint64_t v14 = v173;
              }
              BOOL v41 = v521 == 1;
              v520 = v170;
              --v521;
            }
            while (!v41);
            return;
          case 11:
            uint64_t v175 = v16;
            uint64_t v176 = -(uint64_t)v18;
            uint64_t v493 = -(v516 * v17);
            uint64_t v177 = 4 * v16;
            do
            {
              int v178 = v519;
              do
              {
                unsigned __int8 v179 = *v9;
                if (*v9)
                {
                  int v180 = PDM_21362(*v14, *v9);
                  if (v522) {
                    unsigned __int8 v182 = *v7;
                  }
                  else {
                    unsigned __int8 v182 = -1;
                  }
                  if (v19) {
                    unsigned __int8 v183 = v180;
                  }
                  else {
                    unsigned __int8 v183 = v179;
                  }
                  DAplusdDA_21365(v7, *v7, v182, v180, v183, v181);
                }
                v9 += v175;
                v184 = &v14[v175];
                if ((unint64_t)v184 >= v21) {
                  uint64_t v185 = v176;
                }
                else {
                  uint64_t v185 = 0;
                }
                uint64_t v14 = &v184[v185];
                unint64_t v7 = (unsigned int *)((char *)v7 + v177);
                --v178;
              }
              while (v178);
              v9 += v518;
              v7 += v517;
              uint64_t v186 = v520;
              CGAffineTransform v187 = &v520[v516];
              uint64_t v188 = v493;
              if ((unint64_t)v187 < v514) {
                uint64_t v188 = 0;
              }
              CGRect v189 = &v187[v188];
              uint64_t v190 = v21 + 4 * v188 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v190;
                uint64_t v186 = v189;
                uint64_t v14 = v189;
              }
              BOOL v41 = v521 == 1;
              v520 = v186;
              --v521;
            }
            while (!v41);
            return;
          case 12:
            uint64_t v191 = v16;
            uint64_t v192 = -(uint64_t)v18;
            uint64_t v526 = -(v516 * v17);
            uint64_t v193 = 4 * v16;
            BOOL v513 = v19;
            do
            {
              int v194 = v519;
              do
              {
                unsigned __int8 v195 = *v9;
                if (*v9)
                {
                  unsigned int v196 = PDM_21362(*v14, *v9);
                  unsigned int v197 = *v7;
                  if (v513) {
                    unsigned __int8 v198 = v196;
                  }
                  else {
                    unsigned __int8 v198 = v195;
                  }
                  int v199 = ((v197 >> 8) & 0xFF00FF) + ((v196 >> 8) & 0xFF00FF);
                  unsigned int v200 = (v196 & 0xFF0000 | v198) + (v197 & 0xFF00FF);
                  *unint64_t v7 = (v199 << 8) & 0xFF00FF00 | v200 & 0xFF00FF | (15 * ((v200 >> 8) & 0x10001 | v199 & 0x1000100)) | (240 * ((v200 >> 8) & 0x10001 | v199 & 0x1000100));
                }
                v9 += v191;
                v201 = &v14[v191];
                if ((unint64_t)v201 >= v21) {
                  uint64_t v202 = v192;
                }
                else {
                  uint64_t v202 = 0;
                }
                uint64_t v14 = &v201[v202];
                unint64_t v7 = (unsigned int *)((char *)v7 + v193);
                --v194;
              }
              while (v194);
              v9 += v518;
              v7 += v517;
              v203 = v520;
              v204 = &v520[v516];
              uint64_t v205 = v526;
              if ((unint64_t)v204 < v514) {
                uint64_t v205 = 0;
              }
              v206 = &v204[v205];
              uint64_t v207 = v21 + 4 * v205 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v207;
                v203 = v206;
                uint64_t v14 = v206;
              }
              BOOL v41 = v521 == 1;
              v520 = v203;
              --v521;
            }
            while (!v41);
            return;
          case 13:
            uint64_t v208 = v16;
            uint64_t v209 = -(uint64_t)v18;
            uint64_t v494 = -(v516 * v17);
            uint64_t v210 = 4 * v16;
            while (1)
            {
              int v211 = v519;
              do
              {
                unsigned __int8 v212 = *v9;
                if (!*v9) {
                  goto LABEL_306;
                }
                unsigned int v213 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v212 = v213;
                  if (!(_BYTE)v213) {
                    goto LABEL_306;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v214) = -1;
LABEL_304:
                  unsigned int v215 = PDAmultiplyPDA_21366(*v7, v214, v213, v212);
                  goto LABEL_305;
                }
                unsigned int v214 = *v7;
                if (*v7) {
                  goto LABEL_304;
                }
                unsigned int v215 = v213 & 0xFFFFFF00 | v212;
LABEL_305:
                *unint64_t v7 = v215;
LABEL_306:
                v9 += v208;
                v216 = &v14[v208];
                if ((unint64_t)v216 >= v21) {
                  uint64_t v217 = v209;
                }
                else {
                  uint64_t v217 = 0;
                }
                uint64_t v14 = &v216[v217];
                unint64_t v7 = (unsigned int *)((char *)v7 + v210);
                --v211;
              }
              while (v211);
              v9 += v518;
              v7 += v517;
              v218 = v520;
              v219 = &v520[v516];
              uint64_t v220 = v494;
              if ((unint64_t)v219 < v514) {
                uint64_t v220 = 0;
              }
              v221 = &v219[v220];
              uint64_t v222 = v21 + 4 * v220 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v222;
                v218 = v221;
                uint64_t v14 = v221;
              }
              BOOL v41 = v521 == 1;
              v520 = v218;
              --v521;
              if (v41) {
                return;
              }
            }
          case 14:
            uint64_t v223 = v16;
            uint64_t v224 = -(uint64_t)v18;
            uint64_t v495 = -(v516 * v17);
            uint64_t v225 = 4 * v16;
            while (1)
            {
              int v226 = v519;
              do
              {
                unsigned __int8 v227 = *v9;
                if (!*v9) {
                  goto LABEL_329;
                }
                unsigned int v228 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v227 = v228;
                  if (!(_BYTE)v228) {
                    goto LABEL_329;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v229) = -1;
LABEL_327:
                  unsigned int v230 = PDAscreenPDA_21367(*v7, v229, v228, v227);
                  goto LABEL_328;
                }
                unsigned int v229 = *v7;
                if (*v7) {
                  goto LABEL_327;
                }
                unsigned int v230 = v228 & 0xFFFFFF00 | v227;
LABEL_328:
                *unint64_t v7 = v230;
LABEL_329:
                v9 += v223;
                v231 = &v14[v223];
                if ((unint64_t)v231 >= v21) {
                  uint64_t v232 = v224;
                }
                else {
                  uint64_t v232 = 0;
                }
                uint64_t v14 = &v231[v232];
                unint64_t v7 = (unsigned int *)((char *)v7 + v225);
                --v226;
              }
              while (v226);
              v9 += v518;
              v7 += v517;
              v233 = v520;
              v234 = &v520[v516];
              uint64_t v235 = v495;
              if ((unint64_t)v234 < v514) {
                uint64_t v235 = 0;
              }
              v236 = &v234[v235];
              uint64_t v237 = v21 + 4 * v235 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v237;
                v233 = v236;
                uint64_t v14 = v236;
              }
              BOOL v41 = v521 == 1;
              v520 = v233;
              --v521;
              if (v41) {
                return;
              }
            }
          case 15:
            uint64_t v238 = v16;
            uint64_t v239 = -(uint64_t)v18;
            uint64_t v496 = -(v516 * v17);
            uint64_t v240 = 4 * v16;
            while (1)
            {
              int v241 = v519;
              do
              {
                unsigned __int8 v242 = *v9;
                if (!*v9) {
                  goto LABEL_352;
                }
                unsigned int v243 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v242 = v243;
                  if (!(_BYTE)v243) {
                    goto LABEL_352;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v244) = -1;
LABEL_350:
                  unsigned int v245 = PDAoverlayPDA_21368(*v7, v244, v243, v242);
                  goto LABEL_351;
                }
                unsigned int v244 = *v7;
                if (*v7) {
                  goto LABEL_350;
                }
                unsigned int v245 = v243 & 0xFFFFFF00 | v242;
LABEL_351:
                *unint64_t v7 = v245;
LABEL_352:
                v9 += v238;
                v246 = &v14[v238];
                if ((unint64_t)v246 >= v21) {
                  uint64_t v247 = v239;
                }
                else {
                  uint64_t v247 = 0;
                }
                uint64_t v14 = &v246[v247];
                unint64_t v7 = (unsigned int *)((char *)v7 + v240);
                --v241;
              }
              while (v241);
              v9 += v518;
              v7 += v517;
              v248 = v520;
              v249 = &v520[v516];
              uint64_t v250 = v496;
              if ((unint64_t)v249 < v514) {
                uint64_t v250 = 0;
              }
              v251 = &v249[v250];
              uint64_t v252 = v21 + 4 * v250 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v252;
                v248 = v251;
                uint64_t v14 = v251;
              }
              BOOL v41 = v521 == 1;
              v520 = v248;
              --v521;
              if (v41) {
                return;
              }
            }
          case 16:
            uint64_t v253 = v16;
            uint64_t v254 = -(uint64_t)v18;
            uint64_t v497 = -(v516 * v17);
            uint64_t v255 = 4 * v16;
            while (1)
            {
              int v256 = v519;
              do
              {
                unsigned __int8 v257 = *v9;
                if (!*v9) {
                  goto LABEL_375;
                }
                unsigned int v258 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v257 = v258;
                  if (!(_BYTE)v258) {
                    goto LABEL_375;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v259) = -1;
LABEL_373:
                  unsigned int v260 = PDAdarkenPDA_21370(*v7, v259, v258, v257);
                  goto LABEL_374;
                }
                unsigned int v259 = *v7;
                if (*v7) {
                  goto LABEL_373;
                }
                unsigned int v260 = v258 & 0xFFFFFF00 | v257;
LABEL_374:
                *unint64_t v7 = v260;
LABEL_375:
                v9 += v253;
                v261 = &v14[v253];
                if ((unint64_t)v261 >= v21) {
                  uint64_t v262 = v254;
                }
                else {
                  uint64_t v262 = 0;
                }
                uint64_t v14 = &v261[v262];
                unint64_t v7 = (unsigned int *)((char *)v7 + v255);
                --v256;
              }
              while (v256);
              v9 += v518;
              v7 += v517;
              v263 = v520;
              v264 = &v520[v516];
              uint64_t v265 = v497;
              if ((unint64_t)v264 < v514) {
                uint64_t v265 = 0;
              }
              v266 = &v264[v265];
              uint64_t v267 = v21 + 4 * v265 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v267;
                v263 = v266;
                uint64_t v14 = v266;
              }
              BOOL v41 = v521 == 1;
              v520 = v263;
              --v521;
              if (v41) {
                return;
              }
            }
          case 17:
            uint64_t v268 = v16;
            uint64_t v269 = -(uint64_t)v18;
            uint64_t v498 = -(v516 * v17);
            uint64_t v270 = 4 * v16;
            while (1)
            {
              int v271 = v519;
              do
              {
                unsigned __int8 v272 = *v9;
                if (!*v9) {
                  goto LABEL_398;
                }
                unsigned int v273 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v272 = v273;
                  if (!(_BYTE)v273) {
                    goto LABEL_398;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v274) = -1;
LABEL_396:
                  unsigned int v275 = PDAlightenPDA_21369(*v7, v274, v273, v272);
                  goto LABEL_397;
                }
                unsigned int v274 = *v7;
                if (*v7) {
                  goto LABEL_396;
                }
                unsigned int v275 = v273 & 0xFFFFFF00 | v272;
LABEL_397:
                *unint64_t v7 = v275;
LABEL_398:
                v9 += v268;
                v276 = &v14[v268];
                if ((unint64_t)v276 >= v21) {
                  uint64_t v277 = v269;
                }
                else {
                  uint64_t v277 = 0;
                }
                uint64_t v14 = &v276[v277];
                unint64_t v7 = (unsigned int *)((char *)v7 + v270);
                --v271;
              }
              while (v271);
              v9 += v518;
              v7 += v517;
              v278 = v520;
              v279 = &v520[v516];
              uint64_t v280 = v498;
              if ((unint64_t)v279 < v514) {
                uint64_t v280 = 0;
              }
              v281 = &v279[v280];
              uint64_t v282 = v21 + 4 * v280 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v282;
                v278 = v281;
                uint64_t v14 = v281;
              }
              BOOL v41 = v521 == 1;
              v520 = v278;
              --v521;
              if (v41) {
                return;
              }
            }
          case 18:
            uint64_t v283 = v16;
            uint64_t v284 = -(uint64_t)v18;
            uint64_t v499 = -(v516 * v17);
            uint64_t v285 = 4 * v16;
            while (1)
            {
              int v286 = v519;
              do
              {
                unsigned __int8 v287 = *v9;
                if (!*v9) {
                  goto LABEL_421;
                }
                unsigned int v288 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v287 = v288;
                  if (!(_BYTE)v288) {
                    goto LABEL_421;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v289) = -1;
LABEL_419:
                  unsigned int v290 = PDAcolordodgePDA_21371(*v7, v289, v288, v287);
                  goto LABEL_420;
                }
                unsigned int v289 = *v7;
                if (*v7) {
                  goto LABEL_419;
                }
                unsigned int v290 = v288 & 0xFFFFFF00 | v287;
LABEL_420:
                *unint64_t v7 = v290;
LABEL_421:
                v9 += v283;
                v291 = &v14[v283];
                if ((unint64_t)v291 >= v21) {
                  uint64_t v292 = v284;
                }
                else {
                  uint64_t v292 = 0;
                }
                uint64_t v14 = &v291[v292];
                unint64_t v7 = (unsigned int *)((char *)v7 + v285);
                --v286;
              }
              while (v286);
              v9 += v518;
              v7 += v517;
              v293 = v520;
              v294 = &v520[v516];
              uint64_t v295 = v499;
              if ((unint64_t)v294 < v514) {
                uint64_t v295 = 0;
              }
              v296 = &v294[v295];
              uint64_t v297 = v21 + 4 * v295 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v297;
                v293 = v296;
                uint64_t v14 = v296;
              }
              BOOL v41 = v521 == 1;
              v520 = v293;
              --v521;
              if (v41) {
                return;
              }
            }
          case 19:
            uint64_t v298 = v16;
            uint64_t v299 = -(uint64_t)v18;
            uint64_t v500 = -(v516 * v17);
            uint64_t v300 = 4 * v16;
            while (1)
            {
              int v301 = v519;
              do
              {
                unsigned __int8 v302 = *v9;
                if (!*v9) {
                  goto LABEL_444;
                }
                unsigned int v303 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v302 = v303;
                  if (!(_BYTE)v303) {
                    goto LABEL_444;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v304) = -1;
LABEL_442:
                  unsigned int v305 = PDAcolorburnPDA_21372(*v7, v304, v303, v302);
                  goto LABEL_443;
                }
                unsigned int v304 = *v7;
                if (*v7) {
                  goto LABEL_442;
                }
                unsigned int v305 = v303 & 0xFFFFFF00 | v302;
LABEL_443:
                *unint64_t v7 = v305;
LABEL_444:
                v9 += v298;
                v306 = &v14[v298];
                if ((unint64_t)v306 >= v21) {
                  uint64_t v307 = v299;
                }
                else {
                  uint64_t v307 = 0;
                }
                uint64_t v14 = &v306[v307];
                unint64_t v7 = (unsigned int *)((char *)v7 + v300);
                --v301;
              }
              while (v301);
              v9 += v518;
              v7 += v517;
              v308 = v520;
              v309 = &v520[v516];
              uint64_t v310 = v500;
              if ((unint64_t)v309 < v514) {
                uint64_t v310 = 0;
              }
              v311 = &v309[v310];
              uint64_t v312 = v21 + 4 * v310 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v312;
                v308 = v311;
                uint64_t v14 = v311;
              }
              BOOL v41 = v521 == 1;
              v520 = v308;
              --v521;
              if (v41) {
                return;
              }
            }
          case 20:
            uint64_t v313 = v16;
            uint64_t v314 = -(uint64_t)v18;
            uint64_t v501 = -(v516 * v17);
            uint64_t v315 = 4 * v16;
            while (1)
            {
              int v316 = v519;
              do
              {
                unsigned __int8 v317 = *v9;
                if (!*v9) {
                  goto LABEL_467;
                }
                unsigned int v318 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v317 = v318;
                  if (!(_BYTE)v318) {
                    goto LABEL_467;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v319) = -1;
LABEL_465:
                  unsigned int v320 = PDAsoftlightPDA_21374(*v7, v319, v318, v317);
                  goto LABEL_466;
                }
                unsigned int v319 = *v7;
                if (*v7) {
                  goto LABEL_465;
                }
                unsigned int v320 = v318 & 0xFFFFFF00 | v317;
LABEL_466:
                *unint64_t v7 = v320;
LABEL_467:
                v9 += v313;
                v321 = &v14[v313];
                if ((unint64_t)v321 >= v21) {
                  uint64_t v322 = v314;
                }
                else {
                  uint64_t v322 = 0;
                }
                uint64_t v14 = &v321[v322];
                unint64_t v7 = (unsigned int *)((char *)v7 + v315);
                --v316;
              }
              while (v316);
              v9 += v518;
              v7 += v517;
              v323 = v520;
              v324 = &v520[v516];
              uint64_t v325 = v501;
              if ((unint64_t)v324 < v514) {
                uint64_t v325 = 0;
              }
              v326 = &v324[v325];
              uint64_t v327 = v21 + 4 * v325 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v327;
                v323 = v326;
                uint64_t v14 = v326;
              }
              BOOL v41 = v521 == 1;
              v520 = v323;
              --v521;
              if (v41) {
                return;
              }
            }
          case 21:
            uint64_t v328 = v16;
            uint64_t v329 = -(uint64_t)v18;
            uint64_t v502 = -(v516 * v17);
            uint64_t v330 = 4 * v16;
            while (1)
            {
              int v331 = v519;
              do
              {
                unsigned __int8 v332 = *v9;
                if (!*v9) {
                  goto LABEL_490;
                }
                unsigned int v333 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v332 = v333;
                  if (!(_BYTE)v333) {
                    goto LABEL_490;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v334) = -1;
LABEL_488:
                  unsigned int v335 = PDAhardlightPDA_21373(*v7, v334, v333, v332);
                  goto LABEL_489;
                }
                unsigned int v334 = *v7;
                if (*v7) {
                  goto LABEL_488;
                }
                unsigned int v335 = v333 & 0xFFFFFF00 | v332;
LABEL_489:
                *unint64_t v7 = v335;
LABEL_490:
                v9 += v328;
                v336 = &v14[v328];
                if ((unint64_t)v336 >= v21) {
                  uint64_t v337 = v329;
                }
                else {
                  uint64_t v337 = 0;
                }
                uint64_t v14 = &v336[v337];
                unint64_t v7 = (unsigned int *)((char *)v7 + v330);
                --v331;
              }
              while (v331);
              v9 += v518;
              v7 += v517;
              v338 = v520;
              v339 = &v520[v516];
              uint64_t v340 = v502;
              if ((unint64_t)v339 < v514) {
                uint64_t v340 = 0;
              }
              v341 = &v339[v340];
              uint64_t v342 = v21 + 4 * v340 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v342;
                v338 = v341;
                uint64_t v14 = v341;
              }
              BOOL v41 = v521 == 1;
              v520 = v338;
              --v521;
              if (v41) {
                return;
              }
            }
          case 22:
            uint64_t v343 = v16;
            uint64_t v344 = -(uint64_t)v18;
            uint64_t v503 = -(v516 * v17);
            uint64_t v345 = 4 * v16;
            while (1)
            {
              int v346 = v519;
              do
              {
                unsigned __int8 v347 = *v9;
                if (!*v9) {
                  goto LABEL_513;
                }
                unsigned int v348 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v347 = v348;
                  if (!(_BYTE)v348) {
                    goto LABEL_513;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v349) = -1;
LABEL_511:
                  unsigned int v350 = PDAdifferencePDA_21375(*v7, v349, v348, v347);
                  goto LABEL_512;
                }
                unsigned int v349 = *v7;
                if (*v7) {
                  goto LABEL_511;
                }
                unsigned int v350 = v348 & 0xFFFFFF00 | v347;
LABEL_512:
                *unint64_t v7 = v350;
LABEL_513:
                v9 += v343;
                v351 = &v14[v343];
                if ((unint64_t)v351 >= v21) {
                  uint64_t v352 = v344;
                }
                else {
                  uint64_t v352 = 0;
                }
                uint64_t v14 = &v351[v352];
                unint64_t v7 = (unsigned int *)((char *)v7 + v345);
                --v346;
              }
              while (v346);
              v9 += v518;
              v7 += v517;
              v353 = v520;
              v354 = &v520[v516];
              uint64_t v355 = v503;
              if ((unint64_t)v354 < v514) {
                uint64_t v355 = 0;
              }
              v356 = &v354[v355];
              uint64_t v357 = v21 + 4 * v355 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v357;
                v353 = v356;
                uint64_t v14 = v356;
              }
              BOOL v41 = v521 == 1;
              v520 = v353;
              --v521;
              if (v41) {
                return;
              }
            }
          case 23:
            uint64_t v358 = v16;
            uint64_t v359 = -(uint64_t)v18;
            uint64_t v504 = -(v516 * v17);
            uint64_t v360 = 4 * v16;
            while (1)
            {
              int v361 = v519;
              do
              {
                unsigned __int8 v362 = *v9;
                if (!*v9) {
                  goto LABEL_536;
                }
                unsigned int v363 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v362 = v363;
                  if (!(_BYTE)v363) {
                    goto LABEL_536;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v364) = -1;
LABEL_534:
                  unsigned int v365 = PDAexclusionPDA_21376(*v7, v364, v363, v362);
                  goto LABEL_535;
                }
                unsigned int v364 = *v7;
                if (*v7) {
                  goto LABEL_534;
                }
                unsigned int v365 = v363 & 0xFFFFFF00 | v362;
LABEL_535:
                *unint64_t v7 = v365;
LABEL_536:
                v9 += v358;
                v366 = &v14[v358];
                if ((unint64_t)v366 >= v21) {
                  uint64_t v367 = v359;
                }
                else {
                  uint64_t v367 = 0;
                }
                uint64_t v14 = &v366[v367];
                unint64_t v7 = (unsigned int *)((char *)v7 + v360);
                --v361;
              }
              while (v361);
              v9 += v518;
              v7 += v517;
              v368 = v520;
              v369 = &v520[v516];
              uint64_t v370 = v504;
              if ((unint64_t)v369 < v514) {
                uint64_t v370 = 0;
              }
              v371 = &v369[v370];
              uint64_t v372 = v21 + 4 * v370 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v372;
                v368 = v371;
                uint64_t v14 = v371;
              }
              BOOL v41 = v521 == 1;
              v520 = v368;
              --v521;
              if (v41) {
                return;
              }
            }
          case 24:
            uint64_t v373 = v16;
            uint64_t v374 = -(uint64_t)v18;
            uint64_t v505 = -(v516 * v17);
            uint64_t v375 = 4 * v16;
            while (1)
            {
              int v376 = v519;
              do
              {
                unsigned __int8 v377 = *v9;
                if (!*v9) {
                  goto LABEL_559;
                }
                unsigned int v378 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v377 = v378;
                  if (!(_BYTE)v378) {
                    goto LABEL_559;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v379) = -1;
LABEL_557:
                  unsigned int v380 = PDAhuePDA_21377(*v7, v379, v378, v377);
                  goto LABEL_558;
                }
                unsigned int v379 = *v7;
                if (*v7) {
                  goto LABEL_557;
                }
                unsigned int v380 = v378 & 0xFFFFFF00 | v377;
LABEL_558:
                *unint64_t v7 = v380;
LABEL_559:
                v9 += v373;
                v381 = &v14[v373];
                if ((unint64_t)v381 >= v21) {
                  uint64_t v382 = v374;
                }
                else {
                  uint64_t v382 = 0;
                }
                uint64_t v14 = &v381[v382];
                unint64_t v7 = (unsigned int *)((char *)v7 + v375);
                --v376;
              }
              while (v376);
              v9 += v518;
              v7 += v517;
              v383 = v520;
              v384 = &v520[v516];
              uint64_t v385 = v505;
              if ((unint64_t)v384 < v514) {
                uint64_t v385 = 0;
              }
              v386 = &v384[v385];
              uint64_t v387 = v21 + 4 * v385 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v387;
                v383 = v386;
                uint64_t v14 = v386;
              }
              BOOL v41 = v521 == 1;
              v520 = v383;
              --v521;
              if (v41) {
                return;
              }
            }
          case 25:
            uint64_t v388 = v16;
            uint64_t v389 = -(uint64_t)v18;
            uint64_t v506 = -(v516 * v17);
            uint64_t v390 = 4 * v16;
            while (1)
            {
              int v391 = v519;
              do
              {
                unsigned __int8 v392 = *v9;
                if (!*v9) {
                  goto LABEL_582;
                }
                unsigned int v393 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v392 = v393;
                  if (!(_BYTE)v393) {
                    goto LABEL_582;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v394) = -1;
LABEL_580:
                  unsigned int v395 = PDAsaturationPDA_21378(*v7, v394, v393, v392);
                  goto LABEL_581;
                }
                unsigned int v394 = *v7;
                if (*v7) {
                  goto LABEL_580;
                }
                unsigned int v395 = v393 & 0xFFFFFF00 | v392;
LABEL_581:
                *unint64_t v7 = v395;
LABEL_582:
                v9 += v388;
                v396 = &v14[v388];
                if ((unint64_t)v396 >= v21) {
                  uint64_t v397 = v389;
                }
                else {
                  uint64_t v397 = 0;
                }
                uint64_t v14 = &v396[v397];
                unint64_t v7 = (unsigned int *)((char *)v7 + v390);
                --v391;
              }
              while (v391);
              v9 += v518;
              v7 += v517;
              v398 = v520;
              v399 = &v520[v516];
              uint64_t v400 = v506;
              if ((unint64_t)v399 < v514) {
                uint64_t v400 = 0;
              }
              v401 = &v399[v400];
              uint64_t v402 = v21 + 4 * v400 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v402;
                v398 = v401;
                uint64_t v14 = v401;
              }
              BOOL v41 = v521 == 1;
              v520 = v398;
              --v521;
              if (v41) {
                return;
              }
            }
          case 26:
            uint64_t v403 = v16;
            uint64_t v404 = -(uint64_t)v18;
            uint64_t v507 = -(v516 * v17);
            uint64_t v405 = 4 * v16;
            while (1)
            {
              int v406 = v519;
              do
              {
                unsigned __int8 v407 = *v9;
                if (!*v9) {
                  goto LABEL_605;
                }
                unsigned int v408 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v407 = v408;
                  if (!(_BYTE)v408) {
                    goto LABEL_605;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v409) = -1;
LABEL_603:
                  unsigned int v410 = PDAluminosityPDA_21379(v408, v407, *v7, v409);
                  goto LABEL_604;
                }
                unsigned int v409 = *v7;
                if (*v7) {
                  goto LABEL_603;
                }
                unsigned int v410 = v408 & 0xFFFFFF00 | v407;
LABEL_604:
                *unint64_t v7 = v410;
LABEL_605:
                v9 += v403;
                v411 = &v14[v403];
                if ((unint64_t)v411 >= v21) {
                  uint64_t v412 = v404;
                }
                else {
                  uint64_t v412 = 0;
                }
                uint64_t v14 = &v411[v412];
                unint64_t v7 = (unsigned int *)((char *)v7 + v405);
                --v406;
              }
              while (v406);
              v9 += v518;
              v7 += v517;
              v413 = v520;
              v414 = &v520[v516];
              uint64_t v415 = v507;
              if ((unint64_t)v414 < v514) {
                uint64_t v415 = 0;
              }
              v416 = &v414[v415];
              uint64_t v417 = v21 + 4 * v415 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v417;
                v413 = v416;
                uint64_t v14 = v416;
              }
              BOOL v41 = v521 == 1;
              v520 = v413;
              --v521;
              if (v41) {
                return;
              }
            }
          case 27:
            uint64_t v418 = v16;
            uint64_t v419 = -(uint64_t)v18;
            uint64_t v508 = -(v516 * v17);
            uint64_t v420 = 4 * v16;
            while (1)
            {
              int v421 = v519;
              do
              {
                unsigned __int8 v422 = *v9;
                if (!*v9) {
                  goto LABEL_628;
                }
                unsigned int v423 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v422 = v423;
                  if (!(_BYTE)v423) {
                    goto LABEL_628;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v424) = -1;
LABEL_626:
                  unsigned int v425 = PDAluminosityPDA_21379(*v7, v424, v423, v422);
                  goto LABEL_627;
                }
                unsigned int v424 = *v7;
                if (*v7) {
                  goto LABEL_626;
                }
                unsigned int v425 = v423 & 0xFFFFFF00 | v422;
LABEL_627:
                *unint64_t v7 = v425;
LABEL_628:
                v9 += v418;
                v426 = &v14[v418];
                if ((unint64_t)v426 >= v21) {
                  uint64_t v427 = v419;
                }
                else {
                  uint64_t v427 = 0;
                }
                uint64_t v14 = &v426[v427];
                unint64_t v7 = (unsigned int *)((char *)v7 + v420);
                --v421;
              }
              while (v421);
              v9 += v518;
              v7 += v517;
              v428 = v520;
              v429 = &v520[v516];
              uint64_t v430 = v508;
              if ((unint64_t)v429 < v514) {
                uint64_t v430 = 0;
              }
              v431 = &v429[v430];
              uint64_t v432 = v21 + 4 * v430 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v432;
                v428 = v431;
                uint64_t v14 = v431;
              }
              BOOL v41 = v521 == 1;
              v520 = v428;
              --v521;
              if (v41) {
                return;
              }
            }
          case 28:
            uint64_t v433 = v16;
            uint64_t v434 = -(uint64_t)v18;
            uint64_t v509 = -(v516 * v17);
            uint64_t v435 = 4 * v16;
            while (1)
            {
              int v436 = v519;
              do
              {
                unsigned __int8 v437 = *v9;
                if (!*v9) {
                  goto LABEL_651;
                }
                unsigned int v438 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v437 = v438;
                  if (!(_BYTE)v438) {
                    goto LABEL_651;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v439) = -1;
LABEL_649:
                  unsigned int v440 = PDAtranspose_huePDA_21380(*v7, v439, v438, v437);
                  goto LABEL_650;
                }
                unsigned int v439 = *v7;
                if (*v7) {
                  goto LABEL_649;
                }
                unsigned int v440 = v438 & 0xFFFFFF00 | v437;
LABEL_650:
                *unint64_t v7 = v440;
LABEL_651:
                v9 += v433;
                v441 = &v14[v433];
                if ((unint64_t)v441 >= v21) {
                  uint64_t v442 = v434;
                }
                else {
                  uint64_t v442 = 0;
                }
                uint64_t v14 = &v441[v442];
                unint64_t v7 = (unsigned int *)((char *)v7 + v435);
                --v436;
              }
              while (v436);
              v9 += v518;
              v7 += v517;
              v443 = v520;
              v444 = &v520[v516];
              uint64_t v445 = v509;
              if ((unint64_t)v444 < v514) {
                uint64_t v445 = 0;
              }
              v446 = &v444[v445];
              uint64_t v447 = v21 + 4 * v445 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v447;
                v443 = v446;
                uint64_t v14 = v446;
              }
              BOOL v41 = v521 == 1;
              v520 = v443;
              --v521;
              if (v41) {
                return;
              }
            }
          case 29:
            uint64_t v448 = v16;
            uint64_t v449 = -(uint64_t)v18;
            uint64_t v510 = -(v516 * v17);
            uint64_t v450 = 4 * v16;
            while (1)
            {
              int v451 = v519;
              do
              {
                unsigned __int8 v452 = *v9;
                if (!*v9) {
                  goto LABEL_674;
                }
                unsigned int v453 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v452 = v453;
                  if (!(_BYTE)v453) {
                    goto LABEL_674;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v454) = -1;
LABEL_672:
                  unsigned int v455 = PDAtranspose_saturationPDA_21381(*v7, v454, v453, v452);
                  goto LABEL_673;
                }
                unsigned int v454 = *v7;
                if (*v7) {
                  goto LABEL_672;
                }
                unsigned int v455 = v453 & 0xFFFFFF00 | v452;
LABEL_673:
                *unint64_t v7 = v455;
LABEL_674:
                v9 += v448;
                v456 = &v14[v448];
                if ((unint64_t)v456 >= v21) {
                  uint64_t v457 = v449;
                }
                else {
                  uint64_t v457 = 0;
                }
                uint64_t v14 = &v456[v457];
                unint64_t v7 = (unsigned int *)((char *)v7 + v450);
                --v451;
              }
              while (v451);
              v9 += v518;
              v7 += v517;
              v458 = v520;
              v459 = &v520[v516];
              uint64_t v460 = v510;
              if ((unint64_t)v459 < v514) {
                uint64_t v460 = 0;
              }
              v461 = &v459[v460];
              uint64_t v462 = v21 + 4 * v460 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v462;
                v458 = v461;
                uint64_t v14 = v461;
              }
              BOOL v41 = v521 == 1;
              v520 = v458;
              --v521;
              if (v41) {
                return;
              }
            }
          case 30:
            uint64_t v463 = v16;
            uint64_t v464 = -(uint64_t)v18;
            uint64_t v511 = -(v516 * v17);
            uint64_t v465 = 4 * v16;
            while (1)
            {
              int v466 = v519;
              do
              {
                unsigned __int8 v467 = *v9;
                if (!*v9) {
                  goto LABEL_697;
                }
                unsigned int v468 = PDM_21362(*v14, *v9);
                if (v19)
                {
                  unsigned __int8 v467 = v468;
                  if (!(_BYTE)v468) {
                    goto LABEL_697;
                  }
                }
                if (!v522)
                {
                  LOBYTE(v469) = -1;
LABEL_695:
                  unsigned int v470 = PDAtranspose_luminosityPDA_21382(v468, v467, *v7, v469);
                  goto LABEL_696;
                }
                unsigned int v469 = *v7;
                if (*v7) {
                  goto LABEL_695;
                }
                unsigned int v470 = v468 & 0xFFFFFF00 | v467;
LABEL_696:
                *unint64_t v7 = v470;
LABEL_697:
                v9 += v463;
                v471 = &v14[v463];
                if ((unint64_t)v471 >= v21) {
                  uint64_t v472 = v464;
                }
                else {
                  uint64_t v472 = 0;
                }
                uint64_t v14 = &v471[v472];
                unint64_t v7 = (unsigned int *)((char *)v7 + v465);
                --v466;
              }
              while (v466);
              v9 += v518;
              v7 += v517;
              v473 = v520;
              v474 = &v520[v516];
              uint64_t v475 = v511;
              if ((unint64_t)v474 < v514) {
                uint64_t v475 = 0;
              }
              v476 = &v474[v475];
              uint64_t v477 = v21 + 4 * v475 + 4 * v516;
              if (v515)
              {
                v14 += v516;
              }
              else
              {
                unint64_t v21 = v477;
                v473 = v476;
                uint64_t v14 = v476;
              }
              BOOL v41 = v521 == 1;
              v520 = v473;
              --v521;
              if (v41) {
                return;
              }
            }
          case 31:
            uint64_t v478 = v16;
            uint64_t v479 = -(uint64_t)v18;
            uint64_t v512 = -(v516 * v17);
            uint64_t v480 = 4 * v16;
            break;
          default:
            return;
        }
LABEL_710:
        int v481 = v519;
        while (1)
        {
          unsigned __int8 v482 = *v9;
          if (*v9)
          {
            unsigned int v483 = PDM_21362(*v14, *v9);
            if (!v19) {
              break;
            }
            unsigned __int8 v482 = v483;
            if ((_BYTE)v483) {
              break;
            }
          }
LABEL_720:
          v9 += v478;
          v486 = &v14[v478];
          if ((unint64_t)v486 >= v21) {
            uint64_t v487 = v479;
          }
          else {
            uint64_t v487 = 0;
          }
          uint64_t v14 = &v486[v487];
          unint64_t v7 = (unsigned int *)((char *)v7 + v480);
          if (!--v481)
          {
            v9 += v518;
            v7 += v517;
            v488 = v520;
            v489 = &v520[v516];
            uint64_t v490 = v512;
            if ((unint64_t)v489 < v514) {
              uint64_t v490 = 0;
            }
            v491 = &v489[v490];
            uint64_t v492 = v21 + 4 * v490 + 4 * v516;
            if (v515)
            {
              v14 += v516;
            }
            else
            {
              unint64_t v21 = v492;
              v488 = v491;
              uint64_t v14 = v491;
            }
            BOOL v41 = v521 == 1;
            v520 = v488;
            --v521;
            if (v41) {
              return;
            }
            goto LABEL_710;
          }
        }
        if (v522)
        {
          unsigned int v484 = *v7;
          if (!*v7)
          {
            unsigned int v485 = v483 & 0xFFFFFF00 | v482;
LABEL_719:
            *unint64_t v7 = v485;
            goto LABEL_720;
          }
        }
        else
        {
          LOBYTE(v484) = -1;
        }
        unsigned int v485 = PDAtranspose_luminosityPDA_21382(*v7, v484, v483, v482);
        goto LABEL_719;
      }
      uint64_t v14 = 0;
      unint64_t v21 = 0;
      int v16 = 1;
LABEL_15:
      unint64_t v514 = 0;
      v520 = 0;
      uint64_t v516 = v13 - v3;
      int v515 = 1;
      goto LABEL_16;
    }
    uint64_t v13 = v12 >> 2;
    uint64_t v14 = (unsigned int *)(v4 + 4 * (v10 + v13 * v11));
    if (v13 != v6)
    {
      int v16 = 1;
LABEL_14:
      int v17 = 0;
      uint64_t v3 = v16 * v519;
      BOOL v19 = v5 != 0;
      unint64_t v517 = v6 - v3;
      uint64_t v518 = v8 - v3;
      unint64_t v21 = -1;
      int v18 = v13;
      goto LABEL_15;
    }
    if ((char *)v7 - (char *)v14 >= 1)
    {
      if (v519 >= (uint64_t)((unint64_t)((char *)v7 - (char *)v14) >> 2))
      {
        v7 += v519 - 1;
        v14 += v519 - 1;
        v9 += v519 - 1;
        int v16 = -1;
        goto LABEL_13;
      }
      uint64_t v15 = *(int *)(a1 + 8) - 1;
      if (v7 <= &v14[v6 * v15 - 1 + v519])
      {
        v7 += v6 * v15;
        uint64_t v13 = -(uint64_t)v6;
        v9 += v8 * v15;
        uint64_t v8 = -v8;
        int v16 = 1;
        v14 += v6 * v15;
        unint64_t v6 = -(uint64_t)v6;
        goto LABEL_14;
      }
    }
    int v16 = 1;
LABEL_13:
    uint64_t v13 = (unint64_t)*(int *)(a1 + 28) >> 2;
    goto LABEL_14;
  }
}

unsigned int *DMplusDAM_21388(unsigned int *result, unsigned int a2, int a3, unsigned int a4, unsigned int a5, int a6)
{
  unsigned int v6 = (unsigned __int16)(BYTE1(a4) * (_WORD)a6) + (unsigned __int16)(BYTE1(a2) * (_WORD)a3);
  unsigned int v7 = ((((a4 >> 8) & 0xFF00FF) * a6) >> 16) + ((((a2 >> 8) & 0xFF00FF) * a3) >> 16);
  if (v6 >= 0xFE79) {
    unsigned int v6 = 65145;
  }
  if (v7 >= 0xFE79) {
    unsigned int v7 = 65145;
  }
  unsigned int v8 = (a2 & 0xFF00FF) * a3;
  unsigned int v9 = (unsigned __int16)(a5 * a6) + (unsigned __int16)v8;
  unsigned int v10 = (((a4 & 0xFF0000 | a5) * a6) >> 16) + HIWORD(v8);
  if (v9 >= 0xFE79) {
    int v11 = 65145;
  }
  else {
    int v11 = v9;
  }
  if (v10 >= 0xFE79) {
    int v12 = 65145;
  }
  else {
    int v12 = v10;
  }
  int *result = ((((((v11 | (v12 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v11 | (v12 << 16)) + 8388736) >> 8) & 0xFF00FF | (((((v6 | (v7 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v6 | (v7 << 16)) + 8388736) & 0xFF00FF00;
  return result;
}

uint64_t PIXELCONSTANT_21389(float *a1, int a2, float *a3, float a4)
{
  float v4 = *a1;
  float v5 = a1[1];
  float v6 = v5;
  if (v5 >= a4)
  {
    float v6 = a4;
    if (v4 > a4) {
      float v6 = *a1;
    }
  }
  float v7 = a1[3];
  float v8 = v6 * a1[2];
  if (a3) {
    int v9 = a2;
  }
  else {
    int v9 = 0;
  }
  if (v9 == 1)
  {
    if (*a3 >= v4) {
      float v4 = *a3;
    }
    if (*a3 > v5) {
      float v4 = a1[1];
    }
    int v10 = (int)(float)(v7 + (float)(v4 * v8));
    int v11 = v10;
    int v12 = v10;
  }
  else
  {
    if (v9 == 4)
    {
      float v19 = a3[4];
      float v20 = *a3;
      float v21 = a3[1];
      float v22 = a3[2];
      if (v19 < v4) {
        float v23 = *a1;
      }
      else {
        float v23 = a3[4];
      }
      if (v19 <= v5) {
        float v24 = v23;
      }
      else {
        float v24 = a1[1];
      }
      if (v20 < v4) {
        float v25 = *a1;
      }
      else {
        float v25 = *a3;
      }
      if (v20 <= v5) {
        float v26 = v25;
      }
      else {
        float v26 = a1[1];
      }
      if (v21 < v4) {
        float v27 = *a1;
      }
      else {
        float v27 = a3[1];
      }
      if (v21 <= v5) {
        float v28 = v27;
      }
      else {
        float v28 = a1[1];
      }
      if (v22 < v4) {
        float v29 = *a1;
      }
      else {
        float v29 = a3[2];
      }
      if (v22 <= v5) {
        float v30 = v29;
      }
      else {
        float v30 = a1[1];
      }
      float v31 = (float)(v5 - v26) - v24;
      float v32 = (float)(v5 - v28) - v24;
      float v33 = (float)(v5 - v30) - v24;
      float v34 = v7 + (float)(v31 * v8);
      if (v31 < v4) {
        float v34 = *a1;
      }
      float v35 = v7 + (float)(v32 * v8);
      if (v32 < v4) {
        float v35 = *a1;
      }
      if (v33 >= v4) {
        float v4 = v7 + (float)(v33 * v8);
      }
      int v10 = (int)v34;
      int v11 = (int)v35;
      goto LABEL_63;
    }
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
    if (v9 == 3)
    {
      float v13 = a3[1];
      float v14 = a3[2];
      if (*a3 < v4) {
        float v15 = *a1;
      }
      else {
        float v15 = *a3;
      }
      if (*a3 <= v5) {
        float v16 = v15;
      }
      else {
        float v16 = a1[1];
      }
      if (v13 < v4) {
        float v17 = *a1;
      }
      else {
        float v17 = a3[1];
      }
      if (v13 <= v5) {
        float v18 = v17;
      }
      else {
        float v18 = a1[1];
      }
      if (v14 >= v4) {
        float v4 = a3[2];
      }
      if (v14 > v5) {
        float v4 = a1[1];
      }
      int v10 = (int)(float)(v7 + (float)(v16 * v8));
      int v11 = (int)(float)(v7 + (float)(v18 * v8));
      float v4 = v7 + (float)(v4 * v8);
LABEL_63:
      int v12 = (int)v4;
    }
  }
  return (int)(float)(v7 + v8) | (v10 << 24) | (v11 << 16) | (v12 << 8);
}

uint64_t ARGB32_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if (v11 >= 24 && *(_DWORD *)v8 == 134755144) {
    v11 += 4;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x3000000)
  {
    if (*(void *)(v5 + 16))
    {
      float v14 = ARGB32_shade_radial_RGB;
    }
    else if (*(void *)(v5 + 24))
    {
      float v14 = ARGB32_shade_conic_RGB;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      float v14 = ARGB32_shade_axial_RGB;
    }
    else
    {
      float v14 = ARGB32_shade_custom_RGB;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 3, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 480)
    {
      float v16 = v44;
      v38[1] = v44;
LABEL_30:
      _blt_shade_samples_16((uint64_t)v16, 2, 3, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_32;
    }
    float v16 = malloc_type_malloc(8 * v15 + 32, 0xE83E6668uLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_30;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_32:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  rgba32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

void ARGB32_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12)
{
  float v12 = *(float *)(a1 + 280);
  float v13 = *(float *)(a1 + 296)
      + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
              + (float)(v12 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  uint64_t v14 = a1 + 368;
  uint64_t v15 = *(void *)(a1 + 368);
  uint64_t v16 = ((unint64_t)a3 >> 4) & 0xF0;
  uint64_t v17 = v15 + v16;
  if (v15) {
    uint64_t v18 = v15 + v16;
  }
  else {
    uint64_t v18 = a1 + 368;
  }
  if (v15) {
    char v19 = 15;
  }
  else {
    char v19 = 0;
  }
  float v21 = *(float *)(a1 + 336);
  float v22 = *(float *)(a1 + 344);
  float v23 = *(float *)(a1 + 304);
  float v24 = *(float *)(a1 + 308);
  int v25 = *(_DWORD *)(a1 + 320);
  int v26 = *(_DWORD *)(a1 + 324);
  uint64_t v29 = a1 + 144;
  long long v27 = *(_DWORD **)(a1 + 144);
  uint64_t v28 = *(void *)(v29 + 8);
  long long v30 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v31 = *(void *)(a1 + 360);
  if (v12 != 0.0)
  {
    if (v15) {
      unsigned int v37 = (a2 >> 8) & 0xF;
    }
    else {
      LOBYTE(v37) = 0;
    }
    while (1)
    {
      int v38 = v25;
      if (v13 >= v23)
      {
        int v38 = v26;
        if (v13 <= v24) {
          int v38 = (int)(float)(v22 * (float)(v13 - v21));
        }
      }
      if (v38 < 0)
      {
        if (!v30)
        {
          char v49 = 0;
          goto LABEL_40;
        }
        __int16 v48 = *(unsigned __int8 *)(v18 + v37);
        __int16 v44 = v48 + *v30;
        __int16 v45 = v48 + v30[1];
        __int16 v46 = v48 + v30[2];
        __int16 v47 = v48 + v30[3];
      }
      else
      {
        long long v39 = (_WORD *)(v31 + 8 * v38);
        __int16 v40 = v39[1];
        __int16 v41 = *(unsigned __int8 *)(v18 + v37);
        __int16 v42 = v39[2];
        __int16 v43 = v39[3];
        __int16 v44 = v41 + *v39;
        __int16 v45 = v41 + v40;
        __int16 v46 = v41 + v42;
        __int16 v47 = v41 + v43;
      }
      *(_DWORD *)uint64_t v28 = v44 & 0xFF00 | (HIBYTE(v45) << 16) & 0xFFFF00 | (HIBYTE(v46) << 24) | HIBYTE(v47);
      char v49 = -1;
LABEL_40:
      LOBYTE(v37) = (v37 + 1) & v19;
      float v13 = v12 + v13;
      v28 += 4;
      *(unsigned char *)long long v27 = v49;
      long long v27 = (_DWORD *)((char *)v27 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v15) {
    uint64_t v32 = v17;
  }
  else {
    uint64_t v32 = v14;
  }
  if (v15) {
    LODWORD(v33) = ((a2 >> 8) + 1) & 0xF;
  }
  else {
    LODWORD(v33) = 0;
  }
  if (v15) {
    LODWORD(v34) = (a2 >> 8) & 0xF;
  }
  else {
    LODWORD(v34) = 0;
  }
  if (v15) {
    int v35 = 15;
  }
  else {
    int v35 = 0;
  }
  if (v13 >= v23)
  {
    int v25 = v26;
    if (v13 <= v24) {
      int v25 = (int)(float)(v22 * (float)(v13 - v21));
    }
  }
  if ((v25 & 0x80000000) == 0 || v30)
  {
    uint64_t v50 = (unsigned __int16 *)(v31 + 8 * v25);
    if (v25 < 0) {
      uint64_t v51 = v30;
    }
    else {
      uint64_t v51 = v50;
    }
    unsigned int v52 = *v51;
    unsigned int v53 = v51[3];
    unsigned int v54 = v51[2];
    unsigned int v55 = v51[1];
    if (v15)
    {
      int32x2_t v56 = vdup_n_s32(v52);
      int32x2_t v57 = vdup_n_s32(v55);
      int v58 = a4 + 4;
      int32x2_t v59 = vdup_n_s32(v54);
      int32x2_t v60 = vdup_n_s32(v53);
      do
      {
        unsigned int v61 = (__int8 *)(v32 + v34);
        uint64_t v34 = (v34 + 1) & v35;
        a12.i8[0] = *v61;
        a12.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v62 = (int32x2_t)vand_s8(a12, (int8x8_t)0xFF000000FFLL);
        int8x8_t v63 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v57, v62), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v56, v62), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v59, v62), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v60, v62), 8uLL) & 0xFFFFFEFFFFFFFEFFLL)));
        *(int8x8_t *)uint64_t v28 = v63;
        uint64_t v33 = (v33 + 1) & v35;
        v63.i8[0] = *(unsigned char *)(v32 + v34);
        v63.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v64 = (int32x2_t)vand_s8(v63, (int8x8_t)0xFF000000FFLL);
        a12 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v57, v64), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v56, v64), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v59, v64), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v60, v64), 8uLL) & 0xFFFFFEFFFFFFFEFFLL)));
        *(double *)(v28 + 8) = *(double *)&a12;
        *v27++ = -1;
        v58 -= 4;
        v28 += 16;
      }
      while (v58 > 4);
    }
    else
    {
      int32x4_t v65 = vdupq_n_s32(v52 & 0xFF00 | (v53 >> 8) & 0xFF00FFFF | (BYTE1(v54) << 24) | (BYTE1(v55) << 16));
      int v66 = a4 + 4;
      do
      {
        *(int32x4_t *)uint64_t v28 = v65;
        v28 += 16;
        *v27++ = -1;
        v66 -= 4;
      }
      while (v66 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v36 = 4;
    }
    else {
      int v36 = a4;
    }
    bzero(v27, ((a4 - v36 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t ARGB32_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(result + 280);
  float v5 = *(float *)(*(void *)(result + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = result + 368;
  uint64_t v10 = *(void *)(result + 368);
  int v11 = 15;
  if (v10) {
    uint64_t v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(result + 284);
  float v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  float v14 = *(float *)(result + 304);
  float v15 = *(float *)(result + 308);
  float v16 = *(float *)(result + 312);
  float v17 = *(float *)(result + 316);
  float v18 = *(float *)(result + 336);
  float v19 = *(float *)(result + 348);
  float v20 = *(float *)(result + 344);
  float v21 = *(float *)(result + 356);
  float v22 = *(_WORD **)(result + 376);
  uint64_t v23 = *(void *)(result + 360);
  int v24 = 4 * *(_DWORD *)(result + 48);
  if (v10) {
    uint64_t v25 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v25 = 0;
  }
  long long v27 = *(char **)(result + 144);
  int v26 = *(int **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      int v35 = (_WORD *)(v23
                    + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19))
                    + 8 * (int)(float)(v20 * (float)(v8 - v18)));
      __int16 v36 = v35[1];
      int v37 = *(unsigned __int8 *)(v9 + v25);
      __int16 v38 = v35[2];
      int v39 = (unsigned __int16)v35[3];
      __int16 v32 = v37 + *v35;
      __int16 v33 = v37 + v36;
      __int16 v34 = v37 + v38;
      int32x2_t result = (v37 + v39);
      goto LABEL_21;
    }
    if (v22)
    {
      int v31 = *(unsigned __int8 *)(v9 + v25);
      __int16 v32 = v31 + *v22;
      __int16 v33 = v31 + v22[1];
      __int16 v34 = v31 + v22[2];
      int32x2_t result = v31 + (unsigned __int16)v22[3];
LABEL_21:
      *int v26 = v32 & 0xFF00 | (HIBYTE(v33) << 16) & 0xFFFF00 | (HIBYTE(v34) << 24) | BYTE1(result);
      char v40 = -1;
      goto LABEL_22;
    }
    char v40 = 0;
LABEL_22:
    uint64_t v25 = (v25 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    ++v26;
    *v27++ = v40;
    --a4;
  }
  while (a4);
  return result;
}

void ARGB32_shade_conic_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = *(void *)(a1 + 368);
  if (v9) {
    uint64_t v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v10 = a1 + 368;
  }
  if (v9) {
    int v11 = 15;
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(a1 + 284);
  float v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  float v32 = *(float *)(a1 + 336);
  float v33 = *(float *)(a1 + 304);
  float v15 = *(float *)(a1 + 344);
  uint64_t v16 = *(void *)(a1 + 360);
  float v18 = *(unsigned char **)(a1 + 144);
  float v17 = *(unsigned int **)(a1 + 152);
  if (v9) {
    uint64_t v19 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v19 = 0;
  }
  float v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    float v21 = v15 * (float)((float)(v33 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v32);
    unsigned int v22 = vcvtms_s32_f32(v21);
    float v23 = ceilf(v21);
    float v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    unsigned int v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0) {
      unsigned int v22 = v25;
    }
    float v26 = ceilf(v21 - v15);
    if (v21 <= v15) {
      float v27 = v23;
    }
    else {
      float v27 = v26;
    }
    uint64_t v28 = (unsigned __int16 *)(v16 + 2 * (int)(4 * v22));
    int v29 = 255 - (int)v24;
    long long v30 = (unsigned __int16 *)(v16 + 8 * (int)v27);
    int v31 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = ((int)v24 * v30[1] + (v31 << 8) + v29 * v28[1]) & 0xFF0000 | (v31
                                                                         + (((int)v24 * *v30 + v29 * *v28) >> 8)) & 0xFF00 | (((unsigned __int16)(v31 + (((int)v24 * v30[2] + v29 * v28[2]) >> 8)) >> 8) << 24) | ((unsigned __int16)(v31 + (((int)v24 * v30[3] + v29 * v28[3]) >> 8)) >> 8);
    uint64_t v19 = (v19 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
}

void ARGB32_shade_radial_RGB(uint64_t a1, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float v13 = *(float *)(a1 + 280);
  float v14 = *(float *)(a1 + 284);
  float v15 = *(float *)(*(void *)(a1 + 272) + 4);
  float v16 = v15 * (float)a2;
  float v17 = v15 * (float)(uint64_t)a3;
  float v18 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v17) + (float)(v13 * v16));
  float v19 = *(float *)(a1 + 300) + (float)((float)(v17 * *(float *)(a1 + 292)) + (float)(v14 * v16));
  uint64_t v21 = *(void *)(a1 + 400);
  float v22 = *(float *)(a1 + 336);
  float v23 = *(float *)(a1 + 344);
  float v24 = *(float *)(a1 + 304);
  float v25 = *(float *)(a1 + 308);
  int v26 = *(_DWORD *)(a1 + 324);
  LODWORD(a12) = *(_DWORD *)(v21 + 8);
  float v27 = *(float *)(v21 + 16);
  float v28 = *(float *)(v21 + 20);
  float v29 = *(float *)(v21 + 28);
  uint64_t v32 = a1 + 144;
  long long v30 = *(char **)(a1 + 144);
  uint64_t v31 = *(void *)(v32 + 8);
  float v33 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v34 = *(void *)(a1 + 360);
  uint64_t v35 = ((unint64_t)a2 >> 8) & 0xF;
  if (*(float *)&a12 != 0.0 || v29 != 0.0 || v14 != 0.0)
  {
    int v47 = *(_DWORD *)(a1 + 320);
    float v48 = *(float *)(v21 + 12);
    float v49 = *(float *)(v21 + 24);
    float v50 = *(float *)(v21 + 32);
    uint64_t v51 = a1 + 368;
    uint64_t v52 = *(void *)(a1 + 368);
    uint64_t v53 = v52 + ((a3 >> 4) & 0xF0);
    BOOL v39 = v52 == 0;
    int v54 = 15;
    if (v39)
    {
      int v54 = 0;
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v51 = v53;
    }
    float v55 = -v49;
    float v56 = v25 - v24;
    while (1)
    {
      float v57 = v55 + (float)((float)(v18 + v18) * *(float *)&a12);
      float v58 = (float)((float)(v19 * v19) + (float)(v18 * v18)) - v29;
      if (v28 == 0.0)
      {
        float v65 = v58 / v57;
      }
      else
      {
        float v59 = (float)((float)(v28 * -4.0) * v58) + (float)(v57 * v57);
        if (v59 < 0.0) {
          goto LABEL_56;
        }
        float v60 = sqrtf(v59);
        float v61 = v50 * (float)(v57 - v60);
        float v62 = v57 + v60;
        float v63 = v50 * v62;
        BOOL v64 = (float)(v50 * v62) <= v61;
        if ((float)(v50 * v62) <= v61) {
          float v65 = v50 * v62;
        }
        else {
          float v65 = v61;
        }
        if (v64) {
          float v63 = v61;
        }
        if (v63 < 0.0)
        {
          BOOL v66 = v63 < v48;
LABEL_42:
          int v67 = v47;
          if (v66) {
            goto LABEL_56;
          }
LABEL_43:
          if ((v67 & 0x80000000) == 0) {
            goto LABEL_55;
          }
          goto LABEL_56;
        }
        if (v63 <= 1.0)
        {
          float v68 = v24 + (float)(v63 * v56);
          goto LABEL_54;
        }
        if ((v26 & 0x80000000) == 0)
        {
          int v67 = v26;
          if (v63 <= v27)
          {
LABEL_55:
            uint64_t v69 = (_WORD *)(v34 + 8 * v67);
            __int16 v70 = v69[1];
            __int16 v71 = *(unsigned __int8 *)(v51 + v35);
            __int16 v72 = v69[2];
            __int16 v73 = v69[3];
            __int16 v74 = v71 + *v69;
            __int16 v75 = v71 + v70;
            __int16 v76 = v71 + v72;
            __int16 v77 = v71 + v73;
            goto LABEL_58;
          }
        }
      }
      if (v65 < 0.0)
      {
        BOOL v66 = v65 < v48;
        goto LABEL_42;
      }
      if (v65 > 1.0)
      {
        int v67 = v26;
        if (v65 > v27) {
          goto LABEL_56;
        }
        goto LABEL_43;
      }
      float v68 = v24 + (float)(v65 * v56);
LABEL_54:
      int v67 = (int)(float)(v23 * (float)(v68 - v22));
      if ((v67 & 0x80000000) == 0) {
        goto LABEL_55;
      }
LABEL_56:
      if (!v33)
      {
        char v79 = 0;
        goto LABEL_60;
      }
      __int16 v78 = *(unsigned __int8 *)(v51 + v35);
      __int16 v74 = v78 + *v33;
      __int16 v75 = v78 + v33[1];
      __int16 v76 = v78 + v33[2];
      __int16 v77 = v78 + v33[3];
LABEL_58:
      *(_DWORD *)uint64_t v31 = v74 & 0xFF00 | (HIBYTE(v75) << 16) & 0xFFFF00 | (HIBYTE(v76) << 24) | HIBYTE(v77);
      char v79 = -1;
LABEL_60:
      uint64_t v35 = (v35 + 1) & v54;
      float v18 = v13 + v18;
      float v19 = v14 + v19;
      v31 += 4;
      *v30++ = v79;
      if (!--a4) {
        return;
      }
    }
  }
  uint64_t v36 = a1 + 368;
  uint64_t v37 = *(void *)(a1 + 368);
  int v38 = (BYTE1(a2) + 1) & 0xF;
  BOOL v39 = v37 == 0;
  if (v37) {
    uint64_t v40 = v37 + ((a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v40 = v36;
  }
  if (v39) {
    LODWORD(v41) = 0;
  }
  else {
    LODWORD(v41) = v38;
  }
  if (v39) {
    LODWORD(v42) = 0;
  }
  else {
    LODWORD(v42) = v35;
  }
  if (v39) {
    int v43 = 0;
  }
  else {
    int v43 = 15;
  }
  float v44 = v19 * v19;
  float v45 = -v28;
  if (v44 <= (float)-v28)
  {
    float v80 = fabsf(*(float *)(v21 + 32));
    float v81 = v28 * -4.0;
    float v82 = v25 - v24;
    uint64_t v83 = (unsigned __int16 *)(v34 + 8 * v26);
    int v84 = a4 + 2;
    while (1)
    {
      float v85 = v44 + (float)(v18 * v18);
      float v86 = v13 + v18;
      float v87 = v44 + (float)(v86 * v86);
      if (v85 > v45 && v87 > v45)
      {
        if (v26 < 0)
        {
          if (!v33)
          {
            char v121 = 0;
            char v120 = 0;
            goto LABEL_84;
          }
          unsigned __int16 v96 = *v33;
          int v97 = v33[1];
          int v98 = v33[2];
          unsigned __int16 v99 = v33[3];
        }
        else
        {
          unsigned __int16 v96 = *v83;
          int v97 = v83[1];
          int v98 = v83[2];
          unsigned __int16 v99 = v83[3];
        }
        int v114 = *(unsigned __int8 *)(v40 + v42);
        __int16 v115 = v114 + v96;
        unsigned int v116 = (v114 + v97) >> 8;
        unsigned int v117 = (v114 + v98) >> 8;
        __int16 v118 = v114 + v99;
        __int16 v119 = *(unsigned __int8 *)(v40 + v41);
        __int16 v110 = v119 + v96;
        __int16 v111 = v119 + v97;
        __int16 v112 = v119 + v98;
        __int16 v113 = v119 + v99;
        *(_DWORD *)uint64_t v31 = v115 & 0xFF00 | (v116 << 16) & 0xFFFF00 | (v117 << 24) | HIBYTE(v118);
        goto LABEL_82;
      }
      float v89 = sqrtf(v81 * v87);
      float v90 = v80 * sqrtf(v81 * v85);
      float v91 = v80 * v89;
      int v92 = (int)(float)(v23 * (float)((float)(v24 + (float)(v90 * v82)) - v22));
      int v93 = (int)(float)(v23 * (float)((float)(v24 + (float)((float)(v80 * v89) * v82)) - v22));
      if (v90 <= 1.0 && v91 <= 1.0)
      {
        unsigned int v100 = (_WORD *)(v34 + 8 * v92);
        unint64_t v101 = (__int16 *)(v34 + 8 * v93);
        __int16 v102 = *v101;
        __int16 v103 = v101[1];
        __int16 v104 = v101[2];
        __int16 v105 = v101[3];
        LODWORD(v101) = *(unsigned __int8 *)(v40 + v42);
        __int16 v106 = (_WORD)v101 + *v100;
        unsigned int v107 = (v101 + (unsigned __int16)v100[1]) >> 8;
        unsigned int v108 = (v101 + (unsigned __int16)v100[2]) >> 8;
        LOWORD(v100) = (_WORD)v101 + v100[3];
        __int16 v109 = *(unsigned __int8 *)(v40 + v41);
        __int16 v110 = v109 + v102;
        __int16 v111 = v109 + v103;
        __int16 v112 = v109 + v104;
        __int16 v113 = v109 + v105;
        *(_DWORD *)uint64_t v31 = v106 & 0xFF00 | (v107 << 16) & 0xFFFF00 | (v108 << 24) | BYTE1(v100);
LABEL_82:
        char v120 = -1;
        goto LABEL_83;
      }
      if (v90 <= 1.0)
      {
        if ((v92 & 0x80000000) == 0)
        {
          uint64_t v95 = 4 * v92;
LABEL_88:
          uint64_t v122 = (_WORD *)(v34 + 2 * v95);
          __int16 v123 = v122[1];
          __int16 v124 = *(unsigned __int8 *)(v40 + v42);
          __int16 v125 = v122[2];
          __int16 v126 = v122[3];
          __int16 v127 = v124 + *v122;
          __int16 v128 = v124 + v123;
          __int16 v129 = v124 + v125;
          __int16 v130 = v124 + v126;
          goto LABEL_91;
        }
      }
      else if (v90 <= v27)
      {
        uint64_t v95 = 4 * v26;
        if ((v26 & 0x80000000) == 0) {
          goto LABEL_88;
        }
      }
      if (!v33)
      {
        char v120 = 0;
        goto LABEL_92;
      }
      __int16 v131 = *(unsigned __int8 *)(v40 + v42);
      __int16 v127 = v131 + *v33;
      __int16 v128 = v131 + v33[1];
      __int16 v129 = v131 + v33[2];
      __int16 v130 = v131 + v33[3];
LABEL_91:
      *(_DWORD *)uint64_t v31 = v127 & 0xFF00 | (HIBYTE(v128) << 16) & 0xFFFF00 | (HIBYTE(v129) << 24) | HIBYTE(v130);
      char v120 = -1;
LABEL_92:
      if (v91 <= 1.0)
      {
        if (v93 < 0) {
          goto LABEL_99;
        }
        uint64_t v132 = 4 * v93;
      }
      else if (v91 > v27 || (uint64_t v132 = 4 * v26, v26 < 0))
      {
LABEL_99:
        if (!v33)
        {
          char v121 = 0;
          goto LABEL_84;
        }
        __int16 v138 = *(unsigned __int8 *)(v40 + v41);
        __int16 v110 = v138 + *v33;
        __int16 v111 = v138 + v33[1];
        __int16 v112 = v138 + v33[2];
        __int16 v113 = v138 + v33[3];
        goto LABEL_83;
      }
      uint64_t v133 = (_WORD *)(v34 + 2 * v132);
      __int16 v134 = v133[1];
      __int16 v135 = *(unsigned __int8 *)(v40 + v41);
      __int16 v136 = v133[2];
      __int16 v137 = v133[3];
      __int16 v110 = v135 + *v133;
      __int16 v111 = v135 + v134;
      __int16 v112 = v135 + v136;
      __int16 v113 = v135 + v137;
LABEL_83:
      *(_DWORD *)(v31 + 4) = v110 & 0xFF00 | (HIBYTE(v111) << 16) & 0xFFFF00 | (HIBYTE(v112) << 24) | HIBYTE(v113);
      char v121 = -1;
LABEL_84:
      float v18 = v13 + v86;
      LOBYTE(v42) = (v42 + 1) & v43;
      LOBYTE(v41) = (v41 + 1) & v43;
      v31 += 8;
      *long long v30 = v120;
      v30[1] = v121;
      v30 += 2;
      v84 -= 2;
      if (v84 <= 2) {
        return;
      }
    }
  }
  if (v33 || (v26 & 0x80000000) == 0)
  {
    int v139 = (unsigned __int16 *)(v34 + 8 * v26);
    if (v26 >= 0) {
      int v140 = v139;
    }
    else {
      int v140 = v33;
    }
    int32x2_t v141 = vdup_n_s32(v140[1]);
    int32x2_t v142 = vdup_n_s32(*v140);
    int32x2_t v143 = vdup_n_s32(v140[2]);
    int32x2_t v144 = vdup_n_s32(v140[3]);
    int v145 = a4 + 4;
    do
    {
      uint64_t v146 = (unsigned char *)(v40 + v42);
      uint64_t v42 = (v42 + 1) & v43;
      LOBYTE(a12) = *v146;
      BYTE4(a12) = *(unsigned char *)(v40 + v41);
      int32x2_t v147 = (int32x2_t)vand_s8(*(int8x8_t *)&a12, (int8x8_t)0xFF000000FFLL);
      int8x8_t v148 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v141, v147), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v142, v147), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v143, v147), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v144, v147), 8uLL) & 0xFFFFFEFFFFFFFEFFLL)));
      *(int8x8_t *)uint64_t v31 = v148;
      uint64_t v41 = (v41 + 1) & v43;
      v148.i8[0] = *(unsigned char *)(v40 + v42);
      v148.i8[4] = *(unsigned char *)(v40 + v41);
      int32x2_t v149 = (int32x2_t)vand_s8(v148, (int8x8_t)0xFF000000FFLL);
      a12 = COERCE_DOUBLE(vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v141, v149), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v142, v149), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v143, v149), 0x10uLL) & 0xFF00FFFFFF00FFFFLL), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v144, v149), 8uLL) & 0xFFFFFEFFFFFFFEFFLL))));
      *(double *)(v31 + 8) = a12;
      *(_DWORD *)long long v30 = -1;
      v30 += 4;
      v145 -= 4;
      v31 += 16;
    }
    while (v145 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v46 = 4;
    }
    else {
      int v46 = a4;
    }
    bzero(v30, ((a4 - v46 + 3) & 0xFFFFFFFC) + 4);
  }
}

void ARGB32_mark_image_RGB48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v37 = a2;
  uint64_t v9 = *(unsigned int *)(a1 + 28);
  uint64_t v10 = (int)v9;
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v41 = v12;
  int v42 = v11;
  float v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v43) = *(_DWORD *)(a1 + 108);
    HIDWORD(v43) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v43, v11, v12);
    float v16 = v15;
    if (v15) {
      goto LABEL_24;
    }
  }
  int v17 = 0;
  int v18 = 0;
  float v16 = 0;
  uint64_t v43 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertRGB16toARGB8888", 487, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertRGB16toARGB8888", 487, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v12);
    }
    uint64_t v40 = v16;
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v37);
    uint64_t v21 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    uint64_t v22 = v19 * (uint64_t)a4;
    uint64_t v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      uint64_t v24 = v10;
      v21 += v23 * v10;
      uint64_t v25 = v9;
      int v26 = -(int)v9;
    }
    else
    {
      uint64_t v24 = v10;
      uint64_t v25 = v9;
      int v26 = v9;
    }
    unint64_t v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    float v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      int v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      float v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21) {
        float v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0x7F3B0B10uLL);
      }
    }
    if (v12 >= 1)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (v11 >= 1)
        {
          uint64_t v31 = &v28[i * v26];
          int v32 = v11;
          float v33 = (char *)(v20 + i * (int)v22);
          do
          {
            char v34 = *v33;
            char v35 = v33[2];
            char v36 = v33[4];
            *uint64_t v31 = -1;
            v31[1] = v34;
            v31[2] = v35;
            v31[3] = v36;
            v33 += 6;
            v31 += 4;
            --v32;
          }
          while (v32);
        }
      }
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    uint64_t v10 = v24;
    uint64_t v9 = v25;
    float v16 = v40;
    if (!v40) {
      break;
    }
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v43 + 1, &v43, &v42, &v41))
    {
      free(v16);
      return;
    }
    int v18 = v43;
    int v17 = HIDWORD(v43);
    int v12 = v41;
    int v11 = v42;
    if (v42 < 0) {
      goto LABEL_4;
    }
  }
}

void ARGB32_mark_image_rgb48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v38 = a2;
  uint64_t v9 = *(unsigned int *)(a1 + 28);
  uint64_t v10 = (int)v9;
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v42 = v12;
  int v43 = v11;
  float v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v44) = *(_DWORD *)(a1 + 108);
    HIDWORD(v44) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v44, v11, v12);
    float v16 = v15;
    if (v15) {
      goto LABEL_24;
    }
  }
  int v17 = 0;
  int v18 = 0;
  float v16 = 0;
  uint64_t v44 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertrgb16toARGB8888", 649, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertrgb16toARGB8888", 649, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v12);
    }
    int v41 = v16;
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v38);
    uint64_t v21 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    uint64_t v22 = v19 * (uint64_t)a4;
    uint64_t v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      uint64_t v24 = v10;
      v21 += v23 * v10;
      uint64_t v25 = v9;
      int v26 = -(int)v9;
    }
    else
    {
      uint64_t v24 = v10;
      uint64_t v25 = v9;
      int v26 = v9;
    }
    unint64_t v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    float v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      int v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      float v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21) {
        float v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0xE7346FE5uLL);
      }
    }
    if (v12 >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = (char *)(v20 + 5);
      do
      {
        if (v11 >= 1)
        {
          int v32 = &v28[v30 * v26];
          int v33 = v11;
          char v34 = v31;
          do
          {
            char v35 = *(v34 - 4);
            char v36 = *(v34 - 2);
            char v37 = *v34;
            v34 += 6;
            *int v32 = -1;
            v32[1] = v35;
            void v32[2] = v36;
            v32[3] = v37;
            v32 += 4;
            --v33;
          }
          while (v33);
        }
        ++v30;
        v31 += (int)v22;
      }
      while (v30 != v12);
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    uint64_t v10 = v24;
    uint64_t v9 = v25;
    float v16 = v41;
    if (!v41) {
      break;
    }
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v44 + 1, &v44, &v43, &v42))
    {
      free(v16);
      return;
    }
    int v18 = v44;
    int v17 = HIDWORD(v44);
    int v12 = v42;
    int v11 = v43;
    if (v43 < 0) {
      goto LABEL_4;
    }
  }
}

void ARGB32_mark_image_RGBA64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v64 = a2;
  int v63 = *(_DWORD *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  int v69 = v10;
  int v70 = v9;
  int v11 = *(int **)(a1 + 136);
  if (v11)
  {
    int v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v71) = *(_DWORD *)(a1 + 108);
    HIDWORD(v71) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v71, v9, v10);
    int v14 = v13;
    if (v13) {
      goto LABEL_50;
    }
  }
  int v15 = 0;
  int v16 = 0;
  int v14 = 0;
  uint64_t v71 = 0;
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 76);
    uint64_t v18 = *(void *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    uint64_t v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    uint64_t v20 = *(void *)(a1 + 48);
    uint64_t v21 = (char *)(*(void *)(a1 + 40) + v19 * v63 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    uint64_t v22 = v17 * (uint64_t)v8;
    float v68 = v14;
    if (v64 == 2)
    {
      if (v20) {
        unsigned int v23 = 0;
      }
      else {
        unsigned int v23 = 255;
      }
      if (v10 >= 1)
      {
        int8x16_t v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FF00;
        v25.i64[1] = 0xFF000000FF00;
        v26.i64[0] = 0xFF000000FF0000;
        v26.i64[1] = 0xFF000000FF0000;
        v27.i64[0] = 0xFF000000FFLL;
        v27.i64[1] = 0xFF000000FFLL;
        v28.i64[0] = 0x1000100010001;
        v28.i64[1] = 0x1000100010001;
        do
        {
          int v29 = v9;
          uint64_t v30 = (uint32x4_t *)v21;
          uint64_t v31 = (__int32 *)v18;
          unsigned int v32 = v9;
          if (v9 >= 4)
          {
            do
            {
              v33.i32[0] = v31[1];
              v33.i32[1] = v31[3];
              v33.i32[2] = v31[5];
              v33.i32[3] = v31[7];
              unsigned long long v34 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)v33, 0x10uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
              int v35 = vaddvq_s32((int32x4_t)v34);
              if (v35)
              {
                v36.i32[0] = *v31;
                v36.i32[1] = v31[2];
                v36.i32[2] = v31[4];
                v36.i32[3] = v31[6];
                int32x4_t v37 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8(vandq_s8(v36, v26), (int8x16_t)vshlq_n_s32(v33, 0x18uLL)), vandq_s8((int8x16_t)vshlq_n_s32((int32x4_t)v36, 8uLL), v25)), (int8x16_t)v34);
                if (v35 != 1020)
                {
                  int32x4_t v38 = (int32x4_t)veorq_s8((int8x16_t)v34, v27);
                  v39.i16[0] = v30->u8[0];
                  v39.i16[1] = BYTE2(v30->u32[0]);
                  v39.i16[2] = BYTE4(v30->i64[0]);
                  v39.i16[3] = BYTE6(v30->i64[0]);
                  v39.i16[4] = v30->i64[1];
                  v39.i16[5] = BYTE2(v30->i64[1]);
                  v39.i16[6] = BYTE12(*(unsigned long long *)v30);
                  v39.i16[7] = BYTE14(*(unsigned long long *)v30);
                  int32x4_t v40 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v30, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v38);
                  int32x4_t v41 = vmulq_s32(v39, v38);
                  int32x4_t v37 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v41, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v41, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v37, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v40, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)uint64_t v30 = vorrq_s8((int8x16_t)v37, v24);
              }
              int v29 = v32 - 4;
              v31 += 8;
              ++v30;
              BOOL v42 = v32 > 7;
              v32 -= 4;
            }
            while (v42);
          }
          if (v29 >= 1)
          {
            int v43 = v29 + 1;
            do
            {
              __int32 v44 = v31[1];
              if (BYTE2(v44))
              {
                int v45 = *v31 & 0xFF0000 | (*v31 << 8) | (v44 << 24) | BYTE2(v44);
                if (BYTE2(v44) != 255) {
                  v45 += ((((v30->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                }
                          + 65537
                          + ((((v30->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFFu)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v30->i32[0] = v45 | v23;
              }
              uint64_t v30 = (uint32x4_t *)((char *)v30 + 4);
              --v43;
              v31 += 2;
            }
            while (v43 > 1);
          }
          v18 += v22;
          v21 += v63;
          BOOL v42 = v10-- <= 1;
        }
        while (!v42);
      }
    }
    else
    {
      BOOL v46 = 0;
      if (v20) {
        BOOL v46 = *(void *)(a1 + 96) != 0;
      }
      if (v9 < 0) {
        _CGHandleAssert("CGSConvertRGBA16toARGB8888", 519, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v9);
      }
      if (v10 < 0) {
        _CGHandleAssert("CGSConvertRGBA16toARGB8888", 519, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v10);
      }
      uint64_t v47 = v10 - 1;
      if (v63 < 0)
      {
        v18 += (int)v47 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        int v48 = -v63;
        v21 += v47 * v63;
      }
      else
      {
        int v48 = v63;
      }
      unint64_t v49 = v18 + (int)((v22 * v47) & ((int)v22 >> 31));
      float v50 = v21;
      if (v49 <= (unint64_t)&v21[v10 * (uint64_t)v48])
      {
        int v51 = (int)v22 >= 0 ? v22 : -(int)v22;
        float v50 = v21;
        if (v49 + v10 * (uint64_t)v51 >= (unint64_t)v21)
        {
          int v52 = v48;
          uint64_t v53 = (char *)malloc_type_malloc(v10 * (uint64_t)v48, 0x9E4A635uLL);
          int v48 = v52;
          float v50 = v53;
        }
      }
      if (v10 >= 1)
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (v9 >= 1)
          {
            float v55 = &v50[i * v48];
            int v56 = v9;
            float v57 = (char *)(v18 + i * (int)v22);
            do
            {
              char v58 = *v57;
              char v59 = v57[2];
              char v60 = v57[4];
              char v61 = v57[6];
              if (!v46) {
                char v61 = -1;
              }
              char *v55 = v61;
              v55[1] = v58;
              v55[2] = v59;
              v55[3] = v60;
              v57 += 8;
              v55 += 4;
              --v56;
            }
            while (v56);
          }
        }
      }
      int v8 = a5;
      if (v50 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v50, v21, v48, v48);
        free(v50);
      }
    }
    int v14 = v68;
    if (!v68) {
      break;
    }
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v71 + 1, &v71, &v70, &v69))
    {
      free(v14);
      return;
    }
    int v16 = v71;
    int v15 = HIDWORD(v71);
    int v10 = v69;
    int v9 = v70;
  }
}

void ARGB32_mark_image_rgba64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v66 = a2;
  int v65 = *(_DWORD *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  int v71 = v10;
  int v72 = v9;
  int v11 = *(int **)(a1 + 136);
  if (v11)
  {
    int v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v73) = *(_DWORD *)(a1 + 108);
    HIDWORD(v73) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v73, v9, v10);
    int v14 = v13;
    if (v13) {
      goto LABEL_50;
    }
  }
  int v15 = 0;
  int v16 = 0;
  int v14 = 0;
  uint64_t v73 = 0;
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 76);
    uint64_t v18 = *(void *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    uint64_t v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    uint64_t v20 = *(void *)(a1 + 48);
    uint64_t v21 = (char *)(*(void *)(a1 + 40) + v19 * v65 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    uint64_t v22 = v17 * (uint64_t)v8;
    int v70 = v14;
    if (v66 == 2)
    {
      if (v20) {
        unsigned int v23 = 0;
      }
      else {
        unsigned int v23 = 255;
      }
      if (v10 >= 1)
      {
        int8x16_t v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FF00;
        v25.i64[1] = 0xFF000000FF00;
        v26.i64[0] = 0xFF000000FF0000;
        v26.i64[1] = 0xFF000000FF0000;
        v27.i64[0] = 0xFF000000FFLL;
        v27.i64[1] = 0xFF000000FFLL;
        v28.i64[0] = 0x1000100010001;
        v28.i64[1] = 0x1000100010001;
        do
        {
          int v29 = v9;
          uint64_t v30 = (uint32x4_t *)v21;
          uint64_t v31 = (__int32 *)v18;
          unsigned int v32 = v9;
          if (v9 >= 4)
          {
            do
            {
              v33.i32[0] = v31[1];
              v33.i32[1] = v31[3];
              v33.i32[2] = v31[5];
              v33.i32[3] = v31[7];
              int32x4_t v34 = (int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x18uLL);
              int v35 = vaddvq_s32(v34);
              if (v35)
              {
                v36.i32[0] = *v31;
                v36.i32[1] = v31[2];
                v36.i32[2] = v31[4];
                v36.i32[3] = v31[6];
                int32x4_t v37 = (int32x4_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v36, 8uLL), v26), vandq_s8((int8x16_t)v36, v25)), vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v33, 0x10uLL) & __PAIR128__(0xFF00FFFFFF00FFFFLL, 0xFF00FFFFFF00FFFFLL)), (int8x16_t)v34));
                if (v35 != 1020)
                {
                  int32x4_t v38 = (int32x4_t)veorq_s8((int8x16_t)v34, v27);
                  v39.i16[0] = v30->u8[0];
                  v39.i16[1] = BYTE2(v30->u32[0]);
                  v39.i16[2] = BYTE4(v30->i64[0]);
                  v39.i16[3] = BYTE6(v30->i64[0]);
                  v39.i16[4] = v30->i64[1];
                  v39.i16[5] = BYTE2(v30->i64[1]);
                  v39.i16[6] = BYTE12(*(unsigned long long *)v30);
                  v39.i16[7] = BYTE14(*(unsigned long long *)v30);
                  int32x4_t v40 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v30, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v38);
                  int32x4_t v41 = vmulq_s32(v39, v38);
                  int32x4_t v37 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v41, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v41, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v37, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v40, v28), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)uint64_t v30 = vorrq_s8((int8x16_t)v37, v24);
              }
              int v29 = v32 - 4;
              v31 += 8;
              ++v30;
              BOOL v42 = v32 > 7;
              v32 -= 4;
            }
            while (v42);
          }
          if (v29 >= 1)
          {
            int v43 = v29 + 1;
            do
            {
              unsigned __int32 v44 = v31[1];
              unsigned __int32 v45 = HIBYTE(v44);
              if (HIBYTE(v44))
              {
                int v46 = (*v31 >> 8) & 0xFF0000 | *v31 & 0xFF00 | (BYTE1(v44) << 24) | HIBYTE(v44);
                if (v45 != 255) {
                  v46 += ((((v30->i32[0] & 0xFF00FF) * (v45 ^ 0xFF)
                }
                          + 65537
                          + ((((v30->i32[0] & 0xFF00FF) * (v45 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (v45 ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v30->i32[0] >> 8) & 0xFF00FF) * (v45 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v30->i32[0] = v46 | v23;
              }
              uint64_t v30 = (uint32x4_t *)((char *)v30 + 4);
              --v43;
              v31 += 2;
            }
            while (v43 > 1);
          }
          v18 += v22;
          v21 += v65;
          BOOL v42 = v10-- <= 1;
        }
        while (!v42);
      }
    }
    else
    {
      BOOL v47 = 0;
      if (v20) {
        BOOL v47 = *(void *)(a1 + 96) != 0;
      }
      if (v9 < 0) {
        _CGHandleAssert("CGSConvertrgba16toARGB8888", 681, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v9);
      }
      if (v10 < 0) {
        _CGHandleAssert("CGSConvertrgba16toARGB8888", 681, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v10);
      }
      uint64_t v48 = v10 - 1;
      if (v65 < 0)
      {
        v18 += (int)v48 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        int v49 = -v65;
        v21 += v48 * v65;
      }
      else
      {
        int v49 = v65;
      }
      unint64_t v50 = v18 + (int)((v22 * v48) & ((int)v22 >> 31));
      int v51 = v21;
      if (v50 <= (unint64_t)&v21[v10 * (uint64_t)v49])
      {
        int v52 = (int)v22 >= 0 ? v22 : -(int)v22;
        int v51 = v21;
        if (v50 + v10 * (uint64_t)v52 >= (unint64_t)v21)
        {
          int v53 = v49;
          int v54 = (char *)malloc_type_malloc(v10 * (uint64_t)v49, 0x9BB5A1B4uLL);
          int v49 = v53;
          int v51 = v54;
        }
      }
      if (v10 >= 1)
      {
        uint64_t v55 = 0;
        int v56 = (char *)(v18 + 3);
        do
        {
          if (v9 >= 1)
          {
            float v57 = &v51[v55 * v49];
            char v58 = v56;
            int v59 = v9;
            do
            {
              char v60 = *(v58 - 2);
              char v61 = *v58;
              char v62 = v58[2];
              char v63 = v58[4];
              if (!v47) {
                char v63 = -1;
              }
              char *v57 = v63;
              v57[1] = v60;
              v57[2] = v61;
              v57[3] = v62;
              v57 += 4;
              v58 += 8;
              --v59;
            }
            while (v59);
          }
          ++v55;
          v56 += (int)v22;
        }
        while (v55 != v10);
      }
      int v8 = a5;
      if (v51 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v51, v21, v49, v49);
        free(v51);
      }
    }
    int v14 = v70;
    if (!v70) {
      break;
    }
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v73 + 1, &v73, &v72, &v71))
    {
      free(v14);
      return;
    }
    int v16 = v73;
    int v15 = HIDWORD(v73);
    int v10 = v71;
    int v9 = v72;
  }
}

void RGBAf16_sample_RGB24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGB24", 14743, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_RGBA32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGBA32", 14747, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_rgba32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_rgba32", 14751, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_ARGB32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_ARGB32", 14755, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_argb32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_argb32", 14759, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_RGB48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGB48", 14763, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_rgb48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_rgb48", 14767, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_RGBA64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGBA64", 14771, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_rgba64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_rgba64", 14775, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_WF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_WF", 14779, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_Wf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_Wf", 14783, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_RGBF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGBF", 14787, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_RGBf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGBf", 14791, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGBAF", 14795, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_RGBAf", 14799, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_CMYKF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_CMYKF", 14803, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void RGBAf16_sample_CMYKf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("RGBAf16_sample_CMYKf", 14807, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

__int16 PDAmultiplyPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  float v30 = _S0 * _S7;
  float v31 = _S1 * _S6;
  float v32 = _S2 * _S5;
  _S0 = (float)(_S0 * _S7) + (float)(_S0 * (float)(1.0 - a20));
  _S1 = (float)(_S1 * _S6) + (float)(_S1 * (float)(1.0 - a20));
  _S2 = (float)(_S2 * _S5) + (float)(_S2 * (float)(1.0 - a20));
  if (a20 == 1.0)
  {
    _S0 = v30;
    _S1 = v31;
    _S2 = v32;
  }
  float v36 = _S0 + (float)(_S7 * (float)(1.0 - a5));
  float v37 = _S1 + (float)(_S6 * (float)(1.0 - a5));
  float v38 = _S2 + (float)(_S5 * (float)(1.0 - a5));
  if (a5 != 1.0)
  {
    _S0 = v36;
    _S1 = v37;
    _S2 = v38;
  }
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAoverlayPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  float v30 = (float)(_S0 * _S7) + (float)(_S0 * _S7);
  float v31 = (float)(_S1 * _S6) + (float)(_S1 * _S6);
  float v32 = (float)(_S2 * _S5) + (float)(_S2 * _S5);
  float v33 = a5 * a20;
  float v34 = a5 * 0.5;
  BOOL v35 = (float)(a5 * 0.5) <= _S0;
  float v36 = a20 + 1.0;
  float v37 = a5 + 1.0;
  float v38 = (float)((float)((float)((float)(a5 + 1.0) * _S7) + (float)(_S0 * (float)(a20 + 1.0))) - v30) - (float)(a5 * a20);
  float v39 = 1.0 - a20;
  float v40 = 1.0 - a5;
  _S0 = (float)((float)((float)(1.0 - a5) * _S7) + (float)(_S0 * (float)(1.0 - a20))) + v30;
  if (v35) {
    _S0 = v38;
  }
  BOOL v35 = v34 <= _S1;
  float v42 = (float)((float)((float)(v37 * _S6) + (float)(_S1 * v36)) - v31) - v33;
  _S1 = (float)((float)(v40 * _S6) + (float)(_S1 * v39)) + v31;
  if (v35) {
    _S1 = v42;
  }
  BOOL v35 = v34 <= _S2;
  float v44 = (float)((float)((float)(v37 * _S5) + (float)(_S2 * v36)) - v32) - v33;
  _S2 = (float)((float)(v40 * _S5) + (float)(_S2 * v39)) + v32;
  if (v35) {
    _S2 = v44;
  }
  _S3 = (float)(a5 + a20) - v33;
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAlightenPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  float v30 = _S0 * a20;
  if ((float)(_S7 * a5) > (float)(_S0 * a20)) {
    float v30 = _S7 * a5;
  }
  float v31 = _S1 * a20;
  if ((float)(_S6 * a5) > (float)(_S1 * a20)) {
    float v31 = _S6 * a5;
  }
  float v32 = _S2 * a20;
  if ((float)(_S5 * a5) > (float)(_S2 * a20)) {
    float v32 = _S5 * a5;
  }
  _S0 = v30 + (float)(_S0 * (float)(1.0 - a20));
  _S1 = v31 + (float)(_S1 * (float)(1.0 - a20));
  _S2 = v32 + (float)(_S2 * (float)(1.0 - a20));
  if (a20 == 1.0)
  {
    _S0 = v30;
    _S1 = v31;
    _S2 = v32;
  }
  float v36 = _S0 + (float)(_S7 * (float)(1.0 - a5));
  float v37 = _S1 + (float)(_S6 * (float)(1.0 - a5));
  float v38 = _S2 + (float)(_S5 * (float)(1.0 - a5));
  if (a5 != 1.0)
  {
    _S0 = v36;
    _S1 = v37;
    _S2 = v38;
  }
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAdarkenPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  float v30 = _S0 * a20;
  if ((float)(_S7 * a5) < (float)(_S0 * a20)) {
    float v30 = _S7 * a5;
  }
  float v31 = _S1 * a20;
  if ((float)(_S6 * a5) < (float)(_S1 * a20)) {
    float v31 = _S6 * a5;
  }
  float v32 = _S2 * a20;
  if ((float)(_S5 * a5) < (float)(_S2 * a20)) {
    float v32 = _S5 * a5;
  }
  _S0 = v30 + (float)(_S0 * (float)(1.0 - a20));
  _S1 = v31 + (float)(_S1 * (float)(1.0 - a20));
  _S2 = v32 + (float)(_S2 * (float)(1.0 - a20));
  if (a20 == 1.0)
  {
    _S0 = v30;
    _S1 = v31;
    _S2 = v32;
  }
  float v36 = _S0 + (float)(_S7 * (float)(1.0 - a5));
  float v37 = _S1 + (float)(_S6 * (float)(1.0 - a5));
  float v38 = _S2 + (float)(_S5 * (float)(1.0 - a5));
  if (a5 != 1.0)
  {
    _S0 = v36;
    _S1 = v37;
    _S2 = v38;
  }
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAcolordodgePDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H16 = a18;
  _H5 = a17;
  __asm
  {
    FCVT            S6, H0
    FCVT            S5, H5
  }
  float v25 = a20 * a20;
  float v26 = 0.0;
  __asm { FCMP            H0, #0 }
  _S0 = 0.0;
  if (!_ZF)
  {
    _S0 = 1.0;
    if (_S5 != a20) {
      _S0 = (float)(v25 * _S6) / (float)(a20 - _S5);
    }
  }
  _H20 = a19;
  __asm
  {
    FCVT            S18, H1
    FCVT            S16, H16
    FCMP            H1, #0
  }
  if (!_ZF)
  {
    if (_S16 == a20) {
      float v26 = 1.0;
    }
    else {
      float v26 = (float)(v25 * _S18) / (float)(a20 - _S16);
    }
  }
  __asm
  {
    FCVT            S19, H2
    FCVT            S1, H20
  }
  float v35 = 0.0;
  __asm { FCMP            H2, #0 }
  if (!_ZF)
  {
    if (_S1 == a20) {
      float v35 = 1.0;
    }
    else {
      float v35 = (float)(v25 * _S19) / (float)(a20 - _S1);
    }
  }
  float v37 = _S0 + (float)(_S6 * (float)(1.0 - a20));
  float v38 = v26 + (float)(_S18 * (float)(1.0 - a20));
  if (a20 == 1.0)
  {
    float v39 = v26;
  }
  else
  {
    _S0 = v37;
    float v39 = v38;
  }
  if (a20 == 1.0) {
    float v40 = v35;
  }
  else {
    float v40 = v35 + (float)(_S19 * (float)(1.0 - a20));
  }
  float v41 = _S0 + (float)(_S5 * (float)(1.0 - a5));
  float v42 = v39 + (float)(_S16 * (float)(1.0 - a5));
  float v43 = v40 + (float)(_S1 * (float)(1.0 - a5));
  if (a5 == 1.0)
  {
    _S2 = v39;
  }
  else
  {
    _S0 = v41;
    _S2 = v42;
  }
  if (a5 == 1.0) {
    float v43 = v40;
  }
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  if (_S0 > _S3) {
    _S0 = (float)(a5 + a20) - (float)(a5 * a20);
  }
  if (_S2 > _S3) {
    _S2 = (float)(a5 + a20) - (float)(a5 * a20);
  }
  if (v43 <= _S3) {
    _S4 = v43;
  }
  else {
    _S4 = (float)(a5 + a20) - (float)(a5 * a20);
  }
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S2
    FCVT            H2, S4
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAcolorburnPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H17 = a18;
  _H21 = a17;
  __asm
  {
    FCVT            S22, H0
    FCVT            S19, H1
    FCVT            S16, H2
    FCVT            S20, H21
    FCVT            S18, H17
    FCVT            S1, H5
  }
  float v30 = (float)(a5 * a20) + (float)(_S22 * (float)(1.0 - a20));
  float v31 = (float)(a5 * a20) + (float)(_S19 * (float)(1.0 - a20));
  if (a20 == 1.0)
  {
    float v30 = a5 * a20;
    float v31 = a5 * a20;
    float v32 = a5 * a20;
  }
  else
  {
    float v32 = (float)(a5 * a20) + (float)(_S16 * (float)(1.0 - a20));
  }
  if (a5 == 1.0) {
    _S2 = v30;
  }
  else {
    _S2 = v30 + (float)(_S20 * (float)(1.0 - a5));
  }
  if (a5 == 1.0) {
    _S6 = v31;
  }
  else {
    _S6 = v31 + (float)(_S18 * (float)(1.0 - a5));
  }
  if (a5 == 1.0) {
    _S7 = v32;
  }
  else {
    _S7 = v32 + (float)(_S1 * (float)(1.0 - a5));
  }
  float v36 = a5 - _S22;
  if (v36 != 0.0)
  {
    __asm { FCMP            H21, #0 }
    if (_ZF || (_S2 = _S2 - (float)((float)(v36 * (float)(a20 * a20)) / _S20), _S2 < 0.0)) {
      _S2 = 0.0;
    }
  }
  float v38 = a5 - _S19;
  if (v38 != 0.0)
  {
    __asm { FCMP            H17, #0 }
    if (_ZF || (_S6 = _S6 - (float)((float)(v38 * (float)(a20 * a20)) / _S18), _S6 < 0.0)) {
      _S6 = 0.0;
    }
  }
  float v40 = a5 - _S16;
  if (v40 != 0.0)
  {
    __asm { FCMP            H5, #0 }
    if (_ZF || (_S7 = _S7 - (float)((float)(v40 * (float)(a20 * a20)) / _S1), _S7 < 0.0)) {
      _S7 = 0.0;
    }
  }
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  __asm
  {
    FCVT            H0, S2
    FCVT            H1, S6
    FCVT            H2, S7
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAhardlightPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  float v30 = (float)(_S0 * _S7) + (float)(_S0 * _S7);
  float v31 = (float)(_S1 * _S6) + (float)(_S1 * _S6);
  float v32 = (float)(_S2 * _S5) + (float)(_S2 * _S5);
  float v33 = a5 * a20;
  float v34 = a20 * 0.5;
  float v35 = 1.0 - a20;
  float v36 = 1.0 - a5;
  float v37 = (float)((float)((float)(1.0 - a5) * _S7) + (float)(_S0 * (float)(1.0 - a20))) + v30;
  float v38 = a20 + 1.0;
  float v39 = a5 + 1.0;
  _S0 = (float)((float)((float)((float)(a5 + 1.0) * _S7) + (float)(_S0 * (float)(a20 + 1.0))) - v30) - (float)(a5 * a20);
  if ((float)(a20 * 0.5) >= _S7) {
    _S0 = v37;
  }
  float v41 = (float)((float)(v36 * _S6) + (float)(_S1 * v35)) + v31;
  _S1 = (float)((float)((float)(v39 * _S6) + (float)(_S1 * v38)) - v31) - v33;
  if (v34 >= _S6) {
    _S1 = v41;
  }
  float v43 = (float)((float)(v36 * _S5) + (float)(_S2 * v35)) + v32;
  _S2 = (float)((float)((float)(v39 * _S5) + (float)(_S2 * v38)) - v32) - v33;
  if (v34 >= _S5) {
    _S2 = v43;
  }
  _S3 = (float)(a5 + a20) - v33;
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAsoftlightPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H16 = a19;
  _H17 = a18;
  _H18 = a17;
  __asm
  {
    FCVT            S5, H0
    FCVT            S6, H1
    FCVT            S7, H2
    FCVT            S0, H18
    FCVT            S1, H17
    FCVT            S2, H16
  }
  if (a5 == 0.0)
  {
    float v32 = 0.0;
    float v30 = 0.0;
    float v31 = 0.0;
  }
  else
  {
    float v30 = (float)((float)(_S5 * _S0) + (float)(_S5 * _S0))
        - (float)((float)((float)(_S5 * _S5) * (float)((float)(_S0 + _S0) - a20)) / a5);
    float v31 = 0.0;
    if (v30 < 0.0) {
      float v30 = 0.0;
    }
    float v32 = (float)((float)(_S6 * _S1) + (float)(_S6 * _S1))
        - (float)((float)((float)(_S6 * _S6) * (float)((float)(_S1 + _S1) - a20)) / a5);
    if (v32 < 0.0) {
      float v32 = 0.0;
    }
    if ((float)((float)((float)(_S7 * _S2) + (float)(_S7 * _S2))
               - (float)((float)((float)(_S7 * _S7) * (float)((float)(_S2 + _S2) - a20)) / a5)) >= 0.0)
      float v31 = (float)((float)(_S7 * _S2) + (float)(_S7 * _S2))
          - (float)((float)((float)(_S7 * _S7) * (float)((float)(_S2 + _S2) - a20)) / a5);
  }
  float v33 = v30 + (float)(_S5 * (float)(1.0 - a20));
  float v34 = v32 + (float)(_S6 * (float)(1.0 - a20));
  float v35 = v31 + (float)(_S7 * (float)(1.0 - a20));
  if (a20 == 1.0)
  {
    float v33 = v30;
    float v34 = v32;
    float v35 = v31;
  }
  _S0 = v33 + (float)(_S0 * (float)(1.0 - a5));
  _S1 = v34 + (float)(_S1 * (float)(1.0 - a5));
  _S2 = v35 + (float)(_S2 * (float)(1.0 - a5));
  if (a5 == 1.0)
  {
    _S0 = v33;
    _S1 = v34;
    _S2 = v35;
  }
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAdifferencePDA@<H0>(__n128 _Q0@<Q0>, double a2@<D1>, double a3@<D2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, int a18, float a19)
{
  _H6 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S6, H6
  }
  float v23 = _S0 + _S6;
  float v24 = _S0 * a19;
  float v25 = _S6 * a5;
  float v26 = v23 - v24;
  float v27 = v24 - v25;
  float v28 = v26 - v25;
  if (v27 < 0.0) {
    float v27 = -v27;
  }
  _S0 = v28 + v27;
  _S6 = (float)(a5 + a19) - (float)(a5 * a19);
  __asm
  {
    FCVT            H0, S0
    FCVT            H3, S6
  }
  return result;
}

__int16 PDAexclusionPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  _S0 = (float)(_S0 + _S7) + (float)((float)-(float)(_S0 * _S7) * 2.0);
  _S1 = (float)(_S1 + _S6) + (float)((float)-(float)(_S1 * _S6) * 2.0);
  _S2 = (float)(_S2 + _S5) + (float)((float)-(float)(_S2 * _S5) * 2.0);
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAhuePDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  __asm
  {
    FCVT            S16, H0
    FCVT            S1, H1
    FCVT            S0, H2
    FCVT            S2, H7
    FCVT            S17, H6
    FCVT            S5, H5
  }
  float v30 = _S16 * a20;
  float v31 = _S16 - (float)(_S16 * a20);
  float v32 = _S1 - (float)(_S1 * a20);
  float v33 = _S0 - (float)(_S0 * a20);
  if (a20 == 1.0)
  {
    float v31 = 0.0;
    float v32 = 0.0;
    float v33 = 0.0;
  }
  else
  {
    _S0 = _S0 * a20;
  }
  if (a20 == 1.0) {
    float v34 = _S1;
  }
  else {
    float v34 = _S1 * a20;
  }
  if (a20 == 1.0) {
    float v30 = _S16;
  }
  float v35 = (float)(v31 + _S2) - (float)(_S2 * a5);
  float v36 = (float)(v32 + _S17) - (float)(_S17 * a5);
  if (a5 == 1.0) {
    float v37 = _S2;
  }
  else {
    float v37 = _S2 * a5;
  }
  if (a5 == 1.0)
  {
    float v38 = _S5;
  }
  else
  {
    _S17 = _S17 * a5;
    float v38 = _S5 * a5;
  }
  if (a5 == 1.0)
  {
    float v35 = v31;
    float v39 = v32;
  }
  else
  {
    float v39 = v36;
  }
  if (a5 == 1.0) {
    float v40 = v33;
  }
  else {
    float v40 = (float)(v33 + _S5) - (float)(_S5 * a5);
  }
  float v56 = v37;
  float v57 = _S17;
  float v58 = v38;
  uint64_t v41 = v37 < _S17;
  BOOL v42 = v37 >= _S17;
  if (v38 >= *(&v56 + v42))
  {
    uint64_t v43 = v37 >= _S17;
    if (v38 > *(&v56 + v41))
    {
      BOOL v42 = v37 < _S17;
      uint64_t v41 = 2;
    }
  }
  else
  {
    uint64_t v43 = 2;
  }
  float v44 = *(&v56 + v41);
  float v45 = *(&v56 + v43);
  if (v44 <= v45)
  {
    *(&v56 + v41) = 0.0;
    *(&v56 + v42) = 0.0;
  }
  else
  {
    if (v30 >= v34) {
      float v46 = v34;
    }
    else {
      float v46 = v30;
    }
    if (v30 >= v34) {
      float v47 = v30;
    }
    else {
      float v47 = v34;
    }
    if (_S0 > v47) {
      float v48 = _S0;
    }
    else {
      float v48 = v47;
    }
    if (_S0 >= v46) {
      float v47 = v48;
    }
    else {
      float v46 = _S0;
    }
    float v49 = v47 - v46;
    *(&v56 + v41) = v49;
    *(&v56 + v42) = (float)(v49 / (float)(v44 - v45)) * (float)(*(&v56 + v42) - *(&v56 + v43));
  }
  *(&v56 + v43) = 0.0;
  float v50 = (float)((float)((float)(v34 - v57) * 0.59) + (float)((float)(v30 - v56) * 0.3))
      + (float)((float)(_S0 - v58) * 0.11);
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  _S1 = v35 + (float)(v56 + v50);
  _S2 = v39 + (float)(v57 + v50);
  _S4 = v40 + (float)(v58 + v50);
  __asm
  {
    FCVT            H0, S1
    FCVT            H1, S2
    FCVT            H2, S4
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAsaturationPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H7 = a19;
  _H6 = a18;
  _H16 = a17;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  __asm
  {
    FCVT            S5, H0
    FCVT            S1, H1
    FCVT            S0, H2
    FCVT            S2, H16
    FCVT            S6, H6
    FCVT            S7, H7
  }
  if (a20 == 1.0)
  {
    float v30 = 0.0;
    float v31 = 0.0;
    float v32 = 0.0;
  }
  else
  {
    float v30 = _S5 - (float)(_S5 * a20);
    float v31 = _S1 - (float)(_S1 * a20);
    float v32 = _S0 - (float)(_S0 * a20);
    _S0 = _S0 * a20;
    _S1 = _S1 * a20;
    _S5 = _S5 * a20;
  }
  float v33 = _S2 * a5;
  float v34 = _S6 * a5;
  if (a5 == 1.0)
  {
    float v33 = _S2;
    float v34 = _S6;
    float v35 = _S7;
  }
  else
  {
    float v35 = _S7 * a5;
  }
  if (a5 == 1.0) {
    float v36 = v30;
  }
  else {
    float v36 = (float)(v30 + _S2) - (float)(_S2 * a5);
  }
  if (a5 == 1.0) {
    float v37 = v31;
  }
  else {
    float v37 = (float)(v31 + _S6) - (float)(_S6 * a5);
  }
  if (a5 == 1.0) {
    float v38 = v32;
  }
  else {
    float v38 = (float)(v32 + _S7) - (float)(_S7 * a5);
  }
  float v53 = _S5;
  float v54 = _S1;
  float v55 = _S0;
  uint64_t v39 = _S5 < _S1;
  BOOL v40 = _S5 >= _S1;
  if (_S0 >= *(&v53 + v40))
  {
    uint64_t v41 = _S5 >= _S1;
    if (_S0 > *(&v53 + v39))
    {
      BOOL v40 = _S5 < _S1;
      uint64_t v39 = 2;
    }
  }
  else
  {
    uint64_t v41 = 2;
  }
  float v42 = *(&v53 + v39);
  float v43 = *(&v53 + v41);
  if (v42 <= v43)
  {
    *(&v53 + v39) = 0.0;
    *(&v53 + v40) = 0.0;
  }
  else
  {
    if (v33 >= v34) {
      float v44 = v34;
    }
    else {
      float v44 = v33;
    }
    if (v33 < v34) {
      float v33 = v34;
    }
    if (v35 > v33) {
      float v45 = v35;
    }
    else {
      float v45 = v33;
    }
    if (v35 >= v44)
    {
      float v35 = v44;
      float v33 = v45;
    }
    float v46 = v33 - v35;
    *(&v53 + v39) = v46;
    *(&v53 + v40) = (float)(v46 / (float)(v42 - v43)) * (float)(*(&v53 + v40) - *(&v53 + v41));
  }
  *(&v53 + v41) = 0.0;
  float v47 = (float)((float)((float)(_S1 - v54) * 0.59) + (float)((float)(_S5 - v53) * 0.3))
      + (float)((float)(_S0 - v55) * 0.11);
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  _S1 = v36 + (float)(v53 + v47);
  _S2 = v37 + (float)(v54 + v47);
  _S4 = v38 + (float)(v55 + v47);
  __asm
  {
    FCVT            H0, S1
    FCVT            H1, S2
    FCVT            H2, S4
    FCVT            H3, S3
  }
  return result;
}

__int16 PDAluminosityPDA@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>, __n128 _Q2@<Q2>, double a4@<D3>, float a5@<S4>, double a6@<D5>, double a7@<D6>, double a8@<D7>, uint64_t a9@<X0>, uint64_t a10@<X1>, uint64_t a11@<X2>, uint64_t a12@<X3>, uint64_t a13@<X4>, uint64_t a14@<X5>, uint64_t a15@<X6>, uint64_t a16@<X7>, __int16 a17, __int16 a18, __int16 a19, float a20)
{
  _H5 = a19;
  _H6 = a18;
  _H7 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  float v30 = 0.0;
  float v31 = _S0 - (float)(_S0 * a20);
  float v32 = _S1 - (float)(_S1 * a20);
  if (a20 == 1.0)
  {
    float v31 = 0.0;
    float v32 = 0.0;
  }
  else
  {
    float v30 = _S2 - (float)(_S2 * a20);
    _S2 = _S2 * a20;
  }
  if (a20 != 1.0)
  {
    _S1 = _S1 * a20;
    _S0 = _S0 * a20;
  }
  float v33 = (float)(v31 + _S7) - (float)(_S7 * a5);
  float v34 = (float)(v32 + _S6) - (float)(_S6 * a5);
  float v35 = (float)(v30 + _S5) - (float)(_S5 * a5);
  if (a5 == 1.0)
  {
    float v33 = v31;
  }
  else
  {
    _S7 = _S7 * a5;
    _S6 = _S6 * a5;
    _S5 = _S5 * a5;
  }
  if (a5 == 1.0) {
    float v36 = v32;
  }
  else {
    float v36 = v34;
  }
  if (a5 != 1.0) {
    float v30 = v35;
  }
  float v37 = (float)((float)((float)(_S6 - _S1) * 0.59) + (float)((float)(_S7 - _S0) * 0.3))
      + (float)((float)(_S5 - _S2) * 0.11);
  _S3 = (float)(a5 + a20) - (float)(a5 * a20);
  _S0 = v33 + (float)(_S0 + v37);
  _S1 = v36 + (float)(_S1 + v37);
  _S2 = v30 + (float)(_S2 + v37);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
    FCVT            H2, S2
    FCVT            H3, S3
  }
  return result;
}

void RGBAf16_mark_pixelmask(_DWORD *a1, int *a2, uint64_t a3, __n128 a4, __n128 a5, __n128 _Q2, double _D3, double a8, float32x4_t _Q5, float32x4_t _Q6, double _D7)
{
  int v617 = a2[2];
  unint64_t v13 = a2[7];
  uint64_t v14 = *((void *)a2 + 5);
  uint64_t v15 = *((void *)a2 + 6);
  unint64_t v16 = *((void *)a2 + 11);
  uint64_t v17 = *((void *)a2 + 12);
  uint64_t v18 = *((void *)a2 + 17);
  int v19 = *a2;
  int v616 = a2[1];
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1)
  {
    uint64_t v579 = a3;
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_9_13630);
    a3 = v579;
  }
  BOOL v20 = v15 != 0;
  if (v18)
  {
    uint64_t v21 = v616;
    uint64_t v22 = v617;
    unint64_t v23 = v13 >> 3;
    float v24 = (float16x4_t *)(v14 + 8 * (a2[3] + (v13 >> 3) * a2[4]));
    uint64_t v25 = a2[31];
    float v26 = (char *)(v18 + a2[26] + a2[27] * (uint64_t)(int)v25);
    uint64_t v27 = a2[14];
    uint64_t v28 = a2[15];
    unint64_t v29 = (unint64_t)a2[19] >> 3;
    if ((v19 & 0xFF00) != 0x100)
    {
      uint64_t v33 = a2[16];
      unint64_t v34 = v16 + 8 * v29 * a2[17];
      uint64_t v32 = 1;
      float v35 = (float16x4_t *)v16;
      unint64_t v30 = v16;
      uint64_t v36 = a2[17];
      goto LABEL_15;
    }
    unint64_t v30 = v16 + 8 * (v27 + v29 * v28);
    if (v29 != v23)
    {
      uint64_t v32 = 1;
LABEL_14:
      unint64_t v34 = 0;
      float v35 = 0;
      uint64_t v36 = 0;
      unint64_t v16 = -1;
      uint64_t v33 = v29;
LABEL_15:
      BOOL v37 = v17 != 0;
      int v38 = v32 * v616;
      unint64_t v598 = v34;
      if (v34)
      {
        unint64_t v39 = v30 + 8 * v29 * ((int)v28 % (int)v36);
        float v35 = (float16x4_t *)(v39 + 8 * ((int)v27 % (int)v33));
        unint64_t v16 = v39 + 8 * (int)v33;
        unint64_t v30 = (unint64_t)v35;
      }
      else
      {
        v29 -= v38;
      }
      uint64_t v599 = v25 - v38;
      uint64_t v600 = v23 - v38;
      unint64_t v597 = v29;
      switch((int)a3)
      {
        case 0:
          do
          {
            int v40 = v616;
            do
            {
              unsigned int v41 = *v26;
              if (*v26)
              {
                if (v41 == 255) {
                  *float v24 = 0;
                }
                else {
                  *float v24 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v24), (float)((float)v41 * -0.0039216) + 1.0));
                }
              }
              v26 += (int)v32;
              v24 += (int)v32;
              --v40;
            }
            while (v40);
            v26 += v599;
            v24 += v600;
            --v617;
          }
          while (v617);
          return;
        case 1:
          if (use_vImage_fp16_compositing(void)::predicate != -1)
          {
            int v596 = v36;
            int v580 = v33;
            v615 = v35;
            int v581 = v32;
            dispatch_once(&use_vImage_fp16_compositing(void)::predicate, &__block_literal_global_21437);
            LODWORD(v32) = v581;
            float v35 = v615;
            LODWORD(v36) = v596;
            unint64_t v29 = v597;
            LODWORD(v33) = v580;
          }
          if (use_vImage_fp16_compositing(void)::status)
          {
            vImageCGCompositePixelMask_ARGB16F();
          }
          else if (!v15 || v17)
          {
            do
            {
              int v570 = v616 + 1;
              do
              {
                unsigned int v571 = *v26;
                if (*v26)
                {
                  if (v571 == 255) {
                    float16x4_t v572 = *(float16x4_t *)v30;
                  }
                  else {
                    float16x4_t v572 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v24), 1.0 - (float)((float)v571 * 0.0039216)), vcvtq_f32_f16(*(float16x4_t *)v30), (float)v571 * 0.0039216));
                  }
                  *float v24 = v572;
                }
                v26 += (int)v32;
                unint64_t v573 = v30 + 8 * (int)v32;
                if (v573 >= v16) {
                  uint64_t v574 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v574 = 0;
                }
                unint64_t v30 = v573 + 8 * v574;
                --v570;
                v24 += (int)v32;
              }
              while (v570 > 1);
              v26 += v599;
              v24 += v600;
              v575 = &v35[v29];
              if ((unint64_t)v575 >= v598) {
                uint64_t v576 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v576 = 0;
              }
              v577 = &v575[v576];
              uint64_t v578 = v16 + 8 * v576 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v578;
                float v35 = v577;
                unint64_t v30 = (unint64_t)v577;
              }
              else
              {
                v30 += 8 * v29;
              }
              BOOL v569 = v617-- <= 1;
            }
            while (!v569);
          }
          else
          {
            do
            {
              int v557 = v616 + 1;
              do
              {
                unsigned int v558 = *v26;
                if (*v26)
                {
                  if (v558 == 255)
                  {
                    v24->i32[0] = *(_DWORD *)v30;
                    v24->i16[2] = *(_WORD *)(v30 + 4);
                    v24->i16[3] = COERCE_UNSIGNED_INT(1.0);
                  }
                  else
                  {
                    _H4 = *(_WORD *)(v30 + 4);
                    __asm { FCVT            S4, H4 }
                    float v561 = (float)v558 * 0.0039216;
                    _Q6.i32[0] = *(_DWORD *)v30;
                    *(float32x2_t *)v562.f32 = vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16(*(float16x4_t *)_Q6.f32), v561);
                    v562.f32[2] = v561 * _S4;
                    v562.f32[3] = v561;
                    _Q6 = vmlaq_n_f32(v562, vcvtq_f32_f16(*v24), 1.0 - v561);
                    *float v24 = vcvt_f16_f32(_Q6);
                  }
                }
                v26 += (int)v32;
                unint64_t v563 = v30 + 8 * (int)v32;
                if (v563 >= v16) {
                  uint64_t v564 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v564 = 0;
                }
                unint64_t v30 = v563 + 8 * v564;
                --v557;
                v24 += (int)v32;
              }
              while (v557 > 1);
              v26 += v599;
              v24 += v600;
              v565 = &v35[v29];
              if ((unint64_t)v565 >= v598) {
                uint64_t v566 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v566 = 0;
              }
              v567 = &v565[v566];
              uint64_t v568 = v16 + 8 * v566 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v568;
                float v35 = v567;
                unint64_t v30 = (unint64_t)v567;
              }
              else
              {
                v30 += 8 * v29;
              }
              BOOL v569 = v617-- <= 1;
            }
            while (!v569);
          }
          return;
        case 2:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33] >= 2) {
            composite_pixelmask<(CGCompositeOperation)2,_rgbaf16_t>(v24, v600, (float16x4_t *)v30, v29, v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, *a1);
          }
          else {
            composite_pixelmask_SOVER((uint64_t)v24, v600, v30, v29, (unint64_t)v35, v36, v33, v16, a4.n128_f64[0], a5.n128_f64[0], _Q2.n128_f64[0], *(float16x4_t *)&_D3, a8, _Q5, v34, v26, v599, v616, v617,
          }
              v32);
          return;
        case 3:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)3,_rgbaf16_t>(v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v37, *a1);
          }
          else
          {
            do
            {
              __int16 v124 = (short float *)v24 + 3;
              int v125 = v616;
              do
              {
                unsigned int v126 = *v26;
                if (*v26)
                {
                  if (v126 == 255)
                  {
                    _H1 = *v124;
                    *(v124 - 3) = *(short float *)v30 * *v124;
                    *(v124 - 2) = _H1 * *(short float *)(v30 + 2);
                    *(v124 - 1) = _H1 * *(short float *)(v30 + 4);
                    if (v17)
                    {
                      _H2 = *(_WORD *)(v30 + 6);
                      __asm { FCVT            S2, H2 }
                    }
                    else
                    {
                      _S2 = 1.0;
                    }
                    int32x2_t v149 = (short float *)v24 + 3;
                    __asm { FCVT            S1, H1 }
                    _S1 = _S2 * _S1;
                  }
                  else
                  {
                    float v130 = (float)v126 * 0.0039216;
                    _H1 = *((_WORD *)v124 - 3);
                    __asm { FCVT            S5, H1 }
                    _S2 = 1.0;
                    float v134 = 1.0 - v130;
                    _H3 = *(_WORD *)v30;
                    __asm { FCVT            S6, H3 }
                    _H3 = *v124;
                    __asm { FCVT            S3, H3 }
                    float v139 = v130 * _S3;
                    _S5 = (float)(v139 * _S6) + (float)(_S5 * v134);
                    __asm { FCVT            H5, S5 }
                    *(v124 - 3) = *(short float *)&_S5;
                    *(short float *)&_S5 = *(v124 - 2);
                    __asm { FCVT            S5, H5 }
                    LOWORD(_S6) = *(_WORD *)(v30 + 2);
                    __asm { FCVT            S6, H6 }
                    _S5 = (float)(v139 * _S6) + (float)(_S5 * v134);
                    __asm { FCVT            H5, S5 }
                    *(v124 - 2) = *(short float *)&_S5;
                    *(short float *)&_S5 = *(v124 - 1);
                    __asm { FCVT            S5, H5 }
                    LOWORD(_S6) = *(_WORD *)(v30 + 4);
                    __asm { FCVT            S6, H6 }
                    _S5 = (float)(v139 * _S6) + (float)(_S5 * v134);
                    __asm { FCVT            H5, S5 }
                    *(v124 - 1) = *(short float *)&_S5;
                    if (v17)
                    {
                      _H2 = *(_WORD *)(v30 + 6);
                      __asm { FCVT            S2, H2 }
                    }
                    _S1 = (float)(v139 * _S2) + (float)(_S3 * v134);
                    int32x2_t v149 = v124;
                  }
                  __asm { FCVT            H1, S1 }
                  *(_WORD *)int32x2_t v149 = _H1;
                }
                v26 += (int)v32;
                v24 += (int)v32;
                unint64_t v152 = v30 + 8 * (int)v32;
                if (v152 >= v16) {
                  uint64_t v153 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v153 = 0;
                }
                unint64_t v30 = v152 + 8 * v153;
                v124 += 4 * (int)v32;
                --v125;
              }
              while (v125);
              v26 += v599;
              float v24 = (float16x4_t *)&v124[4 * v600 - 3];
              unsigned int v154 = &v35[v29];
              if ((unint64_t)v154 >= v598) {
                uint64_t v155 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v155 = 0;
              }
              uint64_t v156 = &v154[v155];
              uint64_t v157 = v16 + 8 * v155 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v157;
                float v35 = v156;
                unint64_t v30 = (unint64_t)v156;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 4:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)4,_rgbaf16_t>(v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v37, *a1);
          }
          else
          {
            do
            {
              float64x2_t v158 = (_WORD *)v24 + 3;
              int v159 = v616;
              do
              {
                unsigned int v160 = *v26;
                if (*v26)
                {
                  if (v160 == 255)
                  {
                    _H1 = *(_WORD *)v30;
                    __asm { FCVT            S3, H1 }
                    _H1 = *v158;
                    __asm { FCVT            S1, H1 }
                    _S2 = 1.0;
                    float v166 = 1.0 - _S1;
                    _S3 = v166 * _S3;
                    __asm { FCVT            H3, S3 }
                    *(v158 - 3) = LOWORD(_S3);
                    LOWORD(_S3) = *(_WORD *)(v30 + 2);
                    __asm { FCVT            S3, H3 }
                    _S3 = v166 * _S3;
                    __asm { FCVT            H3, S3 }
                    *(v158 - 2) = LOWORD(_S3);
                    LOWORD(_S3) = *(_WORD *)(v30 + 4);
                    __asm { FCVT            S3, H3 }
                    _S3 = v166 * _S3;
                    __asm { FCVT            H3, S3 }
                    *(v158 - 1) = LOWORD(_S3);
                    if (v17)
                    {
                      _H2 = *(_WORD *)(v30 + 6);
                      __asm { FCVT            S2, H2 }
                    }
                    CGAffineTransform v173 = (_WORD *)v24 + 3;
                    _S1 = v166 * _S2;
                  }
                  else
                  {
                    float v175 = (float)v160 * 0.0039216;
                    _H1 = *(v158 - 3);
                    __asm { FCVT            S5, H1 }
                    _S2 = 1.0;
                    float v179 = 1.0 - v175;
                    _H3 = *(_WORD *)v30;
                    __asm { FCVT            S6, H3 }
                    _H3 = *v158;
                    __asm { FCVT            S3, H3 }
                    float v184 = v175 * (float)(1.0 - _S3);
                    _S5 = (float)(v184 * _S6) + (float)(_S5 * v179);
                    __asm { FCVT            H5, S5 }
                    *(v158 - 3) = LOWORD(_S5);
                    LOWORD(_S5) = *(v158 - 2);
                    __asm { FCVT            S5, H5 }
                    LOWORD(_S6) = *(_WORD *)(v30 + 2);
                    __asm { FCVT            S6, H6 }
                    _S5 = (float)(v184 * _S6) + (float)(_S5 * v179);
                    __asm { FCVT            H5, S5 }
                    *(v158 - 2) = LOWORD(_S5);
                    LOWORD(_S5) = *(v158 - 1);
                    __asm { FCVT            S5, H5 }
                    LOWORD(_S6) = *(_WORD *)(v30 + 4);
                    __asm { FCVT            S6, H6 }
                    _S5 = (float)(v184 * _S6) + (float)(_S5 * v179);
                    __asm { FCVT            H5, S5 }
                    *(v158 - 1) = LOWORD(_S5);
                    if (v17)
                    {
                      _H2 = *(_WORD *)(v30 + 6);
                      __asm { FCVT            S2, H2 }
                    }
                    _S1 = (float)(v184 * _S2) + (float)(_S3 * v179);
                    CGAffineTransform v173 = v158;
                  }
                  __asm { FCVT            H1, S1 }
                  _WORD *v173 = _H1;
                }
                v26 += (int)v32;
                v24 += (int)v32;
                unint64_t v194 = v30 + 8 * (int)v32;
                if (v194 >= v16) {
                  uint64_t v195 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v195 = 0;
                }
                unint64_t v30 = v194 + 8 * v195;
                v158 += 4 * (int)v32;
                --v159;
              }
              while (v159);
              v26 += v599;
              float v24 = (float16x4_t *)&v158[4 * v600 - 3];
              unsigned int v196 = &v35[v29];
              if ((unint64_t)v196 >= v598) {
                uint64_t v197 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v197 = 0;
              }
              unsigned __int8 v198 = &v196[v197];
              uint64_t v199 = v16 + 8 * v197 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v199;
                float v35 = v198;
                unint64_t v30 = (unint64_t)v198;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 5:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)5,_rgbaf16_t>(v24, v600, (float16x4_t *)v30, v29, v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, *a1);
          }
          else
          {
            do
            {
              int v200 = v616;
              do
              {
                if (*v26)
                {
                  float32x4_t v201 = vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), (float)*v26 * 0.0039216)));
                  float32x4_t v202 = vcvtq_f32_f16(*v24);
                  *float v24 = vcvt_f16_f32(vmlaq_laneq_f32(vmulq_n_f32(v202, 1.0 - v201.f32[3]), v201, v202, 3));
                }
                v26 += (int)v32;
                unint64_t v203 = v30 + 8 * (int)v32;
                if (v203 >= v16) {
                  uint64_t v204 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v204 = 0;
                }
                unint64_t v30 = v203 + 8 * v204;
                v24 += (int)v32;
                --v200;
              }
              while (v200);
              v26 += v599;
              v24 += v600;
              uint64_t v205 = &v35[v29];
              if ((unint64_t)v205 >= v598) {
                uint64_t v206 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v206 = 0;
              }
              uint64_t v207 = &v205[v206];
              uint64_t v208 = v16 + 8 * v206 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v208;
                float v35 = v207;
                unint64_t v30 = (unint64_t)v207;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 6:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)6,_rgbaf16_t>((int16x4_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v37, *a1);
            return;
          }
          while (1)
          {
            int v209 = v616;
            do
            {
              unsigned int v210 = *v26;
              if (!*v26) {
                goto LABEL_289;
              }
              _H2 = v24->i16[3];
              __asm { FCVT            S2, H2 }
              float v213 = 1.0 - _S2;
              if ((float)(1.0 - _S2) >= 1.0)
              {
                _H2 = *(_WORD *)v30;
                __asm { FCVT            S3, H2 }
                float v230 = (float)v210 * 0.0039216;
                _S3 = v230 * _S3;
                __asm { FCVT            H3, S3 }
                v24->i16[0] = LOWORD(_S3);
                LOWORD(_S3) = *(_WORD *)(v30 + 2);
                __asm { FCVT            S3, H3 }
                _S3 = v230 * _S3;
                __asm { FCVT            H3, S3 }
                v24->i16[1] = LOWORD(_S3);
                LOWORD(_S3) = *(_WORD *)(v30 + 4);
                __asm { FCVT            S3, H3 }
                _S3 = v230 * _S3;
                __asm { FCVT            H3, S3 }
                v24->i16[2] = LOWORD(_S3);
                if (v17)
                {
                  _H3 = *(_WORD *)(v30 + 6);
                  __asm { FCVT            S3, H3 }
                }
                else
                {
                  _S3 = 1.0;
                }
                _S2 = v230 * _S3;
              }
              else
              {
                if (v213 <= 0.0) {
                  goto LABEL_289;
                }
                _H4 = v24->i16[0];
                __asm { FCVT            S4, H4 }
                _H5 = *(_WORD *)v30;
                __asm { FCVT            S5, H5 }
                float v218 = (float)((float)v210 * 0.0039216) * v213;
                _S4 = _S4 + (float)(_S5 * v218);
                __asm { FCVT            H4, S4 }
                v24->i16[0] = LOWORD(_S4);
                LOWORD(_S4) = v24->i16[1];
                __asm { FCVT            S4, H4 }
                LOWORD(_S5) = *(_WORD *)(v30 + 2);
                __asm { FCVT            S5, H5 }
                _S4 = _S4 + (float)(_S5 * v218);
                __asm { FCVT            H4, S4 }
                v24->i16[1] = LOWORD(_S4);
                LOWORD(_S4) = v24->i16[2];
                __asm { FCVT            S4, H4 }
                LOWORD(_S5) = *(_WORD *)(v30 + 4);
                __asm { FCVT            S5, H5 }
                _S4 = _S4 + (float)(_S5 * v218);
                __asm { FCVT            H4, S4 }
                v24->i16[2] = LOWORD(_S4);
                if (v17)
                {
                  _H4 = *(_WORD *)(v30 + 6);
                  __asm { FCVT            S4, H4 }
                }
                else
                {
                  _S4 = 1.0;
                }
                _S2 = _S2 + (float)(_S4 * v218);
              }
              __asm { FCVT            H2, S2 }
              v24->i16[3] = _H2;
LABEL_289:
              v26 += (int)v32;
              unint64_t v240 = v30 + 8 * (int)v32;
              if (v240 >= v16) {
                uint64_t v241 = -(uint64_t)(int)v33;
              }
              else {
                uint64_t v241 = 0;
              }
              unint64_t v30 = v240 + 8 * v241;
              v24 += (int)v32;
              --v209;
            }
            while (v209);
            v26 += v599;
            v24 += v600;
            unsigned __int8 v242 = &v35[v29];
            if ((unint64_t)v242 >= v598) {
              uint64_t v243 = -(uint64_t)(v29 * (int)v36);
            }
            else {
              uint64_t v243 = 0;
            }
            unsigned int v244 = &v242[v243];
            uint64_t v245 = v16 + 8 * v243 + 8 * v29;
            if (v598)
            {
              unint64_t v16 = v245;
              float v35 = v244;
              unint64_t v30 = (unint64_t)v244;
            }
            else
            {
              v30 += 8 * v29;
            }
            if (!--v617) {
              return;
            }
          }
        case 7:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)7,_rgbaf16_t>(v24, v600, (float16x4_t *)v30, v29, v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, *a1);
          }
          else
          {
            do
            {
              int v246 = v616;
              do
              {
                unsigned int v247 = *v26;
                if (*v26)
                {
                  if (v247 == 255)
                  {
                    float16x4_t v248 = vmul_n_f16(*v24, *(short float *)(v30 + 6));
                  }
                  else
                  {
                    _H3 = *(_WORD *)(v30 + 6);
                    __asm { FCVT            S3, H3 }
                    float32x4_t v251 = vcvtq_f32_f16(*v24);
                    float16x4_t v248 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v251, 1.0 - (float)((float)v247 * 0.0039216)), v251, (float)((float)v247 * 0.0039216) * _S3));
                  }
                  *float v24 = v248;
                }
                v26 += (int)v32;
                unint64_t v252 = v30 + 8 * (int)v32;
                if (v252 >= v16) {
                  uint64_t v253 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v253 = 0;
                }
                unint64_t v30 = v252 + 8 * v253;
                v24 += (int)v32;
                --v246;
              }
              while (v246);
              v26 += v599;
              v24 += v600;
              uint64_t v254 = &v35[v29];
              if ((unint64_t)v254 >= v598) {
                uint64_t v255 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v255 = 0;
              }
              int v256 = &v254[v255];
              uint64_t v257 = v16 + 8 * v255 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v257;
                float v35 = v256;
                unint64_t v30 = (unint64_t)v256;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 8:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)8,_rgbaf16_t>(v24, v600, (float16x4_t *)v30, v29, v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, *a1);
          }
          else
          {
            do
            {
              int v258 = v616;
              do
              {
                unsigned int v259 = *v26;
                if (*v26)
                {
                  _H2 = v24->i16[0];
                  if (v259 == 255)
                  {
                    __asm { FCVT            S3, H2 }
                    _H2 = *(_WORD *)(v30 + 6);
                    __asm { FCVT            S2, H2 }
                    float v264 = 1.0 - _S2;
                  }
                  else
                  {
                    __asm { FCVT            S3, H2 }
                    _H2 = *(_WORD *)(v30 + 6);
                    __asm { FCVT            S2, H2 }
                    float v264 = (float)((float)((float)v259 * -0.0039216) * _S2) + 1.0;
                  }
                  _S3 = v264 * _S3;
                  __asm { FCVT            H3, S3 }
                  v24->i16[0] = LOWORD(_S3);
                  LOWORD(_S3) = v24->i16[1];
                  __asm { FCVT            S3, H3 }
                  _S3 = v264 * _S3;
                  __asm { FCVT            H3, S3 }
                  v24->i16[1] = LOWORD(_S3);
                  LOWORD(_S3) = v24->i16[2];
                  __asm { FCVT            S3, H3 }
                  _S3 = v264 * _S3;
                  __asm { FCVT            H3, S3 }
                  v24->i16[2] = LOWORD(_S3);
                  LOWORD(_S3) = v24->i16[3];
                  __asm { FCVT            S3, H3 }
                  _S2 = v264 * _S3;
                  __asm { FCVT            H2, S2 }
                  v24->i16[3] = LOWORD(_S2);
                }
                v26 += (int)v32;
                unint64_t v274 = v30 + 8 * (int)v32;
                if (v274 >= v16) {
                  uint64_t v275 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v275 = 0;
                }
                unint64_t v30 = v274 + 8 * v275;
                v24 += (int)v32;
                --v258;
              }
              while (v258);
              v26 += v599;
              v24 += v600;
              v276 = &v35[v29];
              if ((unint64_t)v276 >= v598) {
                uint64_t v277 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v277 = 0;
              }
              v278 = &v276[v277];
              uint64_t v279 = v16 + 8 * v277 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v279;
                float v35 = v278;
                unint64_t v30 = (unint64_t)v278;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 9:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)9,_rgbaf16_t>(v24, v600, (float16x4_t *)v30, v29, v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, *a1);
          }
          else
          {
            do
            {
              int v280 = v616;
              do
              {
                if (*v26)
                {
                  float v281 = (float)*v26 * 0.0039216;
                  float v282 = 1.0 - v281;
                  float32x4_t v283 = vcvtq_f32_f16(*v24);
                  float32x4_t v284 = vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), v281)));
                  *float v24 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v283, v282 + v284.f32[3]), v284, 1.0 - v283.f32[3]));
                }
                v26 += (int)v32;
                unint64_t v285 = v30 + 8 * (int)v32;
                if (v285 >= v16) {
                  uint64_t v286 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v286 = 0;
                }
                unint64_t v30 = v285 + 8 * v286;
                v24 += (int)v32;
                --v280;
              }
              while (v280);
              v26 += v599;
              v24 += v600;
              unsigned __int8 v287 = &v35[v29];
              if ((unint64_t)v287 >= v598) {
                uint64_t v288 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v288 = 0;
              }
              unsigned int v289 = &v287[v288];
              uint64_t v290 = v16 + 8 * v288 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v290;
                float v35 = v289;
                unint64_t v30 = (unint64_t)v289;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 10:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)10,_rgbaf16_t>(v24, v600, (float16x4_t *)v30, v29, v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, *a1);
          }
          else
          {
            do
            {
              int v291 = v616;
              do
              {
                if (*v26)
                {
                  float32x4_t v292 = vcvtq_f32_f16(*v24);
                  float32x4_t v293 = vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), (float)*v26 * 0.0039216)));
                  *float v24 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v292, 1.0 - v293.f32[3]), v293, 1.0 - v292.f32[3]));
                }
                v26 += (int)v32;
                unint64_t v294 = v30 + 8 * (int)v32;
                if (v294 >= v16) {
                  uint64_t v295 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v295 = 0;
                }
                unint64_t v30 = v294 + 8 * v295;
                v24 += (int)v32;
                --v291;
              }
              while (v291);
              v26 += v599;
              v24 += v600;
              v296 = &v35[v29];
              if ((unint64_t)v296 >= v598) {
                uint64_t v297 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v297 = 0;
              }
              uint64_t v298 = &v296[v297];
              uint64_t v299 = v16 + 8 * v297 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v299;
                float v35 = v298;
                unint64_t v30 = (unint64_t)v298;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 11:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)11,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
          }
          else
          {
            do
            {
              int v300 = v616;
              do
              {
                unsigned int v301 = *v26;
                if (*v26)
                {
                  float v302 = (float)v301 * 0.0039216;
                  _H2 = *(_WORD *)(v30 + 6);
                  __asm { FCVT            S2, H2 }
                  _S2 = v302 * _S2;
                  __asm { FCVT            H2, S2 }
                  if (v15)
                  {
                    _H3 = v24->i16[3];
                    __asm
                    {
                      FCVT            S6, H3
                      FCVT            S2, H2
                    }
                    if (!v17) {
                      _S2 = (float)v301 * 0.0039216;
                    }
                  }
                  else
                  {
                    __asm { FCVT            S2, H2 }
                    if (!v17) {
                      _S2 = (float)v301 * 0.0039216;
                    }
                    _S6 = 1.0;
                  }
                  _S3 = _S2 + _S6;
                  _S4 = 1.0;
                  if ((float)(_S2 + _S6) > 1.0) {
                    _S3 = 1.0;
                  }
                  _S5 = 1.0;
                  if (v15)
                  {
                    _H5 = v24->i16[3];
                    __asm { FCVT            S5, H5 }
                  }
                  _H7 = *(_WORD *)v30;
                  __asm { FCVT            S7, H7 }
                  _S7 = v302 * _S7;
                  __asm { FCVT            H17, S7 }
                  _H16 = *(_WORD *)(v30 + 2);
                  _H7 = *(_WORD *)(v30 + 4);
                  _H18 = v24->i16[0];
                  __asm
                  {
                    FCVT            S18, H18
                    FCVT            S17, H17
                  }
                  float v323 = (float)(_S2 - _S17) + (float)(_S6 - _S18);
                  _H6 = v24->i16[1];
                  _S17 = _S3 - v323;
                  __asm { FCVT            H17, S17 }
                  v24->i16[0] = LOWORD(_S17);
                  if (v15)
                  {
                    _H4 = v24->i16[3];
                    __asm { FCVT            S4, H4 }
                  }
                  __asm { FCVT            S16, H16 }
                  _S16 = v302 * _S16;
                  __asm
                  {
                    FCVT            H16, S16
                    FCVT            S7, H7
                  }
                  _S1 = v302 * _S7;
                  __asm
                  {
                    FCVT            H1, S1
                    FCVT            S6, H6
                  }
                  float v332 = _S5 - _S6;
                  __asm { FCVT            S6, H16 }
                  float v334 = (float)(_S2 - _S6) + v332;
                  LOWORD(_S6) = v24->i16[2];
                  __asm
                  {
                    FCVT            S6, H6
                    FCVT            S1, H1
                  }
                  float v337 = (float)(_S2 - _S1) + (float)(_S4 - _S6);
                  _S2 = _S3 - v334;
                  __asm { FCVT            H2, S2 }
                  v24->i16[1] = LOWORD(_S2);
                  __asm { FCVT            H2, S3 }
                  v24->i16[3] = LOWORD(_S2);
                  _S1 = _S3 - v337;
                  __asm { FCVT            H1, S1 }
                  v24->i16[2] = LOWORD(_S1);
                }
                v26 += (int)v32;
                unint64_t v340 = v30 + 8 * (int)v32;
                if (v340 >= v16) {
                  uint64_t v341 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v341 = 0;
                }
                unint64_t v30 = v340 + 8 * v341;
                v24 += (int)v32;
                --v300;
              }
              while (v300);
              v26 += v599;
              v24 += v600;
              uint64_t v342 = &v35[v29];
              if ((unint64_t)v342 >= v598) {
                uint64_t v343 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v343 = 0;
              }
              uint64_t v344 = &v342[v343];
              uint64_t v345 = v16 + 8 * v343 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v345;
                float v35 = v344;
                unint64_t v30 = (unint64_t)v344;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 12:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)12,_rgbaf16_t>(v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v37, *a1);
          }
          else
          {
            do
            {
              int v346 = v616;
              do
              {
                if (*v26)
                {
                  float v347 = (float)*v26 * 0.0039216;
                  _H3 = *(_WORD *)v30;
                  __asm { FCVT            S3, H3 }
                  _S3 = v347 * _S3;
                  __asm { FCVT            H3, S3 }
                  _H4 = *(_WORD *)(v30 + 2);
                  __asm { FCVT            S4, H4 }
                  _S4 = v347 * _S4;
                  __asm { FCVT            H4, S4 }
                  _H5 = *(_WORD *)(v30 + 4);
                  __asm { FCVT            S5, H5 }
                  _S5 = v347 * _S5;
                  __asm { FCVT            H5, S5 }
                  _H6 = *(_WORD *)(v30 + 6);
                  __asm { FCVT            S6, H6 }
                  _S6 = v347 * _S6;
                  __asm { FCVT            H6, S6 }
                  short float v361 = *(short float *)&v24->i16[1];
                  *(short float *)v24->i16 = *(short float *)v24->i16 + *(short float *)&_S3;
                  *(short float *)&v24->i16[1] = v361 + *(short float *)&_S4;
                  LOWORD(_S3) = v24->i16[3];
                  __asm
                  {
                    FCVT            S3, H3
                    FCVT            S4, H6
                  }
                  if (v17) {
                    float v347 = _S4;
                  }
                  _S2 = v347 + _S3;
                  if (_S2 > 1.0) {
                    _S2 = 1.0;
                  }
                  *(short float *)&v24->i16[2] = *(short float *)&v24->i16[2] + _H5;
                  __asm { FCVT            H2, S2 }
                  v24->i16[3] = _H2;
                }
                v26 += (int)v32;
                unint64_t v366 = v30 + 8 * (int)v32;
                if (v366 >= v16) {
                  uint64_t v367 = -(uint64_t)(int)v33;
                }
                else {
                  uint64_t v367 = 0;
                }
                unint64_t v30 = v366 + 8 * v367;
                v24 += (int)v32;
                --v346;
              }
              while (v346);
              v26 += v599;
              v24 += v600;
              v368 = &v35[v29];
              if ((unint64_t)v368 >= v598) {
                uint64_t v369 = -(uint64_t)(v29 * (int)v36);
              }
              else {
                uint64_t v369 = 0;
              }
              uint64_t v370 = &v368[v369];
              uint64_t v371 = v16 + 8 * v369 + 8 * v29;
              if (v598)
              {
                unint64_t v16 = v371;
                float v35 = v370;
                unint64_t v30 = (unint64_t)v370;
              }
              else
              {
                v30 += 8 * v29;
              }
              --v617;
            }
            while (v617);
          }
          return;
        case 13:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)13,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v372 = (int)v32;
          uint64_t v373 = -(uint64_t)(int)v33;
          uint64_t v587 = -(uint64_t)(v29 * (int)v36);
          uint64_t v374 = 8 * (int)v32;
          while (1)
          {
            v606 = v35;
            int v375 = v616;
            do
            {
              unsigned int v376 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v376 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v377 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v377);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v376 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v377);
                      v24->i16[2] = WORD2(v377);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_427;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAmultiplyPDA(a4, _Q1, _Q2, _D3, _S4, v377, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v377), SWORD1(v377), SWORD2(v377),
                                  _Q6.f32[0]);
                  v24->i16[1] = v380;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_427:
              v26 += v372;
              unint64_t v382 = v30 + 8 * v372;
              if (v382 >= v16) {
                uint64_t v383 = v373;
              }
              else {
                uint64_t v383 = 0;
              }
              unint64_t v30 = v382 + 8 * v383;
              float v24 = (float16x4_t *)((char *)v24 + v374);
              --v375;
            }
            while (v375);
            v26 += v599;
            float v35 = v606;
            v24 += v600;
            uint64_t v384 = v587;
            uint64_t v385 = &v606[v597];
            if ((unint64_t)v385 < v598) {
              uint64_t v384 = 0;
            }
            v386 = &v385[v384];
            uint64_t v387 = v16 + 8 * v384 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v387;
              float v35 = v386;
              unint64_t v30 = (unint64_t)v386;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 14:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)14,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          while (1)
          {
            int v388 = v616;
            do
            {
              unsigned int v389 = *v26;
              if (*v26)
              {
                float v390 = (float)v389 * 0.0039216;
                _H2 = *(_WORD *)(v30 + 6);
                __asm { FCVT            S2, H2 }
                _S2 = v390 * _S2;
                __asm
                {
                  FCVT            H2, S2
                  FCVT            S2, H2
                }
                if (!v17) {
                  _S2 = (float)v389 * 0.0039216;
                }
                if (_S2 > 0.0)
                {
                  _H3 = *(_WORD *)v30;
                  __asm { FCVT            S3, H3 }
                  _S3 = v390 * _S3;
                  __asm { FCVT            H3, S3 }
                  _H4 = *(_WORD *)(v30 + 2);
                  __asm { FCVT            S4, H4 }
                  _S4 = v390 * _S4;
                  __asm { FCVT            H4, S4 }
                  _H6 = *(_WORD *)(v30 + 4);
                  __asm { FCVT            S6, H6 }
                  _S5 = v390 * _S6;
                  __asm { FCVT            H5, S5 }
                  if (v15)
                  {
                    __asm { FCMP            H6, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i16[0] = _H3;
                      v24->i16[1] = _H4;
                      v24->i16[2] = _H5;
                      __asm { FCVT            H2, S2 }
LABEL_449:
                      v24->i16[3] = _H2;
                      goto LABEL_450;
                    }
                    __asm { FCVT            S6, H6 }
                  }
                  else
                  {
                    _S6 = 1.0;
                  }
                  _H7 = v24->i16[0];
                  _H16 = v24->i16[1];
                  _H17 = v24->i16[2];
                  __asm
                  {
                    FCVT            S7, H7
                    FCVT            S16, H16
                    FCVT            S17, H17
                    FCVT            S3, H3
                    FCVT            S4, H4
                    FCVT            S5, H5
                  }
                  _S3 = _S7 + (float)(_S3 * (float)(1.0 - _S7));
                  _S4 = _S16 + (float)(_S4 * (float)(1.0 - _S16));
                  _S5 = _S17 + (float)(_S5 * (float)(1.0 - _S17));
                  _S2 = (float)(_S2 + _S6) - (float)(_S6 * _S2);
                  __asm
                  {
                    FCVT            H3, S3
                    FCVT            H4, S4
                    FCVT            H5, S5
                  }
                  v24->i16[0] = LOWORD(_S3);
                  v24->i16[1] = LOWORD(_S4);
                  __asm { FCVT            H2, S2 }
                  v24->i16[2] = LOWORD(_S5);
                  goto LABEL_449;
                }
              }
LABEL_450:
              v26 += (int)v32;
              unint64_t v423 = v30 + 8 * (int)v32;
              if (v423 >= v16) {
                uint64_t v424 = -(uint64_t)(int)v33;
              }
              else {
                uint64_t v424 = 0;
              }
              unint64_t v30 = v423 + 8 * v424;
              v24 += (int)v32;
              --v388;
            }
            while (v388);
            v26 += v599;
            v24 += v600;
            unsigned int v425 = &v35[v29];
            if ((unint64_t)v425 >= v598) {
              uint64_t v426 = -(uint64_t)(v29 * (int)v36);
            }
            else {
              uint64_t v426 = 0;
            }
            uint64_t v427 = &v425[v426];
            uint64_t v428 = v16 + 8 * v426 + 8 * v29;
            if (v598)
            {
              unint64_t v16 = v428;
              float v35 = v427;
              unint64_t v30 = (unint64_t)v427;
            }
            else
            {
              v30 += 8 * v29;
            }
            if (!--v617) {
              return;
            }
          }
        case 15:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)15,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v429 = (int)v32;
          uint64_t v430 = -(uint64_t)(int)v33;
          uint64_t v588 = -(uint64_t)(v29 * (int)v36);
          uint64_t v431 = 8 * (int)v32;
          while (1)
          {
            v607 = v35;
            int v432 = v616;
            do
            {
              unsigned int v433 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v433 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v434 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v434);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v433 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v434);
                      v24->i16[2] = WORD2(v434);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_475;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAoverlayPDA(a4, _Q1, _Q2, _D3, _S4, v434, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v434), SWORD1(v434), SWORD2(v434),
                                  _Q6.f32[0]);
                  v24->i16[1] = v437;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_475:
              v26 += v429;
              unint64_t v439 = v30 + 8 * v429;
              if (v439 >= v16) {
                uint64_t v440 = v430;
              }
              else {
                uint64_t v440 = 0;
              }
              unint64_t v30 = v439 + 8 * v440;
              float v24 = (float16x4_t *)((char *)v24 + v431);
              --v432;
            }
            while (v432);
            v26 += v599;
            float v35 = v607;
            v24 += v600;
            uint64_t v441 = v588;
            uint64_t v442 = &v607[v597];
            if ((unint64_t)v442 < v598) {
              uint64_t v441 = 0;
            }
            v443 = &v442[v441];
            uint64_t v444 = v16 + 8 * v441 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v444;
              float v35 = v443;
              unint64_t v30 = (unint64_t)v443;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 16:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)16,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v445 = (int)v32;
          uint64_t v446 = -(uint64_t)(int)v33;
          uint64_t v589 = -(uint64_t)(v29 * (int)v36);
          uint64_t v447 = 8 * (int)v32;
          while (1)
          {
            v608 = v35;
            int v448 = v616;
            do
            {
              unsigned int v449 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v449 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v450 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v450);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v449 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v450);
                      v24->i16[2] = WORD2(v450);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_499;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAdarkenPDA(a4, _Q1, _Q2, _D3, _S4, v450, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v450), SWORD1(v450), SWORD2(v450),
                                  _Q6.f32[0]);
                  v24->i16[1] = v453;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_499:
              v26 += v445;
              unint64_t v455 = v30 + 8 * v445;
              if (v455 >= v16) {
                uint64_t v456 = v446;
              }
              else {
                uint64_t v456 = 0;
              }
              unint64_t v30 = v455 + 8 * v456;
              float v24 = (float16x4_t *)((char *)v24 + v447);
              --v448;
            }
            while (v448);
            v26 += v599;
            float v35 = v608;
            v24 += v600;
            uint64_t v457 = v589;
            v458 = &v608[v597];
            if ((unint64_t)v458 < v598) {
              uint64_t v457 = 0;
            }
            v459 = &v458[v457];
            uint64_t v460 = v16 + 8 * v457 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v460;
              float v35 = v459;
              unint64_t v30 = (unint64_t)v459;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 17:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)17,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v461 = (int)v32;
          uint64_t v462 = -(uint64_t)(int)v33;
          uint64_t v590 = -(uint64_t)(v29 * (int)v36);
          uint64_t v463 = 8 * (int)v32;
          while (1)
          {
            v609 = v35;
            int v464 = v616;
            do
            {
              unsigned int v465 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v465 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v466 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v466);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v465 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v466);
                      v24->i16[2] = WORD2(v466);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_523;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAlightenPDA(a4, _Q1, _Q2, _D3, _S4, v466, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v466), SWORD1(v466), SWORD2(v466),
                                  _Q6.f32[0]);
                  v24->i16[1] = v469;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_523:
              v26 += v461;
              unint64_t v471 = v30 + 8 * v461;
              if (v471 >= v16) {
                uint64_t v472 = v462;
              }
              else {
                uint64_t v472 = 0;
              }
              unint64_t v30 = v471 + 8 * v472;
              float v24 = (float16x4_t *)((char *)v24 + v463);
              --v464;
            }
            while (v464);
            v26 += v599;
            float v35 = v609;
            v24 += v600;
            uint64_t v473 = v590;
            v474 = &v609[v597];
            if ((unint64_t)v474 < v598) {
              uint64_t v473 = 0;
            }
            uint64_t v475 = &v474[v473];
            uint64_t v476 = v16 + 8 * v473 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v476;
              float v35 = v475;
              unint64_t v30 = (unint64_t)v475;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 18:
          uint64_t v42 = (int)v32;
          uint64_t v43 = -(uint64_t)(int)v33;
          uint64_t v582 = -(uint64_t)(v29 * (int)v36);
          uint64_t v44 = 8 * (int)v32;
          while (1)
          {
            v601 = v35;
            int v45 = v616;
            do
            {
              unsigned int v46 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v46 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v47 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v47);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v46 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v47);
                      v24->i16[2] = WORD2(v47);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_93;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAcolordodgePDA(a4, _Q1, _Q2, _D3, _S4, v47, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v47), SWORD1(v47), SWORD2(v47),
                                  _Q6.f32[0]);
                  v24->i16[1] = v54;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_93:
              v26 += v42;
              unint64_t v56 = v30 + 8 * v42;
              if (v56 >= v16) {
                uint64_t v57 = v43;
              }
              else {
                uint64_t v57 = 0;
              }
              unint64_t v30 = v56 + 8 * v57;
              float v24 = (float16x4_t *)((char *)v24 + v44);
              --v45;
            }
            while (v45);
            v26 += v599;
            float v35 = v601;
            v24 += v600;
            uint64_t v58 = v582;
            uint64_t v59 = &v601[v597];
            if ((unint64_t)v59 < v598) {
              uint64_t v58 = 0;
            }
            char v60 = &v59[v58];
            uint64_t v61 = v16 + 8 * v58 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v61;
              float v35 = v60;
              unint64_t v30 = (unint64_t)v60;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 19:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)19,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v477 = (int)v32;
          uint64_t v478 = -(uint64_t)(int)v33;
          uint64_t v591 = -(uint64_t)(v29 * (int)v36);
          uint64_t v479 = 8 * (int)v32;
          while (1)
          {
            v610 = v35;
            int v480 = v616;
            do
            {
              unsigned int v481 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v481 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v482 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v482);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v481 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v482);
                      v24->i16[2] = WORD2(v482);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_547;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAcolorburnPDA(a4, _Q1, _Q2, _D3, _S4, v482, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v482), SWORD1(v482), SWORD2(v482),
                                  _Q6.f32[0]);
                  v24->i16[1] = v485;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_547:
              v26 += v477;
              unint64_t v487 = v30 + 8 * v477;
              if (v487 >= v16) {
                uint64_t v488 = v478;
              }
              else {
                uint64_t v488 = 0;
              }
              unint64_t v30 = v487 + 8 * v488;
              float v24 = (float16x4_t *)((char *)v24 + v479);
              --v480;
            }
            while (v480);
            v26 += v599;
            float v35 = v610;
            v24 += v600;
            uint64_t v489 = v591;
            uint64_t v490 = &v610[v597];
            if ((unint64_t)v490 < v598) {
              uint64_t v489 = 0;
            }
            v491 = &v490[v489];
            uint64_t v492 = v16 + 8 * v489 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v492;
              float v35 = v491;
              unint64_t v30 = (unint64_t)v491;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 20:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)20,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v493 = (int)v32;
          uint64_t v494 = -(uint64_t)(int)v33;
          uint64_t v592 = -(uint64_t)(v29 * (int)v36);
          uint64_t v495 = 8 * (int)v32;
          while (1)
          {
            v611 = v35;
            int v496 = v616;
            do
            {
              unsigned int v497 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v497 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v498 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v498);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v497 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v498);
                      v24->i16[2] = WORD2(v498);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_571;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAsoftlightPDA(a4, _Q1, _Q2, _D3, _S4, v498, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v498), SWORD1(v498), SWORD2(v498),
                                  _Q6.f32[0]);
                  v24->i16[1] = v501;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_571:
              v26 += v493;
              unint64_t v503 = v30 + 8 * v493;
              if (v503 >= v16) {
                uint64_t v504 = v494;
              }
              else {
                uint64_t v504 = 0;
              }
              unint64_t v30 = v503 + 8 * v504;
              float v24 = (float16x4_t *)((char *)v24 + v495);
              --v496;
            }
            while (v496);
            v26 += v599;
            float v35 = v611;
            v24 += v600;
            uint64_t v505 = v592;
            uint64_t v506 = &v611[v597];
            if ((unint64_t)v506 < v598) {
              uint64_t v505 = 0;
            }
            uint64_t v507 = &v506[v505];
            uint64_t v508 = v16 + 8 * v505 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v508;
              float v35 = v507;
              unint64_t v30 = (unint64_t)v507;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 21:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)21,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v509 = (int)v32;
          uint64_t v510 = -(uint64_t)(int)v33;
          uint64_t v593 = -(uint64_t)(v29 * (int)v36);
          uint64_t v511 = 8 * (int)v32;
          while (1)
          {
            v612 = v35;
            int v512 = v616;
            do
            {
              unsigned int v513 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v513 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v514 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v514);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v513 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v514);
                      v24->i16[2] = WORD2(v514);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_595;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAhardlightPDA(a4, _Q1, _Q2, _D3, _S4, v514, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v514), SWORD1(v514), SWORD2(v514),
                                  _Q6.f32[0]);
                  v24->i16[1] = v517;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_595:
              v26 += v509;
              unint64_t v519 = v30 + 8 * v509;
              if (v519 >= v16) {
                uint64_t v520 = v510;
              }
              else {
                uint64_t v520 = 0;
              }
              unint64_t v30 = v519 + 8 * v520;
              float v24 = (float16x4_t *)((char *)v24 + v511);
              --v512;
            }
            while (v512);
            v26 += v599;
            float v35 = v612;
            v24 += v600;
            uint64_t v521 = v593;
            uint64_t v522 = &v612[v597];
            if ((unint64_t)v522 < v598) {
              uint64_t v521 = 0;
            }
            uint64_t v523 = &v522[v521];
            uint64_t v524 = v16 + 8 * v521 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v524;
              float v35 = v523;
              unint64_t v30 = (unint64_t)v523;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 22:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)22,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v525 = (int)v32;
          uint64_t v526 = -(uint64_t)(int)v33;
          uint64_t v594 = -(uint64_t)(v29 * (int)v36);
          uint64_t v527 = 8 * (int)v32;
          while (1)
          {
            v613 = v35;
            int v528 = v616;
            do
            {
              unsigned int v529 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v529 * 0.0039216;
                _Q1 = vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v530 = COERCE_DOUBLE(vcvt_f16_f32(_Q1));
                LOWORD(_D7) = HIWORD(v530);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.f32[0] : (float)v529 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v530);
                      v24->i16[2] = WORD2(v530);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_619;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.i16[0] = v24->i16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAdifferencePDA(a4, *(double *)_Q1.i64, _Q2.n128_f64[0], _D3, _S4, v530, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v530), SHIDWORD(v530), _Q6.f32[0]);
                  v24->i16[1] = v533;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_619:
              v26 += v525;
              unint64_t v535 = v30 + 8 * v525;
              if (v535 >= v16) {
                uint64_t v536 = v526;
              }
              else {
                uint64_t v536 = 0;
              }
              unint64_t v30 = v535 + 8 * v536;
              float v24 = (float16x4_t *)((char *)v24 + v527);
              --v528;
            }
            while (v528);
            v26 += v599;
            float v35 = v613;
            v24 += v600;
            uint64_t v537 = v594;
            v538 = &v613[v597];
            if ((unint64_t)v538 < v598) {
              uint64_t v537 = 0;
            }
            v539 = &v538[v537];
            uint64_t v540 = v16 + 8 * v537 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v540;
              float v35 = v539;
              unint64_t v30 = (unint64_t)v539;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 23:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)23,_rgbaf16_t>((int8x8_t *)v24, v600, (int8x8_t *)v30, v29, (int8x8_t *)v35, v36, v33, v16, v34, v26, v599, v616, v617, v32, v20, v37, *a1);
            return;
          }
          uint64_t v541 = (int)v32;
          uint64_t v542 = -(uint64_t)(int)v33;
          uint64_t v595 = -(uint64_t)(v29 * (int)v36);
          uint64_t v543 = 8 * (int)v32;
          while (1)
          {
            v614 = v35;
            int v544 = v616;
            do
            {
              unsigned int v545 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v545 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v546 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v546);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v545 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v546);
                      v24->i16[2] = WORD2(v546);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_643;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAexclusionPDA(a4, _Q1, _Q2, _D3, _S4, v546, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v546), SWORD1(v546), SWORD2(v546),
                                  _Q6.f32[0]);
                  v24->i16[1] = v549;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_643:
              v26 += v541;
              unint64_t v551 = v30 + 8 * v541;
              if (v551 >= v16) {
                uint64_t v552 = v542;
              }
              else {
                uint64_t v552 = 0;
              }
              unint64_t v30 = v551 + 8 * v552;
              float v24 = (float16x4_t *)((char *)v24 + v543);
              --v544;
            }
            while (v544);
            v26 += v599;
            float v35 = v614;
            v24 += v600;
            uint64_t v553 = v595;
            v554 = &v614[v597];
            if ((unint64_t)v554 < v598) {
              uint64_t v553 = 0;
            }
            v555 = &v554[v553];
            uint64_t v556 = v16 + 8 * v553 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v556;
              float v35 = v555;
              unint64_t v30 = (unint64_t)v555;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 24:
          uint64_t v62 = (int)v32;
          uint64_t v63 = -(uint64_t)(int)v33;
          uint64_t v583 = -(uint64_t)(v29 * (int)v36);
          uint64_t v64 = 8 * (int)v32;
          while (1)
          {
            v602 = v35;
            int v65 = v616;
            do
            {
              unsigned int v66 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v66 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v67 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v67);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v66 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v67);
                      v24->i16[2] = WORD2(v67);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_132;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAhuePDA(a4, _Q1, _Q2, _D3, _S4, v67, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v67), SWORD1(v67), SWORD2(v67),
                                  _Q6.f32[0]);
                  v24->i16[1] = v70;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_132:
              v26 += v62;
              unint64_t v72 = v30 + 8 * v62;
              if (v72 >= v16) {
                uint64_t v73 = v63;
              }
              else {
                uint64_t v73 = 0;
              }
              unint64_t v30 = v72 + 8 * v73;
              float v24 = (float16x4_t *)((char *)v24 + v64);
              --v65;
            }
            while (v65);
            v26 += v599;
            float v35 = v602;
            v24 += v600;
            uint64_t v74 = v583;
            __int16 v75 = &v602[v597];
            if ((unint64_t)v75 < v598) {
              uint64_t v74 = 0;
            }
            __int16 v76 = &v75[v74];
            uint64_t v77 = v16 + 8 * v74 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v77;
              float v35 = v76;
              unint64_t v30 = (unint64_t)v76;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 25:
          uint64_t v78 = (int)v32;
          uint64_t v79 = -(uint64_t)(int)v33;
          uint64_t v584 = -(uint64_t)(v29 * (int)v36);
          uint64_t v80 = 8 * (int)v32;
          while (1)
          {
            v603 = v35;
            int v81 = v616;
            do
            {
              unsigned int v82 = *v26;
              if (*v26)
              {
                a4.n128_f32[0] = (float)v82 * 0.0039216;
                _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
                double v83 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
                LOWORD(_D7) = HIWORD(v83);
                __asm { FCVT            S1, H7 }
                _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v82 * 0.0039216;
                if (_Q6.f32[0] > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H3, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = LODWORD(v83);
                      v24->i16[2] = WORD2(v83);
                      __asm { FCVT            H0, S6 }
                      v24->i16[3] = _H0;
                      goto LABEL_156;
                    }
                    __asm { FCVT            S4, H3 }
                  }
                  else
                  {
                    LOWORD(_D3) = v24->i16[3];
                    _S4 = 1.0;
                  }
                  a4.n128_u16[0] = v24->i16[0];
                  _Q1.n128_u16[0] = v24->u16[1];
                  _Q2.n128_u16[0] = v24->u16[2];
                  v24->i16[0] = PDAsaturationPDA(a4, _Q1, _Q2, _D3, _S4, v83, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v83), SWORD1(v83), SWORD2(v83),
                                  _Q6.f32[0]);
                  v24->i16[1] = v86;
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_156:
              v26 += v78;
              unint64_t v88 = v30 + 8 * v78;
              if (v88 >= v16) {
                uint64_t v89 = v79;
              }
              else {
                uint64_t v89 = 0;
              }
              unint64_t v30 = v88 + 8 * v89;
              float v24 = (float16x4_t *)((char *)v24 + v80);
              --v81;
            }
            while (v81);
            v26 += v599;
            float v35 = v603;
            v24 += v600;
            uint64_t v90 = v584;
            float v91 = &v603[v597];
            if ((unint64_t)v91 < v598) {
              uint64_t v90 = 0;
            }
            int v92 = &v91[v90];
            uint64_t v93 = v16 + 8 * v90 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v93;
              float v35 = v92;
              unint64_t v30 = (unint64_t)v92;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 26:
          uint64_t v94 = (int)v32;
          uint64_t v95 = -(uint64_t)(int)v33;
          uint64_t v585 = -(uint64_t)(v29 * (int)v36);
          uint64_t v96 = 8 * (int)v32;
          while (1)
          {
            v604 = v35;
            int v97 = v616;
            do
            {
              unsigned int v98 = *v26;
              if (*v26)
              {
                a5.n128_f32[0] = (float)v98 * 0.0039216;
                __n128 v99 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a5.n128_f32[0]);
                v99.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v99);
                LOWORD(_D3) = v99.n128_u16[3];
                __asm { FCVT            S2, H3 }
                _S4 = v17 ? _Q2.n128_f32[0] : (float)v98 * 0.0039216;
                if (_S4 > 0.0)
                {
                  if (v15)
                  {
                    __asm { FCMP            H5, #0 }
                    if (!(!_ZF & _CF))
                    {
                      v24->i32[0] = v99.n128_u32[0];
                      v24->i16[2] = v99.n128_i16[2];
                      __asm { FCVT            H0, S4 }
                      v24->i16[3] = _H0;
                      goto LABEL_180;
                    }
                    __asm { FCVT            S6, H5 }
                  }
                  else
                  {
                    _Q5.i16[0] = v24->i16[3];
                    _Q6.i32[0] = 1.0;
                  }
                  LOWORD(_D7) = v24->i16[0];
                  a5.n128_u16[0] = v99.n128_u16[1];
                  _Q2.n128_u16[0] = v99.n128_u16[2];
                  v24->i16[0] = PDAluminosityPDA(v99, a5, _Q2, _D3, _S4, *(double *)_Q5.i64, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, v24->i16[0], *(__int32 *)((char *)v24->i32 + 2), HIWORD(*(unsigned __int32 *)((char *)v24->i32 + 2)),
                                  _Q6.f32[0]);
                  v24->i16[1] = a5.n128_u16[0];
                  v24->i16[2] = _Q2.n128_u16[0];
                  v24->i16[3] = LOWORD(_D3);
                }
              }
LABEL_180:
              v26 += v94;
              unint64_t v102 = v30 + 8 * v94;
              if (v102 >= v16) {
                uint64_t v103 = v95;
              }
              else {
                uint64_t v103 = 0;
              }
              unint64_t v30 = v102 + 8 * v103;
              float v24 = (float16x4_t *)((char *)v24 + v96);
              --v97;
            }
            while (v97);
            v26 += v599;
            float v35 = v604;
            v24 += v600;
            uint64_t v104 = v585;
            __int16 v105 = &v604[v597];
            if ((unint64_t)v105 < v598) {
              uint64_t v104 = 0;
            }
            __int16 v106 = &v105[v104];
            uint64_t v107 = v16 + 8 * v104 + 8 * v597;
            if (v598)
            {
              unint64_t v16 = v107;
              float v35 = v106;
              unint64_t v30 = (unint64_t)v106;
            }
            else
            {
              v30 += 8 * v597;
            }
            if (!--v617) {
              return;
            }
          }
        case 27:
          uint64_t v108 = (int)v32;
          uint64_t v109 = -(uint64_t)(int)v33;
          uint64_t v586 = -(uint64_t)(v29 * (int)v36);
          uint64_t v110 = 8 * (int)v32;
          break;
        default:
          return;
      }
LABEL_192:
      v605 = v35;
      int v111 = v616;
      while (1)
      {
        unsigned int v112 = *v26;
        if (!*v26) {
          goto LABEL_204;
        }
        a4.n128_f32[0] = (float)v112 * 0.0039216;
        _Q1 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v30), a4.n128_f32[0]);
        double v113 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)_Q1));
        LOWORD(_D7) = HIWORD(v113);
        __asm { FCVT            S1, H7 }
        _Q6.f32[0] = v17 ? _Q1.n128_f32[0] : (float)v112 * 0.0039216;
        if (_Q6.f32[0] <= 0.0) {
          goto LABEL_204;
        }
        if (!v15) {
          break;
        }
        __asm { FCMP            H3, #0 }
        if (!_ZF & _CF)
        {
          __asm { FCVT            S4, H3 }
LABEL_203:
          a4.n128_u16[0] = v24->i16[0];
          _Q1.n128_u16[0] = v24->u16[1];
          _Q2.n128_u16[0] = v24->u16[2];
          v24->i16[0] = PDAluminosityPDA(a4, _Q1, _Q2, _D3, _S4, v113, *(double *)_Q6.i64, _D7, v21, v22, a3, v32, v37, v36, v33, v29, SLOWORD(v113), SWORD1(v113), SWORD2(v113),
                          _Q6.f32[0]);
          v24->i16[1] = v116;
          v24->i16[2] = _Q2.n128_u16[0];
          v24->i16[3] = LOWORD(_D3);
          goto LABEL_204;
        }
        v24->i32[0] = LODWORD(v113);
        v24->i16[2] = WORD2(v113);
        __asm { FCVT            H0, S6 }
        v24->i16[3] = _H0;
LABEL_204:
        v26 += v108;
        unint64_t v118 = v30 + 8 * v108;
        if (v118 >= v16) {
          uint64_t v119 = v109;
        }
        else {
          uint64_t v119 = 0;
        }
        unint64_t v30 = v118 + 8 * v119;
        float v24 = (float16x4_t *)((char *)v24 + v110);
        if (!--v111)
        {
          v26 += v599;
          float v35 = v605;
          v24 += v600;
          uint64_t v120 = v586;
          char v121 = &v605[v597];
          if ((unint64_t)v121 < v598) {
            uint64_t v120 = 0;
          }
          uint64_t v122 = &v121[v120];
          uint64_t v123 = v16 + 8 * v120 + 8 * v597;
          if (v598)
          {
            unint64_t v16 = v123;
            float v35 = v122;
            unint64_t v30 = (unint64_t)v122;
          }
          else
          {
            v30 += 8 * v597;
          }
          if (!--v617) {
            return;
          }
          goto LABEL_192;
        }
      }
      LOWORD(_D3) = v24->i16[3];
      _S4 = 1.0;
      goto LABEL_203;
    }
    if ((uint64_t)((uint64_t)v24 - v30) >= 1)
    {
      if (v616 >= (uint64_t)(((unint64_t)v24 - v30) >> 3))
      {
        v24 += v616 - 1;
        v30 += 8 * (v616 - 1);
        v26 += v616 - 1;
        uint64_t v32 = 0xFFFFFFFFLL;
        goto LABEL_13;
      }
      uint64_t v31 = v23 * (v617 - 1);
      if ((unint64_t)v24 <= v30 + 8 * v31 + 8 * (v616 - 1))
      {
        v24 += v31;
        unint64_t v29 = -(uint64_t)v23;
        v26 += v25 * (v617 - 1);
        uint64_t v25 = -v25;
        uint64_t v32 = 1;
        v30 += 8 * v31;
        unint64_t v23 = -(uint64_t)v23;
        goto LABEL_14;
      }
    }
    uint64_t v32 = 1;
LABEL_13:
    unint64_t v29 = v23;
    goto LABEL_14;
  }
}

void RGBAf16_mark_const_deep_mask_ARGB(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  uint64_t v88 = *(unsigned int *)(a1 + 4);
  if ((int)v88 < 1 || (int)v8 < 1) {
    return;
  }
  uint64_t v11 = *(void *)(a1 + 136);
  if (!v11) {
    return;
  }
  uint64_t v13 = *(void *)(a1 + 40);
  *(void *)uint64_t v94 = **(void **)(a1 + 88);
  if (use_vImage_font_smoothing(void)::predicate != -1) {
    dispatch_once(&use_vImage_font_smoothing(void)::predicate, &__block_literal_global_14_21440);
  }
  if (!use_vImage_font_smoothing(void)::status)
  {
    uint64_t v26 = *(int *)(a1 + 124);
    if (v26) {
      _CGHandleAssert("RGBAf16_mark_const_deep_mask_ARGB", 9588, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "((mdn >> 1) << 1) == mdn", "%ld", a6, a7, a8, *(_DWORD *)(a1 + 124));
    }
    if ((a2 - 1) > 1) {
      _CGHandleAssert("RGBAf16_mark_const_deep_mask_ARGB", 9685, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, v85);
    }
    unint64_t v27 = (unint64_t)*(int *)(a1 + 28) >> 3;
    uint64_t v28 = (uint64_t *)(v13 + 8 * (*(int *)(a1 + 12) + v27 * *(int *)(a1 + 16)));
    uint64_t v29 = v26 >> 1;
    uint64_t v86 = v27 - v88;
    uint64_t v87 = v29 - v88;
    unint64_t v30 = (_DWORD *)(v11 + 2 * (*(int *)(a1 + 104) + (int)v29 * (uint64_t)*(int *)(a1 + 108)));
    LOWORD(v31) = COERCE_UNSIGNED_INT(1.0);
    while (1)
    {
      BOOL v32 = (v30 & 3) != 0;
      unint64_t v91 = ((unint64_t)v30 + 2 * v88) & 0xFFFFFFFFFFFFFFFCLL;
      int v89 = v8;
      uint64_t v90 = &v30[v88];
      int v33 = v88;
      do
      {
        if (v32) {
          goto LABEL_19;
        }
        if (v33 == 1)
        {
          if ((_DWORD *)v91 == v90) {
            _CGHandleAssert("RGBAf16_mark_const_deep_mask_ARGB", 9616, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "postamble == true", "mdp %p w %d", a6, a7, a8, (char)v30);
          }
LABEL_19:
          unsigned int v34 = *(unsigned __int16 *)v30;
          uint64_t v35 = 1;
          goto LABEL_21;
        }
        unsigned int v34 = *v30 & 0x7FFF7FFF;
        uint64_t v35 = 2;
LABEL_21:
        if ((v34 & 0x7FFF7FFF) != 0)
        {
          unsigned int v36 = HIWORD(v34);
          uint64_t v37 = v35;
          do
          {
            unsigned int v38 = v34 & 0x7FFF;
            if ((v34 & 0x7FFF) != 0)
            {
              v93[0] = *(void *)v94;
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                _NF = 0;
              }
              else {
                _NF = _H0 < v31;
              }
              if (_NF)
              {
                *(short float *)uint64_t v93 = v94[0] / _H0;
                *((short float *)v93 + 1) = v94[1] / _H0;
                *((short float *)v93 + 2) = v94[2] / _H0;
              }
              ungamma((short float *)v93);
              uint64_t v44 = *v28;
              v92[0] = *v28;
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                BOOL v46 = 0;
              }
              else {
                BOOL v46 = _H0 < v31;
              }
              if (v46)
              {
                *(short float *)int v92 = *(short float *)&v44 / _H0;
                *((short float *)v92 + 1) = *((short float *)&v44 + 1) / _H0;
                *((short float *)v92 + 2) = *((short float *)&v44 + 2) / _H0;
              }
              ungamma((short float *)v92);
              float v47 = (float)(((((v34 >> 2) & 0xF8) + 16) * ((v34 >> 2) & 0xF8)) >> 8) / 255.0;
              _H4 = v93[0];
              __asm { FCVT            S4, H4 }
              _H5 = v92[0];
              __asm { FCVT            S5, H5 }
              _S0 = _S5 + (float)((float)(_S4 - _S5) * (float)((float)(v38 >> 10) / 31.0));
              __asm { FCVT            H0, S0 }
              LOWORD(v92[0]) = LOWORD(_S0);
              LOWORD(_S0) = WORD1(v93[0]);
              __asm { FCVT            S0, H0 }
              LOWORD(_S4) = WORD1(v92[0]);
              __asm { FCVT            S4, H4 }
              _S0 = _S4 + (float)((float)(_S0 - _S4) * (float)((float)((v38 >> 5) & 0x1F) / 31.0));
              __asm { FCVT            H0, S0 }
              WORD1(v92[0]) = LOWORD(_S0);
              LOWORD(_S0) = WORD2(v93[0]);
              __asm { FCVT            S0, H0 }
              _H1 = WORD2(v92[0]);
              __asm { FCVT            S1, H1 }
              _S0 = _S1 + (float)((float)(_S0 - _S1) * (float)((float)(v34 & 0x1F) / 31.0));
              __asm { FCVT            H0, S0 }
              WORD2(v92[0]) = LOWORD(_S0);
              LOWORD(_S0) = HIWORD(v92[0]);
              __asm { FCVT            S0, H0 }
              _S0 = (float)(v47 - (float)(_S0 * v47)) + _S0;
              __asm { FCVT            H0, S0 }
              HIWORD(v92[0]) = LOWORD(_S0);
              gamma((uint64_t)v92);
              _H2 = *((short float *)v92 + 1);
              _H3 = *(short float *)v92;
              _H1 = *((short float *)v92 + 2);
              __asm { FCMP            H0, #0 }
              if (!(_NF ^ _VF | _ZF) && _H0 < v31)
              {
                _H3 = _H0 * *(short float *)v92;
                *(short float *)int v92 = _H0 * *(short float *)v92;
                _H2 = _H0 * *((short float *)v92 + 1);
                *((short float *)v92 + 1) = _H0 * *((short float *)v92 + 1);
                _H1 = _H0 * *((short float *)v92 + 2);
                *((short float *)v92 + 2) = _H0 * *((short float *)v92 + 2);
              }
              __asm { FCVT            S3, H3 }
              _H4 = *(_WORD *)v28;
              __asm { FCVT            S4, H4 }
              _H5 = HIWORD(v93[0]);
              __asm { FCVT            S5, H5 }
              _S3 = _S4 + (float)((float)(_S3 - _S4) * _S5);
              __asm
              {
                FCVT            H3, S3
                FCVT            S2, H2
              }
              LOWORD(_S4) = *((_WORD *)v28 + 1);
              __asm { FCVT            S4, H4 }
              _S2 = _S4 + (float)((float)(_S2 - _S4) * _S5);
              __asm
              {
                FCVT            H2, S2
                FCVT            S1, H1
              }
              LOWORD(_S4) = *((_WORD *)v28 + 2);
              __asm { FCVT            S4, H4 }
              _S1 = _S4 + (float)((float)(_S1 - _S4) * _S5);
              __asm
              {
                FCVT            H1, S1
                FCVT            S0, H0
              }
              LOWORD(_S4) = *((_WORD *)v28 + 3);
              __asm { FCVT            S4, H4 }
              _S0 = _S4 + (float)((float)(_S0 - _S4) * _S5);
              __asm { FCVT            H0, S0 }
              *((short float *)v28 + 3) = _H0;
              if (_H3 > _H0) {
                _H3 = _H0;
              }
              *(short float *)uint64_t v28 = _H3;
              if (_H2 > _H0) {
                _H2 = _H0;
              }
              *((short float *)v28 + 1) = _H2;
              if (_H1 <= _H0) {
                _H0 = _H1;
              }
              *((short float *)v28 + 2) = _H0;
            }
            ++v28;
            unsigned int v34 = v36;
            _ZF = v37 == 1;
            uint64_t v37 = 1;
          }
          while (!_ZF);
        }
        else
        {
          v28 += v35;
        }
        BOOL v32 = 0;
        unint64_t v30 = (_DWORD *)((char *)v30 + 2 * v35);
        _VF = __OFSUB__(v33, v35);
        v33 -= v35;
      }
      while (!((v33 < 0) ^ _VF | (v33 == 0)));
      unint64_t v30 = (_DWORD *)((char *)v30 + 2 * v87);
      v28 += v86;
      LODWORD(v8) = v89 - 1;
      if (v89 <= 1) {
        return;
      }
    }
  }
  if ((a2 - 3) <= 0xFFFFFFFD) {
    _CGHandleAssert("RGBAf16_mark_const_deep_mask_ARGB", 9559, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "mode == COPY || mode == SOVER", "mode = %d", a6, a7, a8, a2);
  }
  uint64_t v14 = *(int *)(a1 + 104);
  int v15 = *(_DWORD *)(a1 + 108);
  uint64_t v16 = *(int *)(a1 + 28);
  v93[0] = v13 + (int)v16 * (uint64_t)*(int *)(a1 + 16) + 8 * *(int *)(a1 + 12);
  v93[1] = v8;
  v93[2] = v88;
  v93[3] = v16;
  uint64_t v17 = *(int *)(a1 + 124);
  v92[0] = v11 + (int)v17 * (uint64_t)v15 + 2 * v14;
  v92[1] = v8;
  v92[2] = v88;
  v92[3] = v17;
  uint64_t v18 = vImageCGCompositeMarkConstDeepMaskARGB_ARGB16F();
  if (v18) {
    CGPostError((uint64_t)"vImageCGCompositeMarkConstDeepMaskARGB_ARGB16F failed %ld", v19, v20, v21, v22, v23, v24, v25, v18);
  }
}

void RGBAf16_mark_const_deep_mask_BGColorARGB(uint64_t a1, int a2, float16x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 8);
  uint64_t v113 = *(unsigned int *)(a1 + 4);
  if ((int)v113 >= 1 && v8 >= 1)
  {
    uint64_t v11 = *(void *)(a1 + 136);
    if (v11)
    {
      uint64_t v14 = *(void *)(a1 + 40);
      int v15 = *(float16x4_t **)(a1 + 88);
      if (use_vImage_font_smoothing(void)::predicate != -1) {
        dispatch_once(&use_vImage_font_smoothing(void)::predicate, &__block_literal_global_14_21440);
      }
      uint64_t v16 = *(int *)(a1 + 124);
      if (v16) {
        _CGHandleAssert("RGBAf16_mark_const_deep_mask_BGColorARGB", 9759, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "((mdn >> 1) << 1) == mdn", "mduint64_t n = %ld", a6, a7, a8, *(_DWORD *)(a1 + 124));
      }
      if ((a2 - 1) > 1) {
        _CGHandleAssert("RGBAf16_mark_const_deep_mask_BGColorARGB", 9883, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, v110);
      }
      unint64_t v17 = (unint64_t)*(int *)(a1 + 28) >> 3;
      uint64_t v18 = (short float *)(v14 + 8 * (*(int *)(a1 + 12) + v17 * *(int *)(a1 + 16)));
      uint64_t v19 = v16 >> 1;
      uint64_t v111 = v17 - v113;
      uint64_t v112 = v19 - v113;
      uint64_t v20 = (_WORD *)(v11 + 2 * (*(int *)(a1 + 104) + (int)v19 * (uint64_t)*(int *)(a1 + 108)));
      LOWORD(v21) = COERCE_UNSIGNED_INT(1.0);
      __asm { FMOV            V0.2S, #31.0 }
      float32x2_t v117 = _D0;
      do
      {
        int v114 = v8;
        BOOL v26 = (v20 & 3) != 0;
        __int16 v115 = &v20[2 * v113];
        unint64_t v116 = (unint64_t)&v20[v113] & 0xFFFFFFFFFFFFFFFCLL;
        int v27 = v113;
        do
        {
          if (v26) {
            goto LABEL_15;
          }
          if (v27 == 1)
          {
            if ((_WORD *)v116 == v115) {
              _CGHandleAssert("RGBAf16_mark_const_deep_mask_BGColorARGB", 9787, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "postamble == true", "", a6, a7, a8, v110);
            }
LABEL_15:
            unsigned int v28 = (unsigned __int16)*v20;
            uint64_t v29 = 1;
            if (!*v20) {
              goto LABEL_64;
            }
            goto LABEL_16;
          }
          unsigned int v28 = *(_DWORD *)v20;
          uint64_t v29 = 2;
          if (!*(_DWORD *)v20)
          {
LABEL_64:
            v18 += 4 * v29;
            goto LABEL_65;
          }
LABEL_16:
          unsigned int v30 = (unsigned __int16)v28;
          unsigned int v31 = HIWORD(v28);
          uint64_t v32 = v29;
          do
          {
            if (v30)
            {
              float16x4_t v121 = *v15;
              v33.i32[0] = *(void *)v18;
              v33.i32[1] = v33.u16[1];
              _S3 = HIWORD(*(void *)&v121);
              _H0 = v121.i16[0];
              float32x4_t v36 = vcvtq_f32_f16((float16x4_t)vmovn_s32(vmovn_hight_s64(v33, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v18), (uint64x2_t)xmmword_1850CDC40))));
              float v37 = 1.0 - v36.f32[3];
              if ((float)(1.0 - v36.f32[3]) > 1.0) {
                float v37 = 1.0;
              }
              if (v37 < 0.0) {
                float v37 = 0.0;
              }
              _D6 = vcvt_f16_f32(vmlaq_n_f32(v36, vcvtq_f32_f16(*a3), v37));
              float16x4_t v120 = _D6;
              _H1 = v121.i16[2];
              _H2 = v121.i16[1];
              if (a2 == 2)
              {
                __asm { FCVT            S3, H3 }
                float v42 = 1.0 - _S3;
                if ((float)(1.0 - _S3) > 1.0) {
                  float v42 = 1.0;
                }
                if (v42 < 0.0) {
                  float v42 = 0.0;
                }
                __asm
                {
                  FCVT            S5, H6
                  FCVT            S0, H0
                }
                _S0 = _S0 + (float)(_S5 * v42);
                __asm { FCVT            H0, S0 }
                v121.i16[0] = _H0;
                LOWORD(_S5) = _D6.i16[1];
                __asm
                {
                  FCVT            S5, H5
                  FCVT            S2, H2
                }
                _S2 = _S2 + (float)(_S5 * v42);
                __asm { FCVT            H2, S2 }
                v121.i16[1] = _H2;
                LOWORD(_S5) = _D6.i16[2];
                __asm
                {
                  FCVT            S5, H5
                  FCVT            S1, H1
                }
                _S1 = _S1 + (float)(_S5 * v42);
                __asm { FCVT            H1, S1 }
                v121.i16[2] = _H1;
                LOWORD(_S5) = _D6.i16[3];
                __asm { FCVT            S5, H5 }
                _S3 = _S3 + (float)(_S5 * v42);
                __asm { FCVT            H3, S3 }
                v121.i16[3] = LOWORD(_S3);
              }
              float16x4_t v118 = _D6;
              __asm { FCMP            H3, #0 }
              if (_NF ^ _VF | _ZF) {
                _NF = 0;
              }
              else {
                _NF = _H3 < v21;
              }
              if (_NF)
              {
                *(short float *)v121.i16 = *(short float *)&_H0 / _H3;
                *(short float *)&v121.i16[1] = *(short float *)&_H2 / _H3;
                *(short float *)&v121.i16[2] = *(short float *)&_H1 / _H3;
              }
              ungamma((short float *)&v121);
              __asm { FCMP            H13, #0 }
              if (_NF ^ _VF | _ZF) {
                BOOL v57 = 0;
              }
              else {
                BOOL v57 = _H13 < v21;
              }
              if (v57)
              {
                *(short float *)v120.i16 = *(short float *)v118.i16 / _H13;
                _H12 = v118.i16[1];
                *(short float *)&v120.i16[1] = *(short float *)&v118.i16[1] / _H13;
                _H15 = v118.i16[2];
                *(short float *)&v120.i16[2] = *(short float *)&v118.i16[2] / _H13;
              }
              else
              {
                _H15 = v118.i16[2];
                _H12 = v118.i16[1];
              }
              ungamma((short float *)&v120);
              *(float32x2_t *)v60.f32 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)vdup_n_s32(v30), (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0xFFFFFFFBFFFFFFF6), (int8x8_t)0x1F0000001FLL)), v117);
              float16x4_t v61 = vcvt_f16_f32(v60);
              _S1 = (float)(v30 & 0x1F) / 31.0;
              __asm { FCVT            H1, S1 }
              short float v64 = *(short float *)&v61.i16[1];
              short float v65 = vmulh_lane_f16(*(short float *)&v61.i16[1], v61, 1);
              if (*(short float *)&v61.i16[1] <= _H1) {
                short float v64 = _H1;
              }
              if (v64 >= *(short float *)v61.i16) {
                short float v66 = v64;
              }
              else {
                short float v66 = *(short float *)v61.i16;
              }
              *(short float *)&v61.i16[2] = _H1;
              *(short float *)&v61.i16[3] = v65;
              float32x4_t v67 = vcvtq_f32_f16(v61);
              __asm { FMOV            V2.4S, #1.0 }
              float16x4_t v119 = vcvt_f16_f32(vmlaq_f32(vmulq_f32(vsubq_f32(_Q2, v67), vcvtq_f32_f16(v120)), vcvtq_f32_f16(v121), v67));
              gamma((uint64_t)&v119);
              _H0 = v119.i16[3];
              if (*(short float *)&v119.i16[3] >= v21 || *(short float *)&v119.i16[3] <= COERCE_SHORT_FLOAT(0)) {
                LOWORD(v71) = COERCE_UNSIGNED_INT(1.0);
              }
              else {
                short float v71 = *(short float *)&v119.i16[3];
              }
              _H3 = *(short float *)&v119.i16[2] * v71;
              _H2 = *(short float *)&v119.i16[1] * v71;
              _H1 = *(short float *)v119.i16 * v71;
              _H4 = v21 - v66;
              _H5 = v118.i16[0];
              __asm
              {
                FCVT            S5, H5
                FCVT            S4, H4
                FCVT            S1, H1
              }
              _S1 = _S1 - (float)(_S5 * _S4);
              __asm { FCVT            H1, S1 }
              v119.i16[0] = _H1;
              __asm
              {
                FCVT            S5, H12
                FCVT            S2, H2
              }
              _S2 = _S2 - (float)(_S5 * _S4);
              __asm { FCVT            H2, S2 }
              v119.i16[1] = _H2;
              __asm
              {
                FCVT            S5, H15
                FCVT            S3, H3
              }
              _S3 = _S3 - (float)(_S5 * _S4);
              __asm { FCVT            H3, S3 }
              v119.i16[2] = _H3;
              __asm
              {
                FCVT            S5, H13
                FCVT            S0, H0
              }
              _S0 = _S0 - (float)(_S5 * _S4);
              __asm { FCVT            H0, S0 }
              v119.i16[3] = LOWORD(_S0);
              __asm { FCVT            S0, H0 }
              float v94 = 1.0 - _S0;
              if ((float)(1.0 - _S0) > 1.0) {
                float v94 = 1.0;
              }
              if (v94 < 0.0) {
                float v94 = 0.0;
              }
              __asm { FCVT            S1, H1 }
              _H5 = *(_WORD *)v18;
              __asm { FCVT            S5, H5 }
              _S1 = _S1 + (float)(_S5 * v94);
              __asm { FCVT            H1, S1 }
              short float *v18 = *(short float *)&_S1;
              __asm { FCVT            S1, H2 }
              _H2 = *((_WORD *)v18 + 1);
              __asm { FCVT            S2, H2 }
              _S1 = _S1 + (float)(_S2 * v94);
              __asm { FCVT            H1, S1 }
              v18[1] = *(short float *)&_S1;
              __asm { FCVT            S1, H3 }
              *(short float *)&_S2 = v18[2];
              __asm { FCVT            S2, H2 }
              _S1 = _S1 + (float)(_S2 * v94);
              __asm { FCVT            H1, S1 }
              v18[2] = *(short float *)&_S1;
              *(short float *)&_S1 = v18[3];
              __asm { FCVT            S1, H1 }
              _S0 = _S0 + (float)(_S1 * v94);
              __asm { FCVT            H0, S0 }
              if (_H0 > v21) {
                LOWORD(_H0) = COERCE_UNSIGNED_INT(1.0);
              }
              __asm { FCMP            H1, #0 }
              if (_NF) {
                _H0 = COERCE_SHORT_FLOAT(0);
              }
              v18[3] = _H0;
            }
            v18 += 4;
            unsigned int v30 = v31;
            _ZF = v32 == 1;
            uint64_t v32 = 1;
          }
          while (!_ZF);
LABEL_65:
          BOOL v26 = 0;
          v20 += v29;
          _VF = __OFSUB__(v27, v29);
          v27 -= v29;
        }
        while (!((v27 < 0) ^ _VF | (v27 == 0)));
        v20 += v112;
        v18 += 4 * v111;
        int v8 = v114 - 1;
      }
      while (v114 > 1);
    }
  }
}

void RGBAf16_mark_const_deep_mask_XRGB(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  uint64_t v79 = *(unsigned int *)(a1 + 4);
  if ((int)v79 < 1 || (int)v8 < 1) {
    return;
  }
  uint64_t v11 = *(void *)(a1 + 136);
  if (!v11) {
    return;
  }
  uint64_t v13 = *(void *)(a1 + 40);
  *(void *)double v83 = **(void **)(a1 + 88);
  if (use_vImage_font_smoothing(void)::predicate != -1) {
    dispatch_once(&use_vImage_font_smoothing(void)::predicate, &__block_literal_global_14_21440);
  }
  if (!use_vImage_font_smoothing(void)::status)
  {
    uint64_t v25 = *(int *)(a1 + 124);
    if (v25) {
      _CGHandleAssert("RGBAf16_mark_const_deep_mask_XRGB", 9947, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "((mdn >> 1) << 1) == mdn", "mduint64_t n = %ld", a6, a7, a8, *(_DWORD *)(a1 + 124));
    }
    if ((a2 - 1) > 1) {
      _CGHandleAssert("RGBAf16_mark_const_deep_mask_XRGB", 10032, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", a6, a7, a8, v76);
    }
    unint64_t v26 = (unint64_t)*(int *)(a1 + 28) >> 3;
    int v27 = (uint64_t *)(v13 + 8 * (*(int *)(a1 + 12) + v26 * *(int *)(a1 + 16)));
    uint64_t v28 = v25 >> 1;
    uint64_t v77 = v26 - v79;
    uint64_t v78 = v28 - v79;
    uint64_t v29 = (_DWORD *)(v11 + 2 * (*(int *)(a1 + 104) + (int)v28 * (uint64_t)*(int *)(a1 + 108)));
    LOWORD(v30) = COERCE_UNSIGNED_INT(1.0);
    while (1)
    {
      int v80 = v8;
      BOOL v31 = (v29 & 3) != 0;
      unint64_t v32 = ((unint64_t)v29 + 2 * v79) & 0xFFFFFFFFFFFFFFFCLL;
      int32x2_t v33 = &v29[v79];
      int v34 = v79;
      do
      {
        if (v31) {
          goto LABEL_19;
        }
        if (v34 == 1)
        {
          if ((_DWORD *)v32 == v33) {
            _CGHandleAssert("RGBAf16_mark_const_deep_mask_XRGB", 9975, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "postamble == true", "", a6, a7, a8, v76);
          }
LABEL_19:
          unsigned int v35 = *(unsigned __int16 *)v29;
          uint64_t v36 = 1;
          goto LABEL_21;
        }
        unsigned int v35 = *v29 & 0x7FFF7FFF;
        uint64_t v36 = 2;
LABEL_21:
        if ((v35 & 0x7FFF7FFF) != 0)
        {
          unsigned int v37 = HIWORD(v35);
          uint64_t v38 = v36;
          do
          {
            unsigned int v39 = v35 & 0x7FFF;
            if ((v35 & 0x7FFF) != 0)
            {
              v82[0] = *(void *)v83;
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                _NF = 0;
              }
              else {
                _NF = _H0 < v30;
              }
              if (_NF)
              {
                *(short float *)unsigned int v82 = v83[0] / _H0;
                *((short float *)v82 + 1) = v83[1] / _H0;
                *((short float *)v82 + 2) = v83[2] / _H0;
              }
              ungamma((short float *)v82);
              uint64_t v45 = *v27;
              v81[0] = *v27;
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                BOOL v47 = 0;
              }
              else {
                BOOL v47 = _H0 < v30;
              }
              if (v47)
              {
                *(short float *)int v81 = *(short float *)&v45 / _H0;
                *((short float *)v81 + 1) = *((short float *)&v45 + 1) / _H0;
                *((short float *)v81 + 2) = *((short float *)&v45 + 2) / _H0;
              }
              ungamma((short float *)v81);
              _H3 = v82[0];
              __asm { FCVT            S3, H3 }
              _H4 = v81[0];
              __asm { FCVT            S4, H4 }
              _S0 = _S4 + (float)((float)(_S3 - _S4) * (float)((float)(v39 >> 10) / 31.0));
              __asm { FCVT            H0, S0 }
              LOWORD(v81[0]) = LOWORD(_S0);
              LOWORD(_S0) = WORD1(v82[0]);
              __asm { FCVT            S0, H0 }
              LOWORD(_S3) = WORD1(v81[0]);
              __asm { FCVT            S3, H3 }
              _S0 = _S3 + (float)((float)(_S0 - _S3) * (float)((float)((v39 >> 5) & 0x1F) / 31.0));
              __asm { FCVT            H0, S0 }
              WORD1(v81[0]) = LOWORD(_S0);
              LOWORD(_S0) = WORD2(v82[0]);
              __asm { FCVT            S0, H0 }
              _H1 = WORD2(v81[0]);
              __asm { FCVT            S1, H1 }
              _S0 = _S1 + (float)((float)(_S0 - _S1) * (float)((float)(v39 & 0x1F) / 31.0));
              __asm { FCVT            H0, S0 }
              WORD2(v81[0]) = LOWORD(_S0);
              gamma((uint64_t)v81);
              _H1 = *((short float *)v81 + 1);
              _H2 = *(short float *)v81;
              _H0 = *((short float *)v81 + 2);
              __asm { FCMP            H3, #0 }
              if (!(_NF ^ _VF | _ZF) && _H3 < v30)
              {
                _H2 = _H3 * *(short float *)v81;
                *(short float *)int v81 = _H3 * *(short float *)v81;
                _H1 = _H3 * *((short float *)v81 + 1);
                *((short float *)v81 + 1) = _H3 * *((short float *)v81 + 1);
                _H0 = _H3 * *((short float *)v81 + 2);
                *((short float *)v81 + 2) = _H3 * *((short float *)v81 + 2);
              }
              __asm { FCVT            S2, H2 }
              _H3 = *(_WORD *)v27;
              __asm { FCVT            S3, H3 }
              _H4 = HIWORD(v82[0]);
              __asm { FCVT            S4, H4 }
              _S2 = _S3 + (float)((float)(_S2 - _S3) * _S4);
              __asm { FCVT            H2, S2 }
              *(_WORD *)int v27 = LOWORD(_S2);
              __asm { FCVT            S1, H1 }
              LOWORD(_S2) = *((_WORD *)v27 + 1);
              __asm { FCVT            S2, H2 }
              _S1 = _S2 + (float)((float)(_S1 - _S2) * _S4);
              __asm { FCVT            H1, S1 }
              *((_WORD *)v27 + 1) = LOWORD(_S1);
              __asm { FCVT            S0, H0 }
              LOWORD(_S1) = *((_WORD *)v27 + 2);
              __asm { FCVT            S1, H1 }
              _S0 = _S1 + (float)((float)(_S0 - _S1) * _S4);
              __asm { FCVT            H0, S0 }
              *((_WORD *)v27 + 2) = LOWORD(_S0);
            }
            ++v27;
            LOWORD(v35) = v37;
            _ZF = v38 == 1;
            uint64_t v38 = 1;
          }
          while (!_ZF);
        }
        else
        {
          v27 += v36;
        }
        BOOL v31 = 0;
        uint64_t v29 = (_DWORD *)((char *)v29 + 2 * v36);
        _VF = __OFSUB__(v34, v36);
        v34 -= v36;
      }
      while (!((v34 < 0) ^ _VF | (v34 == 0)));
      uint64_t v29 = (_DWORD *)((char *)v29 + 2 * v78);
      v27 += v77;
      LODWORD(v8) = v80 - 1;
      if (v80 <= 1) {
        return;
      }
    }
  }
  if ((a2 - 3) <= 0xFFFFFFFD) {
    _CGHandleAssert("RGBAf16_mark_const_deep_mask_XRGB", 9918, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "mode == COPY || mode == SOVER", "mode = %d", a6, a7, a8, a2);
  }
  uint64_t v14 = *(int *)(a1 + 104);
  int v15 = *(_DWORD *)(a1 + 108);
  uint64_t v16 = *(int *)(a1 + 28);
  v82[0] = v13 + (int)v16 * (uint64_t)*(int *)(a1 + 16) + 8 * *(int *)(a1 + 12);
  v82[1] = v8;
  v82[2] = v79;
  v82[3] = v16;
  uint64_t v17 = *(int *)(a1 + 124);
  v81[0] = v11 + (int)v17 * (uint64_t)v15 + 2 * v14;
  v81[1] = v8;
  v81[2] = v79;
  v81[3] = v17;
  if (vImageCGCompositeMarkConstDeepMaskXRGB_ARGB16F()) {
    CGPostError((uint64_t)"vImageCGCompositeMarkConstDeepMaskXRGB_ARGB16F failed", v18, v19, v20, v21, v22, v23, v24, v76);
  }
}

uint64_t RGBAf16_mark_deep_pixel(uint64_t result, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double _D6, float32x4_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  unint64_t v17 = *(unsigned int *)(result + 4);
  int v18 = *(_DWORD *)(result + 8);
  if ((int)v17 < 1 || v18 < 1) {
    return result;
  }
  uint64_t v20 = *(int *)(result + 124);
  if (v20) {
    _CGHandleAssert("RGBAf16_mark_deep_pixel", 10064, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "((mdn >> 1) << 1) == mdn", "mduint64_t n = %lu", a14, a15, a16, v20);
  }
  uint64_t v21 = *(void *)(result + 136);
  if (!v21) {
    return result;
  }
  unint64_t v22 = *(void *)(result + 88);
  uint64_t v23 = *(void *)(result + 96);
  unint64_t v24 = (unint64_t)*(int *)(result + 28) >> 3;
  uint64_t v25 = (float16x4_t *)(*(void *)(result + 40) + 8 * (*(int *)(result + 12) + v24 * *(int *)(result + 16)));
  uint64_t v26 = v20 >> 1;
  int v27 = (unsigned __int16 *)(v21
                           + 2
                           * (*(int *)(result + 104) + (*(int *)(result + 124) >> 1) * (uint64_t)*(int *)(result + 108)));
  uint64_t v29 = *(int *)(result + 56);
  uint64_t v28 = *(int *)(result + 60);
  unint64_t v30 = (unint64_t)*(int *)(result + 76) >> 3;
  if (*(unsigned __int8 *)(result + 1) << 8 == 256)
  {
    v22 += 8 * (v29 + v30 * v28);
    if (v30 == v24)
    {
      if ((uint64_t)((uint64_t)v25 - v22) >= 1)
      {
        if (v17 >= ((unint64_t)v25 - v22) >> 3)
        {
          v25 += (v17 - 1);
          v22 += 8 * (v17 - 1);
          int v33 = -1;
          unint64_t v30 = (unint64_t)*(int *)(result + 28) >> 3;
          v27 += (v17 - 1);
          goto LABEL_19;
        }
        uint64_t v31 = (v18 - 1);
        unint64_t v32 = v22 + 8 * v24 * v31;
        if ((unint64_t)v25 <= v32 + 8 * (v17 - 1))
        {
          v25 += v24 * v31;
          v27 += v26 * v31;
          unint64_t v30 = -(uint64_t)v24;
          uint64_t v26 = -v26;
          int v33 = 1;
          unint64_t v22 = v32;
          unint64_t v24 = -(uint64_t)v24;
          goto LABEL_19;
        }
      }
      int v33 = 1;
      unint64_t v30 = (unint64_t)*(int *)(result + 28) >> 3;
    }
    else
    {
      int v33 = 1;
    }
LABEL_19:
    uint64_t v34 = 0;
    uint64_t v45 = v33 * (int)v17;
    BOOL v36 = v23 != 0;
    unint64_t v37 = v26 - v45;
    unint64_t v38 = v24 - v45;
    unint64_t v44 = -1;
    uint64_t v35 = v30;
    goto LABEL_20;
  }
  uint64_t v35 = *(unsigned int *)(result + 64);
  uint64_t v34 = *(unsigned int *)(result + 68);
  BOOL v36 = v23 != 0;
  unint64_t v37 = v26 - v17;
  unint64_t v38 = v24 - v17;
  if (!v22)
  {
    unint64_t v44 = 0;
    int v33 = 1;
    uint64_t v45 = *(unsigned int *)(result + 4);
LABEL_20:
    unint64_t v41 = 0;
    unint64_t v43 = 0;
    v30 -= v45;
    int v39 = 1;
    goto LABEL_21;
  }
  int v39 = 0;
  int v40 = (int)v29 % (int)v35;
  unint64_t v41 = v22 + 8 * v30 * (int)v34;
  unint64_t v42 = v22 + 8 * v30 * ((int)v28 % (int)v34);
  unint64_t v43 = v42 + 8 * v40;
  unint64_t v44 = v42 + 8 * (int)v35;
  int v33 = 1;
  unint64_t v22 = v43;
LABEL_21:
  if (a2 == 1)
  {
    if (!*(void *)(result + 48)) {
      LOBYTE(v36) = 1;
    }
    __int16 result = v33;
    uint64_t v73 = -(uint64_t)(int)v35;
    uint64_t v74 = -(uint64_t)(v30 * (int)v34);
    uint64_t v75 = 2 * result;
    int v76 = v17 + 1;
    uint64_t v77 = 8 * result;
    if (v36)
    {
      do
      {
        int v78 = v76;
        do
        {
          unsigned int v79 = *v27;
          unsigned int v80 = v79 & 0x7FFF;
          if ((v79 & 0x7FFF) != 0)
          {
            if (v80 == 0x7FFF)
            {
              float16x4_t v81 = *(float16x4_t *)v22;
            }
            else
            {
              v82.f32[0] = (float)(v80 >> 10);
              v82.f32[1] = (float)((v79 >> 5) & 0x1F);
              v82.f32[2] = (float)(v79 & 0x1F);
              v82.f32[3] = (float)(((((v79 >> 2) & 0xF8) + 16) * ((v79 >> 2) & 0xF8)) >> 8);
              float32x4_t v83 = vdivq_f32(v82, (float32x4_t)xmmword_1850CDFE0);
              float16x4_t v81 = vcvt_f16_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_f16(*v25), 1.0 - v83.f32[3]), v83, vcvtq_f32_f16(*(float16x4_t *)v22)));
            }
            float16x4_t *v25 = v81;
          }
          unint64_t v84 = v22 + 8 * result;
          if (v84 >= v44) {
            uint64_t v85 = v73;
          }
          else {
            uint64_t v85 = 0;
          }
          unint64_t v22 = v84 + 8 * v85;
          int v27 = (unsigned __int16 *)((char *)v27 + v75);
          --v78;
          uint64_t v25 = (float16x4_t *)((char *)v25 + v77);
        }
        while (v78 > 1);
        v27 += v37;
        v25 += v38;
        unint64_t v86 = v43 + 8 * v30;
        if (v86 >= v41) {
          uint64_t v87 = v74;
        }
        else {
          uint64_t v87 = 0;
        }
        unint64_t v88 = v86 + 8 * v87;
        uint64_t v89 = v44 + 8 * v87 + 8 * v30;
        v22 += 8 * v30;
        if (!v39)
        {
          unint64_t v44 = v89;
          unint64_t v43 = v88;
          unint64_t v22 = v88;
        }
        _VF = __OFSUB__(v18--, 1);
      }
      while (!((v18 < 0) ^ _VF | (v18 == 0)));
    }
    else
    {
      do
      {
        int v90 = v76;
        do
        {
          unsigned int v91 = *v27;
          unsigned int v92 = v91 & 0x7FFF;
          if ((v91 & 0x7FFF) != 0)
          {
            if (v92 == 0x7FFF)
            {
              v25->i32[0] = *(_DWORD *)v22;
              v25->i16[2] = *(_WORD *)(v22 + 4);
              v25->i16[3] = COERCE_UNSIGNED_INT(1.0);
            }
            else
            {
              v93.f32[0] = (float)(v92 >> 10);
              a10.i32[0] = *(_DWORD *)v22;
              a10 = vcvtq_f32_f16(*(float16x4_t *)a10.f32);
              _H16 = *(_WORD *)(v22 + 4);
              v93.f32[1] = (float)((v91 >> 5) & 0x1F);
              v93.f32[2] = (float)(v91 & 0x1F);
              __asm { FCVT            S4, H16 }
              v93.f32[3] = (float)(((((v91 >> 2) & 0xF8) + 16) * ((v91 >> 2) & 0xF8)) >> 8);
              float32x4_t v96 = vdivq_f32(v93, (float32x4_t)xmmword_1850CDFE0);
              a10.i32[2] = _S4;
              float32x4_t v97 = vmulq_f32(a10, v96);
              a10.i32[3] = 1.0;
              float32x4_t v98 = vsubq_f32(a10, v96);
              v97.i32[3] = v98.i32[3];
              float16x4_t *v25 = vcvt_f16_f32(vmlaq_laneq_f32(v97, vcvtq_f32_f16(*v25), v98, 3));
            }
          }
          unint64_t v99 = v22 + 8 * result;
          if (v99 >= v44) {
            uint64_t v100 = v73;
          }
          else {
            uint64_t v100 = 0;
          }
          unint64_t v22 = v99 + 8 * v100;
          int v27 = (unsigned __int16 *)((char *)v27 + v75);
          --v90;
          uint64_t v25 = (float16x4_t *)((char *)v25 + v77);
        }
        while (v90 > 1);
        v27 += v37;
        v25 += v38;
        unint64_t v101 = v43 + 8 * v30;
        if (v101 >= v41) {
          uint64_t v102 = v74;
        }
        else {
          uint64_t v102 = 0;
        }
        unint64_t v103 = v101 + 8 * v102;
        uint64_t v104 = v44 + 8 * v102 + 8 * v30;
        v22 += 8 * v30;
        if (!v39)
        {
          unint64_t v44 = v104;
          unint64_t v43 = v103;
          unint64_t v22 = v103;
        }
        _VF = __OFSUB__(v18--, 1);
      }
      while (!((v18 < 0) ^ _VF | (v18 == 0)));
    }
    return result;
  }
  if (a2 != 2) {
    _CGHandleAssert("RGBAf16_mark_deep_pixel", 10312, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", v34, v35, v36, v105);
  }
  __int16 result = v33;
  int v46 = v17 + 1;
  __asm { FMOV            V4.2S, #31.0 }
  while (2)
  {
    int v52 = v46;
    do
    {
      unsigned int v53 = *v27;
      unsigned int v54 = v53 & 0x7FFF;
      if ((v53 & 0x7FFF) == 0) {
        goto LABEL_34;
      }
      if (v54 != 0x7FFF)
      {
        _H6 = *(_WORD *)(v22 + 6);
        __asm { FCVT            S6, H6 }
        _S5 = (float)((float)(((((v53 >> 2) & 0xF8) + 16) * ((v53 >> 2) & 0xF8)) >> 8) / 255.0) * _S6;
        __asm
        {
          FCVT            H5, S5
          FCMP            H5, #0
        }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_34;
        }
        a10.i32[0] = v53 >> 5;
        a10.i32[1] = *v27;
        _Q16.i32[0] = *(_DWORD *)(v22 + 2);
        _Q16.i64[0] = vcvtq_f32_f16(*(float16x4_t *)_Q16.f32).u64[0];
        *(float32x2_t *)a10.f32 = vmul_f32(vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8(*(int8x8_t *)a10.f32, (int8x8_t)0x1F0000001FLL)), _D4), *(float32x2_t *)_Q16.f32);
        _Q16.i16[0] = *(_WORD *)v22;
        __asm { FCVT            S16, H16 }
        *(float *)&_D6 = (float)((float)(v54 >> 10) / 31.0) * _Q16.f32[0];
        __asm { FCVT            H6, S6 }
        _D6 = COERCE_DOUBLE(vext_s8(vext_s8(*(int8x8_t *)&_D6, *(int8x8_t *)&_D6, 2uLL), (int8x8_t)vcvt_f16_f32(a10), 6uLL));
        HIWORD(_D6) = _H5;
        float32x4_t v66 = vcvtq_f32_f16(*(float16x4_t *)&_D6);
        a10 = vcvtq_f32_f16(*v25);
        float16x4_t v61 = vcvt_f16_f32(vmlaq_n_f32(v66, a10, 1.0 - v66.f32[3]));
        goto LABEL_32;
      }
      short float v55 = *(short float *)(v22 + 6);
      if (v55 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
      {
        __asm { FCMP            H5, #0 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_34;
        }
        __asm { FCVT            S5, H5 }
        a10.i32[0] = *(_DWORD *)v22;
        v58.i64[0] = vcvtq_f32_f16(*(float16x4_t *)a10.f32).u64[0];
        _H16 = *(_WORD *)(v22 + 4);
        __asm { FCVT            S16, H16 }
        v58.i64[1] = __PAIR64__(LODWORD(_S5), _S16);
        _Q16 = vcvtq_f32_f16(*v25);
        a10 = vmlaq_n_f32(v58, _Q16, 1.0 - _S5);
        float16x4_t v61 = vcvt_f16_f32(a10);
LABEL_32:
        float16x4_t *v25 = v61;
        goto LABEL_34;
      }
      v25->i32[0] = *(_DWORD *)v22;
      v25->i16[2] = *(_WORD *)(v22 + 4);
      *(short float *)&v25->i16[3] = v55;
LABEL_34:
      unint64_t v67 = v22 + 8 * v33;
      if (v67 >= v44) {
        uint64_t v68 = -(uint64_t)(int)v35;
      }
      else {
        uint64_t v68 = 0;
      }
      unint64_t v22 = v67 + 8 * v68;
      v27 += v33;
      v25 += v33;
      --v52;
    }
    while (v52 > 1);
    v27 += v37;
    v25 += v38;
    unint64_t v69 = v43 + 8 * v30;
    if (v69 >= v41) {
      uint64_t v70 = -(uint64_t)(v30 * (int)v34);
    }
    else {
      uint64_t v70 = 0;
    }
    unint64_t v71 = v69 + 8 * v70;
    uint64_t v72 = v44 + 8 * v70 + 8 * v30;
    v22 += 8 * v30;
    if (!v39)
    {
      unint64_t v44 = v72;
      unint64_t v43 = v71;
      unint64_t v22 = v71;
    }
    _VF = __OFSUB__(v18--, 1);
    if (!((v18 < 0) ^ _VF | (v18 == 0))) {
      continue;
    }
    return result;
  }
}

void RGBAf16_mark_bits(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  float v7 = (_DWORD *)v2;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int v8 = *(_DWORD *)(v5 + 112);
  int v9 = *(_DWORD *)(v5 + 116);
  unsigned int v10 = (v8 + 15) & 0xFFFFFFF0;
  size_t v11 = v10 * v9;
  if ((int)v11 <= 4096)
  {
    int v12 = v35;
  }
  else
  {
    int v12 = malloc_type_malloc(v11, 0x449083EEuLL);
    if (!v12) {
      return;
    }
  }
  CGSConvertBitsToMask(*(uint16x4_t **)(v6 + 136), *(_DWORD *)(v6 + 124), v12, v10, v8, v9, *(_DWORD *)(v6 + 128));
  long long v25 = *(_OWORD *)(v6 + 112);
  v31[6] = *(_OWORD *)(v6 + 96);
  long long v32 = v25;
  long long v26 = *(_OWORD *)(v6 + 144);
  long long v33 = *(_OWORD *)(v6 + 128);
  long long v34 = v26;
  long long v27 = *(_OWORD *)(v6 + 48);
  v31[2] = *(_OWORD *)(v6 + 32);
  v31[3] = v27;
  long long v28 = *(_OWORD *)(v6 + 80);
  v31[4] = *(_OWORD *)(v6 + 64);
  v31[5] = v28;
  __n128 v29 = *(__n128 *)v6;
  __n128 v30 = *(__n128 *)(v6 + 16);
  v31[0] = *(_OWORD *)v6;
  v31[1] = v30;
  HIDWORD(v32) = (v8 + 15) & 0xFFFFFFF0;
  *((void *)&v33 + 1) = v12;
  if (BYTE1(v31[0]) << 8 == 1024) {
    RGBAf16_mark_constmask((uint64_t)v31, v4, v13, v14, v29.n128_f64[0], v30, v19, v20, v21, *(double *)v22.i64, *(double *)v23.i64, *(float16x4_t *)&v24, v15, v16, v17, v18);
  }
  else {
    RGBAf16_mark_pixelmask(v7, (int *)v31, v4, v29, v30, v19, v20, v21, v22, v23, v24);
  }
  if (v12 != v35) {
    free(v12);
  }
}

short float *ungamma(short float *result)
{
  __asm { FCMP            H1, #0 }
  LOWORD(v5) = COERCE_UNSIGNED_INT(1.0);
  _ZF = _ZF || _H1 == v5;
  if (!_ZF)
  {
    __asm { FCVT            S2, H1 }
    short float v8 = _H1 * _H1;
    _S2 = -(float)(_S2 * _S2);
    __asm
    {
      FCVT            H2, S2
      FCMP            H1, #0
    }
    if (_NF) {
      short float v12 = _H2;
    }
    else {
      short float v12 = v8;
    }
    int *result = v12;
  }
  __asm { FCMP            H1, #0 }
  if (!_ZF && _H1 != v5)
  {
    __asm { FCVT            S0, H1 }
    short float v16 = _H1 * _H1;
    _S0 = -(float)(_S0 * _S0);
    __asm
    {
      FCVT            H0, S0
      FCMP            H1, #0
    }
    if (!_NF) {
      _H0 = v16;
    }
    result[1] = _H0;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF && _H0 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
  {
    __asm { FCVT            S1, H0 }
    short float v23 = _H0 * _H0;
    _S1 = -(float)(_S1 * _S1);
    __asm
    {
      FCVT            H1, S1
      FCMP            H0, #0
    }
    if (_NF) {
      short float v27 = _H1;
    }
    else {
      short float v27 = v23;
    }
    result[2] = v27;
  }
  return result;
}

__int16 gamma@<H0>(uint64_t a1@<X0>)
{
  __asm { FCMP            H1, #0 }
  LOWORD(v5) = COERCE_UNSIGNED_INT(1.0);
  _ZF = _ZF || _H1 == v5;
  if (!_ZF)
  {
    __asm { FCVT            S2, H1 }
    float v8 = sqrtf(_S2);
    float v9 = -sqrtf(fabsf(_S2));
    __asm { FCMP            H1, #0 }
    if (_NF) {
      _S1 = v9;
    }
    else {
      _S1 = v8;
    }
    __asm { FCVT            H1, S1 }
    *(_WORD *)a1 = _H1;
  }
  __asm { FCMP            H1, #0 }
  if (!_ZF && _H1 != v5)
  {
    __asm { FCVT            S0, H1 }
    float v16 = sqrtf(_S0);
    _S0 = -sqrtf(fabsf(_S0));
    __asm { FCMP            H1, #0 }
    if (!_NF) {
      _S0 = v16;
    }
    __asm { FCVT            H0, S0 }
    *(_WORD *)(a1 + 2) = _H0;
  }
  __asm { FCMP            H0, #0 }
  if (!_ZF && *(short float *)&result != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
  {
    __asm { FCVT            S1, H0 }
    float v23 = sqrtf(_S1);
    float v24 = -sqrtf(fabsf(_S1));
    __asm { FCMP            H0, #0 }
    if (_NF) {
      _S0 = v24;
    }
    else {
      _S0 = v23;
    }
    __asm { FCVT            H0, S0 }
    *(short float *)(a1 + 4) = *(short float *)&result;
  }
  return result;
}

const void *___ZL25use_vImage_font_smoothingv_block_invoke()
{
  return get_BOOLean_property("USE_VIMAGE_FONT_SMOOTHING_SUPPORT", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&use_vImage_font_smoothing(void)::status);
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)2,_rgbaf16_t>(float16x4_t *result, uint64_t a2, float16x4_t *a3, uint64_t a4, float16x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v18 = 4 * a14;
  uint64_t v19 = -(uint64_t)a7;
  uint64_t v20 = -(a6 * a4);
  uint64_t v21 = 32 * a14;
  uint64_t v22 = 8 * a14;
  v23.i64[0] = 0x3C003C003C003C00;
  v23.i64[1] = 0x3C003C003C003C00;
  v24.i64[0] = -1;
  v24.i64[1] = -1;
  float16x8_t v25 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v26 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a15 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v27 = (a8 - (unint64_t)a3) >> 3;
      if (v27 >= a12) {
        unint64_t v27 = a12;
      }
      unint64_t v28 = v27;
      if (v27 < 4) {
        goto LABEL_36;
      }
      while (1)
      {
        __int32 v29 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          uint64_t v36 = (unsigned __int8 *)&a10[v28];
          unint64_t v37 = (int8x16_t *)a10;
          do
            unint64_t v38 = v37++;
          while (v37 <= (int8x16_t *)v36 && (vminvq_u8((uint8x16_t)vceqq_s8(*v38, v24)) & 0x80) != 0);
          do
          {
            int v39 = v38;
            unint64_t v38 = (int8x16_t *)((char *)v38 + 4);
          }
          while (v38 <= (int8x16_t *)v36 && v39->i32[0] == -1);
          if (v39 < (int8x16_t *)v36)
          {
            while (v39->u8[0] == 255)
            {
              int v39 = (int8x16_t *)((char *)v39 + 1);
              if (v39 >= (int8x16_t *)v36)
              {
                int v39 = (int8x16_t *)&a10[v28];
                break;
              }
            }
          }
          uint64_t v40 = 0;
          int64_t v41 = (char *)v39 - a10;
          unint64_t v42 = (char *)v39 - a10;
          do
          {
            unint64_t v43 = (int8x16_t *)((char *)result + v40);
            float16x8_t v44 = *(float16x8_t *)&a3->i8[v40];
            float16x8_t v45 = *(float16x8_t *)&a3[2].i8[v40];
            float16x8_t v46 = (float16x8_t)vqtbl1q_s8((int8x16_t)v45, (int8x16_t)xmmword_1850CD880);
            float16x8_t v47 = (float16x8_t)vqtbl1q_s8((int8x16_t)v44, (int8x16_t)xmmword_1850CD880);
            int8x16_t v48 = (int8x16_t)vcgtzq_f16(v46);
            float16x8_t v15 = vmaxnmq_f16(vminnmq_f16(v46, v23), (float16x8_t)0);
            int8x16_t v49 = vbslq_s8(v48, (int8x16_t)vaddq_f16(v45, vmlsq_f16(*(float16x8_t *)&result[2].i8[v40], *(float16x8_t *)&result[2].i8[v40], v15)), *(int8x16_t *)&result[2].i8[v40]);
            int8x16_t *v43 = vbslq_s8((int8x16_t)vcgtzq_f16(v47), (int8x16_t)vaddq_f16(v44, vmlsq_f16(*(float16x8_t *)&result->i8[v40], *(float16x8_t *)&result->i8[v40], vmaxnmq_f16(vminnmq_f16(v47, v23), (float16x8_t)0))), *(int8x16_t *)&result->i8[v40]);
            v43[1] = v49;
            a10 += v18;
            v42 -= 4;
            v40 += v21;
          }
          while (v42 > 3);
          a3 = (float16x4_t *)((char *)a3 + v40);
          __int16 result = (float16x4_t *)((char *)result + v40);
          unint64_t v28 = v28 - v41 + v42;
          goto LABEL_33;
        }
        if (v29) {
          break;
        }
        __n128 v30 = (unsigned __int8 *)&a10[v28];
        uint64_t v31 = (int8x16_t *)a10;
        do
          long long v32 = v31++;
        while (v31 <= (int8x16_t *)v30 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v32)) & 0x80) != 0);
        do
        {
          long long v33 = v32;
          long long v32 = (int8x16_t *)((char *)v32 + 4);
        }
        while (v32 <= (int8x16_t *)v30 && !v33->i32[0]);
        if (v33 < (int8x16_t *)v30)
        {
          while (!v33->i8[0])
          {
            long long v33 = (int8x16_t *)((char *)v33 + 1);
            if (v33 >= (int8x16_t *)v30)
            {
              long long v33 = (int8x16_t *)&a10[v28];
              break;
            }
          }
        }
        int64_t v34 = (char *)v33 - a10;
        int64_t v35 = ((char *)v33 - a10) * a14;
        a3 += v35;
        result += v35;
        a10 += v35;
        v28 -= v34;
LABEL_33:
        if (v28 <= 3) {
          goto LABEL_36;
        }
      }
      uint64_t v50 = 0;
      while (1)
      {
        int v51 = (int8x16_t *)((char *)result + v50);
        float16x8_t v53 = *(float16x8_t *)&result->i8[v50];
        float16x8_t v52 = *(float16x8_t *)&result[2].i8[v50];
        v15.i32[0] = v29;
        uint8x16_t v54 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v55 = vmulq_f16(*(float16x8_t *)&a3[2].i8[v50], vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v54)), v25));
        float16x8_t v56 = vmulq_f16(*(float16x8_t *)&a3->i8[v50], vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v54.i8)), v25));
        float16x8_t v57 = (float16x8_t)vqtbl1q_s8((int8x16_t)v56, (int8x16_t)xmmword_1850CD880);
        float16x8_t v58 = (float16x8_t)vqtbl1q_s8((int8x16_t)v55, (int8x16_t)xmmword_1850CD880);
        int8x16_t v59 = (int8x16_t)vcgtzq_f16(v57);
        float16x8_t v60 = vmlsq_f16(v53, v53, vmaxnmq_f16(vminnmq_f16(v57, v23), (float16x8_t)0));
        float16x8_t v15 = vmlsq_f16(v52, v52, vmaxnmq_f16(vminnmq_f16(v58, v23), (float16x8_t)0));
        int8x16_t *v51 = vbslq_s8(v59, (int8x16_t)vaddq_f16(v56, v60), (int8x16_t)v53);
        v51[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v58), (int8x16_t)vaddq_f16(v55, v15), (int8x16_t)v52);
        a10 += v18;
        v28 -= 4;
        if (v28 < 4) {
          break;
        }
        __int32 v29 = *(_DWORD *)a10;
        v50 += v21;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          __int16 result = (float16x4_t *)((char *)result + v50);
          a3 = (float16x4_t *)((char *)a3 + v50);
          goto LABEL_33;
        }
      }
      __int16 result = (float16x4_t *)((char *)result + v21 + v50);
      a3 = (float16x4_t *)((char *)a3 + v21 + v50);
LABEL_36:
      for (unint64_t i = a12 - v27 + v28; i; --i)
      {
        if (*a10)
        {
          float16x4_t v62 = vmul_f16(vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v26), *a3);
          float16x4_t v63 = (float16x4_t)vdup_lane_s16((int16x4_t)v62, 3);
          *(float16x4_t *)v15.i8 = vmls_f16(*result, *result, vmaxnm_f16(vminnm_f16(v63, (float16x4_t)0x3C003C003C003C00), 0));
          int *result = (float16x4_t)vbsl_s8((int8x8_t)vcgtz_f16(v63), (int8x8_t)vadd_f16(v62, *(float16x4_t *)v15.i8), (int8x8_t)*result);
        }
        short float v64 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v64 >= a8) {
          uint64_t v65 = v19;
        }
        else {
          uint64_t v65 = 0;
        }
        a3 = &v64[v65];
        __int16 result = (float16x4_t *)((char *)result + v22);
      }
      a10 += a11;
      result += a2;
      float32x4_t v66 = &a5[a4];
      if ((unint64_t)v66 >= a9) {
        uint64_t v67 = v20;
      }
      else {
        uint64_t v67 = 0;
      }
      uint64_t v68 = &v66[v67];
      uint64_t v69 = a8 + 8 * v67 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v68;
        a8 = v69;
        a5 = v68;
      }
      BOOL v70 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v70 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v71 = (a8 - (unint64_t)a3) >> 3;
    if (v71 >= a12) {
      unint64_t v71 = a12;
    }
    unint64_t v72 = v71;
    if (v71 < 4) {
      goto LABEL_85;
    }
    while (1)
    {
      __int32 v73 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        unsigned int v80 = (unsigned __int8 *)&a10[v72];
        float16x4_t v81 = (int8x16_t *)a10;
        do
          float32x4_t v82 = v81++;
        while (v81 <= (int8x16_t *)v80 && (vminvq_u8((uint8x16_t)vceqq_s8(*v82, v24)) & 0x80) != 0);
        do
        {
          float32x4_t v83 = v82;
          float32x4_t v82 = (int8x16_t *)((char *)v82 + 4);
        }
        while (v82 <= (int8x16_t *)v80 && v83->i32[0] == -1);
        if (v83 < (int8x16_t *)v80)
        {
          while (v83->u8[0] == 255)
          {
            float32x4_t v83 = (int8x16_t *)((char *)v83 + 1);
            if (v83 >= (int8x16_t *)v80)
            {
              float32x4_t v83 = (int8x16_t *)&a10[v72];
              break;
            }
          }
        }
        uint64_t v84 = 0;
        int64_t v85 = (char *)v83 - a10;
        unint64_t v86 = (char *)v83 - a10;
        do
        {
          uint64_t v87 = (int8x16_t *)((char *)result + v84);
          float16x8_t v88 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v84]);
          float16x8_t v89 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v84]);
          float16x8_t v90 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v84]);
          float16x8_t v91 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v84]);
          float16x8_t v92 = (float16x8_t)vqtbl1q_s8((int8x16_t)v89, (int8x16_t)xmmword_1850CD880);
          float16x8_t v93 = (float16x8_t)vqtbl1q_s8((int8x16_t)v88, (int8x16_t)xmmword_1850CD880);
          int8x16_t v94 = (int8x16_t)vcgtzq_f16(v92);
          float16x8_t v95 = vmlsq_f16(v91, v91, vmaxnmq_f16(vminnmq_f16(v92, v23), (float16x8_t)0));
          float16x8_t v15 = vmlsq_f16(v90, v90, vmaxnmq_f16(vminnmq_f16(v93, v23), (float16x8_t)0));
          *uint64_t v87 = vrev16q_s8(vbslq_s8(v94, (int8x16_t)vaddq_f16(v95, v89), (int8x16_t)v91));
          v87[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v93), (int8x16_t)vaddq_f16(v15, v88), (int8x16_t)v90));
          a10 += v18;
          v86 -= 4;
          v84 += v21;
        }
        while (v86 > 3);
        a3 = (float16x4_t *)((char *)a3 + v84);
        __int16 result = (float16x4_t *)((char *)result + v84);
        unint64_t v72 = v72 - v85 + v86;
        goto LABEL_82;
      }
      if (v73) {
        break;
      }
      uint64_t v74 = (unsigned __int8 *)&a10[v72];
      uint64_t v75 = (int8x16_t *)a10;
      do
        int v76 = v75++;
      while (v75 <= (int8x16_t *)v74 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v76)) & 0x80) != 0);
      do
      {
        uint64_t v77 = v76;
        int v76 = (int8x16_t *)((char *)v76 + 4);
      }
      while (v76 <= (int8x16_t *)v74 && !v77->i32[0]);
      if (v77 < (int8x16_t *)v74)
      {
        while (!v77->i8[0])
        {
          uint64_t v77 = (int8x16_t *)((char *)v77 + 1);
          if (v77 >= (int8x16_t *)v74)
          {
            uint64_t v77 = (int8x16_t *)&a10[v72];
            break;
          }
        }
      }
      int64_t v78 = (char *)v77 - a10;
      int64_t v79 = ((char *)v77 - a10) * a14;
      a3 += v79;
      result += v79;
      a10 += v79;
      v72 -= v78;
LABEL_82:
      if (v72 <= 3) {
        goto LABEL_85;
      }
    }
    uint64_t v96 = 0;
    while (1)
    {
      float32x4_t v97 = (int8x16_t *)((char *)result + v96);
      float16x8_t v98 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v96]);
      float16x8_t v99 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v96]);
      v15.i32[0] = v73;
      uint8x16_t v100 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v101 = vmulq_f16(vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v100.i8)), v25), (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v96]));
      float16x8_t v102 = vmulq_f16(vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v100)), v25), (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v96]));
      float16x8_t v103 = (float16x8_t)vqtbl1q_s8((int8x16_t)v102, (int8x16_t)xmmword_1850CD880);
      float16x8_t v104 = (float16x8_t)vqtbl1q_s8((int8x16_t)v101, (int8x16_t)xmmword_1850CD880);
      int8x16_t v105 = (int8x16_t)vcgtzq_f16(v103);
      float16x8_t v15 = vmaxnmq_f16(vminnmq_f16(v103, v23), (float16x8_t)0);
      *float32x4_t v97 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v104), (int8x16_t)vaddq_f16(v101, vmlsq_f16(v99, v99, vmaxnmq_f16(vminnmq_f16(v104, v23), (float16x8_t)0))), (int8x16_t)v99));
      v97[1] = vrev16q_s8(vbslq_s8(v105, (int8x16_t)vaddq_f16(v102, vmlsq_f16(v98, v98, v15)), (int8x16_t)v98));
      a10 += v18;
      v72 -= 4;
      if (v72 < 4) {
        break;
      }
      __int32 v73 = *(_DWORD *)a10;
      v96 += v21;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        __int16 result = (float16x4_t *)((char *)result + v96);
        a3 = (float16x4_t *)((char *)a3 + v96);
        goto LABEL_82;
      }
    }
    __int16 result = (float16x4_t *)((char *)result + v21 + v96);
    a3 = (float16x4_t *)((char *)a3 + v21 + v96);
LABEL_85:
    for (unint64_t j = a12 - v71 + v72; j; --j)
    {
      if (*a10)
      {
        float16x4_t v107 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v108 = vmul_f16(vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v26), (float16x4_t)vrev16_s8((int8x8_t)*a3));
        float16x4_t v109 = (float16x4_t)vdup_lane_s16((int16x4_t)v108, 3);
        *(float16x4_t *)v15.i8 = vmls_f16(v107, v107, vmaxnm_f16(vminnm_f16(v109, (float16x4_t)0x3C003C003C003C00), 0));
        int *result = (float16x4_t)vrev16_s8(vbsl_s8((int8x8_t)vcgtz_f16(v109), (int8x8_t)vadd_f16(v108, *(float16x4_t *)v15.i8), (int8x8_t)v107));
      }
      char v110 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v110 >= a8) {
        uint64_t v111 = v19;
      }
      else {
        uint64_t v111 = 0;
      }
      a3 = &v110[v111];
      __int16 result = (float16x4_t *)((char *)result + v22);
    }
    a10 += a11;
    result += a2;
    uint64_t v112 = &a5[a4];
    if ((unint64_t)v112 >= a9) {
      uint64_t v113 = v20;
    }
    else {
      uint64_t v113 = 0;
    }
    int v114 = &v112[v113];
    uint64_t v115 = a8 + 8 * v113 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v114;
      a8 = v115;
      a5 = v114;
    }
    BOOL v70 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v70 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

uint64_t composite_pixelmask_SOVER(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, int a6, int a7, unint64_t a8, double a9, double a10, double a11, float16x4_t a12, double a13, float32x4_t a14, unint64_t a15, unsigned char *a16, uint64_t a17, int a18, int a19, int a20)
{
  if (use_vImage_fp16_compositing(void)::predicate != -1) {
    dispatch_once(&use_vImage_fp16_compositing(void)::predicate, &__block_literal_global_21437);
  }
  if (use_vImage_fp16_compositing(void)::status) {
    return vImageCGCompositePixelMask_ARGB16F();
  }
  LOWORD(v31) = COERCE_UNSIGNED_INT(1.0);
  do
  {
    int v32 = a18;
    do
    {
      unsigned int v33 = *a16;
      if (!*a16) {
        goto LABEL_18;
      }
      if (v33 == 255)
      {
        short float v34 = *(short float *)(a3 + 6);
        if (v34 < v31)
        {
          __asm { FCMP            H3, #0 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_18;
          }
          __asm { FCVT            S3, H3 }
          a14.i32[0] = *(_DWORD *)a3;
          v41.i64[0] = vcvtq_f32_f16(*(float16x4_t *)a14.f32).u64[0];
          _H6 = *(_WORD *)(a3 + 4);
          __asm { FCVT            S6, H6 }
          v41.i64[1] = __PAIR64__(LODWORD(_S3), _S6);
          a14 = vmlaq_n_f32(v41, vcvtq_f32_f16(*(float16x4_t *)a1), 1.0 - _S3);
          a12 = vcvt_f16_f32(a14);
LABEL_15:
          *(double *)a1 = *(double *)&a12;
          goto LABEL_18;
        }
        *(_DWORD *)a1 = *(_DWORD *)a3;
        *(_WORD *)(a1 + 4) = *(_WORD *)(a3 + 4);
        *(short float *)(a1 + 6) = v34;
      }
      else
      {
        float v44 = (float)v33 * 0.0039216;
        a12.i32[0] = *(_DWORD *)a3;
        float32x4_t v45 = vcvtq_f32_f16(a12);
        *(float32x2_t *)v45.f32 = vmul_n_f32(*(float32x2_t *)v45.f32, v44);
        a12 = vcvt_f16_f32(v45);
        _H4 = *(_WORD *)(a3 + 4);
        __asm { FCVT            S4, H4 }
        _S4 = v44 * _S4;
        __asm { FCVT            H4, S4 }
        _H6 = *(_WORD *)(a3 + 6);
        __asm { FCVT            S6, H6 }
        _S5 = v44 * _S6;
        __asm { FCVT            H5, S5 }
        if (_H5 < v31)
        {
          __asm { FCMP            H5, #0 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_18;
          }
          __asm { FCVT            S5, H5 }
          v56.i64[0] = vcvtq_f32_f16(a12).u64[0];
          __asm { FCVT            S4, H4 }
          v56.i64[1] = __PAIR64__(LODWORD(_S5), _S4);
          a12 = vcvt_f16_f32(vmlaq_n_f32(v56, vcvtq_f32_f16(*(float16x4_t *)a1), 1.0 - _S5));
          goto LABEL_15;
        }
        *(_DWORD *)a1 = a12.i32[0];
        *(_WORD *)(a1 + 4) = _H4;
        *(short float *)(a1 + 6) = _H5;
      }
LABEL_18:
      a16 += a20;
      unint64_t v58 = a3 + 8 * a20;
      if (v58 >= a8) {
        uint64_t v59 = -(uint64_t)a7;
      }
      else {
        uint64_t v59 = 0;
      }
      a3 = v58 + 8 * v59;
      a1 += 8 * a20;
      --v32;
    }
    while (v32);
    a16 += a17;
    a1 += 8 * a2;
    unint64_t v60 = a5 + 8 * a4;
    if (v60 >= a15) {
      uint64_t v61 = -(a6 * a4);
    }
    else {
      uint64_t v61 = 0;
    }
    unint64_t v62 = v60 + 8 * v61;
    uint64_t result = a8 + 8 * v61 + 8 * a4;
    if (a15)
    {
      a8 = result;
      a5 = v62;
      a3 = v62;
    }
    else
    {
      a3 += 8 * a4;
    }
    --a19;
  }
  while (a19);
  return result;
}

int16x4_t *composite_pixelmask<(CGCompositeOperation)6,_rgbaf16_t>(int16x4_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = -1;
  }
  int8x16_t v19 = (int8x16_t)vdupq_n_s16(v18);
  v21.i64[0] = 0xFFFF000000000000;
  v21.i64[1] = 0xFFFF000000000000;
  int8x16_t v22 = vmvnq_s8(vandq_s8(v19, v21));
  int8x16_t v23 = vandq_s8(v19, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v24 = 4 * a14;
  int8x8_t v25 = 0;
  v25.i16[3] = v18;
  int8x8_t v26 = vmvn_s8(v25);
  int8x8_t v27 = vand_s8(*(int8x8_t *)v19.i8, (int8x8_t)0x3C00000000000000);
  uint64_t v28 = -(uint64_t)a7;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 8 * a14;
  v32.i64[0] = 0x3C003C003C003C00;
  v32.i64[1] = 0x3C003C003C003C00;
  v33.i64[0] = -1;
  v33.i64[1] = -1;
  float16x8_t v34 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v35 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a16 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v36 = (a8 - (unint64_t)a3) >> 3;
      if (v36 >= a12) {
        unint64_t v36 = a12;
      }
      unint64_t v37 = v36;
      if (v36 < 4) {
        goto LABEL_39;
      }
      while (1)
      {
        __int32 v38 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          float32x4_t v45 = (unsigned __int8 *)&a10[v37];
          float16x8_t v46 = (int8x16_t *)a10;
          do
            float16x8_t v47 = v46++;
          while (v46 <= (int8x16_t *)v45 && (vminvq_u8((uint8x16_t)vceqq_s8(*v47, v33)) & 0x80) != 0);
          do
          {
            int8x16_t v48 = v47;
            float16x8_t v47 = (int8x16_t *)((char *)v47 + 4);
          }
          while (v47 <= (int8x16_t *)v45 && v48->i32[0] == -1);
          if (v48 < (int8x16_t *)v45)
          {
            while (v48->u8[0] == 255)
            {
              int8x16_t v48 = (int8x16_t *)((char *)v48 + 1);
              if (v48 >= (int8x16_t *)v45)
              {
                int8x16_t v48 = (int8x16_t *)&a10[v37];
                break;
              }
            }
          }
          uint64_t v49 = 0;
          int64_t v50 = (char *)v48 - a10;
          unint64_t v51 = (char *)v48 - a10;
          do
          {
            float16x8_t v52 = (int8x16_t *)((char *)result + v49);
            int8x16_t v53 = *(int8x16_t *)&result->i8[v49];
            int8x16_t v54 = *(int8x16_t *)&result[2].i8[v49];
            float16x8_t v55 = (float16x8_t)vqtbl1q_s8(v54, (int8x16_t)xmmword_1850CD880);
            float16x8_t v56 = (float16x8_t)vqtbl1q_s8(v53, (int8x16_t)xmmword_1850CD880);
            int8x16_t v57 = (int8x16_t)vcgtzq_f16(v56);
            int8x16_t v58 = (int8x16_t)vcgtzq_f16(v55);
            int8x16_t v59 = (int8x16_t)vcgtq_f16(v55, v32);
            float16x8_t v16 = (float16x8_t)vandq_s8(v58, (int8x16_t)v55);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v49], v22), v23);
            float16x8_t v61 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v49], v22), v23);
            int8x16_t *v52 = vbslq_s8((int8x16_t)vcgtq_f16(v56, v32), v53, (int8x16_t)vaddq_f16(vmlsq_f16(v60, v60, (float16x8_t)vandq_s8(v57, (int8x16_t)v56)), (float16x8_t)vandq_s8(v57, v53)));
            v52[1] = vbslq_s8(v59, v54, (int8x16_t)vaddq_f16(vmlsq_f16(v61, v61, v16), (float16x8_t)vandq_s8(v58, v54)));
            a10 += v24;
            v51 -= 4;
            v49 += v30;
          }
          while (v51 > 3);
          a3 = (int8x8_t *)((char *)a3 + v49);
          uint64_t result = (int16x4_t *)((char *)result + v49);
          unint64_t v37 = v37 - v50 + v51;
          goto LABEL_36;
        }
        if (v38) {
          break;
        }
        int v39 = (unsigned __int8 *)&a10[v37];
        uint64_t v40 = (int8x16_t *)a10;
        do
          float32x4_t v41 = v40++;
        while (v40 <= (int8x16_t *)v39 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v41)) & 0x80) != 0);
        do
        {
          unint64_t v42 = v41;
          float32x4_t v41 = (int8x16_t *)((char *)v41 + 4);
        }
        while (v41 <= (int8x16_t *)v39 && !v42->i32[0]);
        if (v42 < (int8x16_t *)v39)
        {
          while (!v42->i8[0])
          {
            unint64_t v42 = (int8x16_t *)((char *)v42 + 1);
            if (v42 >= (int8x16_t *)v39)
            {
              unint64_t v42 = (int8x16_t *)&a10[v37];
              break;
            }
          }
        }
        int64_t v43 = (char *)v42 - a10;
        int64_t v44 = ((char *)v42 - a10) * a14;
        a3 += v44;
        result += v44;
        a10 += v44;
        v37 -= v43;
LABEL_36:
        if (v37 <= 3) {
          goto LABEL_39;
        }
      }
      uint64_t v62 = 0;
      while (1)
      {
        float16x4_t v63 = (int8x16_t *)((char *)result + v62);
        int8x16_t v64 = *(int8x16_t *)&result->i8[v62];
        int8x16_t v65 = *(int8x16_t *)&result[2].i8[v62];
        v16.i32[0] = v38;
        uint8x16_t v66 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v67 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v66.i8));
        float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v66)), v34);
        float16x8_t v68 = vmulq_f16(v67, v34);
        float16x8_t v69 = (float16x8_t)vqtbl1q_s8(v65, (int8x16_t)xmmword_1850CD880);
        float16x8_t v70 = (float16x8_t)vqtbl1q_s8(v64, (int8x16_t)xmmword_1850CD880);
        int8x16_t v71 = (int8x16_t)vcgtzq_f16(v70);
        int8x16_t v72 = (int8x16_t)vcgtzq_f16(v69);
        float16x8_t v73 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v62], v22), v23);
        float16x8_t v74 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v62], v22), v23);
        int8x16_t *v63 = vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f16(v68), (int8x16_t)vcgtq_f16(v70, v32)), v64, (int8x16_t)vmlaq_f16((float16x8_t)vandq_s8(v71, v64), v68, vmlsq_f16(v73, v73, (float16x8_t)vandq_s8(v71, (int8x16_t)v70))));
        v63[1] = vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f16(v16), (int8x16_t)vcgtq_f16(v69, v32)), v65, (int8x16_t)vmlaq_f16((float16x8_t)vandq_s8(v72, v65), v16, vmlsq_f16(v74, v74, (float16x8_t)vandq_s8(v72, (int8x16_t)v69))));
        a10 += v24;
        v37 -= 4;
        if (v37 < 4) {
          break;
        }
        __int32 v38 = *(_DWORD *)a10;
        v62 += v30;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int16x4_t *)((char *)result + v62);
          a3 = (int8x8_t *)((char *)a3 + v62);
          goto LABEL_36;
        }
      }
      uint64_t result = (int16x4_t *)((char *)result + v30 + v62);
      a3 = (int8x8_t *)((char *)a3 + v30 + v62);
LABEL_39:
      for (unint64_t i = a12 - v36 + v37; i; --i)
      {
        if (*a10)
        {
          float16x4_t v76 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v35);
          float16x4_t v77 = (float16x4_t)vorr_s8(vand_s8(*a3, v26), v27);
          float16x4_t v78 = (float16x4_t)vdup_lane_s16(*result, 3);
          int8x8_t v79 = (int8x8_t)vcgtz_f16(v78);
          int8x8_t v80 = (int8x8_t)vcgt_f16(v78, (float16x4_t)0x3C003C003C003C00);
          *(int8x8_t *)v16.i8 = vand_s8(v79, (int8x8_t)v78);
          int *result = (int16x4_t)vbsl_s8(vorr_s8(v80, (int8x8_t)vceqz_f16(v76)), (int8x8_t)*result, (int8x8_t)vmla_f16((float16x4_t)vand_s8(v79, (int8x8_t)*result), v76, vmls_f16(v77, v77, *(float16x4_t *)v16.i8)));
        }
        float16x4_t v81 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v81 >= a8) {
          uint64_t v82 = v28;
        }
        else {
          uint64_t v82 = 0;
        }
        a3 = &v81[v82];
        uint64_t result = (int16x4_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      float32x4_t v83 = &a5[a4];
      if ((unint64_t)v83 >= a9) {
        uint64_t v84 = v29;
      }
      else {
        uint64_t v84 = 0;
      }
      int64_t v85 = &v83[v84];
      uint64_t v86 = a8 + 8 * v84 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v85;
        a8 = v86;
        a5 = v85;
      }
      BOOL v87 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v87 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v88 = (a8 - (unint64_t)a3) >> 3;
    if (v88 >= a12) {
      unint64_t v88 = a12;
    }
    unint64_t v89 = v88;
    if (v88 < 4) {
      goto LABEL_88;
    }
    while (1)
    {
      __int32 v90 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        float32x4_t v97 = (unsigned __int8 *)&a10[v89];
        float16x8_t v98 = (int8x16_t *)a10;
        do
          float16x8_t v99 = v98++;
        while (v98 <= (int8x16_t *)v97 && (vminvq_u8((uint8x16_t)vceqq_s8(*v99, v33)) & 0x80) != 0);
        do
        {
          uint8x16_t v100 = v99;
          float16x8_t v99 = (int8x16_t *)((char *)v99 + 4);
        }
        while (v99 <= (int8x16_t *)v97 && v100->i32[0] == -1);
        if (v100 < (int8x16_t *)v97)
        {
          while (v100->u8[0] == 255)
          {
            uint8x16_t v100 = (int8x16_t *)((char *)v100 + 1);
            if (v100 >= (int8x16_t *)v97)
            {
              uint8x16_t v100 = (int8x16_t *)&a10[v89];
              break;
            }
          }
        }
        uint64_t v101 = 0;
        int64_t v102 = (char *)v100 - a10;
        unint64_t v103 = (char *)v100 - a10;
        do
        {
          float16x8_t v104 = (int8x16_t *)((char *)result + v101);
          int8x16_t v105 = vrev16q_s8(*(int8x16_t *)&result->i8[v101]);
          int8x16_t v106 = vrev16q_s8(*(int8x16_t *)&result[2].i8[v101]);
          float16x8_t v107 = (float16x8_t)vqtbl1q_s8(v106, (int8x16_t)xmmword_1850CD880);
          float16x8_t v108 = (float16x8_t)vqtbl1q_s8(v105, (int8x16_t)xmmword_1850CD880);
          int8x16_t v109 = (int8x16_t)vcgtzq_f16(v108);
          int8x16_t v110 = (int8x16_t)vcgtzq_f16(v107);
          int8x16_t v111 = (int8x16_t)vcgtq_f16(v107, v32);
          float16x8_t v16 = (float16x8_t)vandq_s8(v110, (int8x16_t)v107);
          float16x8_t v112 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v101]), v22), v23);
          float16x8_t v113 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v101]), v22), v23);
          *float16x8_t v104 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtq_f16(v108, v32), v105, (int8x16_t)vaddq_f16(vmlsq_f16(v112, v112, (float16x8_t)vandq_s8(v109, (int8x16_t)v108)), (float16x8_t)vandq_s8(v109, v105))));
          v104[1] = vrev16q_s8(vbslq_s8(v111, v106, (int8x16_t)vaddq_f16(vmlsq_f16(v113, v113, v16), (float16x8_t)vandq_s8(v110, v106))));
          a10 += v24;
          v103 -= 4;
          v101 += v30;
        }
        while (v103 > 3);
        a3 = (int8x8_t *)((char *)a3 + v101);
        uint64_t result = (int16x4_t *)((char *)result + v101);
        unint64_t v89 = v89 - v102 + v103;
        goto LABEL_85;
      }
      if (v90) {
        break;
      }
      float16x8_t v91 = (unsigned __int8 *)&a10[v89];
      float16x8_t v92 = (int8x16_t *)a10;
      do
        float16x8_t v93 = v92++;
      while (v92 <= (int8x16_t *)v91 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v93)) & 0x80) != 0);
      do
      {
        int8x16_t v94 = v93;
        float16x8_t v93 = (int8x16_t *)((char *)v93 + 4);
      }
      while (v93 <= (int8x16_t *)v91 && !v94->i32[0]);
      if (v94 < (int8x16_t *)v91)
      {
        while (!v94->i8[0])
        {
          int8x16_t v94 = (int8x16_t *)((char *)v94 + 1);
          if (v94 >= (int8x16_t *)v91)
          {
            int8x16_t v94 = (int8x16_t *)&a10[v89];
            break;
          }
        }
      }
      int64_t v95 = (char *)v94 - a10;
      int64_t v96 = ((char *)v94 - a10) * a14;
      a3 += v96;
      result += v96;
      a10 += v96;
      v89 -= v95;
LABEL_85:
      if (v89 <= 3) {
        goto LABEL_88;
      }
    }
    uint64_t v114 = 0;
    while (1)
    {
      uint64_t v115 = (int8x16_t *)((char *)result + v114);
      int8x16_t v116 = vrev16q_s8(*(int8x16_t *)&result->i8[v114]);
      int8x16_t v117 = vrev16q_s8(*(int8x16_t *)&result[2].i8[v114]);
      v16.i32[0] = v90;
      uint8x16_t v118 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v119 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v118.i8));
      float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v118)), v34);
      float16x8_t v120 = vmulq_f16(v119, v34);
      float16x8_t v121 = (float16x8_t)vqtbl1q_s8(v117, (int8x16_t)xmmword_1850CD880);
      float16x8_t v122 = (float16x8_t)vqtbl1q_s8(v116, (int8x16_t)xmmword_1850CD880);
      int8x16_t v123 = (int8x16_t)vcgtzq_f16(v122);
      int8x16_t v124 = (int8x16_t)vcgtzq_f16(v121);
      float16x8_t v125 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v114]), v22), v23);
      float16x8_t v126 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v114]), v22), v23);
      *uint64_t v115 = vrev16q_s8(vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f16(v120), (int8x16_t)vcgtq_f16(v122, v32)), v116, (int8x16_t)vmlaq_f16((float16x8_t)vandq_s8(v123, v116), v120, vmlsq_f16(v125, v125, (float16x8_t)vandq_s8(v123, (int8x16_t)v122)))));
      v115[1] = vrev16q_s8(vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f16(v16), (int8x16_t)vcgtq_f16(v121, v32)), v117, (int8x16_t)vmlaq_f16((float16x8_t)vandq_s8(v124, v117), v16, vmlsq_f16(v126, v126, (float16x8_t)vandq_s8(v124, (int8x16_t)v121)))));
      a10 += v24;
      v89 -= 4;
      if (v89 < 4) {
        break;
      }
      __int32 v90 = *(_DWORD *)a10;
      v114 += v30;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int16x4_t *)((char *)result + v114);
        a3 = (int8x8_t *)((char *)a3 + v114);
        goto LABEL_85;
      }
    }
    uint64_t result = (int16x4_t *)((char *)result + v30 + v114);
    a3 = (int8x8_t *)((char *)a3 + v30 + v114);
LABEL_88:
    for (unint64_t j = a12 - v88 + v89; j; --j)
    {
      if (*a10)
      {
        int16x4_t v128 = (int16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v129 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v35);
        float16x4_t v130 = (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v26), v27);
        float16x4_t v131 = (float16x4_t)vdup_lane_s16(v128, 3);
        int8x8_t v132 = (int8x8_t)vcgtz_f16(v131);
        int8x8_t v133 = (int8x8_t)vcgt_f16(v131, (float16x4_t)0x3C003C003C003C00);
        *(int8x8_t *)v16.i8 = vand_s8(v132, (int8x8_t)v131);
        int *result = (int16x4_t)vrev16_s8(vbsl_s8(vorr_s8(v133, (int8x8_t)vceqz_f16(v129)), (int8x8_t)v128, (int8x8_t)vmla_f16((float16x4_t)vand_s8(v132, (int8x8_t)v128), v129, vmls_f16(v130, v130, *(float16x4_t *)v16.i8))));
      }
      float v134 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v134 >= a8) {
        uint64_t v135 = v28;
      }
      else {
        uint64_t v135 = 0;
      }
      a3 = &v134[v135];
      uint64_t result = (int16x4_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    __int16 v136 = &a5[a4];
    if ((unint64_t)v136 >= a9) {
      uint64_t v137 = v29;
    }
    else {
      uint64_t v137 = 0;
    }
    __int16 v138 = &v136[v137];
    uint64_t v139 = a8 + 8 * v137 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v138;
      a8 = v139;
      a5 = v138;
    }
    BOOL v87 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v87 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)3,_rgbaf16_t>(float16x4_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = -1;
  }
  int8x16_t v19 = (int8x16_t)vdupq_n_s16(v18);
  v21.i64[0] = 0xFFFF000000000000;
  v21.i64[1] = 0xFFFF000000000000;
  int8x16_t v22 = vmvnq_s8(vandq_s8(v19, v21));
  int8x16_t v23 = vandq_s8(v19, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v24 = 4 * a14;
  int8x8_t v25 = 0;
  v25.i16[3] = v18;
  int8x8_t v26 = vmvn_s8(v25);
  int8x8_t v27 = vand_s8(*(int8x8_t *)v19.i8, (int8x8_t)0x3C00000000000000);
  uint64_t v28 = -(uint64_t)a7;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 8 * a14;
  v32.i64[0] = -1;
  v32.i64[1] = -1;
  float16x8_t v33 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v34 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a16 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v35 = (a8 - (unint64_t)a3) >> 3;
      if (v35 >= a12) {
        unint64_t v35 = a12;
      }
      unint64_t v36 = v35;
      if (v35 < 4) {
        goto LABEL_39;
      }
      while (1)
      {
        __int32 v37 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v44 = (unsigned __int8 *)&a10[v36];
          float32x4_t v45 = (int8x16_t *)a10;
          do
            float16x8_t v46 = v45++;
          while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqq_s8(*v46, v32)) & 0x80) != 0);
          do
          {
            float16x8_t v47 = v46;
            float16x8_t v46 = (int8x16_t *)((char *)v46 + 4);
          }
          while (v46 <= (int8x16_t *)v44 && v47->i32[0] == -1);
          if (v47 < (int8x16_t *)v44)
          {
            while (v47->u8[0] == 255)
            {
              float16x8_t v47 = (int8x16_t *)((char *)v47 + 1);
              if (v47 >= (int8x16_t *)v44)
              {
                float16x8_t v47 = (int8x16_t *)&a10[v36];
                break;
              }
            }
          }
          uint64_t v48 = 0;
          int64_t v49 = (char *)v47 - a10;
          unint64_t v50 = (char *)v47 - a10;
          do
          {
            unint64_t v51 = (float16x8_t *)((char *)result + v48);
            float16x8_t v52 = *(float16x8_t *)&result->i8[v48];
            float16x8_t v16 = (float16x8_t)vqtbl1q_s8((int8x16_t)v52, (int8x16_t)xmmword_1850CD880);
            float16x8_t v53 = vmlaq_f16(vsubq_f16(*(float16x8_t *)&result[2].i8[v48], *(float16x8_t *)&result[2].i8[v48]), (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v48], (int8x16_t)xmmword_1850CD880), (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v48], v22), v23));
            float16x8_t *v51 = vmlaq_f16(vsubq_f16(v52, v52), v16, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v48], v22), v23));
            v51[1] = v53;
            a10 += v24;
            v50 -= 4;
            v48 += v30;
          }
          while (v50 > 3);
          a3 = (int8x8_t *)((char *)a3 + v48);
          uint64_t result = (float16x4_t *)((char *)result + v48);
          unint64_t v36 = v36 - v49 + v50;
          goto LABEL_36;
        }
        if (v37) {
          break;
        }
        __int32 v38 = (unsigned __int8 *)&a10[v36];
        int v39 = (int8x16_t *)a10;
        do
          uint64_t v40 = v39++;
        while (v39 <= (int8x16_t *)v38 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v40)) & 0x80) != 0);
        do
        {
          float32x4_t v41 = v40;
          uint64_t v40 = (int8x16_t *)((char *)v40 + 4);
        }
        while (v40 <= (int8x16_t *)v38 && !v41->i32[0]);
        if (v41 < (int8x16_t *)v38)
        {
          while (!v41->i8[0])
          {
            float32x4_t v41 = (int8x16_t *)((char *)v41 + 1);
            if (v41 >= (int8x16_t *)v38)
            {
              float32x4_t v41 = (int8x16_t *)&a10[v36];
              break;
            }
          }
        }
        int64_t v42 = (char *)v41 - a10;
        int64_t v43 = ((char *)v41 - a10) * a14;
        a3 += v43;
        result += v43;
        a10 += v43;
        v36 -= v42;
LABEL_36:
        if (v36 <= 3) {
          goto LABEL_39;
        }
      }
      uint64_t v54 = 0;
      while (1)
      {
        float16x8_t v55 = (float16x8_t *)((char *)result + v54);
        v16.i32[0] = v37;
        uint8x16_t v56 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v57 = vcvtq_f16_u16(vmovl_high_u8(v56));
        float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v56.i8)), v33);
        float16x8_t v58 = vmulq_f16(v57, v33);
        float16x8_t v59 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result[2].i8[v54], *(float16x8_t *)&result[2].i8[v54], v58), (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v54], (int8x16_t)xmmword_1850CD880), vmulq_f16(v58, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v54], v22), v23)));
        float16x8_t *v55 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result->i8[v54], *(float16x8_t *)&result->i8[v54], v16), (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v54], (int8x16_t)xmmword_1850CD880), vmulq_f16(v16, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v54], v22), v23)));
        v55[1] = v59;
        a10 += v24;
        v36 -= 4;
        if (v36 < 4) {
          break;
        }
        __int32 v37 = *(_DWORD *)a10;
        v54 += v30;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v54);
          a3 = (int8x8_t *)((char *)a3 + v54);
          goto LABEL_36;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v30 + v54);
      a3 = (int8x8_t *)((char *)a3 + v30 + v54);
LABEL_39:
      for (unint64_t i = a12 - v35 + v36; i; --i)
      {
        if (*a10)
        {
          float16x4_t v61 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v34);
          int *result = vmla_lane_f16(vmls_f16(*result, *result, v61), vmul_f16(v61, (float16x4_t)vorr_s8(vand_s8(*a3, v26), v27)), *result, 3);
        }
        uint64_t v62 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v62 >= a8) {
          uint64_t v63 = v28;
        }
        else {
          uint64_t v63 = 0;
        }
        a3 = &v62[v63];
        uint64_t result = (float16x4_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      int8x16_t v64 = &a5[a4];
      if ((unint64_t)v64 >= a9) {
        uint64_t v65 = v29;
      }
      else {
        uint64_t v65 = 0;
      }
      uint8x16_t v66 = &v64[v65];
      uint64_t v67 = a8 + 8 * v65 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v66;
        a8 = v67;
        a5 = v66;
      }
      BOOL v68 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v68 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v69 = (a8 - (unint64_t)a3) >> 3;
    if (v69 >= a12) {
      unint64_t v69 = a12;
    }
    unint64_t v70 = v69;
    if (v69 < 4) {
      goto LABEL_88;
    }
    while (1)
    {
      __int32 v71 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        float16x4_t v78 = (unsigned __int8 *)&a10[v70];
        int8x8_t v79 = (int8x16_t *)a10;
        do
          int8x8_t v80 = v79++;
        while (v79 <= (int8x16_t *)v78 && (vminvq_u8((uint8x16_t)vceqq_s8(*v80, v32)) & 0x80) != 0);
        do
        {
          float16x4_t v81 = v80;
          int8x8_t v80 = (int8x16_t *)((char *)v80 + 4);
        }
        while (v80 <= (int8x16_t *)v78 && v81->i32[0] == -1);
        if (v81 < (int8x16_t *)v78)
        {
          while (v81->u8[0] == 255)
          {
            float16x4_t v81 = (int8x16_t *)((char *)v81 + 1);
            if (v81 >= (int8x16_t *)v78)
            {
              float16x4_t v81 = (int8x16_t *)&a10[v70];
              break;
            }
          }
        }
        uint64_t v82 = 0;
        int64_t v83 = (char *)v81 - a10;
        unint64_t v84 = (char *)v81 - a10;
        do
        {
          int64_t v85 = (int8x16_t *)((char *)result + v82);
          float16x8_t v86 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v82]);
          float16x8_t v87 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v82]);
          float16x8_t v16 = (float16x8_t)vqtbl1q_s8((int8x16_t)v87, (int8x16_t)xmmword_1850CD880);
          int8x16_t v88 = vrev16q_s8((int8x16_t)vmlaq_f16(vsubq_f16(v87, v87), v16, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v82]), v22), v23)));
          *int64_t v85 = vrev16q_s8((int8x16_t)vmlaq_f16(vsubq_f16(v86, v86), (float16x8_t)vqtbl1q_s8((int8x16_t)v86, (int8x16_t)xmmword_1850CD880), (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v82]), v22), v23)));
          v85[1] = v88;
          a10 += v24;
          v84 -= 4;
          v82 += v30;
        }
        while (v84 > 3);
        a3 = (int8x8_t *)((char *)a3 + v82);
        uint64_t result = (float16x4_t *)((char *)result + v82);
        unint64_t v70 = v70 - v83 + v84;
        goto LABEL_85;
      }
      if (v71) {
        break;
      }
      int8x16_t v72 = (unsigned __int8 *)&a10[v70];
      float16x8_t v73 = (int8x16_t *)a10;
      do
        float16x8_t v74 = v73++;
      while (v73 <= (int8x16_t *)v72 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v74)) & 0x80) != 0);
      do
      {
        uint64_t v75 = v74;
        float16x8_t v74 = (int8x16_t *)((char *)v74 + 4);
      }
      while (v74 <= (int8x16_t *)v72 && !v75->i32[0]);
      if (v75 < (int8x16_t *)v72)
      {
        while (!v75->i8[0])
        {
          uint64_t v75 = (int8x16_t *)((char *)v75 + 1);
          if (v75 >= (int8x16_t *)v72)
          {
            uint64_t v75 = (int8x16_t *)&a10[v70];
            break;
          }
        }
      }
      int64_t v76 = (char *)v75 - a10;
      int64_t v77 = ((char *)v75 - a10) * a14;
      a3 += v77;
      result += v77;
      a10 += v77;
      v70 -= v76;
LABEL_85:
      if (v70 <= 3) {
        goto LABEL_88;
      }
    }
    uint64_t v89 = 0;
    while (1)
    {
      __int32 v90 = (int8x16_t *)((char *)result + v89);
      float16x8_t v91 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v89]);
      float16x8_t v92 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v89]);
      v16.i32[0] = v71;
      uint8x16_t v93 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v94 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v93.i8));
      float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v93)), v33);
      float16x8_t v95 = vmulq_f16(v94, v33);
      int8x16_t v96 = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v91, v91, v16), (float16x8_t)vqtbl1q_s8((int8x16_t)v91, (int8x16_t)xmmword_1850CD880), vmulq_f16(v16, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v89]), v22), v23))));
      *__int32 v90 = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v92, v92, v95), (float16x8_t)vqtbl1q_s8((int8x16_t)v92, (int8x16_t)xmmword_1850CD880), vmulq_f16(v95, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v89]), v22), v23))));
      v90[1] = v96;
      a10 += v24;
      v70 -= 4;
      if (v70 < 4) {
        break;
      }
      __int32 v71 = *(_DWORD *)a10;
      v89 += v30;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v89);
        a3 = (int8x8_t *)((char *)a3 + v89);
        goto LABEL_85;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v30 + v89);
    a3 = (int8x8_t *)((char *)a3 + v30 + v89);
LABEL_88:
    for (unint64_t j = a12 - v69 + v70; j; --j)
    {
      if (*a10)
      {
        float16x4_t v98 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v99 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v34);
        int *result = (float16x4_t)vrev16_s8((int8x8_t)vmla_lane_f16(vmls_f16(v98, v98, v99), vmul_f16(v99, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v26), v27)), v98, 3));
      }
      uint8x16_t v100 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v100 >= a8) {
        uint64_t v101 = v28;
      }
      else {
        uint64_t v101 = 0;
      }
      a3 = &v100[v101];
      uint64_t result = (float16x4_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    int64_t v102 = &a5[a4];
    if ((unint64_t)v102 >= a9) {
      uint64_t v103 = v29;
    }
    else {
      uint64_t v103 = 0;
    }
    float16x8_t v104 = &v102[v103];
    uint64_t v105 = a8 + 8 * v103 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v104;
      a8 = v105;
      a5 = v104;
    }
    BOOL v68 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v68 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)7,_rgbaf16_t>(float16x4_t *result, uint64_t a2, float16x4_t *a3, uint64_t a4, float16x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v18 = 4 * a14;
  uint64_t v19 = -(uint64_t)a7;
  uint64_t v20 = -(a6 * a4);
  uint64_t v21 = 32 * a14;
  uint64_t v22 = 8 * a14;
  v23.i64[0] = 0xBC00BC00BC00BC00;
  v23.i64[1] = 0xBC00BC00BC00BC00;
  v24.i64[0] = -1;
  v24.i64[1] = -1;
  float16x8_t v25 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v26 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a15 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v27 = (a8 - (unint64_t)a3) >> 3;
      if (v27 >= a12) {
        unint64_t v27 = a12;
      }
      unint64_t v28 = v27;
      if (v27 < 4) {
        goto LABEL_36;
      }
      while (1)
      {
        __int32 v29 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          unint64_t v36 = (unsigned __int8 *)&a10[v28];
          __int32 v37 = (int8x16_t *)a10;
          do
            __int32 v38 = v37++;
          while (v37 <= (int8x16_t *)v36 && (vminvq_u8((uint8x16_t)vceqq_s8(*v38, v24)) & 0x80) != 0);
          do
          {
            int v39 = v38;
            __int32 v38 = (int8x16_t *)((char *)v38 + 4);
          }
          while (v38 <= (int8x16_t *)v36 && v39->i32[0] == -1);
          if (v39 < (int8x16_t *)v36)
          {
            while (v39->u8[0] == 255)
            {
              int v39 = (int8x16_t *)((char *)v39 + 1);
              if (v39 >= (int8x16_t *)v36)
              {
                int v39 = (int8x16_t *)&a10[v28];
                break;
              }
            }
          }
          uint64_t v40 = 0;
          int64_t v41 = (char *)v39 - a10;
          unint64_t v42 = (char *)v39 - a10;
          do
          {
            int64_t v43 = (float16x8_t *)((char *)result + v40);
            v44.i64[0] = 0x3C003C003C003C00;
            v44.i64[1] = 0x3C003C003C003C00;
            float16x8_t v15 = vmlaq_f16(v44, v23, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v40], (int8x16_t)xmmword_1850CD880));
            v45.i64[0] = 0x3C003C003C003C00;
            v45.i64[1] = 0x3C003C003C003C00;
            float16x8_t v46 = vmlsq_f16(*(float16x8_t *)&result[2].i8[v40], *(float16x8_t *)&result[2].i8[v40], vmlaq_f16(v45, v23, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3[2].i8[v40], (int8x16_t)xmmword_1850CD880)));
            float16x8_t *v43 = vmlsq_f16(*(float16x8_t *)&result->i8[v40], *(float16x8_t *)&result->i8[v40], v15);
            v43[1] = v46;
            a10 += v18;
            v42 -= 4;
            v40 += v21;
          }
          while (v42 > 3);
          a3 = (float16x4_t *)((char *)a3 + v40);
          uint64_t result = (float16x4_t *)((char *)result + v40);
          unint64_t v28 = v28 - v41 + v42;
          goto LABEL_33;
        }
        if (v29) {
          break;
        }
        uint64_t v30 = (unsigned __int8 *)&a10[v28];
        uint64_t v31 = (int8x16_t *)a10;
        do
          int8x16_t v32 = v31++;
        while (v31 <= (int8x16_t *)v30 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v32)) & 0x80) != 0);
        do
        {
          float16x8_t v33 = v32;
          int8x16_t v32 = (int8x16_t *)((char *)v32 + 4);
        }
        while (v32 <= (int8x16_t *)v30 && !v33->i32[0]);
        if (v33 < (int8x16_t *)v30)
        {
          while (!v33->i8[0])
          {
            float16x8_t v33 = (int8x16_t *)((char *)v33 + 1);
            if (v33 >= (int8x16_t *)v30)
            {
              float16x8_t v33 = (int8x16_t *)&a10[v28];
              break;
            }
          }
        }
        int64_t v34 = (char *)v33 - a10;
        int64_t v35 = ((char *)v33 - a10) * a14;
        a3 += v35;
        result += v35;
        a10 += v35;
        v28 -= v34;
LABEL_33:
        if (v28 <= 3) {
          goto LABEL_36;
        }
      }
      uint64_t v47 = 0;
      while (1)
      {
        uint64_t v48 = (float16x8_t *)((char *)result + v47);
        v15.i32[0] = v29;
        uint8x16_t v49 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v50 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v49.i8));
        float16x8_t v51 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v49)), v25);
        float16x8_t v52 = vmulq_f16(v50, v25);
        float16x8_t v15 = vmlsq_f16(v51, v51, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3[2].i8[v47], (int8x16_t)xmmword_1850CD880));
        float16x8_t v53 = vmlsq_f16(*(float16x8_t *)&result[2].i8[v47], *(float16x8_t *)&result[2].i8[v47], v15);
        float16x8_t *v48 = vmlsq_f16(*(float16x8_t *)&result->i8[v47], *(float16x8_t *)&result->i8[v47], vmlsq_f16(v52, v52, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v47], (int8x16_t)xmmword_1850CD880)));
        v48[1] = v53;
        a10 += v18;
        v28 -= 4;
        if (v28 < 4) {
          break;
        }
        __int32 v29 = *(_DWORD *)a10;
        v47 += v21;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v47);
          a3 = (float16x4_t *)((char *)a3 + v47);
          goto LABEL_33;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v21 + v47);
      a3 = (float16x4_t *)((char *)a3 + v21 + v47);
LABEL_36:
      for (unint64_t i = a12 - v27 + v28; i; --i)
      {
        if (*a10)
        {
          float16x4_t v55 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v26);
          int *result = vmls_f16(*result, *result, vmls_lane_f16(v55, v55, *a3, 3));
        }
        uint8x16_t v56 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v56 >= a8) {
          uint64_t v57 = v19;
        }
        else {
          uint64_t v57 = 0;
        }
        a3 = &v56[v57];
        uint64_t result = (float16x4_t *)((char *)result + v22);
      }
      a10 += a11;
      result += a2;
      float16x8_t v58 = &a5[a4];
      if ((unint64_t)v58 >= a9) {
        uint64_t v59 = v20;
      }
      else {
        uint64_t v59 = 0;
      }
      float16x8_t v60 = &v58[v59];
      uint64_t v61 = a8 + 8 * v59 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v60;
        a8 = v61;
        a5 = v60;
      }
      BOOL v62 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v62 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v63 = (a8 - (unint64_t)a3) >> 3;
    if (v63 >= a12) {
      unint64_t v63 = a12;
    }
    unint64_t v64 = v63;
    if (v63 < 4) {
      goto LABEL_85;
    }
    while (1)
    {
      __int32 v65 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        int8x16_t v72 = (unsigned __int8 *)&a10[v64];
        float16x8_t v73 = (int8x16_t *)a10;
        do
          float16x8_t v74 = v73++;
        while (v73 <= (int8x16_t *)v72 && (vminvq_u8((uint8x16_t)vceqq_s8(*v74, v24)) & 0x80) != 0);
        do
        {
          uint64_t v75 = v74;
          float16x8_t v74 = (int8x16_t *)((char *)v74 + 4);
        }
        while (v74 <= (int8x16_t *)v72 && v75->i32[0] == -1);
        if (v75 < (int8x16_t *)v72)
        {
          while (v75->u8[0] == 255)
          {
            uint64_t v75 = (int8x16_t *)((char *)v75 + 1);
            if (v75 >= (int8x16_t *)v72)
            {
              uint64_t v75 = (int8x16_t *)&a10[v64];
              break;
            }
          }
        }
        uint64_t v76 = 0;
        int64_t v77 = (char *)v75 - a10;
        unint64_t v78 = (char *)v75 - a10;
        do
        {
          int8x8_t v79 = (int8x16_t *)((char *)result + v76);
          float16x8_t v80 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v76]);
          float16x8_t v81 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v76]);
          v82.i64[0] = 0x3C003C003C003C00;
          v82.i64[1] = 0x3C003C003C003C00;
          float16x8_t v15 = vmlaq_f16(v82, v23, (float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v76]), (int8x16_t)xmmword_1850CD880));
          v83.i64[0] = 0x3C003C003C003C00;
          v83.i64[1] = 0x3C003C003C003C00;
          int8x16_t v84 = vrev16q_s8((int8x16_t)vmlsq_f16(v80, v80, vmlaq_f16(v83, v23, (float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v76]), (int8x16_t)xmmword_1850CD880))));
          *int8x8_t v79 = vrev16q_s8((int8x16_t)vmlsq_f16(v81, v81, v15));
          v79[1] = v84;
          a10 += v18;
          v78 -= 4;
          v76 += v21;
        }
        while (v78 > 3);
        a3 = (float16x4_t *)((char *)a3 + v76);
        uint64_t result = (float16x4_t *)((char *)result + v76);
        unint64_t v64 = v64 - v77 + v78;
        goto LABEL_82;
      }
      if (v65) {
        break;
      }
      uint8x16_t v66 = (unsigned __int8 *)&a10[v64];
      uint64_t v67 = (int8x16_t *)a10;
      do
        BOOL v68 = v67++;
      while (v67 <= (int8x16_t *)v66 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v68)) & 0x80) != 0);
      do
      {
        unint64_t v69 = v68;
        BOOL v68 = (int8x16_t *)((char *)v68 + 4);
      }
      while (v68 <= (int8x16_t *)v66 && !v69->i32[0]);
      if (v69 < (int8x16_t *)v66)
      {
        while (!v69->i8[0])
        {
          unint64_t v69 = (int8x16_t *)((char *)v69 + 1);
          if (v69 >= (int8x16_t *)v66)
          {
            unint64_t v69 = (int8x16_t *)&a10[v64];
            break;
          }
        }
      }
      int64_t v70 = (char *)v69 - a10;
      int64_t v71 = ((char *)v69 - a10) * a14;
      a3 += v71;
      result += v71;
      a10 += v71;
      v64 -= v70;
LABEL_82:
      if (v64 <= 3) {
        goto LABEL_85;
      }
    }
    uint64_t v85 = 0;
    while (1)
    {
      float16x8_t v86 = (int8x16_t *)((char *)result + v85);
      float16x8_t v87 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v85]);
      float16x8_t v88 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v85]);
      v15.i32[0] = v65;
      uint8x16_t v89 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v90 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v89.i8));
      float16x8_t v91 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v89)), v25);
      float16x8_t v92 = vmulq_f16(v90, v25);
      float16x8_t v15 = vmlsq_f16(v91, v91, (float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v85]), (int8x16_t)xmmword_1850CD880));
      *float16x8_t v86 = vrev16q_s8((int8x16_t)vmlsq_f16(v88, v88, vmlsq_f16(v92, v92, (float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v85]), (int8x16_t)xmmword_1850CD880))));
      v86[1] = vrev16q_s8((int8x16_t)vmlsq_f16(v87, v87, v15));
      a10 += v18;
      v64 -= 4;
      if (v64 < 4) {
        break;
      }
      __int32 v65 = *(_DWORD *)a10;
      v85 += v21;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v85);
        a3 = (float16x4_t *)((char *)a3 + v85);
        goto LABEL_82;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v21 + v85);
    a3 = (float16x4_t *)((char *)a3 + v21 + v85);
LABEL_85:
    for (unint64_t j = a12 - v63 + v64; j; --j)
    {
      if (*a10)
      {
        float16x4_t v94 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v95 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v26);
        int *result = (float16x4_t)vrev16_s8((int8x8_t)vmls_f16(v94, v94, vmls_lane_f16(v95, v95, (float16x4_t)vrev16_s8((int8x8_t)*a3), 3)));
      }
      int8x16_t v96 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v96 >= a8) {
        uint64_t v97 = v19;
      }
      else {
        uint64_t v97 = 0;
      }
      a3 = &v96[v97];
      uint64_t result = (float16x4_t *)((char *)result + v22);
    }
    a10 += a11;
    result += a2;
    float16x4_t v98 = &a5[a4];
    if ((unint64_t)v98 >= a9) {
      uint64_t v99 = v20;
    }
    else {
      uint64_t v99 = 0;
    }
    uint8x16_t v100 = &v98[v99];
    uint64_t v101 = a8 + 8 * v99 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v100;
      a8 = v101;
      a5 = v100;
    }
    BOOL v62 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v62 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)4,_rgbaf16_t>(float16x4_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = -1;
  }
  int8x16_t v19 = (int8x16_t)vdupq_n_s16(v18);
  v21.i64[0] = 0xFFFF000000000000;
  v21.i64[1] = 0xFFFF000000000000;
  int8x16_t v22 = vmvnq_s8(vandq_s8(v19, v21));
  int8x16_t v23 = vandq_s8(v19, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v24 = 4 * a14;
  int8x8_t v25 = 0;
  v25.i16[3] = v18;
  int8x8_t v26 = vmvn_s8(v25);
  int8x8_t v27 = vand_s8(*(int8x8_t *)v19.i8, (int8x8_t)0x3C00000000000000);
  uint64_t v28 = -(uint64_t)a7;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 8 * a14;
  v32.i64[0] = -1;
  v32.i64[1] = -1;
  float16x8_t v33 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v34 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a16 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v35 = (a8 - (unint64_t)a3) >> 3;
      if (v35 >= a12) {
        unint64_t v35 = a12;
      }
      unint64_t v36 = v35;
      if (v35 < 4) {
        goto LABEL_39;
      }
      while (1)
      {
        __int32 v37 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          float16x8_t v44 = (unsigned __int8 *)&a10[v36];
          float16x8_t v45 = (int8x16_t *)a10;
          do
            float16x8_t v46 = v45++;
          while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqq_s8(*v46, v32)) & 0x80) != 0);
          do
          {
            uint64_t v47 = v46;
            float16x8_t v46 = (int8x16_t *)((char *)v46 + 4);
          }
          while (v46 <= (int8x16_t *)v44 && v47->i32[0] == -1);
          if (v47 < (int8x16_t *)v44)
          {
            while (v47->u8[0] == 255)
            {
              uint64_t v47 = (int8x16_t *)((char *)v47 + 1);
              if (v47 >= (int8x16_t *)v44)
              {
                uint64_t v47 = (int8x16_t *)&a10[v36];
                break;
              }
            }
          }
          uint64_t v48 = 0;
          int64_t v49 = (char *)v47 - a10;
          unint64_t v50 = (char *)v47 - a10;
          do
          {
            float16x8_t v51 = (float16x8_t *)((char *)result + v48);
            float16x8_t v52 = *(float16x8_t *)&result[2].i8[v48];
            float16x8_t v16 = (float16x8_t)vqtbl1q_s8((int8x16_t)v52, (int8x16_t)xmmword_1850CD880);
            float16x8_t v53 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v48], v22), v23);
            float16x8_t v54 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v48], v22), v23);
            float16x8_t *v51 = vaddq_f16(vsubq_f16(*(float16x8_t *)&result->i8[v48], *(float16x8_t *)&result->i8[v48]), vmlsq_f16(v53, v53, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v48], (int8x16_t)xmmword_1850CD880)));
            v51[1] = vaddq_f16(vsubq_f16(v52, v52), vmlsq_f16(v54, v54, v16));
            a10 += v24;
            v50 -= 4;
            v48 += v30;
          }
          while (v50 > 3);
          a3 = (int8x8_t *)((char *)a3 + v48);
          uint64_t result = (float16x4_t *)((char *)result + v48);
          unint64_t v36 = v36 - v49 + v50;
          goto LABEL_36;
        }
        if (v37) {
          break;
        }
        __int32 v38 = (unsigned __int8 *)&a10[v36];
        int v39 = (int8x16_t *)a10;
        do
          uint64_t v40 = v39++;
        while (v39 <= (int8x16_t *)v38 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v40)) & 0x80) != 0);
        do
        {
          int64_t v41 = v40;
          uint64_t v40 = (int8x16_t *)((char *)v40 + 4);
        }
        while (v40 <= (int8x16_t *)v38 && !v41->i32[0]);
        if (v41 < (int8x16_t *)v38)
        {
          while (!v41->i8[0])
          {
            int64_t v41 = (int8x16_t *)((char *)v41 + 1);
            if (v41 >= (int8x16_t *)v38)
            {
              int64_t v41 = (int8x16_t *)&a10[v36];
              break;
            }
          }
        }
        int64_t v42 = (char *)v41 - a10;
        int64_t v43 = ((char *)v41 - a10) * a14;
        a3 += v43;
        result += v43;
        a10 += v43;
        v36 -= v42;
LABEL_36:
        if (v36 <= 3) {
          goto LABEL_39;
        }
      }
      uint64_t v55 = 0;
      while (1)
      {
        uint8x16_t v56 = (float16x8_t *)((char *)result + v55);
        v16.i32[0] = v37;
        uint8x16_t v57 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v58 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v57.i8));
        float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v57)), v33);
        float16x8_t v59 = vmulq_f16(v58, v33);
        float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v55], v22), v23);
        float16x8_t v61 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v55], v22), v23);
        float16x8_t v62 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result[2].i8[v55], *(float16x8_t *)&result[2].i8[v55], v16), v16, vmlsq_f16(v61, v61, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v55], (int8x16_t)xmmword_1850CD880)));
        float16x8_t *v56 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result->i8[v55], *(float16x8_t *)&result->i8[v55], v59), v59, vmlsq_f16(v60, v60, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v55], (int8x16_t)xmmword_1850CD880)));
        v56[1] = v62;
        a10 += v24;
        v36 -= 4;
        if (v36 < 4) {
          break;
        }
        __int32 v37 = *(_DWORD *)a10;
        v55 += v30;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v55);
          a3 = (int8x8_t *)((char *)a3 + v55);
          goto LABEL_36;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v30 + v55);
      a3 = (int8x8_t *)((char *)a3 + v30 + v55);
LABEL_39:
      for (unint64_t i = a12 - v35 + v36; i; --i)
      {
        if (*a10)
        {
          float16x4_t v64 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v34);
          float16x4_t v65 = (float16x4_t)vorr_s8(vand_s8(*a3, v26), v27);
          int *result = vmla_f16(vmls_f16(*result, *result, v64), v64, vmls_lane_f16(v65, v65, *result, 3));
        }
        uint8x16_t v66 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v66 >= a8) {
          uint64_t v67 = v28;
        }
        else {
          uint64_t v67 = 0;
        }
        a3 = &v66[v67];
        uint64_t result = (float16x4_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      BOOL v68 = &a5[a4];
      if ((unint64_t)v68 >= a9) {
        uint64_t v69 = v29;
      }
      else {
        uint64_t v69 = 0;
      }
      int64_t v70 = &v68[v69];
      uint64_t v71 = a8 + 8 * v69 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v70;
        a8 = v71;
        a5 = v70;
      }
      BOOL v72 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v72 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v73 = (a8 - (unint64_t)a3) >> 3;
    if (v73 >= a12) {
      unint64_t v73 = a12;
    }
    unint64_t v74 = v73;
    if (v73 < 4) {
      goto LABEL_88;
    }
    while (1)
    {
      __int32 v75 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        float16x8_t v82 = (unsigned __int8 *)&a10[v74];
        float16x8_t v83 = (int8x16_t *)a10;
        do
          int8x16_t v84 = v83++;
        while (v83 <= (int8x16_t *)v82 && (vminvq_u8((uint8x16_t)vceqq_s8(*v84, v32)) & 0x80) != 0);
        do
        {
          uint64_t v85 = v84;
          int8x16_t v84 = (int8x16_t *)((char *)v84 + 4);
        }
        while (v84 <= (int8x16_t *)v82 && v85->i32[0] == -1);
        if (v85 < (int8x16_t *)v82)
        {
          while (v85->u8[0] == 255)
          {
            uint64_t v85 = (int8x16_t *)((char *)v85 + 1);
            if (v85 >= (int8x16_t *)v82)
            {
              uint64_t v85 = (int8x16_t *)&a10[v74];
              break;
            }
          }
        }
        uint64_t v86 = 0;
        int64_t v87 = (char *)v85 - a10;
        unint64_t v88 = (char *)v85 - a10;
        do
        {
          uint8x16_t v89 = (int8x16_t *)((char *)result + v86);
          float16x8_t v90 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v86]);
          float16x8_t v91 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v86]);
          float16x8_t v16 = (float16x8_t)vqtbl1q_s8((int8x16_t)v91, (int8x16_t)xmmword_1850CD880);
          float16x8_t v92 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v86]), v22), v23);
          float16x8_t v93 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v86]), v22), v23);
          *uint8x16_t v89 = vrev16q_s8((int8x16_t)vaddq_f16(vsubq_f16(v90, v90), vmlsq_f16(v92, v92, (float16x8_t)vqtbl1q_s8((int8x16_t)v90, (int8x16_t)xmmword_1850CD880))));
          v89[1] = vrev16q_s8((int8x16_t)vaddq_f16(vsubq_f16(v91, v91), vmlsq_f16(v93, v93, v16)));
          a10 += v24;
          v88 -= 4;
          v86 += v30;
        }
        while (v88 > 3);
        a3 = (int8x8_t *)((char *)a3 + v86);
        uint64_t result = (float16x4_t *)((char *)result + v86);
        unint64_t v74 = v74 - v87 + v88;
        goto LABEL_85;
      }
      if (v75) {
        break;
      }
      uint64_t v76 = (unsigned __int8 *)&a10[v74];
      int64_t v77 = (int8x16_t *)a10;
      do
        unint64_t v78 = v77++;
      while (v77 <= (int8x16_t *)v76 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v78)) & 0x80) != 0);
      do
      {
        int8x8_t v79 = v78;
        unint64_t v78 = (int8x16_t *)((char *)v78 + 4);
      }
      while (v78 <= (int8x16_t *)v76 && !v79->i32[0]);
      if (v79 < (int8x16_t *)v76)
      {
        while (!v79->i8[0])
        {
          int8x8_t v79 = (int8x16_t *)((char *)v79 + 1);
          if (v79 >= (int8x16_t *)v76)
          {
            int8x8_t v79 = (int8x16_t *)&a10[v74];
            break;
          }
        }
      }
      int64_t v80 = (char *)v79 - a10;
      int64_t v81 = ((char *)v79 - a10) * a14;
      a3 += v81;
      result += v81;
      a10 += v81;
      v74 -= v80;
LABEL_85:
      if (v74 <= 3) {
        goto LABEL_88;
      }
    }
    uint64_t v94 = 0;
    while (1)
    {
      float16x4_t v95 = (int8x16_t *)((char *)result + v94);
      float16x8_t v96 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v94]);
      float16x8_t v97 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v94]);
      v16.i32[0] = v75;
      uint8x16_t v98 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v99 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v98.i8));
      float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v98)), v33);
      float16x8_t v100 = vmulq_f16(v99, v33);
      float16x8_t v101 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v94]), v22), v23);
      float16x8_t v102 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v94]), v22), v23);
      *float16x4_t v95 = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v96, v96, v100), v100, vmlsq_f16(v101, v101, (float16x8_t)vqtbl1q_s8((int8x16_t)v96, (int8x16_t)xmmword_1850CD880))));
      v95[1] = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v97, v97, v16), v16, vmlsq_f16(v102, v102, (float16x8_t)vqtbl1q_s8((int8x16_t)v97, (int8x16_t)xmmword_1850CD880))));
      a10 += v24;
      v74 -= 4;
      if (v74 < 4) {
        break;
      }
      __int32 v75 = *(_DWORD *)a10;
      v94 += v30;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v94);
        a3 = (int8x8_t *)((char *)a3 + v94);
        goto LABEL_85;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v30 + v94);
    a3 = (int8x8_t *)((char *)a3 + v30 + v94);
LABEL_88:
    for (unint64_t j = a12 - v73 + v74; j; --j)
    {
      if (*a10)
      {
        float16x4_t v104 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v105 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v34);
        float16x4_t v106 = (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v26), v27);
        int *result = (float16x4_t)vrev16_s8((int8x8_t)vmla_f16(vmls_f16(v104, v104, v105), v105, vmls_lane_f16(v106, v106, v104, 3)));
      }
      float16x8_t v107 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v107 >= a8) {
        uint64_t v108 = v28;
      }
      else {
        uint64_t v108 = 0;
      }
      a3 = &v107[v108];
      uint64_t result = (float16x4_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    int8x16_t v109 = &a5[a4];
    if ((unint64_t)v109 >= a9) {
      uint64_t v110 = v29;
    }
    else {
      uint64_t v110 = 0;
    }
    int8x16_t v111 = &v109[v110];
    uint64_t v112 = a8 + 8 * v110 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v111;
      a8 = v112;
      a5 = v111;
    }
    BOOL v72 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v72 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)8,_rgbaf16_t>(float16x4_t *result, uint64_t a2, float16x4_t *a3, uint64_t a4, float16x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v18 = 4 * a14;
  uint64_t v19 = -(uint64_t)a7;
  uint64_t v20 = -(a6 * a4);
  uint64_t v21 = 32 * a14;
  uint64_t v22 = 8 * a14;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  float16x8_t v24 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v25 = (float16x4_t)vdup_n_s16(0x9C04u);
  if ((a15 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v26 = (a8 - (unint64_t)a3) >> 3;
      if (v26 >= a12) {
        unint64_t v26 = a12;
      }
      unint64_t v27 = v26;
      if (v26 < 4) {
        goto LABEL_36;
      }
      while (1)
      {
        __int32 v28 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          unint64_t v35 = (unsigned __int8 *)&a10[v27];
          unint64_t v36 = (int8x16_t *)a10;
          do
            __int32 v37 = v36++;
          while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, v23)) & 0x80) != 0);
          do
          {
            __int32 v38 = v37;
            __int32 v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
          if (v38 < (int8x16_t *)v35)
          {
            while (v38->u8[0] == 255)
            {
              __int32 v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= (int8x16_t *)v35)
              {
                __int32 v38 = (int8x16_t *)&a10[v27];
                break;
              }
            }
          }
          uint64_t v39 = 0;
          int64_t v40 = (char *)v38 - a10;
          unint64_t v41 = (char *)v38 - a10;
          do
          {
            int64_t v42 = (float16x8_t *)((char *)result + v39);
            float16x8_t v43 = vmlsq_f16(*(float16x8_t *)&result[2].i8[v39], *(float16x8_t *)&result[2].i8[v39], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3[2].i8[v39], (int8x16_t)xmmword_1850CD880));
            float16x8_t *v42 = vmlsq_f16(*(float16x8_t *)&result->i8[v39], *(float16x8_t *)&result->i8[v39], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v39], (int8x16_t)xmmword_1850CD880));
            v42[1] = v43;
            a10 += v18;
            v41 -= 4;
            v39 += v21;
          }
          while (v41 > 3);
          a3 = (float16x4_t *)((char *)a3 + v39);
          uint64_t result = (float16x4_t *)((char *)result + v39);
          unint64_t v27 = v27 - v40 + v41;
          goto LABEL_33;
        }
        if (v28) {
          break;
        }
        uint64_t v29 = (unsigned __int8 *)&a10[v27];
        uint64_t v30 = (int8x16_t *)a10;
        do
          uint64_t v31 = v30++;
        while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
        do
        {
          int8x16_t v32 = v31;
          uint64_t v31 = (int8x16_t *)((char *)v31 + 4);
        }
        while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
        if (v32 < (int8x16_t *)v29)
        {
          while (!v32->i8[0])
          {
            int8x16_t v32 = (int8x16_t *)((char *)v32 + 1);
            if (v32 >= (int8x16_t *)v29)
            {
              int8x16_t v32 = (int8x16_t *)&a10[v27];
              break;
            }
          }
        }
        int64_t v33 = (char *)v32 - a10;
        int64_t v34 = ((char *)v32 - a10) * a14;
        a3 += v34;
        result += v34;
        a10 += v34;
        v27 -= v33;
LABEL_33:
        if (v27 <= 3) {
          goto LABEL_36;
        }
      }
      uint64_t v44 = 0;
      while (1)
      {
        float16x8_t v45 = (float16x8_t *)((char *)result + v44);
        v15.i32[0] = v28;
        uint8x16_t v46 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v47 = vcvtq_f16_u16(vmovl_high_u8(v46));
        float16x8_t v15 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v46.i8)), v24);
        float16x8_t v48 = vmlsq_f16(*(float16x8_t *)&result[2].i8[v44], *(float16x8_t *)&result[2].i8[v44], vmulq_f16((float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3[2].i8[v44], (int8x16_t)xmmword_1850CD880), vmulq_f16(v47, v24)));
        float16x8_t *v45 = vmlsq_f16(*(float16x8_t *)&result->i8[v44], *(float16x8_t *)&result->i8[v44], vmulq_f16((float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v44], (int8x16_t)xmmword_1850CD880), v15));
        v45[1] = v48;
        a10 += v18;
        v27 -= 4;
        if (v27 < 4) {
          break;
        }
        __int32 v28 = *(_DWORD *)a10;
        v44 += v21;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v44);
          a3 = (float16x4_t *)((char *)a3 + v44);
          goto LABEL_33;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v21 + v44);
      a3 = (float16x4_t *)((char *)a3 + v21 + v44);
LABEL_36:
      for (unint64_t i = a12 - v26 + v27; i; --i)
      {
        if (*a10) {
          int *result = vmla_f16(*result, vmul_lane_f16(vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25), *a3, 3), *result);
        }
        unint64_t v50 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v50 >= a8) {
          uint64_t v51 = v19;
        }
        else {
          uint64_t v51 = 0;
        }
        a3 = &v50[v51];
        uint64_t result = (float16x4_t *)((char *)result + v22);
      }
      a10 += a11;
      result += a2;
      float16x8_t v52 = &a5[a4];
      if ((unint64_t)v52 >= a9) {
        uint64_t v53 = v20;
      }
      else {
        uint64_t v53 = 0;
      }
      float16x8_t v54 = &v52[v53];
      uint64_t v55 = a8 + 8 * v53 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v54;
        a8 = v55;
        a5 = v54;
      }
      BOOL v56 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v56 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v57 = (a8 - (unint64_t)a3) >> 3;
    if (v57 >= a12) {
      unint64_t v57 = a12;
    }
    unint64_t v58 = v57;
    if (v57 < 4) {
      goto LABEL_85;
    }
    while (1)
    {
      __int32 v59 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        uint8x16_t v66 = (unsigned __int8 *)&a10[v58];
        uint64_t v67 = (int8x16_t *)a10;
        do
          BOOL v68 = v67++;
        while (v67 <= (int8x16_t *)v66 && (vminvq_u8((uint8x16_t)vceqq_s8(*v68, v23)) & 0x80) != 0);
        do
        {
          uint64_t v69 = v68;
          BOOL v68 = (int8x16_t *)((char *)v68 + 4);
        }
        while (v68 <= (int8x16_t *)v66 && v69->i32[0] == -1);
        if (v69 < (int8x16_t *)v66)
        {
          while (v69->u8[0] == 255)
          {
            uint64_t v69 = (int8x16_t *)((char *)v69 + 1);
            if (v69 >= (int8x16_t *)v66)
            {
              uint64_t v69 = (int8x16_t *)&a10[v58];
              break;
            }
          }
        }
        uint64_t v70 = 0;
        int64_t v71 = (char *)v69 - a10;
        unint64_t v72 = (char *)v69 - a10;
        do
        {
          unint64_t v73 = (int8x16_t *)((char *)result + v70);
          float16x8_t v74 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v70]);
          float16x8_t v75 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v70]);
          int8x16_t v76 = vrev16q_s8((int8x16_t)vmlsq_f16(v74, v74, (float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v70]), (int8x16_t)xmmword_1850CD880)));
          *unint64_t v73 = vrev16q_s8((int8x16_t)vmlsq_f16(v75, v75, (float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v70]), (int8x16_t)xmmword_1850CD880)));
          v73[1] = v76;
          a10 += v18;
          v72 -= 4;
          v70 += v21;
        }
        while (v72 > 3);
        a3 = (float16x4_t *)((char *)a3 + v70);
        uint64_t result = (float16x4_t *)((char *)result + v70);
        unint64_t v58 = v58 - v71 + v72;
        goto LABEL_82;
      }
      if (v59) {
        break;
      }
      float16x8_t v60 = (unsigned __int8 *)&a10[v58];
      float16x8_t v61 = (int8x16_t *)a10;
      do
        float16x8_t v62 = v61++;
      while (v61 <= (int8x16_t *)v60 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v62)) & 0x80) != 0);
      do
      {
        unint64_t v63 = v62;
        float16x8_t v62 = (int8x16_t *)((char *)v62 + 4);
      }
      while (v62 <= (int8x16_t *)v60 && !v63->i32[0]);
      if (v63 < (int8x16_t *)v60)
      {
        while (!v63->i8[0])
        {
          unint64_t v63 = (int8x16_t *)((char *)v63 + 1);
          if (v63 >= (int8x16_t *)v60)
          {
            unint64_t v63 = (int8x16_t *)&a10[v58];
            break;
          }
        }
      }
      int64_t v64 = (char *)v63 - a10;
      int64_t v65 = ((char *)v63 - a10) * a14;
      a3 += v65;
      result += v65;
      a10 += v65;
      v58 -= v64;
LABEL_82:
      if (v58 <= 3) {
        goto LABEL_85;
      }
    }
    uint64_t v77 = 0;
    while (1)
    {
      unint64_t v78 = (int8x16_t *)((char *)result + v77);
      float16x8_t v79 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v77]);
      float16x8_t v80 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v77]);
      v15.i32[0] = v59;
      uint8x16_t v81 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v82 = vcvtq_f16_u16(vmovl_high_u8(v81));
      float16x8_t v15 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v81.i8)), v24);
      int8x16_t v83 = vrev16q_s8((int8x16_t)vmlsq_f16(v79, v79, vmulq_f16((float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v77]), (int8x16_t)xmmword_1850CD880), vmulq_f16(v82, v24))));
      *unint64_t v78 = vrev16q_s8((int8x16_t)vmlsq_f16(v80, v80, vmulq_f16((float16x8_t)vqtbl1q_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v77]), (int8x16_t)xmmword_1850CD880), v15)));
      v78[1] = v83;
      a10 += v18;
      v58 -= 4;
      if (v58 < 4) {
        break;
      }
      __int32 v59 = *(_DWORD *)a10;
      v77 += v21;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v77);
        a3 = (float16x4_t *)((char *)a3 + v77);
        goto LABEL_82;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v21 + v77);
    a3 = (float16x4_t *)((char *)a3 + v21 + v77);
LABEL_85:
    for (unint64_t j = a12 - v57 + v58; j; --j)
    {
      if (*a10)
      {
        float16x4_t v85 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        int *result = (float16x4_t)vrev16_s8((int8x8_t)vmla_f16(v85, vmul_lane_f16(vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25), (float16x4_t)vrev16_s8((int8x8_t)*a3), 3), v85));
      }
      uint64_t v86 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v86 >= a8) {
        uint64_t v87 = v19;
      }
      else {
        uint64_t v87 = 0;
      }
      a3 = &v86[v87];
      uint64_t result = (float16x4_t *)((char *)result + v22);
    }
    a10 += a11;
    result += a2;
    unint64_t v88 = &a5[a4];
    if ((unint64_t)v88 >= a9) {
      uint64_t v89 = v20;
    }
    else {
      uint64_t v89 = 0;
    }
    float16x8_t v90 = &v88[v89];
    uint64_t v91 = a8 + 8 * v89 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v90;
      a8 = v91;
      a5 = v90;
    }
    BOOL v56 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v56 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)5,_rgbaf16_t>(float16x4_t *result, uint64_t a2, float16x4_t *a3, uint64_t a4, float16x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v18 = 4 * a14;
  uint64_t v19 = -(uint64_t)a7;
  uint64_t v20 = -(a6 * a4);
  uint64_t v21 = 32 * a14;
  uint64_t v22 = 8 * a14;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  float16x8_t v24 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v25 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a15 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v26 = (a8 - (unint64_t)a3) >> 3;
      if (v26 >= a12) {
        unint64_t v26 = a12;
      }
      unint64_t v27 = v26;
      if (v26 < 4) {
        goto LABEL_36;
      }
      while (1)
      {
        __int32 v28 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          unint64_t v35 = (unsigned __int8 *)&a10[v27];
          unint64_t v36 = (int8x16_t *)a10;
          do
            __int32 v37 = v36++;
          while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, v23)) & 0x80) != 0);
          do
          {
            __int32 v38 = v37;
            __int32 v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
          if (v38 < (int8x16_t *)v35)
          {
            while (v38->u8[0] == 255)
            {
              __int32 v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= (int8x16_t *)v35)
              {
                __int32 v38 = (int8x16_t *)&a10[v27];
                break;
              }
            }
          }
          uint64_t v39 = 0;
          int64_t v40 = (char *)v38 - a10;
          unint64_t v41 = (char *)v38 - a10;
          do
          {
            int64_t v42 = (float16x8_t *)((char *)result + v39);
            float16x8_t v43 = *(float16x8_t *)&a3[2].i8[v39];
            float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v43, (int8x16_t)xmmword_1850CD880);
            float16x8_t v44 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result[2].i8[v39], *(float16x8_t *)&result[2].i8[v39], v15), (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v39], (int8x16_t)xmmword_1850CD880), v43);
            float16x8_t *v42 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result->i8[v39], *(float16x8_t *)&result->i8[v39], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v39], (int8x16_t)xmmword_1850CD880)), (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v39], (int8x16_t)xmmword_1850CD880), *(float16x8_t *)&a3->i8[v39]);
            v42[1] = v44;
            a10 += v18;
            v41 -= 4;
            v39 += v21;
          }
          while (v41 > 3);
          a3 = (float16x4_t *)((char *)a3 + v39);
          uint64_t result = (float16x4_t *)((char *)result + v39);
          unint64_t v27 = v27 - v40 + v41;
          goto LABEL_33;
        }
        if (v28) {
          break;
        }
        uint64_t v29 = (unsigned __int8 *)&a10[v27];
        uint64_t v30 = (int8x16_t *)a10;
        do
          uint64_t v31 = v30++;
        while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
        do
        {
          int8x16_t v32 = v31;
          uint64_t v31 = (int8x16_t *)((char *)v31 + 4);
        }
        while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
        if (v32 < (int8x16_t *)v29)
        {
          while (!v32->i8[0])
          {
            int8x16_t v32 = (int8x16_t *)((char *)v32 + 1);
            if (v32 >= (int8x16_t *)v29)
            {
              int8x16_t v32 = (int8x16_t *)&a10[v27];
              break;
            }
          }
        }
        int64_t v33 = (char *)v32 - a10;
        int64_t v34 = ((char *)v32 - a10) * a14;
        a3 += v34;
        result += v34;
        a10 += v34;
        v27 -= v33;
LABEL_33:
        if (v27 <= 3) {
          goto LABEL_36;
        }
      }
      uint64_t v45 = 0;
      while (1)
      {
        uint8x16_t v46 = (float16x8_t *)((char *)result + v45);
        v15.i32[0] = v28;
        uint8x16_t v47 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v48 = vmulq_f16(*(float16x8_t *)&a3->i8[v45], vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v47.i8)), v24));
        float16x8_t v49 = vmulq_f16(*(float16x8_t *)&a3[2].i8[v45], vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v47)), v24));
        float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v49, (int8x16_t)xmmword_1850CD880);
        float16x8_t v50 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result[2].i8[v45], *(float16x8_t *)&result[2].i8[v45], v15), (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v45], (int8x16_t)xmmword_1850CD880), v49);
        *uint8x16_t v46 = vmlaq_f16(vmlsq_f16(*(float16x8_t *)&result->i8[v45], *(float16x8_t *)&result->i8[v45], (float16x8_t)vqtbl1q_s8((int8x16_t)v48, (int8x16_t)xmmword_1850CD880)), (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v45], (int8x16_t)xmmword_1850CD880), v48);
        v46[1] = v50;
        a10 += v18;
        v27 -= 4;
        if (v27 < 4) {
          break;
        }
        __int32 v28 = *(_DWORD *)a10;
        v45 += v21;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v45);
          a3 = (float16x4_t *)((char *)a3 + v45);
          goto LABEL_33;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v21 + v45);
      a3 = (float16x4_t *)((char *)a3 + v21 + v45);
LABEL_36:
      for (unint64_t i = a12 - v26 + v27; i; --i)
      {
        if (*a10)
        {
          float16x4_t v52 = vmul_f16(vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25), *a3);
          int *result = vmla_lane_f16(vmls_lane_f16(*result, *result, v52, 3), v52, *result, 3);
        }
        uint64_t v53 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v53 >= a8) {
          uint64_t v54 = v19;
        }
        else {
          uint64_t v54 = 0;
        }
        a3 = &v53[v54];
        uint64_t result = (float16x4_t *)((char *)result + v22);
      }
      a10 += a11;
      result += a2;
      uint64_t v55 = &a5[a4];
      if ((unint64_t)v55 >= a9) {
        uint64_t v56 = v20;
      }
      else {
        uint64_t v56 = 0;
      }
      unint64_t v57 = &v55[v56];
      uint64_t v58 = a8 + 8 * v56 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v57;
        a8 = v58;
        a5 = v57;
      }
      BOOL v59 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v59 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v60 = (a8 - (unint64_t)a3) >> 3;
    if (v60 >= a12) {
      unint64_t v60 = a12;
    }
    unint64_t v61 = v60;
    if (v60 < 4) {
      goto LABEL_85;
    }
    while (1)
    {
      __int32 v62 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        uint64_t v69 = (unsigned __int8 *)&a10[v61];
        uint64_t v70 = (int8x16_t *)a10;
        do
          int64_t v71 = v70++;
        while (v70 <= (int8x16_t *)v69 && (vminvq_u8((uint8x16_t)vceqq_s8(*v71, v23)) & 0x80) != 0);
        do
        {
          unint64_t v72 = v71;
          int64_t v71 = (int8x16_t *)((char *)v71 + 4);
        }
        while (v71 <= (int8x16_t *)v69 && v72->i32[0] == -1);
        if (v72 < (int8x16_t *)v69)
        {
          while (v72->u8[0] == 255)
          {
            unint64_t v72 = (int8x16_t *)((char *)v72 + 1);
            if (v72 >= (int8x16_t *)v69)
            {
              unint64_t v72 = (int8x16_t *)&a10[v61];
              break;
            }
          }
        }
        uint64_t v73 = 0;
        int64_t v74 = (char *)v72 - a10;
        unint64_t v75 = (char *)v72 - a10;
        do
        {
          int8x16_t v76 = (int8x16_t *)((char *)result + v73);
          float16x8_t v77 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v73]);
          float16x8_t v78 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v73]);
          float16x8_t v79 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v73]);
          float16x8_t v80 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v73]);
          float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v78, (int8x16_t)xmmword_1850CD880);
          int8x16_t *v76 = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v79, v79, (float16x8_t)vqtbl1q_s8((int8x16_t)v77, (int8x16_t)xmmword_1850CD880)), (float16x8_t)vqtbl1q_s8((int8x16_t)v79, (int8x16_t)xmmword_1850CD880), v77));
          v76[1] = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v80, v80, v15), (float16x8_t)vqtbl1q_s8((int8x16_t)v80, (int8x16_t)xmmword_1850CD880), v78));
          a10 += v18;
          v75 -= 4;
          v73 += v21;
        }
        while (v75 > 3);
        a3 = (float16x4_t *)((char *)a3 + v73);
        uint64_t result = (float16x4_t *)((char *)result + v73);
        unint64_t v61 = v61 - v74 + v75;
        goto LABEL_82;
      }
      if (v62) {
        break;
      }
      unint64_t v63 = (unsigned __int8 *)&a10[v61];
      int64_t v64 = (int8x16_t *)a10;
      do
        int64_t v65 = v64++;
      while (v64 <= (int8x16_t *)v63 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v65)) & 0x80) != 0);
      do
      {
        uint8x16_t v66 = v65;
        int64_t v65 = (int8x16_t *)((char *)v65 + 4);
      }
      while (v65 <= (int8x16_t *)v63 && !v66->i32[0]);
      if (v66 < (int8x16_t *)v63)
      {
        while (!v66->i8[0])
        {
          uint8x16_t v66 = (int8x16_t *)((char *)v66 + 1);
          if (v66 >= (int8x16_t *)v63)
          {
            uint8x16_t v66 = (int8x16_t *)&a10[v61];
            break;
          }
        }
      }
      int64_t v67 = (char *)v66 - a10;
      int64_t v68 = ((char *)v66 - a10) * a14;
      a3 += v68;
      result += v68;
      a10 += v68;
      v61 -= v67;
LABEL_82:
      if (v61 <= 3) {
        goto LABEL_85;
      }
    }
    uint64_t v81 = 0;
    while (1)
    {
      float16x8_t v82 = (int8x16_t *)((char *)result + v81);
      float16x8_t v83 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v81]);
      float16x8_t v84 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v81]);
      v15.i32[0] = v62;
      uint8x16_t v85 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v86 = vmulq_f16(vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v85.i8)), v24), (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v81]));
      float16x8_t v87 = vmulq_f16(vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v85)), v24), (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v81]));
      float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v87, (int8x16_t)xmmword_1850CD880);
      int8x16_t *v82 = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v84, v84, (float16x8_t)vqtbl1q_s8((int8x16_t)v86, (int8x16_t)xmmword_1850CD880)), (float16x8_t)vqtbl1q_s8((int8x16_t)v84, (int8x16_t)xmmword_1850CD880), v86));
      v82[1] = vrev16q_s8((int8x16_t)vmlaq_f16(vmlsq_f16(v83, v83, v15), (float16x8_t)vqtbl1q_s8((int8x16_t)v83, (int8x16_t)xmmword_1850CD880), v87));
      a10 += v18;
      v61 -= 4;
      if (v61 < 4) {
        break;
      }
      __int32 v62 = *(_DWORD *)a10;
      v81 += v21;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v81);
        a3 = (float16x4_t *)((char *)a3 + v81);
        goto LABEL_82;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v21 + v81);
    a3 = (float16x4_t *)((char *)a3 + v21 + v81);
LABEL_85:
    for (unint64_t j = a12 - v60 + v61; j; --j)
    {
      if (*a10)
      {
        float16x4_t v89 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v90 = vmul_f16(vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25), (float16x4_t)vrev16_s8((int8x8_t)*a3));
        int *result = (float16x4_t)vrev16_s8((int8x8_t)vmla_lane_f16(vmls_lane_f16(v89, v89, v90, 3), v90, v89, 3));
      }
      uint64_t v91 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v91 >= a8) {
        uint64_t v92 = v19;
      }
      else {
        uint64_t v92 = 0;
      }
      a3 = &v91[v92];
      uint64_t result = (float16x4_t *)((char *)result + v22);
    }
    a10 += a11;
    result += a2;
    float16x8_t v93 = &a5[a4];
    if ((unint64_t)v93 >= a9) {
      uint64_t v94 = v20;
    }
    else {
      uint64_t v94 = 0;
    }
    float16x4_t v95 = &v93[v94];
    uint64_t v96 = a8 + 8 * v94 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v95;
      a8 = v96;
      a5 = v95;
    }
    BOOL v59 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v59 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)9,_rgbaf16_t>(float16x4_t *result, uint64_t a2, float16x4_t *a3, uint64_t a4, float16x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v18 = 4 * a14;
  uint64_t v19 = -(uint64_t)a7;
  uint64_t v20 = -(a6 * a4);
  uint64_t v21 = 32 * a14;
  uint64_t v22 = 8 * a14;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  float16x8_t v24 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v25 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a15 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v26 = (a8 - (unint64_t)a3) >> 3;
      if (v26 >= a12) {
        unint64_t v26 = a12;
      }
      unint64_t v27 = v26;
      if (v26 < 4) {
        goto LABEL_36;
      }
      while (1)
      {
        __int32 v28 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          unint64_t v35 = (unsigned __int8 *)&a10[v27];
          unint64_t v36 = (int8x16_t *)a10;
          do
            __int32 v37 = v36++;
          while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, v23)) & 0x80) != 0);
          do
          {
            __int32 v38 = v37;
            __int32 v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
          if (v38 < (int8x16_t *)v35)
          {
            while (v38->u8[0] == 255)
            {
              __int32 v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= (int8x16_t *)v35)
              {
                __int32 v38 = (int8x16_t *)&a10[v27];
                break;
              }
            }
          }
          uint64_t v39 = 0;
          int64_t v40 = (char *)v38 - a10;
          unint64_t v41 = (char *)v38 - a10;
          do
          {
            int64_t v42 = (float16x8_t *)((char *)result + v39);
            float16x8_t v43 = *(float16x8_t *)&a3[2].i8[v39];
            float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v43, (int8x16_t)xmmword_1850CD880);
            float16x8_t v44 = vaddq_f16(*(float16x8_t *)&result[2].i8[v39], vsubq_f16(vmlsq_f16(v43, v43, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v39], (int8x16_t)xmmword_1850CD880)), vmlsq_f16(*(float16x8_t *)&result[2].i8[v39], *(float16x8_t *)&result[2].i8[v39], v15)));
            float16x8_t *v42 = vaddq_f16(*(float16x8_t *)&result->i8[v39], vsubq_f16(vmlsq_f16(*(float16x8_t *)&a3->i8[v39], *(float16x8_t *)&a3->i8[v39], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v39], (int8x16_t)xmmword_1850CD880)), vmlsq_f16(*(float16x8_t *)&result->i8[v39], *(float16x8_t *)&result->i8[v39], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v39], (int8x16_t)xmmword_1850CD880))));
            v42[1] = v44;
            a10 += v18;
            v41 -= 4;
            v39 += v21;
          }
          while (v41 > 3);
          a3 = (float16x4_t *)((char *)a3 + v39);
          uint64_t result = (float16x4_t *)((char *)result + v39);
          unint64_t v27 = v27 - v40 + v41;
          goto LABEL_33;
        }
        if (v28) {
          break;
        }
        uint64_t v29 = (unsigned __int8 *)&a10[v27];
        uint64_t v30 = (int8x16_t *)a10;
        do
          uint64_t v31 = v30++;
        while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
        do
        {
          int8x16_t v32 = v31;
          uint64_t v31 = (int8x16_t *)((char *)v31 + 4);
        }
        while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
        if (v32 < (int8x16_t *)v29)
        {
          while (!v32->i8[0])
          {
            int8x16_t v32 = (int8x16_t *)((char *)v32 + 1);
            if (v32 >= (int8x16_t *)v29)
            {
              int8x16_t v32 = (int8x16_t *)&a10[v27];
              break;
            }
          }
        }
        int64_t v33 = (char *)v32 - a10;
        int64_t v34 = ((char *)v32 - a10) * a14;
        a3 += v34;
        result += v34;
        a10 += v34;
        v27 -= v33;
LABEL_33:
        if (v27 <= 3) {
          goto LABEL_36;
        }
      }
      uint64_t v45 = 0;
      while (1)
      {
        uint8x16_t v46 = (float16x8_t *)((char *)result + v45);
        v15.i32[0] = v28;
        uint8x16_t v47 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v48 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v47.i8));
        float16x8_t v15 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v47)), v24);
        float16x8_t v49 = vmlaq_f16(*(float16x8_t *)&result[2].i8[v45], vsubq_f16(vmlsq_f16(*(float16x8_t *)&a3[2].i8[v45], *(float16x8_t *)&a3[2].i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v45], (int8x16_t)xmmword_1850CD880)), vmlsq_f16(*(float16x8_t *)&result[2].i8[v45], *(float16x8_t *)&result[2].i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3[2].i8[v45], (int8x16_t)xmmword_1850CD880))), v15);
        *uint8x16_t v46 = vmlaq_f16(*(float16x8_t *)&result->i8[v45], vsubq_f16(vmlsq_f16(*(float16x8_t *)&a3->i8[v45], *(float16x8_t *)&a3->i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v45], (int8x16_t)xmmword_1850CD880)), vmlsq_f16(*(float16x8_t *)&result->i8[v45], *(float16x8_t *)&result->i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v45], (int8x16_t)xmmword_1850CD880))), vmulq_f16(v48, v24));
        v46[1] = v49;
        a10 += v18;
        v27 -= 4;
        if (v27 < 4) {
          break;
        }
        __int32 v28 = *(_DWORD *)a10;
        v45 += v21;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v45);
          a3 = (float16x4_t *)((char *)a3 + v45);
          goto LABEL_33;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v21 + v45);
      a3 = (float16x4_t *)((char *)a3 + v21 + v45);
LABEL_36:
      for (unint64_t i = a12 - v26 + v27; i; --i)
      {
        if (*a10) {
          int *result = vmla_f16(*result, vsub_f16(vmls_lane_f16(*a3, *a3, *result, 3), vmls_lane_f16(*result, *result, *a3, 3)), vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25));
        }
        uint64_t v51 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v51 >= a8) {
          uint64_t v52 = v19;
        }
        else {
          uint64_t v52 = 0;
        }
        a3 = &v51[v52];
        uint64_t result = (float16x4_t *)((char *)result + v22);
      }
      a10 += a11;
      result += a2;
      uint64_t v53 = &a5[a4];
      if ((unint64_t)v53 >= a9) {
        uint64_t v54 = v20;
      }
      else {
        uint64_t v54 = 0;
      }
      uint64_t v55 = &v53[v54];
      uint64_t v56 = a8 + 8 * v54 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v55;
        a8 = v56;
        a5 = v55;
      }
      BOOL v57 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v57 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v58 = (a8 - (unint64_t)a3) >> 3;
    if (v58 >= a12) {
      unint64_t v58 = a12;
    }
    unint64_t v59 = v58;
    if (v58 < 4) {
      goto LABEL_85;
    }
    while (1)
    {
      __int32 v60 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        int64_t v67 = (unsigned __int8 *)&a10[v59];
        int64_t v68 = (int8x16_t *)a10;
        do
          uint64_t v69 = v68++;
        while (v68 <= (int8x16_t *)v67 && (vminvq_u8((uint8x16_t)vceqq_s8(*v69, v23)) & 0x80) != 0);
        do
        {
          uint64_t v70 = v69;
          uint64_t v69 = (int8x16_t *)((char *)v69 + 4);
        }
        while (v69 <= (int8x16_t *)v67 && v70->i32[0] == -1);
        if (v70 < (int8x16_t *)v67)
        {
          while (v70->u8[0] == 255)
          {
            uint64_t v70 = (int8x16_t *)((char *)v70 + 1);
            if (v70 >= (int8x16_t *)v67)
            {
              uint64_t v70 = (int8x16_t *)&a10[v59];
              break;
            }
          }
        }
        uint64_t v71 = 0;
        int64_t v72 = (char *)v70 - a10;
        unint64_t v73 = (char *)v70 - a10;
        do
        {
          int64_t v74 = (int8x16_t *)((char *)result + v71);
          float16x8_t v75 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v71]);
          float16x8_t v76 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v71]);
          float16x8_t v77 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v71]);
          float16x8_t v78 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v71]);
          float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v76, (int8x16_t)xmmword_1850CD880);
          *int64_t v74 = vrev16q_s8((int8x16_t)vaddq_f16(vsubq_f16(vmlsq_f16(v75, v75, (float16x8_t)vqtbl1q_s8((int8x16_t)v77, (int8x16_t)xmmword_1850CD880)), vmlsq_f16(v77, v77, (float16x8_t)vqtbl1q_s8((int8x16_t)v75, (int8x16_t)xmmword_1850CD880))), v77));
          v74[1] = vrev16q_s8((int8x16_t)vaddq_f16(vsubq_f16(vmlsq_f16(v76, v76, (float16x8_t)vqtbl1q_s8((int8x16_t)v78, (int8x16_t)xmmword_1850CD880)), vmlsq_f16(v78, v78, v15)), v78));
          a10 += v18;
          v73 -= 4;
          v71 += v21;
        }
        while (v73 > 3);
        a3 = (float16x4_t *)((char *)a3 + v71);
        uint64_t result = (float16x4_t *)((char *)result + v71);
        unint64_t v59 = v59 - v72 + v73;
        goto LABEL_82;
      }
      if (v60) {
        break;
      }
      unint64_t v61 = (unsigned __int8 *)&a10[v59];
      __int32 v62 = (int8x16_t *)a10;
      do
        unint64_t v63 = v62++;
      while (v62 <= (int8x16_t *)v61 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v63)) & 0x80) != 0);
      do
      {
        int64_t v64 = v63;
        unint64_t v63 = (int8x16_t *)((char *)v63 + 4);
      }
      while (v63 <= (int8x16_t *)v61 && !v64->i32[0]);
      if (v64 < (int8x16_t *)v61)
      {
        while (!v64->i8[0])
        {
          int64_t v64 = (int8x16_t *)((char *)v64 + 1);
          if (v64 >= (int8x16_t *)v61)
          {
            int64_t v64 = (int8x16_t *)&a10[v59];
            break;
          }
        }
      }
      int64_t v65 = (char *)v64 - a10;
      int64_t v66 = ((char *)v64 - a10) * a14;
      a3 += v66;
      result += v66;
      a10 += v66;
      v59 -= v65;
LABEL_82:
      if (v59 <= 3) {
        goto LABEL_85;
      }
    }
    uint64_t v79 = 0;
    while (1)
    {
      float16x8_t v80 = (int8x16_t *)((char *)result + v79);
      float16x8_t v81 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v79]);
      float16x8_t v82 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v79]);
      float16x8_t v83 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v79]);
      float16x8_t v84 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v79]);
      v15.i32[0] = v60;
      uint8x16_t v85 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v86 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v85.i8));
      float16x8_t v15 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v85)), v24);
      *float16x8_t v80 = vrev16q_s8((int8x16_t)vmlaq_f16(v83, vsubq_f16(vmlsq_f16(v81, v81, (float16x8_t)vqtbl1q_s8((int8x16_t)v83, (int8x16_t)xmmword_1850CD880)), vmlsq_f16(v83, v83, (float16x8_t)vqtbl1q_s8((int8x16_t)v81, (int8x16_t)xmmword_1850CD880))), vmulq_f16(v86, v24)));
      v80[1] = vrev16q_s8((int8x16_t)vmlaq_f16(v84, vsubq_f16(vmlsq_f16(v82, v82, (float16x8_t)vqtbl1q_s8((int8x16_t)v84, (int8x16_t)xmmword_1850CD880)), vmlsq_f16(v84, v84, (float16x8_t)vqtbl1q_s8((int8x16_t)v82, (int8x16_t)xmmword_1850CD880))), v15));
      a10 += v18;
      v59 -= 4;
      if (v59 < 4) {
        break;
      }
      __int32 v60 = *(_DWORD *)a10;
      v79 += v21;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v79);
        a3 = (float16x4_t *)((char *)a3 + v79);
        goto LABEL_82;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v21 + v79);
    a3 = (float16x4_t *)((char *)a3 + v21 + v79);
LABEL_85:
    for (unint64_t j = a12 - v58 + v59; j; --j)
    {
      if (*a10)
      {
        float16x4_t v88 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v89 = (float16x4_t)vrev16_s8((int8x8_t)*a3);
        int *result = (float16x4_t)vrev16_s8((int8x8_t)vmla_f16(v88, vsub_f16(vmls_lane_f16(v89, v89, v88, 3), vmls_lane_f16(v88, v88, v89, 3)), vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25)));
      }
      float16x4_t v90 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v90 >= a8) {
        uint64_t v91 = v19;
      }
      else {
        uint64_t v91 = 0;
      }
      a3 = &v90[v91];
      uint64_t result = (float16x4_t *)((char *)result + v22);
    }
    a10 += a11;
    result += a2;
    uint64_t v92 = &a5[a4];
    if ((unint64_t)v92 >= a9) {
      uint64_t v93 = v20;
    }
    else {
      uint64_t v93 = 0;
    }
    uint64_t v94 = &v92[v93];
    uint64_t v95 = a8 + 8 * v93 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v94;
      a8 = v95;
      a5 = v94;
    }
    BOOL v57 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v57 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)10,_rgbaf16_t>(float16x4_t *result, uint64_t a2, float16x4_t *a3, uint64_t a4, float16x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v18 = 4 * a14;
  uint64_t v19 = -(uint64_t)a7;
  uint64_t v20 = -(a6 * a4);
  uint64_t v21 = 32 * a14;
  uint64_t v22 = 8 * a14;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  float16x8_t v24 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v25 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a15 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v26 = (a8 - (unint64_t)a3) >> 3;
      if (v26 >= a12) {
        unint64_t v26 = a12;
      }
      unint64_t v27 = v26;
      if (v26 < 4) {
        goto LABEL_36;
      }
      while (1)
      {
        __int32 v28 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          unint64_t v35 = (unsigned __int8 *)&a10[v27];
          unint64_t v36 = (int8x16_t *)a10;
          do
            __int32 v37 = v36++;
          while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, v23)) & 0x80) != 0);
          do
          {
            __int32 v38 = v37;
            __int32 v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
          if (v38 < (int8x16_t *)v35)
          {
            while (v38->u8[0] == 255)
            {
              __int32 v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= (int8x16_t *)v35)
              {
                __int32 v38 = (int8x16_t *)&a10[v27];
                break;
              }
            }
          }
          uint64_t v39 = 0;
          int64_t v40 = (char *)v38 - a10;
          unint64_t v41 = (char *)v38 - a10;
          do
          {
            int64_t v42 = (float16x8_t *)((char *)result + v39);
            float16x8_t v43 = *(float16x8_t *)&a3[2].i8[v39];
            float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v43, (int8x16_t)xmmword_1850CD880);
            float16x8_t v44 = vaddq_f16(*(float16x8_t *)&result[2].i8[v39], vmlsq_f16(vmlsq_f16(v43, v43, (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v39], (int8x16_t)xmmword_1850CD880)), *(float16x8_t *)&result[2].i8[v39], v15));
            float16x8_t *v42 = vaddq_f16(*(float16x8_t *)&result->i8[v39], vmlsq_f16(vmlsq_f16(*(float16x8_t *)&a3->i8[v39], *(float16x8_t *)&a3->i8[v39], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v39], (int8x16_t)xmmword_1850CD880)), *(float16x8_t *)&result->i8[v39], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v39], (int8x16_t)xmmword_1850CD880)));
            v42[1] = v44;
            a10 += v18;
            v41 -= 4;
            v39 += v21;
          }
          while (v41 > 3);
          a3 = (float16x4_t *)((char *)a3 + v39);
          uint64_t result = (float16x4_t *)((char *)result + v39);
          unint64_t v27 = v27 - v40 + v41;
          goto LABEL_33;
        }
        if (v28) {
          break;
        }
        uint64_t v29 = (unsigned __int8 *)&a10[v27];
        uint64_t v30 = (int8x16_t *)a10;
        do
          uint64_t v31 = v30++;
        while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
        do
        {
          int8x16_t v32 = v31;
          uint64_t v31 = (int8x16_t *)((char *)v31 + 4);
        }
        while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
        if (v32 < (int8x16_t *)v29)
        {
          while (!v32->i8[0])
          {
            int8x16_t v32 = (int8x16_t *)((char *)v32 + 1);
            if (v32 >= (int8x16_t *)v29)
            {
              int8x16_t v32 = (int8x16_t *)&a10[v27];
              break;
            }
          }
        }
        int64_t v33 = (char *)v32 - a10;
        int64_t v34 = ((char *)v32 - a10) * a14;
        a3 += v34;
        result += v34;
        a10 += v34;
        v27 -= v33;
LABEL_33:
        if (v27 <= 3) {
          goto LABEL_36;
        }
      }
      uint64_t v45 = 0;
      while (1)
      {
        uint8x16_t v46 = (float16x8_t *)((char *)result + v45);
        v15.i32[0] = v28;
        uint8x16_t v47 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v48 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v47.i8));
        float16x8_t v15 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v47)), v24);
        float16x8_t v49 = vmlaq_f16(*(float16x8_t *)&result[2].i8[v45], v15, vmlsq_f16(vmlsq_f16(*(float16x8_t *)&a3[2].i8[v45], *(float16x8_t *)&a3[2].i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result[2].i8[v45], (int8x16_t)xmmword_1850CD880)), *(float16x8_t *)&result[2].i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3[2].i8[v45], (int8x16_t)xmmword_1850CD880)));
        *uint8x16_t v46 = vmlaq_f16(*(float16x8_t *)&result->i8[v45], vmulq_f16(v48, v24), vmlsq_f16(vmlsq_f16(*(float16x8_t *)&a3->i8[v45], *(float16x8_t *)&a3->i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&result->i8[v45], (int8x16_t)xmmword_1850CD880)), *(float16x8_t *)&result->i8[v45], (float16x8_t)vqtbl1q_s8(*(int8x16_t *)&a3->i8[v45], (int8x16_t)xmmword_1850CD880)));
        v46[1] = v49;
        a10 += v18;
        v27 -= 4;
        if (v27 < 4) {
          break;
        }
        __int32 v28 = *(_DWORD *)a10;
        v45 += v21;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v45);
          a3 = (float16x4_t *)((char *)a3 + v45);
          goto LABEL_33;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v21 + v45);
      a3 = (float16x4_t *)((char *)a3 + v21 + v45);
LABEL_36:
      for (unint64_t i = a12 - v26 + v27; i; --i)
      {
        if (*a10) {
          int *result = vmla_f16(*result, vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25), vmls_lane_f16(vmls_lane_f16(*a3, *a3, *result, 3), *result, *a3, 3));
        }
        uint64_t v51 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v51 >= a8) {
          uint64_t v52 = v19;
        }
        else {
          uint64_t v52 = 0;
        }
        a3 = &v51[v52];
        uint64_t result = (float16x4_t *)((char *)result + v22);
      }
      a10 += a11;
      result += a2;
      uint64_t v53 = &a5[a4];
      if ((unint64_t)v53 >= a9) {
        uint64_t v54 = v20;
      }
      else {
        uint64_t v54 = 0;
      }
      uint64_t v55 = &v53[v54];
      uint64_t v56 = a8 + 8 * v54 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v55;
        a8 = v56;
        a5 = v55;
      }
      BOOL v57 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v57 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v58 = (a8 - (unint64_t)a3) >> 3;
    if (v58 >= a12) {
      unint64_t v58 = a12;
    }
    unint64_t v59 = v58;
    if (v58 < 4) {
      goto LABEL_85;
    }
    while (1)
    {
      __int32 v60 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        int64_t v67 = (unsigned __int8 *)&a10[v59];
        int64_t v68 = (int8x16_t *)a10;
        do
          uint64_t v69 = v68++;
        while (v68 <= (int8x16_t *)v67 && (vminvq_u8((uint8x16_t)vceqq_s8(*v69, v23)) & 0x80) != 0);
        do
        {
          uint64_t v70 = v69;
          uint64_t v69 = (int8x16_t *)((char *)v69 + 4);
        }
        while (v69 <= (int8x16_t *)v67 && v70->i32[0] == -1);
        if (v70 < (int8x16_t *)v67)
        {
          while (v70->u8[0] == 255)
          {
            uint64_t v70 = (int8x16_t *)((char *)v70 + 1);
            if (v70 >= (int8x16_t *)v67)
            {
              uint64_t v70 = (int8x16_t *)&a10[v59];
              break;
            }
          }
        }
        uint64_t v71 = 0;
        int64_t v72 = (char *)v70 - a10;
        unint64_t v73 = (char *)v70 - a10;
        do
        {
          int64_t v74 = (int8x16_t *)((char *)result + v71);
          float16x8_t v75 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v71]);
          float16x8_t v76 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v71]);
          float16x8_t v77 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v71]);
          float16x8_t v78 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v71]);
          float16x8_t v15 = (float16x8_t)vqtbl1q_s8((int8x16_t)v76, (int8x16_t)xmmword_1850CD880);
          *int64_t v74 = vrev16q_s8((int8x16_t)vaddq_f16(vmlsq_f16(vmlsq_f16(v75, v75, (float16x8_t)vqtbl1q_s8((int8x16_t)v77, (int8x16_t)xmmword_1850CD880)), v77, (float16x8_t)vqtbl1q_s8((int8x16_t)v75, (int8x16_t)xmmword_1850CD880)), v77));
          v74[1] = vrev16q_s8((int8x16_t)vaddq_f16(vmlsq_f16(vmlsq_f16(v76, v76, (float16x8_t)vqtbl1q_s8((int8x16_t)v78, (int8x16_t)xmmword_1850CD880)), v78, v15), v78));
          a10 += v18;
          v73 -= 4;
          v71 += v21;
        }
        while (v73 > 3);
        a3 = (float16x4_t *)((char *)a3 + v71);
        uint64_t result = (float16x4_t *)((char *)result + v71);
        unint64_t v59 = v59 - v72 + v73;
        goto LABEL_82;
      }
      if (v60) {
        break;
      }
      unint64_t v61 = (unsigned __int8 *)&a10[v59];
      __int32 v62 = (int8x16_t *)a10;
      do
        unint64_t v63 = v62++;
      while (v62 <= (int8x16_t *)v61 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v63)) & 0x80) != 0);
      do
      {
        int64_t v64 = v63;
        unint64_t v63 = (int8x16_t *)((char *)v63 + 4);
      }
      while (v63 <= (int8x16_t *)v61 && !v64->i32[0]);
      if (v64 < (int8x16_t *)v61)
      {
        while (!v64->i8[0])
        {
          int64_t v64 = (int8x16_t *)((char *)v64 + 1);
          if (v64 >= (int8x16_t *)v61)
          {
            int64_t v64 = (int8x16_t *)&a10[v59];
            break;
          }
        }
      }
      int64_t v65 = (char *)v64 - a10;
      int64_t v66 = ((char *)v64 - a10) * a14;
      a3 += v66;
      result += v66;
      a10 += v66;
      v59 -= v65;
LABEL_82:
      if (v59 <= 3) {
        goto LABEL_85;
      }
    }
    uint64_t v79 = 0;
    while (1)
    {
      float16x8_t v80 = (int8x16_t *)((char *)result + v79);
      float16x8_t v81 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3->i8[v79]);
      float16x8_t v82 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&a3[2].i8[v79]);
      float16x8_t v83 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v79]);
      float16x8_t v84 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v79]);
      v15.i32[0] = v60;
      uint8x16_t v85 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v15, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v86 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v85.i8));
      float16x8_t v15 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v85)), v24);
      *float16x8_t v80 = vrev16q_s8((int8x16_t)vmlaq_f16(v83, vmulq_f16(v86, v24), vmlsq_f16(vmlsq_f16(v81, v81, (float16x8_t)vqtbl1q_s8((int8x16_t)v83, (int8x16_t)xmmword_1850CD880)), v83, (float16x8_t)vqtbl1q_s8((int8x16_t)v81, (int8x16_t)xmmword_1850CD880))));
      v80[1] = vrev16q_s8((int8x16_t)vmlaq_f16(v84, v15, vmlsq_f16(vmlsq_f16(v82, v82, (float16x8_t)vqtbl1q_s8((int8x16_t)v84, (int8x16_t)xmmword_1850CD880)), v84, (float16x8_t)vqtbl1q_s8((int8x16_t)v82, (int8x16_t)xmmword_1850CD880))));
      a10 += v18;
      v59 -= 4;
      if (v59 < 4) {
        break;
      }
      __int32 v60 = *(_DWORD *)a10;
      v79 += v21;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v79);
        a3 = (float16x4_t *)((char *)a3 + v79);
        goto LABEL_82;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v21 + v79);
    a3 = (float16x4_t *)((char *)a3 + v21 + v79);
LABEL_85:
    for (unint64_t j = a12 - v58 + v59; j; --j)
    {
      if (*a10)
      {
        float16x4_t v88 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v89 = (float16x4_t)vrev16_s8((int8x8_t)*a3);
        int *result = (float16x4_t)vrev16_s8((int8x8_t)vmla_f16(v88, vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v25), vmls_lane_f16(vmls_lane_f16(v89, v89, v88, 3), v88, v89, 3)));
      }
      float16x4_t v90 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v90 >= a8) {
        uint64_t v91 = v19;
      }
      else {
        uint64_t v91 = 0;
      }
      a3 = &v90[v91];
      uint64_t result = (float16x4_t *)((char *)result + v22);
    }
    a10 += a11;
    result += a2;
    uint64_t v92 = &a5[a4];
    if ((unint64_t)v92 >= a9) {
      uint64_t v93 = v20;
    }
    else {
      uint64_t v93 = 0;
    }
    uint64_t v94 = &v92[v93];
    uint64_t v95 = a8 + 8 * v93 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v94;
      a8 = v95;
      a5 = v94;
    }
    BOOL v57 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v57 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)11,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = (int8x16_t)vdupq_n_s16(v24);
  int8x16_t v26 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  int8x16_t v27 = vandq_s8(v25, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v25, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v24;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = 0x3C003C003C003C00;
  v38.i64[1] = 0x3C003C003C003C00;
  v39.i64[0] = -1;
  v39.i64[1] = -1;
  float16x8_t v40 = (float16x8_t)vdupq_n_s16(0x1C04u);
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 3;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v43 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          float16x8_t v50 = (unsigned __int8 *)&a10[v42];
          uint64_t v51 = (int8x16_t *)a10;
          do
            uint64_t v52 = v51++;
          while (v51 <= (int8x16_t *)v50 && (vminvq_u8((uint8x16_t)vceqq_s8(*v52, v39)) & 0x80) != 0);
          do
          {
            uint64_t v53 = v52;
            uint64_t v52 = (int8x16_t *)((char *)v52 + 4);
          }
          while (v52 <= (int8x16_t *)v50 && v53->i32[0] == -1);
          if (v53 < (int8x16_t *)v50)
          {
            while (v53->u8[0] == 255)
            {
              uint64_t v53 = (int8x16_t *)((char *)v53 + 1);
              if (v53 >= (int8x16_t *)v50)
              {
                uint64_t v53 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          uint64_t v54 = 0;
          int64_t v55 = (char *)v53 - a10;
          unint64_t v56 = (char *)v53 - a10;
          do
          {
            BOOL v57 = (float16x8_t *)((char *)result + v54);
            float16x8_t v58 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v54], v23), v26);
            float16x8_t v59 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v54], v23), v26);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v54], v28), v29);
            float16x8_t v61 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v54], v28), v29);
            float16x8_t v17 = (float16x8_t)vqtbl1q_s8((int8x16_t)v59, (int8x16_t)xmmword_1850CD880);
            float16x8_t v62 = (float16x8_t)vqtbl1q_s8((int8x16_t)v58, (int8x16_t)xmmword_1850CD880);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v61, (int8x16_t)xmmword_1850CD880);
            float16x8_t v64 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float16x8_t *v57 = vsubq_f16(vminnmq_f16(vaddq_f16(v17, v63), v38), vaddq_f16(vsubq_f16(v17, v59), vsubq_f16(v63, v61)));
            v57[1] = vsubq_f16(vminnmq_f16(vaddq_f16(v62, v64), v38), vaddq_f16(vsubq_f16(v62, v58), vsubq_f16(v64, v60)));
            a10 += v30;
            v56 -= 4;
            v54 += v36;
          }
          while (v56 > 3);
          a3 = (int8x8_t *)((char *)a3 + v54);
          uint64_t result = (int8x8_t *)((char *)result + v54);
          unint64_t v42 = v42 - v55 + v56;
          goto LABEL_39;
        }
        if (v43) {
          break;
        }
        float16x8_t v44 = (unsigned __int8 *)&a10[v42];
        uint64_t v45 = (int8x16_t *)a10;
        do
          uint8x16_t v46 = v45++;
        while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
        do
        {
          uint8x16_t v47 = v46;
          uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= (int8x16_t *)v44 && !v47->i32[0]);
        if (v47 < (int8x16_t *)v44)
        {
          while (!v47->i8[0])
          {
            uint8x16_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= (int8x16_t *)v44)
            {
              uint8x16_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        int64_t v48 = (char *)v47 - a10;
        int64_t v49 = ((char *)v47 - a10) * a14;
        a3 += v49;
        result += v49;
        a10 += v49;
        v42 -= v48;
LABEL_39:
        if (v42 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v65 = 0;
      while (1)
      {
        int64_t v66 = (int8x16_t *)((char *)result + v65);
        v17.i32[0] = v43;
        uint8x16_t v67 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v68 = vcvtq_f16_u16(vmovl_high_u8(v67));
        float16x8_t v17 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v67.i8)), v40);
        float16x8_t v69 = vmulq_f16(v68, v40);
        float16x8_t v70 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v65], v23), v26);
        float16x8_t v71 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v65], v23), v26);
        float16x8_t v72 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v69)), (int8x16_t)v38, *(int8x16_t *)&result[2].i8[v65]);
        float16x8_t v73 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v17)), (int8x16_t)v38, *(int8x16_t *)&result->i8[v65]);
        float16x8_t v74 = (float16x8_t)vqtbl1q_s8((int8x16_t)v71, (int8x16_t)xmmword_1850CD880);
        float16x8_t v75 = (float16x8_t)vqtbl1q_s8((int8x16_t)v70, (int8x16_t)xmmword_1850CD880);
        float16x8_t v76 = (float16x8_t)vqtbl1q_s8((int8x16_t)v73, (int8x16_t)xmmword_1850CD880);
        float16x8_t v77 = (float16x8_t)vqtbl1q_s8((int8x16_t)v72, (int8x16_t)xmmword_1850CD880);
        int8x16_t *v66 = vbslq_s8((int8x16_t)vceqzq_f16(v17), (int8x16_t)v73, (int8x16_t)vsubq_f16(vminnmq_f16(vmlaq_f16(v76, v17, v74), v38), vmlaq_f16(vsubq_f16(v76, v73), v17, vsubq_f16(v74, v71))));
        v66[1] = vbslq_s8((int8x16_t)vceqzq_f16(v69), (int8x16_t)v72, (int8x16_t)vsubq_f16(vminnmq_f16(vmlaq_f16(v77, v69, v75), v38), vmlaq_f16(vsubq_f16(v77, v72), v69, vsubq_f16(v75, v70))));
        a10 += v30;
        v42 -= 4;
        if (v42 < 4) {
          break;
        }
        __int32 v43 = *(_DWORD *)a10;
        v65 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v65);
          a3 = (int8x8_t *)((char *)a3 + v65);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v65);
      a3 = (int8x8_t *)((char *)a3 + v36 + v65);
LABEL_42:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float16x4_t v79 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v80 = (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33);
          float16x4_t v81 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v79)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v82 = (float16x4_t)vdup_lane_s16((int16x4_t)v81, 3);
          float16x4_t v83 = vsub_f16(v82, v81);
          *(float16x4_t *)v17.i8 = vmla_lane_f16(v82, v79, v80, 3);
          int *result = vbsl_s8((int8x8_t)vceqz_f16(v79), (int8x8_t)v81, (int8x8_t)vsub_f16(vminnm_f16(*(float16x4_t *)v17.i8, (float16x4_t)0x3C003C003C003C00), vmla_f16(v83, v79, vsub_f16((float16x4_t)vdup_lane_s16((int16x4_t)v80, 3), v80))));
        }
        float16x8_t v84 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v84 >= a8) {
          uint64_t v85 = -(uint64_t)a7;
        }
        else {
          uint64_t v85 = 0;
        }
        a3 = &v84[v85];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      float16x8_t v86 = &a5[a4];
      if ((unint64_t)v86 >= a9) {
        uint64_t v87 = v35;
      }
      else {
        uint64_t v87 = 0;
      }
      float16x4_t v88 = &v86[v87];
      uint64_t v89 = a8 + 8 * v87 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v88;
        a8 = v89;
        a5 = v88;
      }
      BOOL v90 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v90 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v91 = (a8 - (unint64_t)a3) >> 3;
    if (v91 >= a12) {
      unint64_t v91 = a12;
    }
    unint64_t v92 = v91;
    if (v91 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v93 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        float16x8_t v100 = (unsigned __int8 *)&a10[v92];
        float16x8_t v101 = (int8x16_t *)a10;
        do
          float16x8_t v102 = v101++;
        while (v101 <= (int8x16_t *)v100 && (vminvq_u8((uint8x16_t)vceqq_s8(*v102, v39)) & 0x80) != 0);
        do
        {
          uint64_t v103 = v102;
          float16x8_t v102 = (int8x16_t *)((char *)v102 + 4);
        }
        while (v102 <= (int8x16_t *)v100 && v103->i32[0] == -1);
        if (v103 < (int8x16_t *)v100)
        {
          while (v103->u8[0] == 255)
          {
            uint64_t v103 = (int8x16_t *)((char *)v103 + 1);
            if (v103 >= (int8x16_t *)v100)
            {
              uint64_t v103 = (int8x16_t *)&a10[v92];
              break;
            }
          }
        }
        uint64_t v104 = 0;
        int64_t v105 = (char *)v103 - a10;
        unint64_t v106 = (char *)v103 - a10;
        do
        {
          float16x8_t v107 = (int8x16_t *)((char *)result + v104);
          float16x8_t v108 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v104]), v23), v26);
          float16x8_t v109 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v104]), v23), v26);
          float16x8_t v110 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v104]), v28), v29);
          float16x8_t v111 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v104]), v28), v29);
          float16x8_t v17 = (float16x8_t)vqtbl1q_s8((int8x16_t)v109, (int8x16_t)xmmword_1850CD880);
          float16x8_t v112 = (float16x8_t)vqtbl1q_s8((int8x16_t)v108, (int8x16_t)xmmword_1850CD880);
          float16x8_t v113 = (float16x8_t)vqtbl1q_s8((int8x16_t)v111, (int8x16_t)xmmword_1850CD880);
          float16x8_t v114 = (float16x8_t)vqtbl1q_s8((int8x16_t)v110, (int8x16_t)xmmword_1850CD880);
          *float16x8_t v107 = vrev16q_s8((int8x16_t)vsubq_f16(vminnmq_f16(vaddq_f16(v17, v113), v38), vaddq_f16(vsubq_f16(v17, v109), vsubq_f16(v113, v111))));
          v107[1] = vrev16q_s8((int8x16_t)vsubq_f16(vminnmq_f16(vaddq_f16(v112, v114), v38), vaddq_f16(vsubq_f16(v112, v108), vsubq_f16(v114, v110))));
          a10 += v30;
          v106 -= 4;
          v104 += v36;
        }
        while (v106 > 3);
        a3 = (int8x8_t *)((char *)a3 + v104);
        uint64_t result = (int8x8_t *)((char *)result + v104);
        unint64_t v92 = v92 - v105 + v106;
        goto LABEL_88;
      }
      if (v93) {
        break;
      }
      uint64_t v94 = (unsigned __int8 *)&a10[v92];
      uint64_t v95 = (int8x16_t *)a10;
      do
        uint64_t v96 = v95++;
      while (v95 <= (int8x16_t *)v94 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v96)) & 0x80) != 0);
      do
      {
        float16x8_t v97 = v96;
        uint64_t v96 = (int8x16_t *)((char *)v96 + 4);
      }
      while (v96 <= (int8x16_t *)v94 && !v97->i32[0]);
      if (v97 < (int8x16_t *)v94)
      {
        while (!v97->i8[0])
        {
          float16x8_t v97 = (int8x16_t *)((char *)v97 + 1);
          if (v97 >= (int8x16_t *)v94)
          {
            float16x8_t v97 = (int8x16_t *)&a10[v92];
            break;
          }
        }
      }
      int64_t v98 = (char *)v97 - a10;
      int64_t v99 = ((char *)v97 - a10) * a14;
      a3 += v99;
      result += v99;
      a10 += v99;
      v92 -= v98;
LABEL_88:
      if (v92 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v115 = 0;
    while (1)
    {
      int8x16_t v116 = (int8x16_t *)((char *)result + v115);
      v17.i32[0] = v93;
      uint8x16_t v117 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v118 = vcvtq_f16_u16(vmovl_high_u8(v117));
      float16x8_t v17 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v117.i8)), v40);
      float16x8_t v119 = vmulq_f16(v118, v40);
      float16x8_t v120 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v115]), v23), v26);
      float16x8_t v121 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v115]), v23), v26);
      float16x8_t v122 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v119)), (int8x16_t)v38, vrev16q_s8(*(int8x16_t *)&result[2].i8[v115]));
      float16x8_t v123 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v17)), (int8x16_t)v38, vrev16q_s8(*(int8x16_t *)&result->i8[v115]));
      float16x8_t v124 = (float16x8_t)vqtbl1q_s8((int8x16_t)v121, (int8x16_t)xmmword_1850CD880);
      float16x8_t v125 = (float16x8_t)vqtbl1q_s8((int8x16_t)v120, (int8x16_t)xmmword_1850CD880);
      float16x8_t v126 = (float16x8_t)vqtbl1q_s8((int8x16_t)v123, (int8x16_t)xmmword_1850CD880);
      float16x8_t v127 = (float16x8_t)vqtbl1q_s8((int8x16_t)v122, (int8x16_t)xmmword_1850CD880);
      *int8x16_t v116 = vrev16q_s8(vbslq_s8((int8x16_t)vceqzq_f16(v17), (int8x16_t)v123, (int8x16_t)vsubq_f16(vminnmq_f16(vmlaq_f16(v126, v17, v124), v38), vmlaq_f16(vsubq_f16(v126, v123), v17, vsubq_f16(v124, v121)))));
      v116[1] = vrev16q_s8(vbslq_s8((int8x16_t)vceqzq_f16(v119), (int8x16_t)v122, (int8x16_t)vsubq_f16(vminnmq_f16(vmlaq_f16(v127, v119, v125), v38), vmlaq_f16(vsubq_f16(v127, v122), v119, vsubq_f16(v125, v120)))));
      a10 += v30;
      v92 -= 4;
      if (v92 < 4) {
        break;
      }
      __int32 v93 = *(_DWORD *)a10;
      v115 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v115);
        a3 = (int8x8_t *)((char *)a3 + v115);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v115);
    a3 = (int8x8_t *)((char *)a3 + v36 + v115);
LABEL_91:
    for (unint64_t j = a12 - v91 + v92; j; --j)
    {
      if (*a10)
      {
        float16x4_t v129 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v130 = (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33);
        float16x4_t v131 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v129)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v132 = (float16x4_t)vdup_lane_s16((int16x4_t)v131, 3);
        float16x4_t v133 = vsub_f16(v132, v131);
        *(float16x4_t *)v17.i8 = vmla_lane_f16(v132, v129, v130, 3);
        int *result = vrev16_s8(vbsl_s8((int8x8_t)vceqz_f16(v129), (int8x8_t)v131, (int8x8_t)vsub_f16(vminnm_f16(*(float16x4_t *)v17.i8, (float16x4_t)0x3C003C003C003C00), vmla_f16(v133, v129, vsub_f16((float16x4_t)vdup_lane_s16((int16x4_t)v130, 3), v130)))));
      }
      float v134 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v134 >= a8) {
        uint64_t v135 = -(uint64_t)a7;
      }
      else {
        uint64_t v135 = 0;
      }
      a3 = &v134[v135];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    __int16 v136 = &a5[a4];
    if ((unint64_t)v136 >= a9) {
      uint64_t v137 = v35;
    }
    else {
      uint64_t v137 = 0;
    }
    __int16 v138 = &v136[v137];
    uint64_t v139 = a8 + 8 * v137 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v138;
      a8 = v139;
      a5 = v138;
    }
    BOOL v90 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v90 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float16x4_t *composite_pixelmask<(CGCompositeOperation)12,_rgbaf16_t>(float16x4_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  int8x16_t v20 = (int8x16_t)vdupq_n_s16(v19);
  v21.i64[0] = 0xFFFF000000000000;
  v21.i64[1] = 0xFFFF000000000000;
  int8x16_t v22 = vmvnq_s8(vandq_s8(v20, v21));
  int8x16_t v23 = vandq_s8(v20, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v24 = 4 * a14;
  int8x8_t v25 = 0;
  v25.i16[3] = v19;
  int8x8_t v26 = vmvn_s8(v25);
  int8x8_t v27 = vand_s8(*(int8x8_t *)v20.i8, (int8x8_t)0x3C00000000000000);
  uint64_t v28 = -(uint64_t)a7;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 8 * a14;
  v32.i64[0] = -1;
  v32.i64[1] = -1;
  float16x8_t v33 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v34 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a16 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v35 = (a8 - (unint64_t)a3) >> 3;
      if (v35 >= a12) {
        unint64_t v35 = a12;
      }
      unint64_t v36 = v35;
      if (v35 < 4) {
        goto LABEL_39;
      }
      while (1)
      {
        __int32 v37 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          float16x8_t v44 = (unsigned __int8 *)&a10[v36];
          uint64_t v45 = (int8x16_t *)a10;
          do
            uint8x16_t v46 = v45++;
          while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqq_s8(*v46, v32)) & 0x80) != 0);
          do
          {
            uint8x16_t v47 = v46;
            uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
          }
          while (v46 <= (int8x16_t *)v44 && v47->i32[0] == -1);
          if (v47 < (int8x16_t *)v44)
          {
            while (v47->u8[0] == 255)
            {
              uint8x16_t v47 = (int8x16_t *)((char *)v47 + 1);
              if (v47 >= (int8x16_t *)v44)
              {
                uint8x16_t v47 = (int8x16_t *)&a10[v36];
                break;
              }
            }
          }
          uint64_t v48 = 0;
          int64_t v49 = (char *)v47 - a10;
          unint64_t v50 = (char *)v47 - a10;
          do
          {
            uint64_t v51 = (float16x8_t *)((char *)result + v48);
            float16x8_t v52 = vminnmq_f16(vaddq_f16(*(float16x8_t *)&result[2].i8[v48], (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v48], v22), v23)), (float16x8_t)xmmword_1850CE000);
            float16x8_t *v51 = vminnmq_f16(vaddq_f16(*(float16x8_t *)&result->i8[v48], (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v48], v22), v23)), (float16x8_t)xmmword_1850CE000);
            v51[1] = v52;
            a10 += v24;
            v50 -= 4;
            v48 += v30;
          }
          while (v50 > 3);
          a3 = (int8x8_t *)((char *)a3 + v48);
          uint64_t result = (float16x4_t *)((char *)result + v48);
          unint64_t v36 = v36 - v49 + v50;
          goto LABEL_36;
        }
        if (v37) {
          break;
        }
        float16x8_t v38 = (unsigned __int8 *)&a10[v36];
        int8x16_t v39 = (int8x16_t *)a10;
        do
          float16x8_t v40 = v39++;
        while (v39 <= (int8x16_t *)v38 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v40)) & 0x80) != 0);
        do
        {
          unint64_t v41 = v40;
          float16x8_t v40 = (int8x16_t *)((char *)v40 + 4);
        }
        while (v40 <= (int8x16_t *)v38 && !v41->i32[0]);
        if (v41 < (int8x16_t *)v38)
        {
          while (!v41->i8[0])
          {
            unint64_t v41 = (int8x16_t *)((char *)v41 + 1);
            if (v41 >= (int8x16_t *)v38)
            {
              unint64_t v41 = (int8x16_t *)&a10[v36];
              break;
            }
          }
        }
        int64_t v42 = (char *)v41 - a10;
        int64_t v43 = ((char *)v41 - a10) * a14;
        a3 += v43;
        result += v43;
        a10 += v43;
        v36 -= v42;
LABEL_36:
        if (v36 <= 3) {
          goto LABEL_39;
        }
      }
      uint64_t v53 = 0;
      while (1)
      {
        uint64_t v54 = (int8x16_t *)((char *)result + v53);
        v16.i32[0] = v37;
        uint8x16_t v55 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v56 = vcvtq_f16_u16(vmovl_high_u8(v55));
        float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v55.i8)), v33);
        float16x8_t v57 = vmulq_f16(v56, v33);
        int8x16_t v58 = vbslq_s8((int8x16_t)vcgtzq_f16(v57), (int8x16_t)vminnmq_f16(vmlaq_f16(*(float16x8_t *)&result[2].i8[v53], v57, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v53], v22), v23)), (float16x8_t)xmmword_1850CE000), *(int8x16_t *)&result[2].i8[v53]);
        *uint64_t v54 = vbslq_s8((int8x16_t)vcgtzq_f16(v16), (int8x16_t)vminnmq_f16(vmlaq_f16(*(float16x8_t *)&result->i8[v53], v16, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v53], v22), v23)), (float16x8_t)xmmword_1850CE000), *(int8x16_t *)&result->i8[v53]);
        v54[1] = v58;
        a10 += v24;
        v36 -= 4;
        if (v36 < 4) {
          break;
        }
        __int32 v37 = *(_DWORD *)a10;
        v53 += v30;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (float16x4_t *)((char *)result + v53);
          a3 = (int8x8_t *)((char *)a3 + v53);
          goto LABEL_36;
        }
      }
      uint64_t result = (float16x4_t *)((char *)result + v30 + v53);
      a3 = (int8x8_t *)((char *)a3 + v30 + v53);
LABEL_39:
      for (unint64_t i = a12 - v35 + v36; i; --i)
      {
        if (*a10)
        {
          float16x4_t v60 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v34);
          *(float16x4_t *)v16.i8 = vmla_f16(*result, v60, (float16x4_t)vorr_s8(vand_s8(*a3, v26), v27));
          int *result = (float16x4_t)vbsl_s8((int8x8_t)vcgtz_f16(v60), (int8x8_t)vminnm_f16(*(float16x4_t *)v16.i8, (float16x4_t)0x3C007BFF7BFF7BFFLL), (int8x8_t)*result);
        }
        float16x8_t v61 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v61 >= a8) {
          uint64_t v62 = v28;
        }
        else {
          uint64_t v62 = 0;
        }
        a3 = &v61[v62];
        uint64_t result = (float16x4_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      float16x8_t v63 = &a5[a4];
      if ((unint64_t)v63 >= a9) {
        uint64_t v64 = v29;
      }
      else {
        uint64_t v64 = 0;
      }
      uint64_t v65 = &v63[v64];
      uint64_t v66 = a8 + 8 * v64 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v65;
        a8 = v66;
        a5 = v65;
      }
      BOOL v67 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v67 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v68 = (a8 - (unint64_t)a3) >> 3;
    if (v68 >= a12) {
      unint64_t v68 = a12;
    }
    unint64_t v69 = v68;
    if (v68 < 4) {
      goto LABEL_88;
    }
    while (1)
    {
      __int32 v70 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        float16x8_t v77 = (unsigned __int8 *)&a10[v69];
        float16x8_t v78 = (int8x16_t *)a10;
        do
          float16x4_t v79 = v78++;
        while (v78 <= (int8x16_t *)v77 && (vminvq_u8((uint8x16_t)vceqq_s8(*v79, v32)) & 0x80) != 0);
        do
        {
          float16x4_t v80 = v79;
          float16x4_t v79 = (int8x16_t *)((char *)v79 + 4);
        }
        while (v79 <= (int8x16_t *)v77 && v80->i32[0] == -1);
        if (v80 < (int8x16_t *)v77)
        {
          while (v80->u8[0] == 255)
          {
            float16x4_t v80 = (int8x16_t *)((char *)v80 + 1);
            if (v80 >= (int8x16_t *)v77)
            {
              float16x4_t v80 = (int8x16_t *)&a10[v69];
              break;
            }
          }
        }
        uint64_t v81 = 0;
        int64_t v82 = (char *)v80 - a10;
        unint64_t v83 = (char *)v80 - a10;
        do
        {
          float16x8_t v84 = (int8x16_t *)((char *)result + v81);
          int8x16_t v85 = vrev16q_s8((int8x16_t)vminnmq_f16(vaddq_f16((float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v81]), (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v81]), v22), v23)), (float16x8_t)xmmword_1850CE000));
          *float16x8_t v84 = vrev16q_s8((int8x16_t)vminnmq_f16(vaddq_f16((float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v81]), (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v81]), v22), v23)), (float16x8_t)xmmword_1850CE000));
          v84[1] = v85;
          a10 += v24;
          v83 -= 4;
          v81 += v30;
        }
        while (v83 > 3);
        a3 = (int8x8_t *)((char *)a3 + v81);
        uint64_t result = (float16x4_t *)((char *)result + v81);
        unint64_t v69 = v69 - v82 + v83;
        goto LABEL_85;
      }
      if (v70) {
        break;
      }
      float16x8_t v71 = (unsigned __int8 *)&a10[v69];
      float16x8_t v72 = (int8x16_t *)a10;
      do
        float16x8_t v73 = v72++;
      while (v72 <= (int8x16_t *)v71 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v73)) & 0x80) != 0);
      do
      {
        float16x8_t v74 = v73;
        float16x8_t v73 = (int8x16_t *)((char *)v73 + 4);
      }
      while (v73 <= (int8x16_t *)v71 && !v74->i32[0]);
      if (v74 < (int8x16_t *)v71)
      {
        while (!v74->i8[0])
        {
          float16x8_t v74 = (int8x16_t *)((char *)v74 + 1);
          if (v74 >= (int8x16_t *)v71)
          {
            float16x8_t v74 = (int8x16_t *)&a10[v69];
            break;
          }
        }
      }
      int64_t v75 = (char *)v74 - a10;
      int64_t v76 = ((char *)v74 - a10) * a14;
      a3 += v76;
      result += v76;
      a10 += v76;
      v69 -= v75;
LABEL_85:
      if (v69 <= 3) {
        goto LABEL_88;
      }
    }
    uint64_t v86 = 0;
    while (1)
    {
      uint64_t v87 = (int8x16_t *)((char *)result + v86);
      float16x8_t v88 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result->i8[v86]);
      float16x8_t v89 = (float16x8_t)vrev16q_s8(*(int8x16_t *)&result[2].i8[v86]);
      v16.i32[0] = v70;
      uint8x16_t v90 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v16, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v91 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v90.i8));
      float16x8_t v16 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v90)), v33);
      float16x8_t v92 = vmulq_f16(v91, v33);
      int8x16_t v93 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v16), (int8x16_t)vminnmq_f16(vmlaq_f16(v89, v16, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v86]), v22), v23)), (float16x8_t)xmmword_1850CE000), (int8x16_t)v89));
      *uint64_t v87 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v92), (int8x16_t)vminnmq_f16(vmlaq_f16(v88, v92, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v86]), v22), v23)), (float16x8_t)xmmword_1850CE000), (int8x16_t)v88));
      v87[1] = v93;
      a10 += v24;
      v69 -= 4;
      if (v69 < 4) {
        break;
      }
      __int32 v70 = *(_DWORD *)a10;
      v86 += v30;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (float16x4_t *)((char *)result + v86);
        a3 = (int8x8_t *)((char *)a3 + v86);
        goto LABEL_85;
      }
    }
    uint64_t result = (float16x4_t *)((char *)result + v30 + v86);
    a3 = (int8x8_t *)((char *)a3 + v30 + v86);
LABEL_88:
    for (unint64_t j = a12 - v68 + v69; j; --j)
    {
      if (*a10)
      {
        float16x4_t v95 = (float16x4_t)vrev16_s8((int8x8_t)*result);
        float16x4_t v96 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v34);
        *(float16x4_t *)v16.i8 = vmla_f16(v95, v96, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v26), v27));
        int *result = (float16x4_t)vrev16_s8(vbsl_s8((int8x8_t)vcgtz_f16(v96), (int8x8_t)vminnm_f16(*(float16x4_t *)v16.i8, (float16x4_t)0x3C007BFF7BFF7BFFLL), (int8x8_t)v95));
      }
      float16x8_t v97 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v97 >= a8) {
        uint64_t v98 = v28;
      }
      else {
        uint64_t v98 = 0;
      }
      a3 = &v97[v98];
      uint64_t result = (float16x4_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    int64_t v99 = &a5[a4];
    if ((unint64_t)v99 >= a9) {
      uint64_t v100 = v29;
    }
    else {
      uint64_t v100 = 0;
    }
    float16x8_t v101 = &v99[v100];
    uint64_t v102 = a8 + 8 * v100 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v101;
      a8 = v102;
      a5 = v101;
    }
    BOOL v67 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v67 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)13,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = (int8x16_t)vdupq_n_s16(v24);
  int8x16_t v26 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  int8x16_t v27 = vandq_s8(v25, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v25, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v24;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  float16x8_t v39 = (float16x8_t)vdupq_n_s16(0x1C04u);
  v40.i64[0] = 0x3C003C003C003C00;
  v40.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 3;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v43 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          unint64_t v50 = (unsigned __int8 *)&a10[v42];
          uint64_t v51 = (int8x16_t *)a10;
          do
            float16x8_t v52 = v51++;
          while (v51 <= (int8x16_t *)v50 && (vminvq_u8((uint8x16_t)vceqq_s8(*v52, v38)) & 0x80) != 0);
          do
          {
            uint64_t v53 = v52;
            float16x8_t v52 = (int8x16_t *)((char *)v52 + 4);
          }
          while (v52 <= (int8x16_t *)v50 && v53->i32[0] == -1);
          if (v53 < (int8x16_t *)v50)
          {
            while (v53->u8[0] == 255)
            {
              uint64_t v53 = (int8x16_t *)((char *)v53 + 1);
              if (v53 >= (int8x16_t *)v50)
              {
                uint64_t v53 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          uint64_t v54 = 0;
          int64_t v55 = (char *)v53 - a10;
          unint64_t v56 = (char *)v53 - a10;
          do
          {
            float16x8_t v57 = (int8x16_t *)((char *)result + v54);
            float16x8_t v58 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v54], v23), v26);
            float16x8_t v59 = (float16x8_t)vqtbl1q_s8((int8x16_t)v58, (int8x16_t)xmmword_1850CD880);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v54], v23), v26);
            float16x8_t v61 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float16x8_t v62 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v54], v28), v29);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v62, (int8x16_t)xmmword_1850CD880);
            float16x8_t v64 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v54], v28), v29);
            float16x8_t v65 = (float16x8_t)vqtbl1q_s8((int8x16_t)v64, (int8x16_t)xmmword_1850CD880);
            int8x16_t v66 = (int8x16_t)vcgtzq_f16(v61);
            int8x16_t v67 = (int8x16_t)vcgtzq_f16(v59);
            float16x8_t v68 = vmlsq_f16(v62, v61, v62);
            float16x8_t v69 = vmlsq_f16(v64, v59, v64);
            int8x16_t v17 = (int8x16_t)vmlaq_f16(vaddq_f16(v68, vmlsq_f16(v60, v63, v60)), v60, v62);
            int8x16_t *v57 = vbslq_s8(v66, vbslq_s8((int8x16_t)vcgtzq_f16(v63), v17, (int8x16_t)v60), (int8x16_t)v62);
            v57[1] = vbslq_s8(v67, vbslq_s8((int8x16_t)vcgtzq_f16(v65), (int8x16_t)vmlaq_f16(vaddq_f16(v69, vmlsq_f16(v58, v65, v58)), v58, v64), (int8x16_t)v58), (int8x16_t)v64);
            a10 += v30;
            v56 -= 4;
            v54 += v36;
          }
          while (v56 > 3);
          a3 = (int8x8_t *)((char *)a3 + v54);
          uint64_t result = (int8x8_t *)((char *)result + v54);
          unint64_t v42 = v42 - v55 + v56;
          goto LABEL_39;
        }
        if (v43) {
          break;
        }
        float16x8_t v44 = (unsigned __int8 *)&a10[v42];
        uint64_t v45 = (int8x16_t *)a10;
        do
          uint8x16_t v46 = v45++;
        while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
        do
        {
          uint8x16_t v47 = v46;
          uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= (int8x16_t *)v44 && !v47->i32[0]);
        if (v47 < (int8x16_t *)v44)
        {
          while (!v47->i8[0])
          {
            uint8x16_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= (int8x16_t *)v44)
            {
              uint8x16_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        int64_t v48 = (char *)v47 - a10;
        int64_t v49 = ((char *)v47 - a10) * a14;
        a3 += v49;
        result += v49;
        a10 += v49;
        v42 -= v48;
LABEL_39:
        if (v42 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v70 = 0;
      while (1)
      {
        float16x8_t v71 = (int8x16_t *)((char *)result + v70);
        v17.i32[0] = v43;
        uint8x16_t v72 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v73 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v72.i8));
        float16x8_t v74 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v72)), v39);
        float16x8_t v75 = vmulq_f16(v73, v39);
        float16x8_t v76 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v75)), v40, *(int8x16_t *)&result->i8[v70]);
        float16x8_t v77 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v74)), v40, *(int8x16_t *)&result[2].i8[v70]);
        float16x8_t v78 = vmulq_f16(v74, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v70], v23), v26));
        float16x8_t v79 = vmulq_f16(v75, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v70], v23), v26));
        float16x8_t v80 = (float16x8_t)vqtbl1q_s8((int8x16_t)v79, (int8x16_t)xmmword_1850CD880);
        float16x8_t v81 = (float16x8_t)vqtbl1q_s8((int8x16_t)v78, (int8x16_t)xmmword_1850CD880);
        float16x8_t v82 = (float16x8_t)vqtbl1q_s8((int8x16_t)v77, (int8x16_t)xmmword_1850CD880);
        float16x8_t v83 = (float16x8_t)vqtbl1q_s8((int8x16_t)v76, (int8x16_t)xmmword_1850CD880);
        int8x16_t v84 = (int8x16_t)vcgtzq_f16(v80);
        float16x8_t v85 = vmlsq_f16(v76, v80, v76);
        int8x16_t v17 = (int8x16_t)vmlaq_f16(vaddq_f16(vmlsq_f16(v77, v81, v77), vmlsq_f16(v78, v82, v78)), v78, v77);
        *float16x8_t v71 = vbslq_s8(v84, vbslq_s8((int8x16_t)vcgtzq_f16(v83), (int8x16_t)vmlaq_f16(vaddq_f16(v85, vmlsq_f16(v79, v83, v79)), v79, v76), (int8x16_t)v79), (int8x16_t)v76);
        v71[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v81), vbslq_s8((int8x16_t)vcgtzq_f16(v82), v17, (int8x16_t)v78), (int8x16_t)v77);
        a10 += v30;
        v42 -= 4;
        if (v42 < 4) {
          break;
        }
        __int32 v43 = *(_DWORD *)a10;
        v70 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v70);
          a3 = (int8x8_t *)((char *)a3 + v70);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v70);
      a3 = (int8x8_t *)((char *)a3 + v36 + v70);
LABEL_42:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float16x4_t v87 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v88 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v87)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v89 = vmul_f16(v87, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          int *result = vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v89, 3)), vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v88, 3)), (int8x8_t)vmla_f16(vadd_f16(vmls_lane_f16(v89, v89, v88, 3), vmls_lane_f16(v88, v88, v89, 3)), v89, v88), (int8x8_t)v89), (int8x8_t)v88);
        }
        uint8x16_t v90 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v90 >= a8) {
          uint64_t v91 = -(uint64_t)a7;
        }
        else {
          uint64_t v91 = 0;
        }
        a3 = &v90[v91];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      float16x8_t v92 = &a5[a4];
      if ((unint64_t)v92 >= a9) {
        uint64_t v93 = v35;
      }
      else {
        uint64_t v93 = 0;
      }
      uint64_t v94 = &v92[v93];
      uint64_t v95 = a8 + 8 * v93 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v94;
        a8 = v95;
        a5 = v94;
      }
      BOOL v96 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v96 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v97 = (a8 - (unint64_t)a3) >> 3;
    if (v97 >= a12) {
      unint64_t v97 = a12;
    }
    unint64_t v98 = v97;
    if (v97 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v99 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        unint64_t v106 = (unsigned __int8 *)&a10[v98];
        float16x8_t v107 = (int8x16_t *)a10;
        do
          float16x8_t v108 = v107++;
        while (v107 <= (int8x16_t *)v106 && (vminvq_u8((uint8x16_t)vceqq_s8(*v108, v38)) & 0x80) != 0);
        do
        {
          float16x8_t v109 = v108;
          float16x8_t v108 = (int8x16_t *)((char *)v108 + 4);
        }
        while (v108 <= (int8x16_t *)v106 && v109->i32[0] == -1);
        if (v109 < (int8x16_t *)v106)
        {
          while (v109->u8[0] == 255)
          {
            float16x8_t v109 = (int8x16_t *)((char *)v109 + 1);
            if (v109 >= (int8x16_t *)v106)
            {
              float16x8_t v109 = (int8x16_t *)&a10[v98];
              break;
            }
          }
        }
        uint64_t v110 = 0;
        int64_t v111 = (char *)v109 - a10;
        unint64_t v112 = (char *)v109 - a10;
        do
        {
          float16x8_t v113 = (int8x16_t *)((char *)result + v110);
          float16x8_t v114 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v110]), v23), v26);
          float16x8_t v115 = (float16x8_t)vqtbl1q_s8((int8x16_t)v114, (int8x16_t)xmmword_1850CD880);
          float16x8_t v116 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v110]), v23), v26);
          float16x8_t v117 = (float16x8_t)vqtbl1q_s8((int8x16_t)v116, (int8x16_t)xmmword_1850CD880);
          float16x8_t v118 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v110]), v28), v29);
          float16x8_t v119 = (float16x8_t)vqtbl1q_s8((int8x16_t)v118, (int8x16_t)xmmword_1850CD880);
          float16x8_t v120 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v110]), v28), v29);
          float16x8_t v121 = (float16x8_t)vqtbl1q_s8((int8x16_t)v120, (int8x16_t)xmmword_1850CD880);
          int8x16_t v122 = (int8x16_t)vcgtzq_f16(v115);
          float16x8_t v123 = vmlsq_f16(v120, v115, v120);
          int8x16_t v17 = (int8x16_t)vmlaq_f16(vaddq_f16(vmlsq_f16(v118, v117, v118), vmlsq_f16(v116, v119, v116)), v116, v118);
          *float16x8_t v113 = vrev16q_s8(vbslq_s8(v122, vbslq_s8((int8x16_t)vcgtzq_f16(v121), (int8x16_t)vmlaq_f16(vaddq_f16(v123, vmlsq_f16(v114, v121, v114)), v114, v120), (int8x16_t)v114), (int8x16_t)v120));
          v113[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v117), vbslq_s8((int8x16_t)vcgtzq_f16(v119), v17, (int8x16_t)v116), (int8x16_t)v118));
          a10 += v30;
          v112 -= 4;
          v110 += v36;
        }
        while (v112 > 3);
        a3 = (int8x8_t *)((char *)a3 + v110);
        uint64_t result = (int8x8_t *)((char *)result + v110);
        unint64_t v98 = v98 - v111 + v112;
        goto LABEL_88;
      }
      if (v99) {
        break;
      }
      uint64_t v100 = (unsigned __int8 *)&a10[v98];
      float16x8_t v101 = (int8x16_t *)a10;
      do
        uint64_t v102 = v101++;
      while (v101 <= (int8x16_t *)v100 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v102)) & 0x80) != 0);
      do
      {
        uint64_t v103 = v102;
        uint64_t v102 = (int8x16_t *)((char *)v102 + 4);
      }
      while (v102 <= (int8x16_t *)v100 && !v103->i32[0]);
      if (v103 < (int8x16_t *)v100)
      {
        while (!v103->i8[0])
        {
          uint64_t v103 = (int8x16_t *)((char *)v103 + 1);
          if (v103 >= (int8x16_t *)v100)
          {
            uint64_t v103 = (int8x16_t *)&a10[v98];
            break;
          }
        }
      }
      int64_t v104 = (char *)v103 - a10;
      int64_t v105 = ((char *)v103 - a10) * a14;
      a3 += v105;
      result += v105;
      a10 += v105;
      v98 -= v104;
LABEL_88:
      if (v98 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v124 = 0;
    while (1)
    {
      float16x8_t v125 = (int8x16_t *)((char *)result + v124);
      v17.i32[0] = v99;
      uint8x16_t v126 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v127 = vcvtq_f16_u16(vmovl_high_u8(v126));
      float16x8_t v128 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v126.i8)), v39);
      float16x8_t v129 = vmulq_f16(v127, v39);
      float16x8_t v130 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v129)), v40, vrev16q_s8(*(int8x16_t *)&result[2].i8[v124]));
      float16x8_t v131 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v128)), v40, vrev16q_s8(*(int8x16_t *)&result->i8[v124]));
      float16x8_t v132 = vmulq_f16(v128, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v124]), v23), v26));
      float16x8_t v133 = vmulq_f16(v129, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v124]), v23), v26));
      float16x8_t v134 = (float16x8_t)vqtbl1q_s8((int8x16_t)v133, (int8x16_t)xmmword_1850CD880);
      float16x8_t v135 = (float16x8_t)vqtbl1q_s8((int8x16_t)v132, (int8x16_t)xmmword_1850CD880);
      float16x8_t v136 = (float16x8_t)vqtbl1q_s8((int8x16_t)v131, (int8x16_t)xmmword_1850CD880);
      float16x8_t v137 = (float16x8_t)vqtbl1q_s8((int8x16_t)v130, (int8x16_t)xmmword_1850CD880);
      int8x16_t v138 = (int8x16_t)vcgtzq_f16(v135);
      int8x16_t v139 = (int8x16_t)vcgtzq_f16(v134);
      float16x8_t v140 = vmlsq_f16(v131, v135, v131);
      float16x8_t v141 = vmlsq_f16(v130, v134, v130);
      int8x16_t v17 = (int8x16_t)vmlaq_f16(vaddq_f16(v140, vmlsq_f16(v132, v136, v132)), v132, v131);
      *float16x8_t v125 = vrev16q_s8(vbslq_s8(v138, vbslq_s8((int8x16_t)vcgtzq_f16(v136), v17, (int8x16_t)v132), (int8x16_t)v131));
      v125[1] = vrev16q_s8(vbslq_s8(v139, vbslq_s8((int8x16_t)vcgtzq_f16(v137), (int8x16_t)vmlaq_f16(vaddq_f16(v141, vmlsq_f16(v133, v137, v133)), v133, v130), (int8x16_t)v133), (int8x16_t)v130));
      a10 += v30;
      v98 -= 4;
      if (v98 < 4) {
        break;
      }
      __int32 v99 = *(_DWORD *)a10;
      v124 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v124);
        a3 = (int8x8_t *)((char *)a3 + v124);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v124);
    a3 = (int8x8_t *)((char *)a3 + v36 + v124);
LABEL_91:
    for (unint64_t j = a12 - v97 + v98; j; --j)
    {
      if (*a10)
      {
        float16x4_t v143 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v144 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v143)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v145 = vmul_f16(v143, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        int *result = vrev16_s8(vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v145, 3)), vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v144, 3)), (int8x8_t)vmla_f16(vadd_f16(vmls_lane_f16(v145, v145, v144, 3), vmls_lane_f16(v144, v144, v145, 3)), v145, v144), (int8x8_t)v145), (int8x8_t)v144));
      }
      uint64_t v146 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v146 >= a8) {
        uint64_t v147 = -(uint64_t)a7;
      }
      else {
        uint64_t v147 = 0;
      }
      a3 = &v146[v147];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    int8x8_t v148 = &a5[a4];
    if ((unint64_t)v148 >= a9) {
      uint64_t v149 = v35;
    }
    else {
      uint64_t v149 = 0;
    }
    uint64_t v150 = &v148[v149];
    uint64_t v151 = a8 + 8 * v149 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v150;
      a8 = v151;
      a5 = v150;
    }
    BOOL v96 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v96 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)14,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  int8x16_t v24 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  if (a15) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = (int8x16_t)vdupq_n_s16(v25);
  int8x16_t v27 = vandq_s8(v26, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v26, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  int8x8_t v34 = 0;
  v34.i16[3] = v25;
  uint64_t v35 = -(uint64_t)a7;
  uint64_t v36 = -(a6 * a4);
  uint64_t v37 = 32 * a14;
  uint64_t v38 = 8 * a14;
  v39.i64[0] = 0x3C003C003C003C00;
  v39.i64[1] = 0x3C003C003C003C00;
  v40.i64[0] = -1;
  v40.i64[1] = -1;
  float16x8_t v41 = (float16x8_t)vdupq_n_s16(0x1C04u);
  float16x4_t v42 = (float16x4_t)vdup_n_s16(0x1C04u);
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v43 = (a8 - (unint64_t)a3) >> 3;
      if (v43 >= a12) {
        unint64_t v43 = a12;
      }
      unint64_t v44 = v43;
      if (v43 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v45 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          float16x8_t v52 = (unsigned __int8 *)&a10[v44];
          uint64_t v53 = (int8x16_t *)a10;
          do
            uint64_t v54 = v53++;
          while (v53 <= (int8x16_t *)v52 && (vminvq_u8((uint8x16_t)vceqq_s8(*v54, v40)) & 0x80) != 0);
          do
          {
            int64_t v55 = v54;
            uint64_t v54 = (int8x16_t *)((char *)v54 + 4);
          }
          while (v54 <= (int8x16_t *)v52 && v55->i32[0] == -1);
          if (v55 < (int8x16_t *)v52)
          {
            while (v55->u8[0] == 255)
            {
              int64_t v55 = (int8x16_t *)((char *)v55 + 1);
              if (v55 >= (int8x16_t *)v52)
              {
                int64_t v55 = (int8x16_t *)&a10[v44];
                break;
              }
            }
          }
          uint64_t v56 = 0;
          int64_t v57 = (char *)v55 - a10;
          unint64_t v58 = (char *)v55 - a10;
          do
          {
            float16x8_t v59 = (int8x16_t *)((char *)result + v56);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v56], v23), v24);
            float16x8_t v61 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v56], v23), v24);
            float16x8_t v62 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v56], v28), v29);
            float16x8_t v63 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v56], v28), v29);
            int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880));
            *float16x8_t v59 = vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v61, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v63, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v61, v61, v63), v63), (int8x16_t)v61), (int8x16_t)v63);
            v59[1] = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v62, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v60, v60, v62), v62), (int8x16_t)v60), (int8x16_t)v62);
            a10 += v30;
            v58 -= 4;
            v56 += v37;
          }
          while (v58 > 3);
          a3 = (int8x8_t *)((char *)a3 + v56);
          uint64_t result = (int8x8_t *)((char *)result + v56);
          unint64_t v44 = v44 - v57 + v58;
          goto LABEL_39;
        }
        if (v45) {
          break;
        }
        uint8x16_t v46 = (unsigned __int8 *)&a10[v44];
        uint8x16_t v47 = (int8x16_t *)a10;
        do
          int64_t v48 = v47++;
        while (v47 <= (int8x16_t *)v46 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v48)) & 0x80) != 0);
        do
        {
          int64_t v49 = v48;
          int64_t v48 = (int8x16_t *)((char *)v48 + 4);
        }
        while (v48 <= (int8x16_t *)v46 && !v49->i32[0]);
        if (v49 < (int8x16_t *)v46)
        {
          while (!v49->i8[0])
          {
            int64_t v49 = (int8x16_t *)((char *)v49 + 1);
            if (v49 >= (int8x16_t *)v46)
            {
              int64_t v49 = (int8x16_t *)&a10[v44];
              break;
            }
          }
        }
        int64_t v50 = (char *)v49 - a10;
        int64_t v51 = ((char *)v49 - a10) * a14;
        a3 += v51;
        result += v51;
        a10 += v51;
        v44 -= v50;
LABEL_39:
        if (v44 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v64 = 0;
      while (1)
      {
        float16x8_t v65 = (int8x16_t *)((char *)result + v64);
        v17.i32[0] = v45;
        uint8x16_t v66 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v67 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v66.i8));
        float16x8_t v68 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v66)), v41);
        float16x8_t v69 = vmulq_f16(v67, v41);
        float16x8_t v70 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v69)), (int8x16_t)v39, *(int8x16_t *)&result->i8[v64]);
        float16x8_t v71 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v68)), (int8x16_t)v39, *(int8x16_t *)&result[2].i8[v64]);
        float16x8_t v72 = vmulq_f16(v68, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v64], v23), v24));
        float16x8_t v73 = vmulq_f16(v69, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v64], v23), v24));
        int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v73, (int8x16_t)xmmword_1850CD880));
        *float16x8_t v65 = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v70, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v73, v73, v70), v70), (int8x16_t)v73), (int8x16_t)v70);
        v65[1] = vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v72, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v71, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v72, v72, v71), v71), (int8x16_t)v72), (int8x16_t)v71);
        a10 += v30;
        v44 -= 4;
        if (v44 < 4) {
          break;
        }
        __int32 v45 = *(_DWORD *)a10;
        v64 += v37;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v64);
          a3 = (int8x8_t *)((char *)a3 + v64);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v37 + v64);
      a3 = (int8x8_t *)((char *)a3 + v37 + v64);
LABEL_42:
      for (unint64_t i = a12 - v43 + v44; i; --i)
      {
        if (*a10)
        {
          float16x4_t v75 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v42);
          float16x4_t v76 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v75)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v77 = vmul_f16(v75, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          *(float16x4_t *)v17.i8 = vadd_f16(vmls_f16(v77, v77, v76), v76);
          int *result = vbsl_s8((int8x8_t)vdup_lane_s16(vcgtz_f16(v77), 3), vbsl_s8((int8x8_t)vcgtz_f16(vmaxnm_f16(vminnm_f16((float16x4_t)vdup_lane_s16((int16x4_t)v76, 3), (float16x4_t)0x3C003C003C003C00), 0)), *(int8x8_t *)v17.i8, (int8x8_t)v77), (int8x8_t)v76);
        }
        float16x8_t v78 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v78 >= a8) {
          uint64_t v79 = v35;
        }
        else {
          uint64_t v79 = 0;
        }
        a3 = &v78[v79];
        uint64_t result = (int8x8_t *)((char *)result + v38);
      }
      a10 += a11;
      result += a2;
      float16x8_t v80 = &a5[a4];
      if ((unint64_t)v80 >= a9) {
        uint64_t v81 = v36;
      }
      else {
        uint64_t v81 = 0;
      }
      float16x8_t v82 = &v80[v81];
      uint64_t v83 = a8 + 8 * v81 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v82;
        a8 = v83;
        a5 = v82;
      }
      BOOL v84 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v84 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v85 = (a8 - (unint64_t)a3) >> 3;
    if (v85 >= a12) {
      unint64_t v85 = a12;
    }
    unint64_t v86 = v85;
    if (v85 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v87 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        uint64_t v94 = (unsigned __int8 *)&a10[v86];
        uint64_t v95 = (int8x16_t *)a10;
        do
          BOOL v96 = v95++;
        while (v95 <= (int8x16_t *)v94 && (vminvq_u8((uint8x16_t)vceqq_s8(*v96, v40)) & 0x80) != 0);
        do
        {
          unint64_t v97 = v96;
          BOOL v96 = (int8x16_t *)((char *)v96 + 4);
        }
        while (v96 <= (int8x16_t *)v94 && v97->i32[0] == -1);
        if (v97 < (int8x16_t *)v94)
        {
          while (v97->u8[0] == 255)
          {
            unint64_t v97 = (int8x16_t *)((char *)v97 + 1);
            if (v97 >= (int8x16_t *)v94)
            {
              unint64_t v97 = (int8x16_t *)&a10[v86];
              break;
            }
          }
        }
        uint64_t v98 = 0;
        int64_t v99 = (char *)v97 - a10;
        unint64_t v100 = (char *)v97 - a10;
        do
        {
          float16x8_t v101 = (int8x16_t *)((char *)result + v98);
          float16x8_t v102 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v98]), v23), v24);
          float16x8_t v103 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v98]), v23), v24);
          float16x8_t v104 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v98]), v28), v29);
          float16x8_t v105 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v98]), v28), v29);
          int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v102, (int8x16_t)xmmword_1850CD880));
          *float16x8_t v101 = vrev16q_s8(vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v105, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v102, v102, v105), v105), (int8x16_t)v102), (int8x16_t)v105));
          v101[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v103, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v104, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v103, v103, v104), v104), (int8x16_t)v103), (int8x16_t)v104));
          a10 += v30;
          v100 -= 4;
          v98 += v37;
        }
        while (v100 > 3);
        a3 = (int8x8_t *)((char *)a3 + v98);
        uint64_t result = (int8x8_t *)((char *)result + v98);
        unint64_t v86 = v86 - v99 + v100;
        goto LABEL_88;
      }
      if (v87) {
        break;
      }
      float16x4_t v88 = (unsigned __int8 *)&a10[v86];
      float16x4_t v89 = (int8x16_t *)a10;
      do
        uint8x16_t v90 = v89++;
      while (v89 <= (int8x16_t *)v88 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v90)) & 0x80) != 0);
      do
      {
        uint64_t v91 = v90;
        uint8x16_t v90 = (int8x16_t *)((char *)v90 + 4);
      }
      while (v90 <= (int8x16_t *)v88 && !v91->i32[0]);
      if (v91 < (int8x16_t *)v88)
      {
        while (!v91->i8[0])
        {
          uint64_t v91 = (int8x16_t *)((char *)v91 + 1);
          if (v91 >= (int8x16_t *)v88)
          {
            uint64_t v91 = (int8x16_t *)&a10[v86];
            break;
          }
        }
      }
      int64_t v92 = (char *)v91 - a10;
      int64_t v93 = ((char *)v91 - a10) * a14;
      a3 += v93;
      result += v93;
      a10 += v93;
      v86 -= v92;
LABEL_88:
      if (v86 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v106 = 0;
    while (1)
    {
      float16x8_t v107 = (int8x16_t *)((char *)result + v106);
      v17.i32[0] = v87;
      uint8x16_t v108 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v109 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v108.i8));
      float16x8_t v110 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v108)), v41);
      float16x8_t v111 = vmulq_f16(v109, v41);
      float16x8_t v112 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v111)), (int8x16_t)v39, vrev16q_s8(*(int8x16_t *)&result->i8[v106]));
      float16x8_t v113 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v110)), (int8x16_t)v39, vrev16q_s8(*(int8x16_t *)&result[2].i8[v106]));
      float16x8_t v114 = vmulq_f16(v111, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v106]), v23), v24));
      float16x8_t v115 = vmulq_f16(v110, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v106]), v23), v24));
      int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v115, (int8x16_t)xmmword_1850CD880));
      *float16x8_t v107 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v114, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v112, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v114, v114, v112), v112), (int8x16_t)v114), (int8x16_t)v112));
      v107[1] = vrev16q_s8(vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16(vmaxnmq_f16(vminnmq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v113, (int8x16_t)xmmword_1850CD880), v39), (float16x8_t)0)), (int8x16_t)vaddq_f16(vmlsq_f16(v115, v115, v113), v113), (int8x16_t)v115), (int8x16_t)v113));
      a10 += v30;
      v86 -= 4;
      if (v86 < 4) {
        break;
      }
      __int32 v87 = *(_DWORD *)a10;
      v106 += v37;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v106);
        a3 = (int8x8_t *)((char *)a3 + v106);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v37 + v106);
    a3 = (int8x8_t *)((char *)a3 + v37 + v106);
LABEL_91:
    for (unint64_t j = a12 - v85 + v86; j; --j)
    {
      if (*a10)
      {
        float16x4_t v117 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), v42);
        float16x4_t v118 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v117)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v119 = vmul_f16(v117, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        *(float16x4_t *)v17.i8 = vadd_f16(vmls_f16(v119, v119, v118), v118);
        int *result = vrev16_s8(vbsl_s8((int8x8_t)vdup_lane_s16(vcgtz_f16(v119), 3), vbsl_s8((int8x8_t)vcgtz_f16(vmaxnm_f16(vminnm_f16((float16x4_t)vdup_lane_s16((int16x4_t)v118, 3), (float16x4_t)0x3C003C003C003C00), 0)), *(int8x8_t *)v17.i8, (int8x8_t)v119), (int8x8_t)v118));
      }
      float16x8_t v120 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v120 >= a8) {
        uint64_t v121 = v35;
      }
      else {
        uint64_t v121 = 0;
      }
      a3 = &v120[v121];
      uint64_t result = (int8x8_t *)((char *)result + v38);
    }
    a10 += a11;
    result += a2;
    int8x16_t v122 = &a5[a4];
    if ((unint64_t)v122 >= a9) {
      uint64_t v123 = v36;
    }
    else {
      uint64_t v123 = 0;
    }
    uint64_t v124 = &v122[v123];
    uint64_t v125 = a8 + 8 * v123 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v124;
      a8 = v125;
      a5 = v124;
    }
    BOOL v84 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v84 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)15,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = (int8x16_t)vdupq_n_s16(v24);
  int8x16_t v26 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  int8x16_t v27 = vandq_s8(v25, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v25, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v24;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  int8x8_t v321 = v34;
  int8x8_t v320 = v32;
  v38.i64[0] = 0x3F0000003F000000;
  v38.i64[1] = 0x3F0000003F000000;
  v39.i64[0] = 0x8000000080000000;
  v39.i64[1] = 0x8000000080000000;
  v40.i64[0] = 0x3C003C003C003C00;
  v40.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 3;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 4) {
        goto LABEL_43;
      }
      while (1)
      {
        __int32 v43 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v50 = (unsigned __int8 *)&a10[v42];
          int64_t v51 = (int8x16_t *)a10;
          v52.i64[0] = -1;
          v52.i64[1] = -1;
          do
            uint64_t v53 = v51++;
          while (v51 <= (int8x16_t *)v50 && (vminvq_u8((uint8x16_t)vceqq_s8(*v53, v52)) & 0x80) != 0);
          do
          {
            uint64_t v54 = v53;
            uint64_t v53 = (int8x16_t *)((char *)v53 + 4);
          }
          while (v53 <= (int8x16_t *)v50 && v54->i32[0] == -1);
          if (v54 < (int8x16_t *)v50)
          {
            while (v54->u8[0] == 255)
            {
              uint64_t v54 = (int8x16_t *)((char *)v54 + 1);
              if (v54 >= (int8x16_t *)v50)
              {
                uint64_t v54 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          uint64_t v55 = 0;
          unint64_t v56 = (char *)v54 - a10;
          unint64_t v57 = v56;
          do
          {
            unint64_t v58 = (int8x16_t *)((char *)result + v55);
            float16x8_t v59 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v55], v23), v26);
            float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v55], v28), v29);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v55], v28), v29);
            float16x8_t v61 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v55], v23), v26);
            float16x8_t v62 = (float16x8_t)vqtbl1q_s8((int8x16_t)v61, (int8x16_t)xmmword_1850CD880);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v59, (int8x16_t)xmmword_1850CD880);
            float16x8_t v64 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float32x4_t v65 = vcvtq_f32_f16(*(float16x4_t *)v59.i8);
            float32x4_t v66 = vcvt_hight_f32_f16(v59);
            float32x4_t v67 = vcvt_hight_f32_f16(v60);
            float32x4_t v68 = vcvtq_f32_f16(*(float16x4_t *)v60.i8);
            float32x4_t v69 = vcvtq_f32_f16(*(float16x4_t *)v63.i8);
            float32x4_t v70 = vcvt_hight_f32_f16(v63);
            float32x4_t v71 = vcvtq_f32_f16(*(float16x4_t *)v64.i8);
            float32x4_t v72 = vcvt_hight_f32_f16(v64);
            int8x16_t v73 = (int8x16_t)vcgtq_f32(vmulq_f32(v71, v38), v68);
            int8x16_t v74 = (int8x16_t)vcgtq_f32(vmulq_f32(v72, v38), v67);
            int8x16_t v75 = vandq_s8(v73, v39);
            float32x4_t v76 = (float32x4_t)veorq_s8(v75, (int8x16_t)vsubq_f32(v69, v65));
            float32x4_t v77 = (float32x4_t)veorq_s8(v75, (int8x16_t)vsubq_f32(v71, v68));
            int8x16_t v78 = vandq_s8(v74, v39);
            float32x4_t v79 = (float32x4_t)veorq_s8(v78, (int8x16_t)vsubq_f32(v70, v66));
            float32x4_t v80 = (float32x4_t)veorq_s8(v78, (int8x16_t)vsubq_f32(v72, v67));
            float16x8_t v81 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
            float32x4_t v82 = vmlaq_f32(v67, v79, v67);
            float32x4_t v83 = vcvtq_f32_f16(*(float16x4_t *)v61.i8);
            float32x4_t v84 = vmlaq_f32(v68, v76, v68);
            float32x4_t v85 = vcvt_hight_f32_f16(v61);
            float32x4_t v86 = vmlaq_f32(v66, v80, v66);
            float32x4_t v87 = vcvt_hight_f32_f16(v17);
            float32x4_t v88 = vmlaq_f32(v65, v77, v65);
            float32x4_t v89 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
            float32x4_t v90 = vaddq_f32(v88, v84);
            float32x4_t v91 = vcvtq_f32_f16(*(float16x4_t *)v62.i8);
            int8x16_t v92 = (int8x16_t)vmulq_f32(v70, v72);
            float32x4_t v93 = vcvtq_f32_f16(*(float16x4_t *)v81.i8);
            int8x16_t v94 = (int8x16_t)vmulq_f32(v69, v71);
            float32x4_t v95 = vcvt_hight_f32_f16(v81);
            float32x4_t v96 = vaddq_f32(v86, v82);
            float32x4_t v97 = (float32x4_t)vbslq_s8(v73, v39, v94);
            int8x16_t v98 = (int8x16_t)vcgtq_f32(vmulq_f32(v93, v38), v89);
            float32x4_t v99 = (float32x4_t)vbslq_s8(v74, v39, v92);
            float32x4_t v100 = vcvt_hight_f32_f16(v62);
            int8x16_t v101 = (int8x16_t)vcgtq_f32(vmulq_f32(v95, v38), v87);
            int8x16_t v102 = vbslq_s8((int8x16_t)vcgtzq_f16(v64), (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(v90, v97)), vsubq_f32(v96, v99)), (int8x16_t)v59);
            int8x16_t v103 = vandq_s8(v98, v39);
            float32x4_t v104 = (float32x4_t)veorq_s8(v103, (int8x16_t)vsubq_f32(v91, v83));
            float32x4_t v105 = (float32x4_t)veorq_s8(v103, (int8x16_t)vsubq_f32(v93, v89));
            int8x16_t v106 = vandq_s8(v101, v39);
            *unint64_t v58 = vbslq_s8((int8x16_t)vcgtzq_f16(v63), v102, (int8x16_t)v60);
            v58[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v62), vbslq_s8((int8x16_t)vcgtzq_f16(v81), (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(vaddq_f32(vmlaq_f32(v83, v105, v83), vmlaq_f32(v89, v104, v89)), (float32x4_t)vbslq_s8(v98, v39, (int8x16_t)vmulq_f32(v91, v93)))), vsubq_f32(vaddq_f32(vmlaq_f32(v85, (float32x4_t)veorq_s8(v106, (int8x16_t)vsubq_f32(v95, v87)), v85), vmlaq_f32(v87, (float32x4_t)veorq_s8(v106, (int8x16_t)vsubq_f32(v100, v85)), v87)), (float32x4_t)vbslq_s8(v101, v39, (int8x16_t)vmulq_f32(v100, v95)))),
                         (int8x16_t)v61),
                       (int8x16_t)v17);
            a10 += v30;
            v57 -= 4;
            v55 += v36;
          }
          while (v57 > 3);
          a3 = (int8x8_t *)((char *)a3 + v55);
          uint64_t result = (int8x8_t *)((char *)result + v55);
          unint64_t v42 = v42 - v56 + v57;
LABEL_39:
          int8x8_t v34 = v321;
          int8x8_t v32 = v320;
          goto LABEL_40;
        }
        if (v43) {
          break;
        }
        unint64_t v44 = (unsigned __int8 *)&a10[v42];
        __int32 v45 = (int8x16_t *)a10;
        do
        {
          uint8x16_t v46 = v45++;
          if (v45 > (int8x16_t *)v44) {
            break;
          }
          float16x8_t v17 = (float16x8_t)vceqzq_s8(*v46);
        }
        while ((vminvq_u8((uint8x16_t)v17) & 0x80) != 0);
        do
        {
          uint8x16_t v47 = v46;
          uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= (int8x16_t *)v44 && !v47->i32[0]);
        if (v47 < (int8x16_t *)v44)
        {
          while (!v47->i8[0])
          {
            uint8x16_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= (int8x16_t *)v44)
            {
              uint8x16_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        int64_t v48 = (char *)v47 - a10;
        int64_t v49 = ((char *)v47 - a10) * a14;
        a3 += v49;
        result += v49;
        a10 += v49;
        v42 -= v48;
LABEL_40:
        if (v42 <= 3) {
          goto LABEL_43;
        }
      }
      uint64_t v107 = 0;
      while (1)
      {
        uint8x16_t v108 = (int8x16_t *)((char *)result + v107);
        v17.i32[0] = v43;
        uint8x16_t v109 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v110 = (float16x8_t)vdupq_n_s16(0x1C04u);
        float16x8_t v111 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v109)), v110);
        float16x8_t v112 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v109.i8)), v110);
        float16x8_t v17 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v112)), v40, *(int8x16_t *)&result->i8[v107]);
        float16x8_t v113 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v111)), v40, *(int8x16_t *)&result[2].i8[v107]);
        float16x8_t v114 = vmulq_f16(v111, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v107], v23), v26));
        float16x8_t v115 = vmulq_f16(v112, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v107], v23), v26));
        float16x8_t v116 = (float16x8_t)vqtbl1q_s8((int8x16_t)v115, (int8x16_t)xmmword_1850CD880);
        float16x8_t v117 = (float16x8_t)vqtbl1q_s8((int8x16_t)v114, (int8x16_t)xmmword_1850CD880);
        float16x8_t v118 = (float16x8_t)vqtbl1q_s8((int8x16_t)v113, (int8x16_t)xmmword_1850CD880);
        float32x4_t v119 = vcvtq_f32_f16(*(float16x4_t *)v114.i8);
        float32x4_t v120 = vcvt_hight_f32_f16(v114);
        float32x4_t v121 = vcvt_hight_f32_f16(v113);
        float32x4_t v122 = vcvtq_f32_f16(*(float16x4_t *)v113.i8);
        float32x4_t v123 = vcvtq_f32_f16(*(float16x4_t *)v117.i8);
        float32x4_t v124 = vcvt_hight_f32_f16(v117);
        float32x4_t v125 = vcvtq_f32_f16(*(float16x4_t *)v118.i8);
        float32x4_t v126 = vcvt_hight_f32_f16(v118);
        int8x16_t v127 = (int8x16_t)vcgtq_f32(vmulq_f32(v125, v38), v122);
        int8x16_t v128 = (int8x16_t)vcgtq_f32(vmulq_f32(v126, v38), v121);
        int8x16_t v129 = vandq_s8(v127, v39);
        float32x4_t v130 = (float32x4_t)veorq_s8(v129, (int8x16_t)vsubq_f32(v123, v119));
        float32x4_t v131 = (float32x4_t)veorq_s8(v129, (int8x16_t)vsubq_f32(v125, v122));
        int8x16_t v132 = vandq_s8(v128, v39);
        float32x4_t v133 = (float32x4_t)veorq_s8(v132, (int8x16_t)vsubq_f32(v124, v120));
        float32x4_t v134 = (float32x4_t)veorq_s8(v132, (int8x16_t)vsubq_f32(v126, v121));
        float16x8_t v135 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
        float32x4_t v136 = vmlaq_f32(v121, v133, v121);
        float32x4_t v137 = vcvtq_f32_f16(*(float16x4_t *)v115.i8);
        float32x4_t v138 = vmlaq_f32(v122, v130, v122);
        float32x4_t v139 = vcvt_hight_f32_f16(v115);
        float32x4_t v140 = vmlaq_f32(v120, v134, v120);
        float32x4_t v141 = vcvt_hight_f32_f16(v17);
        float32x4_t v142 = vmlaq_f32(v119, v131, v119);
        float32x4_t v143 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
        float32x4_t v144 = vaddq_f32(v142, v138);
        float32x4_t v145 = vcvtq_f32_f16(*(float16x4_t *)v116.i8);
        float32x4_t v146 = vaddq_f32(v140, v136);
        float32x4_t v147 = vcvt_hight_f32_f16(v116);
        int8x16_t v148 = (int8x16_t)vmulq_f32(v124, v126);
        float32x4_t v149 = vcvtq_f32_f16(*(float16x4_t *)v135.i8);
        int8x16_t v150 = (int8x16_t)vmulq_f32(v123, v125);
        float32x4_t v151 = vcvt_hight_f32_f16(v135);
        float32x4_t v152 = (float32x4_t)vbslq_s8(v127, v39, v150);
        float32x4_t v153 = (float32x4_t)vbslq_s8(v128, v39, v148);
        int8x16_t v154 = (int8x16_t)vcgtq_f32(vmulq_f32(v149, v38), v143);
        int8x16_t v155 = (int8x16_t)vcgtq_f32(vmulq_f32(v151, v38), v141);
        int8x16_t v156 = vbslq_s8((int8x16_t)vcgtzq_f16(v118), (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(v144, v152)), vsubq_f32(v146, v153)), (int8x16_t)v114);
        int8x16_t v157 = vandq_s8(v154, v39);
        float32x4_t v158 = (float32x4_t)veorq_s8(v157, (int8x16_t)vsubq_f32(v145, v137));
        float32x4_t v159 = (float32x4_t)veorq_s8(v157, (int8x16_t)vsubq_f32(v149, v143));
        int8x16_t v160 = vandq_s8(v155, v39);
        *uint8x16_t v108 = vbslq_s8((int8x16_t)vcgtzq_f16(v116), vbslq_s8((int8x16_t)vcgtzq_f16(v135), (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(vaddq_f32(vmlaq_f32(v137, v159, v137), vmlaq_f32(v143, v158, v143)), (float32x4_t)vbslq_s8(v154, v39, (int8x16_t)vmulq_f32(v145, v149)))), vsubq_f32(vaddq_f32(vmlaq_f32(v139, (float32x4_t)veorq_s8(v160, (int8x16_t)vsubq_f32(v151, v141)), v139), vmlaq_f32(v141, (float32x4_t)veorq_s8(v160, (int8x16_t)vsubq_f32(v147, v139)), v141)), (float32x4_t)vbslq_s8(v155, v39, (int8x16_t)vmulq_f32(v147, v151)))),
                    (int8x16_t)v115),
                  (int8x16_t)v17);
        v108[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v117), v156, (int8x16_t)v113);
        a10 += v30;
        v42 -= 4;
        if (v42 < 4) {
          break;
        }
        __int32 v43 = *(_DWORD *)a10;
        v107 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v107);
          a3 = (int8x8_t *)((char *)a3 + v107);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v107);
      a3 = (int8x8_t *)((char *)a3 + v36 + v107);
      int8x8_t v34 = v321;
      int8x8_t v32 = v320;
LABEL_43:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float16x4_t v162 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v163 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v162)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v164 = vmul_f16(v162, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          float16x4_t v165 = (float16x4_t)vdup_lane_s16((int16x4_t)v164, 3);
          float16x4_t v166 = (float16x4_t)vdup_lane_s16((int16x4_t)v163, 3);
          *(int16x4_t *)v17.i8 = vcgtz_f16(v166);
          int8x8_t v167 = (int8x8_t)vcgtz_f16(v165);
          float32x4_t v168 = vcvtq_f32_f16(v164);
          float32x4_t v169 = vcvtq_f32_f16(v163);
          float32x4_t v170 = vcvtq_f32_f16(v165);
          float32x4_t v171 = vcvtq_f32_f16(v166);
          int8x16_t v172 = (int8x16_t)vcgtq_f32(vmulq_f32(v171, v38), v169);
          int8x16_t v173 = vandq_s8(v172, v39);
          int *result = vbsl_s8(v167, vbsl_s8(*(int8x8_t *)v17.i8, (int8x8_t)vcvt_f16_f32(vsubq_f32(vaddq_f32(vmlaq_f32(v168, (float32x4_t)veorq_s8(v173, (int8x16_t)vsubq_f32(v171, v169)), v168), vmlaq_f32(v169, (float32x4_t)veorq_s8(v173, (int8x16_t)vsubq_f32(v170, v168)), v169)), (float32x4_t)vbslq_s8(v172, v39, (int8x16_t)vmulq_f32(v171, v170)))), (int8x8_t)v164), (int8x8_t)v163);
        }
        uint64_t v174 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v174 >= a8) {
          uint64_t v175 = -(uint64_t)a7;
        }
        else {
          uint64_t v175 = 0;
        }
        a3 = &v174[v175];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      uint64_t v176 = &a5[a4];
      if ((unint64_t)v176 >= a9) {
        uint64_t v177 = v35;
      }
      else {
        uint64_t v177 = 0;
      }
      int v178 = &v176[v177];
      uint64_t v179 = a8 + 8 * v177 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v178;
        a8 = v179;
        a5 = v178;
      }
      BOOL v180 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v180 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v181 = (a8 - (unint64_t)a3) >> 3;
    if (v181 >= a12) {
      unint64_t v181 = a12;
    }
    unint64_t v182 = v181;
    if (v181 < 4) {
      goto LABEL_93;
    }
    while (1)
    {
      __int32 v183 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        uint64_t v190 = (unsigned __int8 *)&a10[v182];
        uint64_t v191 = (int8x16_t *)a10;
        v192.i64[0] = -1;
        v192.i64[1] = -1;
        do
          uint64_t v193 = v191++;
        while (v191 <= (int8x16_t *)v190 && (vminvq_u8((uint8x16_t)vceqq_s8(*v193, v192)) & 0x80) != 0);
        do
        {
          unint64_t v194 = v193;
          uint64_t v193 = (int8x16_t *)((char *)v193 + 4);
        }
        while (v193 <= (int8x16_t *)v190 && v194->i32[0] == -1);
        if (v194 < (int8x16_t *)v190)
        {
          while (v194->u8[0] == 255)
          {
            unint64_t v194 = (int8x16_t *)((char *)v194 + 1);
            if (v194 >= (int8x16_t *)v190)
            {
              unint64_t v194 = (int8x16_t *)&a10[v182];
              break;
            }
          }
        }
        uint64_t v195 = 0;
        int64_t v196 = (char *)v194 - a10;
        unint64_t v197 = (char *)v194 - a10;
        do
        {
          unsigned __int8 v198 = (int8x16_t *)((char *)result + v195);
          float16x8_t v199 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v195]), v23), v26);
          float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v195]), v23), v26);
          float16x8_t v200 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v195]), v28), v29);
          float16x8_t v201 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v195]), v28), v29);
          float16x8_t v202 = (float16x8_t)vqtbl1q_s8((int8x16_t)v199, (int8x16_t)xmmword_1850CD880);
          float16x8_t v203 = (float16x8_t)vqtbl1q_s8((int8x16_t)v201, (int8x16_t)xmmword_1850CD880);
          float16x8_t v204 = (float16x8_t)vqtbl1q_s8((int8x16_t)v200, (int8x16_t)xmmword_1850CD880);
          float32x4_t v205 = vcvtq_f32_f16(*(float16x4_t *)v199.i8);
          float32x4_t v206 = vcvt_hight_f32_f16(v199);
          float32x4_t v207 = vcvt_hight_f32_f16(v201);
          float32x4_t v208 = vcvtq_f32_f16(*(float16x4_t *)v201.i8);
          float32x4_t v209 = vcvtq_f32_f16(*(float16x4_t *)v202.i8);
          float32x4_t v210 = vcvt_hight_f32_f16(v202);
          float32x4_t v211 = vcvtq_f32_f16(*(float16x4_t *)v203.i8);
          float32x4_t v212 = vcvt_hight_f32_f16(v203);
          int8x16_t v213 = (int8x16_t)vcgtq_f32(vmulq_f32(v211, v38), v208);
          int8x16_t v214 = (int8x16_t)vcgtq_f32(vmulq_f32(v212, v38), v207);
          int8x16_t v215 = vandq_s8(v213, v39);
          float32x4_t v216 = (float32x4_t)veorq_s8(v215, (int8x16_t)vsubq_f32(v209, v205));
          float32x4_t v217 = (float32x4_t)veorq_s8(v215, (int8x16_t)vsubq_f32(v211, v208));
          int8x16_t v218 = vandq_s8(v214, v39);
          float32x4_t v219 = (float32x4_t)veorq_s8(v218, (int8x16_t)vsubq_f32(v210, v206));
          float32x4_t v220 = (float32x4_t)veorq_s8(v218, (int8x16_t)vsubq_f32(v212, v207));
          float16x8_t v221 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
          float32x4_t v222 = vmlaq_f32(v207, v219, v207);
          float32x4_t v223 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
          float32x4_t v224 = vmlaq_f32(v208, v216, v208);
          float32x4_t v225 = vcvt_hight_f32_f16(v17);
          float32x4_t v226 = vmlaq_f32(v206, v220, v206);
          float32x4_t v227 = vcvt_hight_f32_f16(v200);
          float32x4_t v228 = vmlaq_f32(v205, v217, v205);
          float32x4_t v229 = vcvtq_f32_f16(*(float16x4_t *)v200.i8);
          int8x16_t v230 = (int8x16_t)vmulq_f32(v210, v212);
          float32x4_t v231 = vcvtq_f32_f16(*(float16x4_t *)v221.i8);
          float32x4_t v232 = vaddq_f32(v228, v224);
          float32x4_t v233 = vcvt_hight_f32_f16(v221);
          int8x16_t v234 = (int8x16_t)vmulq_f32(v209, v211);
          float32x4_t v235 = vcvtq_f32_f16(*(float16x4_t *)v204.i8);
          float32x4_t v236 = (float32x4_t)vbslq_s8(v213, v39, v234);
          float32x4_t v237 = vcvt_hight_f32_f16(v204);
          float32x4_t v238 = (float32x4_t)vbslq_s8(v214, v39, v230);
          int8x16_t v239 = (int8x16_t)vcgtq_f32(vmulq_f32(v235, v38), v229);
          int8x16_t v240 = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(v232, v236)), vsubq_f32(vaddq_f32(v226, v222), v238));
          int8x16_t v241 = (int8x16_t)vcgtq_f32(vmulq_f32(v237, v38), v227);
          int8x16_t v242 = vbslq_s8((int8x16_t)vcgtzq_f16(v203), v240, (int8x16_t)v199);
          int8x16_t v243 = vandq_s8(v239, v39);
          float32x4_t v244 = (float32x4_t)veorq_s8(v243, (int8x16_t)vsubq_f32(v231, v223));
          float32x4_t v245 = (float32x4_t)veorq_s8(v243, (int8x16_t)vsubq_f32(v235, v229));
          int8x16_t v246 = vandq_s8(v241, v39);
          *unsigned __int8 v198 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v221), vbslq_s8((int8x16_t)vcgtzq_f16(v204), (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(vaddq_f32(vmlaq_f32(v223, v245, v223), vmlaq_f32(v229, v244, v229)), (float32x4_t)vbslq_s8(v239, v39, (int8x16_t)vmulq_f32(v231, v235)))), vsubq_f32(vaddq_f32(vmlaq_f32(v225, (float32x4_t)veorq_s8(v246, (int8x16_t)vsubq_f32(v237, v227)), v225), vmlaq_f32(v227, (float32x4_t)veorq_s8(v246, (int8x16_t)vsubq_f32(v233, v225)), v227)),
                                       (float32x4_t)vbslq_s8(v241, v39, (int8x16_t)vmulq_f32(v233, v237)))),
                        (int8x16_t)v17),
                      (int8x16_t)v200));
          v198[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v202), v242, (int8x16_t)v201));
          a10 += v30;
          v197 -= 4;
          v195 += v36;
        }
        while (v197 > 3);
        a3 = (int8x8_t *)((char *)a3 + v195);
        uint64_t result = (int8x8_t *)((char *)result + v195);
        unint64_t v182 = v182 - v196 + v197;
LABEL_89:
        int8x8_t v34 = v321;
        int8x8_t v32 = v320;
        goto LABEL_90;
      }
      if (v183) {
        break;
      }
      float v184 = (unsigned __int8 *)&a10[v182];
      uint64_t v185 = (int8x16_t *)a10;
      do
        uint64_t v186 = v185++;
      while (v185 <= (int8x16_t *)v184 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v186)) & 0x80) != 0);
      do
      {
        CGAffineTransform v187 = v186;
        uint64_t v186 = (int8x16_t *)((char *)v186 + 4);
      }
      while (v186 <= (int8x16_t *)v184 && !v187->i32[0]);
      if (v187 < (int8x16_t *)v184)
      {
        while (!v187->i8[0])
        {
          CGAffineTransform v187 = (int8x16_t *)((char *)v187 + 1);
          if (v187 >= (int8x16_t *)v184)
          {
            CGAffineTransform v187 = (int8x16_t *)&a10[v182];
            break;
          }
        }
      }
      int64_t v188 = (char *)v187 - a10;
      int64_t v189 = ((char *)v187 - a10) * a14;
      a3 += v189;
      result += v189;
      a10 += v189;
      v182 -= v188;
LABEL_90:
      if (v182 <= 3) {
        goto LABEL_93;
      }
    }
    uint64_t v247 = 0;
    while (1)
    {
      float16x4_t v248 = (int8x16_t *)((char *)result + v247);
      v17.i32[0] = v183;
      uint8x16_t v249 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v250 = (float16x8_t)vdupq_n_s16(0x1C04u);
      float16x8_t v251 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v249.i8)), v250);
      float16x8_t v252 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v249)), v250);
      float16x8_t v17 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v252)), v40, vrev16q_s8(*(int8x16_t *)&result[2].i8[v247]));
      float16x8_t v253 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v251)), v40, vrev16q_s8(*(int8x16_t *)&result->i8[v247]));
      float16x8_t v254 = vmulq_f16(v251, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v247]), v23), v26));
      float16x8_t v255 = vmulq_f16(v252, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v247]), v23), v26));
      float16x8_t v256 = (float16x8_t)vqtbl1q_s8((int8x16_t)v255, (int8x16_t)xmmword_1850CD880);
      float16x8_t v257 = (float16x8_t)vqtbl1q_s8((int8x16_t)v254, (int8x16_t)xmmword_1850CD880);
      float16x8_t v258 = (float16x8_t)vqtbl1q_s8((int8x16_t)v253, (int8x16_t)xmmword_1850CD880);
      float32x4_t v259 = vcvtq_f32_f16(*(float16x4_t *)v254.i8);
      float32x4_t v260 = vcvt_hight_f32_f16(v254);
      float32x4_t v261 = vcvt_hight_f32_f16(v253);
      float32x4_t v262 = vcvtq_f32_f16(*(float16x4_t *)v253.i8);
      float32x4_t v263 = vcvtq_f32_f16(*(float16x4_t *)v257.i8);
      float32x4_t v264 = vcvt_hight_f32_f16(v257);
      float32x4_t v265 = vcvtq_f32_f16(*(float16x4_t *)v258.i8);
      float32x4_t v266 = vcvt_hight_f32_f16(v258);
      int8x16_t v267 = (int8x16_t)vcgtq_f32(vmulq_f32(v265, v38), v262);
      int8x16_t v268 = (int8x16_t)vcgtq_f32(vmulq_f32(v266, v38), v261);
      int8x16_t v269 = vandq_s8(v267, v39);
      float32x4_t v270 = (float32x4_t)veorq_s8(v269, (int8x16_t)vsubq_f32(v263, v259));
      float32x4_t v271 = (float32x4_t)veorq_s8(v269, (int8x16_t)vsubq_f32(v265, v262));
      int8x16_t v272 = vandq_s8(v268, v39);
      float32x4_t v273 = (float32x4_t)veorq_s8(v272, (int8x16_t)vsubq_f32(v264, v260));
      float32x4_t v274 = (float32x4_t)veorq_s8(v272, (int8x16_t)vsubq_f32(v266, v261));
      float16x8_t v275 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
      float32x4_t v276 = vmlaq_f32(v261, v273, v261);
      float32x4_t v277 = vcvtq_f32_f16(*(float16x4_t *)v255.i8);
      float32x4_t v278 = vmlaq_f32(v262, v270, v262);
      float32x4_t v279 = vcvt_hight_f32_f16(v255);
      float32x4_t v280 = vmlaq_f32(v260, v274, v260);
      float32x4_t v281 = vcvt_hight_f32_f16(v17);
      float32x4_t v282 = vmlaq_f32(v259, v271, v259);
      float32x4_t v283 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
      float32x4_t v284 = vaddq_f32(v282, v278);
      float32x4_t v285 = vcvtq_f32_f16(*(float16x4_t *)v256.i8);
      float32x4_t v286 = vaddq_f32(v280, v276);
      float32x4_t v287 = vcvt_hight_f32_f16(v256);
      int8x16_t v288 = (int8x16_t)vmulq_f32(v264, v266);
      float32x4_t v289 = vcvtq_f32_f16(*(float16x4_t *)v275.i8);
      int8x16_t v290 = (int8x16_t)vmulq_f32(v263, v265);
      float32x4_t v291 = vcvt_hight_f32_f16(v275);
      float32x4_t v292 = (float32x4_t)vbslq_s8(v267, v39, v290);
      float32x4_t v293 = (float32x4_t)vbslq_s8(v268, v39, v288);
      int8x16_t v294 = (int8x16_t)vcgtq_f32(vmulq_f32(v289, v38), v283);
      int8x16_t v295 = (int8x16_t)vcgtq_f32(vmulq_f32(v291, v38), v281);
      int8x16_t v296 = vbslq_s8((int8x16_t)vcgtzq_f16(v258), (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(v284, v292)), vsubq_f32(v286, v293)), (int8x16_t)v254);
      int8x16_t v297 = vandq_s8(v294, v39);
      float32x4_t v298 = (float32x4_t)veorq_s8(v297, (int8x16_t)vsubq_f32(v285, v277));
      float32x4_t v299 = (float32x4_t)veorq_s8(v297, (int8x16_t)vsubq_f32(v289, v283));
      int8x16_t v300 = vandq_s8(v295, v39);
      int8x16_t *v248 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v257), v296, (int8x16_t)v253));
      v248[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v256), vbslq_s8((int8x16_t)vcgtzq_f16(v275), (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vsubq_f32(vaddq_f32(vmlaq_f32(v277, v299, v277), vmlaq_f32(v283, v298, v283)), (float32x4_t)vbslq_s8(v294, v39, (int8x16_t)vmulq_f32(v285, v289)))), vsubq_f32(vaddq_f32(vmlaq_f32(v279, (float32x4_t)veorq_s8(v300, (int8x16_t)vsubq_f32(v291, v281)), v279), vmlaq_f32(v281, (float32x4_t)veorq_s8(v300, (int8x16_t)vsubq_f32(v287, v279)), v281)),
                                     (float32x4_t)vbslq_s8(v295, v39, (int8x16_t)vmulq_f32(v287, v291)))),
                      (int8x16_t)v255),
                    (int8x16_t)v17));
      a10 += v30;
      v182 -= 4;
      if (v182 < 4) {
        break;
      }
      __int32 v183 = *(_DWORD *)a10;
      v247 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v247);
        a3 = (int8x8_t *)((char *)a3 + v247);
        goto LABEL_89;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v247);
    a3 = (int8x8_t *)((char *)a3 + v36 + v247);
    int8x8_t v34 = v321;
    int8x8_t v32 = v320;
LABEL_93:
    for (unint64_t j = a12 - v181 + v182; j; --j)
    {
      if (*a10)
      {
        float16x4_t v302 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v303 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v302)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v304 = vmul_f16(v302, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v305 = (float16x4_t)vdup_lane_s16((int16x4_t)v304, 3);
        float16x4_t v306 = (float16x4_t)vdup_lane_s16((int16x4_t)v303, 3);
        *(int16x4_t *)v17.i8 = vcgtz_f16(v306);
        int8x8_t v307 = (int8x8_t)vcgtz_f16(v305);
        float32x4_t v308 = vcvtq_f32_f16(v304);
        float32x4_t v309 = vcvtq_f32_f16(v303);
        float32x4_t v310 = vcvtq_f32_f16(v305);
        float32x4_t v311 = vcvtq_f32_f16(v306);
        int8x16_t v312 = (int8x16_t)vcgtq_f32(vmulq_f32(v311, v38), v309);
        int8x16_t v313 = vandq_s8(v312, v39);
        int *result = vrev16_s8(vbsl_s8(v307, vbsl_s8(*(int8x8_t *)v17.i8, (int8x8_t)vcvt_f16_f32(vsubq_f32(vaddq_f32(vmlaq_f32(v308, (float32x4_t)veorq_s8(v313, (int8x16_t)vsubq_f32(v311, v309)), v308), vmlaq_f32(v309, (float32x4_t)veorq_s8(v313, (int8x16_t)vsubq_f32(v310, v308)), v309)), (float32x4_t)vbslq_s8(v312, v39, (int8x16_t)vmulq_f32(v311, v310)))), (int8x8_t)v304), (int8x8_t)v303));
      }
      uint64_t v314 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v314 >= a8) {
        uint64_t v315 = -(uint64_t)a7;
      }
      else {
        uint64_t v315 = 0;
      }
      a3 = &v314[v315];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    int v316 = &a5[a4];
    if ((unint64_t)v316 >= a9) {
      uint64_t v317 = v35;
    }
    else {
      uint64_t v317 = 0;
    }
    unsigned int v318 = &v316[v317];
    uint64_t v319 = a8 + 8 * v317 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v318;
      a8 = v319;
      a5 = v318;
    }
    BOOL v180 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v180 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)17,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = (int8x16_t)vdupq_n_s16(v24);
  int8x16_t v26 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  int8x16_t v27 = vandq_s8(v25, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v25, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v24;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  float16x8_t v39 = (float16x8_t)vdupq_n_s16(0x1C04u);
  v40.i64[0] = 0x3C003C003C003C00;
  v40.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 3;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v43 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v50 = (unsigned __int8 *)&a10[v42];
          int64_t v51 = (int8x16_t *)a10;
          do
            int8x16_t v52 = v51++;
          while (v51 <= (int8x16_t *)v50 && (vminvq_u8((uint8x16_t)vceqq_s8(*v52, v38)) & 0x80) != 0);
          do
          {
            uint64_t v53 = v52;
            int8x16_t v52 = (int8x16_t *)((char *)v52 + 4);
          }
          while (v52 <= (int8x16_t *)v50 && v53->i32[0] == -1);
          if (v53 < (int8x16_t *)v50)
          {
            while (v53->u8[0] == 255)
            {
              uint64_t v53 = (int8x16_t *)((char *)v53 + 1);
              if (v53 >= (int8x16_t *)v50)
              {
                uint64_t v53 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          uint64_t v54 = 0;
          int64_t v55 = (char *)v53 - a10;
          unint64_t v56 = (char *)v53 - a10;
          do
          {
            unint64_t v57 = (int8x16_t *)((char *)result + v54);
            float16x8_t v58 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v54], v23), v26);
            float16x8_t v59 = (float16x8_t)vqtbl1q_s8((int8x16_t)v58, (int8x16_t)xmmword_1850CD880);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v54], v23), v26);
            float16x8_t v61 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float16x8_t v62 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v54], v28), v29);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v62, (int8x16_t)xmmword_1850CD880);
            float16x8_t v64 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v54], v28), v29);
            float16x8_t v65 = (float16x8_t)vqtbl1q_s8((int8x16_t)v64, (int8x16_t)xmmword_1850CD880);
            int8x16_t v66 = (int8x16_t)vcgtzq_f16(v61);
            int8x16_t v67 = (int8x16_t)vcgtzq_f16(v59);
            float16x8_t v68 = vmaxnmq_f16(vmulq_f16(v61, v62), vmulq_f16(v63, v60));
            float16x8_t v69 = vmlsq_f16(v62, v62, v61);
            float16x8_t v70 = vaddq_f16(vmaxnmq_f16(vmulq_f16(v59, v64), vmulq_f16(v65, v58)), vmlsq_f16(v64, v64, v59));
            int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v60, v60, v63), vaddq_f16(v68, v69));
            int8x16_t *v57 = vbslq_s8(v66, vbslq_s8((int8x16_t)vcgtzq_f16(v63), v17, (int8x16_t)v60), (int8x16_t)v62);
            v57[1] = vbslq_s8(v67, vbslq_s8((int8x16_t)vcgtzq_f16(v65), (int8x16_t)vaddq_f16(vmlsq_f16(v58, v58, v65), v70), (int8x16_t)v58), (int8x16_t)v64);
            a10 += v30;
            v56 -= 4;
            v54 += v36;
          }
          while (v56 > 3);
          a3 = (int8x8_t *)((char *)a3 + v54);
          uint64_t result = (int8x8_t *)((char *)result + v54);
          unint64_t v42 = v42 - v55 + v56;
          goto LABEL_39;
        }
        if (v43) {
          break;
        }
        unint64_t v44 = (unsigned __int8 *)&a10[v42];
        __int32 v45 = (int8x16_t *)a10;
        do
          uint8x16_t v46 = v45++;
        while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
        do
        {
          uint8x16_t v47 = v46;
          uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= (int8x16_t *)v44 && !v47->i32[0]);
        if (v47 < (int8x16_t *)v44)
        {
          while (!v47->i8[0])
          {
            uint8x16_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= (int8x16_t *)v44)
            {
              uint8x16_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        int64_t v48 = (char *)v47 - a10;
        int64_t v49 = ((char *)v47 - a10) * a14;
        a3 += v49;
        result += v49;
        a10 += v49;
        v42 -= v48;
LABEL_39:
        if (v42 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v71 = 0;
      while (1)
      {
        float32x4_t v72 = (int8x16_t *)((char *)result + v71);
        v17.i32[0] = v43;
        uint8x16_t v73 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v74 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v73.i8));
        float16x8_t v75 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v73)), v39);
        float16x8_t v76 = vmulq_f16(v74, v39);
        float16x8_t v77 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v76)), v40, *(int8x16_t *)&result->i8[v71]);
        float16x8_t v78 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v75)), v40, *(int8x16_t *)&result[2].i8[v71]);
        float16x8_t v79 = vmulq_f16(v75, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v71], v23), v26));
        float16x8_t v80 = vmulq_f16(v76, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v71], v23), v26));
        float16x8_t v81 = (float16x8_t)vqtbl1q_s8((int8x16_t)v80, (int8x16_t)xmmword_1850CD880);
        float16x8_t v82 = (float16x8_t)vqtbl1q_s8((int8x16_t)v79, (int8x16_t)xmmword_1850CD880);
        float16x8_t v83 = (float16x8_t)vqtbl1q_s8((int8x16_t)v78, (int8x16_t)xmmword_1850CD880);
        float16x8_t v84 = (float16x8_t)vqtbl1q_s8((int8x16_t)v77, (int8x16_t)xmmword_1850CD880);
        int8x16_t v85 = (int8x16_t)vcgtzq_f16(v81);
        float16x8_t v86 = vmaxnmq_f16(vmulq_f16(v81, v77), vmulq_f16(v80, v84));
        float16x8_t v87 = vmlsq_f16(v77, v77, v81);
        int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v79, v79, v83), vaddq_f16(vmaxnmq_f16(vmulq_f16(v82, v78), vmulq_f16(v79, v83)), vmlsq_f16(v78, v78, v82)));
        *float32x4_t v72 = vbslq_s8(v85, vbslq_s8((int8x16_t)vcgtzq_f16(v84), (int8x16_t)vaddq_f16(vmlsq_f16(v80, v80, v84), vaddq_f16(v86, v87)), (int8x16_t)v80), (int8x16_t)v77);
        v72[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v82), vbslq_s8((int8x16_t)vcgtzq_f16(v83), v17, (int8x16_t)v79), (int8x16_t)v78);
        a10 += v30;
        v42 -= 4;
        if (v42 < 4) {
          break;
        }
        __int32 v43 = *(_DWORD *)a10;
        v71 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v71);
          a3 = (int8x8_t *)((char *)a3 + v71);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v71);
      a3 = (int8x8_t *)((char *)a3 + v36 + v71);
LABEL_42:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float16x4_t v89 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v90 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v89)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v91 = vmul_f16(v89, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          int *result = vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v91, 3)), vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v90, 3)), (int8x8_t)vadd_f16(vmls_lane_f16(v91, v91, v90, 3), vadd_f16(vmaxnm_f16(vmul_lane_f16(v90, v91, 3), vmul_lane_f16(v91, v90, 3)), vmls_lane_f16(v90, v90, v91, 3))), (int8x8_t)v91), (int8x8_t)v90);
        }
        int8x16_t v92 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v92 >= a8) {
          uint64_t v93 = -(uint64_t)a7;
        }
        else {
          uint64_t v93 = 0;
        }
        a3 = &v92[v93];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      int8x16_t v94 = &a5[a4];
      if ((unint64_t)v94 >= a9) {
        uint64_t v95 = v35;
      }
      else {
        uint64_t v95 = 0;
      }
      float32x4_t v96 = &v94[v95];
      uint64_t v97 = a8 + 8 * v95 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v96;
        a8 = v97;
        a5 = v96;
      }
      BOOL v98 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v98 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v99 = (a8 - (unint64_t)a3) >> 3;
    if (v99 >= a12) {
      unint64_t v99 = a12;
    }
    unint64_t v100 = v99;
    if (v99 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v101 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        uint8x16_t v108 = (unsigned __int8 *)&a10[v100];
        uint8x16_t v109 = (int8x16_t *)a10;
        do
          float16x8_t v110 = v109++;
        while (v109 <= (int8x16_t *)v108 && (vminvq_u8((uint8x16_t)vceqq_s8(*v110, v38)) & 0x80) != 0);
        do
        {
          float16x8_t v111 = v110;
          float16x8_t v110 = (int8x16_t *)((char *)v110 + 4);
        }
        while (v110 <= (int8x16_t *)v108 && v111->i32[0] == -1);
        if (v111 < (int8x16_t *)v108)
        {
          while (v111->u8[0] == 255)
          {
            float16x8_t v111 = (int8x16_t *)((char *)v111 + 1);
            if (v111 >= (int8x16_t *)v108)
            {
              float16x8_t v111 = (int8x16_t *)&a10[v100];
              break;
            }
          }
        }
        uint64_t v112 = 0;
        int64_t v113 = (char *)v111 - a10;
        unint64_t v114 = (char *)v111 - a10;
        do
        {
          float16x8_t v115 = (int8x16_t *)((char *)result + v112);
          float16x8_t v116 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v112]), v23), v26);
          float16x8_t v117 = (float16x8_t)vqtbl1q_s8((int8x16_t)v116, (int8x16_t)xmmword_1850CD880);
          float16x8_t v118 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v112]), v23), v26);
          float16x8_t v119 = (float16x8_t)vqtbl1q_s8((int8x16_t)v118, (int8x16_t)xmmword_1850CD880);
          float16x8_t v120 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v112]), v28), v29);
          float16x8_t v121 = (float16x8_t)vqtbl1q_s8((int8x16_t)v120, (int8x16_t)xmmword_1850CD880);
          float16x8_t v122 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v112]), v28), v29);
          float16x8_t v123 = (float16x8_t)vqtbl1q_s8((int8x16_t)v122, (int8x16_t)xmmword_1850CD880);
          int8x16_t v124 = (int8x16_t)vcgtzq_f16(v117);
          float16x8_t v125 = vmaxnmq_f16(vmulq_f16(v117, v122), vmulq_f16(v123, v116));
          float16x8_t v126 = vmlsq_f16(v122, v122, v117);
          int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v118, v118, v121), vaddq_f16(vmaxnmq_f16(vmulq_f16(v119, v120), vmulq_f16(v121, v118)), vmlsq_f16(v120, v120, v119)));
          *float16x8_t v115 = vrev16q_s8(vbslq_s8(v124, vbslq_s8((int8x16_t)vcgtzq_f16(v123), (int8x16_t)vaddq_f16(vmlsq_f16(v116, v116, v123), vaddq_f16(v125, v126)), (int8x16_t)v116), (int8x16_t)v122));
          v115[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v119), vbslq_s8((int8x16_t)vcgtzq_f16(v121), v17, (int8x16_t)v118), (int8x16_t)v120));
          a10 += v30;
          v114 -= 4;
          v112 += v36;
        }
        while (v114 > 3);
        a3 = (int8x8_t *)((char *)a3 + v112);
        uint64_t result = (int8x8_t *)((char *)result + v112);
        unint64_t v100 = v100 - v113 + v114;
        goto LABEL_88;
      }
      if (v101) {
        break;
      }
      int8x16_t v102 = (unsigned __int8 *)&a10[v100];
      int8x16_t v103 = (int8x16_t *)a10;
      do
        float32x4_t v104 = v103++;
      while (v103 <= (int8x16_t *)v102 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v104)) & 0x80) != 0);
      do
      {
        float32x4_t v105 = v104;
        float32x4_t v104 = (int8x16_t *)((char *)v104 + 4);
      }
      while (v104 <= (int8x16_t *)v102 && !v105->i32[0]);
      if (v105 < (int8x16_t *)v102)
      {
        while (!v105->i8[0])
        {
          float32x4_t v105 = (int8x16_t *)((char *)v105 + 1);
          if (v105 >= (int8x16_t *)v102)
          {
            float32x4_t v105 = (int8x16_t *)&a10[v100];
            break;
          }
        }
      }
      int64_t v106 = (char *)v105 - a10;
      int64_t v107 = ((char *)v105 - a10) * a14;
      a3 += v107;
      result += v107;
      a10 += v107;
      v100 -= v106;
LABEL_88:
      if (v100 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v127 = 0;
    while (1)
    {
      int8x16_t v128 = (int8x16_t *)((char *)result + v127);
      v17.i32[0] = v101;
      uint8x16_t v129 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v130 = vcvtq_f16_u16(vmovl_high_u8(v129));
      float16x8_t v131 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v129.i8)), v39);
      float16x8_t v132 = vmulq_f16(v130, v39);
      float16x8_t v133 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v132)), v40, vrev16q_s8(*(int8x16_t *)&result[2].i8[v127]));
      float16x8_t v134 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v131)), v40, vrev16q_s8(*(int8x16_t *)&result->i8[v127]));
      float16x8_t v135 = vmulq_f16(v131, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v127]), v23), v26));
      float16x8_t v136 = vmulq_f16(v132, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v127]), v23), v26));
      float16x8_t v137 = (float16x8_t)vqtbl1q_s8((int8x16_t)v136, (int8x16_t)xmmword_1850CD880);
      float16x8_t v138 = (float16x8_t)vqtbl1q_s8((int8x16_t)v135, (int8x16_t)xmmword_1850CD880);
      float16x8_t v139 = (float16x8_t)vqtbl1q_s8((int8x16_t)v134, (int8x16_t)xmmword_1850CD880);
      float16x8_t v140 = (float16x8_t)vqtbl1q_s8((int8x16_t)v133, (int8x16_t)xmmword_1850CD880);
      int8x16_t v141 = (int8x16_t)vcgtzq_f16(v138);
      int8x16_t v142 = (int8x16_t)vcgtzq_f16(v137);
      float16x8_t v143 = vmaxnmq_f16(vmulq_f16(v138, v134), vmulq_f16(v135, v139));
      float16x8_t v144 = vmlsq_f16(v134, v134, v138);
      float16x8_t v145 = vaddq_f16(vmaxnmq_f16(vmulq_f16(v137, v133), vmulq_f16(v136, v140)), vmlsq_f16(v133, v133, v137));
      int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v135, v135, v139), vaddq_f16(v143, v144));
      int8x16_t *v128 = vrev16q_s8(vbslq_s8(v141, vbslq_s8((int8x16_t)vcgtzq_f16(v139), v17, (int8x16_t)v135), (int8x16_t)v134));
      v128[1] = vrev16q_s8(vbslq_s8(v142, vbslq_s8((int8x16_t)vcgtzq_f16(v140), (int8x16_t)vaddq_f16(vmlsq_f16(v136, v136, v140), v145), (int8x16_t)v136), (int8x16_t)v133));
      a10 += v30;
      v100 -= 4;
      if (v100 < 4) {
        break;
      }
      __int32 v101 = *(_DWORD *)a10;
      v127 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v127);
        a3 = (int8x8_t *)((char *)a3 + v127);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v127);
    a3 = (int8x8_t *)((char *)a3 + v36 + v127);
LABEL_91:
    for (unint64_t j = a12 - v99 + v100; j; --j)
    {
      if (*a10)
      {
        float16x4_t v147 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v148 = vmul_f16(v147, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v149 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v147)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        int *result = vrev16_s8(vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v148, 3)), vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v149, 3)), (int8x8_t)vadd_f16(vmls_lane_f16(v148, v148, v149, 3), vadd_f16(vmaxnm_f16(vmul_lane_f16(v149, v148, 3), vmul_lane_f16(v148, v149, 3)), vmls_lane_f16(v149, v149, v148, 3))), (int8x8_t)v148), (int8x8_t)v149));
      }
      int8x16_t v150 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v150 >= a8) {
        uint64_t v151 = -(uint64_t)a7;
      }
      else {
        uint64_t v151 = 0;
      }
      a3 = &v150[v151];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    float32x4_t v152 = &a5[a4];
    if ((unint64_t)v152 >= a9) {
      uint64_t v153 = v35;
    }
    else {
      uint64_t v153 = 0;
    }
    int8x16_t v154 = &v152[v153];
    uint64_t v155 = a8 + 8 * v153 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v154;
      a8 = v155;
      a5 = v154;
    }
    BOOL v98 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v98 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)16,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = (int8x16_t)vdupq_n_s16(v24);
  int8x16_t v26 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  int8x16_t v27 = vandq_s8(v25, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v25, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v24;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  float16x8_t v39 = (float16x8_t)vdupq_n_s16(0x1C04u);
  v40.i64[0] = 0x3C003C003C003C00;
  v40.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 3;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v43 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v50 = (unsigned __int8 *)&a10[v42];
          int64_t v51 = (int8x16_t *)a10;
          do
            int8x16_t v52 = v51++;
          while (v51 <= (int8x16_t *)v50 && (vminvq_u8((uint8x16_t)vceqq_s8(*v52, v38)) & 0x80) != 0);
          do
          {
            uint64_t v53 = v52;
            int8x16_t v52 = (int8x16_t *)((char *)v52 + 4);
          }
          while (v52 <= (int8x16_t *)v50 && v53->i32[0] == -1);
          if (v53 < (int8x16_t *)v50)
          {
            while (v53->u8[0] == 255)
            {
              uint64_t v53 = (int8x16_t *)((char *)v53 + 1);
              if (v53 >= (int8x16_t *)v50)
              {
                uint64_t v53 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          uint64_t v54 = 0;
          int64_t v55 = (char *)v53 - a10;
          unint64_t v56 = (char *)v53 - a10;
          do
          {
            unint64_t v57 = (int8x16_t *)((char *)result + v54);
            float16x8_t v58 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v54], v23), v26);
            float16x8_t v59 = (float16x8_t)vqtbl1q_s8((int8x16_t)v58, (int8x16_t)xmmword_1850CD880);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v54], v23), v26);
            float16x8_t v61 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float16x8_t v62 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v54], v28), v29);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v62, (int8x16_t)xmmword_1850CD880);
            float16x8_t v64 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v54], v28), v29);
            float16x8_t v65 = (float16x8_t)vqtbl1q_s8((int8x16_t)v64, (int8x16_t)xmmword_1850CD880);
            int8x16_t v66 = (int8x16_t)vcgtzq_f16(v61);
            int8x16_t v67 = (int8x16_t)vcgtzq_f16(v59);
            float16x8_t v68 = vminnmq_f16(vmulq_f16(v61, v62), vmulq_f16(v63, v60));
            float16x8_t v69 = vmlsq_f16(v62, v62, v61);
            float16x8_t v70 = vaddq_f16(vminnmq_f16(vmulq_f16(v59, v64), vmulq_f16(v65, v58)), vmlsq_f16(v64, v64, v59));
            int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v60, v60, v63), vaddq_f16(v68, v69));
            int8x16_t *v57 = vbslq_s8(v66, vbslq_s8((int8x16_t)vcgtzq_f16(v63), v17, (int8x16_t)v60), (int8x16_t)v62);
            v57[1] = vbslq_s8(v67, vbslq_s8((int8x16_t)vcgtzq_f16(v65), (int8x16_t)vaddq_f16(vmlsq_f16(v58, v58, v65), v70), (int8x16_t)v58), (int8x16_t)v64);
            a10 += v30;
            v56 -= 4;
            v54 += v36;
          }
          while (v56 > 3);
          a3 = (int8x8_t *)((char *)a3 + v54);
          uint64_t result = (int8x8_t *)((char *)result + v54);
          unint64_t v42 = v42 - v55 + v56;
          goto LABEL_39;
        }
        if (v43) {
          break;
        }
        unint64_t v44 = (unsigned __int8 *)&a10[v42];
        __int32 v45 = (int8x16_t *)a10;
        do
          uint8x16_t v46 = v45++;
        while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
        do
        {
          uint8x16_t v47 = v46;
          uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= (int8x16_t *)v44 && !v47->i32[0]);
        if (v47 < (int8x16_t *)v44)
        {
          while (!v47->i8[0])
          {
            uint8x16_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= (int8x16_t *)v44)
            {
              uint8x16_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        int64_t v48 = (char *)v47 - a10;
        int64_t v49 = ((char *)v47 - a10) * a14;
        a3 += v49;
        result += v49;
        a10 += v49;
        v42 -= v48;
LABEL_39:
        if (v42 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v71 = 0;
      while (1)
      {
        float32x4_t v72 = (int8x16_t *)((char *)result + v71);
        v17.i32[0] = v43;
        uint8x16_t v73 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v74 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v73.i8));
        float16x8_t v75 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v73)), v39);
        float16x8_t v76 = vmulq_f16(v74, v39);
        float16x8_t v77 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v76)), v40, *(int8x16_t *)&result->i8[v71]);
        float16x8_t v78 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v75)), v40, *(int8x16_t *)&result[2].i8[v71]);
        float16x8_t v79 = vmulq_f16(v75, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v71], v23), v26));
        float16x8_t v80 = vmulq_f16(v76, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v71], v23), v26));
        float16x8_t v81 = (float16x8_t)vqtbl1q_s8((int8x16_t)v80, (int8x16_t)xmmword_1850CD880);
        float16x8_t v82 = (float16x8_t)vqtbl1q_s8((int8x16_t)v79, (int8x16_t)xmmword_1850CD880);
        float16x8_t v83 = (float16x8_t)vqtbl1q_s8((int8x16_t)v78, (int8x16_t)xmmword_1850CD880);
        float16x8_t v84 = (float16x8_t)vqtbl1q_s8((int8x16_t)v77, (int8x16_t)xmmword_1850CD880);
        int8x16_t v85 = (int8x16_t)vcgtzq_f16(v81);
        float16x8_t v86 = vminnmq_f16(vmulq_f16(v81, v77), vmulq_f16(v80, v84));
        float16x8_t v87 = vmlsq_f16(v77, v77, v81);
        int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v79, v79, v83), vaddq_f16(vminnmq_f16(vmulq_f16(v82, v78), vmulq_f16(v79, v83)), vmlsq_f16(v78, v78, v82)));
        *float32x4_t v72 = vbslq_s8(v85, vbslq_s8((int8x16_t)vcgtzq_f16(v84), (int8x16_t)vaddq_f16(vmlsq_f16(v80, v80, v84), vaddq_f16(v86, v87)), (int8x16_t)v80), (int8x16_t)v77);
        v72[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v82), vbslq_s8((int8x16_t)vcgtzq_f16(v83), v17, (int8x16_t)v79), (int8x16_t)v78);
        a10 += v30;
        v42 -= 4;
        if (v42 < 4) {
          break;
        }
        __int32 v43 = *(_DWORD *)a10;
        v71 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v71);
          a3 = (int8x8_t *)((char *)a3 + v71);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v71);
      a3 = (int8x8_t *)((char *)a3 + v36 + v71);
LABEL_42:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float16x4_t v89 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v90 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v89)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v91 = vmul_f16(v89, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          int *result = vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v91, 3)), vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v90, 3)), (int8x8_t)vadd_f16(vmls_lane_f16(v91, v91, v90, 3), vadd_f16(vminnm_f16(vmul_lane_f16(v90, v91, 3), vmul_lane_f16(v91, v90, 3)), vmls_lane_f16(v90, v90, v91, 3))), (int8x8_t)v91), (int8x8_t)v90);
        }
        int8x16_t v92 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v92 >= a8) {
          uint64_t v93 = -(uint64_t)a7;
        }
        else {
          uint64_t v93 = 0;
        }
        a3 = &v92[v93];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      int8x16_t v94 = &a5[a4];
      if ((unint64_t)v94 >= a9) {
        uint64_t v95 = v35;
      }
      else {
        uint64_t v95 = 0;
      }
      float32x4_t v96 = &v94[v95];
      uint64_t v97 = a8 + 8 * v95 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v96;
        a8 = v97;
        a5 = v96;
      }
      BOOL v98 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v98 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v99 = (a8 - (unint64_t)a3) >> 3;
    if (v99 >= a12) {
      unint64_t v99 = a12;
    }
    unint64_t v100 = v99;
    if (v99 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v101 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        uint8x16_t v108 = (unsigned __int8 *)&a10[v100];
        uint8x16_t v109 = (int8x16_t *)a10;
        do
          float16x8_t v110 = v109++;
        while (v109 <= (int8x16_t *)v108 && (vminvq_u8((uint8x16_t)vceqq_s8(*v110, v38)) & 0x80) != 0);
        do
        {
          float16x8_t v111 = v110;
          float16x8_t v110 = (int8x16_t *)((char *)v110 + 4);
        }
        while (v110 <= (int8x16_t *)v108 && v111->i32[0] == -1);
        if (v111 < (int8x16_t *)v108)
        {
          while (v111->u8[0] == 255)
          {
            float16x8_t v111 = (int8x16_t *)((char *)v111 + 1);
            if (v111 >= (int8x16_t *)v108)
            {
              float16x8_t v111 = (int8x16_t *)&a10[v100];
              break;
            }
          }
        }
        uint64_t v112 = 0;
        int64_t v113 = (char *)v111 - a10;
        unint64_t v114 = (char *)v111 - a10;
        do
        {
          float16x8_t v115 = (int8x16_t *)((char *)result + v112);
          float16x8_t v116 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v112]), v23), v26);
          float16x8_t v117 = (float16x8_t)vqtbl1q_s8((int8x16_t)v116, (int8x16_t)xmmword_1850CD880);
          float16x8_t v118 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v112]), v23), v26);
          float16x8_t v119 = (float16x8_t)vqtbl1q_s8((int8x16_t)v118, (int8x16_t)xmmword_1850CD880);
          float16x8_t v120 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v112]), v28), v29);
          float16x8_t v121 = (float16x8_t)vqtbl1q_s8((int8x16_t)v120, (int8x16_t)xmmword_1850CD880);
          float16x8_t v122 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v112]), v28), v29);
          float16x8_t v123 = (float16x8_t)vqtbl1q_s8((int8x16_t)v122, (int8x16_t)xmmword_1850CD880);
          int8x16_t v124 = (int8x16_t)vcgtzq_f16(v117);
          float16x8_t v125 = vminnmq_f16(vmulq_f16(v117, v122), vmulq_f16(v123, v116));
          float16x8_t v126 = vmlsq_f16(v122, v122, v117);
          int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v118, v118, v121), vaddq_f16(vminnmq_f16(vmulq_f16(v119, v120), vmulq_f16(v121, v118)), vmlsq_f16(v120, v120, v119)));
          *float16x8_t v115 = vrev16q_s8(vbslq_s8(v124, vbslq_s8((int8x16_t)vcgtzq_f16(v123), (int8x16_t)vaddq_f16(vmlsq_f16(v116, v116, v123), vaddq_f16(v125, v126)), (int8x16_t)v116), (int8x16_t)v122));
          v115[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v119), vbslq_s8((int8x16_t)vcgtzq_f16(v121), v17, (int8x16_t)v118), (int8x16_t)v120));
          a10 += v30;
          v114 -= 4;
          v112 += v36;
        }
        while (v114 > 3);
        a3 = (int8x8_t *)((char *)a3 + v112);
        uint64_t result = (int8x8_t *)((char *)result + v112);
        unint64_t v100 = v100 - v113 + v114;
        goto LABEL_88;
      }
      if (v101) {
        break;
      }
      int8x16_t v102 = (unsigned __int8 *)&a10[v100];
      int8x16_t v103 = (int8x16_t *)a10;
      do
        float32x4_t v104 = v103++;
      while (v103 <= (int8x16_t *)v102 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v104)) & 0x80) != 0);
      do
      {
        float32x4_t v105 = v104;
        float32x4_t v104 = (int8x16_t *)((char *)v104 + 4);
      }
      while (v104 <= (int8x16_t *)v102 && !v105->i32[0]);
      if (v105 < (int8x16_t *)v102)
      {
        while (!v105->i8[0])
        {
          float32x4_t v105 = (int8x16_t *)((char *)v105 + 1);
          if (v105 >= (int8x16_t *)v102)
          {
            float32x4_t v105 = (int8x16_t *)&a10[v100];
            break;
          }
        }
      }
      int64_t v106 = (char *)v105 - a10;
      int64_t v107 = ((char *)v105 - a10) * a14;
      a3 += v107;
      result += v107;
      a10 += v107;
      v100 -= v106;
LABEL_88:
      if (v100 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v127 = 0;
    while (1)
    {
      int8x16_t v128 = (int8x16_t *)((char *)result + v127);
      v17.i32[0] = v101;
      uint8x16_t v129 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v130 = vcvtq_f16_u16(vmovl_high_u8(v129));
      float16x8_t v131 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v129.i8)), v39);
      float16x8_t v132 = vmulq_f16(v130, v39);
      float16x8_t v133 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v132)), v40, vrev16q_s8(*(int8x16_t *)&result[2].i8[v127]));
      float16x8_t v134 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v131)), v40, vrev16q_s8(*(int8x16_t *)&result->i8[v127]));
      float16x8_t v135 = vmulq_f16(v131, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v127]), v23), v26));
      float16x8_t v136 = vmulq_f16(v132, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v127]), v23), v26));
      float16x8_t v137 = (float16x8_t)vqtbl1q_s8((int8x16_t)v136, (int8x16_t)xmmword_1850CD880);
      float16x8_t v138 = (float16x8_t)vqtbl1q_s8((int8x16_t)v135, (int8x16_t)xmmword_1850CD880);
      float16x8_t v139 = (float16x8_t)vqtbl1q_s8((int8x16_t)v134, (int8x16_t)xmmword_1850CD880);
      float16x8_t v140 = (float16x8_t)vqtbl1q_s8((int8x16_t)v133, (int8x16_t)xmmword_1850CD880);
      int8x16_t v141 = (int8x16_t)vcgtzq_f16(v138);
      int8x16_t v142 = (int8x16_t)vcgtzq_f16(v137);
      float16x8_t v143 = vminnmq_f16(vmulq_f16(v138, v134), vmulq_f16(v135, v139));
      float16x8_t v144 = vmlsq_f16(v134, v134, v138);
      float16x8_t v145 = vaddq_f16(vminnmq_f16(vmulq_f16(v137, v133), vmulq_f16(v136, v140)), vmlsq_f16(v133, v133, v137));
      int8x16_t v17 = (int8x16_t)vaddq_f16(vmlsq_f16(v135, v135, v139), vaddq_f16(v143, v144));
      int8x16_t *v128 = vrev16q_s8(vbslq_s8(v141, vbslq_s8((int8x16_t)vcgtzq_f16(v139), v17, (int8x16_t)v135), (int8x16_t)v134));
      v128[1] = vrev16q_s8(vbslq_s8(v142, vbslq_s8((int8x16_t)vcgtzq_f16(v140), (int8x16_t)vaddq_f16(vmlsq_f16(v136, v136, v140), v145), (int8x16_t)v136), (int8x16_t)v133));
      a10 += v30;
      v100 -= 4;
      if (v100 < 4) {
        break;
      }
      __int32 v101 = *(_DWORD *)a10;
      v127 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v127);
        a3 = (int8x8_t *)((char *)a3 + v127);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v127);
    a3 = (int8x8_t *)((char *)a3 + v36 + v127);
LABEL_91:
    for (unint64_t j = a12 - v99 + v100; j; --j)
    {
      if (*a10)
      {
        float16x4_t v147 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v148 = vmul_f16(v147, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v149 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v147)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        int *result = vrev16_s8(vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v148, 3)), vbsl_s8((int8x8_t)vcgtz_f16((float16x4_t)vdup_lane_s16((int16x4_t)v149, 3)), (int8x8_t)vadd_f16(vmls_lane_f16(v148, v148, v149, 3), vadd_f16(vminnm_f16(vmul_lane_f16(v149, v148, 3), vmul_lane_f16(v148, v149, 3)), vmls_lane_f16(v149, v149, v148, 3))), (int8x8_t)v148), (int8x8_t)v149));
      }
      int8x16_t v150 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v150 >= a8) {
        uint64_t v151 = -(uint64_t)a7;
      }
      else {
        uint64_t v151 = 0;
      }
      a3 = &v150[v151];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    float32x4_t v152 = &a5[a4];
    if ((unint64_t)v152 >= a9) {
      uint64_t v153 = v35;
    }
    else {
      uint64_t v153 = 0;
    }
    int8x16_t v154 = &v152[v153];
    uint64_t v155 = a8 + 8 * v153 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v154;
      a8 = v155;
      a5 = v154;
    }
    BOOL v98 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v98 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)19,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  int8x16_t v24 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  if (a15) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = (int8x16_t)vdupq_n_s16(v25);
  int8x16_t v27 = vandq_s8(v26, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v26, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  int8x8_t v34 = 0;
  v34.i16[3] = v25;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  v39.i64[0] = 0x3C003C003C003C00;
  v39.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v40 = (a8 - (unint64_t)a3) >> 3;
      if (v40 >= a12) {
        unint64_t v40 = a12;
      }
      unint64_t v41 = v40;
      if (v40 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v42 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v49 = (unsigned __int8 *)&a10[v41];
          int64_t v50 = (int8x16_t *)a10;
          do
            int64_t v51 = v50++;
          while (v50 <= (int8x16_t *)v49 && (vminvq_u8((uint8x16_t)vceqq_s8(*v51, v38)) & 0x80) != 0);
          do
          {
            int8x16_t v52 = v51;
            int64_t v51 = (int8x16_t *)((char *)v51 + 4);
          }
          while (v51 <= (int8x16_t *)v49 && v52->i32[0] == -1);
          if (v52 < (int8x16_t *)v49)
          {
            while (v52->u8[0] == 255)
            {
              int8x16_t v52 = (int8x16_t *)((char *)v52 + 1);
              if (v52 >= (int8x16_t *)v49)
              {
                int8x16_t v52 = (int8x16_t *)&a10[v41];
                break;
              }
            }
          }
          uint64_t v53 = 0;
          int64_t v54 = (char *)v52 - a10;
          unint64_t v55 = (char *)v52 - a10;
          do
          {
            unint64_t v56 = (int8x16_t *)((char *)result + v53);
            float16x8_t v57 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v53], v23), v24);
            float16x8_t v58 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v53], v23), v24);
            float16x8_t v59 = (float16x8_t)vqtbl1q_s8((int8x16_t)v57, (int8x16_t)xmmword_1850CD880);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v53], v28), v29);
            float16x8_t v61 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float16x8_t v62 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v53], v28), v29);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v62, (int8x16_t)xmmword_1850CD880);
            float16x8_t v64 = (float16x8_t)vqtbl1q_s8((int8x16_t)v58, (int8x16_t)xmmword_1850CD880);
            float16x8_t v65 = vaddq_f16(vmlsq_f16(v58, v58, v63), vaddq_f16(vmulq_f16(v64, v63), vmlsq_f16(v62, v62, v64)));
            float32x4_t v66 = vcvt_hight_f32_f16(v64);
            float32x4_t v67 = vdivq_f32(vmulq_f32(v66, v66), vcvt_hight_f32_f16(v58));
            float32x4_t v68 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v65), vcvt_hight_f32_f16(v63), v67), vcvt_hight_f32_f16(v62), v67);
            float16x8_t v69 = vaddq_f16(vmlsq_f16(v57, v57, v61), vaddq_f16(vmulq_f16(v59, v61), vmlsq_f16(v60, v60, v59)));
            float32x4_t v70 = vcvtq_f32_f16(*(float16x4_t *)v64.i8);
            float32x4_t v71 = vdivq_f32(vmulq_f32(v70, v70), vcvtq_f32_f16(*(float16x4_t *)v58.i8));
            float32x4_t v72 = vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v65.i8), vcvtq_f32_f16(*(float16x4_t *)v63.i8), v71), vcvtq_f32_f16(*(float16x4_t *)v62.i8), v71);
            float32x4_t v73 = vcvt_hight_f32_f16(v59);
            float32x4_t v74 = vdivq_f32(vmulq_f32(v73, v73), vcvt_hight_f32_f16(v57));
            float32x4_t v75 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v69), vcvt_hight_f32_f16(v61), v74), vcvt_hight_f32_f16(v60), v74);
            float32x4_t v76 = vcvtq_f32_f16(*(float16x4_t *)v59.i8);
            float32x4_t v77 = vdivq_f32(vmulq_f32(v76, v76), vcvtq_f32_f16(*(float16x4_t *)v57.i8));
            float16x8_t v78 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v69.i8), vcvtq_f32_f16(*(float16x4_t *)v61.i8), v77), vcvtq_f32_f16(*(float16x4_t *)v60.i8), v77)), v75);
            int8x16_t v79 = (int8x16_t)vcgtzq_f16(v61);
            int8x16_t v80 = vbslq_s8((int8x16_t)vcgtzq_f16(v59), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f16(v78, (float16x8_t)0), vbicq_s8(v79, (int8x16_t)vceqzq_f16(v57))), vbicq_s8((int8x16_t)v57, v79)), (int8x16_t)v60);
            int8x16_t v81 = (int8x16_t)vcgtzq_f16(v63);
            int8x16_t v17 = vandq_s8((int8x16_t)vmaxnmq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v72), v68), (float16x8_t)0), vbicq_s8(v81, (int8x16_t)vceqzq_f16(v58)));
            int8x16_t *v56 = vbslq_s8((int8x16_t)vcgtzq_f16(v64), vorrq_s8(v17, vbicq_s8((int8x16_t)v58, v81)), (int8x16_t)v62);
            v56[1] = v80;
            a10 += v30;
            v55 -= 4;
            v53 += v36;
          }
          while (v55 > 3);
          a3 = (int8x8_t *)((char *)a3 + v53);
          uint64_t result = (int8x8_t *)((char *)result + v53);
          unint64_t v41 = v41 - v54 + v55;
          goto LABEL_39;
        }
        if (v42) {
          break;
        }
        __int32 v43 = (unsigned __int8 *)&a10[v41];
        unint64_t v44 = (int8x16_t *)a10;
        do
          __int32 v45 = v44++;
        while (v44 <= (int8x16_t *)v43 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v45)) & 0x80) != 0);
        do
        {
          uint8x16_t v46 = v45;
          __int32 v45 = (int8x16_t *)((char *)v45 + 4);
        }
        while (v45 <= (int8x16_t *)v43 && !v46->i32[0]);
        if (v46 < (int8x16_t *)v43)
        {
          while (!v46->i8[0])
          {
            uint8x16_t v46 = (int8x16_t *)((char *)v46 + 1);
            if (v46 >= (int8x16_t *)v43)
            {
              uint8x16_t v46 = (int8x16_t *)&a10[v41];
              break;
            }
          }
        }
        int64_t v47 = (char *)v46 - a10;
        int64_t v48 = ((char *)v46 - a10) * a14;
        a3 += v48;
        result += v48;
        a10 += v48;
        v41 -= v47;
LABEL_39:
        if (v41 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v82 = 0;
      while (1)
      {
        float16x8_t v83 = (int8x16_t *)((char *)result + v82);
        v17.i32[0] = v42;
        uint8x16_t v84 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v85 = vcvtq_f16_u16(vmovl_high_u8(v84));
        float16x8_t v86 = (float16x8_t)vdupq_n_s16(0x1C04u);
        float16x8_t v87 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v84.i8)), v86);
        float16x8_t v88 = vmulq_f16(v85, v86);
        float16x8_t v89 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v88)), v39, *(int8x16_t *)&result[2].i8[v82]);
        float16x8_t v90 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v87)), v39, *(int8x16_t *)&result->i8[v82]);
        float16x8_t v91 = vmulq_f16(v88, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v82], v23), v24));
        float16x8_t v92 = vmulq_f16(v87, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v82], v23), v24));
        float16x8_t v93 = (float16x8_t)vqtbl1q_s8((int8x16_t)v92, (int8x16_t)xmmword_1850CD880);
        float16x8_t v94 = (float16x8_t)vqtbl1q_s8((int8x16_t)v91, (int8x16_t)xmmword_1850CD880);
        float16x8_t v95 = (float16x8_t)vqtbl1q_s8((int8x16_t)v90, (int8x16_t)xmmword_1850CD880);
        float16x8_t v96 = (float16x8_t)vqtbl1q_s8((int8x16_t)v89, (int8x16_t)xmmword_1850CD880);
        float16x8_t v97 = vaddq_f16(vmlsq_f16(v92, v92, v95), vaddq_f16(vmulq_f16(v93, v95), vmlsq_f16(v90, v90, v93)));
        float32x4_t v98 = vcvt_hight_f32_f16(v93);
        float32x4_t v99 = vdivq_f32(vmulq_f32(v98, v98), vcvt_hight_f32_f16(v92));
        float32x4_t v100 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v97), vcvt_hight_f32_f16(v95), v99), vcvt_hight_f32_f16(v90), v99);
        float16x8_t v101 = vaddq_f16(vmlsq_f16(v91, v91, v96), vaddq_f16(vmulq_f16(v94, v96), vmlsq_f16(v89, v89, v94)));
        float32x4_t v102 = vcvtq_f32_f16(*(float16x4_t *)v93.i8);
        float32x4_t v103 = vdivq_f32(vmulq_f32(v102, v102), vcvtq_f32_f16(*(float16x4_t *)v92.i8));
        float32x4_t v104 = vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v97.i8), vcvtq_f32_f16(*(float16x4_t *)v95.i8), v103), vcvtq_f32_f16(*(float16x4_t *)v90.i8), v103);
        float32x4_t v105 = vcvt_hight_f32_f16(v94);
        float32x4_t v106 = vdivq_f32(vmulq_f32(v105, v105), vcvt_hight_f32_f16(v91));
        float32x4_t v107 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v101), vcvt_hight_f32_f16(v96), v106), vcvt_hight_f32_f16(v89), v106);
        float32x4_t v108 = vcvtq_f32_f16(*(float16x4_t *)v94.i8);
        float32x4_t v109 = vdivq_f32(vmulq_f32(v108, v108), vcvtq_f32_f16(*(float16x4_t *)v91.i8));
        float32x4_t v110 = vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v101.i8), vcvtq_f32_f16(*(float16x4_t *)v96.i8), v109), vcvtq_f32_f16(*(float16x4_t *)v89.i8), v109);
        int8x16_t v111 = (int8x16_t)vcgtzq_f16(v95);
        int8x16_t v112 = vbslq_s8((int8x16_t)vcgtzq_f16(v93), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v104), v100), (float16x8_t)0), vbicq_s8(v111, (int8x16_t)vceqzq_f16(v92))), vbicq_s8((int8x16_t)v92, v111)), (int8x16_t)v90);
        int8x16_t v113 = (int8x16_t)vcgtzq_f16(v96);
        int8x16_t v17 = vandq_s8((int8x16_t)vmaxnmq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v110), v107), (float16x8_t)0), vbicq_s8(v113, (int8x16_t)vceqzq_f16(v91)));
        *float16x8_t v83 = v112;
        v83[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v94), vorrq_s8(v17, vbicq_s8((int8x16_t)v91, v113)), (int8x16_t)v89);
        a10 += v30;
        v41 -= 4;
        if (v41 < 4) {
          break;
        }
        __int32 v42 = *(_DWORD *)a10;
        v82 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v82);
          a3 = (int8x8_t *)((char *)a3 + v82);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v82);
      a3 = (int8x8_t *)((char *)a3 + v36 + v82);
LABEL_42:
      for (unint64_t i = a12 - v40 + v41; i; --i)
      {
        if (*a10)
        {
          float16x4_t v115 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          int8x8_t v116 = vand_s8(v34, (int8x8_t)vcgtz_f16(v115));
          float16x4_t v117 = vmul_f16(v115, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          float16x4_t v118 = (float16x4_t)vdup_lane_s16((int16x4_t)v117, 3);
          float16x4_t v119 = (float16x4_t)vbsl_s8(v116, (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v120 = (float16x4_t)vdup_lane_s16((int16x4_t)v119, 3);
          int8x8_t v121 = (int8x8_t)vcgtz_f16(v120);
          *(int16x4_t *)v17.i8 = vceqz_f16(v117);
          int8x8_t v122 = (int8x8_t)vcgtz_f16(v118);
          float32x4_t v123 = vcvtq_f32_f16(v118);
          float32x4_t v124 = vdivq_f32(vmulq_f32(v123, v123), vcvtq_f32_f16(v117));
          int *result = vbsl_s8(v122, vorr_s8(vand_s8((int8x8_t)vmaxnm_f16(vcvt_f16_f32(vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(vadd_f16(vmls_lane_f16(v117, v117, v119, 3), vadd_f16(vmls_lane_f16(v119, v119, v117, 3), vmul_lane_f16(v120, v117, 3)))), vcvtq_f32_f16(v120), v124), vcvtq_f32_f16(v119), v124)), 0), vbic_s8(v121, *(int8x8_t *)v17.i8)),
                        vbic_s8((int8x8_t)v117, v121)),
                      (int8x8_t)v119);
        }
        float16x8_t v125 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v125 >= a8) {
          uint64_t v126 = -(uint64_t)a7;
        }
        else {
          uint64_t v126 = 0;
        }
        a3 = &v125[v126];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      uint64_t v127 = &a5[a4];
      if ((unint64_t)v127 >= a9) {
        uint64_t v128 = v35;
      }
      else {
        uint64_t v128 = 0;
      }
      uint8x16_t v129 = &v127[v128];
      uint64_t v130 = a8 + 8 * v128 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v129;
        a8 = v130;
        a5 = v129;
      }
      BOOL v131 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v131 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v132 = (a8 - (unint64_t)a3) >> 3;
    if (v132 >= a12) {
      unint64_t v132 = a12;
    }
    unint64_t v133 = v132;
    if (v132 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v134 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        int8x16_t v141 = (unsigned __int8 *)&a10[v133];
        int8x16_t v142 = (int8x16_t *)a10;
        do
          float16x8_t v143 = v142++;
        while (v142 <= (int8x16_t *)v141 && (vminvq_u8((uint8x16_t)vceqq_s8(*v143, v38)) & 0x80) != 0);
        do
        {
          float16x8_t v144 = v143;
          float16x8_t v143 = (int8x16_t *)((char *)v143 + 4);
        }
        while (v143 <= (int8x16_t *)v141 && v144->i32[0] == -1);
        if (v144 < (int8x16_t *)v141)
        {
          while (v144->u8[0] == 255)
          {
            float16x8_t v144 = (int8x16_t *)((char *)v144 + 1);
            if (v144 >= (int8x16_t *)v141)
            {
              float16x8_t v144 = (int8x16_t *)&a10[v133];
              break;
            }
          }
        }
        uint64_t v145 = 0;
        int64_t v146 = (char *)v144 - a10;
        unint64_t v147 = (char *)v144 - a10;
        do
        {
          float16x4_t v148 = (int8x16_t *)((char *)result + v145);
          float16x8_t v149 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v145]), v23), v24);
          float16x8_t v150 = (float16x8_t)vqtbl1q_s8((int8x16_t)v149, (int8x16_t)xmmword_1850CD880);
          float16x8_t v151 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v145]), v23), v24);
          float16x8_t v152 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v145]), v28), v29);
          float16x8_t v153 = (float16x8_t)vqtbl1q_s8((int8x16_t)v151, (int8x16_t)xmmword_1850CD880);
          float16x8_t v154 = (float16x8_t)vqtbl1q_s8((int8x16_t)v152, (int8x16_t)xmmword_1850CD880);
          float16x8_t v155 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v145]), v28), v29);
          float16x8_t v156 = (float16x8_t)vqtbl1q_s8((int8x16_t)v155, (int8x16_t)xmmword_1850CD880);
          float32x4_t v157 = vcvt_hight_f32_f16(v150);
          float16x8_t v158 = vaddq_f16(vmlsq_f16(v149, v149, v154), vaddq_f16(vmulq_f16(v150, v154), vmlsq_f16(v152, v152, v150)));
          float32x4_t v159 = vdivq_f32(vmulq_f32(v157, v157), vcvt_hight_f32_f16(v149));
          float32x4_t v160 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v158), vcvt_hight_f32_f16(v154), v159), vcvt_hight_f32_f16(v152), v159);
          float16x8_t v161 = vaddq_f16(vmlsq_f16(v151, v151, v156), vaddq_f16(vmulq_f16(v153, v156), vmlsq_f16(v155, v155, v153)));
          float32x4_t v162 = vcvtq_f32_f16(*(float16x4_t *)v150.i8);
          float32x4_t v163 = vdivq_f32(vmulq_f32(v162, v162), vcvtq_f32_f16(*(float16x4_t *)v149.i8));
          float32x4_t v164 = vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v158.i8), vcvtq_f32_f16(*(float16x4_t *)v154.i8), v163), vcvtq_f32_f16(*(float16x4_t *)v152.i8), v163);
          float32x4_t v165 = vcvt_hight_f32_f16(v153);
          float32x4_t v166 = vdivq_f32(vmulq_f32(v165, v165), vcvt_hight_f32_f16(v151));
          float32x4_t v167 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v161), vcvt_hight_f32_f16(v156), v166), vcvt_hight_f32_f16(v155), v166);
          float32x4_t v168 = vcvtq_f32_f16(*(float16x4_t *)v153.i8);
          float32x4_t v169 = vdivq_f32(vmulq_f32(v168, v168), vcvtq_f32_f16(*(float16x4_t *)v151.i8));
          float32x4_t v170 = vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v161.i8), vcvtq_f32_f16(*(float16x4_t *)v156.i8), v169), vcvtq_f32_f16(*(float16x4_t *)v155.i8), v169);
          int8x16_t v171 = (int8x16_t)vcgtzq_f16(v154);
          int8x16_t v172 = vbslq_s8((int8x16_t)vcgtzq_f16(v150), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v164), v160), (float16x8_t)0), vbicq_s8(v171, (int8x16_t)vceqzq_f16(v149))), vbicq_s8((int8x16_t)v149, v171)), (int8x16_t)v152);
          int8x16_t v173 = (int8x16_t)vcgtzq_f16(v156);
          int8x16_t v17 = vandq_s8((int8x16_t)vmaxnmq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v170), v167), (float16x8_t)0), vbicq_s8(v173, (int8x16_t)vceqzq_f16(v151)));
          *float16x4_t v148 = vrev16q_s8(v172);
          v148[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v153), vorrq_s8(v17, vbicq_s8((int8x16_t)v151, v173)), (int8x16_t)v155));
          a10 += v30;
          v147 -= 4;
          v145 += v36;
        }
        while (v147 > 3);
        a3 = (int8x8_t *)((char *)a3 + v145);
        uint64_t result = (int8x8_t *)((char *)result + v145);
        unint64_t v133 = v133 - v146 + v147;
        goto LABEL_88;
      }
      if (v134) {
        break;
      }
      float16x8_t v135 = (unsigned __int8 *)&a10[v133];
      float16x8_t v136 = (int8x16_t *)a10;
      do
        float16x8_t v137 = v136++;
      while (v136 <= (int8x16_t *)v135 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v137)) & 0x80) != 0);
      do
      {
        float16x8_t v138 = v137;
        float16x8_t v137 = (int8x16_t *)((char *)v137 + 4);
      }
      while (v137 <= (int8x16_t *)v135 && !v138->i32[0]);
      if (v138 < (int8x16_t *)v135)
      {
        while (!v138->i8[0])
        {
          float16x8_t v138 = (int8x16_t *)((char *)v138 + 1);
          if (v138 >= (int8x16_t *)v135)
          {
            float16x8_t v138 = (int8x16_t *)&a10[v133];
            break;
          }
        }
      }
      int64_t v139 = (char *)v138 - a10;
      int64_t v140 = ((char *)v138 - a10) * a14;
      a3 += v140;
      result += v140;
      a10 += v140;
      v133 -= v139;
LABEL_88:
      if (v133 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v174 = 0;
    while (1)
    {
      uint64_t v175 = (int8x16_t *)((char *)result + v174);
      v17.i32[0] = v134;
      uint8x16_t v176 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v177 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v176.i8));
      float16x8_t v178 = (float16x8_t)vdupq_n_s16(0x1C04u);
      float16x8_t v179 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v176)), v178);
      float16x8_t v180 = vmulq_f16(v177, v178);
      float16x8_t v181 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v180)), v39, vrev16q_s8(*(int8x16_t *)&result->i8[v174]));
      float16x8_t v182 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v179)), v39, vrev16q_s8(*(int8x16_t *)&result[2].i8[v174]));
      float16x8_t v183 = vmulq_f16(v180, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v174]), v23), v24));
      float16x8_t v184 = vmulq_f16(v179, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v174]), v23), v24));
      float16x8_t v185 = (float16x8_t)vqtbl1q_s8((int8x16_t)v184, (int8x16_t)xmmword_1850CD880);
      float16x8_t v186 = (float16x8_t)vqtbl1q_s8((int8x16_t)v183, (int8x16_t)xmmword_1850CD880);
      float16x8_t v187 = (float16x8_t)vqtbl1q_s8((int8x16_t)v182, (int8x16_t)xmmword_1850CD880);
      float16x8_t v188 = (float16x8_t)vqtbl1q_s8((int8x16_t)v181, (int8x16_t)xmmword_1850CD880);
      float16x8_t v189 = vaddq_f16(vmlsq_f16(v183, v183, v188), vaddq_f16(vmulq_f16(v186, v188), vmlsq_f16(v181, v181, v186)));
      float32x4_t v190 = vcvt_hight_f32_f16(v186);
      float32x4_t v191 = vdivq_f32(vmulq_f32(v190, v190), vcvt_hight_f32_f16(v183));
      float32x4_t v192 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v189), vcvt_hight_f32_f16(v188), v191), vcvt_hight_f32_f16(v181), v191);
      float16x8_t v193 = vaddq_f16(vmlsq_f16(v184, v184, v187), vaddq_f16(vmulq_f16(v185, v187), vmlsq_f16(v182, v182, v185)));
      float32x4_t v194 = vcvtq_f32_f16(*(float16x4_t *)v186.i8);
      float32x4_t v195 = vdivq_f32(vmulq_f32(v194, v194), vcvtq_f32_f16(*(float16x4_t *)v183.i8));
      float32x4_t v196 = vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v189.i8), vcvtq_f32_f16(*(float16x4_t *)v188.i8), v195), vcvtq_f32_f16(*(float16x4_t *)v181.i8), v195);
      float32x4_t v197 = vcvt_hight_f32_f16(v185);
      float32x4_t v198 = vdivq_f32(vmulq_f32(v197, v197), vcvt_hight_f32_f16(v184));
      float32x4_t v199 = vmlaq_f32(vmlsq_f32(vcvt_hight_f32_f16(v193), vcvt_hight_f32_f16(v187), v198), vcvt_hight_f32_f16(v182), v198);
      float32x4_t v200 = vcvtq_f32_f16(*(float16x4_t *)v185.i8);
      float32x4_t v201 = vdivq_f32(vmulq_f32(v200, v200), vcvtq_f32_f16(*(float16x4_t *)v184.i8));
      float16x8_t v202 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(*(float16x4_t *)v193.i8), vcvtq_f32_f16(*(float16x4_t *)v187.i8), v201), vcvtq_f32_f16(*(float16x4_t *)v182.i8), v201)), v199);
      int8x16_t v203 = (int8x16_t)vcgtzq_f16(v187);
      int8x16_t v204 = vbslq_s8((int8x16_t)vcgtzq_f16(v185), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f16(v202, (float16x8_t)0), vbicq_s8(v203, (int8x16_t)vceqzq_f16(v184))), vbicq_s8((int8x16_t)v184, v203)), (int8x16_t)v182);
      int8x16_t v205 = (int8x16_t)vcgtzq_f16(v188);
      int8x16_t v17 = vandq_s8((int8x16_t)vmaxnmq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v196), v192), (float16x8_t)0), vbicq_s8(v205, (int8x16_t)vceqzq_f16(v183)));
      *uint64_t v175 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v186), vorrq_s8(v17, vbicq_s8((int8x16_t)v183, v205)), (int8x16_t)v181));
      v175[1] = vrev16q_s8(v204);
      a10 += v30;
      v133 -= 4;
      if (v133 < 4) {
        break;
      }
      __int32 v134 = *(_DWORD *)a10;
      v174 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v174);
        a3 = (int8x8_t *)((char *)a3 + v174);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v174);
    a3 = (int8x8_t *)((char *)a3 + v36 + v174);
LABEL_91:
    for (unint64_t j = a12 - v132 + v133; j; --j)
    {
      if (*a10)
      {
        float16x4_t v207 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v208 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v207)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v209 = vmul_f16(v207, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v210 = (float16x4_t)vdup_lane_s16((int16x4_t)v209, 3);
        float16x4_t v211 = (float16x4_t)vdup_lane_s16((int16x4_t)v208, 3);
        int8x8_t v212 = (int8x8_t)vcgtz_f16(v211);
        *(int16x4_t *)v17.i8 = vceqz_f16(v209);
        int8x8_t v213 = (int8x8_t)vcgtz_f16(v210);
        float32x4_t v214 = vcvtq_f32_f16(v210);
        float32x4_t v215 = vdivq_f32(vmulq_f32(v214, v214), vcvtq_f32_f16(v209));
        int *result = vrev16_s8(vbsl_s8(v213, vorr_s8(vand_s8((int8x8_t)vmaxnm_f16(vcvt_f16_f32(vmlaq_f32(vmlsq_f32(vcvtq_f32_f16(vadd_f16(vmls_lane_f16(v209, v209, v208, 3), vadd_f16(vmls_lane_f16(v208, v208, v209, 3), vmul_lane_f16(v211, v209, 3)))), vcvtq_f32_f16(v211), v215), vcvtq_f32_f16(v208), v215)), 0),
                          vbic_s8(v212, *(int8x8_t *)v17.i8)),
                        vbic_s8((int8x8_t)v209, v212)),
                      (int8x8_t)v208));
      }
      float32x4_t v216 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v216 >= a8) {
        uint64_t v217 = -(uint64_t)a7;
      }
      else {
        uint64_t v217 = 0;
      }
      a3 = &v216[v217];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    int8x16_t v218 = &a5[a4];
    if ((unint64_t)v218 >= a9) {
      uint64_t v219 = v35;
    }
    else {
      uint64_t v219 = 0;
    }
    float32x4_t v220 = &v218[v219];
    uint64_t v221 = a8 + 8 * v219 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v220;
      a8 = v221;
      a5 = v220;
    }
    BOOL v131 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v131 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)21,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = (int8x16_t)vdupq_n_s16(v24);
  int8x16_t v26 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  int8x16_t v27 = vandq_s8(v25, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v25, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v24;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = 0x3800380038003800;
  v38.i64[1] = 0x3800380038003800;
  v39.i64[0] = 0x8000800080008000;
  v39.i64[1] = 0x8000800080008000;
  v40.i64[0] = -1;
  v40.i64[1] = -1;
  v41.i64[0] = 0x3C003C003C003C00;
  v41.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v42 = (a8 - (unint64_t)a3) >> 3;
      if (v42 >= a12) {
        unint64_t v42 = a12;
      }
      unint64_t v43 = v42;
      if (v42 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v44 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v51 = (unsigned __int8 *)&a10[v43];
          int8x16_t v52 = (int8x16_t *)a10;
          do
            uint64_t v53 = v52++;
          while (v52 <= (int8x16_t *)v51 && (vminvq_u8((uint8x16_t)vceqq_s8(*v53, v40)) & 0x80) != 0);
          do
          {
            int64_t v54 = v53;
            uint64_t v53 = (int8x16_t *)((char *)v53 + 4);
          }
          while (v53 <= (int8x16_t *)v51 && v54->i32[0] == -1);
          if (v54 < (int8x16_t *)v51)
          {
            while (v54->u8[0] == 255)
            {
              int64_t v54 = (int8x16_t *)((char *)v54 + 1);
              if (v54 >= (int8x16_t *)v51)
              {
                int64_t v54 = (int8x16_t *)&a10[v43];
                break;
              }
            }
          }
          uint64_t v55 = 0;
          int64_t v56 = (char *)v54 - a10;
          unint64_t v57 = (char *)v54 - a10;
          do
          {
            float16x8_t v58 = (int8x16_t *)((char *)result + v55);
            float16x8_t v59 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v55], v23), v26);
            float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v55], v23), v26);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v55], v28), v29);
            float16x8_t v61 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v55], v28), v29);
            float16x8_t v62 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v59, (int8x16_t)xmmword_1850CD880);
            float16x8_t v64 = (float16x8_t)vqtbl1q_s8((int8x16_t)v61, (int8x16_t)xmmword_1850CD880);
            float16x8_t v65 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            int8x16_t v66 = (int8x16_t)vcgtq_f16(v59, vmulq_f16(v63, v38));
            int8x16_t v67 = (int8x16_t)vcgtq_f16(v17, vmulq_f16(v62, v38));
            int8x16_t v68 = vbicq_s8(v39, v67);
            int8x16_t v69 = vbicq_s8(v39, v66);
            *float16x8_t v58 = vbslq_s8((int8x16_t)vcgtzq_f16(v63), vbslq_s8((int8x16_t)vcgtzq_f16(v64), (int8x16_t)vsubq_f16(vaddq_f16(vmlaq_f16(v61, (float16x8_t)veorq_s8(v69, (int8x16_t)vsubq_f16(v63, v59)), v61), vmlaq_f16(v59, (float16x8_t)veorq_s8(v69, (int8x16_t)vsubq_f16(v64, v61)), v59)), (float16x8_t)vandq_s8((int8x16_t)vmulq_f16(v63, v64), v66)), (int8x16_t)v59), (int8x16_t)v61);
            v58[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v62), vbslq_s8((int8x16_t)vcgtzq_f16(v65), (int8x16_t)vsubq_f16(vaddq_f16(vmlaq_f16(v60, (float16x8_t)veorq_s8(v68, (int8x16_t)vsubq_f16(v62, v17)), v60), vmlaq_f16(v17, (float16x8_t)veorq_s8(v68, (int8x16_t)vsubq_f16(v65, v60)), v17)), (float16x8_t)vandq_s8((int8x16_t)vmulq_f16(v62, v65), v67)), (int8x16_t)v17), (int8x16_t)v60);
            a10 += v30;
            v57 -= 4;
            v55 += v36;
          }
          while (v57 > 3);
          a3 = (int8x8_t *)((char *)a3 + v55);
          uint64_t result = (int8x8_t *)((char *)result + v55);
          unint64_t v43 = v43 - v56 + v57;
          goto LABEL_39;
        }
        if (v44) {
          break;
        }
        __int32 v45 = (unsigned __int8 *)&a10[v43];
        uint8x16_t v46 = (int8x16_t *)a10;
        do
          int64_t v47 = v46++;
        while (v46 <= (int8x16_t *)v45 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v47)) & 0x80) != 0);
        do
        {
          int64_t v48 = v47;
          int64_t v47 = (int8x16_t *)((char *)v47 + 4);
        }
        while (v47 <= (int8x16_t *)v45 && !v48->i32[0]);
        if (v48 < (int8x16_t *)v45)
        {
          while (!v48->i8[0])
          {
            int64_t v48 = (int8x16_t *)((char *)v48 + 1);
            if (v48 >= (int8x16_t *)v45)
            {
              int64_t v48 = (int8x16_t *)&a10[v43];
              break;
            }
          }
        }
        int64_t v49 = (char *)v48 - a10;
        int64_t v50 = ((char *)v48 - a10) * a14;
        a3 += v50;
        result += v50;
        a10 += v50;
        v43 -= v49;
LABEL_39:
        if (v43 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v70 = 0;
      while (1)
      {
        float32x4_t v71 = (int8x16_t *)((char *)result + v70);
        v17.i32[0] = v44;
        uint8x16_t v72 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v73 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v72.i8));
        float16x8_t v74 = (float16x8_t)vdupq_n_s16(0x1C04u);
        float16x8_t v75 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v72)), v74);
        float16x8_t v76 = vmulq_f16(v73, v74);
        float16x8_t v77 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v76)), v41, *(int8x16_t *)&result->i8[v70]);
        float16x8_t v78 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v75)), v41, *(int8x16_t *)&result[2].i8[v70]);
        float16x8_t v79 = vmulq_f16(v75, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v70], v23), v26));
        float16x8_t v80 = vmulq_f16(v76, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v70], v23), v26));
        float16x8_t v81 = (float16x8_t)vqtbl1q_s8((int8x16_t)v80, (int8x16_t)xmmword_1850CD880);
        float16x8_t v82 = (float16x8_t)vqtbl1q_s8((int8x16_t)v79, (int8x16_t)xmmword_1850CD880);
        float16x8_t v83 = (float16x8_t)vqtbl1q_s8((int8x16_t)v78, (int8x16_t)xmmword_1850CD880);
        float16x8_t v84 = (float16x8_t)vqtbl1q_s8((int8x16_t)v77, (int8x16_t)xmmword_1850CD880);
        int8x16_t v85 = (int8x16_t)vcgtzq_f16(v84);
        int8x16_t v86 = (int8x16_t)vcgtzq_f16(v81);
        int8x16_t v87 = (int8x16_t)vmulq_f16(v81, v84);
        int8x16_t v88 = (int8x16_t)vcgtq_f16(v79, vmulq_f16(v82, v38));
        int8x16_t v89 = (int8x16_t)vcgtq_f16(v80, vmulq_f16(v81, v38));
        int8x16_t v90 = vbicq_s8(v39, v89);
        int8x16_t v91 = vbicq_s8(v39, v88);
        float16x8_t v92 = (float16x8_t)veorq_s8(v90, (int8x16_t)vsubq_f16(v84, v77));
        float16x8_t v93 = vmlaq_f16(v77, (float16x8_t)veorq_s8(v90, (int8x16_t)vsubq_f16(v81, v80)), v77);
        float16x8_t v17 = vsubq_f16(vaddq_f16(vmlaq_f16(v78, (float16x8_t)veorq_s8(v91, (int8x16_t)vsubq_f16(v82, v79)), v78), vmlaq_f16(v79, (float16x8_t)veorq_s8(v91, (int8x16_t)vsubq_f16(v83, v78)), v79)), (float16x8_t)vandq_s8((int8x16_t)vmulq_f16(v82, v83), v88));
        *float32x4_t v71 = vbslq_s8(v86, vbslq_s8(v85, (int8x16_t)vsubq_f16(vaddq_f16(v93, vmlaq_f16(v80, v92, v80)), (float16x8_t)vandq_s8(v87, v89)), (int8x16_t)v80), (int8x16_t)v77);
        v71[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v82), vbslq_s8((int8x16_t)vcgtzq_f16(v83), (int8x16_t)v17, (int8x16_t)v79), (int8x16_t)v78);
        a10 += v30;
        v43 -= 4;
        if (v43 < 4) {
          break;
        }
        __int32 v44 = *(_DWORD *)a10;
        v70 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v70);
          a3 = (int8x8_t *)((char *)a3 + v70);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v70);
      a3 = (int8x8_t *)((char *)a3 + v36 + v70);
LABEL_42:
      for (unint64_t i = a12 - v42 + v43; i; --i)
      {
        if (*a10)
        {
          float16x4_t v95 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v96 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v95)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v97 = vmul_f16(v95, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          float16x4_t v98 = (float16x4_t)vdup_lane_s16((int16x4_t)v97, 3);
          float16x4_t v99 = (float16x4_t)vdup_lane_s16((int16x4_t)v96, 3);
          *(int16x4_t *)v17.i8 = vcgtz_f16(v98);
          int8x8_t v100 = (int8x8_t)vcgt_f16(v97, vmul_lane_f16((float16x4_t)0x3800380038003800, v97, 3));
          int8x8_t v101 = vbic_s8((int8x8_t)0x8000800080008000, v100);
          int *result = vbsl_s8(*(int8x8_t *)v17.i8, vbsl_s8((int8x8_t)vcgtz_f16(v99), (int8x8_t)vsub_f16(vadd_f16(vmla_f16(v96, (float16x4_t)veor_s8(v101, (int8x8_t)vsub_f16(v98, v97)), v96), vmla_f16(v97, (float16x4_t)veor_s8(v101, (int8x8_t)vsub_f16(v99, v96)), v97)), (float16x4_t)vand_s8((int8x8_t)vmul_lane_f16(v99, v97, 3), v100)), (int8x8_t)v97), (int8x8_t)v96);
        }
        float32x4_t v102 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v102 >= a8) {
          uint64_t v103 = -(uint64_t)a7;
        }
        else {
          uint64_t v103 = 0;
        }
        a3 = &v102[v103];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      float32x4_t v104 = &a5[a4];
      if ((unint64_t)v104 >= a9) {
        uint64_t v105 = v35;
      }
      else {
        uint64_t v105 = 0;
      }
      float32x4_t v106 = &v104[v105];
      uint64_t v107 = a8 + 8 * v105 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v106;
        a8 = v107;
        a5 = v106;
      }
      BOOL v108 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v108 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v109 = (a8 - (unint64_t)a3) >> 3;
    if (v109 >= a12) {
      unint64_t v109 = a12;
    }
    unint64_t v110 = v109;
    if (v109 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v111 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        float16x4_t v118 = (unsigned __int8 *)&a10[v110];
        float16x4_t v119 = (int8x16_t *)a10;
        do
          float16x4_t v120 = v119++;
        while (v119 <= (int8x16_t *)v118 && (vminvq_u8((uint8x16_t)vceqq_s8(*v120, v40)) & 0x80) != 0);
        do
        {
          int8x8_t v121 = v120;
          float16x4_t v120 = (int8x16_t *)((char *)v120 + 4);
        }
        while (v120 <= (int8x16_t *)v118 && v121->i32[0] == -1);
        if (v121 < (int8x16_t *)v118)
        {
          while (v121->u8[0] == 255)
          {
            int8x8_t v121 = (int8x16_t *)((char *)v121 + 1);
            if (v121 >= (int8x16_t *)v118)
            {
              int8x8_t v121 = (int8x16_t *)&a10[v110];
              break;
            }
          }
        }
        uint64_t v122 = 0;
        int64_t v123 = (char *)v121 - a10;
        unint64_t v124 = (char *)v121 - a10;
        do
        {
          float16x8_t v125 = (int8x16_t *)((char *)result + v122);
          float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v122]), v23), v26);
          float16x8_t v126 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v122]), v23), v26);
          float16x8_t v127 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v122]), v28), v29);
          float16x8_t v128 = (float16x8_t)vqtbl1q_s8((int8x16_t)v126, (int8x16_t)xmmword_1850CD880);
          float16x8_t v129 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
          float16x8_t v130 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v122]), v28), v29);
          float16x8_t v131 = (float16x8_t)vqtbl1q_s8((int8x16_t)v130, (int8x16_t)xmmword_1850CD880);
          float16x8_t v132 = (float16x8_t)vqtbl1q_s8((int8x16_t)v127, (int8x16_t)xmmword_1850CD880);
          int8x16_t v133 = (int8x16_t)vcgtq_f16(v17, vmulq_f16(v129, v38));
          int8x16_t v134 = (int8x16_t)vcgtq_f16(v126, vmulq_f16(v128, v38));
          int8x16_t v135 = vbicq_s8(v39, v134);
          int8x16_t v136 = vbicq_s8(v39, v133);
          *float16x8_t v125 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v128), vbslq_s8((int8x16_t)vcgtzq_f16(v132), (int8x16_t)vsubq_f16(vaddq_f16(vmlaq_f16(v127, (float16x8_t)veorq_s8(v135, (int8x16_t)vsubq_f16(v128, v126)), v127), vmlaq_f16(v126, (float16x8_t)veorq_s8(v135, (int8x16_t)vsubq_f16(v132, v127)), v126)), (float16x8_t)vandq_s8((int8x16_t)vmulq_f16(v128, v132), v134)), (int8x16_t)v126), (int8x16_t)v127));
          v125[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v129), vbslq_s8((int8x16_t)vcgtzq_f16(v131), (int8x16_t)vsubq_f16(vaddq_f16(vmlaq_f16(v130, (float16x8_t)veorq_s8(v136, (int8x16_t)vsubq_f16(v129, v17)), v130), vmlaq_f16(v17, (float16x8_t)veorq_s8(v136, (int8x16_t)vsubq_f16(v131, v130)), v17)), (float16x8_t)vandq_s8((int8x16_t)vmulq_f16(v129, v131), v133)), (int8x16_t)v17), (int8x16_t)v130));
          a10 += v30;
          v124 -= 4;
          v122 += v36;
        }
        while (v124 > 3);
        a3 = (int8x8_t *)((char *)a3 + v122);
        uint64_t result = (int8x8_t *)((char *)result + v122);
        unint64_t v110 = v110 - v123 + v124;
        goto LABEL_88;
      }
      if (v111) {
        break;
      }
      int8x16_t v112 = (unsigned __int8 *)&a10[v110];
      int8x16_t v113 = (int8x16_t *)a10;
      do
        unint64_t v114 = v113++;
      while (v113 <= (int8x16_t *)v112 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v114)) & 0x80) != 0);
      do
      {
        float16x4_t v115 = v114;
        unint64_t v114 = (int8x16_t *)((char *)v114 + 4);
      }
      while (v114 <= (int8x16_t *)v112 && !v115->i32[0]);
      if (v115 < (int8x16_t *)v112)
      {
        while (!v115->i8[0])
        {
          float16x4_t v115 = (int8x16_t *)((char *)v115 + 1);
          if (v115 >= (int8x16_t *)v112)
          {
            float16x4_t v115 = (int8x16_t *)&a10[v110];
            break;
          }
        }
      }
      int64_t v116 = (char *)v115 - a10;
      int64_t v117 = ((char *)v115 - a10) * a14;
      a3 += v117;
      result += v117;
      a10 += v117;
      v110 -= v116;
LABEL_88:
      if (v110 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v137 = 0;
    while (1)
    {
      float16x8_t v138 = (int8x16_t *)((char *)result + v137);
      v17.i32[0] = v111;
      uint8x16_t v139 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v140 = vcvtq_f16_u16(vmovl_high_u8(v139));
      float16x8_t v141 = (float16x8_t)vdupq_n_s16(0x1C04u);
      float16x8_t v142 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v139.i8)), v141);
      float16x8_t v143 = vmulq_f16(v140, v141);
      float16x8_t v144 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v143)), v41, vrev16q_s8(*(int8x16_t *)&result[2].i8[v137]));
      float16x8_t v145 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v142)), v41, vrev16q_s8(*(int8x16_t *)&result->i8[v137]));
      float16x8_t v146 = vmulq_f16(v142, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v137]), v23), v26));
      float16x8_t v147 = vmulq_f16(v143, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v137]), v23), v26));
      float16x8_t v148 = (float16x8_t)vqtbl1q_s8((int8x16_t)v147, (int8x16_t)xmmword_1850CD880);
      float16x8_t v149 = (float16x8_t)vqtbl1q_s8((int8x16_t)v146, (int8x16_t)xmmword_1850CD880);
      float16x8_t v150 = (float16x8_t)vqtbl1q_s8((int8x16_t)v145, (int8x16_t)xmmword_1850CD880);
      float16x8_t v151 = (float16x8_t)vqtbl1q_s8((int8x16_t)v144, (int8x16_t)xmmword_1850CD880);
      int8x16_t v152 = (int8x16_t)vcgtzq_f16(v151);
      int8x16_t v153 = (int8x16_t)vcgtzq_f16(v148);
      int8x16_t v154 = (int8x16_t)vmulq_f16(v148, v151);
      int8x16_t v155 = (int8x16_t)vcgtq_f16(v146, vmulq_f16(v149, v38));
      int8x16_t v156 = (int8x16_t)vcgtq_f16(v147, vmulq_f16(v148, v38));
      int8x16_t v157 = vbicq_s8(v39, v156);
      int8x16_t v158 = vbicq_s8(v39, v155);
      float16x8_t v159 = (float16x8_t)veorq_s8(v157, (int8x16_t)vsubq_f16(v151, v144));
      float16x8_t v160 = vmlaq_f16(v144, (float16x8_t)veorq_s8(v157, (int8x16_t)vsubq_f16(v148, v147)), v144);
      float16x8_t v17 = vsubq_f16(vaddq_f16(vmlaq_f16(v145, (float16x8_t)veorq_s8(v158, (int8x16_t)vsubq_f16(v149, v146)), v145), vmlaq_f16(v146, (float16x8_t)veorq_s8(v158, (int8x16_t)vsubq_f16(v150, v145)), v146)), (float16x8_t)vandq_s8((int8x16_t)vmulq_f16(v149, v150), v155));
      *float16x8_t v138 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v149), vbslq_s8((int8x16_t)vcgtzq_f16(v150), (int8x16_t)v17, (int8x16_t)v146), (int8x16_t)v145));
      v138[1] = vrev16q_s8(vbslq_s8(v153, vbslq_s8(v152, (int8x16_t)vsubq_f16(vaddq_f16(v160, vmlaq_f16(v147, v159, v147)), (float16x8_t)vandq_s8(v154, v156)), (int8x16_t)v147), (int8x16_t)v144));
      a10 += v30;
      v110 -= 4;
      if (v110 < 4) {
        break;
      }
      __int32 v111 = *(_DWORD *)a10;
      v137 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v137);
        a3 = (int8x8_t *)((char *)a3 + v137);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v137);
    a3 = (int8x8_t *)((char *)a3 + v36 + v137);
LABEL_91:
    for (unint64_t j = a12 - v109 + v110; j; --j)
    {
      if (*a10)
      {
        float16x4_t v162 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v163 = vmul_f16(v162, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v164 = (float16x4_t)vdup_lane_s16((int16x4_t)v163, 3);
        float16x4_t v165 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v162)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v166 = (float16x4_t)vdup_lane_s16((int16x4_t)v165, 3);
        *(int16x4_t *)v17.i8 = vcgtz_f16(v164);
        int8x8_t v167 = (int8x8_t)vcgt_f16(v163, vmul_lane_f16((float16x4_t)0x3800380038003800, v163, 3));
        int8x8_t v168 = vbic_s8((int8x8_t)0x8000800080008000, v167);
        int *result = vrev16_s8(vbsl_s8(*(int8x8_t *)v17.i8, vbsl_s8((int8x8_t)vcgtz_f16(v166), (int8x8_t)vsub_f16(vadd_f16(vmla_f16(v165, (float16x4_t)veor_s8(v168, (int8x8_t)vsub_f16(v164, v163)), v165), vmla_f16(v163, (float16x4_t)veor_s8(v168, (int8x8_t)vsub_f16(v166, v165)), v163)), (float16x4_t)vand_s8((int8x8_t)vmul_lane_f16(v166, v163, 3), v167)), (int8x8_t)v163), (int8x8_t)v165));
      }
      float32x4_t v169 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v169 >= a8) {
        uint64_t v170 = -(uint64_t)a7;
      }
      else {
        uint64_t v170 = 0;
      }
      a3 = &v169[v170];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    int8x16_t v171 = &a5[a4];
    if ((unint64_t)v171 >= a9) {
      uint64_t v172 = v35;
    }
    else {
      uint64_t v172 = 0;
    }
    int8x16_t v173 = &v171[v172];
    uint64_t v174 = a8 + 8 * v172 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v173;
      a8 = v174;
      a5 = v173;
    }
    BOOL v108 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v108 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)20,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = (int8x16_t)vdupq_n_s16(v24);
  int8x16_t v26 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  int8x16_t v27 = vandq_s8(v25, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v25, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v24;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  v39.i64[0] = 0x3C003C003C003C00;
  v39.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v40 = (a8 - (unint64_t)a3) >> 3;
      if (v40 >= a12) {
        unint64_t v40 = a12;
      }
      unint64_t v41 = v40;
      if (v40 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v42 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v49 = (unsigned __int8 *)&a10[v41];
          int64_t v50 = (int8x16_t *)a10;
          do
            int64_t v51 = v50++;
          while (v50 <= (int8x16_t *)v49 && (vminvq_u8((uint8x16_t)vceqq_s8(*v51, v38)) & 0x80) != 0);
          do
          {
            int8x16_t v52 = v51;
            int64_t v51 = (int8x16_t *)((char *)v51 + 4);
          }
          while (v51 <= (int8x16_t *)v49 && v52->i32[0] == -1);
          if (v52 < (int8x16_t *)v49)
          {
            while (v52->u8[0] == 255)
            {
              int8x16_t v52 = (int8x16_t *)((char *)v52 + 1);
              if (v52 >= (int8x16_t *)v49)
              {
                int8x16_t v52 = (int8x16_t *)&a10[v41];
                break;
              }
            }
          }
          uint64_t v53 = 0;
          unint64_t v54 = (char *)v52 - a10;
          unint64_t v55 = v54;
          do
          {
            int64_t v56 = (int8x16_t *)((char *)result + v53);
            float16x8_t v57 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v53], v23), v26);
            float16x8_t v58 = (float16x8_t)vqtbl1q_s8((int8x16_t)v57, (int8x16_t)xmmword_1850CD880);
            float16x8_t v59 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v53], v23), v26);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v53], v28), v29);
            float16x8_t v61 = (float16x8_t)vqtbl1q_s8((int8x16_t)v59, (int8x16_t)xmmword_1850CD880);
            float16x8_t v62 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v53], v28), v29);
            float16x8_t v63 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
            float32x4_t v64 = vcvtq_f32_f16(*(float16x4_t *)v60.i8);
            float32x4_t v65 = vcvt_hight_f32_f16(v60);
            float32x4_t v66 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
            float32x4_t v67 = vcvt_hight_f32_f16(v17);
            float32x4_t v68 = vcvtq_f32_f16(*(float16x4_t *)v57.i8);
            float32x4_t v69 = vdivq_f32(v66, vcvtq_f32_f16(*(float16x4_t *)v63.i8));
            float32x4_t v70 = vaddq_f32(v68, v68);
            float32x4_t v71 = vmlaq_f32(vmlsq_f32(v70, v69, v70), v69, vcvtq_f32_f16(*(float16x4_t *)v58.i8));
            float32x4_t v72 = vcvt_hight_f32_f16(v57);
            float32x4_t v73 = vdivq_f32(v67, vcvt_hight_f32_f16(v63));
            float32x4_t v74 = vaddq_f32(v72, v72);
            float32x4_t v75 = vcvtq_f32_f16(*(float16x4_t *)v59.i8);
            float32x4_t v76 = vdivq_f32(v64, vcvtq_f32_f16(*(float16x4_t *)v62.i8));
            float32x4_t v77 = vaddq_f32(v75, v75);
            float32x4_t v78 = vmlaq_f32(vmlsq_f32(v77, v76, v77), v76, vcvtq_f32_f16(*(float16x4_t *)v61.i8));
            float32x4_t v79 = vcvt_hight_f32_f16(v59);
            float32x4_t v80 = vdivq_f32(v65, vcvt_hight_f32_f16(v62));
            float32x4_t v81 = vaddq_f32(v79, v79);
            float32x4_t v82 = vmulq_f32(vmlaq_f32(vmlsq_f32(v81, v80, v81), v80, vcvt_hight_f32_f16(v61)), v65);
            *(float16x4_t *)v64.f32 = vcvt_f16_f32(vmulq_f32(v78, v64));
            int8x16_t v83 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v64.f32);
            int16x8_t v84 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v64.f32, v82)), (int8x16_t)vceqzq_f16(v62));
            int8x16_t v85 = (int8x16_t)vmovl_high_s16(v84);
            float32x4_t v86 = (float32x4_t)vandq_s8(v83, (int8x16_t)vmovl_s16(*(int16x4_t *)v84.i8));
            float16x8_t v87 = vmlsq_f16(v60, v60, v61);
            int8x16_t v88 = vbslq_s8((int8x16_t)vcgtzq_f16(v62), (int8x16_t)vaddq_f16(vmlsq_f16(v59, v59, v62), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v86, vcvtq_f32_f16(*(float16x4_t *)v87.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(vcvt_f16_f32(v82)), v85), vcvt_hight_f32_f16(v87)))), (int8x16_t)v59);
            float32x4_t v89 = vmulq_f32(vmlaq_f32(vmlsq_f32(v74, v73, v74), v73, vcvt_hight_f32_f16(v58)), v67);
            *(float16x4_t *)v66.f32 = vcvt_f16_f32(vmulq_f32(v71, v66));
            int8x16_t v90 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v66.f32);
            int16x8_t v91 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v66.f32, v89)), (int8x16_t)vceqzq_f16(v63));
            int8x16_t v92 = (int8x16_t)vmovl_high_s16(v91);
            float32x4_t v93 = (float32x4_t)vandq_s8(v90, (int8x16_t)vmovl_s16(*(int16x4_t *)v91.i8));
            float16x8_t v94 = vmlsq_f16(v17, v17, v58);
            int8x16_t *v56 = vbslq_s8((int8x16_t)vcgtzq_f16(v61), v88, (int8x16_t)v60);
            v56[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v58), vbslq_s8((int8x16_t)vcgtzq_f16(v63), (int8x16_t)vaddq_f16(vmlsq_f16(v57, v57, v63), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v93, vcvtq_f32_f16(*(float16x4_t *)v94.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(vcvt_f16_f32(v89)), v92), vcvt_hight_f32_f16(v94)))), (int8x16_t)v57), (int8x16_t)v17);
            a10 += v30;
            v55 -= 4;
            v53 += v36;
          }
          while (v55 > 3);
          a3 = (int8x8_t *)((char *)a3 + v53);
          uint64_t result = (int8x8_t *)((char *)result + v53);
          unint64_t v41 = v41 - v54 + v55;
          goto LABEL_39;
        }
        if (v42) {
          break;
        }
        unint64_t v43 = (unsigned __int8 *)&a10[v41];
        __int32 v44 = (int8x16_t *)a10;
        do
          __int32 v45 = v44++;
        while (v44 <= (int8x16_t *)v43 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v45)) & 0x80) != 0);
        do
        {
          uint8x16_t v46 = v45;
          __int32 v45 = (int8x16_t *)((char *)v45 + 4);
        }
        while (v45 <= (int8x16_t *)v43 && !v46->i32[0]);
        if (v46 < (int8x16_t *)v43)
        {
          while (!v46->i8[0])
          {
            uint8x16_t v46 = (int8x16_t *)((char *)v46 + 1);
            if (v46 >= (int8x16_t *)v43)
            {
              uint8x16_t v46 = (int8x16_t *)&a10[v41];
              break;
            }
          }
        }
        int64_t v47 = (char *)v46 - a10;
        int64_t v48 = ((char *)v46 - a10) * a14;
        a3 += v48;
        result += v48;
        a10 += v48;
        v41 -= v47;
LABEL_39:
        if (v41 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v95 = 0;
      while (1)
      {
        float16x4_t v96 = (int8x16_t *)((char *)result + v95);
        v17.i32[0] = v42;
        uint8x16_t v97 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v98 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v97.i8));
        float16x8_t v99 = (float16x8_t)vdupq_n_s16(0x1C04u);
        float16x8_t v100 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v97)), v99);
        float16x8_t v101 = vmulq_f16(v98, v99);
        float16x8_t v102 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v101)), v39, *(int8x16_t *)&result->i8[v95]);
        float16x8_t v103 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v100)), v39, *(int8x16_t *)&result[2].i8[v95]);
        float16x8_t v104 = vmulq_f16(v100, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v95], v23), v26));
        float16x8_t v105 = vmulq_f16(v101, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v95], v23), v26));
        float16x8_t v106 = (float16x8_t)vqtbl1q_s8((int8x16_t)v105, (int8x16_t)xmmword_1850CD880);
        float16x8_t v17 = (float16x8_t)vqtbl1q_s8((int8x16_t)v104, (int8x16_t)xmmword_1850CD880);
        float16x8_t v107 = (float16x8_t)vqtbl1q_s8((int8x16_t)v103, (int8x16_t)xmmword_1850CD880);
        float16x8_t v108 = (float16x8_t)vqtbl1q_s8((int8x16_t)v102, (int8x16_t)xmmword_1850CD880);
        float32x4_t v109 = vcvtq_f32_f16(*(float16x4_t *)v102.i8);
        float32x4_t v110 = vcvt_hight_f32_f16(v102);
        float32x4_t v111 = vcvtq_f32_f16(*(float16x4_t *)v103.i8);
        float32x4_t v112 = vcvt_hight_f32_f16(v103);
        float32x4_t v113 = vcvtq_f32_f16(*(float16x4_t *)v105.i8);
        float32x4_t v114 = vdivq_f32(v109, vcvtq_f32_f16(*(float16x4_t *)v108.i8));
        float32x4_t v115 = vaddq_f32(v113, v113);
        float32x4_t v116 = vmlaq_f32(vmlsq_f32(v115, v114, v115), v114, vcvtq_f32_f16(*(float16x4_t *)v106.i8));
        float32x4_t v117 = vcvt_hight_f32_f16(v105);
        float32x4_t v118 = vdivq_f32(v110, vcvt_hight_f32_f16(v108));
        float32x4_t v119 = vaddq_f32(v117, v117);
        float32x4_t v120 = vcvtq_f32_f16(*(float16x4_t *)v104.i8);
        float32x4_t v121 = vdivq_f32(v111, vcvtq_f32_f16(*(float16x4_t *)v107.i8));
        float32x4_t v122 = vaddq_f32(v120, v120);
        float32x4_t v123 = vmlaq_f32(vmlsq_f32(v122, v121, v122), v121, vcvtq_f32_f16(*(float16x4_t *)v17.i8));
        float32x4_t v124 = vcvt_hight_f32_f16(v104);
        float32x4_t v125 = vdivq_f32(v112, vcvt_hight_f32_f16(v107));
        float32x4_t v126 = vaddq_f32(v124, v124);
        float32x4_t v127 = vmulq_f32(vmlaq_f32(vmlsq_f32(v126, v125, v126), v125, vcvt_hight_f32_f16(v17)), v112);
        *(float16x4_t *)v111.f32 = vcvt_f16_f32(vmulq_f32(v123, v111));
        int8x16_t v128 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v111.f32);
        int16x8_t v129 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v111.f32, v127)), (int8x16_t)vceqzq_f16(v107));
        int8x16_t v130 = (int8x16_t)vmovl_high_s16(v129);
        float32x4_t v131 = (float32x4_t)vandq_s8(v128, (int8x16_t)vmovl_s16(*(int16x4_t *)v129.i8));
        float16x8_t v132 = vmlsq_f16(v103, v103, v17);
        int8x16_t v133 = vbslq_s8((int8x16_t)vcgtzq_f16(v107), (int8x16_t)vaddq_f16(vmlsq_f16(v104, v104, v107), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v131, vcvtq_f32_f16(*(float16x4_t *)v132.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(vcvt_f16_f32(v127)), v130), vcvt_hight_f32_f16(v132)))), (int8x16_t)v104);
        float32x4_t v134 = vmulq_f32(vmlaq_f32(vmlsq_f32(v119, v118, v119), v118, vcvt_hight_f32_f16(v106)), v110);
        *(float16x4_t *)v109.f32 = vcvt_f16_f32(vmulq_f32(v116, v109));
        int8x16_t v135 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v109.f32);
        int16x8_t v136 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v109.f32, v134)), (int8x16_t)vceqzq_f16(v108));
        int8x16_t v137 = (int8x16_t)vmovl_high_s16(v136);
        float32x4_t v138 = (float32x4_t)vandq_s8(v135, (int8x16_t)vmovl_s16(*(int16x4_t *)v136.i8));
        float16x8_t v139 = vmlsq_f16(v102, v102, v106);
        *float16x4_t v96 = vbslq_s8((int8x16_t)vcgtzq_f16(v106), vbslq_s8((int8x16_t)vcgtzq_f16(v108), (int8x16_t)vaddq_f16(vmlsq_f16(v105, v105, v108), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v138, vcvtq_f32_f16(*(float16x4_t *)v139.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(vcvt_f16_f32(v134)), v137), vcvt_hight_f32_f16(v139)))), (int8x16_t)v105), (int8x16_t)v102);
        v96[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v17), v133, (int8x16_t)v103);
        a10 += v30;
        v41 -= 4;
        if (v41 < 4) {
          break;
        }
        __int32 v42 = *(_DWORD *)a10;
        v95 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v95);
          a3 = (int8x8_t *)((char *)a3 + v95);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v95);
      a3 = (int8x8_t *)((char *)a3 + v36 + v95);
LABEL_42:
      for (unint64_t i = a12 - v40 + v41; i; --i)
      {
        if (*a10)
        {
          float16x4_t v141 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v142 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v141)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v143 = vmul_f16(v141, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          float16x4_t v144 = (float16x4_t)vdup_lane_s16((int16x4_t)v143, 3);
          float16x4_t v145 = (float16x4_t)vdup_lane_s16((int16x4_t)v142, 3);
          int8x8_t v146 = (int8x8_t)vcgtz_f16(v145);
          int8x8_t v147 = (int8x8_t)vcgtz_f16(v144);
          int8x8_t v148 = (int8x8_t)vceqz_f16(v145);
          float32x4_t v149 = vcvtq_f32_f16(v142);
          float32x4_t v150 = vcvtq_f32_f16(v143);
          float32x4_t v151 = vdivq_f32(v149, vcvtq_f32_f16(v145));
          float32x4_t v152 = vaddq_f32(v150, v150);
          float16x4_t v153 = vcvt_f16_f32(vmulq_f32(vmlaq_f32(vmlsq_f32(v152, v151, v152), v151, vcvtq_f32_f16(v144)), v149));
          int8x16_t v154 = (int8x16_t)vmovl_s16((int16x4_t)vbic_s8((int8x8_t)vcgez_f16(v153), v148));
          float16x8_t v17 = (float16x8_t)vcvtq_f32_f16(vmls_lane_f16(v142, v142, v143, 3));
          int *result = vbsl_s8(v147, vbsl_s8(v146, (int8x8_t)vadd_f16(vmls_lane_f16(v143, v143, v142, 3), vcvt_f16_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(v153), v154), (float32x4_t)v17))), (int8x8_t)v143), (int8x8_t)v142);
        }
        int8x16_t v155 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v155 >= a8) {
          uint64_t v156 = -(uint64_t)a7;
        }
        else {
          uint64_t v156 = 0;
        }
        a3 = &v155[v156];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      int8x16_t v157 = &a5[a4];
      if ((unint64_t)v157 >= a9) {
        uint64_t v158 = v35;
      }
      else {
        uint64_t v158 = 0;
      }
      float16x8_t v159 = &v157[v158];
      uint64_t v160 = a8 + 8 * v158 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v159;
        a8 = v160;
        a5 = v159;
      }
      BOOL v161 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v161 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v162 = (a8 - (unint64_t)a3) >> 3;
    if (v162 >= a12) {
      unint64_t v162 = a12;
    }
    unint64_t v163 = v162;
    if (v162 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v164 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        int8x16_t v171 = (unsigned __int8 *)&a10[v163];
        uint64_t v172 = (int8x16_t *)a10;
        do
          int8x16_t v173 = v172++;
        while (v172 <= (int8x16_t *)v171 && (vminvq_u8((uint8x16_t)vceqq_s8(*v173, v38)) & 0x80) != 0);
        do
        {
          uint64_t v174 = v173;
          int8x16_t v173 = (int8x16_t *)((char *)v173 + 4);
        }
        while (v173 <= (int8x16_t *)v171 && v174->i32[0] == -1);
        if (v174 < (int8x16_t *)v171)
        {
          while (v174->u8[0] == 255)
          {
            uint64_t v174 = (int8x16_t *)((char *)v174 + 1);
            if (v174 >= (int8x16_t *)v171)
            {
              uint64_t v174 = (int8x16_t *)&a10[v163];
              break;
            }
          }
        }
        uint64_t v175 = 0;
        unint64_t v176 = (char *)v174 - a10;
        unint64_t v177 = v176;
        do
        {
          float16x8_t v178 = (int8x16_t *)((char *)result + v175);
          float16x8_t v179 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v175]), v23), v26);
          float16x8_t v180 = (float16x8_t)vqtbl1q_s8((int8x16_t)v179, (int8x16_t)xmmword_1850CD880);
          float16x8_t v181 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v175]), v23), v26);
          float16x8_t v182 = (float16x8_t)vqtbl1q_s8((int8x16_t)v181, (int8x16_t)xmmword_1850CD880);
          float16x8_t v183 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v175]), v28), v29);
          float16x8_t v184 = (float16x8_t)vqtbl1q_s8((int8x16_t)v183, (int8x16_t)xmmword_1850CD880);
          float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v175]), v28), v29);
          float16x8_t v185 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
          float32x4_t v186 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
          float32x4_t v187 = vcvt_hight_f32_f16(v17);
          float32x4_t v188 = vcvtq_f32_f16(*(float16x4_t *)v183.i8);
          float32x4_t v189 = vcvt_hight_f32_f16(v183);
          float32x4_t v190 = vcvtq_f32_f16(*(float16x4_t *)v179.i8);
          float32x4_t v191 = vdivq_f32(v186, vcvtq_f32_f16(*(float16x4_t *)v185.i8));
          float32x4_t v192 = vaddq_f32(v190, v190);
          float32x4_t v193 = vmlaq_f32(vmlsq_f32(v192, v191, v192), v191, vcvtq_f32_f16(*(float16x4_t *)v180.i8));
          float32x4_t v194 = vcvt_hight_f32_f16(v179);
          float32x4_t v195 = vdivq_f32(v187, vcvt_hight_f32_f16(v185));
          float32x4_t v196 = vaddq_f32(v194, v194);
          float32x4_t v197 = vmlaq_f32(vmlsq_f32(v196, v195, v196), v195, vcvt_hight_f32_f16(v180));
          float32x4_t v198 = vcvtq_f32_f16(*(float16x4_t *)v181.i8);
          float32x4_t v199 = vdivq_f32(v188, vcvtq_f32_f16(*(float16x4_t *)v184.i8));
          float32x4_t v200 = vaddq_f32(v198, v198);
          float32x4_t v201 = vmlaq_f32(vmlsq_f32(v200, v199, v200), v199, vcvtq_f32_f16(*(float16x4_t *)v182.i8));
          float32x4_t v202 = vcvt_hight_f32_f16(v181);
          float32x4_t v203 = vdivq_f32(v189, vcvt_hight_f32_f16(v184));
          float32x4_t v204 = vaddq_f32(v202, v202);
          float32x4_t v205 = vmulq_f32(vmlaq_f32(vmlsq_f32(v204, v203, v204), v203, vcvt_hight_f32_f16(v182)), v189);
          float32x4_t v206 = vmulq_f32(v197, v187);
          *(float16x4_t *)v188.f32 = vcvt_f16_f32(vmulq_f32(v201, v188));
          int8x16_t v207 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v188.f32);
          int16x8_t v208 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v188.f32, v205)), (int8x16_t)vceqzq_f16(v184));
          int8x16_t v209 = (int8x16_t)vmovl_high_s16(v208);
          float32x4_t v210 = (float32x4_t)vandq_s8(v207, (int8x16_t)vmovl_s16(*(int16x4_t *)v208.i8));
          float16x8_t v211 = vmlsq_f16(v183, v183, v182);
          *(float16x4_t *)v186.f32 = vcvt_f16_f32(vmulq_f32(v193, v186));
          int8x16_t v212 = vbslq_s8((int8x16_t)vcgtzq_f16(v184), (int8x16_t)vaddq_f16(vmlsq_f16(v181, v181, v184), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v210, vcvtq_f32_f16(*(float16x4_t *)v211.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(vcvt_f16_f32(v205)), v209), vcvt_hight_f32_f16(v211)))), (int8x16_t)v181);
          int8x16_t v213 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v186.f32);
          int16x8_t v214 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v186.f32, v206)), (int8x16_t)vceqzq_f16(v185));
          *(float16x4_t *)v186.f32 = vcvt_f16_f32(v206);
          float32x4_t v215 = (float32x4_t)vandq_s8(v213, (int8x16_t)vmovl_s16(*(int16x4_t *)v214.i8));
          float16x8_t v216 = vmlsq_f16(v17, v17, v180);
          *float16x8_t v178 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v180), vbslq_s8((int8x16_t)vcgtzq_f16(v185), (int8x16_t)vaddq_f16(vmlsq_f16(v179, v179, v185), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v215, vcvtq_f32_f16(*(float16x4_t *)v216.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v186.f32), (int8x16_t)vmovl_high_s16(v214)), vcvt_hight_f32_f16(v216)))), (int8x16_t)v179), (int8x16_t)v17));
          v178[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v182), v212, (int8x16_t)v183));
          a10 += v30;
          v177 -= 4;
          v175 += v36;
        }
        while (v177 > 3);
        a3 = (int8x8_t *)((char *)a3 + v175);
        uint64_t result = (int8x8_t *)((char *)result + v175);
        unint64_t v163 = v163 - v176 + v177;
        goto LABEL_88;
      }
      if (v164) {
        break;
      }
      float16x4_t v165 = (unsigned __int8 *)&a10[v163];
      float16x4_t v166 = (int8x16_t *)a10;
      do
        int8x8_t v167 = v166++;
      while (v166 <= (int8x16_t *)v165 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v167)) & 0x80) != 0);
      do
      {
        int8x8_t v168 = v167;
        int8x8_t v167 = (int8x16_t *)((char *)v167 + 4);
      }
      while (v167 <= (int8x16_t *)v165 && !v168->i32[0]);
      if (v168 < (int8x16_t *)v165)
      {
        while (!v168->i8[0])
        {
          int8x8_t v168 = (int8x16_t *)((char *)v168 + 1);
          if (v168 >= (int8x16_t *)v165)
          {
            int8x8_t v168 = (int8x16_t *)&a10[v163];
            break;
          }
        }
      }
      int64_t v169 = (char *)v168 - a10;
      int64_t v170 = ((char *)v168 - a10) * a14;
      a3 += v170;
      result += v170;
      a10 += v170;
      v163 -= v169;
LABEL_88:
      if (v163 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v217 = 0;
    while (1)
    {
      int8x16_t v218 = (int8x16_t *)((char *)result + v217);
      v17.i32[0] = v164;
      uint8x16_t v219 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v220 = vcvtq_f16_u16(vmovl_high_u8(v219));
      float16x8_t v221 = (float16x8_t)vdupq_n_s16(0x1C04u);
      float16x8_t v222 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v219.i8)), v221);
      float16x8_t v223 = vmulq_f16(v220, v221);
      float16x8_t v224 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v223)), v39, vrev16q_s8(*(int8x16_t *)&result[2].i8[v217]));
      float16x8_t v225 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v222)), v39, vrev16q_s8(*(int8x16_t *)&result->i8[v217]));
      float16x8_t v226 = vmulq_f16(v222, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v217]), v23), v26));
      float16x8_t v227 = vmulq_f16(v223, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v217]), v23), v26));
      float16x8_t v228 = (float16x8_t)vqtbl1q_s8((int8x16_t)v227, (int8x16_t)xmmword_1850CD880);
      float16x8_t v17 = (float16x8_t)vqtbl1q_s8((int8x16_t)v226, (int8x16_t)xmmword_1850CD880);
      float16x8_t v229 = (float16x8_t)vqtbl1q_s8((int8x16_t)v225, (int8x16_t)xmmword_1850CD880);
      float16x8_t v230 = (float16x8_t)vqtbl1q_s8((int8x16_t)v224, (int8x16_t)xmmword_1850CD880);
      float32x4_t v231 = vcvtq_f32_f16(*(float16x4_t *)v225.i8);
      float32x4_t v232 = vcvt_hight_f32_f16(v225);
      float32x4_t v233 = vcvtq_f32_f16(*(float16x4_t *)v224.i8);
      float32x4_t v234 = vcvt_hight_f32_f16(v224);
      float32x4_t v235 = vcvtq_f32_f16(*(float16x4_t *)v227.i8);
      float32x4_t v236 = vdivq_f32(v233, vcvtq_f32_f16(*(float16x4_t *)v230.i8));
      float32x4_t v237 = vaddq_f32(v235, v235);
      float32x4_t v238 = vmlaq_f32(vmlsq_f32(v237, v236, v237), v236, vcvtq_f32_f16(*(float16x4_t *)v228.i8));
      float32x4_t v239 = vcvt_hight_f32_f16(v227);
      float32x4_t v240 = vdivq_f32(v234, vcvt_hight_f32_f16(v230));
      float32x4_t v241 = vaddq_f32(v239, v239);
      float32x4_t v242 = vcvtq_f32_f16(*(float16x4_t *)v226.i8);
      float32x4_t v243 = vdivq_f32(v231, vcvtq_f32_f16(*(float16x4_t *)v229.i8));
      float32x4_t v244 = vaddq_f32(v242, v242);
      float32x4_t v245 = vmlaq_f32(vmlsq_f32(v244, v243, v244), v243, vcvtq_f32_f16(*(float16x4_t *)v17.i8));
      float32x4_t v246 = vcvt_hight_f32_f16(v226);
      float32x4_t v247 = vdivq_f32(v232, vcvt_hight_f32_f16(v229));
      float32x4_t v248 = vaddq_f32(v246, v246);
      float32x4_t v249 = vmulq_f32(vmlaq_f32(vmlsq_f32(v248, v247, v248), v247, vcvt_hight_f32_f16(v17)), v232);
      *(float16x4_t *)v231.f32 = vcvt_f16_f32(vmulq_f32(v245, v231));
      int8x16_t v250 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v231.f32);
      int16x8_t v251 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v231.f32, v249)), (int8x16_t)vceqzq_f16(v229));
      int8x16_t v252 = (int8x16_t)vmovl_high_s16(v251);
      float32x4_t v253 = (float32x4_t)vandq_s8(v250, (int8x16_t)vmovl_s16(*(int16x4_t *)v251.i8));
      float16x8_t v254 = vmlsq_f16(v225, v225, v17);
      int8x16_t v255 = vbslq_s8((int8x16_t)vcgtzq_f16(v229), (int8x16_t)vaddq_f16(vmlsq_f16(v226, v226, v229), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v253, vcvtq_f32_f16(*(float16x4_t *)v254.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(vcvt_f16_f32(v249)), v252), vcvt_hight_f32_f16(v254)))), (int8x16_t)v226);
      float32x4_t v256 = vmulq_f32(vmlaq_f32(vmlsq_f32(v241, v240, v241), v240, vcvt_hight_f32_f16(v228)), v234);
      *(float16x4_t *)v233.f32 = vcvt_f16_f32(vmulq_f32(v238, v233));
      int8x16_t v257 = (int8x16_t)vcvtq_f32_f16(*(float16x4_t *)v233.f32);
      int16x8_t v258 = (int16x8_t)vbicq_s8((int8x16_t)vcgezq_f16(vcvt_hight_f16_f32(*(int16x4_t *)v233.f32, v256)), (int8x16_t)vceqzq_f16(v230));
      int8x16_t v259 = (int8x16_t)vmovl_high_s16(v258);
      float32x4_t v260 = (float32x4_t)vandq_s8(v257, (int8x16_t)vmovl_s16(*(int16x4_t *)v258.i8));
      float16x8_t v261 = vmlsq_f16(v224, v224, v228);
      int8x16_t *v218 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v17), v255, (int8x16_t)v225));
      v218[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v228), vbslq_s8((int8x16_t)vcgtzq_f16(v230), (int8x16_t)vaddq_f16(vmlsq_f16(v227, v227, v230), vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vaddq_f32(v260, vcvtq_f32_f16(*(float16x4_t *)v261.i8))), vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(vcvt_f16_f32(v256)), v259), vcvt_hight_f32_f16(v261)))), (int8x16_t)v227), (int8x16_t)v224));
      a10 += v30;
      v163 -= 4;
      if (v163 < 4) {
        break;
      }
      __int32 v164 = *(_DWORD *)a10;
      v217 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v217);
        a3 = (int8x8_t *)((char *)a3 + v217);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v217);
    a3 = (int8x8_t *)((char *)a3 + v36 + v217);
LABEL_91:
    for (unint64_t j = a12 - v162 + v163; j; --j)
    {
      if (*a10)
      {
        float16x4_t v263 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v264 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v263)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v265 = vmul_f16(v263, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v266 = (float16x4_t)vdup_lane_s16((int16x4_t)v265, 3);
        float16x4_t v267 = (float16x4_t)vdup_lane_s16((int16x4_t)v264, 3);
        int8x8_t v268 = (int8x8_t)vcgtz_f16(v267);
        int8x8_t v269 = (int8x8_t)vcgtz_f16(v266);
        int8x8_t v270 = (int8x8_t)vceqz_f16(v267);
        float32x4_t v271 = vcvtq_f32_f16(v264);
        float32x4_t v272 = vcvtq_f32_f16(v265);
        float32x4_t v273 = vdivq_f32(v271, vcvtq_f32_f16(v267));
        float32x4_t v274 = vaddq_f32(v272, v272);
        float16x4_t v275 = vcvt_f16_f32(vmulq_f32(vmlaq_f32(vmlsq_f32(v274, v273, v274), v273, vcvtq_f32_f16(v266)), v271));
        int8x16_t v276 = (int8x16_t)vmovl_s16((int16x4_t)vbic_s8((int8x8_t)vcgez_f16(v275), v270));
        float16x8_t v17 = (float16x8_t)vcvtq_f32_f16(vmls_lane_f16(v264, v264, v265, 3));
        int *result = vrev16_s8(vbsl_s8(v269, vbsl_s8(v268, (int8x8_t)vadd_f16(vmls_lane_f16(v265, v265, v264, 3), vcvt_f16_f32(vaddq_f32((float32x4_t)vandq_s8((int8x16_t)vcvtq_f32_f16(v275), v276), (float32x4_t)v17))), (int8x8_t)v265), (int8x8_t)v264));
      }
      float32x4_t v277 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v277 >= a8) {
        uint64_t v278 = -(uint64_t)a7;
      }
      else {
        uint64_t v278 = 0;
      }
      a3 = &v277[v278];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    float32x4_t v279 = &a5[a4];
    if ((unint64_t)v279 >= a9) {
      uint64_t v280 = v35;
    }
    else {
      uint64_t v280 = 0;
    }
    float32x4_t v281 = &v279[v280];
    uint64_t v282 = a8 + 8 * v280 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v281;
      a8 = v282;
      a5 = v281;
    }
    BOOL v161 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v161 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)22,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  int8x16_t v24 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  if (a15) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = (int8x16_t)vdupq_n_s16(v25);
  int8x16_t v27 = vandq_s8(v26, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v26, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v25;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  float16x8_t v39 = (float16x8_t)vdupq_n_s16(0x1C04u);
  v40.i64[0] = 0x3C003C003C003C00;
  v40.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 3;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v43 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v50 = (unsigned __int8 *)&a10[v42];
          int64_t v51 = (int8x16_t *)a10;
          do
            int8x16_t v52 = v51++;
          while (v51 <= (int8x16_t *)v50 && (vminvq_u8((uint8x16_t)vceqq_s8(*v52, v38)) & 0x80) != 0);
          do
          {
            uint64_t v53 = v52;
            int8x16_t v52 = (int8x16_t *)((char *)v52 + 4);
          }
          while (v52 <= (int8x16_t *)v50 && v53->i32[0] == -1);
          if (v53 < (int8x16_t *)v50)
          {
            while (v53->u8[0] == 255)
            {
              uint64_t v53 = (int8x16_t *)((char *)v53 + 1);
              if (v53 >= (int8x16_t *)v50)
              {
                uint64_t v53 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          uint64_t v54 = 0;
          int64_t v55 = (char *)v53 - a10;
          unint64_t v56 = (char *)v53 - a10;
          do
          {
            float16x8_t v57 = (int8x16_t *)((char *)result + v54);
            float16x8_t v58 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v54], v23), v24);
            float16x8_t v59 = (float16x8_t)vqtbl1q_s8((int8x16_t)v58, (int8x16_t)xmmword_1850CD880);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v54], v23), v24);
            float16x8_t v61 = (float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
            float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v54], v28), v29);
            float16x8_t v62 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
            float16x8_t v63 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v54], v28), v29);
            float16x8_t v64 = (float16x8_t)vqtbl1q_s8((int8x16_t)v63, (int8x16_t)xmmword_1850CD880);
            v148.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v61, v17), vmulq_f16(v62, v60)), vaddq_f16(vmlsq_f16(v17, v17, v61), vmlsq_f16(v60, v60, v62)));
            v145.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v59, v63), vmulq_f16(v64, v58)), vaddq_f16(vmlsq_f16(v63, v63, v59), vmlsq_f16(v58, v58, v64)));
            v148.val[1] = (int8x16_t)vaddq_f16(v60, vmlsq_f16(v62, v62, v61));
            v145.val[1] = (int8x16_t)vaddq_f16(v58, vmlsq_f16(v64, v64, v59));
            int8x16_t *v57 = vbslq_s8((int8x16_t)vcgtzq_f16(v61), vbslq_s8((int8x16_t)vcgtzq_f16(v62), vqtbl2q_s8(v148, (int8x16_t)xmmword_1850CE010), (int8x16_t)v60), (int8x16_t)v17);
            v57[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v59), vbslq_s8((int8x16_t)vcgtzq_f16(v64), vqtbl2q_s8(v145, (int8x16_t)xmmword_1850CE010), (int8x16_t)v58), (int8x16_t)v63);
            a10 += v30;
            v56 -= 4;
            v54 += v36;
          }
          while (v56 > 3);
          a3 = (int8x8_t *)((char *)a3 + v54);
          uint64_t result = (int8x8_t *)((char *)result + v54);
          unint64_t v42 = v42 - v55 + v56;
          goto LABEL_39;
        }
        if (v43) {
          break;
        }
        __int32 v44 = (unsigned __int8 *)&a10[v42];
        __int32 v45 = (int8x16_t *)a10;
        do
          uint8x16_t v46 = v45++;
        while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
        do
        {
          int64_t v47 = v46;
          uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= (int8x16_t *)v44 && !v47->i32[0]);
        if (v47 < (int8x16_t *)v44)
        {
          while (!v47->i8[0])
          {
            int64_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= (int8x16_t *)v44)
            {
              int64_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        int64_t v48 = (char *)v47 - a10;
        int64_t v49 = ((char *)v47 - a10) * a14;
        a3 += v49;
        result += v49;
        a10 += v49;
        v42 -= v48;
LABEL_39:
        if (v42 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v65 = 0;
      while (1)
      {
        float32x4_t v66 = (int8x16_t *)((char *)result + v65);
        v17.i32[0] = v43;
        uint8x16_t v67 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v68 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v67.i8));
        float16x8_t v69 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v67)), v39);
        float16x8_t v70 = vmulq_f16(v68, v39);
        float16x8_t v71 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v70)), v40, *(int8x16_t *)&result->i8[v65]);
        float16x8_t v72 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v69)), v40, *(int8x16_t *)&result[2].i8[v65]);
        float16x8_t v73 = vmulq_f16(v69, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v65], v23), v24));
        float16x8_t v74 = vmulq_f16(v70, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v65], v23), v24));
        float16x8_t v75 = (float16x8_t)vqtbl1q_s8((int8x16_t)v74, (int8x16_t)xmmword_1850CD880);
        float16x8_t v76 = (float16x8_t)vqtbl1q_s8((int8x16_t)v73, (int8x16_t)xmmword_1850CD880);
        float16x8_t v77 = (float16x8_t)vqtbl1q_s8((int8x16_t)v72, (int8x16_t)xmmword_1850CD880);
        float16x8_t v78 = (float16x8_t)vqtbl1q_s8((int8x16_t)v71, (int8x16_t)xmmword_1850CD880);
        int8x16_t v79 = (int8x16_t)vcgtzq_f16(v75);
        v146.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v76, v72), vmulq_f16(v73, v77)), vaddq_f16(vmlsq_f16(v72, v72, v76), vmlsq_f16(v73, v73, v77)));
        v149.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v75, v71), vmulq_f16(v74, v78)), vaddq_f16(vmlsq_f16(v71, v71, v75), vmlsq_f16(v74, v74, v78)));
        v146.val[1] = (int8x16_t)vaddq_f16(v73, vmlsq_f16(v77, v77, v76));
        v149.val[1] = (int8x16_t)vaddq_f16(v74, vmlsq_f16(v78, v78, v75));
        float16x8_t v17 = (float16x8_t)vqtbl2q_s8(v149, (int8x16_t)xmmword_1850CE010);
        int8x16_t *v66 = vbslq_s8(v79, vbslq_s8((int8x16_t)vcgtzq_f16(v78), (int8x16_t)v17, (int8x16_t)v74), (int8x16_t)v71);
        v66[1] = vbslq_s8((int8x16_t)vcgtzq_f16(v76), vbslq_s8((int8x16_t)vcgtzq_f16(v77), vqtbl2q_s8(v146, (int8x16_t)xmmword_1850CE010), (int8x16_t)v73), (int8x16_t)v72);
        a10 += v30;
        v42 -= 4;
        if (v42 < 4) {
          break;
        }
        __int32 v43 = *(_DWORD *)a10;
        v65 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v65);
          a3 = (int8x8_t *)((char *)a3 + v65);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v65);
      a3 = (int8x8_t *)((char *)a3 + v36 + v65);
LABEL_42:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float16x4_t v81 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v82 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v81)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v83 = vmul_f16(v81, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          float16x4_t v84 = (float16x4_t)vdup_lane_s16((int16x4_t)v83, 3);
          float16x4_t v85 = (float16x4_t)vdup_lane_s16((int16x4_t)v82, 3);
          *(float16x4_t *)v17.i8 = vadd_f16(vadd_f16(vmls_lane_f16(v83, v83, v82, 3), vmls_lane_f16(v82, v82, v83, 3)), vabd_f16(vmul_lane_f16(v82, v83, 3), vmul_lane_f16(v83, v82, 3)));
          v17.i16[3] = vadd_f16(v83, vmls_lane_f16(v85, v84, v82, 3)).i16[3];
          int *result = vbsl_s8((int8x8_t)vcgtz_f16(v84), vbsl_s8((int8x8_t)vcgtz_f16(v85), *(int8x8_t *)v17.i8, (int8x8_t)v83), (int8x8_t)v82);
        }
        float32x4_t v86 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v86 >= a8) {
          uint64_t v87 = -(uint64_t)a7;
        }
        else {
          uint64_t v87 = 0;
        }
        a3 = &v86[v87];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      int8x16_t v88 = &a5[a4];
      if ((unint64_t)v88 >= a9) {
        uint64_t v89 = v35;
      }
      else {
        uint64_t v89 = 0;
      }
      int8x16_t v90 = &v88[v89];
      uint64_t v91 = a8 + 8 * v89 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v90;
        a8 = v91;
        a5 = v90;
      }
      BOOL v92 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v92 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v93 = (a8 - (unint64_t)a3) >> 3;
    if (v93 >= a12) {
      unint64_t v93 = a12;
    }
    unint64_t v94 = v93;
    if (v93 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v95 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        float16x8_t v102 = (unsigned __int8 *)&a10[v94];
        float16x8_t v103 = (int8x16_t *)a10;
        do
          float16x8_t v104 = v103++;
        while (v103 <= (int8x16_t *)v102 && (vminvq_u8((uint8x16_t)vceqq_s8(*v104, v38)) & 0x80) != 0);
        do
        {
          float16x8_t v105 = v104;
          float16x8_t v104 = (int8x16_t *)((char *)v104 + 4);
        }
        while (v104 <= (int8x16_t *)v102 && v105->i32[0] == -1);
        if (v105 < (int8x16_t *)v102)
        {
          while (v105->u8[0] == 255)
          {
            float16x8_t v105 = (int8x16_t *)((char *)v105 + 1);
            if (v105 >= (int8x16_t *)v102)
            {
              float16x8_t v105 = (int8x16_t *)&a10[v94];
              break;
            }
          }
        }
        uint64_t v106 = 0;
        int64_t v107 = (char *)v105 - a10;
        unint64_t v108 = (char *)v105 - a10;
        do
        {
          float32x4_t v109 = (int8x16_t *)((char *)result + v106);
          float16x8_t v110 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v106]), v23), v24);
          float16x8_t v111 = (float16x8_t)vqtbl1q_s8((int8x16_t)v110, (int8x16_t)xmmword_1850CD880);
          float16x8_t v112 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v106]), v23), v24);
          float16x8_t v113 = (float16x8_t)vqtbl1q_s8((int8x16_t)v112, (int8x16_t)xmmword_1850CD880);
          float16x8_t v114 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v106]), v28), v29);
          float16x8_t v115 = (float16x8_t)vqtbl1q_s8((int8x16_t)v114, (int8x16_t)xmmword_1850CD880);
          float16x8_t v17 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v106]), v28), v29);
          float16x8_t v116 = (float16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD880);
          v147.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v113, v114), vmulq_f16(v115, v112)), vaddq_f16(vmlsq_f16(v114, v114, v113), vmlsq_f16(v112, v112, v115)));
          v150.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v111, v17), vmulq_f16(v116, v110)), vaddq_f16(vmlsq_f16(v17, v17, v111), vmlsq_f16(v110, v110, v116)));
          v147.val[1] = (int8x16_t)vaddq_f16(v112, vmlsq_f16(v115, v115, v113));
          v150.val[1] = (int8x16_t)vaddq_f16(v110, vmlsq_f16(v116, v116, v111));
          *float32x4_t v109 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v111), vbslq_s8((int8x16_t)vcgtzq_f16(v116), vqtbl2q_s8(v150, (int8x16_t)xmmword_1850CE010), (int8x16_t)v110), (int8x16_t)v17));
          v109[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v113), vbslq_s8((int8x16_t)vcgtzq_f16(v115), vqtbl2q_s8(v147, (int8x16_t)xmmword_1850CE010), (int8x16_t)v112), (int8x16_t)v114));
          a10 += v30;
          v108 -= 4;
          v106 += v36;
        }
        while (v108 > 3);
        a3 = (int8x8_t *)((char *)a3 + v106);
        uint64_t result = (int8x8_t *)((char *)result + v106);
        unint64_t v94 = v94 - v107 + v108;
        goto LABEL_88;
      }
      if (v95) {
        break;
      }
      float16x4_t v96 = (unsigned __int8 *)&a10[v94];
      uint8x16_t v97 = (int8x16_t *)a10;
      do
        float16x8_t v98 = v97++;
      while (v97 <= (int8x16_t *)v96 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v98)) & 0x80) != 0);
      do
      {
        float16x8_t v99 = v98;
        float16x8_t v98 = (int8x16_t *)((char *)v98 + 4);
      }
      while (v98 <= (int8x16_t *)v96 && !v99->i32[0]);
      if (v99 < (int8x16_t *)v96)
      {
        while (!v99->i8[0])
        {
          float16x8_t v99 = (int8x16_t *)((char *)v99 + 1);
          if (v99 >= (int8x16_t *)v96)
          {
            float16x8_t v99 = (int8x16_t *)&a10[v94];
            break;
          }
        }
      }
      int64_t v100 = (char *)v99 - a10;
      int64_t v101 = ((char *)v99 - a10) * a14;
      a3 += v101;
      result += v101;
      a10 += v101;
      v94 -= v100;
LABEL_88:
      if (v94 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v117 = 0;
    while (1)
    {
      float32x4_t v118 = (int8x16_t *)((char *)result + v117);
      v17.i32[0] = v95;
      uint8x16_t v119 = (uint8x16_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v120 = vcvtq_f16_u16(vmovl_high_u8(v119));
      float16x8_t v121 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v119.i8)), v39);
      float16x8_t v122 = vmulq_f16(v120, v39);
      float16x8_t v123 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v122)), v40, vrev16q_s8(*(int8x16_t *)&result[2].i8[v117]));
      float16x8_t v124 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v121)), v40, vrev16q_s8(*(int8x16_t *)&result->i8[v117]));
      float16x8_t v125 = vmulq_f16(v121, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v117]), v23), v24));
      float16x8_t v126 = vmulq_f16(v122, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v117]), v23), v24));
      float16x8_t v127 = (float16x8_t)vqtbl1q_s8((int8x16_t)v126, (int8x16_t)xmmword_1850CD880);
      float16x8_t v128 = (float16x8_t)vqtbl1q_s8((int8x16_t)v125, (int8x16_t)xmmword_1850CD880);
      float16x8_t v129 = (float16x8_t)vqtbl1q_s8((int8x16_t)v124, (int8x16_t)xmmword_1850CD880);
      float16x8_t v130 = (float16x8_t)vqtbl1q_s8((int8x16_t)v123, (int8x16_t)xmmword_1850CD880);
      int8x16_t v131 = (int8x16_t)vcgtzq_f16(v127);
      v151.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v128, v124), vmulq_f16(v125, v129)), vaddq_f16(vmlsq_f16(v124, v124, v128), vmlsq_f16(v125, v125, v129)));
      v144.val[0] = (int8x16_t)vaddq_f16(vabdq_f16(vmulq_f16(v127, v123), vmulq_f16(v126, v130)), vaddq_f16(vmlsq_f16(v123, v123, v127), vmlsq_f16(v126, v126, v130)));
      v151.val[1] = (int8x16_t)vaddq_f16(v125, vmlsq_f16(v129, v129, v128));
      v144.val[1] = (int8x16_t)vaddq_f16(v126, vmlsq_f16(v130, v130, v127));
      float16x8_t v17 = (float16x8_t)vqtbl2q_s8(v144, (int8x16_t)xmmword_1850CE010);
      int8x16_t *v118 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16(v128), vbslq_s8((int8x16_t)vcgtzq_f16(v129), vqtbl2q_s8(v151, (int8x16_t)xmmword_1850CE010), (int8x16_t)v125), (int8x16_t)v124));
      v118[1] = vrev16q_s8(vbslq_s8(v131, vbslq_s8((int8x16_t)vcgtzq_f16(v130), (int8x16_t)v17, (int8x16_t)v126), (int8x16_t)v123));
      a10 += v30;
      v94 -= 4;
      if (v94 < 4) {
        break;
      }
      __int32 v95 = *(_DWORD *)a10;
      v117 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v117);
        a3 = (int8x8_t *)((char *)a3 + v117);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v117);
    a3 = (int8x8_t *)((char *)a3 + v36 + v117);
LABEL_91:
    for (unint64_t j = a12 - v93 + v94; j; --j)
    {
      if (*a10)
      {
        float16x4_t v133 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v134 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v133)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v135 = vmul_f16(v133, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v136 = (float16x4_t)vdup_lane_s16((int16x4_t)v135, 3);
        float16x4_t v137 = (float16x4_t)vdup_lane_s16((int16x4_t)v134, 3);
        *(float16x4_t *)v17.i8 = vadd_f16(vadd_f16(vmls_lane_f16(v135, v135, v134, 3), vmls_lane_f16(v134, v134, v135, 3)), vabd_f16(vmul_lane_f16(v134, v135, 3), vmul_lane_f16(v135, v134, 3)));
        v17.i16[3] = vadd_f16(v135, vmls_lane_f16(v137, v136, v134, 3)).i16[3];
        int *result = vrev16_s8(vbsl_s8((int8x8_t)vcgtz_f16(v136), vbsl_s8((int8x8_t)vcgtz_f16(v137), *(int8x8_t *)v17.i8, (int8x8_t)v135), (int8x8_t)v134));
      }
      float32x4_t v138 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v138 >= a8) {
        uint64_t v139 = -(uint64_t)a7;
      }
      else {
        uint64_t v139 = 0;
      }
      a3 = &v138[v139];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    float16x8_t v140 = &a5[a4];
    if ((unint64_t)v140 >= a9) {
      uint64_t v141 = v35;
    }
    else {
      uint64_t v141 = 0;
    }
    float16x4_t v142 = &v140[v141];
    uint64_t v143 = a8 + 8 * v141 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v142;
      a8 = v143;
      a5 = v142;
    }
    BOOL v92 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v92 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x8_t *composite_pixelmask<(CGCompositeOperation)23,_rgbaf16_t>(int8x8_t *result, uint64_t a2, int8x8_t *a3, uint64_t a4, int8x8_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  int8x16_t v21 = (int8x16_t)vdupq_n_s16(v20);
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vmvnq_s8(vandq_s8(v21, v22));
  int8x16_t v24 = vandq_s8(v21, (int8x16_t)xmmword_1850CDFF0);
  if (a15) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = (int8x16_t)vdupq_n_s16(v25);
  int8x16_t v27 = vandq_s8(v26, v22);
  int8x16_t v28 = vmvnq_s8(v27);
  int8x16_t v29 = vandq_s8(v26, (int8x16_t)xmmword_1850CDFF0);
  uint64_t v30 = 4 * a14;
  int8x8_t v34 = 0;
  int8x8_t v31 = 0;
  v31.i16[3] = v20;
  int8x8_t v32 = vmvn_s8(v31);
  int8x8_t v33 = vand_s8(*(int8x8_t *)v21.i8, (int8x8_t)0x3C00000000000000);
  v34.i16[3] = v25;
  uint64_t v35 = -(a6 * a4);
  uint64_t v36 = 32 * a14;
  uint64_t v37 = 8 * a14;
  v38.i64[0] = -1;
  v38.i64[1] = -1;
  float16x8_t v39 = (float16x8_t)vdupq_n_s16(0x1C04u);
  v40.i64[0] = 0x3C003C003C003C00;
  v40.i64[1] = 0x3C003C003C003C00;
  if ((a17 & 0x30) != 0)
  {
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 3;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 4) {
        goto LABEL_42;
      }
      while (1)
      {
        __int32 v43 = *(_DWORD *)a10;
        if (*(_DWORD *)a10 == -1)
        {
          int64_t v50 = (unsigned __int8 *)&a10[v42];
          int64_t v51 = (int8x16_t *)a10;
          do
            int8x16_t v52 = v51++;
          while (v51 <= (int8x16_t *)v50 && (vminvq_u8((uint8x16_t)vceqq_s8(*v52, v38)) & 0x80) != 0);
          do
          {
            uint64_t v53 = v52;
            int8x16_t v52 = (int8x16_t *)((char *)v52 + 4);
          }
          while (v52 <= (int8x16_t *)v50 && v53->i32[0] == -1);
          if (v53 < (int8x16_t *)v50)
          {
            while (v53->u8[0] == 255)
            {
              uint64_t v53 = (int8x16_t *)((char *)v53 + 1);
              if (v53 >= (int8x16_t *)v50)
              {
                uint64_t v53 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          uint64_t v54 = 0;
          int64_t v55 = (char *)v53 - a10;
          unint64_t v56 = (char *)v53 - a10;
          do
          {
            float16x8_t v57 = (int8x16_t *)((char *)result + v54);
            float16x8_t v58 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v54], v23), v24);
            float16x8_t v59 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v54], v23), v24);
            float16x8_t v60 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result->i8[v54], v28), v29);
            float16x8_t v61 = (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&result[2].i8[v54], v28), v29);
            int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v58, (int8x16_t)xmmword_1850CD880));
            float16x8_t v62 = vmlsq_f16(v60, v60, v59);
            float16x8_t v63 = vmlsq_f16(v61, v61, v58);
            v138.val[0] = (int8x16_t)vaddq_f16(v62, vmlsq_f16(v59, v59, v60));
            v134.val[0] = (int8x16_t)vaddq_f16(v63, vmlsq_f16(v58, v58, v61));
            v138.val[1] = (int8x16_t)vaddq_f16(v62, v59);
            v134.val[1] = (int8x16_t)vaddq_f16(v63, v58);
            int8x16_t *v57 = vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v59, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v138, (int8x16_t)xmmword_1850CE010), (int8x16_t)v59), (int8x16_t)v60);
            v57[1] = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v61, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v134, (int8x16_t)xmmword_1850CE010), (int8x16_t)v58), (int8x16_t)v61);
            a10 += v30;
            v56 -= 4;
            v54 += v36;
          }
          while (v56 > 3);
          a3 = (int8x8_t *)((char *)a3 + v54);
          uint64_t result = (int8x8_t *)((char *)result + v54);
          unint64_t v42 = v42 - v55 + v56;
          goto LABEL_39;
        }
        if (v43) {
          break;
        }
        __int32 v44 = (unsigned __int8 *)&a10[v42];
        __int32 v45 = (int8x16_t *)a10;
        do
          uint8x16_t v46 = v45++;
        while (v45 <= (int8x16_t *)v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
        do
        {
          int64_t v47 = v46;
          uint8x16_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= (int8x16_t *)v44 && !v47->i32[0]);
        if (v47 < (int8x16_t *)v44)
        {
          while (!v47->i8[0])
          {
            int64_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= (int8x16_t *)v44)
            {
              int64_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        int64_t v48 = (char *)v47 - a10;
        int64_t v49 = ((char *)v47 - a10) * a14;
        a3 += v49;
        result += v49;
        a10 += v49;
        v42 -= v48;
LABEL_39:
        if (v42 <= 3) {
          goto LABEL_42;
        }
      }
      uint64_t v64 = 0;
      while (1)
      {
        uint64_t v65 = (int8x16_t *)((char *)result + v64);
        v17.i32[0] = v43;
        uint8x16_t v66 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
        float16x8_t v67 = vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v66.i8));
        float16x8_t v68 = vmulq_f16(vcvtq_f16_u16(vmovl_high_u8(v66)), v39);
        float16x8_t v69 = vmulq_f16(v67, v39);
        float16x8_t v70 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v69)), v40, *(int8x16_t *)&result->i8[v64]);
        float16x8_t v71 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v68)), v40, *(int8x16_t *)&result[2].i8[v64]);
        float16x8_t v72 = vmulq_f16(v68, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3[2].i8[v64], v23), v24));
        float16x8_t v73 = vmulq_f16(v69, (float16x8_t)vorrq_s8(vandq_s8(*(int8x16_t *)&a3->i8[v64], v23), v24));
        int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v73, (int8x16_t)xmmword_1850CD880));
        float16x8_t v74 = vmlsq_f16(v70, v70, v73);
        float16x8_t v75 = vmlsq_f16(v71, v71, v72);
        v136.val[0] = (int8x16_t)vaddq_f16(v75, vmlsq_f16(v72, v72, v71));
        v140.val[0] = (int8x16_t)vaddq_f16(v74, vmlsq_f16(v73, v73, v70));
        v136.val[1] = (int8x16_t)vaddq_f16(v72, v75);
        v140.val[1] = (int8x16_t)vaddq_f16(v73, v74);
        *uint64_t v65 = vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v70, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v140, (int8x16_t)xmmword_1850CE010), (int8x16_t)v73), (int8x16_t)v70);
        v65[1] = vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v72, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v71, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v136, (int8x16_t)xmmword_1850CE010), (int8x16_t)v72), (int8x16_t)v71);
        a10 += v30;
        v42 -= 4;
        if (v42 < 4) {
          break;
        }
        __int32 v43 = *(_DWORD *)a10;
        v64 += v36;
        if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
        {
          uint64_t result = (int8x8_t *)((char *)result + v64);
          a3 = (int8x8_t *)((char *)a3 + v64);
          goto LABEL_39;
        }
      }
      uint64_t result = (int8x8_t *)((char *)result + v36 + v64);
      a3 = (int8x8_t *)((char *)a3 + v36 + v64);
LABEL_42:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float16x4_t v77 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
          float16x4_t v78 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v77)), (int8x8_t)0x3C003C003C003C00, *result);
          float16x4_t v79 = vmul_f16(v77, (float16x4_t)vorr_s8(vand_s8(*a3, v32), v33));
          float16x4_t v80 = vmls_f16(v79, v79, v78);
          v80.i16[3] = v79.i16[3];
          *(float16x4_t *)v17.i8 = vadd_f16(v80, vmls_f16(v78, v78, v79));
          int *result = vbsl_s8((int8x8_t)vdup_lane_s16(vcgtz_f16(v79), 3), vbsl_s8((int8x8_t)vdup_lane_s16(vcgtz_f16(v78), 3), *(int8x8_t *)v17.i8, (int8x8_t)v79), (int8x8_t)v78);
        }
        float16x4_t v81 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v81 >= a8) {
          uint64_t v82 = -(uint64_t)a7;
        }
        else {
          uint64_t v82 = 0;
        }
        a3 = &v81[v82];
        uint64_t result = (int8x8_t *)((char *)result + v37);
      }
      a10 += a11;
      result += a2;
      float16x4_t v83 = &a5[a4];
      if ((unint64_t)v83 >= a9) {
        uint64_t v84 = v35;
      }
      else {
        uint64_t v84 = 0;
      }
      float16x4_t v85 = &v83[v84];
      uint64_t v86 = a8 + 8 * v84 + 8 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v85;
        a8 = v86;
        a5 = v85;
      }
      BOOL v87 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v87 | (a13 == 0)) {
        return result;
      }
    }
  }
  while (2)
  {
    unint64_t v88 = (a8 - (unint64_t)a3) >> 3;
    if (v88 >= a12) {
      unint64_t v88 = a12;
    }
    unint64_t v89 = v88;
    if (v88 < 4) {
      goto LABEL_91;
    }
    while (1)
    {
      __int32 v90 = *(_DWORD *)a10;
      if (*(_DWORD *)a10 == -1)
      {
        uint8x16_t v97 = (unsigned __int8 *)&a10[v89];
        float16x8_t v98 = (int8x16_t *)a10;
        do
          float16x8_t v99 = v98++;
        while (v98 <= (int8x16_t *)v97 && (vminvq_u8((uint8x16_t)vceqq_s8(*v99, v38)) & 0x80) != 0);
        do
        {
          int64_t v100 = v99;
          float16x8_t v99 = (int8x16_t *)((char *)v99 + 4);
        }
        while (v99 <= (int8x16_t *)v97 && v100->i32[0] == -1);
        if (v100 < (int8x16_t *)v97)
        {
          while (v100->u8[0] == 255)
          {
            int64_t v100 = (int8x16_t *)((char *)v100 + 1);
            if (v100 >= (int8x16_t *)v97)
            {
              int64_t v100 = (int8x16_t *)&a10[v89];
              break;
            }
          }
        }
        uint64_t v101 = 0;
        int64_t v102 = (char *)v100 - a10;
        unint64_t v103 = (char *)v100 - a10;
        do
        {
          float16x8_t v104 = (int8x16_t *)((char *)result + v101);
          float16x8_t v105 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v101]), v23), v24);
          float16x8_t v106 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v101]), v23), v24);
          float16x8_t v107 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result[2].i8[v101]), v28), v29);
          float16x8_t v108 = (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&result->i8[v101]), v28), v29);
          int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v105, (int8x16_t)xmmword_1850CD880));
          float16x8_t v109 = vmlsq_f16(v108, v108, v105);
          float16x8_t v110 = vmlsq_f16(v107, v107, v106);
          v137.val[0] = (int8x16_t)vaddq_f16(v110, vmlsq_f16(v106, v106, v107));
          v141.val[0] = (int8x16_t)vaddq_f16(v109, vmlsq_f16(v105, v105, v108));
          v137.val[1] = (int8x16_t)vaddq_f16(v110, v106);
          v141.val[1] = (int8x16_t)vaddq_f16(v109, v105);
          *float16x8_t v104 = vrev16q_s8(vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v108, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v141, (int8x16_t)xmmword_1850CE010), (int8x16_t)v105), (int8x16_t)v108));
          v104[1] = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v106, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v107, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v137, (int8x16_t)xmmword_1850CE010), (int8x16_t)v106), (int8x16_t)v107));
          a10 += v30;
          v103 -= 4;
          v101 += v36;
        }
        while (v103 > 3);
        a3 = (int8x8_t *)((char *)a3 + v101);
        uint64_t result = (int8x8_t *)((char *)result + v101);
        unint64_t v89 = v89 - v102 + v103;
        goto LABEL_88;
      }
      if (v90) {
        break;
      }
      uint64_t v91 = (unsigned __int8 *)&a10[v89];
      BOOL v92 = (int8x16_t *)a10;
      do
        unint64_t v93 = v92++;
      while (v92 <= (int8x16_t *)v91 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v93)) & 0x80) != 0);
      do
      {
        unint64_t v94 = v93;
        unint64_t v93 = (int8x16_t *)((char *)v93 + 4);
      }
      while (v93 <= (int8x16_t *)v91 && !v94->i32[0]);
      if (v94 < (int8x16_t *)v91)
      {
        while (!v94->i8[0])
        {
          unint64_t v94 = (int8x16_t *)((char *)v94 + 1);
          if (v94 >= (int8x16_t *)v91)
          {
            unint64_t v94 = (int8x16_t *)&a10[v89];
            break;
          }
        }
      }
      int64_t v95 = (char *)v94 - a10;
      int64_t v96 = ((char *)v94 - a10) * a14;
      a3 += v96;
      result += v96;
      a10 += v96;
      v89 -= v95;
LABEL_88:
      if (v89 <= 3) {
        goto LABEL_91;
      }
    }
    uint64_t v111 = 0;
    while (1)
    {
      float16x8_t v112 = (int8x16_t *)((char *)result + v111);
      v17.i32[0] = v90;
      uint8x16_t v113 = (uint8x16_t)vqtbl1q_s8(v17, (int8x16_t)xmmword_1850CD8E0);
      float16x8_t v114 = vcvtq_f16_u16(vmovl_high_u8(v113));
      float16x8_t v115 = vmulq_f16(vcvtq_f16_u16(vmovl_u8(*(uint8x8_t *)v113.i8)), v39);
      float16x8_t v116 = vmulq_f16(v114, v39);
      float16x8_t v117 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v116)), v40, vrev16q_s8(*(int8x16_t *)&result[2].i8[v111]));
      float16x8_t v118 = (float16x8_t)vbslq_s8(vandq_s8(v27, (int8x16_t)vcgtzq_f16(v115)), v40, vrev16q_s8(*(int8x16_t *)&result->i8[v111]));
      float16x8_t v119 = vmulq_f16(v115, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3->i8[v111]), v23), v24));
      float16x8_t v120 = vmulq_f16(v116, (float16x8_t)vorrq_s8(vandq_s8(vrev16q_s8(*(int8x16_t *)&a3[2].i8[v111]), v23), v24));
      int8x16_t v17 = (int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v120, (int8x16_t)xmmword_1850CD880));
      float16x8_t v121 = vmlsq_f16(v118, v118, v119);
      float16x8_t v122 = vmlsq_f16(v117, v117, v120);
      v139.val[0] = (int8x16_t)vaddq_f16(v121, vmlsq_f16(v119, v119, v118));
      v135.val[0] = (int8x16_t)vaddq_f16(v122, vmlsq_f16(v120, v120, v117));
      v139.val[1] = (int8x16_t)vaddq_f16(v119, v121);
      v135.val[1] = (int8x16_t)vaddq_f16(v120, v122);
      *float16x8_t v112 = vrev16q_s8(vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v119, (int8x16_t)xmmword_1850CD880)), vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v118, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v139, (int8x16_t)xmmword_1850CE010), (int8x16_t)v119), (int8x16_t)v118));
      v112[1] = vrev16q_s8(vbslq_s8(v17, vbslq_s8((int8x16_t)vcgtzq_f16((float16x8_t)vqtbl1q_s8((int8x16_t)v117, (int8x16_t)xmmword_1850CD880)), vqtbl2q_s8(v135, (int8x16_t)xmmword_1850CE010), (int8x16_t)v120), (int8x16_t)v117));
      a10 += v30;
      v89 -= 4;
      if (v89 < 4) {
        break;
      }
      __int32 v90 = *(_DWORD *)a10;
      v111 += v36;
      if ((*(_DWORD *)a10 - 1) >= 0xFFFFFFFE)
      {
        uint64_t result = (int8x8_t *)((char *)result + v111);
        a3 = (int8x8_t *)((char *)a3 + v111);
        goto LABEL_88;
      }
    }
    uint64_t result = (int8x8_t *)((char *)result + v36 + v111);
    a3 = (int8x8_t *)((char *)a3 + v36 + v111);
LABEL_91:
    for (unint64_t j = a12 - v88 + v89; j; --j)
    {
      if (*a10)
      {
        float16x4_t v124 = vmul_f16(vcvt_f16_u16((uint16x4_t)vdup_n_s16(*a10)), (float16x4_t)vdup_n_s16(0x1C04u));
        float16x4_t v125 = (float16x4_t)vbsl_s8(vand_s8(v34, (int8x8_t)vcgtz_f16(v124)), (int8x8_t)0x3C003C003C003C00, vrev16_s8(*result));
        float16x4_t v126 = vmul_f16(v124, (float16x4_t)vorr_s8(vand_s8(vrev16_s8(*a3), v32), v33));
        float16x4_t v127 = vmls_f16(v126, v126, v125);
        v127.i16[3] = v126.i16[3];
        *(float16x4_t *)v17.i8 = vadd_f16(v127, vmls_f16(v125, v125, v126));
        int *result = vrev16_s8(vbsl_s8((int8x8_t)vdup_lane_s16(vcgtz_f16(v126), 3), vbsl_s8((int8x8_t)vdup_lane_s16(vcgtz_f16(v125), 3), *(int8x8_t *)v17.i8, (int8x8_t)v126), (int8x8_t)v125));
      }
      float16x8_t v128 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v128 >= a8) {
        uint64_t v129 = -(uint64_t)a7;
      }
      else {
        uint64_t v129 = 0;
      }
      a3 = &v128[v129];
      uint64_t result = (int8x8_t *)((char *)result + v37);
    }
    a10 += a11;
    result += a2;
    float16x8_t v130 = &a5[a4];
    if ((unint64_t)v130 >= a9) {
      uint64_t v131 = v35;
    }
    else {
      uint64_t v131 = 0;
    }
    float16x8_t v132 = &v130[v131];
    uint64_t v133 = a8 + 8 * v131 + 8 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v132;
      a8 = v133;
      a5 = v132;
    }
    BOOL v87 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v87 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

void RGBAf16_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  uint64_t v499 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  int v475 = *(_DWORD *)(a1 + 8);
  unint64_t v5 = *(int *)(a1 + 28);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v480 = *(void *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  float v7 = *(int **)(a1 + 136);
  uint64_t v476 = *(void *)(a2 + 96);
  uint64_t v479 = *(void *)(a2 + 104);
  int v481 = 0;
  *(void *)(a2 + 264) = &v481;
  uint64_t v469 = (int)v4;
  unint64_t v8 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v8 > 0x1FFFFFF) {
    return;
  }
  __n128 v474 = a4;
  uint64_t v478 = *(int *)(a1 + 16);
  uint64_t v477 = (void *)*(int *)(a1 + 12);
  uint64_t v12 = *(int *)(a2 + 16);
  uint64_t v13 = (v12 + 10) * v8;
  if (v13 > 65439)
  {
    float16x8_t v16 = (char *)malloc_type_calloc(1uLL, v13 + 96, 0x508B8458uLL);
    float16x8_t v15 = v16;
    uint64_t v18 = v16;
    if (!v16) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    float16x8_t v15 = &v462[-((v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v15, v14);
    uint64_t v18 = 0;
  }
  double v466 = v18;
  unsigned int v470 = a3;
  unint64_t v19 = v5 >> 3;
  unint64_t v20 = (unint64_t)(v15 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v21 = v20 + ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v12) {
    uint64_t v22 = 8 * v8;
  }
  else {
    uint64_t v22 = 0;
  }
  unint64_t v23 = v21 + v22;
  *(void *)(a2 + 144) = v20;
  *(void *)(a2 + 152) = v21 + v22;
  *(void *)(a2 + 160) = v21;
  uint64_t v24 = v6 + 8 * ((void)v477 + v19 * v478);
  uint64_t v25 = v469;
  unint64_t v465 = v5 >> 3;
  uint64_t v472 = v19 - v469;
  uint64_t v26 = *(int *)(a1 + 104);
  int v27 = *(_DWORD *)(a1 + 108);
  int v28 = *(unsigned __int8 *)(a1 + 2);
  if (v28 == 6 || v28 == 1)
  {
    uint64_t v29 = v476;
    if (v7)
    {
      uint64_t v30 = 0;
      int v31 = 0;
      uint64_t v32 = *(int *)(a1 + 124);
      uint64_t v33 = v469;
      int8x8_t v34 = (unsigned __int8 *)v7 + v26 + (int)v32 * (uint64_t)v27;
      uint64_t v464 = v32;
      uint64_t v471 = v32 - v469;
      unsigned int v35 = v470;
      int v36 = v475;
      goto LABEL_20;
    }
LABEL_17:
    float16x8_t v39 = v466;
    if (v466) {
      goto LABEL_434;
    }
    return;
  }
  if (!v7)
  {
    uint64_t v471 = 0;
    uint64_t v464 = 0;
    uint64_t v30 = 0;
    uint64_t v33 = v469;
    int8x8_t v34 = 0;
    int v31 = 0;
    unsigned int v35 = v470;
    int v36 = v475;
    uint64_t v29 = v476;
    goto LABEL_20;
  }
  int v36 = v475;
  shape_enum_clip_alloc((uint64_t)v16, v17, v7, 1, 1, 1, v26, v27, v4, v475);
  if (!v37) {
    goto LABEL_17;
  }
  uint64_t v464 = 0;
  uint64_t v38 = (int)((v12 * v8 + 15) & 0xFFFFFFF0);
  if (!v12) {
    uint64_t v38 = 8 * v8;
  }
  int v31 = 0;
  uint64_t v471 = -v25;
  int8x8_t v34 = (unsigned __int8 *)(v23 + v38 + 16);
  unsigned int v35 = v470;
  uint64_t v29 = v476;
  uint64_t v30 = v37;
  while (1)
  {
LABEL_425:
    while (1)
    {
      int v458 = *((_DWORD *)v34 - 4);
      int v459 = v458 - v31;
      if (v458 <= v31) {
        break;
      }
      v36 -= v459;
      if (v36 < 1) {
        goto LABEL_431;
      }
      v29 += *(void *)(a2 + 128) * v459;
      v479 += *(void *)(a2 + 136) * v459;
      v24 += 8 * v465 * v459;
      int v31 = v458;
    }
    if (v31 < *((_DWORD *)v34 - 3) + v458) {
      break;
    }
    if (!shape_enum_clip_scan((uint64_t)v30, (_DWORD *)v34 - 4)) {
      goto LABEL_431;
    }
  }
  uint64_t v33 = v469;
LABEL_20:
  uint64_t v468 = (v4 - 1) + 1;
  uint64_t v467 = -v33;
  uint64_t v463 = 8 * v33;
  uint64_t v473 = v35;
  int8x16_t v40 = v30;
  uint64_t v41 = v479;
  while (2)
  {
    LODWORD(v478) = v31;
    uint64_t v477 = v40;
    *(_DWORD *)(a2 + 240) = v36;
    uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))a2)(a2, v29, v41, v4);
    int64_t v55 = *(float16x4_t **)(a2 + 160);
    unint64_t v56 = *(unsigned __int8 **)(a2 + 144);
    unsigned int v57 = *(_DWORD *)(a2 + 8);
    if (v57 == *(_DWORD *)(a2 + 12))
    {
      _D1 = (int8x8_t)v474.n128_u64[0];
      if (v474.n128_f32[0] < 1.0)
      {
        int v59 = v4;
        float16x8_t v60 = *(unsigned char **)(a2 + 144);
        do
        {
          if (*v60) {
            float16x4_t *v55 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v55), *(float *)_D1.i32));
          }
          ++v60;
          ++v55;
          --v59;
        }
        while (v59);
        v55 += v467;
        v56 += v468 + v467;
      }
    }
    else
    {
      int v61 = HIWORD(v57) & 0x3F;
      _D1 = (int8x8_t)v474.n128_u64[0];
      if (v61 != 32)
      {
        if (v61 == 16) {
          _CGHandleAssert("RGBAf16_image_pixel", 10428, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", v47, v48, v49, v462[0]);
        }
        _CGHandleAssert("RGBAf16_image_pixel", 10478, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_rgba_float16.cc", "", "Unimplemented", v47, v48, v49, v462[0]);
      }
      uint64_t v62 = *(void *)(a2 + 152);
      uint64_t v63 = 0;
      if (v474.n128_f32[0] >= 1.0)
      {
        do
        {
          if (v56[v63]) {
            v55[v63] = *(float16x4_t *)(v62 + 8 * v63);
          }
          ++v63;
        }
        while (v4 != v63);
      }
      else
      {
        do
        {
          if (v56[v63]) {
            v55[v63] = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)(v62 + 8 * v63)), *(float *)_D1.i32));
          }
          ++v63;
        }
        while (v4 != v63);
      }
    }
    if (v35 > 0x1B) {
      goto LABEL_372;
    }
    uint64_t v479 = v41;
    switch(v473)
    {
      case 1:
        if (use_vImage_image_compositing(void)::predicate[0] != -1) {
          dispatch_once(use_vImage_image_compositing(void)::predicate, &__block_literal_global_24_21460);
        }
        if (use_vImage_image_compositing(void)::status)
        {
          int v498 = 66051;
          uint64_t v494 = v24;
          uint64_t v495 = 1;
          uint64_t v496 = v469;
          uint64_t v497 = v463;
          uint64_t v490 = v55;
          uint64_t v491 = 1;
          uint64_t v492 = v469;
          uint64_t v493 = v463;
          v486 = v56;
          uint64_t v487 = 1;
          uint64_t v488 = v469;
          uint64_t v489 = v469;
          double v482 = v34;
          uint64_t v483 = 1;
          uint64_t v484 = v469;
          uint64_t v485 = v469;
          vImageCGCompositeImage_ARGB16F();
          int v67 = v478;
        }
        else
        {
          unsigned __int8 v428 = *v56;
          uint64_t v429 = v56 + 1;
          int v430 = v4;
          if (v34)
          {
            uint64_t v431 = v34;
            int v432 = (float16x4_t *)v24;
            int v67 = v478;
            do
            {
              if (v428)
              {
                unsigned int v433 = ((unsigned __int16)(*v431 * v428 + ((*v431 * v428) >> 8) + 1) >> 8);
                if (v433)
                {
                  if (v433 == 255) {
                    float16x4_t v434 = *v55;
                  }
                  else {
                    float16x4_t v434 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v432), 1.0 - (float)((float)v433 * 0.0039216)), vcvtq_f32_f16(*v55), (float)v433 * 0.0039216));
                  }
                  *int v432 = v434;
                }
              }
              unsigned __int8 v435 = *v429++;
              unsigned __int8 v428 = v435;
              ++v55;
              ++v431;
              ++v432;
              --v430;
            }
            while (v430);
          }
          else
          {
            unint64_t v455 = (float16x4_t *)v24;
            int v67 = v478;
            do
            {
              if (v428)
              {
                if (v428 == 255) {
                  float16x4_t v456 = *v55;
                }
                else {
                  float16x4_t v456 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v455), 1.0 - (float)((float)v428 * 0.0039216)), vcvtq_f32_f16(*v55), (float)v428 * 0.0039216));
                }
                *unint64_t v455 = v456;
              }
              unsigned __int8 v457 = *v429++;
              unsigned __int8 v428 = v457;
              ++v55;
              ++v455;
              --v430;
            }
            while (v430);
          }
        }
        if (v34) {
          v34 += v464;
        }
        else {
          int8x8_t v34 = 0;
        }
        v24 += 8 * v465;
        uint64_t v41 = v479;
        uint64_t v30 = v477;
        goto LABEL_374;
      case 2:
        unsigned __int8 v68 = *v56;
        if (v34)
        {
          uint64_t v69 = 0;
          float16x8_t v70 = v56 + 1;
          int v71 = v4;
          int v67 = v478;
          while (1)
          {
            if (!v68) {
              goto LABEL_65;
            }
            unsigned int v72 = ((unsigned __int16)(*v34 * v68 + ((*v34 * v68) >> 8) + 1) >> 8);
            if (!((unsigned __int16)(*v34 * v68 + ((*v34 * v68) >> 8) + 1) >> 8)) {
              goto LABEL_65;
            }
            if (v72 == 255)
            {
              float16x8_t v73 = &v55[v69];
              short float v74 = *(short float *)&v55[v69].i16[3];
              if (v74 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                uint64_t v94 = v24 + v69 * 8;
                *(_DWORD *)uint64_t v94 = v73->i32[0];
                *(_WORD *)(v94 + 4) = v73->i16[2];
                *(short float *)(v94 + 6) = v74;
                goto LABEL_65;
              }
              __asm { FCMP            H0, #0 }
              if (!(_NF ^ _VF | _ZF))
              {
                __asm { FCVT            S0, H0 }
                v50.n128_u32[0] = v55[v69].u32[0];
                v81.i64[0] = vcvtq_f32_f16((float16x4_t)v50.n128_u64[0]).u64[0];
                _H3 = v55[v69].i16[2];
                __asm { FCVT            S3, H3 }
                v81.i64[1] = __PAIR64__(LODWORD(_S0), _S3);
                __n128 v50 = (__n128)vmlaq_n_f32(v81, vcvtq_f32_f16(*(float16x4_t *)(v24 + v69 * 8)), 1.0 - _S0);
                float16x4_t v84 = vcvt_f16_f32((float32x4_t)v50);
LABEL_63:
                *(float16x4_t *)(v24 + v69 * 8) = v84;
              }
            }
            else
            {
              *(float *)_D1.i32 = (float)v72 * 0.0039216;
              float16x4_t v85 = &v55[v69];
              _H0 = v55[v69].i16[3];
              __asm { FCVT            S0, H0 }
              _S0 = *(float *)_D1.i32 * _S0;
              __asm
              {
                FCVT            H0, S0
                FCMP            H0, #0
              }
              if (!(_NF ^ _VF | _ZF))
              {
                _H2 = v85->i16[0];
                LODWORD(_D3) = *(__int32 *)((char *)v85->i32 + 2);
                float32x4_t v91 = vcvtq_f32_f16(*(float16x4_t *)&_D3);
                *(float32x2_t *)v91.f32 = vmul_n_f32(*(float32x2_t *)v91.f32, *(float *)_D1.i32);
                __asm { FCVT            S2, H2 }
                *(float *)_D1.i32 = *(float *)_D1.i32 * _S2;
                __asm { FCVT            H1, S1 }
                _D1 = vext_s8(vext_s8(_D1, _D1, 2uLL), (int8x8_t)vcvt_f16_f32(v91), 6uLL);
                _D1.i16[3] = _H0;
                float32x4_t v93 = vcvtq_f32_f16((float16x4_t)_D1);
                _D3 = *(double *)(v24 + v69 * 8);
                __n128 v50 = (__n128)vcvtq_f32_f16(*(float16x4_t *)&_D3);
                float16x4_t v84 = vcvt_f16_f32(vmlaq_n_f32(v93, (float32x4_t)v50, 1.0 - v93.f32[3]));
                goto LABEL_63;
              }
            }
LABEL_65:
            unsigned __int8 v95 = *v70++;
            unsigned __int8 v68 = v95;
            ++v34;
            ++v69;
            if (!--v71)
            {
              uint64_t v96 = v24 + v69 * 8 - 8;
              v34 += v471;
              uint64_t v30 = v477;
              goto LABEL_413;
            }
          }
        }
        int v436 = (short float *)v55 + 2;
        uint64_t v96 = v24 - 8;
        __int16 v437 = v56 + 1;
        int v438 = v4;
        uint64_t v30 = v477;
        int v67 = v478;
        do
        {
          if (!v68) {
            goto LABEL_411;
          }
          if (v68 != 255)
          {
            *(float *)_D1.i32 = (float)v68 * 0.0039216;
            _H0 = *((_WORD *)v436 + 1);
            __asm { FCVT            S0, H0 }
            _S0 = *(float *)_D1.i32 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_411;
            }
            v50.n128_u32[0] = *(_DWORD *)(v436 - 1);
            float32x4_t v450 = vcvtq_f32_f16((float16x4_t)v50.n128_u64[0]);
            *(float32x2_t *)v450.f32 = vmul_n_f32(*(float32x2_t *)v450.f32, *(float *)_D1.i32);
            _H3 = *((_WORD *)v436 - 2);
            __asm { FCVT            S3, H3 }
            *(float *)_D1.i32 = *(float *)_D1.i32 * _S3;
            __asm { FCVT            H1, S1 }
            _D1 = vext_s8(vext_s8(_D1, _D1, 2uLL), (int8x8_t)vcvt_f16_f32(v450), 6uLL);
            _D1.i16[3] = _H0;
            float32x4_t v453 = vcvtq_f32_f16((float16x4_t)_D1);
            __n128 v50 = (__n128)vcvtq_f32_f16(*(float16x4_t *)(v96 + 8));
            float16x4_t v445 = vcvt_f16_f32(vmlaq_n_f32(v453, (float32x4_t)v50, 1.0 - v453.f32[3]));
            goto LABEL_409;
          }
          short float v439 = v436[1];
          if (v439 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_411;
            }
            __asm { FCVT            S0, H0 }
            v50.n128_u32[0] = *((_DWORD *)v436 - 1);
            v442.i64[0] = vcvtq_f32_f16((float16x4_t)v50.n128_u64[0]).u64[0];
            _H3 = *v436;
            __asm { FCVT            S3, H3 }
            v442.i64[1] = __PAIR64__(LODWORD(_S0), _S3);
            __n128 v50 = (__n128)vmlaq_n_f32(v442, vcvtq_f32_f16(*(float16x4_t *)(v96 + 8)), 1.0 - _S0);
            float16x4_t v445 = vcvt_f16_f32((float32x4_t)v50);
LABEL_409:
            *(float16x4_t *)(v96 + 8) = v445;
            goto LABEL_411;
          }
          *(_DWORD *)(v96 + 8) = *((_DWORD *)v436 - 1);
          *(short float *)(v96 + 12) = *v436;
          *(short float *)(v96 + 14) = v439;
LABEL_411:
          unsigned __int8 v454 = *v437++;
          unsigned __int8 v68 = v454;
          v436 += 4;
          v96 += 8;
          --v438;
        }
        while (v438);
        int8x8_t v34 = 0;
LABEL_413:
        uint64_t v24 = v96 + 8 * v472 + 8;
        uint64_t v41 = v479;
LABEL_374:
        if (--v36)
        {
          int8x16_t v40 = 0;
          int v31 = v67 + 1;
          v29 += *(void *)(a2 + 128);
          v41 += *(void *)(a2 + 136);
          if (v30)
          {
            uint64_t v479 = v41;
            goto LABEL_425;
          }
          continue;
        }
LABEL_431:
        uint64_t v460 = v466;
        if (v30) {
          free(v30);
        }
        float16x8_t v39 = v460;
        if (v460) {
LABEL_434:
        }
          free(v39);
        return;
      case 3:
        int v97 = v4;
        float16x8_t v98 = v34;
        do
        {
          unsigned int v99 = *v56;
          if (*v56)
          {
            if (v34) {
              unsigned int v99 = (*v98 * v99 + ((*v98 * v99) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v99)
            {
              if (v99 == 255)
              {
                float16x4_t v100 = vmul_n_f16(*v55, *(short float *)(v24 + 6));
              }
              else
              {
                float32x4_t v101 = vcvtq_f32_f16(*(float16x4_t *)v24);
                float16x4_t v100 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v101, 1.0 - (float)((float)v99 * 0.0039216)), vcvtq_f32_f16(*v55), vmuls_lane_f32((float)v99 * 0.0039216, v101, 3)));
              }
              *(float16x4_t *)uint64_t v24 = v100;
            }
          }
          ++v56;
          ++v55;
          v98 += v34 != 0;
          v24 += 8;
          --v97;
        }
        while (v97);
        goto LABEL_201;
      case 4:
        int64_t v102 = (_WORD *)(v24 + 6);
        unint64_t v103 = (_WORD *)v55 + 2;
        int v104 = v4;
        float16x8_t v105 = v34;
        uint64_t v30 = v477;
        do
        {
          float16x8_t v106 = v102;
          unsigned int v107 = *v56;
          if (*v56)
          {
            if (v34) {
              unsigned int v107 = (*v105 * v107 + ((*v105 * v107) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v107)
            {
              if (v107 == 255)
              {
                _H0 = *(v103 - 2);
                __asm { FCVT            S0, H0 }
                float16x8_t v110 = (_WORD *)(v24 + 6);
                _H1 = *v106;
                __asm { FCVT            S1, H1 }
                float v113 = 1.0 - _S1;
                _S0 = v113 * _S0;
                __asm { FCVT            H0, S0 }
                *(v106 - 3) = LOWORD(_S0);
                LOWORD(_S0) = *(v103 - 1);
                __asm { FCVT            S0, H0 }
                _S0 = v113 * _S0;
                __asm { FCVT            H0, S0 }
                *(v106 - 2) = LOWORD(_S0);
                LOWORD(_S0) = *v103;
                __asm { FCVT            S0, H0 }
                _S0 = v113 * _S0;
                __asm { FCVT            H0, S0 }
                *(v106 - 1) = LOWORD(_S0);
                LOWORD(_S0) = v103[1];
                __asm { FCVT            S0, H0 }
                _S0 = v113 * _S0;
              }
              else
              {
                float v121 = (float)v107 * 0.0039216;
                _H1 = *(v103 - 2);
                __asm { FCVT            S1, H1 }
                _H2 = *v106;
                __asm { FCVT            S2, H2 }
                float v126 = v121 * (float)(1.0 - _S2);
                _H5 = *(v106 - 3);
                __asm { FCVT            S5, H5 }
                float v129 = 1.0 - v121;
                _S1 = (float)(v129 * _S5) + (float)(_S1 * v126);
                __asm { FCVT            H1, S1 }
                *(v106 - 3) = LOWORD(_S1);
                LOWORD(_S1) = *(v103 - 1);
                __asm { FCVT            S1, H1 }
                _H3 = *(v106 - 2);
                __asm { FCVT            S3, H3 }
                _S1 = (float)(v129 * _S3) + (float)(_S1 * v126);
                __asm { FCVT            H1, S1 }
                *(v106 - 2) = LOWORD(_S1);
                LOWORD(_S1) = *v103;
                __asm { FCVT            S1, H1 }
                LOWORD(_S3) = *(v106 - 1);
                __asm { FCVT            S3, H3 }
                _S1 = (float)(v129 * _S3) + (float)(_S1 * v126);
                __asm { FCVT            H1, S1 }
                *(v106 - 1) = LOWORD(_S1);
                LOWORD(_S1) = v103[1];
                __asm { FCVT            S1, H1 }
                _S0 = (float)(v129 * _S2) + (float)(_S1 * v126);
                float16x8_t v110 = v106;
              }
              __asm { FCVT            H0, S0 }
              *float16x8_t v110 = _H0;
            }
          }
          ++v56;
          v105 += v34 != 0;
          v24 += 8;
          int64_t v102 = v106 + 4;
          v103 += 4;
          --v104;
        }
        while (v104);
        int8x8_t v34 = &v105[v471];
        uint64_t v24 = (uint64_t)&v106[4 * v472 + 1];
        goto LABEL_174;
      case 5:
        int v140 = v4;
        float16x8_t v98 = v34;
        while (1)
        {
          unsigned int v141 = *v56;
          if (*v56)
          {
            if (!v34) {
              goto LABEL_94;
            }
            unsigned int v142 = *v98 * v141 + ((*v98 * v141) >> 8) + 1;
            if (BYTE1(v142)) {
              break;
            }
          }
LABEL_95:
          ++v56;
          ++v55;
          v98 += v34 != 0;
          v24 += 8;
          if (!--v140) {
            goto LABEL_201;
          }
        }
        unsigned int v141 = v142 >> 8;
LABEL_94:
        float32x4_t v143 = vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v55), (float)v141 * 0.0039216)));
        float32x4_t v144 = vcvtq_f32_f16(*(float16x4_t *)v24);
        *(float16x4_t *)uint64_t v24 = vcvt_f16_f32(vmlaq_laneq_f32(vmulq_n_f32(v144, 1.0 - v143.f32[3]), v143, v144, 3));
        goto LABEL_95;
      case 6:
        int8x16x2_t v145 = (_WORD *)v55 + 2;
        int v146 = v4;
        int8x16x2_t v147 = v34;
        uint64_t v30 = v477;
        while (1)
        {
          unsigned int v148 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v149 = *v147 * v148 + ((*v147 * v148) >> 8) + 1;
              if (!BYTE1(v149)) {
                goto LABEL_107;
              }
              unsigned int v148 = v149 >> 8;
            }
            _H0 = *(_WORD *)(v24 + 6);
            __asm { FCVT            S0, H0 }
            float v152 = 1.0 - _S0;
            if ((float)(1.0 - _S0) >= 1.0)
            {
              _H0 = *(v145 - 2);
              __asm { FCVT            S0, H0 }
              float v169 = (float)v148 * 0.0039216;
              _S0 = v169 * _S0;
              __asm { FCVT            H0, S0 }
              *(_WORD *)uint64_t v24 = LOWORD(_S0);
              LOWORD(_S0) = *(v145 - 1);
              __asm { FCVT            S0, H0 }
              _S0 = v169 * _S0;
              __asm { FCVT            H0, S0 }
              *(_WORD *)(v24 + 2) = LOWORD(_S0);
              LOWORD(_S0) = *v145;
              __asm { FCVT            S0, H0 }
              _S0 = v169 * _S0;
              __asm { FCVT            H0, S0 }
              *(_WORD *)(v24 + 4) = LOWORD(_S0);
              LOWORD(_S0) = v145[1];
              __asm { FCVT            S0, H0 }
              _S0 = v169 * _S0;
              goto LABEL_106;
            }
            if (v152 > 0.0)
            {
              _H2 = *(_WORD *)v24;
              __asm { FCVT            S2, H2 }
              _H3 = *(v145 - 2);
              __asm { FCVT            S3, H3 }
              float v157 = (float)((float)v148 * 0.0039216) * v152;
              _S2 = _S2 + (float)(_S3 * v157);
              __asm { FCVT            H2, S2 }
              *(_WORD *)uint64_t v24 = LOWORD(_S2);
              LOWORD(_S2) = *(_WORD *)(v24 + 2);
              __asm { FCVT            S2, H2 }
              LOWORD(_S3) = *(v145 - 1);
              __asm { FCVT            S3, H3 }
              _S2 = _S2 + (float)(_S3 * v157);
              __asm { FCVT            H2, S2 }
              *(_WORD *)(v24 + 2) = LOWORD(_S2);
              LOWORD(_S2) = *(_WORD *)(v24 + 4);
              __asm { FCVT            S2, H2 }
              LOWORD(_S3) = *v145;
              __asm { FCVT            S3, H3 }
              _S2 = _S2 + (float)(_S3 * v157);
              __asm { FCVT            H2, S2 }
              *(_WORD *)(v24 + 4) = LOWORD(_S2);
              LOWORD(_S2) = v145[1];
              __asm { FCVT            S2, H2 }
              _S0 = _S0 + (float)(_S2 * v157);
LABEL_106:
              __asm { FCVT            H0, S0 }
              *(_WORD *)(v24 + 6) = _H0;
            }
          }
LABEL_107:
          ++v56;
          v147 += v34 != 0;
          v24 += 8;
          v145 += 4;
          if (!--v146) {
            goto LABEL_173;
          }
        }
      case 7:
        unint64_t v177 = (short float *)v55 + 3;
        int v178 = v4;
        int8x16x2_t v147 = v34;
        uint64_t v30 = v477;
        do
        {
          unsigned int v179 = *v56;
          if (*v56)
          {
            if (v34) {
              unsigned int v179 = (*v147 * v179 + ((*v147 * v179) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v179)
            {
              if (v179 == 255)
              {
                float16x4_t v180 = vmul_n_f16(*(float16x4_t *)v24, *v177);
              }
              else
              {
                _H1 = *v177;
                __asm { FCVT            S1, H1 }
                float32x4_t v183 = vcvtq_f32_f16(*(float16x4_t *)v24);
                float16x4_t v180 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v183, 1.0 - (float)((float)v179 * 0.0039216)), v183, (float)((float)v179 * 0.0039216) * _S1));
              }
              *(float16x4_t *)uint64_t v24 = v180;
            }
          }
          ++v56;
          v147 += v34 != 0;
          v24 += 8;
          v177 += 4;
          --v178;
        }
        while (v178);
        goto LABEL_173;
      case 8:
        float16x8_t v184 = (__int16 *)v55 + 3;
        int v185 = v4;
        int8x16x2_t v147 = v34;
        uint64_t v30 = v477;
        do
        {
          unsigned int v186 = *v56;
          if (*v56)
          {
            if (v34) {
              unsigned int v186 = (*v147 * v186 + ((*v147 * v186) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v186)
            {
              if (v186 == 255)
              {
                _H0 = *(_WORD *)v24;
                __asm { FCVT            S0, H0 }
                _H1 = *v184;
                __asm { FCVT            S1, H1 }
                float v191 = 1.0 - _S1;
                _S0 = v191 * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)uint64_t v24 = LOWORD(_S0);
                LOWORD(_S0) = *(_WORD *)(v24 + 2);
                __asm { FCVT            S0, H0 }
                _S0 = v191 * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)(v24 + 2) = LOWORD(_S0);
                LOWORD(_S0) = *(_WORD *)(v24 + 4);
                __asm { FCVT            S0, H0 }
                _S0 = v191 * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)(v24 + 4) = LOWORD(_S0);
                float32x4_t v197 = (_WORD *)(v24 + 6);
                LOWORD(_S0) = *(_WORD *)(v24 + 6);
                __asm { FCVT            S0, H0 }
                _S0 = v191 * _S0;
              }
              else
              {
                float v200 = (float)v186 * 0.0039216;
                _H1 = *(_WORD *)v24;
                __asm { FCVT            S1, H1 }
                _H2 = *v184;
                __asm { FCVT            S2, H2 }
                float v205 = v200 * (float)(1.0 - _S2);
                float v206 = 1.0 - v200;
                _S1 = (float)(v206 * _S1) + (float)(_S1 * v205);
                __asm { FCVT            H1, S1 }
                *(_WORD *)uint64_t v24 = LOWORD(_S1);
                LOWORD(_S1) = *(_WORD *)(v24 + 2);
                __asm { FCVT            S1, H1 }
                _S1 = (float)(v206 * _S1) + (float)(_S1 * v205);
                __asm { FCVT            H1, S1 }
                *(_WORD *)(v24 + 2) = LOWORD(_S1);
                LOWORD(_S1) = *(_WORD *)(v24 + 4);
                __asm { FCVT            S1, H1 }
                _S1 = (float)(v206 * _S1) + (float)(_S1 * v205);
                __asm { FCVT            H1, S1 }
                *(_WORD *)(v24 + 4) = LOWORD(_S1);
                float32x4_t v197 = (_WORD *)(v24 + 6);
                LOWORD(_S1) = *(_WORD *)(v24 + 6);
                __asm { FCVT            S1, H1 }
                _S0 = (float)(v206 * _S1) + (float)(_S1 * v205);
              }
              __asm { FCVT            H0, S0 }
              *float32x4_t v197 = _H0;
            }
          }
          ++v56;
          v147 += v34 != 0;
          v24 += 8;
          v184 += 4;
          --v185;
        }
        while (v185);
        goto LABEL_173;
      case 9:
        int v214 = v4;
        float16x8_t v98 = v34;
        while (1)
        {
          unsigned int v215 = *v56;
          if (*v56)
          {
            if (!v34) {
              goto LABEL_136;
            }
            unsigned int v216 = *v98 * v215 + ((*v98 * v215) >> 8) + 1;
            if (BYTE1(v216)) {
              break;
            }
          }
LABEL_137:
          ++v56;
          ++v55;
          v98 += v34 != 0;
          v24 += 8;
          if (!--v214) {
            goto LABEL_201;
          }
        }
        unsigned int v215 = v216 >> 8;
LABEL_136:
        float v217 = (float)v215 * 0.0039216;
        float v218 = 1.0 - v217;
        float32x4_t v219 = vcvtq_f32_f16(*(float16x4_t *)v24);
        float32x4_t v220 = vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v55), v217)));
        *(float16x4_t *)uint64_t v24 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v219, v218 + v220.f32[3]), v220, 1.0 - v219.f32[3]));
        goto LABEL_137;
      case 10:
        int v221 = v4;
        float16x8_t v98 = v34;
        while (1)
        {
          unsigned int v222 = *v56;
          if (*v56)
          {
            if (!v34) {
              goto LABEL_144;
            }
            unsigned int v223 = *v98 * v222 + ((*v98 * v222) >> 8) + 1;
            if (BYTE1(v223)) {
              break;
            }
          }
LABEL_145:
          ++v56;
          ++v55;
          v98 += v34 != 0;
          v24 += 8;
          if (!--v221) {
            goto LABEL_201;
          }
        }
        unsigned int v222 = v223 >> 8;
LABEL_144:
        float32x4_t v224 = vcvtq_f32_f16(*(float16x4_t *)v24);
        float32x4_t v225 = vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v55), (float)v222 * 0.0039216)));
        *(float16x4_t *)uint64_t v24 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v224, 1.0 - v225.f32[3]), v225, 1.0 - v224.f32[3]));
        goto LABEL_145;
      case 11:
        float16x8_t v226 = (__int16 *)v55 + 2;
        int v227 = v4;
        int8x16x2_t v147 = v34;
        uint64_t v30 = v477;
        while (1)
        {
          unsigned int v228 = *v56;
          if (*v56)
          {
            if (!v34) {
              goto LABEL_152;
            }
            unsigned int v229 = *v147 * v228 + ((*v147 * v228) >> 8) + 1;
            if (BYTE1(v229)) {
              break;
            }
          }
LABEL_162:
          ++v56;
          v147 += v34 != 0;
          v24 += 8;
          v226 += 4;
          if (!--v227) {
            goto LABEL_173;
          }
        }
        unsigned int v228 = v229 >> 8;
LABEL_152:
        float v230 = (float)v228 * 0.0039216;
        _H1 = v226[1];
        __asm { FCVT            S1, H1 }
        _S1 = v230 * _S1;
        __asm { FCVT            H1, S1 }
        if (v480)
        {
          _H2 = *(_WORD *)(v24 + 6);
          __asm
          {
            FCVT            S5, H2
            FCVT            S1, H1
          }
        }
        else
        {
          __asm { FCVT            S1, H1 }
          _S5 = 1.0;
        }
        _S2 = _S1 + _S5;
        _S3 = 1.0;
        if ((float)(_S1 + _S5) > 1.0) {
          _S2 = 1.0;
        }
        _S4 = 1.0;
        if (v480)
        {
          _H4 = *(_WORD *)(v24 + 6);
          __asm { FCVT            S4, H4 }
        }
        _H6 = *(v226 - 2);
        __asm { FCVT            S6, H6 }
        _S6 = v230 * _S6;
        __asm { FCVT            H16, S6 }
        _H7 = *(v226 - 1);
        _H6 = *v226;
        _H17 = *(_WORD *)v24;
        __asm
        {
          FCVT            S17, H17
          FCVT            S16, H16
        }
        float v251 = (float)(_S1 - _S16) + (float)(_S5 - _S17);
        _H5 = *(_WORD *)(v24 + 2);
        _S16 = _S2 - v251;
        __asm { FCVT            H16, S16 }
        *(_WORD *)uint64_t v24 = LOWORD(_S16);
        if (v480)
        {
          _H3 = *(_WORD *)(v24 + 6);
          __asm { FCVT            S3, H3 }
        }
        __asm { FCVT            S7, H7 }
        _S7 = v230 * _S7;
        __asm
        {
          FCVT            H7, S7
          FCVT            S6, H6
        }
        _S0 = v230 * _S6;
        __asm
        {
          FCVT            H0, S0
          FCVT            S5, H5
        }
        float v260 = _S4 - _S5;
        __asm { FCVT            S5, H7 }
        float v262 = (float)(_S1 - _S5) + v260;
        LOWORD(_S5) = *(_WORD *)(v24 + 4);
        __asm
        {
          FCVT            S5, H5
          FCVT            S0, H0
        }
        float v265 = (float)(_S1 - _S0) + (float)(_S3 - _S5);
        _S1 = _S2 - v262;
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v24 + 2) = LOWORD(_S1);
        __asm { FCVT            H1, S2 }
        *(_WORD *)(v24 + 6) = LOWORD(_S1);
        _S0 = _S2 - v265;
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v24 + 4) = LOWORD(_S0);
        goto LABEL_162;
      case 12:
        int8x8_t v268 = (__int16 *)v55 + 2;
        int v269 = v4;
        int8x16x2_t v147 = v34;
        uint64_t v30 = v477;
        while (1)
        {
          unsigned int v270 = *v56;
          if (*v56)
          {
            if (!v34) {
              goto LABEL_169;
            }
            unsigned int v271 = *v147 * v270 + ((*v147 * v270) >> 8) + 1;
            if (BYTE1(v271)) {
              break;
            }
          }
LABEL_172:
          ++v56;
          v147 += v34 != 0;
          v24 += 8;
          v268 += 4;
          if (!--v269)
          {
LABEL_173:
            int8x8_t v34 = &v147[v471];
            v24 += 8 * v472;
LABEL_174:
            uint64_t v41 = v479;
            goto LABEL_373;
          }
        }
        unsigned int v270 = v271 >> 8;
LABEL_169:
        _H0 = *(v268 - 2);
        __asm { FCVT            S0, H0 }
        float v274 = (float)v270 * 0.0039216;
        _S0 = v274 * _S0;
        __asm { FCVT            H0, S0 }
        _H2 = *(v268 - 1);
        __asm { FCVT            S2, H2 }
        _S2 = v274 * _S2;
        __asm { FCVT            H2, S2 }
        _H3 = *v268;
        __asm { FCVT            S3, H3 }
        _S3 = v274 * _S3;
        __asm { FCVT            H3, S3 }
        _H4 = v268[1];
        __asm { FCVT            S4, H4 }
        _S1 = v274 * _S4;
        __asm { FCVT            H1, S1 }
        short float v286 = *(short float *)(v24 + 2);
        *(short float *)uint64_t v24 = *(short float *)v24 + *(short float *)&_S0;
        *(short float *)(v24 + 2) = v286 + *(short float *)&_S2;
        LOWORD(_S0) = *(_WORD *)(v24 + 6);
        __asm
        {
          FCVT            S0, H0
          FCVT            S1, H1
        }
        _S0 = _S1 + _S0;
        if (_S0 > 1.0) {
          _S0 = 1.0;
        }
        *(short float *)(v24 + 4) = *(short float *)(v24 + 4) + _H3;
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v24 + 6) = _H0;
        goto LABEL_172;
      case 13:
        uint64_t v476 = v29;
        int v475 = v36;
        int v291 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v293 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v294 = *v292 * v293 + ((*v292 * v293) >> 8) + 1;
              if (!BYTE1(v294)) {
                goto LABEL_187;
              }
              unsigned int v293 = v294 >> 8;
            }
            __n128 v295 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v296 = (__n128)vmulq_n_f32((float32x4_t)v295, (float)v293 * 0.0039216);
            double v297 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v296));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_186;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_186:
                __asm { FCVT            S7, H6 }
                v296.n128_u16[0] = *(_WORD *)v24;
                v295.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAmultiplyPDA(v296, v295, v50, _D3, _S4, v297, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v297), SWORD1(v297), SWORD2(v297),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v299;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_187;
              }
              *(double *)uint64_t v24 = v297;
            }
          }
LABEL_187:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v291) {
            goto LABEL_369;
          }
        }
      case 14:
        int v300 = v4;
        float16x8_t v98 = v34;
        while (1)
        {
          unsigned int v301 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v302 = *v98 * v301 + ((*v98 * v301) >> 8) + 1;
              if (!BYTE1(v302)) {
                goto LABEL_200;
              }
              unsigned int v301 = v302 >> 8;
            }
            _D0 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v55), (float)v301 * 0.0039216));
            __asm { FCMP            H3, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              _S2 = 1.0;
              if (!v480) {
                goto LABEL_199;
              }
              __asm { FCMP            H2, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S2, H2 }
LABEL_199:
                __asm { FCVT            S3, H3 }
                _H4 = *(_WORD *)v24;
                _H5 = *(_WORD *)(v24 + 2);
                _H6 = *(_WORD *)(v24 + 4);
                __asm
                {
                  FCVT            S4, H4
                  FCVT            S5, H5
                  FCVT            S6, H6
                  FCVT            S7, H0
                }
                _H16 = _D0.i16[1];
                __asm { FCVT            S16, H16 }
                _H0 = _D0.i16[2];
                __asm { FCVT            S0, H0 }
                _S4 = _S4 + (float)(_S7 * (float)(1.0 - _S4));
                _S5 = _S5 + (float)(_S16 * (float)(1.0 - _S5));
                _S0 = _S6 + (float)(_S0 * (float)(1.0 - _S6));
                _S1 = (float)(_S2 + _S3) - (float)(_S2 * _S3);
                __asm
                {
                  FCVT            H2, S4
                  FCVT            H3, S5
                  FCVT            H0, S0
                }
                *(_WORD *)uint64_t v24 = _H2;
                *(_WORD *)(v24 + 2) = LOWORD(_S3);
                __asm { FCVT            H1, S1 }
                *(_WORD *)(v24 + 4) = LOWORD(_S0);
                *(_WORD *)(v24 + 6) = LOWORD(_S1);
                goto LABEL_200;
              }
              *(float16x4_t *)uint64_t v24 = _D0;
            }
          }
LABEL_200:
          ++v56;
          ++v55;
          v98 += v34 != 0;
          v24 += 8;
          if (!--v300)
          {
LABEL_201:
            int8x8_t v34 = &v98[v471];
            v24 += 8 * v472;
            goto LABEL_371;
          }
        }
      case 15:
        uint64_t v476 = v29;
        int v475 = v36;
        int v324 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v325 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v326 = *v292 * v325 + ((*v292 * v325) >> 8) + 1;
              if (!BYTE1(v326)) {
                goto LABEL_214;
              }
              unsigned int v325 = v326 >> 8;
            }
            __n128 v327 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v328 = (__n128)vmulq_n_f32((float32x4_t)v327, (float)v325 * 0.0039216);
            double v329 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v328));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_213;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_213:
                __asm { FCVT            S7, H6 }
                v328.n128_u16[0] = *(_WORD *)v24;
                v327.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAoverlayPDA(v328, v327, v50, _D3, _S4, v329, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v329), SWORD1(v329), SWORD2(v329),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v331;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_214;
              }
              *(double *)uint64_t v24 = v329;
            }
          }
LABEL_214:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v324) {
            goto LABEL_369;
          }
        }
      case 16:
        uint64_t v476 = v29;
        int v475 = v36;
        int v332 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v333 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v334 = *v292 * v333 + ((*v292 * v333) >> 8) + 1;
              if (!BYTE1(v334)) {
                goto LABEL_228;
              }
              unsigned int v333 = v334 >> 8;
            }
            __n128 v335 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v336 = (__n128)vmulq_n_f32((float32x4_t)v335, (float)v333 * 0.0039216);
            double v337 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v336));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_227;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_227:
                __asm { FCVT            S7, H6 }
                v336.n128_u16[0] = *(_WORD *)v24;
                v335.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAdarkenPDA(v336, v335, v50, _D3, _S4, v337, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v337), SWORD1(v337), SWORD2(v337),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v339;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_228;
              }
              *(double *)uint64_t v24 = v337;
            }
          }
LABEL_228:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v332) {
            goto LABEL_369;
          }
        }
      case 17:
        uint64_t v476 = v29;
        int v475 = v36;
        int v340 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v341 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v342 = *v292 * v341 + ((*v292 * v341) >> 8) + 1;
              if (!BYTE1(v342)) {
                goto LABEL_242;
              }
              unsigned int v341 = v342 >> 8;
            }
            __n128 v343 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v344 = (__n128)vmulq_n_f32((float32x4_t)v343, (float)v341 * 0.0039216);
            double v345 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v344));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_241;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_241:
                __asm { FCVT            S7, H6 }
                v344.n128_u16[0] = *(_WORD *)v24;
                v343.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAlightenPDA(v344, v343, v50, _D3, _S4, v345, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v345), SWORD1(v345), SWORD2(v345),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v347;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_242;
              }
              *(double *)uint64_t v24 = v345;
            }
          }
LABEL_242:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v340) {
            goto LABEL_369;
          }
        }
      case 18:
        uint64_t v476 = v29;
        int v475 = v36;
        int v348 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v349 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v350 = *v292 * v349 + ((*v292 * v349) >> 8) + 1;
              if (!BYTE1(v350)) {
                goto LABEL_256;
              }
              unsigned int v349 = v350 >> 8;
            }
            __n128 v351 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v352 = (__n128)vmulq_n_f32((float32x4_t)v351, (float)v349 * 0.0039216);
            double v353 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v352));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_255;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_255:
                __asm { FCVT            S7, H6 }
                v352.n128_u16[0] = *(_WORD *)v24;
                v351.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAcolordodgePDA(v352, v351, v50, _D3, _S4, v353, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v353), SWORD1(v353), SWORD2(v353),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v355;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_256;
              }
              *(double *)uint64_t v24 = v353;
            }
          }
LABEL_256:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v348) {
            goto LABEL_369;
          }
        }
      case 19:
        uint64_t v476 = v29;
        int v475 = v36;
        int v356 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v357 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v358 = *v292 * v357 + ((*v292 * v357) >> 8) + 1;
              if (!BYTE1(v358)) {
                goto LABEL_270;
              }
              unsigned int v357 = v358 >> 8;
            }
            __n128 v359 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v360 = (__n128)vmulq_n_f32((float32x4_t)v359, (float)v357 * 0.0039216);
            double v361 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v360));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_269;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_269:
                __asm { FCVT            S7, H6 }
                v360.n128_u16[0] = *(_WORD *)v24;
                v359.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAcolorburnPDA(v360, v359, v50, _D3, _S4, v361, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v361), SWORD1(v361), SWORD2(v361),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v363;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_270;
              }
              *(double *)uint64_t v24 = v361;
            }
          }
LABEL_270:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v356) {
            goto LABEL_369;
          }
        }
      case 20:
        uint64_t v476 = v29;
        int v475 = v36;
        int v364 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v365 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v366 = *v292 * v365 + ((*v292 * v365) >> 8) + 1;
              if (!BYTE1(v366)) {
                goto LABEL_284;
              }
              unsigned int v365 = v366 >> 8;
            }
            __n128 v367 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v368 = (__n128)vmulq_n_f32((float32x4_t)v367, (float)v365 * 0.0039216);
            double v369 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v368));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_283;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_283:
                __asm { FCVT            S7, H6 }
                v368.n128_u16[0] = *(_WORD *)v24;
                v367.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAsoftlightPDA(v368, v367, v50, _D3, _S4, v369, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v369), SWORD1(v369), SWORD2(v369),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v371;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_284;
              }
              *(double *)uint64_t v24 = v369;
            }
          }
LABEL_284:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v364) {
            goto LABEL_369;
          }
        }
      case 21:
        uint64_t v476 = v29;
        int v475 = v36;
        int v372 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v373 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v374 = *v292 * v373 + ((*v292 * v373) >> 8) + 1;
              if (!BYTE1(v374)) {
                goto LABEL_298;
              }
              unsigned int v373 = v374 >> 8;
            }
            __n128 v375 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v376 = (__n128)vmulq_n_f32((float32x4_t)v375, (float)v373 * 0.0039216);
            double v377 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v376));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_297;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_297:
                __asm { FCVT            S7, H6 }
                v376.n128_u16[0] = *(_WORD *)v24;
                v375.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAhardlightPDA(v376, v375, v50, _D3, _S4, v377, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v377), SWORD1(v377), SWORD2(v377),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v379;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_298;
              }
              *(double *)uint64_t v24 = v377;
            }
          }
LABEL_298:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v372) {
            goto LABEL_369;
          }
        }
      case 22:
        uint64_t v476 = v29;
        int v475 = v36;
        int v380 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v381 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v382 = *v292 * v381 + ((*v292 * v381) >> 8) + 1;
              if (!BYTE1(v382)) {
                goto LABEL_312;
              }
              unsigned int v381 = v382 >> 8;
            }
            float32x4_t v383 = vcvtq_f32_f16(*v55);
            __n128 v384 = (__n128)vmulq_n_f32(v383, (float)v381 * 0.0039216);
            double v385 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v384));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_311;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_311:
                __asm { FCVT            S7, H6 }
                v384.n128_u16[0] = *(_WORD *)v24;
                v383.i16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                HIWORD(v461) = LOWORD(_D6);
                LOWORD(v461) = WORD2(v385);
                *(_WORD *)uint64_t v24 = PDAdifferencePDA(v384, *(double *)v383.i64, v50.n128_f64[0], _D3, _S4, v385, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v385), v461, *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v387;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_312;
              }
              *(double *)uint64_t v24 = v385;
            }
          }
LABEL_312:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v380) {
            goto LABEL_369;
          }
        }
      case 23:
        uint64_t v476 = v29;
        int v475 = v36;
        int v388 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v389 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v390 = *v292 * v389 + ((*v292 * v389) >> 8) + 1;
              if (!BYTE1(v390)) {
                goto LABEL_326;
              }
              unsigned int v389 = v390 >> 8;
            }
            __n128 v391 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v392 = (__n128)vmulq_n_f32((float32x4_t)v391, (float)v389 * 0.0039216);
            double v393 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v392));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_325;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_325:
                __asm { FCVT            S7, H6 }
                v392.n128_u16[0] = *(_WORD *)v24;
                v391.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAexclusionPDA(v392, v391, v50, _D3, _S4, v393, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v393), SWORD1(v393), SWORD2(v393),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v395;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_326;
              }
              *(double *)uint64_t v24 = v393;
            }
          }
LABEL_326:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v388) {
            goto LABEL_369;
          }
        }
      case 24:
        uint64_t v476 = v29;
        int v475 = v36;
        int v396 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v397 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v398 = *v292 * v397 + ((*v292 * v397) >> 8) + 1;
              if (!BYTE1(v398)) {
                goto LABEL_340;
              }
              unsigned int v397 = v398 >> 8;
            }
            __n128 v399 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v400 = (__n128)vmulq_n_f32((float32x4_t)v399, (float)v397 * 0.0039216);
            double v401 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v400));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_339;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_339:
                __asm { FCVT            S7, H6 }
                v400.n128_u16[0] = *(_WORD *)v24;
                v399.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAhuePDA(v400, v399, v50, _D3, _S4, v401, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v401), SWORD1(v401), SWORD2(v401),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v403;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_340;
              }
              *(double *)uint64_t v24 = v401;
            }
          }
LABEL_340:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v396) {
            goto LABEL_369;
          }
        }
      case 25:
        uint64_t v476 = v29;
        int v475 = v36;
        int v404 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v405 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v406 = *v292 * v405 + ((*v292 * v405) >> 8) + 1;
              if (!BYTE1(v406)) {
                goto LABEL_354;
              }
              unsigned int v405 = v406 >> 8;
            }
            __n128 v407 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v408 = (__n128)vmulq_n_f32((float32x4_t)v407, (float)v405 * 0.0039216);
            double v409 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v408));
            __asm { FCMP            H6, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D3) = *(_WORD *)(v24 + 6);
                _S4 = 1.0;
                goto LABEL_353;
              }
              __asm { FCMP            H3, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S4, H3 }
LABEL_353:
                __asm { FCVT            S7, H6 }
                v408.n128_u16[0] = *(_WORD *)v24;
                v407.n128_u16[0] = *(_WORD *)(v24 + 2);
                v50.n128_u16[0] = *(_WORD *)(v24 + 4);
                *(_WORD *)uint64_t v24 = PDAsaturationPDA(v408, v407, v50, _D3, _S4, v409, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v409), SWORD1(v409), SWORD2(v409),
                                  *(float *)&_D7);
                *(_WORD *)(v24 + 2) = v411;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_354;
              }
              *(double *)uint64_t v24 = v409;
            }
          }
LABEL_354:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v404) {
            goto LABEL_369;
          }
        }
      case 26:
        uint64_t v476 = v29;
        int v475 = v36;
        int v412 = v4;
        float32x4_t v292 = v34;
        while (1)
        {
          unsigned int v413 = *v56;
          if (*v56)
          {
            if (v34)
            {
              unsigned int v414 = *v292 * v413 + ((*v292 * v413) >> 8) + 1;
              if (!BYTE1(v414)) {
                goto LABEL_368;
              }
              unsigned int v413 = v414 >> 8;
            }
            __n128 v415 = (__n128)vcvtq_f32_f16(*v55);
            __n128 v416 = (__n128)vmulq_n_f32((float32x4_t)v415, (float)v413 * 0.0039216);
            v416.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v416);
            __asm { FCMP            H3, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              if (!v480)
              {
                LOWORD(_D5) = *(_WORD *)(v24 + 6);
                LODWORD(_D6) = 1.0;
                goto LABEL_367;
              }
              __asm { FCMP            H5, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S6, H5 }
LABEL_367:
                __asm { FCVT            S4, H3 }
                LOWORD(_D7) = *(_WORD *)v24;
                v415.n128_u16[0] = v416.n128_u16[1];
                v50.n128_u16[0] = v416.n128_u16[2];
                *(_WORD *)uint64_t v24 = PDAluminosityPDA(v416, v415, v50, _D3, _S4, _D5, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, *(_WORD *)v24, *(_DWORD *)(v24 + 2), HIWORD(*(_DWORD *)(v24 + 2)),
                                  *(float *)&_D6);
                *(_WORD *)(v24 + 2) = v418;
                *(_WORD *)(v24 + 4) = v50.n128_u16[0];
                *(_WORD *)(v24 + 6) = LOWORD(_D3);
                goto LABEL_368;
              }
              *(void *)uint64_t v24 = v416.n128_u64[0];
            }
          }
LABEL_368:
          ++v56;
          ++v55;
          v292 += v34 != 0;
          v24 += 8;
          if (!--v412)
          {
LABEL_369:
            int8x8_t v34 = &v292[v471];
LABEL_370:
            v24 += 8 * v472;
            unsigned int v35 = v470;
            int v36 = v475;
            uint64_t v29 = v476;
LABEL_371:
            uint64_t v41 = v479;
LABEL_372:
            uint64_t v30 = v477;
LABEL_373:
            int v67 = v478;
            goto LABEL_374;
          }
        }
      case 27:
        uint64_t v476 = v29;
        int v475 = v36;
        uint64_t v419 = v34;
        int v420 = v4;
        break;
      default:
        int v64 = v4;
        uint64_t v65 = v34;
        uint64_t v41 = v479;
        uint64_t v30 = v477;
        do
        {
          unsigned int v66 = *v56;
          if (*v56)
          {
            if (v34) {
              unsigned int v66 = (*v65 * v66 + ((*v65 * v66) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v66)
            {
              if (v66 == 255) {
                *(void *)uint64_t v24 = 0;
              }
              else {
                *(float16x4_t *)uint64_t v24 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v24), (float)((float)v66 * -0.0039216) + 1.0));
              }
            }
          }
          ++v56;
          v65 += v34 != 0;
          v24 += 8;
          --v64;
        }
        while (v64);
        int8x8_t v34 = &v65[v471];
        v24 += 8 * v472;
        goto LABEL_373;
    }
    break;
  }
  while (1)
  {
    unsigned int v421 = *v56;
    if (*v56)
    {
      if (v34)
      {
        unsigned int v422 = *v419 * v421 + ((*v419 * v421) >> 8) + 1;
        if (!BYTE1(v422)) {
          goto LABEL_389;
        }
        unsigned int v421 = v422 >> 8;
      }
      __n128 v423 = (__n128)vcvtq_f32_f16(*v55);
      __n128 v424 = (__n128)vmulq_n_f32((float32x4_t)v423, (float)v421 * 0.0039216);
      double v425 = COERCE_DOUBLE(vcvt_f16_f32((float32x4_t)v424));
      __asm { FCMP            H6, #0 }
      if (!(_NF ^ _VF | _ZF))
      {
        if (!v480)
        {
          LOWORD(_D3) = *(_WORD *)(v24 + 6);
          _S4 = 1.0;
          goto LABEL_388;
        }
        __asm { FCMP            H3, #0 }
        if (!_ZF & _CF)
        {
          __asm { FCVT            S4, H3 }
LABEL_388:
          __asm { FCVT            S7, H6 }
          v424.n128_u16[0] = *(_WORD *)v24;
          v423.n128_u16[0] = *(_WORD *)(v24 + 2);
          v50.n128_u16[0] = *(_WORD *)(v24 + 4);
          *(_WORD *)uint64_t v24 = PDAluminosityPDA(v424, v423, v50, _D3, _S4, v425, _D6, _D7, v42, v43, v44, v45, v46, v47, v48, v49, SLOWORD(v425), SWORD1(v425), SWORD2(v425),
                            *(float *)&_D7);
          *(_WORD *)(v24 + 2) = v427;
          *(_WORD *)(v24 + 4) = v50.n128_u16[0];
          *(_WORD *)(v24 + 6) = LOWORD(_D3);
          goto LABEL_389;
        }
        *(double *)uint64_t v24 = v425;
      }
    }
LABEL_389:
    ++v56;
    ++v55;
    v419 += v34 != 0;
    v24 += 8;
    if (!--v420)
    {
      int8x8_t v34 = &v419[v471];
      goto LABEL_370;
    }
  }
}

const void *___ZL28use_vImage_image_compositingv_block_invoke()
{
  return get_BOOLean_property("USE_VIMAGE_IMAGE_COMPOSITING", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&use_vImage_image_compositing(void)::status);
}

uint64_t RGBAf16_sample_RGBAf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v129 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v129 = v5 % v6;
    }
  }
  else
  {
    uint64_t v129 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v128 = v11;
  }
  else
  {
    uint64_t v128 = 0;
  }
  uint64_t v124 = *(void *)(result + 80);
  uint64_t v125 = *(void *)(result + 88);
  int v122 = *(_DWORD *)(result + 188);
  uint64_t v12 = *(void *)(result + 152) - 8;
  uint64_t v127 = *(void *)(result + 144) - 1;
  int16x4_t v13 = (int16x4_t)vbsl_s8((int8x8_t)vceqd_s64(*(void *)(result + 40), 0), (int8x8_t)0x3C00800080008000, (int8x8_t)0x800080008000);
  int v120 = *(_DWORD *)(result + 240);
  unint64_t v14 = v9
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 2 * (4 * *(_DWORD *)(result + 256))
      - 8;
  uint64_t v126 = *(void *)(result + 72);
  uint64_t v123 = *(void *)(result + 64);
  int v15 = a4;
  while (1)
  {
    if (a3 >= v126)
    {
      if (a3 <= v125)
      {
        uint64_t v24 = 0;
        uint64_t v25 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v26 = 0x3FFFFFFF;
        uint64_t v27 = a3;
        uint64_t v28 = v123;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v125;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_51;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v28 = v123;
        unsigned int v26 = v122 | v23;
        uint64_t v27 = v21 - 0x1000000;
        uint64_t v24 = a3 - (v21 - 0x1000000);
        uint64_t v25 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v126 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_51;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v28 = v123;
      unsigned int v26 = v122 | v19;
      uint64_t v27 = v17 + 0x1000000;
      uint64_t v24 = a3 - (v17 + 0x1000000);
      uint64_t v25 = 512;
    }
    if (a2 >= v28)
    {
      if (a2 <= v124)
      {
        uint64_t v33 = 0;
        uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v32 = a2;
      }
      else
      {
        uint64_t v35 = *(void *)(result + 192);
        uint64_t v36 = *(void *)(result + 200) + v124;
        uint64_t v37 = v36 - a2 + (v35 >> 1);
        if (v37 < 1) {
          goto LABEL_51;
        }
        if (v37 < v35) {
          unsigned int v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v122;
        }
        uint64_t v32 = v36 - 0x1000000;
        uint64_t v33 = a2 - (v36 - 0x1000000);
        uint64_t v34 = 28;
      }
    }
    else
    {
      uint64_t v29 = *(void *)(result + 192);
      uint64_t v30 = v28 - *(void *)(result + 200);
      uint64_t v31 = a2 - v30 + (v29 >> 1);
      if (v31 < 1) {
        goto LABEL_51;
      }
      if (v31 < v29) {
        unsigned int v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v122;
      }
      uint64_t v32 = v30 + 0x1000000;
      uint64_t v33 = a2 - (v30 + 0x1000000);
      uint64_t v34 = 32;
    }
    if (v26 >= 0x400000) {
      break;
    }
LABEL_51:
    --v15;
    a2 += v5;
    a3 += v10;
    v12 += 8;
    *(unsigned char *)(v127 + 1) = 0;
    uint64_t v50 = v127 + 1;
LABEL_52:
    uint64_t v127 = v50;
    if (!v15) {
      return result;
    }
  }
  if (v6)
  {
    uint64_t v38 = (v7 & ((v27 % v7) >> 63)) + v27 % v7;
    uint64_t v39 = (v6 & ((v32 % v6) >> 63)) + v32 % v6;
    if (v38 >= v7) {
      uint64_t v40 = v7;
    }
    else {
      uint64_t v40 = 0;
    }
    uint64_t v27 = v38 - v40;
    if (v39 >= v6) {
      uint64_t v41 = v6;
    }
    else {
      uint64_t v41 = 0;
    }
    uint64_t v32 = v39 - v41;
    v24 += v27;
    v33 += v32;
  }
  uint64_t v42 = v9 + SHIDWORD(v27) * (uint64_t)v4;
  uint64_t v43 = v32 >> 32;
  unint64_t v44 = v42 + 8 * v43;
  uint64_t v45 = *(int16x4_t **)(result + 32);
  if (v14 >= v44) {
    uint64_t v46 = (int16x4_t *)(v42 + 8 * v43);
  }
  else {
    uint64_t v46 = (int16x4_t *)v14;
  }
  if (v46 < v45) {
    uint64_t v46 = *(int16x4_t **)(result + 32);
  }
  float16x4_t v47 = (float16x4_t)vmin_s16(vmax_s16(*v46, v13), (int16x4_t)0x3C007FFF7FFF7FFFLL);
  uint64_t v48 = v124;
  if (!v8) {
    goto LABEL_54;
  }
  unsigned int v49 = *(_DWORD *)(v8 + (v34 | v25));
LABEL_55:
  int v52 = v49 & 0xF;
  uint64_t v53 = v49 >> 8;
  unsigned int v54 = HIBYTE(v49) & 3;
  if (v52 == 1)
  {
    LODWORD(v82) = SBYTE1(v49);
    if (v6)
    {
      uint64_t v83 = v53 << 56;
      uint64_t v84 = v24 + (v83 >> 24);
      uint64_t v85 = v7 & (v84 >> 63);
      if (v85 + v84 >= v7) {
        uint64_t v86 = v7;
      }
      else {
        uint64_t v86 = 0;
      }
      uint64_t v87 = v85 + (v83 >> 24);
      uint64_t v48 = v124;
      uint64_t v82 = (v87 - v86) >> 32;
    }
    unint64_t v88 = (int16x4_t *)(v44 + (int)v82 * (uint64_t)v4);
    if (v14 < (unint64_t)v88) {
      unint64_t v88 = (int16x4_t *)v14;
    }
    if (v88 < v45) {
      unint64_t v88 = v45;
    }
    float16x4_t v89 = (float16x4_t)vmin_s16(vmax_s16(*v88, v13), (int16x4_t)0x3C007FFF7FFF7FFFLL);
    __int32 v90 = (char *)&interpolate_rgbaf16[4 * v54];
    goto LABEL_100;
  }
  if (v52 == 2)
  {
    uint64_t v91 = SBYTE2(v49);
    if (v6)
    {
      uint64_t v92 = v33 + ((uint64_t)SBYTE2(v49) << 32);
      uint64_t v93 = v6 & (v92 >> 63);
      if (v93 + v92 >= v6) {
        uint64_t v94 = v6;
      }
      else {
        uint64_t v94 = 0;
      }
      uint64_t v91 = (v93 + ((uint64_t)((unint64_t)HIWORD(v49) << 56) >> 24) - v94) >> 32;
    }
    unsigned __int8 v95 = (int16x4_t *)(v44 + 8 * v91);
    if (v14 < (unint64_t)v95) {
      unsigned __int8 v95 = (int16x4_t *)v14;
    }
    if (v95 < v45) {
      unsigned __int8 v95 = v45;
    }
    float16x4_t v89 = (float16x4_t)vmin_s16(vmax_s16(*v95, v13), (int16x4_t)0x3C007FFF7FFF7FFFLL);
    __int32 v90 = (char *)&interpolate_rgbaf16[4 * ((v49 >> 28) & 3)];
LABEL_100:
    _H6 = *((_WORD *)v90 + 3);
    __asm { FCVT            S6, H6 }
    float32x4_t v98 = vcvtq_f32_f16(v47);
    float32x4_t v81 = vmlaq_n_f32(v98, vsubq_f32(vcvtq_f32_f16(v89), v98), _S6);
    goto LABEL_101;
  }
  if (v52 != 3)
  {
LABEL_54:
    uint64_t v51 = v125;
    goto LABEL_102;
  }
  LODWORD(v55) = SBYTE1(v49);
  uint64_t v56 = SBYTE2(v49);
  if (v6)
  {
    uint64_t v57 = v53 << 56;
    uint64_t v58 = v24 + (v57 >> 24);
    uint64_t v59 = v33 + ((uint64_t)SBYTE2(v49) << 32);
    uint64_t v60 = v7 & (v58 >> 63);
    uint64_t v61 = v6 & (v59 >> 63);
    uint64_t v62 = v61 + v59;
    if (v60 + v58 >= v7) {
      uint64_t v63 = v7;
    }
    else {
      uint64_t v63 = 0;
    }
    if (v62 >= v6) {
      uint64_t v64 = v6;
    }
    else {
      uint64_t v64 = 0;
    }
    uint64_t v55 = (v60 + (v57 >> 24) - v63) >> 32;
    uint64_t v56 = (v61 + ((uint64_t)((unint64_t)HIWORD(v49) << 56) >> 24) - v64) >> 32;
  }
  uint64_t v65 = (int16x4_t *)(v44 + 8 * v56);
  if (v14 < (unint64_t)v65) {
    uint64_t v65 = (int16x4_t *)v14;
  }
  if (v65 < v45) {
    uint64_t v65 = v45;
  }
  float16x4_t v66 = (float16x4_t)vmin_s16(vmax_s16(*v65, v13), (int16x4_t)0x3C007FFF7FFF7FFFLL);
  unint64_t v67 = v44 + (int)v55 * (uint64_t)v4;
  if (v14 >= v67) {
    unsigned __int8 v68 = (int16x4_t *)(v44 + (int)v55 * (uint64_t)v4);
  }
  else {
    unsigned __int8 v68 = (int16x4_t *)v14;
  }
  if (v68 < v45) {
    unsigned __int8 v68 = v45;
  }
  float16x4_t v69 = (float16x4_t)vmin_s16(vmax_s16(*v68, v13), (int16x4_t)0x3C007FFF7FFF7FFFLL);
  float16x8_t v70 = (int16x4_t *)(v67 + 8 * v56);
  if (v14 < (unint64_t)v70) {
    float16x8_t v70 = (int16x4_t *)v14;
  }
  if (v70 < v45) {
    float16x8_t v70 = v45;
  }
  _H16 = interpolate_rgbaf16[4 * v54 + 3];
  __asm { FCVT            S16, H16 }
  _H17 = interpolate_rgbaf16[4 * ((v49 >> 28) & 3) + 3];
  __asm { FCVT            S17, H17 }
  float32x4_t v78 = vcvtq_f32_f16(v47);
  float32x4_t v79 = vmaxnmq_f32(vminnmq_f32(vmlaq_n_f32(v78, vsubq_f32(vcvtq_f32_f16(v66), v78), _S17), (float32x4_t)xmmword_1850CD6C0), (float32x4_t)xmmword_1850CE020);
  float32x4_t v80 = vcvtq_f32_f16(v69);
  float32x4_t v81 = vmlaq_n_f32(v79, vsubq_f32(vmaxnmq_f32(vminnmq_f32(vmlaq_n_f32(v80, vsubq_f32(vcvtq_f32_f16((float16x4_t)vmin_s16(vmax_s16(*v70, v13), (int16x4_t)0x3C007FFF7FFF7FFFLL)), v80), _S17), (float32x4_t)xmmword_1850CD6C0), (float32x4_t)xmmword_1850CE020), v79), _S16);
  uint64_t v48 = v124;
LABEL_101:
  uint64_t v51 = v125;
  float16x4_t v47 = vcvt_f16_f32(vmaxnmq_f32(vminnmq_f32(v81, (float32x4_t)xmmword_1850CD6C0), (float32x4_t)xmmword_1850CE020));
LABEL_102:
  uint64_t v99 = 0;
  uint64_t v100 = v127 + 1;
  uint64_t v101 = v12 + 8;
  int v102 = v15 - 1;
  a3 += v10;
  uint64_t v103 = v51 - a3;
  a2 += v5;
  uint64_t v104 = v48 - a2;
  v12 += 8;
  while (1)
  {
    int v105 = v15;
    *(float16x4_t *)(v101 + 8 * v99) = v47;
    uint64_t v106 = v100 + v99;
    *(unsigned char *)(v100 + v99) = v26 >> 22;
    if (v102 == v99) {
      return result;
    }
    --v15;
    if ((v103 | v104 | (a3 - v126) | (a2 - v123)) < 0)
    {
      uint64_t v50 = v127 + v99 + 1;
      goto LABEL_52;
    }
    if (v6)
    {
      uint64_t v107 = (v7 & ((v24 + v128) >> 63)) + v24 + v128;
      uint64_t v108 = (v6 & ((v33 + v129) >> 63)) + v33 + v129;
      if (v107 >= v7) {
        uint64_t v109 = v7;
      }
      else {
        uint64_t v109 = 0;
      }
      uint64_t v24 = v107 - v109;
      if (v108 >= v6) {
        uint64_t v110 = v6;
      }
      else {
        uint64_t v110 = 0;
      }
      uint64_t v33 = v108 - v110;
      int v111 = HIDWORD(v24);
      uint64_t v112 = v33;
    }
    else
    {
      int v111 = HIDWORD(a3);
      uint64_t v112 = a2;
    }
    uint64_t v113 = v9 + v111 * (uint64_t)v4;
    uint64_t v114 = v112 >> 32;
    unint64_t v44 = v113 + 8 * v114;
    uint64_t v45 = *(int16x4_t **)(result + 32);
    if (v14 >= v44) {
      float16x8_t v115 = (int16x4_t *)(v113 + 8 * v114);
    }
    else {
      float16x8_t v115 = (int16x4_t *)v14;
    }
    if (v115 < v45) {
      float16x8_t v115 = *(int16x4_t **)(result + 32);
    }
    float16x4_t v47 = (float16x4_t)vmin_s16(vmax_s16(*v115, v13), (int16x4_t)0x3C007FFF7FFF7FFFLL);
    if (v8)
    {
      unsigned int v49 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      unsigned int v116 = v49 & 0xF;
      if ((v49 & 0xF) != 0)
      {
        float16x8_t v117 = *(unsigned int **)(result + 264);
        unsigned int v118 = *v117;
        if (v105 == a4)
        {
          uint64_t v48 = v124;
        }
        else
        {
          uint64_t v48 = v124;
          if (v15 != 1 && v120 != 1 && v118 == 3 && v116 < 3) {
            v49 |= 3u;
          }
        }
        unsigned int v26 = -1;
        if (v118 < v116) {
          *float16x8_t v117 = v116;
        }
        uint64_t v127 = v106;
        goto LABEL_55;
      }
    }
    ++v99;
    v12 += 8;
    a3 += v10;
    v103 -= v10;
    a2 += v5;
    v104 -= v5;
    unsigned int v26 = -1;
  }
}

uint64_t RGBAf16_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  signed int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x3000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    uint64_t v12 = RGBAf16_shade_radial_RGB;
  }
  else if (*(void *)(v5 + 24))
  {
    uint64_t v12 = RGBAf16_shade_conic_RGB;
  }
  else if (v16 < 2)
  {
    uint64_t v12 = RGBAf16_shade_axial_RGB;
  }
  else
  {
    uint64_t v12 = RGBAf16_shade_custom_RGB;
  }
  int16x4_t v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  RGBAf16_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

void RGBAf16_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  uint64_t v6 = *(float **)(a1 + 272);
  float v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  float v8 = *(float *)(a1 + 336);
  float v9 = *(float *)(a1 + 344);
  float v10 = *(float *)(a1 + 304);
  float v11 = *(float *)(a1 + 308);
  LODWORD(v12) = *(_DWORD *)(a1 + 320);
  int v13 = *(_DWORD *)(a1 + 324);
  uint64_t v16 = a1 + 144;
  int v14 = *(_DWORD **)(a1 + 144);
  int v15 = *(_WORD **)(v16 + 8);
  uint64_t v17 = *(void *)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v18 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v18 = v6;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  uint64_t v19 = *(void *)(a1 + 40);
  if (v19) {
    uint64_t v21 = *(float **)(a1 + 40);
  }
  else {
    uint64_t v21 = v6;
  }
  if (v5 != 0.0)
  {
    for (unint64_t i = (short float *)(v15 + 2); ; i += 4)
    {
      LODWORD(v24) = v12;
      if (v7 >= v10)
      {
        LODWORD(v24) = v13;
        if (v7 <= v11) {
          LODWORD(v24) = (int)(float)(v9 * (float)(v7 - v8));
        }
      }
      if ((v24 & 0x80000000) != 0)
      {
        if (!v17)
        {
          char v40 = 0;
          goto LABEL_31;
        }
        _S7 = *v18;
        __asm { FCVT            H7, S7 }
        _S16 = *(float *)v17;
        _S17 = *(_DWORD *)(v17 + 4);
        __asm
        {
          FCVT            H16, S16
          FCVT            H17, S17
        }
        _S18 = *(_DWORD *)(v17 + 8);
        __asm { FCVT            H18, S18 }
        *(i - 2) = _H7 * *(short float *)&_S16;
        *(i - 1) = _H7 * *(short float *)&_S17;
        *unint64_t i = _H7 * *(short float *)&_S18;
      }
      else
      {
        uint64_t v25 = (float *)(v20 + 12 * v24);
        uint64_t v24 = v24;
        if (!v19) {
          uint64_t v24 = 0;
        }
        _S7 = v21[v24];
        if (v19) {
          float v27 = v21[v24];
        }
        else {
          float v27 = 1.0;
        }
        _S16 = *v25 * v27;
        _S17 = v27 * v25[1];
        _S18 = v27 * v25[2];
        __asm { FCVT            H16, S16 }
        *(i - 2) = *(short float *)&_S16;
        __asm { FCVT            H16, S17 }
        *(i - 1) = *(short float *)&_S16;
        __asm { FCVT            H16, S18 }
        *unint64_t i = *(short float *)&_S16;
        __asm { FCVT            H7, S7 }
      }
      i[1] = _H7;
      char v40 = -1;
LABEL_31:
      float v7 = v5 + v7;
      *(unsigned char *)int v14 = v40;
      int v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v7 >= v10)
  {
    LODWORD(v12) = v13;
    if (v7 <= v11) {
      LODWORD(v12) = (int)(float)(v9 * (float)(v7 - v8));
    }
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      float v42 = *v18;
      _S1 = *v18 * *(float *)v17;
      _S3 = *v18;
    }
    else
    {
      uint64_t v17 = v20 + 12 * v12;
      uint64_t v12 = v12;
      if (!v19) {
        uint64_t v12 = 0;
      }
      _S3 = v21[v12];
      float v42 = 1.0;
      if (v19) {
        float v42 = v21[v12];
      }
      _S1 = *(float *)v17 * v42;
    }
    _D2 = vmul_n_f32(*(float32x2_t *)(v17 + 4), v42);
    __asm
    {
      FCVT            H0, S1
      FCVT            H1, S2
    }
    _D2.i32[0] = _D2.i32[1];
    __asm
    {
      FCVT            H2, S2
      FCVT            H3, S3
    }
    int v49 = a4 + 4;
    do
    {
      *int v15 = _H0;
      v15[1] = _H1;
      v15[2] = _H2;
      v15[3] = _H3;
      v15[4] = _H0;
      v15[5] = _H1;
      v15[6] = _H2;
      v15[7] = _H3;
      v15[8] = _H0;
      v15[9] = _H1;
      v15[10] = _H2;
      v15[11] = _H3;
      v15[12] = _H0;
      v15[13] = _H1;
      v15[14] = _H2;
      v49 -= 4;
      v15[15] = _H3;
      v15 += 16;
      *v14++ = -1;
    }
    while (v49 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v22 = 4;
    }
    else {
      int v22 = a4;
    }
    bzero(v14, ((a4 - v22 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t RGBAf16_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4, int8x16_t a5, int32x4_t a6)
{
  uint64_t v7 = *(void *)(result + 272);
  a5.i64[0] = *(void *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), *(float *)(v7 + 4) * (float)a3), *(float32x2_t *)a5.i8, *(float *)(v7 + 4) * (float)a2));
  float32x4_t v8 = *(float32x4_t *)(result + 304);
  float v9 = *(float *)(result + 336);
  float v10 = *(float *)(result + 348);
  float v11 = *(float *)(result + 344);
  float v12 = *(float *)(result + 356);
  int v14 = *(char **)(result + 144);
  int v13 = *(float16x4_t **)(result + 152);
  int v15 = *(float **)(result + 384);
  uint64_t v16 = *(__int32 **)(result + 392);
  if (!v16) {
    uint64_t v16 = *(__int32 **)(result + 272);
  }
  uint64_t v17 = *(void *)(result + 32);
  uint64_t v18 = *(void *)(result + 40);
  if (v18) {
    int v19 = *(_DWORD *)(result + 48);
  }
  else {
    int v19 = 0;
  }
  if (v18) {
    uint64_t v7 = *(void *)(result + 40);
  }
  int v20 = 3 * *(_DWORD *)(result + 48);
  do
  {
    float32x4_t v21 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v8, v21))), vmovn_s32(vcgtq_f32(v21, v8))), 0xFuLL))) & 1) == 0)
    {
      int v25 = (int)(float)(v12 * (float)(*(float *)&a6.i32[1] - v10));
      float v26 = v11 * (float)(*(float *)a6.i32 - v9);
      uint64_t v23 = v17 + 4 * v20 * v25 + 12 * (int)v26;
      uint64_t result = v7 + 4 * v19 * v25;
      uint64_t v27 = (int)v26;
      if (!v18) {
        uint64_t v27 = 0;
      }
      __int32 v24 = *(_DWORD *)(result + 4 * v27);
      if (v18) {
        v6.i32[0] = *(_DWORD *)(result + 4 * v27);
      }
      else {
        v6.f32[0] = 1.0;
      }
      float v22 = *(float *)v23 * v6.f32[0];
      goto LABEL_18;
    }
    if (v15)
    {
      v6.i32[0] = *v16;
      float v22 = *(float *)v16 * *v15;
      uint64_t v23 = (uint64_t)v15;
      __int32 v24 = *v16;
LABEL_18:
      *(float32x2_t *)v6.f32 = vmul_n_f32(*(float32x2_t *)(v23 + 4), v6.f32[0]);
      float32x4_t v6 = (float32x4_t)vextq_s8(a5, (int8x16_t)v6, 0xCuLL);
      v6.f32[0] = v22;
      v6.i32[3] = v24;
      *int v13 = vcvt_f16_f32(v6);
      char v28 = -1;
      goto LABEL_20;
    }
    char v28 = 0;
LABEL_20:
    *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)a6.i8);
    ++v13;
    *v14++ = v28;
    --a4;
  }
  while (a4);
  return result;
}

void RGBAf16_shade_conic_RGB(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(void *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(void *)&a1[34] + 4) * (float)a2));
  float v8 = a1[42].f32[0];
  float v9 = a1[43].f32[0];
  float v10 = a1[38].f32[0];
  float v12 = (unsigned char *)a1[18];
  float v11 = (_WORD *)a1[19];
  float32x2_t v13 = a1[4];
  float32x2_t v14 = a1[5];
  if (v14) {
    float32x2_t v15 = a1[5];
  }
  else {
    float32x2_t v15 = a1[34];
  }
  float v16 = a1[38].f32[1] - v10;
  do
  {
    __n128 v42 = a6;
    float v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    float v18 = ceilf(v17);
    LODWORD(v19) = vcvtms_s32_f32(v17);
    unsigned int v20 = vcvtms_s32_f32(v9 + v17);
    if (v17 < 0.0) {
      LODWORD(v19) = v20;
    }
    float v21 = ceilf(v17 - v9);
    if (v17 > v9) {
      float v18 = v21;
    }
    LODWORD(v22) = (int)v18;
    uint64_t v23 = (float *)(*(void *)&v13 + 12 * v19);
    uint64_t v19 = (int)v19;
    if (!*(void *)&v14) {
      uint64_t v19 = 0;
    }
    float v24 = *(float *)(*(void *)&v15 + 4 * v19);
    float v26 = *v23;
    float v25 = v23[1];
    float v27 = v23[2];
    char v28 = (float *)(*(void *)&v13 + 12 * v22);
    uint64_t v22 = (int)v22;
    if (!*(void *)&v14) {
      uint64_t v22 = 0;
    }
    float v29 = *(float *)(*(void *)&v15 + 4 * v22);
    float v31 = *v28;
    float v30 = v28[1];
    float v32 = v28[2];
    if (v14)
    {
      float v26 = v24 * v26;
      float v25 = v24 * v25;
      float v27 = v24 * v27;
      float v31 = v29 * v31;
      float v30 = v29 * v30;
      float v32 = v29 * v32;
    }
    a6.n128_u64[1] = v42.n128_u64[1];
    float v33 = v17 - (float)(int)floorf(v17);
    _S4 = v24 + (float)(v33 * (float)(v29 - v24));
    _S3 = v26 + (float)(v33 * (float)(v31 - v26));
    _S2 = v25 + (float)(v33 * (float)(v30 - v25));
    _S0 = v27 + (float)(v33 * (float)(v32 - v27));
    __asm { FCVT            H3, S3 }
    *float v11 = LOWORD(_S3);
    __asm { FCVT            H2, S2 }
    v11[1] = LOWORD(_S2);
    __asm { FCVT            H0, S0 }
    void v11[2] = LOWORD(_S0);
    __asm { FCVT            H0, S4 }
    v11[3] = LOWORD(_S0);
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v42.n128_u64[0]);
    *v12++ = -1;
    v11 += 4;
    --a4;
  }
  while (a4);
}

void RGBAf16_shade_radial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int8x16_t a5)
{
  float v8 = *(float **)(a1 + 400);
  a5.i32[0] = *(_DWORD *)(a1 + 280);
  float v9 = *(float *)(a1 + 284);
  float v10 = *(float **)(a1 + 272);
  float v11 = v10[1];
  float v12 = v11 * (float)a2;
  float v13 = v11 * (float)a3;
  float v14 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v13) + (float)(*(float *)a5.i32 * v12));
  float v15 = *(float *)(a1 + 300) + (float)((float)(v13 * *(float *)(a1 + 292)) + (float)(v9 * v12));
  float v16 = *(float *)(a1 + 336);
  float v17 = *(float *)(a1 + 344);
  float v18 = *(float *)(a1 + 304);
  float v19 = *(float *)(a1 + 308);
  uint64_t v20 = *(unsigned int *)(a1 + 324);
  float v21 = v8[2];
  float v22 = v8[4];
  float v23 = v8[5];
  float v24 = v8[7];
  uint64_t v27 = a1 + 144;
  float v25 = *(char **)(a1 + 144);
  float v26 = *(float16x4_t **)(v27 + 8);
  uint64_t v28 = *(void *)(a1 + 384);
  float v29 = *(float **)(a1 + 392);
  if (!v29) {
    float v29 = v10;
  }
  uint64_t v30 = *(void *)(a1 + 32);
  uint64_t v31 = *(void *)(a1 + 40);
  if (v31) {
    float v10 = *(float **)(a1 + 40);
  }
  if (v21 != 0.0 || v24 != 0.0 || v9 != 0.0)
  {
    int v35 = *(_DWORD *)(a1 + 320);
    float v36 = v8[3];
    float v37 = v8[8];
    float v38 = -v8[6];
    float v39 = v19 - v18;
    while (1)
    {
      float v40 = v38 + (float)((float)(v14 + v14) * v21);
      float v41 = (float)((float)(v15 * v15) + (float)(v14 * v14)) - v24;
      if (v23 == 0.0)
      {
        float v48 = v41 / v40;
      }
      else
      {
        float v42 = (float)((float)(v23 * -4.0) * v41) + (float)(v40 * v40);
        if (v42 < 0.0) {
          goto LABEL_48;
        }
        float v43 = sqrtf(v42);
        float v44 = v37 * (float)(v40 - v43);
        float v45 = v40 + v43;
        float v46 = v37 * v45;
        BOOL v47 = (float)(v37 * v45) <= v44;
        if ((float)(v37 * v45) <= v44) {
          float v48 = v37 * v45;
        }
        else {
          float v48 = v44;
        }
        if (v47) {
          float v46 = v44;
        }
        if (v46 < 0.0)
        {
          _NF = v46 < v36;
LABEL_29:
          LODWORD(v50) = v35;
          if (_NF) {
            goto LABEL_48;
          }
LABEL_30:
          if ((v50 & 0x80000000) == 0) {
            goto LABEL_42;
          }
          goto LABEL_48;
        }
        if (v46 <= 1.0)
        {
          float v51 = v18 + (float)(v46 * v39);
          goto LABEL_41;
        }
        if ((v20 & 0x80000000) == 0)
        {
          LODWORD(v50) = v20;
          if (v46 <= v22)
          {
LABEL_42:
            uint64_t v52 = v30 + 12 * v50;
            uint64_t v50 = v50;
            if (!v31) {
              uint64_t v50 = 0;
            }
            __int32 v53 = LODWORD(v10[v50]);
            if (v31) {
              v6.f32[0] = v10[v50];
            }
            else {
              v6.f32[0] = 1.0;
            }
            float v54 = *(float *)v52 * v6.f32[0];
            goto LABEL_50;
          }
        }
      }
      if (v48 < 0.0)
      {
        _NF = v48 < v36;
        goto LABEL_29;
      }
      if (v48 > 1.0)
      {
        LODWORD(v50) = v20;
        if (v48 > v22) {
          goto LABEL_48;
        }
        goto LABEL_30;
      }
      float v51 = v18 + (float)(v48 * v39);
LABEL_41:
      LODWORD(v50) = (int)(float)(v17 * (float)(v51 - v16));
      if ((v50 & 0x80000000) == 0) {
        goto LABEL_42;
      }
LABEL_48:
      if (!v28)
      {
        char v55 = 0;
        goto LABEL_52;
      }
      v6.f32[0] = *v29;
      float v54 = *v29 * *(float *)v28;
      uint64_t v52 = v28;
      __int32 v53 = *(_DWORD *)v29;
LABEL_50:
      *(float32x2_t *)v6.f32 = vmul_n_f32(*(float32x2_t *)(v52 + 4), v6.f32[0]);
      float32x4_t v6 = (float32x4_t)vextq_s8(a5, (int8x16_t)v6, 0xCuLL);
      v6.f32[0] = v54;
      v6.i32[3] = v53;
      *float v26 = vcvt_f16_f32(v6);
      char v55 = -1;
LABEL_52:
      float v14 = *(float *)a5.i32 + v14;
      float v15 = v9 + v15;
      ++v26;
      *v25++ = v55;
      if (!--a4) {
        return;
      }
    }
  }
  float v32 = v15 * v15;
  float v33 = -v23;
  if (v32 <= (float)-v23)
  {
    float v56 = fabsf(v8[8]);
    float v57 = v23 * -4.0;
    float v58 = v19 - v18;
    uint64_t v59 = (float *)(v30 + 12 * (int)v20);
    if (v31) {
      uint64_t v60 = v20;
    }
    else {
      uint64_t v60 = 0;
    }
    uint64_t v61 = v26 + 1;
    int v62 = a4 + 2;
    while (1)
    {
      float v63 = v32 + (float)(v14 * v14);
      float v64 = *(float *)a5.i32 + v14;
      float v65 = v32 + (float)(v64 * v64);
      if (v63 > v33 && v65 > v33)
      {
        if ((v20 & 0x80000000) != 0)
        {
          if (!v28)
          {
            char v122 = 0;
            char v98 = 0;
            goto LABEL_114;
          }
          _S20 = *(_DWORD *)v29;
          _S21 = *v29 * *(float *)v28;
          _S22 = *v29 * *(float *)(v28 + 4);
          _S23 = *v29 * *(float *)(v28 + 8);
        }
        else
        {
          _S20 = LODWORD(v10[v60]);
          if (v31) {
            float v75 = v10[v60];
          }
          else {
            float v75 = 1.0;
          }
          _S21 = *v59 * v75;
          _S22 = v75 * v59[1];
          _S23 = v75 * v59[2];
        }
        __asm { FCVT            H21, S21 }
        v61[-1].i16[0] = _H21;
        __asm { FCVT            H22, S22 }
        v61[-1].i16[1] = _H22;
        __asm { FCVT            H23, S23 }
        v61[-1].i16[2] = _H23;
        __asm { FCVT            H20, S20 }
        v61[-1].i16[3] = _H20;
        v61->i16[0] = _H21;
        v61->i16[1] = _H22;
        v61->i16[2] = _H23;
        goto LABEL_112;
      }
      float v67 = sqrtf(v57 * v65);
      float v68 = v56 * sqrtf(v57 * v63);
      float v69 = v56 * v67;
      uint64_t v70 = (int)(float)(v17 * (float)((float)(v18 + (float)(v68 * v58)) - v16));
      uint64_t v71 = (int)(float)(v17 * (float)((float)(v18 + (float)((float)(v56 * v67) * v58)) - v16));
      if (v68 <= 1.0 && v69 <= 1.0)
      {
        float32x4_t v79 = (float *)(v30 + 12 * v70);
        uint64_t v70 = (int)v70;
        if (!v31) {
          uint64_t v70 = 0;
        }
        _S20 = v10[v70];
        _S23 = *v79;
        _S22 = v79[1];
        _S21 = v79[2];
        if (v31)
        {
          _S23 = _S20 * _S23;
          _S22 = _S20 * _S22;
          int v84 = v71;
          _S21 = _S20 * _S21;
        }
        else
        {
          int v84 = 0;
        }
        uint64_t v109 = (float *)(v30 + 12 * v71);
        _S24 = v10[v84];
        if (v31) {
          float v111 = v10[v84];
        }
        else {
          float v111 = 1.0;
        }
        _S25 = *v109 * v111;
        _S26 = v111 * v109[1];
        _S27 = v111 * v109[2];
        __asm { FCVT            H23, S23 }
        v61[-1].i16[0] = _H23;
        __asm { FCVT            H22, S22 }
        v61[-1].i16[1] = _H22;
        __asm { FCVT            H21, S21 }
        v61[-1].i16[2] = _H21;
        __asm { FCVT            H20, S20 }
        v61[-1].i16[3] = _H20;
        __asm { FCVT            H20, S25 }
        v61->i16[0] = _H20;
        __asm { FCVT            H20, S26 }
        v61->i16[1] = _H20;
        __asm { FCVT            H20, S27 }
        v61->i16[2] = _H20;
        __asm { FCVT            H20, S24 }
LABEL_112:
        char v98 = -1;
        goto LABEL_113;
      }
      if (v68 <= 1.0)
      {
        if ((v70 & 0x80000000) == 0)
        {
          uint64_t v73 = 3 * (int)v70;
          if (!v31) {
            uint64_t v70 = 0;
          }
LABEL_86:
          float v92 = v10[v70];
          uint64_t v93 = (_DWORD *)(v30 + 4 * v73);
          float v95 = *(float *)v93;
          uint64_t v94 = (float32x2_t *)(v93 + 1);
          float v96 = v95;
          if (v31) {
            v5.f32[0] = v92;
          }
          else {
            v5.f32[0] = 1.0;
          }
          float v97 = v96 * v5.f32[0];
LABEL_92:
          *(float32x2_t *)v5.f32 = vmul_n_f32(*v94, v5.f32[0]);
          float32x4_t v5 = (float32x4_t)vextq_s8(a5, (int8x16_t)v5, 0xCuLL);
          v5.f32[0] = v97;
          v5.f32[3] = v92;
          v61[-1] = vcvt_f16_f32(v5);
          char v98 = -1;
          goto LABEL_93;
        }
      }
      else if (v68 <= v22)
      {
        uint64_t v70 = v60;
        uint64_t v73 = 3 * (int)v20;
        if ((v20 & 0x80000000) == 0) {
          goto LABEL_86;
        }
      }
      if (v28)
      {
        v5.f32[0] = *v29;
        float v97 = *v29 * *(float *)v28;
        uint64_t v94 = (float32x2_t *)(v28 + 4);
        float v92 = *v29;
        goto LABEL_92;
      }
      char v98 = 0;
LABEL_93:
      if (v69 <= 1.0)
      {
        if ((v71 & 0x80000000) != 0) {
          goto LABEL_104;
        }
        uint64_t v99 = 3 * (int)v71;
        if (!v31) {
          uint64_t v71 = 0;
        }
      }
      else if (v69 > v22 || (uint64_t v71 = v60, v99 = 3 * (int)v20, (v20 & 0x80000000) != 0))
      {
LABEL_104:
        if (!v28)
        {
          char v122 = 0;
          goto LABEL_114;
        }
        _S20 = *(_DWORD *)v29;
        _S21 = *v29 * *(float *)v28;
        _S22 = *v29 * *(float *)(v28 + 4);
        _S23 = *v29 * *(float *)(v28 + 8);
        goto LABEL_106;
      }
      uint64_t v100 = (float *)(v30 + 4 * v99);
      _S20 = LODWORD(v10[v71]);
      if (v31) {
        float v102 = v10[v71];
      }
      else {
        float v102 = 1.0;
      }
      _S21 = *v100 * v102;
      _S22 = v102 * v100[1];
      _S23 = v102 * v100[2];
LABEL_106:
      __asm { FCVT            H21, S21 }
      v61->i16[0] = _H21;
      __asm { FCVT            H21, S22 }
      v61->i16[1] = _H21;
      __asm { FCVT            H21, S23 }
      v61->i16[2] = _H21;
      __asm { FCVT            H20, S20 }
LABEL_113:
      v61->i16[3] = _H20;
      char v122 = -1;
LABEL_114:
      float v14 = *(float *)a5.i32 + v64;
      char *v25 = v98;
      v25[1] = v122;
      v25 += 2;
      v61 += 2;
      v62 -= 2;
      if (v62 <= 2) {
        return;
      }
    }
  }
  if (v28 || (v20 & 0x80000000) == 0)
  {
    if ((v20 & 0x80000000) != 0)
    {
      _S3 = *(_DWORD *)v29;
      _S0 = *v29 * *(float *)v28;
      _D2 = vmul_n_f32(*(float32x2_t *)(v28 + 4), *v29);
    }
    else
    {
      uint64_t v123 = v30 + 12 * v20;
      if (!v31) {
        uint64_t v20 = 0;
      }
      _S3 = LODWORD(v10[v20]);
      if (v31) {
        float v125 = v10[v20];
      }
      else {
        float v125 = 1.0;
      }
      _D2 = vmul_n_f32(*(float32x2_t *)(v123 + 4), v125);
      _S0 = *(float *)v123 * v125;
    }
    __asm
    {
      FCVT            H0, S0
      FCVT            H1, S2
    }
    _S2 = _D2.i32[1];
    __asm
    {
      FCVT            H2, S2
      FCVT            H3, S3
    }
    int v133 = a4 + 4;
    do
    {
      v26->i16[0] = _H0;
      v26->i16[1] = _H1;
      v26->i16[2] = _H2;
      v26->i16[3] = _H3;
      v26[1].i16[0] = _H0;
      v26[1].i16[1] = _H1;
      v26[1].i16[2] = _H2;
      v26[1].i16[3] = _H3;
      v26[2].i16[0] = _H0;
      v26[2].i16[1] = _H1;
      v26[2].i16[2] = _H2;
      v26[2].i16[3] = _H3;
      v26[3].i16[0] = _H0;
      v26[3].i16[1] = _H1;
      v26[3].i16[2] = _H2;
      v133 -= 4;
      v26[3].i16[3] = _H3;
      v26 += 4;
      *(_DWORD *)float v25 = -1;
      v25 += 4;
    }
    while (v133 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v34 = 4;
    }
    else {
      int v34 = a4;
    }
    bzero(v25, ((a4 - v34 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t RGBAf16_sample_Wf16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(result + 32);
  uint64_t v6 = *(void *)(result + 40);
  int v7 = *(_DWORD *)(result + 24);
  int v8 = *(_DWORD *)(result + 28);
  uint64_t v9 = *(void *)(result + 176);
  uint64_t v10 = *(void *)(result + 72);
  uint64_t v124 = *(void *)(result + 80);
  uint64_t v122 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 112);
  uint64_t v11 = *(void *)(result + 120);
  int v121 = *(_DWORD *)(result + 188);
  float v13 = (_WORD *)(*(void *)(result + 152) - 8);
  uint64_t v14 = *(void *)(result + 144) - 1;
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  unint64_t v17 = v6 + (v15 * v8) + 2 * (v16 - 1);
  unint64_t v18 = v5 + (v15 * v7) + 2 * v16 - 2;
  int v119 = *(_DWORD *)(result + 240);
  int v120 = a4;
  uint64_t v123 = *(void *)(result + 64);
  while (1)
  {
    if (a3 >= v10)
    {
      if (a3 <= v122)
      {
        uint64_t v28 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v29 = 0x3FFFFFFF;
        uint64_t v30 = a3;
        uint64_t v22 = v123;
        uint64_t v31 = v124;
      }
      else
      {
        uint64_t v24 = *(void *)(result + 216);
        uint64_t v25 = *(void *)(result + 224) + v122;
        uint64_t v26 = v25 - a3 + (v24 >> 1);
        uint64_t v22 = v123;
        if (v26 < 1) {
          goto LABEL_39;
        }
        if (v26 >= v24) {
          LODWORD(v27) = 0x3FFFFFFF;
        }
        else {
          unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
        }
        uint64_t v31 = v124;
        unsigned int v29 = v27 | v121;
        uint64_t v30 = v25 - 0x1000000;
        uint64_t v28 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v10 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      uint64_t v22 = v123;
      if (v21 < 1) {
        goto LABEL_39;
      }
      if (v21 >= v19) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      uint64_t v31 = v124;
      unsigned int v29 = v23 | v121;
      uint64_t v30 = v20 + 0x1000000;
      uint64_t v28 = 512;
    }
    if (a2 >= v22) {
      break;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = v22 - *(void *)(result + 200);
    uint64_t v34 = a2 - v33 + (v32 >> 1);
    if (v34 >= 1)
    {
      if (v34 < v32) {
        unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v121;
      }
      uint64_t v35 = v33 + 0x1000000;
      uint64_t v36 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v12;
    a3 += v11;
    v13 += 4;
    *(unsigned char *)++uint64_t v14 = 0;
LABEL_40:
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v31)
  {
    uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v35 = a2;
    goto LABEL_26;
  }
  uint64_t v37 = v31;
  uint64_t v38 = *(void *)(result + 192);
  uint64_t v39 = *(void *)(result + 200) + v37;
  uint64_t v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1) {
    goto LABEL_39;
  }
  if (v40 < v38) {
    unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v121;
  }
  uint64_t v35 = v39 - 0x1000000;
  uint64_t v36 = 28;
LABEL_26:
  if (v29 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v41 = v30 >> 32;
  uint64_t v42 = v5 + (int)v41 * (uint64_t)v7;
  uint64_t v43 = v35 >> 31;
  unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v45 = v42 + (v43 & 0xFFFFFFFFFFFFFFFELL);
  float v46 = *(__int16 **)(result + 32);
  if (v18 >= v45) {
    BOOL v47 = (__int16 *)(v42 + (v43 & 0xFFFFFFFFFFFFFFFELL));
  }
  else {
    BOOL v47 = (__int16 *)v18;
  }
  if (v47 < v46) {
    BOOL v47 = *(__int16 **)(result + 32);
  }
  if (v6)
  {
    unint64_t v48 = v6 + (int)v41 * (uint64_t)v8 + v44;
    int v49 = *(__int16 **)(result + 40);
    if (v17 >= v48) {
      uint64_t v50 = (__int16 *)v48;
    }
    else {
      uint64_t v50 = (__int16 *)v17;
    }
    if (v50 >= v49) {
      int v49 = v50;
    }
    _H2 = *v49;
    __asm { FCVT            S2, H2 }
  }
  else
  {
    unint64_t v48 = 0;
    _S2 = 1.0;
  }
  _H3 = *v47;
  __asm { FCVT            S3, H3 }
  if (v9)
  {
    unsigned int v58 = *(_DWORD *)(v9 + (v36 | v28));
LABEL_45:
    int v59 = v58 & 0xF;
    int v60 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      float16x4_t v89 = (__int16 *)(v45 + SBYTE1(v58) * (uint64_t)v7);
      if (v18 < (unint64_t)v89) {
        float16x4_t v89 = (__int16 *)v18;
      }
      if (v89 < v46) {
        float16x4_t v89 = v46;
      }
      _H4 = *v89;
      __asm { FCVT            S4, H4 }
      _S5 = 1.0;
      if (v6)
      {
        uint64_t v93 = (__int16 *)(v48 + SBYTE1(v58) * (uint64_t)v8);
        if (v17 < (unint64_t)v93) {
          uint64_t v93 = (__int16 *)v17;
        }
        if ((unint64_t)v93 < *(void *)(result + 40)) {
          uint64_t v93 = *(__int16 **)(result + 40);
        }
        _H5 = *v93;
        __asm { FCVT            S5, H5 }
      }
      float v95 = &interpolate_waf[2 * v60];
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          uint64_t v61 = (__int16 *)(v45 + 2 * SBYTE2(v58));
          if (v18 < (unint64_t)v61) {
            uint64_t v61 = (__int16 *)v18;
          }
          if (v61 < v46) {
            uint64_t v61 = v46;
          }
          _H4 = *v61;
          __asm { FCVT            S4, H4 }
          unint64_t v64 = v45 + SBYTE1(v58) * (uint64_t)v7;
          if (v18 >= v64) {
            float v65 = (__int16 *)(v45 + SBYTE1(v58) * (uint64_t)v7);
          }
          else {
            float v65 = (__int16 *)v18;
          }
          if (v65 < v46) {
            float v65 = v46;
          }
          _H5 = *v65;
          __asm { FCVT            S5, H5 }
          float v68 = (__int16 *)(v64 + 2 * SBYTE2(v58));
          if (v18 < (unint64_t)v68) {
            float v68 = (__int16 *)v18;
          }
          if (v68 < v46) {
            float v68 = v46;
          }
          _H6 = *v68;
          __asm { FCVT            S6, H6 }
          _S7 = 1.0;
          _S16 = 1.0;
          _S17 = 1.0;
          if (v6)
          {
            uint64_t v74 = 2 * SBYTE2(v58);
            float v75 = (__int16 *)(v48 + v74);
            unint64_t v76 = *(void *)(result + 40);
            if (v17 < v48 + v74) {
              float v75 = (__int16 *)v17;
            }
            if ((unint64_t)v75 < v76) {
              float v75 = *(__int16 **)(result + 40);
            }
            _H7 = *v75;
            __asm { FCVT            S7, H7 }
            unint64_t v78 = v48 + SBYTE1(v58) * (uint64_t)v8;
            if (v17 >= v78) {
              float32x4_t v79 = (__int16 *)(v48 + SBYTE1(v58) * (uint64_t)v8);
            }
            else {
              float32x4_t v79 = (__int16 *)v17;
            }
            if ((unint64_t)v79 < v76) {
              float32x4_t v79 = *(__int16 **)(result + 40);
            }
            _H16 = *v79;
            __asm { FCVT            S16, H16 }
            float32x4_t v81 = (__int16 *)(v78 + v74);
            if (v17 < (unint64_t)v81) {
              float32x4_t v81 = (__int16 *)v17;
            }
            if ((unint64_t)v81 < v76) {
              float32x4_t v81 = *(__int16 **)(result + 40);
            }
            _H17 = *v81;
            __asm { FCVT            S17, H17 }
          }
          float v83 = interpolate_waf[2 * v60 + 1];
          float v84 = interpolate_waf[2 * ((v58 >> 28) & 3) + 1];
          float v85 = (float)(_S3 - (float)(_S3 * v84)) + (float)(_S4 * v84);
          float v86 = (float)(_S5 - (float)(_S5 * v84)) + (float)(_S6 * v84);
          float v87 = (float)(_S2 - (float)(_S2 * v84)) + (float)(_S7 * v84);
          if (v87 > 1.0) {
            float v87 = 1.0;
          }
          if (v87 < 0.0) {
            float v87 = 0.0;
          }
          float v88 = (float)(_S16 - (float)(_S16 * v84)) + (float)(_S17 * v84);
          if (v88 > 1.0) {
            float v88 = 1.0;
          }
          if (v88 < 0.0) {
            float v88 = 0.0;
          }
          _S3 = (float)(v85 - (float)(v85 * v83)) + (float)(v86 * v83);
          _S2 = (float)(v87 - (float)(v87 * v83)) + (float)(v88 * v83);
          if (_S2 > 1.0) {
            _S2 = 1.0;
          }
          if (_S2 < 0.0) {
            _S2 = 0.0;
          }
        }
        goto LABEL_112;
      }
      float v96 = (__int16 *)(v45 + 2 * SBYTE2(v58));
      if (v18 < (unint64_t)v96) {
        float v96 = (__int16 *)v18;
      }
      if (v96 < v46) {
        float v96 = v46;
      }
      _H4 = *v96;
      __asm { FCVT            S4, H4 }
      _S5 = 1.0;
      if (v6)
      {
        char v98 = (__int16 *)(v48 + 2 * SBYTE2(v58));
        if (v17 < (unint64_t)v98) {
          char v98 = (__int16 *)v17;
        }
        if ((unint64_t)v98 < *(void *)(result + 40)) {
          char v98 = *(__int16 **)(result + 40);
        }
        _H5 = *v98;
        __asm { FCVT            S5, H5 }
      }
      float v95 = &interpolate_waf[2 * ((v58 >> 28) & 3)];
    }
    float v100 = v95[1];
    _S3 = (float)(_S3 - (float)(_S3 * v100)) + (float)(_S4 * v100);
    _S2 = (float)(_S2 - (float)(_S2 * v100)) + (float)(_S5 * v100);
  }
LABEL_112:
  __asm { FCVT            H3, S3 }
  v13[6] = _H3;
  v13[5] = _H3;
  v13[4] = _H3;
  __asm { FCVT            H2, S2 }
  v13[7] = _H2;
  *(unsigned char *)++uint64_t v14 = v29 >> 22;
  if (--a4)
  {
    uint64_t v103 = v13 + 11;
    a2 += v12;
    uint64_t v104 = v124 - a2;
    a3 += v11;
    uint64_t v105 = v122 - a3;
    while (1)
    {
      float v13 = v103 - 7;
      if (((a2 - v123) | v104 | (a3 - v10) | v105) < 0) {
        goto LABEL_40;
      }
      uint64_t v106 = v5 + SHIDWORD(a3) * (uint64_t)v7;
      unint64_t v107 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v45 = v106 + v107;
      float v46 = *(__int16 **)(result + 32);
      if (v18 >= v106 + v107) {
        uint64_t v108 = (__int16 *)(v106 + v107);
      }
      else {
        uint64_t v108 = (__int16 *)v18;
      }
      if (v108 >= v46) {
        uint64_t v109 = v108;
      }
      else {
        uint64_t v109 = *(__int16 **)(result + 32);
      }
      if (v6)
      {
        unint64_t v48 = v6 + SHIDWORD(a3) * (uint64_t)v8 + v107;
        uint64_t v110 = *(__int16 **)(result + 40);
        if (v17 >= v48) {
          float v111 = (__int16 *)(v6 + SHIDWORD(a3) * (uint64_t)v8 + v107);
        }
        else {
          float v111 = (__int16 *)v17;
        }
        if (v111 >= v110) {
          uint64_t v110 = v111;
        }
        _H2 = *v110;
        __asm { FCVT            S2, H2 }
      }
      else
      {
        _S2 = 1.0;
      }
      _H3 = *v109;
      if (v9)
      {
        unsigned int v58 = *(_DWORD *)(v9 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        unsigned int v114 = v58 & 0xF;
        if ((v58 & 0xF) != 0)
        {
          __asm { FCVT            S3, H3 }
          unsigned int v116 = *(unsigned int **)(result + 264);
          unsigned int v117 = *v116;
          if (a4 != 1 && a4 + 1 != v120 && v119 != 1 && v117 == 3 && v114 < 3) {
            v58 |= 3u;
          }
          unsigned int v29 = -1;
          if (v117 < v114) {
            *unsigned int v116 = v114;
          }
          goto LABEL_45;
        }
      }
      *(v103 - 1) = _H3;
      *(v103 - 2) = _H3;
      *(v103 - 3) = _H3;
      __asm { FCVT            H2, S2 }
      *uint64_t v103 = _H2;
      *(unsigned char *)++uint64_t v14 = -1;
      v103 += 4;
      a2 += v12;
      v104 -= v12;
      a3 += v11;
      v105 -= v11;
      if (!--a4) {
        return result;
      }
    }
  }
  return result;
}

uint64_t RGBAf16_sample_RGBf16(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, float16x4_t a9, double a10, double _D6, float16x4_t a12)
{
  uint64_t v17 = *(void *)(result + 32);
  int v18 = *(_DWORD *)(result + 24);
  uint64_t v19 = *(void *)(result + 176);
  uint64_t v20 = *(void *)(result + 64);
  uint64_t v21 = *(void *)(result + 72);
  uint64_t v22 = *(void *)(result + 80);
  uint64_t v23 = *(void *)(result + 88);
  uint64_t v24 = *(void *)(result + 112);
  uint64_t v25 = *(void *)(result + 120);
  int v26 = *(_DWORD *)(result + 188);
  uint64_t v27 = *(void *)(result + 152) - 8;
  uint64_t v28 = *(void *)(result + 144) - 1;
  unint64_t v29 = v17
      + ((*(_DWORD *)(result + 260) - 1) * v18)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  int v98 = *(_DWORD *)(result + 240);
  int v99 = a4;
  while (1)
  {
    if ((uint64_t)a3 >= v21)
    {
      if ((uint64_t)a3 <= v23)
      {
        uint64_t v38 = (a3 >> 22) & 0x3C0;
        unsigned int v39 = 0x3FFFFFFF;
        HIDWORD(v40) = HIDWORD(a3);
      }
      else
      {
        uint64_t v34 = *(void *)(result + 216);
        uint64_t v35 = *(void *)(result + 224) + v23;
        uint64_t v36 = v35 - a3 + (v34 >> 1);
        if (v36 < 1) {
          goto LABEL_34;
        }
        if (v36 >= v34) {
          LODWORD(v37) = 0x3FFFFFFF;
        }
        else {
          unint64_t v37 = (unint64_t)(*(void *)(result + 232) * v36) >> 32;
        }
        unsigned int v39 = v37 | v26;
        uint64_t v40 = v35 - 0x1000000;
        uint64_t v38 = 448;
      }
    }
    else
    {
      uint64_t v30 = *(void *)(result + 216);
      uint64_t v31 = v21 - *(void *)(result + 224);
      uint64_t v32 = a3 - v31 + (v30 >> 1);
      if (v32 < 1) {
        goto LABEL_34;
      }
      if (v32 >= v30) {
        LODWORD(v33) = 0x3FFFFFFF;
      }
      else {
        unint64_t v33 = (unint64_t)(*(void *)(result + 232) * v32) >> 32;
      }
      unsigned int v39 = v33 | v26;
      uint64_t v40 = v31 + 0x1000000;
      uint64_t v38 = 512;
    }
    if (a2 >= v20) {
      break;
    }
    uint64_t v41 = *(void *)(result + 192);
    uint64_t v42 = v20 - *(void *)(result + 200);
    uint64_t v43 = a2 - v42 + (v41 >> 1);
    if (v43 >= 1)
    {
      if (v43 < v41) {
        unsigned int v39 = ((v39 >> 15) * (((unint64_t)(*(void *)(result + 208) * v43) >> 32) >> 15)) | v26;
      }
      uint64_t v44 = v42 + 0x1000000;
      uint64_t v45 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v24;
    a3 += v25;
    v27 += 8;
    *(unsigned char *)++uint64_t v28 = 0;
LABEL_35:
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v22)
  {
    uint64_t v45 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v44 = a2;
    goto LABEL_26;
  }
  uint64_t v46 = *(void *)(result + 192);
  uint64_t v47 = *(void *)(result + 200) + v22;
  uint64_t v48 = v47 - a2 + (v46 >> 1);
  if (v48 < 1) {
    goto LABEL_34;
  }
  if (v48 < v46) {
    unsigned int v39 = ((v39 >> 15) * (((unint64_t)(*(void *)(result + 208) * v48) >> 32) >> 15)) | v26;
  }
  uint64_t v44 = v47 - 0x1000000;
  uint64_t v45 = 28;
LABEL_26:
  if (v39 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v49 = v44 >> 32;
  uint64_t v50 = v17 + SHIDWORD(v40) * (uint64_t)v18;
  unint64_t v51 = v50 + 6 * (int)v49;
  unint64_t v52 = *(void *)(result + 32);
  if (v29 >= v51) {
    unint64_t v53 = v50 + 6 * (int)v49;
  }
  else {
    unint64_t v53 = v29;
  }
  if (v53 < v52) {
    unint64_t v53 = *(void *)(result + 32);
  }
  a9.i32[0] = *(_DWORD *)v53;
  _H3 = *(_WORD *)(v53 + 4);
  if (!v19) {
    goto LABEL_37;
  }
  unsigned int v55 = *(_DWORD *)(v19 + (v45 | v38));
LABEL_38:
  int v57 = v55 & 0xF;
  int v58 = HIBYTE(v55) & 3;
  if (v57 == 1)
  {
    unint64_t v82 = v51 + SBYTE1(v55) * (uint64_t)v18;
    if (v29 < v82) {
      unint64_t v82 = v29;
    }
    if (v82 < v52) {
      unint64_t v82 = v52;
    }
    _H5 = *(_WORD *)(v82 + 4);
    float v84 = &interpolate_rgbaf16[4 * v58];
    goto LABEL_73;
  }
  if (v57 == 2)
  {
    unint64_t v82 = v51 + 6 * SBYTE2(v55);
    if (v29 < v82) {
      unint64_t v82 = v29;
    }
    if (v82 < v52) {
      unint64_t v82 = v52;
    }
    _H5 = *(_WORD *)(v82 + 4);
    float v84 = &interpolate_rgbaf16[4 * ((v55 >> 28) & 3)];
LABEL_73:
    LOWORD(_D6) = v84[3];
    __asm { FCVT            S6, H6 }
    float32x4_t v85 = vcvtq_f32_f16(a9);
    a12.i32[0] = *(_DWORD *)v82;
    a12 = (float16x4_t)vcvtq_f32_f16(a12).u64[0];
    *(float32x2_t *)v85.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v85.f32, *(float32x2_t *)v85.f32, *(float32x2_t *)&_D6, 0), (float32x2_t)a12, *(float *)&_D6);
    a9 = vcvt_f16_f32(v85);
    __asm
    {
      FCVT            S3, H3
      FCVT            S5, H5
    }
    _S3 = (float)(_S3 - (float)(_S3 * *(float *)&_D6)) + (float)(_S5 * *(float *)&_D6);
    __asm { FCVT            H3, S3 }
    _S5 = (float)(1.0 - *(float *)&_D6) + *(float *)&_D6;
    goto LABEL_74;
  }
  if (v57 != 3)
  {
LABEL_37:
    _H5 = COERCE_UNSIGNED_INT(1.0);
    goto LABEL_75;
  }
  unint64_t v59 = v51 + 6 * SBYTE2(v55);
  if (v29 < v59) {
    unint64_t v59 = v29;
  }
  if (v59 < v52) {
    unint64_t v59 = v52;
  }
  _H5 = *(_WORD *)(v59 + 4);
  unint64_t v61 = v51 + SBYTE1(v55) * (uint64_t)v18;
  if (v29 >= v61) {
    unint64_t v62 = v51 + SBYTE1(v55) * (uint64_t)v18;
  }
  else {
    unint64_t v62 = v29;
  }
  if (v62 < v52) {
    unint64_t v62 = v52;
  }
  _H6 = *(_WORD *)(v62 + 4);
  unint64_t v64 = v61 + 6 * SBYTE2(v55);
  if (v29 < v64) {
    unint64_t v64 = v29;
  }
  if (v64 < v52) {
    unint64_t v64 = v52;
  }
  _H7 = *(_WORD *)(v64 + 4);
  _H16 = interpolate_rgbaf16[4 * v58 + 3];
  __asm { FCVT            S16, H16 }
  _H17 = interpolate_rgbaf16[4 * ((v55 >> 28) & 3) + 3];
  __asm { FCVT            S17, H17 }
  float32x4_t v71 = vcvtq_f32_f16(a9);
  __asm
  {
    FCVT            S3, H3
    FCVT            S5, H5
  }
  float v74 = (float)(_S3 - (float)(_S3 * _D17.f32[0])) + (float)(_S5 * _D17.f32[0]);
  __asm
  {
    FCVT            S5, H6
    FCVT            S6, H7
  }
  float v77 = (float)(_S5 - (float)(_S5 * _D17.f32[0])) + (float)(_S6 * _D17.f32[0]);
  float v78 = (float)(1.0 - _D17.f32[0]) + _D17.f32[0];
  if (v78 > 1.0) {
    float v78 = 1.0;
  }
  if (v78 < 0.0) {
    float v78 = 0.0;
  }
  a12.i32[0] = *(_DWORD *)v59;
  v14.i32[0] = *(_DWORD *)v62;
  v15.i32[0] = *(_DWORD *)v64;
  *(float32x2_t *)v71.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v71.f32, *(float32x2_t *)v71.f32, _D17, 0), (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a12), _D17.f32[0]);
  float32x2_t v79 = (float32x2_t)vcvtq_f32_f16(v14).u64[0];
  float16x4_t v14 = (float16x4_t)vcvtq_f32_f16(v15).u64[0];
  a12 = (float16x4_t)vmla_n_f32(vmls_lane_f32(v79, v79, _D17, 0), (float32x2_t)v14, _D17.f32[0]);
  *(float32x2_t *)v71.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v71.f32, *(float32x2_t *)v71.f32, _D16, 0), (float32x2_t)a12, _D16.f32[0]);
  a9 = vcvt_f16_f32(v71);
  _S3 = (float)(v74 - (float)(v74 * _D16.f32[0])) + (float)(v77 * _D16.f32[0]);
  __asm { FCVT            H3, S3 }
  _S5 = (float)(v78 - (float)(v78 * _D16.f32[0])) + (float)(v78 * _D16.f32[0]);
  if (_S5 > 1.0) {
    _S5 = 1.0;
  }
  if (_S5 < 0.0) {
    _S5 = 0.0;
  }
LABEL_74:
  __asm { FCVT            H5, S5 }
LABEL_75:
  *(_DWORD *)(v27 + 8) = a9.i32[0];
  *(_WORD *)(v27 + 12) = _H3;
  *(_WORD *)(v27 + 14) = _H5;
  *(unsigned char *)++uint64_t v28 = v39 >> 22;
  if (--a4)
  {
    float16x4_t v89 = (_WORD *)(v27 + 22);
    a2 += v24;
    uint64_t v90 = v22 - a2;
    a3 += v25;
    uint64_t v91 = v23 - a3;
    while (1)
    {
      uint64_t v27 = (uint64_t)(v89 - 7);
      if ((((a2 - v20) | v90 | (a3 - v21) | v91) & 0x8000000000000000) != 0) {
        goto LABEL_35;
      }
      uint64_t v92 = v17 + SHIDWORD(a3) * (uint64_t)v18;
      unint64_t v51 = v92 + 6 * SHIDWORD(a2);
      unint64_t v52 = *(void *)(result + 32);
      if (v29 >= v51) {
        unint64_t v93 = v92 + 6 * SHIDWORD(a2);
      }
      else {
        unint64_t v93 = v29;
      }
      if (v93 < v52) {
        unint64_t v93 = *(void *)(result + 32);
      }
      a9.i32[0] = *(_DWORD *)v93;
      _H3 = *(_WORD *)(v93 + 4);
      if (v19)
      {
        unsigned int v55 = *(_DWORD *)(v19 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        unsigned int v94 = v55 & 0xF;
        if ((v55 & 0xF) != 0)
        {
          float v95 = *(unsigned int **)(result + 264);
          unsigned int v96 = *v95;
          if (a4 != 1 && a4 + 1 != v99 && v98 != 1 && v96 == 3 && v94 < 3) {
            v55 |= 3u;
          }
          unsigned int v39 = -1;
          if (v96 < v94) {
            *float v95 = v94;
          }
          goto LABEL_38;
        }
      }
      *(_DWORD *)(v89 - 3) = a9.i32[0];
      *(v89 - 1) = _H3;
      *float16x4_t v89 = COERCE_UNSIGNED_INT(1.0);
      v89 += 4;
      a2 += v24;
      v90 -= v24;
      a3 += v25;
      v91 -= v25;
      *(unsigned char *)++uint64_t v28 = -1;
      if (!--a4) {
        return result;
      }
    }
  }
  return result;
}

uint64_t RGBAf16_sample_CMYKf16(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, float32x4_t _Q6)
{
  uint64_t v13 = *(void *)(result + 32);
  uint64_t v14 = *(void *)(result + 40);
  int v15 = *(_DWORD *)(result + 24);
  int v16 = *(_DWORD *)(result + 28);
  uint64_t v17 = *(void *)(result + 176);
  uint64_t v18 = *(void *)(result + 72);
  uint64_t v19 = *(void *)(result + 88);
  uint64_t v135 = *(void *)(result + 80);
  uint64_t v21 = *(void *)(result + 112);
  uint64_t v20 = *(void *)(result + 120);
  int v133 = *(_DWORD *)(result + 188);
  uint64_t v22 = (_WORD *)(*(void *)(result + 152) - 8);
  uint64_t v23 = (unsigned char *)(*(void *)(result + 144) - 1);
  int v24 = *(_DWORD *)(result + 260) - 1;
  int v25 = *(_DWORD *)(result + 256);
  unint64_t v26 = v14 + (v24 * v16) + 2 * (v25 - 1);
  unint64_t v27 = v13 + (v24 * v15) + 2 * (4 * v25) - 8;
  int v131 = *(_DWORD *)(result + 240);
  int v132 = a4;
  uint64_t v134 = *(void *)(result + 64);
  while (1)
  {
    if (a3 >= v18)
    {
      if (a3 <= v19)
      {
        uint64_t v36 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v37 = 0x3FFFFFFF;
        uint64_t v38 = a3;
        uint64_t v39 = v134;
      }
      else
      {
        uint64_t v32 = *(void *)(result + 216);
        uint64_t v33 = *(void *)(result + 224) + v19;
        uint64_t v34 = v33 - a3 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_39;
        }
        if (v34 >= v32) {
          LODWORD(v35) = 0x3FFFFFFF;
        }
        else {
          unint64_t v35 = (unint64_t)(*(void *)(result + 232) * v34) >> 32;
        }
        uint64_t v39 = v134;
        unsigned int v37 = v35 | v133;
        uint64_t v38 = v33 - 0x1000000;
        uint64_t v36 = 448;
      }
    }
    else
    {
      uint64_t v28 = *(void *)(result + 216);
      uint64_t v29 = v18 - *(void *)(result + 224);
      uint64_t v30 = a3 - v29 + (v28 >> 1);
      if (v30 < 1) {
        goto LABEL_39;
      }
      if (v30 >= v28) {
        LODWORD(v31) = 0x3FFFFFFF;
      }
      else {
        unint64_t v31 = (unint64_t)(*(void *)(result + 232) * v30) >> 32;
      }
      uint64_t v39 = v134;
      unsigned int v37 = v31 | v133;
      uint64_t v38 = v29 + 0x1000000;
      uint64_t v36 = 512;
    }
    if (a2 >= v39)
    {
      if (a2 <= v135)
      {
        uint64_t v44 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v43 = a2;
      }
      else
      {
        uint64_t v45 = *(void *)(result + 192);
        uint64_t v46 = *(void *)(result + 200) + v135;
        uint64_t v47 = v46 - a2 + (v45 >> 1);
        if (v47 < 1) {
          goto LABEL_39;
        }
        if (v47 < v45) {
          unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v47) >> 32) >> 15)) | v133;
        }
        uint64_t v43 = v46 - 0x1000000;
        uint64_t v44 = 28;
      }
    }
    else
    {
      uint64_t v40 = *(void *)(result + 192);
      uint64_t v41 = v39 - *(void *)(result + 200);
      uint64_t v42 = a2 - v41 + (v40 >> 1);
      if (v42 < 1) {
        goto LABEL_39;
      }
      if (v42 < v40) {
        unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v133;
      }
      uint64_t v43 = v41 + 0x1000000;
      uint64_t v44 = 32;
    }
    if (v37 >= 0x400000) {
      break;
    }
LABEL_39:
    --a4;
    a2 += v21;
    a3 += v20;
    v22 += 4;
    *++uint64_t v23 = 0;
LABEL_40:
    if (!a4) {
      return result;
    }
  }
  uint64_t v48 = v38 >> 32;
  uint64_t v49 = v43 >> 32;
  uint64_t v50 = v13 + (int)v48 * (uint64_t)v15;
  unint64_t v51 = v50 + 8 * v49;
  unint64_t v52 = *(float16x4_t **)(result + 32);
  if (v27 >= v51) {
    unint64_t v53 = (float16x4_t *)(v50 + 8 * v49);
  }
  else {
    unint64_t v53 = (float16x4_t *)v27;
  }
  if (v53 < v52) {
    unint64_t v53 = *(float16x4_t **)(result + 32);
  }
  if (v14)
  {
    unint64_t v54 = v14 + (int)v48 * (uint64_t)v16 + 2 * v49;
    unsigned int v55 = *(__int16 **)(result + 40);
    if (v26 >= v54) {
      float v56 = (__int16 *)v54;
    }
    else {
      float v56 = (__int16 *)v26;
    }
    if (v56 >= v55) {
      unsigned int v55 = v56;
    }
    _H2 = *v55;
  }
  else
  {
    unint64_t v54 = 0;
    _H2 = COERCE_UNSIGNED_INT(1.0);
  }
  _D3 = *v53;
  uint64_t v59 = v135;
  if (!v17) {
    goto LABEL_113;
  }
  unsigned int v60 = *(_DWORD *)(v17 + (v44 | v36));
LABEL_45:
  int v61 = v60 & 0xF;
  int v62 = HIBYTE(v60) & 3;
  switch(v61)
  {
    case 1:
      unsigned int v94 = (float16x4_t *)(v51 + SBYTE1(v60) * (uint64_t)v15);
      if (v27 < (unint64_t)v94) {
        unsigned int v94 = (float16x4_t *)v27;
      }
      if (v94 < v52) {
        unsigned int v94 = v52;
      }
      float16x4_t v95 = *v94;
      _H5 = COERCE_UNSIGNED_INT(1.0);
      if (v14)
      {
        float v97 = (__int16 *)(v54 + SBYTE1(v60) * (uint64_t)v16);
        if (v26 < (unint64_t)v97) {
          float v97 = (__int16 *)v26;
        }
        if ((unint64_t)v97 < *(void *)(result + 40)) {
          float v97 = *(__int16 **)(result + 40);
        }
        _H5 = *v97;
      }
      _Q6.i16[0] = interpolate_cmykaf[5 * v62 + 4];
      __asm { FCVT            S6, H6 }
      float32x4_t v98 = vcvtq_f32_f16(_D3);
      _D3 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v98, v98, *(float32x2_t *)_Q6.f32, 0), vcvtq_f32_f16(v95), _Q6.f32[0]));
      __asm { FCVT            S2, H2 }
      float v100 = _S2 - (float)(_S2 * _Q6.f32[0]);
      __asm { FCVT            S4, H5 }
      goto LABEL_111;
    case 2:
      int64_t v102 = (unint64_t)HIWORD(v60) << 56;
      uint64_t v103 = (float16x4_t *)(v51 + (v102 >> 53));
      if (v27 < (unint64_t)v103) {
        uint64_t v103 = (float16x4_t *)v27;
      }
      if (v103 < v52) {
        uint64_t v103 = v52;
      }
      float16x4_t v104 = *v103;
      _H4 = COERCE_UNSIGNED_INT(1.0);
      if (v14)
      {
        uint64_t v106 = (__int16 *)(v54 + (v102 >> 55));
        if (v26 < (unint64_t)v106) {
          uint64_t v106 = (__int16 *)v26;
        }
        if ((unint64_t)v106 < *(void *)(result + 40)) {
          uint64_t v106 = *(__int16 **)(result + 40);
        }
        _H4 = *v106;
      }
      _Q6.i16[0] = interpolate_cmykaf[5 * ((v60 >> 28) & 3) + 4];
      __asm { FCVT            S6, H6 }
      float32x4_t v107 = vcvtq_f32_f16(_D3);
      _D3 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v107, v107, *(float32x2_t *)_Q6.f32, 0), vcvtq_f32_f16(v104), _Q6.f32[0]));
      __asm { FCVT            S2, H2 }
      float v100 = _S2 - (float)(_S2 * _Q6.f32[0]);
      __asm { FCVT            S4, H4 }
LABEL_111:
      _S2 = v100 + (float)(_S4 * _Q6.f32[0]);
      goto LABEL_112;
    case 3:
      int64_t v63 = (unint64_t)HIWORD(v60) << 56;
      unint64_t v64 = (float16x4_t *)(v51 + (v63 >> 53));
      if (v27 < (unint64_t)v64) {
        unint64_t v64 = (float16x4_t *)v27;
      }
      if (v64 < v52) {
        unint64_t v64 = v52;
      }
      float v65 = (float16x4_t *)(v51 + SBYTE1(v60) * (uint64_t)v15);
      if (v27 >= (unint64_t)v65) {
        float16x4_t v66 = v65;
      }
      else {
        float16x4_t v66 = (float16x4_t *)v27;
      }
      if (v66 < v52) {
        float16x4_t v66 = v52;
      }
      float v67 = (float16x4_t *)((char *)v65 + (v63 >> 53));
      if (v27 < (unint64_t)v67) {
        float v67 = (float16x4_t *)v27;
      }
      if (v67 < v52) {
        float v67 = v52;
      }
      float16x4_t v68 = *v66;
      float16x4_t v69 = *v67;
      _H7 = COERCE_UNSIGNED_INT(1.0);
      _H16 = COERCE_UNSIGNED_INT(1.0);
      _H17 = COERCE_UNSIGNED_INT(1.0);
      if (v14)
      {
        uint64_t v73 = (__int16 *)(v54 + (v63 >> 55));
        unint64_t v74 = *(void *)(result + 40);
        if (v26 < (unint64_t)v73) {
          uint64_t v73 = (__int16 *)v26;
        }
        if ((unint64_t)v73 < v74) {
          uint64_t v73 = *(__int16 **)(result + 40);
        }
        _H7 = *v73;
        unint64_t v75 = v54 + SBYTE1(v60) * (uint64_t)v16;
        if (v26 >= v75) {
          unint64_t v76 = (__int16 *)(v54 + SBYTE1(v60) * (uint64_t)v16);
        }
        else {
          unint64_t v76 = (__int16 *)v26;
        }
        if ((unint64_t)v76 < v74) {
          unint64_t v76 = *(__int16 **)(result + 40);
        }
        _H16 = *v76;
        float v77 = (__int16 *)(v75 + (v63 >> 55));
        if (v26 < (unint64_t)v77) {
          float v77 = (__int16 *)v26;
        }
        if ((unint64_t)v77 < v74) {
          float v77 = *(__int16 **)(result + 40);
        }
        _H17 = *v77;
      }
      _H18 = interpolate_cmykaf[5 * v62 + 4];
      __asm { FCVT            S18, H18 }
      _H19 = interpolate_cmykaf[5 * ((v60 >> 28) & 3) + 4];
      __asm { FCVT            S19, H19 }
      float32x4_t v83 = vcvtq_f32_f16(_D3);
      float32x4_t v84 = vcvtq_f32_f16(*v64);
      float32x4_t v85 = vcvtq_f32_f16(v68);
      _Q6 = vcvtq_f32_f16(v69);
      __asm
      {
        FCVT            S2, H2
        FCVT            S7, H7
      }
      float v88 = (float)(_S2 - (float)(_S2 * _D19.f32[0])) + (float)(_S7 * _D19.f32[0]);
      if (v88 > 1.0) {
        float v88 = 1.0;
      }
      if (v88 < 0.0) {
        float v88 = 0.0;
      }
      __asm
      {
        FCVT            S7, H16
        FCVT            S16, H17
      }
      float v91 = (float)(_S7 - (float)(_S7 * _D19.f32[0])) + (float)(_S16 * _D19.f32[0]);
      if (v91 > 1.0) {
        float v91 = 1.0;
      }
      if (v91 < 0.0) {
        float v91 = 0.0;
      }
      float32x4_t v92 = vmlaq_n_f32(vmlsq_lane_f32(v83, v83, _D19, 0), v84, _D19.f32[0]);
      _D3 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v92, v92, _D18, 0), vmlaq_n_f32(vmlsq_lane_f32(v85, v85, _D19, 0), _Q6, _D19.f32[0]), _D18.f32[0]));
      _S2 = (float)(v88 - (float)(v88 * _D18.f32[0])) + (float)(v91 * _D18.f32[0]);
      if (_S2 > 1.0) {
        _S2 = 1.0;
      }
      if (_S2 < 0.0) {
        _S2 = 0.0;
      }
LABEL_112:
      __asm { FCVT            H2, S2 }
      uint64_t v59 = v135;
      break;
  }
LABEL_113:
  ++v23;
  a2 += v21;
  uint64_t v109 = v59 - a2;
  v22 += 4;
  a3 += v20;
  uint64_t v110 = v19 - a3;
  while (1)
  {
    int v111 = a4;
    __asm { FCVT            S4, H2 }
    _H5 = _D3.i16[3];
    __asm
    {
      FCVT            S5, H5
      FCVT            S6, H3
    }
    _H7 = _D3.i16[1];
    __asm { FCVT            S7, H7 }
    _H3 = _D3.i16[2];
    __asm { FCVT            S3, H3 }
    _S6 = (float)(_S4 - _S6) - _S5;
    __asm { FCVT            H6, S6 }
    *uint64_t v22 = LOWORD(_S6);
    _S6 = (float)(_S4 - _S7) - _S5;
    __asm { FCVT            H6, S6 }
    v22[1] = LOWORD(_S6);
    _S3 = (float)(_S4 - _S3) - _S5;
    __asm { FCVT            H3, S3 }
    unsigned char v22[2] = LOWORD(_S3);
    v22[3] = _H2;
    *uint64_t v23 = v37 >> 22;
    if (!--a4) {
      return result;
    }
    if ((v110 | v109 | (a3 - v18) | (a2 - v134)) < 0) {
      goto LABEL_40;
    }
    unint64_t v51 = v13 + SHIDWORD(a3) * (uint64_t)v15 + 8 * (a2 >> 32);
    unint64_t v52 = *(float16x4_t **)(result + 32);
    if (v27 >= v51) {
      unint64_t v123 = v13 + SHIDWORD(a3) * (uint64_t)v15 + 8 * (a2 >> 32);
    }
    else {
      unint64_t v123 = v27;
    }
    if (v123 >= (unint64_t)v52) {
      uint64_t v124 = (float16x4_t *)v123;
    }
    else {
      uint64_t v124 = *(float16x4_t **)(result + 32);
    }
    if (v14)
    {
      unint64_t v54 = v14 + SHIDWORD(a3) * (uint64_t)v16 + 2 * (a2 >> 32);
      float v125 = *(__int16 **)(result + 40);
      if (v26 >= v54) {
        unint64_t v126 = v14 + SHIDWORD(a3) * (uint64_t)v16 + 2 * (a2 >> 32);
      }
      else {
        unint64_t v126 = v26;
      }
      if (v126 >= (unint64_t)v125) {
        float v125 = (__int16 *)v126;
      }
      _H2 = *v125;
    }
    else
    {
      _H2 = COERCE_UNSIGNED_INT(1.0);
    }
    _D3 = *v124;
    if (v17)
    {
      unsigned int v60 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      unsigned int v127 = v60 & 0xF;
      if ((v60 & 0xF) != 0)
      {
        uint64_t v128 = *(unsigned int **)(result + 264);
        unsigned int v129 = *v128;
        if (v111 != v132 && a4 != 1 && v131 != 1 && v129 == 3 && v127 < 3) {
          v60 |= 3u;
        }
        unsigned int v37 = -1;
        if (v129 < v127) {
          unsigned int *v128 = v127;
        }
        uint64_t v59 = v135;
        goto LABEL_45;
      }
    }
    ++v23;
    v109 -= v21;
    a2 += v21;
    v22 += 4;
    a3 += v20;
    v110 -= v20;
    unsigned int v37 = -1;
  }
}

BOOL CPFontEnumeratorIsKnownRenderedChar(uint64_t a1, unsigned __int16 *a2)
{
  if (a1 == 2)
  {
    int v3 = *a2;
    if ((unsigned __int16)((unsigned __int16)(v3 + 9408) >> 6) >= 0x3F3u)
    {
      int v4 = a2[1];
      if ((unsigned __int16)((unsigned __int16)(v4 + 0x2000) >> 10) >= 0x3Fu) {
        return (~v3 & 0x3F | ~v4 & 0x3FE) != 0;
      }
    }
    return 0;
  }
  if (a1 != 1) {
    return 0;
  }
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0;
  }
  if (v2 > 0x7F)
  {
    if (!__maskrune(*a2, 0x200uLL)) {
      goto LABEL_11;
    }
    return 0;
  }
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x200) != 0) {
    return 0;
  }
LABEL_11:
  if (v2 > 0xFFFD) {
    return 0;
  }
  return (unsigned __int16)(v2 + 560) >= 0x20u && v2 >> 11 != 27;
}

uint64_t CPFontEnumeratorProcessMultiUnicodes(uint64_t a1, uint64_t a2, unsigned __int16 *a3)
{
  if (!a2) {
    return 0;
  }
  unsigned __int16 v5 = 0;
  int v6 = 0;
  uint64_t v7 = a2 - 1;
  uint64_t v8 = MEMORY[0x1E4F14390];
  while (2)
  {
    int v9 = v6;
    unint64_t v10 = a3[v7];
    if (v10 > 0x7F) {
      int v11 = __maskrune(a3[v7], 0x4000uLL);
    }
    else {
      int v11 = *(_DWORD *)(v8 + 4 * v10 + 60) & 0x4000;
    }
    int v6 = 1;
    if (v11 || v10 == 160) {
      goto LABEL_16;
    }
    int v6 = 2;
    if ((int)v10 <= 8207)
    {
      if (v10 != 45 && v10 != 173) {
        goto LABEL_35;
      }
LABEL_16:
      if (!v9)
      {
LABEL_18:
        switch(v6)
        {
          case 1:
            if (v10 == 160 || v10 == 32) {
              unsigned __int16 v5 = 9;
            }
            else {
              unsigned __int16 v5 = v10;
            }
            goto LABEL_33;
          case 2:
            BOOL v13 = v10 == 173;
            goto LABEL_28;
          case 3:
            BOOL v13 = v10 == 61441;
            goto LABEL_28;
          case 4:
            BOOL v13 = v10 == 61442;
LABEL_28:
            if (!v13 || v9 == 0) {
              unsigned __int16 v5 = v10;
            }
LABEL_33:
            if (--v7 == -1) {
              return v5;
            }
            continue;
          default:
            goto LABEL_43;
        }
      }
      goto LABEL_17;
    }
    break;
  }
  if (v10 == 8208) {
    goto LABEL_16;
  }
  if (v10 == 61441 || v10 == 64257)
  {
    int v6 = 3;
    if (!v9) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_35:
  if (v10 == 61442 || v10 == 64258) {
    int v6 = 4;
  }
  else {
    int v6 = 0;
  }
  if (!v9) {
    goto LABEL_18;
  }
LABEL_17:
  if (v6 == v9) {
    goto LABEL_18;
  }
LABEL_43:
  CPMultiUnicodesAppend(*(void *)(*(void *)(a1 + 112) + 2296), 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(void *)(*(void *)(a1 + 112) + 2072) - *(void *)(*(void *)(a1 + 112) + 2064)) >> 6), a2, a3);
  return 0;
}

uint64_t CPFontEnumeratorGetUnicharForCID(uint64_t a1, uint64_t a2, unsigned __int16 *a3, BOOL *a4)
{
  unsigned int v6 = a2;
  uint64_t v8 = *(void *)(a1 + 96);
  if (v8
    && cmap_vtable
    && (int v9 = *(uint64_t (**)(void, uint64_t, unsigned __int16 *))(cmap_vtable + 64)) != 0)
  {
    uint64_t v10 = v9(*(void *)(v8 + 16), a2, a3);
    *a4 = CPFontEnumeratorIsKnownRenderedChar(v10, a3);
    if (v10) {
      goto LABEL_9;
    }
  }
  else
  {
    *a4 = CPFontEnumeratorIsKnownRenderedChar(0, a3);
  }
  uint64_t v11 = CGPDFGetUnicharGuessForCID(v6, a3);
  if (!v11) {
    return 0;
  }
  uint64_t v10 = v11;
LABEL_9:
  if (v10 == 1) {
    return *a3;
  }
  uint64_t v12 = CPFontEnumeratorProcessMultiUnicodes(a1, v10, a3);
  unsigned __int16 v14 = v12;
  if (v12) {
    *a4 = CPFontEnumeratorIsKnownRenderedChar(1, &v14);
  }
  return v12;
}

void Wf16_sample_W8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_W8", 13485, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void Wf16_sample_W16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_W16", 13489, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void Wf16_sample_w16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_w16", 13493, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void Wf16_sample_WF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_WF", 13497, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

uint64_t Wf16_sample_Wf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v162 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v161 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v161 = v5 % v6;
    }
  }
  else
  {
    uint64_t v161 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v10 = *(void *)(result + 32);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v11 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v12 = v11 % v7;
    if (v11 <= v7) {
      uint64_t v12 = *(void *)(result + 120);
    }
    uint64_t v160 = v12;
  }
  else
  {
    uint64_t v160 = 0;
  }
  uint64_t v156 = *(void *)(result + 80);
  uint64_t v158 = *(void *)(result + 88);
  int v155 = *(_DWORD *)(result + 188);
  uint64_t v13 = *(void *)(result + 152) - 4;
  uint64_t v14 = *(void *)(result + 144) - 1;
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  unint64_t v17 = v9 + (v15 * v162) + 2 * (v16 - 1);
  unint64_t v18 = v10 + (v15 * v4) + 2 * v16 - 2;
  int v153 = *(_DWORD *)(result + 240);
  int v154 = a4;
  uint64_t v157 = *(void *)(result + 64);
  uint64_t v159 = *(void *)(result + 72);
  while (1)
  {
    if (a3 >= v159)
    {
      if (a3 <= v158)
      {
        uint64_t v27 = 0;
        uint64_t v28 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v29 = 0x3FFFFFFF;
        uint64_t v30 = a3;
        uint64_t v31 = v157;
      }
      else
      {
        uint64_t v23 = *(void *)(result + 216);
        uint64_t v24 = *(void *)(result + 224) + v158;
        uint64_t v25 = v24 - a3 + (v23 >> 1);
        if (v25 < 1) {
          goto LABEL_57;
        }
        if (v25 >= v23) {
          LODWORD(v26) = 0x3FFFFFFF;
        }
        else {
          unint64_t v26 = (unint64_t)(*(void *)(result + 232) * v25) >> 32;
        }
        uint64_t v31 = v157;
        unsigned int v29 = v155 | v26;
        uint64_t v30 = v24 - 0x1000000;
        uint64_t v27 = a3 - (v24 - 0x1000000);
        uint64_t v28 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v159 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      if (v21 < 1) {
        goto LABEL_57;
      }
      if (v21 >= v19) {
        LODWORD(v22) = 0x3FFFFFFF;
      }
      else {
        unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      uint64_t v31 = v157;
      unsigned int v29 = v155 | v22;
      uint64_t v30 = v20 + 0x1000000;
      uint64_t v27 = a3 - (v20 + 0x1000000);
      uint64_t v28 = 512;
    }
    if (a2 >= v31) {
      break;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = v31 - *(void *)(result + 200);
    uint64_t v34 = a2 - v33 + (v32 >> 1);
    if (v34 >= 1)
    {
      if (v34 < v32) {
        unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v155;
      }
      uint64_t v35 = v33 + 0x1000000;
      uint64_t v36 = a2 - (v33 + 0x1000000);
      uint64_t v37 = 32;
      goto LABEL_35;
    }
LABEL_57:
    --a4;
    a2 += v5;
    a3 += v11;
    v13 += 4;
    *(unsigned char *)++uint64_t v14 = 0;
LABEL_58:
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v156)
  {
    uint64_t v36 = 0;
    uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v35 = a2;
    goto LABEL_35;
  }
  uint64_t v38 = *(void *)(result + 192);
  uint64_t v39 = *(void *)(result + 200) + v156;
  uint64_t v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1) {
    goto LABEL_57;
  }
  if (v40 < v38) {
    unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v155;
  }
  uint64_t v35 = v39 - 0x1000000;
  uint64_t v36 = a2 - (v39 - 0x1000000);
  uint64_t v37 = 28;
LABEL_35:
  if (v29 < 0x400000) {
    goto LABEL_57;
  }
  if (v6)
  {
    uint64_t v41 = (v7 & ((v30 % v7) >> 63)) + v30 % v7;
    uint64_t v42 = (v6 & ((v35 % v6) >> 63)) + v35 % v6;
    if (v41 >= v7) {
      uint64_t v43 = v7;
    }
    else {
      uint64_t v43 = 0;
    }
    uint64_t v30 = v41 - v43;
    if (v42 >= v6) {
      uint64_t v44 = v6;
    }
    else {
      uint64_t v44 = 0;
    }
    uint64_t v35 = v42 - v44;
    v27 += v30;
    v36 += v42 - v44;
  }
  uint64_t v45 = v30 >> 32;
  uint64_t v46 = v10 + SHIDWORD(v30) * (uint64_t)v4;
  unint64_t v47 = (v35 >> 31) & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v48 = (__int16 *)(v46 + v47);
  uint64_t v49 = *(__int16 **)(result + 32);
  if (v18 >= v46 + v47) {
    uint64_t v50 = (__int16 *)(v46 + v47);
  }
  else {
    uint64_t v50 = (__int16 *)v18;
  }
  if (v50 >= v49) {
    unint64_t v51 = v50;
  }
  else {
    unint64_t v51 = *(__int16 **)(result + 32);
  }
  if (v9)
  {
    unint64_t v52 = v9 + (int)v45 * (uint64_t)v162 + v47;
    unint64_t v53 = *(__int16 **)(result + 40);
    if (v17 >= v52) {
      unint64_t v54 = (__int16 *)v52;
    }
    else {
      unint64_t v54 = (__int16 *)v17;
    }
    if (v54 >= v53) {
      unint64_t v53 = v54;
    }
    _H2 = *v53;
  }
  else
  {
    unint64_t v52 = 0;
    _H2 = COERCE_UNSIGNED_INT(1.0);
  }
  _H3 = *v51;
  if (!v8) {
    goto LABEL_155;
  }
  unsigned int v57 = *(_DWORD *)(v8 + (v37 | v28));
LABEL_63:
  int v58 = v57 & 0xF;
  uint64_t v59 = v57 >> 8;
  int v60 = HIBYTE(v57) & 3;
  switch(v58)
  {
    case 1:
      LODWORD(v111) = SBYTE1(v57);
      if (v6)
      {
        uint64_t v112 = v27 + ((uint64_t)SBYTE1(v57) << 32);
        uint64_t v113 = v7 & (v112 >> 63);
        if (v113 + v112 >= v7) {
          uint64_t v114 = v7;
        }
        else {
          uint64_t v114 = 0;
        }
        uint64_t v111 = (v113 + ((uint64_t)(char)v59 << 32) - v114) >> 32;
      }
      float16x8_t v115 = (__int16 *)((char *)v48 + (int)v111 * (uint64_t)v4);
      if (v18 < (unint64_t)v115) {
        float16x8_t v115 = (__int16 *)v18;
      }
      if (v115 < v49) {
        float16x8_t v115 = v49;
      }
      _H4 = *v115;
      _H5 = COERCE_UNSIGNED_INT(1.0);
      if (v9)
      {
        unsigned int v118 = (__int16 *)(v52 + (int)v111 * (uint64_t)v162);
        if (v17 < (unint64_t)v118) {
          unsigned int v118 = (__int16 *)v17;
        }
        if ((unint64_t)v118 < *(void *)(result + 40)) {
          unsigned int v118 = *(__int16 **)(result + 40);
        }
        _H5 = *v118;
      }
      int v119 = &interpolate_waf[2 * v60];
      goto LABEL_153;
    case 2:
      uint64_t v120 = SBYTE2(v57);
      if (v6)
      {
        int64_t v121 = (unint64_t)HIWORD(v57) << 56;
        uint64_t v122 = v36 + (v121 >> 24);
        uint64_t v123 = v6 & (v122 >> 63);
        if (v123 + v122 >= v6) {
          uint64_t v124 = v6;
        }
        else {
          uint64_t v124 = 0;
        }
        uint64_t v120 = (v123 + (v121 >> 24) - v124) >> 32;
      }
      float v125 = &v48[v120];
      if (v18 < (unint64_t)v125) {
        float v125 = (__int16 *)v18;
      }
      if (v125 < v49) {
        float v125 = v49;
      }
      _H4 = *v125;
      _H5 = COERCE_UNSIGNED_INT(1.0);
      if (v9)
      {
        unint64_t v126 = (__int16 *)(v52 + 2 * v120);
        if (v17 < (unint64_t)v126) {
          unint64_t v126 = (__int16 *)v17;
        }
        if ((unint64_t)v126 < *(void *)(result + 40)) {
          unint64_t v126 = *(__int16 **)(result + 40);
        }
        _H5 = *v126;
      }
      int v119 = &interpolate_waf[2 * ((v57 >> 28) & 3)];
LABEL_153:
      _H6 = v119[1];
      __asm
      {
        FCVT            S6, H6
        FCVT            S3, H3
        FCVT            S4, H4
      }
      _S3 = (float)(_S3 - (float)(_S3 * _S6)) + (float)(_S4 * _S6);
      __asm
      {
        FCVT            H3, S3
        FCVT            S2, H2
        FCVT            S4, H5
      }
      _S2 = (float)(_S2 - (float)(_S2 * _S6)) + (float)(_S4 * _S6);
      goto LABEL_154;
    case 3:
      LODWORD(v61) = SBYTE1(v57);
      uint64_t v62 = SBYTE2(v57);
      if (v6)
      {
        uint64_t v63 = v59 << 56;
        uint64_t v64 = v27 + ((uint64_t)SBYTE1(v57) << 32);
        uint64_t v65 = v36 + ((uint64_t)SBYTE2(v57) << 32);
        unsigned int v152 = v29;
        uint64_t v66 = v7 & (v64 >> 63);
        uint64_t v67 = v6 & (v65 >> 63);
        uint64_t v68 = v67 + v65;
        if (v66 + v64 >= v7) {
          uint64_t v69 = v7;
        }
        else {
          uint64_t v69 = 0;
        }
        if (v68 >= v6) {
          uint64_t v70 = v6;
        }
        else {
          uint64_t v70 = 0;
        }
        uint64_t v71 = v66 + (v63 >> 24);
        unsigned int v29 = v152;
        uint64_t v61 = (v71 - v69) >> 32;
        uint64_t v62 = (v67 + ((uint64_t)((unint64_t)HIWORD(v57) << 56) >> 24) - v70) >> 32;
      }
      unsigned int v72 = &v48[v62];
      if (v18 < (unint64_t)v72) {
        unsigned int v72 = (__int16 *)v18;
      }
      if (v72 < v49) {
        unsigned int v72 = v49;
      }
      _H4 = *v72;
      unint64_t v74 = (unint64_t)v48 + (int)v61 * (uint64_t)v4;
      if (v18 >= v74) {
        unint64_t v75 = (__int16 *)((char *)v48 + (int)v61 * (uint64_t)v4);
      }
      else {
        unint64_t v75 = (__int16 *)v18;
      }
      if (v75 < v49) {
        unint64_t v75 = v49;
      }
      _H5 = *v75;
      float v77 = (__int16 *)(v74 + 2 * v62);
      if (v18 < (unint64_t)v77) {
        float v77 = (__int16 *)v18;
      }
      if (v77 < v49) {
        float v77 = v49;
      }
      _H6 = *v77;
      _H7 = COERCE_UNSIGNED_INT(1.0);
      _H16 = COERCE_UNSIGNED_INT(1.0);
      _H17 = COERCE_UNSIGNED_INT(1.0);
      if (v9)
      {
        uint64_t v82 = 2 * v62;
        float32x4_t v83 = (__int16 *)(v52 + 2 * v62);
        unint64_t v84 = *(void *)(result + 40);
        if (v17 < (unint64_t)v83) {
          float32x4_t v83 = (__int16 *)v17;
        }
        if ((unint64_t)v83 < v84) {
          float32x4_t v83 = *(__int16 **)(result + 40);
        }
        _H7 = *v83;
        unint64_t v85 = v52 + (int)v61 * (uint64_t)v162;
        if (v17 >= v85) {
          float v86 = (__int16 *)(v52 + (int)v61 * (uint64_t)v162);
        }
        else {
          float v86 = (__int16 *)v17;
        }
        if ((unint64_t)v86 < v84) {
          float v86 = *(__int16 **)(result + 40);
        }
        _H16 = *v86;
        float v87 = (__int16 *)(v85 + v82);
        if (v17 < (unint64_t)v87) {
          float v87 = (__int16 *)v17;
        }
        if ((unint64_t)v87 < v84) {
          float v87 = *(__int16 **)(result + 40);
        }
        _H17 = *v87;
      }
      _H18 = interpolate_waf[2 * (HIBYTE(v57) & 3) + 1];
      __asm { FCVT            S18, H18 }
      _H19 = interpolate_waf[2 * ((v57 >> 28) & 3) + 1];
      __asm
      {
        FCVT            S19, H19
        FCVT            S3, H3
        FCVT            S4, H4
      }
      float v97 = (float)(_S3 - (float)(_S3 * _S19)) + (float)(_S4 * _S19);
      __asm
      {
        FCVT            S4, H5
        FCVT            S5, H6
      }
      float v100 = (float)(_S4 - (float)(_S4 * _S19)) + (float)(_S5 * _S19);
      __asm
      {
        FCVT            S2, H2
        FCVT            S5, H7
      }
      float v103 = (float)(_S2 - (float)(_S2 * _S19)) + (float)(_S5 * _S19);
      if (v103 < 1.0) {
        float v104 = v103;
      }
      else {
        float v104 = 1.0;
      }
      if (v103 > 1.0) {
        float v103 = 1.0;
      }
      if (v104 < 0.0) {
        float v103 = 0.0;
      }
      __asm
      {
        FCVT            S5, H16
        FCVT            S6, H17
      }
      float v107 = (float)(_S5 - (float)(_S5 * _S19)) + (float)(_S6 * _S19);
      if (v107 < 1.0) {
        float v108 = v107;
      }
      else {
        float v108 = 1.0;
      }
      if (v107 > 1.0) {
        float v107 = 1.0;
      }
      if (v108 < 0.0) {
        float v107 = 0.0;
      }
      _S3 = (float)(v97 - (float)(v97 * _S18)) + (float)(v100 * _S18);
      __asm { FCVT            H3, S3 }
      _S2 = (float)(v103 - (float)(v103 * _S18)) + (float)(v107 * _S18);
      if (_S2 >= 1.0) {
        _S2 = 1.0;
      }
      if (_S2 <= 0.0) {
        _S2 = 0.0;
      }
LABEL_154:
      __asm { FCVT            H2, S2 }
      break;
  }
LABEL_155:
  *(_WORD *)(v13 + 4) = _H3;
  *(_WORD *)(v13 + 6) = _H2;
  *(unsigned char *)++uint64_t v14 = v29 >> 22;
  if (--a4)
  {
    uint64_t v134 = (_WORD *)(v13 + 10);
    a2 += v5;
    uint64_t v135 = v156 - a2;
    a3 += v11;
    uint64_t v136 = v158 - a3;
    while (1)
    {
      uint64_t v13 = (uint64_t)(v134 - 3);
      if ((v136 | v135 | (a3 - v159) | (a2 - v157)) < 0) {
        goto LABEL_58;
      }
      if (v6)
      {
        uint64_t v137 = (v7 & ((v27 + v160) >> 63)) + v27 + v160;
        uint64_t v138 = (v6 & ((v36 + v161) >> 63)) + v36 + v161;
        if (v137 >= v7) {
          uint64_t v139 = v7;
        }
        else {
          uint64_t v139 = 0;
        }
        uint64_t v140 = v137 - v139;
        if (v138 >= v6) {
          uint64_t v141 = v6;
        }
        else {
          uint64_t v141 = 0;
        }
        uint64_t v142 = v138 - v141;
        uint64_t v36 = v142;
        uint64_t v27 = v140;
      }
      else
      {
        uint64_t v142 = a2;
        uint64_t v140 = a3;
      }
      uint64_t v143 = v140 >> 32;
      unint64_t v144 = (v142 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v48 = (__int16 *)(v10 + SHIDWORD(v140) * (uint64_t)v4 + v144);
      uint64_t v49 = *(__int16 **)(result + 32);
      if (v18 >= (unint64_t)v48) {
        int8x16x2_t v145 = v48;
      }
      else {
        int8x16x2_t v145 = (__int16 *)v18;
      }
      if (v145 < v49) {
        int8x16x2_t v145 = *(__int16 **)(result + 32);
      }
      if (v9)
      {
        unint64_t v52 = v9 + (int)v143 * (uint64_t)v162 + v144;
        int v146 = *(__int16 **)(result + 40);
        if (v17 >= v52) {
          int8x16x2_t v147 = (__int16 *)v52;
        }
        else {
          int8x16x2_t v147 = (__int16 *)v17;
        }
        if (v147 >= v146) {
          int v146 = v147;
        }
        _H2 = *v146;
      }
      else
      {
        _H2 = COERCE_UNSIGNED_INT(1.0);
      }
      _H3 = *v145;
      if (v8)
      {
        unsigned int v57 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        unsigned int v148 = v57 & 0xF;
        if ((v57 & 0xF) != 0)
        {
          unsigned int v149 = *(unsigned int **)(result + 264);
          unsigned int v150 = *v149;
          if (a4 + 1 != v154 && a4 != 1 && v153 != 1 && v150 == 3 && v148 < 3) {
            v57 |= 3u;
          }
          unsigned int v29 = -1;
          if (v150 < v148) {
            *unsigned int v149 = v148;
          }
          goto LABEL_63;
        }
      }
      *(v134 - 1) = _H3;
      *uint64_t v134 = _H2;
      v134 += 2;
      a2 += v5;
      v135 -= v5;
      a3 += v11;
      *(unsigned char *)++uint64_t v14 = -1;
      v136 -= v11;
      if (!--a4) {
        return result;
      }
    }
  }
  return result;
}

void Wf16_sample_RGBF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_RGBF", 13505, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

uint64_t Wf16_sample_RGBf_inner(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, float16x4_t _D7)
{
  uint64_t v19 = *(void *)(result + 32);
  int v20 = *(_DWORD *)(result + 24);
  uint64_t v21 = *(void *)(result + 176);
  uint64_t v22 = *(void *)(result + 64);
  uint64_t v23 = *(void *)(result + 72);
  uint64_t v24 = *(void *)(result + 80);
  uint64_t v25 = *(void *)(result + 88);
  uint64_t v26 = *(void *)(result + 112);
  uint64_t v27 = *(void *)(result + 120);
  int v28 = *(_DWORD *)(result + 188);
  uint64_t v29 = *(void *)(result + 152) - 4;
  uint64_t v30 = *(void *)(result + 144) - 1;
  int v111 = *(_DWORD *)(result + 240);
  unint64_t v31 = v19
      + ((*(_DWORD *)(result + 260) - 1) * v20)
      + 4 * (3 * *(_DWORD *)(result + 256))
      - 6;
  int v112 = a4;
  while (1)
  {
    if ((uint64_t)a3 >= v23)
    {
      if ((uint64_t)a3 <= v25)
      {
        uint64_t v40 = (a3 >> 22) & 0x3C0;
        unsigned int v41 = 0x3FFFFFFF;
        HIDWORD(v42) = HIDWORD(a3);
      }
      else
      {
        uint64_t v36 = *(void *)(result + 216);
        uint64_t v37 = *(void *)(result + 224) + v25;
        uint64_t v38 = v37 - a3 + (v36 >> 1);
        if (v38 < 1) {
          goto LABEL_34;
        }
        if (v38 >= v36) {
          LODWORD(v39) = 0x3FFFFFFF;
        }
        else {
          unint64_t v39 = (unint64_t)(*(void *)(result + 232) * v38) >> 32;
        }
        unsigned int v41 = v28 | v39;
        uint64_t v42 = v37 - 0x1000000;
        uint64_t v40 = 448;
      }
    }
    else
    {
      uint64_t v32 = *(void *)(result + 216);
      uint64_t v33 = v23 - *(void *)(result + 224);
      uint64_t v34 = a3 - v33 + (v32 >> 1);
      if (v34 < 1) {
        goto LABEL_34;
      }
      if (v34 >= v32) {
        LODWORD(v35) = 0x3FFFFFFF;
      }
      else {
        unint64_t v35 = (unint64_t)(*(void *)(result + 232) * v34) >> 32;
      }
      unsigned int v41 = v28 | v35;
      uint64_t v42 = v33 + 0x1000000;
      uint64_t v40 = 512;
    }
    if (a2 >= v22) {
      break;
    }
    uint64_t v43 = *(void *)(result + 192);
    uint64_t v44 = v22 - *(void *)(result + 200);
    uint64_t v45 = a2 - v44 + (v43 >> 1);
    if (v45 >= 1)
    {
      if (v45 < v43) {
        unsigned int v41 = ((v41 >> 15) * (((unint64_t)(*(void *)(result + 208) * v45) >> 32) >> 15)) | v28;
      }
      uint64_t v46 = v44 + 0x1000000;
      uint64_t v47 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v26;
    a3 += v27;
    v29 += 4;
    *(unsigned char *)++uint64_t v30 = 0;
LABEL_35:
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v24)
  {
    uint64_t v47 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v46 = a2;
    goto LABEL_26;
  }
  uint64_t v48 = *(void *)(result + 192);
  uint64_t v49 = *(void *)(result + 200) + v24;
  uint64_t v50 = v49 - a2 + (v48 >> 1);
  if (v50 < 1) {
    goto LABEL_34;
  }
  if (v50 < v48) {
    unsigned int v41 = ((v41 >> 15) * (((unint64_t)(*(void *)(result + 208) * v50) >> 32) >> 15)) | v28;
  }
  uint64_t v46 = v49 - 0x1000000;
  uint64_t v47 = 28;
LABEL_26:
  if (v41 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v51 = v46 >> 32;
  uint64_t v52 = v19 + SHIDWORD(v42) * (uint64_t)v20;
  unint64_t v53 = v52 + 6 * (int)v51;
  unint64_t v54 = *(void *)(result + 32);
  if (v31 >= v53) {
    unint64_t v55 = v52 + 6 * (int)v51;
  }
  else {
    unint64_t v55 = v31;
  }
  if (v55 < v54) {
    unint64_t v55 = *(void *)(result + 32);
  }
  _D7.i32[0] = *(_DWORD *)v55;
  _H6 = *(_WORD *)(v55 + 4);
  if (!v21) {
    goto LABEL_37;
  }
  unsigned int v57 = *(_DWORD *)(v21 + (v47 | v40));
LABEL_38:
  int v59 = v57 & 0xF;
  int v60 = HIBYTE(v57) & 3;
  if (v59 == 1)
  {
    unint64_t v85 = v53 + SBYTE1(v57) * (uint64_t)v20;
    if (v31 < v85) {
      unint64_t v85 = v31;
    }
    if (v85 < v54) {
      unint64_t v85 = v54;
    }
    _H16 = *(_WORD *)(v85 + 4);
    float v87 = &interpolate_rgbaf16[4 * v60];
    goto LABEL_76;
  }
  if (v59 == 2)
  {
    unint64_t v85 = v53 + 6 * SBYTE2(v57);
    if (v31 < v85) {
      unint64_t v85 = v31;
    }
    if (v85 < v54) {
      unint64_t v85 = v54;
    }
    _H16 = *(_WORD *)(v85 + 4);
    float v87 = &interpolate_rgbaf16[4 * ((v57 >> 28) & 3)];
LABEL_76:
    _D17.i16[0] = v87[3];
    __asm { FCVT            S17, H17 }
    float32x4_t v88 = vcvtq_f32_f16(_D7);
    v13.i32[0] = *(_DWORD *)v85;
    float16x4_t v13 = (float16x4_t)vcvtq_f32_f16(v13).u64[0];
    *(float32x2_t *)v88.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v88.f32, *(float32x2_t *)v88.f32, _D17, 0), (float32x2_t)v13, _D17.f32[0]);
    _D7 = vcvt_f16_f32(v88);
    __asm
    {
      FCVT            S6, H6
      FCVT            S16, H16
    }
    _S6 = (float)(_S6 - (float)(_S6 * _D17.f32[0])) + (float)(_S16 * _D17.f32[0]);
    __asm { FCVT            H6, S6 }
    _S16 = (float)(1.0 - _D17.f32[0]) + _D17.f32[0];
    goto LABEL_77;
  }
  if (v59 != 3)
  {
LABEL_37:
    _H16 = COERCE_UNSIGNED_INT(1.0);
    goto LABEL_78;
  }
  unint64_t v61 = v53 + 6 * SBYTE2(v57);
  if (v31 < v61) {
    unint64_t v61 = v31;
  }
  if (v61 < v54) {
    unint64_t v61 = v54;
  }
  _H16 = *(_WORD *)(v61 + 4);
  unint64_t v63 = v53 + SBYTE1(v57) * (uint64_t)v20;
  if (v31 >= v63) {
    unint64_t v64 = v53 + SBYTE1(v57) * (uint64_t)v20;
  }
  else {
    unint64_t v64 = v31;
  }
  if (v64 < v54) {
    unint64_t v64 = v54;
  }
  _H17 = *(_WORD *)(v64 + 4);
  unint64_t v66 = v63 + 6 * SBYTE2(v57);
  if (v31 < v66) {
    unint64_t v66 = v31;
  }
  if (v66 < v54) {
    unint64_t v66 = v54;
  }
  _H18 = *(_WORD *)(v66 + 4);
  _H19 = interpolate_rgbaf16[4 * v60 + 3];
  __asm { FCVT            S19, H19 }
  _H20 = interpolate_rgbaf16[4 * ((v57 >> 28) & 3) + 3];
  __asm { FCVT            S20, H20 }
  float32x4_t v73 = vcvtq_f32_f16(_D7);
  __asm
  {
    FCVT            S6, H6
    FCVT            S16, H16
  }
  float v76 = (float)(_S6 - (float)(_S6 * _D20.f32[0])) + (float)(_S16 * _D20.f32[0]);
  __asm
  {
    FCVT            S16, H17
    FCVT            S17, H18
  }
  float v79 = (float)(_S16 - (float)(_S16 * _D20.f32[0])) + (float)(_S17 * _D20.f32[0]);
  float v80 = (float)(1.0 - _D20.f32[0]) + _D20.f32[0];
  if (v80 < 1.0) {
    float v81 = (float)(1.0 - _D20.f32[0]) + _D20.f32[0];
  }
  else {
    float v81 = 1.0;
  }
  if (v80 > 1.0) {
    float v80 = 1.0;
  }
  if (v81 < 0.0) {
    float v80 = 0.0;
  }
  v13.i32[0] = *(_DWORD *)v61;
  v16.i32[0] = *(_DWORD *)v64;
  v17.i32[0] = *(_DWORD *)v66;
  *(float32x2_t *)v73.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v73.f32, *(float32x2_t *)v73.f32, _D20, 0), (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(v13), _D20.f32[0]);
  float32x2_t v82 = (float32x2_t)vcvtq_f32_f16(v16).u64[0];
  float16x4_t v16 = (float16x4_t)vcvtq_f32_f16(v17).u64[0];
  float16x4_t v13 = (float16x4_t)vmla_n_f32(vmls_lane_f32(v82, v82, _D20, 0), (float32x2_t)v16, _D20.f32[0]);
  *(float32x2_t *)v73.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v73.f32, *(float32x2_t *)v73.f32, _D19, 0), (float32x2_t)v13, _D19.f32[0]);
  _D7 = vcvt_f16_f32(v73);
  _S6 = (float)(v76 - (float)(v76 * _D19.f32[0])) + (float)(v79 * _D19.f32[0]);
  __asm { FCVT            H6, S6 }
  _S16 = (float)(v80 - (float)(v80 * _D19.f32[0])) + (float)(v80 * _D19.f32[0]);
  if (_S16 >= 1.0) {
    _S16 = 1.0;
  }
  if (_S16 <= 0.0) {
    _S16 = 0.0;
  }
LABEL_77:
  __asm { FCVT            H16, S16 }
LABEL_78:
  __asm { FCVT            S17, H7 }
  _H7 = _D7.i16[1];
  __asm
  {
    FCVT            S7, H7
    FCVT            S6, H6
  }
  _S6 = (float)((float)(_S7 * 0.59) + (float)(_S17 * 0.3)) + (float)(_S6 * 0.11);
  __asm { FCVT            H6, S6 }
  *(_WORD *)(v29 + 4) = LOWORD(_S6);
  *(_WORD *)(v29 + 6) = _H16;
  *(unsigned char *)++uint64_t v30 = v41 >> 22;
  if (--a4)
  {
    float v97 = (_WORD *)(v29 + 10);
    a2 += v26;
    uint64_t v98 = v24 - a2;
    a3 += v27;
    uint64_t v99 = v25 - a3;
    while (1)
    {
      uint64_t v29 = (uint64_t)(v97 - 3);
      if (((v99 | v98 | (a3 - v23) | (a2 - v22)) & 0x8000000000000000) != 0) {
        goto LABEL_35;
      }
      uint64_t v100 = v19 + SHIDWORD(a3) * (uint64_t)v20;
      unint64_t v53 = v100 + 6 * SHIDWORD(a2);
      unint64_t v54 = *(void *)(result + 32);
      if (v31 >= v53) {
        unint64_t v101 = v100 + 6 * SHIDWORD(a2);
      }
      else {
        unint64_t v101 = v31;
      }
      if (v101 < v54) {
        unint64_t v101 = *(void *)(result + 32);
      }
      _D7.i32[0] = *(_DWORD *)v101;
      _H6 = *(_WORD *)(v101 + 4);
      if (v21)
      {
        unsigned int v57 = *(_DWORD *)(v21 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        unsigned int v102 = v57 & 0xF;
        if ((v57 & 0xF) != 0)
        {
          float v108 = *(unsigned int **)(result + 264);
          unsigned int v109 = *v108;
          if (a4 + 1 != v112 && a4 != 1 && v111 != 1 && v109 == 3 && v102 < 3) {
            v57 |= 3u;
          }
          unsigned int v41 = -1;
          if (v109 < v102) {
            *float v108 = v102;
          }
          goto LABEL_38;
        }
      }
      __asm { FCVT            S16, H7 }
      _H7 = HIWORD(*(_DWORD *)v101);
      __asm
      {
        FCVT            S7, H7
        FCVT            S6, H6
      }
      _S6 = (float)((float)(_S7 * 0.59) + (float)(_S16 * 0.3)) + (float)(_S6 * 0.11);
      __asm { FCVT            H6, S6 }
      *(v97 - 1) = LOWORD(_S6);
      *float v97 = COERCE_UNSIGNED_INT(1.0);
      *(unsigned char *)++uint64_t v30 = -1;
      v97 += 2;
      a2 += v26;
      v98 -= v26;
      a3 += v27;
      v99 -= v27;
      if (!--a4) {
        return result;
      }
    }
  }
  return result;
}

void Wf16_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_RGBAF", 13513, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

uint64_t Wf16_sample_RGBAf_inner(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v12 = *(_DWORD *)(result + 24);
  uint64_t v13 = *(void *)(result + 176);
  uint64_t v14 = *(void *)(result + 64);
  uint64_t v15 = *(void *)(result + 72);
  uint64_t v16 = *(void *)(result + 80);
  uint64_t v17 = *(void *)(result + 88);
  uint64_t v18 = *(void *)(result + 112);
  uint64_t v19 = *(void *)(result + 120);
  int v131 = *(_DWORD *)(result + 188);
  uint64_t v20 = *(void *)(result + 152) - 4;
  uint64_t v21 = *(void *)(result + 144) - 1;
  uint64_t v22 = *(void *)(result + 32);
  uint64_t v23 = *(void *)(result + 40);
  int v129 = *(_DWORD *)(result + 240);
  unint64_t v24 = v22
      + ((*(_DWORD *)(result + 260) - 1) * v12)
      + 2 * (4 * *(_DWORD *)(result + 256))
      - 8;
  int v25 = a4;
  while (1)
  {
    if ((uint64_t)a3 >= v15)
    {
      if ((uint64_t)a3 <= v17)
      {
        uint64_t v34 = (a3 >> 22) & 0x3C0;
        unsigned int v35 = 0x3FFFFFFF;
        HIDWORD(v36) = HIDWORD(a3);
      }
      else
      {
        uint64_t v30 = *(void *)(result + 216);
        uint64_t v31 = *(void *)(result + 224) + v17;
        uint64_t v32 = v31 - a3 + (v30 >> 1);
        if (v32 < 1) {
          goto LABEL_37;
        }
        if (v32 >= v30) {
          LODWORD(v33) = 0x3FFFFFFF;
        }
        else {
          unint64_t v33 = (unint64_t)(*(void *)(result + 232) * v32) >> 32;
        }
        unsigned int v35 = v131 | v33;
        uint64_t v36 = v31 - 0x1000000;
        uint64_t v34 = 448;
      }
    }
    else
    {
      uint64_t v26 = *(void *)(result + 216);
      uint64_t v27 = v15 - *(void *)(result + 224);
      uint64_t v28 = a3 - v27 + (v26 >> 1);
      if (v28 < 1) {
        goto LABEL_37;
      }
      if (v28 >= v26) {
        LODWORD(v29) = 0x3FFFFFFF;
      }
      else {
        unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
      }
      unsigned int v35 = v131 | v29;
      uint64_t v36 = v27 + 0x1000000;
      uint64_t v34 = 512;
    }
    if (a2 >= v14) {
      break;
    }
    uint64_t v37 = *(void *)(result + 192);
    uint64_t v38 = v14 - *(void *)(result + 200);
    uint64_t v39 = a2 - v38 + (v37 >> 1);
    if (v39 >= 1)
    {
      if (v39 < v37) {
        unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v131;
      }
      uint64_t v40 = v38 + 0x1000000;
      uint64_t v41 = 32;
      goto LABEL_26;
    }
LABEL_37:
    --v25;
    a2 += v18;
    a3 += v19;
    v20 += 4;
    *(unsigned char *)++uint64_t v21 = 0;
LABEL_38:
    if (!v25) {
      return result;
    }
  }
  if (a2 <= v16)
  {
    uint64_t v41 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v40 = a2;
    goto LABEL_26;
  }
  uint64_t v42 = *(void *)(result + 192);
  uint64_t v43 = *(void *)(result + 200) + v16;
  uint64_t v44 = v43 - a2 + (v42 >> 1);
  if (v44 < 1) {
    goto LABEL_37;
  }
  if (v44 < v42) {
    unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v44) >> 32) >> 15)) | v131;
  }
  uint64_t v40 = v43 - 0x1000000;
  uint64_t v41 = 28;
LABEL_26:
  if (v35 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v45 = v22 + SHIDWORD(v36) * (uint64_t)v12;
  unint64_t v46 = v45 + 8 * (v40 >> 32);
  unint64_t v47 = *(void *)(result + 32);
  if (v24 >= v46) {
    unint64_t v48 = v45 + 8 * (v40 >> 32);
  }
  else {
    unint64_t v48 = v24;
  }
  if (v48 >= v47) {
    unint64_t v49 = v48;
  }
  else {
    unint64_t v49 = *(void *)(result + 32);
  }
  if (v23)
  {
    __asm { FCMP            H7, #0 }
    if (_ZF || !_CF) {
      _H7 = COERCE_SHORT_FLOAT(0);
    }
  }
  else
  {
    LOWORD(_H7) = COERCE_UNSIGNED_INT(1.0);
  }
  _D17.i32[0] = *(_DWORD *)v49;
  _H16 = *(_WORD *)(v49 + 4);
  if (!v13) {
    goto LABEL_120;
  }
  unsigned int v55 = *(_DWORD *)(v13 + (v41 | v34));
LABEL_43:
  int v56 = v55 & 0xF;
  int v57 = HIBYTE(v55) & 3;
  switch(v56)
  {
    case 1:
      unint64_t v71 = v46 + SBYTE1(v55) * (uint64_t)v12;
      if (v24 < v71) {
        unint64_t v71 = v24;
      }
      if (v71 >= v47) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v47;
      }
      v6.i32[0] = *(_DWORD *)v72;
      _H18 = *(_WORD *)(v72 + 4);
      LOWORD(_H19) = COERCE_UNSIGNED_INT(1.0);
      if (v23)
      {
        __asm { FCMP            H19, #0 }
        if (_ZF || !_CF) {
          _H19 = COERCE_SHORT_FLOAT(0);
        }
      }
      unint64_t v75 = &interpolate_rgbaf16[4 * v57];
      goto LABEL_88;
    case 2:
      unint64_t v76 = v46 + ((uint64_t)((unint64_t)HIWORD(v55) << 56) >> 53);
      if (v24 < v76) {
        unint64_t v76 = v24;
      }
      if (v76 >= v47) {
        unint64_t v77 = v76;
      }
      else {
        unint64_t v77 = v47;
      }
      v6.i32[0] = *(_DWORD *)v77;
      _H18 = *(_WORD *)(v77 + 4);
      LOWORD(_H19) = COERCE_UNSIGNED_INT(1.0);
      if (v23)
      {
        __asm { FCMP            H19, #0 }
        if (_ZF || !_CF) {
          _H19 = COERCE_SHORT_FLOAT(0);
        }
      }
      unint64_t v75 = &interpolate_rgbaf16[4 * ((v55 >> 28) & 3)];
LABEL_88:
      _D21.i16[0] = v75[3];
      __asm { FCVT            S21, H21 }
      float32x4_t v78 = vcvtq_f32_f16(_D17);
      float16x4_t v6 = (float16x4_t)vcvtq_f32_f16(v6).u64[0];
      *(float32x2_t *)v78.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v78.f32, *(float32x2_t *)v78.f32, _D21, 0), (float32x2_t)v6, _D21.f32[0]);
      _D17 = vcvt_f16_f32(v78);
      __asm
      {
        FCVT            S16, H16
        FCVT            S18, H18
      }
      _S16 = (float)(_S16 - (float)(_S16 * _D21.f32[0])) + (float)(_S18 * _D21.f32[0]);
      __asm
      {
        FCVT            H16, S16
        FCVT            S7, H7
        FCVT            S18, H19
      }
      _S7 = (float)(_S7 - (float)(_S7 * _D21.f32[0])) + (float)(_S18 * _D21.f32[0]);
      goto LABEL_119;
    case 3:
      uint64_t v58 = SBYTE1(v55) * (uint64_t)v12;
      uint64_t v59 = 8 * SBYTE2(v55);
      unint64_t v60 = v46 + ((uint64_t)((unint64_t)HIWORD(v55) << 56) >> 53);
      if (v24 < v60) {
        unint64_t v60 = v24;
      }
      if (v60 < v47) {
        unint64_t v60 = v47;
      }
      v5.i32[0] = *(_DWORD *)v60;
      _H18 = *(_WORD *)(v60 + 4);
      if (v23)
      {
        __asm { FCMP            H20, #0 }
        if (!_ZF && _CF) {
          _H21 = _H20;
        }
        else {
          _H21 = COERCE_SHORT_FLOAT(0);
        }
        unint64_t v64 = v46 + v58;
        if (v24 >= v46 + v58) {
          unint64_t v65 = v46 + v58;
        }
        else {
          unint64_t v65 = v24;
        }
        if (v65 >= v47) {
          unint64_t v66 = v65;
        }
        else {
          unint64_t v66 = v47;
        }
        __asm { FCMP            H20, #0 }
        if (_ZF || !_CF) {
          _H20 = COERCE_SHORT_FLOAT(0);
        }
        unint64_t v68 = v64 + v59;
        if (v24 < v68) {
          unint64_t v68 = v24;
        }
        if (v68 >= v47) {
          unint64_t v69 = v68;
        }
        else {
          unint64_t v69 = v47;
        }
        __asm { FCMP            H22, #0 }
        if (_ZF || !_CF) {
          _H22 = COERCE_SHORT_FLOAT(0);
        }
      }
      else
      {
        unint64_t v85 = v46 + v58;
        if (v24 >= v46 + v58) {
          unint64_t v86 = v46 + v58;
        }
        else {
          unint64_t v86 = v24;
        }
        if (v86 >= v47) {
          unint64_t v66 = v86;
        }
        else {
          unint64_t v66 = v47;
        }
        unint64_t v87 = v85 + v59;
        if (v24 < v87) {
          unint64_t v87 = v24;
        }
        if (v87 >= v47) {
          unint64_t v69 = v87;
        }
        else {
          unint64_t v69 = v47;
        }
        LOWORD(_H20) = COERCE_UNSIGNED_INT(1.0);
        LOWORD(_H21) = COERCE_UNSIGNED_INT(1.0);
        LOWORD(_H22) = COERCE_UNSIGNED_INT(1.0);
      }
      _H23 = *(_WORD *)(v66 + 4);
      v8.i32[0] = *(_DWORD *)v66;
      v9.i32[0] = *(_DWORD *)v69;
      _H26 = *(_WORD *)(v69 + 4);
      _H27 = interpolate_rgbaf16[4 * v57 + 3];
      __asm { FCVT            S27, H27 }
      _H28 = interpolate_rgbaf16[4 * ((v55 >> 28) & 3) + 3];
      __asm { FCVT            S28, H28 }
      float32x4_t v92 = vcvtq_f32_f16(_D17);
      float16x4_t v5 = (float16x4_t)vcvtq_f32_f16(v5).u64[0];
      float32x2_t v93 = (float32x2_t)vcvtq_f32_f16(v8).u64[0];
      float16x4_t v9 = (float16x4_t)vcvtq_f32_f16(v9).u64[0];
      __asm
      {
        FCVT            S16, H16
        FCVT            S18, H18
      }
      float v96 = (float)(_S16 - (float)(_S16 * _D28.f32[0])) + (float)(_S18 * _D28.f32[0]);
      __asm
      {
        FCVT            S18, H23
        FCVT            S23, H26
      }
      float v99 = (float)(_S18 - (float)(_S18 * _D28.f32[0])) + (float)(_S23 * _D28.f32[0]);
      __asm
      {
        FCVT            S7, H7
        FCVT            S21, H21
      }
      float v102 = (float)(_S7 - (float)(_S7 * _D28.f32[0])) + (float)(_S21 * _D28.f32[0]);
      if (v102 < 1.0) {
        float v103 = v102;
      }
      else {
        float v103 = 1.0;
      }
      if (v102 > 1.0) {
        float v102 = 1.0;
      }
      if (v103 < 0.0) {
        float v102 = 0.0;
      }
      __asm
      {
        FCVT            S20, H20
        FCVT            S21, H22
      }
      float v106 = (float)(_S20 - (float)(_S20 * _D28.f32[0])) + (float)(_S21 * _D28.f32[0]);
      if (v106 < 1.0) {
        float v107 = v106;
      }
      else {
        float v107 = 1.0;
      }
      if (v106 > 1.0) {
        float v106 = 1.0;
      }
      if (v107 < 0.0) {
        float v106 = 0.0;
      }
      *(float32x2_t *)v92.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v92.f32, *(float32x2_t *)v92.f32, _D28, 0), (float32x2_t)v5, _D28.f32[0]);
      float16x4_t v8 = (float16x4_t)vmla_n_f32(vmls_lane_f32(v93, v93, _D28, 0), (float32x2_t)v9, _D28.f32[0]);
      *(float32x2_t *)v92.f32 = vmla_n_f32(vmls_lane_f32(*(float32x2_t *)v92.f32, *(float32x2_t *)v92.f32, _D27, 0), (float32x2_t)v8, _D27.f32[0]);
      _D17 = vcvt_f16_f32(v92);
      _S16 = (float)(v96 - (float)(v96 * _D27.f32[0])) + (float)(v99 * _D27.f32[0]);
      __asm { FCVT            H16, S16 }
      _S7 = (float)(v102 - (float)(v102 * _D27.f32[0])) + (float)(v106 * _D27.f32[0]);
      if (_S7 >= 1.0) {
        _S7 = 1.0;
      }
      if (_S7 <= 0.0) {
        _S7 = 0.0;
      }
LABEL_119:
      __asm { FCVT            H7, S7 }
      break;
  }
LABEL_120:
  __asm { FCVT            S18, H17 }
  _H17 = _D17.i16[1];
  __asm
  {
    FCVT            S17, H17
    FCVT            S16, H16
  }
  _S16 = (float)((float)(_S17 * 0.59) + (float)(_S18 * 0.3)) + (float)(_S16 * 0.11);
  __asm { FCVT            H16, S16 }
  *(_WORD *)(v20 + 4) = LOWORD(_S16);
  *(short float *)(v20 + 6) = _H7;
  *(unsigned char *)++uint64_t v21 = v35 >> 22;
  if (--v25)
  {
    uint64_t v114 = (short float *)(v20 + 10);
    a2 += v18;
    uint64_t v115 = v16 - a2;
    a3 += v19;
    uint64_t v116 = v17 - a3;
    while (1)
    {
      uint64_t v20 = (uint64_t)(v114 - 3);
      if (((v116 | v115 | (a3 - v15) | (a2 - v14)) & 0x8000000000000000) != 0) {
        goto LABEL_38;
      }
      uint64_t v117 = v22 + SHIDWORD(a3) * (uint64_t)v12;
      unint64_t v46 = v117 + 8 * (a2 >> 32);
      unint64_t v47 = *(void *)(result + 32);
      if (v24 >= v46) {
        unint64_t v118 = v117 + 8 * (a2 >> 32);
      }
      else {
        unint64_t v118 = v24;
      }
      if (v118 >= v47) {
        unint64_t v119 = v118;
      }
      else {
        unint64_t v119 = *(void *)(result + 32);
      }
      if (v23)
      {
        __asm { FCMP            H7, #0 }
        if (_ZF || !_CF) {
          _H7 = COERCE_SHORT_FLOAT(0);
        }
      }
      else
      {
        LOWORD(_H7) = COERCE_UNSIGNED_INT(1.0);
      }
      _D17.i32[0] = *(_DWORD *)v119;
      _H16 = *(_WORD *)(v119 + 4);
      if (v13)
      {
        unsigned int v55 = *(_DWORD *)(v13 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        unsigned int v120 = v55 & 0xF;
        if ((v55 & 0xF) != 0)
        {
          unint64_t v126 = *(unsigned int **)(result + 264);
          unsigned int v127 = *v126;
          if (v25 + 1 != a4 && v25 != 1 && v129 != 1)
          {
            _CF = v127 != 3 || v120 >= 3;
            if (!_CF) {
              v55 |= 3u;
            }
          }
          unsigned int v35 = -1;
          if (v127 < v120) {
            *unint64_t v126 = v120;
          }
          goto LABEL_43;
        }
      }
      __asm { FCVT            S18, H17 }
      _H17 = _D17.i16[1];
      __asm
      {
        FCVT            S17, H17
        FCVT            S16, H16
      }
      _S16 = (float)((float)(_S17 * 0.59) + (float)(_S18 * 0.3)) + (float)(_S16 * 0.11);
      __asm { FCVT            H16, S16 }
      *(v114 - 1) = *(short float *)&_S16;
      *uint64_t v114 = _H7;
      *(unsigned char *)++uint64_t v21 = -1;
      v114 += 2;
      a2 += v18;
      v115 -= v18;
      a3 += v19;
      v116 -= v19;
      if (!--v25) {
        return result;
      }
    }
  }
  return result;
}

void Wf16_sample_CMYKF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_CMYKF", 13521, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void Wf16_sample_CMYKf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("Wf16_sample_CMYKf", 13525, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

_DWORD *Wf16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  float16x4_t v9 = *(float **)(*(void *)a1 + 64);
  _S10 = *v9;
  float v10 = v9[1];
  if (!a2 || a3 <= 3)
  {
    a2 = malloc_type_malloc(0x34uLL, 0x705560E0uLL);
    if (!a2) {
      return a2;
    }
  }
  if (_S10 <= a6) {
    _S0 = a6;
  }
  else {
    _S0 = _S10;
  }
  if (v10 < a6) {
    _S0 = v10;
  }
  if (a5) {
    int v13 = a4;
  }
  else {
    int v13 = 0;
  }
  switch(v13)
  {
    case 1:
      float v14 = *a5;
      goto LABEL_18;
    case 4:
      float v14 = (float)(v10 - (float)((float)((float)(*a5 * v9[2]) + (float)(a5[1] * v9[3])) + (float)(a5[2] * v9[4])))
          - a5[3];
      goto LABEL_18;
    case 3:
      float v14 = (float)((float)(*a5 * v9[2]) + (float)(a5[1] * v9[3])) + (float)(a5[2] * v9[4]);
LABEL_18:
      _S10 = _S0 * v14;
      break;
  }
  *(_OWORD *)a2 = xmmword_1850CDB00;
  a2[6] = 0;
  *((void *)a2 + 2) = 1;
  __asm { FCVT            H1, S10 }
  *((_WORD *)a2 + 24) = _H1;
  __asm { FCVT            H0, S0 }
  *((_WORD *)a2 + 25) = _H0;
  uint64_t v21 = (char *)a2 + 50;
  if (!_NF) {
    uint64_t v21 = 0;
  }
  *((void *)a2 + 4) = a2 + 12;
  *((void *)a2 + 5) = v21;
  return a2;
}

uint64_t Wf16_mark(uint64_t a1, __n128 a2)
{
  return Wf16_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

uint64_t Wf16_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v1019 = *MEMORY[0x1E4F143B8];
  float16x4_t v9 = *(char **)(v4 + 96);
  uint64_t v10 = *(void *)(v4 + 48);
  int v11 = *(_DWORD *)(v3 + 16 * *(_DWORD *)v4 + 8 * (v9 == 0) + 4 * (v10 == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v4;
  unint64_t v14 = *(unsigned int *)(v4 + 4);
  unsigned int v15 = v14 - 1;
  if ((int)v14 < 1) {
    return 0;
  }
  int v16 = *(_DWORD *)(v4 + 8);
  uint64_t v17 = (v16 - 1);
  if (v16 < 1) {
    return 0;
  }
  uint64_t v18 = *(uint16x4_t **)(v4 + 136);
  if ((*(_DWORD *)v4 & 0xFF0000) != 0x50000 && v18)
  {
    int v19 = *(_DWORD *)(v4 + 128);
    if ((v19 | 8) == 8)
    {
      if ((*(_DWORD *)v4 & 0xFF00) == 0x400) {
        Wf16_mark_constmask(v4, v11, _Q0, v6, v7);
      }
      else {
        Wf16_mark_pixelmask(v4, v11, _Q0, v6, v7);
      }
    }
    else
    {
      int v28 = *(_DWORD *)(v4 + 112);
      int v29 = *(_DWORD *)(v4 + 116);
      unsigned int v30 = (v28 + 15) & 0xFFFFFFF0;
      size_t v31 = v30 * v29;
      if ((int)v31 <= 4096)
      {
        unint64_t v33 = v1018;
      }
      else
      {
        uint64_t v32 = malloc_type_malloc(v31, 0x89490681uLL);
        if (!v32) {
          return 1;
        }
        unint64_t v33 = v32;
        uint64_t v18 = *(uint16x4_t **)(v13 + 136);
        int v19 = *(_DWORD *)(v13 + 128);
      }
      CGSConvertBitsToMask(v18, *(_DWORD *)(v13 + 124), v33, v30, v28, v29, v19);
      long long v58 = *(_OWORD *)(v13 + 112);
      long long v1014 = *(_OWORD *)(v13 + 96);
      long long v1015 = v58;
      long long v59 = *(_OWORD *)(v13 + 144);
      long long v1016 = *(_OWORD *)(v13 + 128);
      long long v1017 = v59;
      long long v60 = *(_OWORD *)(v13 + 48);
      long long v1010 = *(_OWORD *)(v13 + 32);
      long long v1011 = v60;
      long long v61 = *(_OWORD *)(v13 + 80);
      long long v1012 = *(_OWORD *)(v13 + 64);
      long long v1013 = v61;
      __n128 v62 = *(__n128 *)v13;
      long long v63 = *(_OWORD *)(v13 + 16);
      *(_OWORD *)v1008 = *(_OWORD *)v13;
      long long v1009 = v63;
      HIDWORD(v1015) = (v28 + 15) & 0xFFFFFFF0;
      *((void *)&v1016 + 1) = v33;
      if (BYTE1(v1008[0]) << 8 == 1024) {
        Wf16_mark_constmask((uint64_t)v1008, v11, v62, *(double *)&v63, v57);
      }
      else {
        Wf16_mark_pixelmask((uint64_t)v1008, v11, v62, *(double *)&v63, v57);
      }
      if (v33 != (unsigned char *)v1018)
      {
        unint64_t v64 = v33;
        goto LABEL_1375;
      }
    }
    return 1;
  }
  int v20 = *(_DWORD *)v4 & 0xFF00;
  int v967 = *(_DWORD *)(v3 + 16 * *(_DWORD *)v4 + 8 * (v9 == 0) + 4 * (v10 == 0));
  uint64_t v968 = v4;
  if (v20 != 1024)
  {
    v1018[0] = *(_DWORD *)(v4 + 4);
    v1008[0] = v16;
    uint64_t v22 = *(_WORD **)(v4 + 88);
    uint64_t v24 = *(int *)(v4 + 12);
    uint64_t v23 = *(int *)(v4 + 16);
    unint64_t v25 = (unint64_t)*(int *)(v4 + 28) >> 1;
    if (v10)
    {
      unint64_t v26 = (unint64_t)*(int *)(v4 + 32) >> 1;
      v973 = (char *)(v10 + 2 * (v24 + v26 * v23));
      uint64_t v27 = 0xFFFFFFFFLL;
    }
    else
    {
      v973 = 0;
      unint64_t v26 = 0;
      uint64_t v27 = 0;
    }
    unint64_t v972 = *(void *)(v4 + 40) + 2 * (v24 + v23 * v25);
    int v44 = *(_DWORD *)(v4 + 56);
    int v45 = *(_DWORD *)(v4 + 60);
    unint64_t v991 = (unint64_t)*(int *)(v4 + 76) >> 1;
    if (v20 == 256)
    {
      if (v9)
      {
        unint64_t v993 = (unint64_t)*(int *)(v4 + 80) >> 1;
        v9 += 2 * v44 + 2 * v993 * v45;
        uint64_t v46 = 0xFFFFFFFFLL;
      }
      else
      {
        unint64_t v993 = 0;
        uint64_t v46 = 0;
      }
      v22 += v44 + v45 * v991;
      if (v991 == v25 && (uint64_t)(v972 - (void)v22) >= 1)
      {
        if (v14 >= (v972 - (unint64_t)v22) >> 1)
        {
          v972 += 2 * v15;
          v22 += v15;
          v973 += 2 * (v27 & v15);
          int v66 = -1;
          unint64_t v991 = (unint64_t)*(int *)(v4 + 28) >> 1;
          v9 += 2 * (v46 & v15);
          goto LABEL_49;
        }
        unint64_t v65 = &v22[v25 * v17];
        if (v972 <= (unint64_t)&v65[v15])
        {
          v972 += 2 * v25 * v17;
          unint64_t v25 = -(uint64_t)v25;
          v973 += 2 * v26 * v17;
          unint64_t v26 = -(uint64_t)v26;
          v9 += 2 * v993 * v17;
          v27 &= 1u;
          unint64_t v993 = -(uint64_t)v993;
          v46 &= 1u;
          int v66 = 1;
          uint64_t v22 = v65;
          unint64_t v991 = v25;
          goto LABEL_49;
        }
      }
      v27 &= 1u;
      v46 &= 1u;
      int v66 = 1;
LABEL_49:
      int v969 = *(_DWORD *)(v4 + 56);
      int v970 = *(_DWORD *)(v4 + 60);
      if (v18)
      {
        uint64_t v1004 = v46;
        uint64_t v1006 = v27;
        v992 = 0;
        v990 = 0;
        unint64_t v67 = -1;
        unint64_t v47 = v991;
        int v975 = v993;
        goto LABEL_54;
      }
      unint64_t v72 = v66 * (int)v14;
      unint64_t v1002 = v26 - (int)v27 * (int)v14;
      unint64_t v67 = -1;
      unint64_t v73 = v993;
      int v974 = v66;
      int v975 = v993;
      unint64_t v74 = v991;
      unint64_t v47 = v991;
LABEL_62:
      uint64_t v976 = 0;
      uint64_t v977 = (uint64_t)v22;
      v990 = 0;
      unint64_t v991 = v74 - v72;
      v992 = 0;
      unint64_t v993 = v73 - (int)v46 * (int)v14;
      uint64_t v996 = (uint64_t)v9;
      uint64_t v971 = (uint64_t)v9;
      float32x4_t v78 = (_WORD *)v972;
      unint64_t v71 = v973;
      goto LABEL_66;
    }
    unint64_t v47 = *(unsigned int *)(v4 + 64);
    int v975 = *(_DWORD *)(v4 + 68);
    if (v9)
    {
      unint64_t v993 = (unint64_t)*(int *)(v4 + 80) >> 1;
      uint64_t v46 = 1;
    }
    else
    {
      unint64_t v993 = 0;
      uint64_t v46 = 0;
    }
    v990 = &v22[v991 * v975];
    v27 &= 1u;
    if (v18)
    {
      int v969 = *(_DWORD *)(v4 + 56);
      int v970 = *(_DWORD *)(v4 + 60);
      uint64_t v1004 = v46;
      uint64_t v1006 = v27;
      int v66 = 1;
      v992 = *(_WORD **)(v4 + 88);
      unint64_t v67 = (unint64_t)v992;
LABEL_54:
      int v974 = v66;
      unint64_t v978 = v25;
      shape_enum_clip_alloc(v3, v4, (int *)v18, v66, v25, 1, *(_DWORD *)(v4 + 104), *(_DWORD *)(v4 + 108), v14, v16);
      uint64_t v69 = v68;
      uint64_t v70 = v9;
      uint64_t v971 = (uint64_t)v9;
      unint64_t v71 = v973;
      unint64_t v1002 = v26;
      if (!v68) {
        return 1;
      }
      goto LABEL_957;
    }
    unint64_t v1002 = v26 - (v27 * v14);
    if (!v22)
    {
      int v969 = *(_DWORD *)(v4 + 56);
      int v970 = *(_DWORD *)(v4 + 60);
      unint64_t v67 = 0;
      int v974 = 1;
      unint64_t v72 = v14;
      unint64_t v73 = v993;
      unint64_t v74 = (unint64_t)*(int *)(v4 + 76) >> 1;
      goto LABEL_62;
    }
    uint64_t v75 = v45 % v975;
    int v970 = v45 % v975;
    uint64_t v977 = *(void *)(v4 + 88);
    unint64_t v76 = &v22[v991 * v75];
    int v77 = v44 % (int)v47;
    uint64_t v22 = &v76[v77];
    unint64_t v67 = (unint64_t)&v76[(int)v47];
    int v969 = v77;
    v992 = v22;
    if (v9)
    {
      uint64_t v976 = 0;
      uint64_t v971 = (uint64_t)v9;
      v9 += 2 * v993 * v75 + 2 * v77;
      int v974 = 1;
      uint64_t v46 = 1;
      uint64_t v996 = (uint64_t)v9;
    }
    else
    {
      uint64_t v971 = 0;
      uint64_t v976 = 0;
      uint64_t v996 = 0;
      int v974 = 1;
    }
    float32x4_t v78 = (_WORD *)v972;
    unint64_t v71 = v973;
    unint64_t v72 = v14;
LABEL_66:
    uint64_t v1004 = v46;
    uint64_t v1006 = v27;
    unint64_t v978 = v25;
    *(void *)v998 = v25 - v72;
    switch(v11)
    {
      case 0:
        unint64_t v979 = v67;
        unint64_t v79 = v26;
        uint64_t v80 = (int)v14;
        uint64_t v81 = *(void *)v998 - (int)v14;
        int v82 = v14 - 1;
        float32x4_t v83 = &v78[-(int)v14 + 1];
        if (v974 >= 0)
        {
          float32x4_t v83 = v78;
          uint64_t v81 = *(void *)v998 + (int)v14;
        }
        unsigned int v84 = v1008[0];
        uint64_t v85 = v1008[0] - 1;
        unint64_t v86 = (char *)&v83[(v81 * v85) & (v81 >> 63)];
        if (v81 < 0) {
          uint64_t v81 = -v81;
        }
        int v87 = 2 * v14;
        CGBlt_fillBytes(v87, v1008[0], 0, v86, 2 * v81);
        if (v27)
        {
          if (v974 < 0)
          {
            uint64_t v88 = v1002 - v80;
            v71 -= 2 * v82;
          }
          else
          {
            uint64_t v88 = v1002 + v80;
          }
          unint64_t v26 = v79;
          v71 += 2 * ((v88 * v85) & (v88 >> 63));
          if (v88 < 0) {
            uint64_t v88 = -v88;
          }
          unint64_t v1002 = v88;
          CGBlt_fillBytes(v87, v84, 0, v71, 2 * v88);
          uint64_t v13 = v968;
        }
        else
        {
          uint64_t v13 = v968;
          unint64_t v26 = v79;
        }
        uint64_t v22 = (_WORD *)v977;
        goto LABEL_919;
      case 1:
        int v89 = *(unsigned __int8 *)(v13 + 1);
        if (v89 == 2)
        {
          if ((int)v14 >= 16 && (2 * v47) <= 0x40)
          {
            _Q0.n128_u32[0] = 2 * v47;
            uint8x8_t v635 = (uint8x8_t)vcnt_s8((int8x8_t)_Q0.n128_u64[0]);
            v635.i16[0] = vaddlv_u8(v635);
            if (v635.i32[0] <= 1u)
            {
              unint64_t v979 = v67;
              int v636 = 2 * (v14 + v998[0]);
              int v999 = v1008[0];
              CGSFillDRAM64((unint64_t)v78, v636, 2 * v14, v1008[0], v977, 2 * v991, 2 * v47, v975, 2 * v969, v970);
              if (v27)
              {
                uint64_t v69 = v976;
                if (v1004) {
                  CGSFillDRAM64((unint64_t)v71, 2 * (v14 + v1002), 2 * v14, v999, v971, 2 * v993, 2 * v47, v975, 2 * v969, v970);
                }
                else {
                  CGBlt_fillBytes(2 * v14, v999, 1006648320, v71, 2 * (v14 + v1002));
                }
                uint64_t v22 = (_WORD *)v977;
              }
              else
              {
                uint64_t v22 = (_WORD *)v977;
LABEL_919:
                uint64_t v69 = v976;
              }
              unint64_t v67 = v979;
              goto LABEL_764;
            }
          }
        }
        else if (v89 == 1)
        {
          if (v974 < 0)
          {
            uint64_t v90 = v991 - (int)v14;
            v22 += -(int)v14 + 1;
            uint64_t v91 = *(void *)v998 - (int)v14;
            v78 += -(int)v14 + 1;
          }
          else
          {
            uint64_t v90 = v991 + (int)v14;
            uint64_t v91 = *(void *)v998 + (int)v14;
          }
          uint64_t v672 = v1008[0] - 1;
          v673 = (char *)&v22[(v90 * v672) & (v90 >> 63)];
          if (v90 >= 0) {
            unint64_t v674 = v90;
          }
          else {
            unint64_t v674 = -v90;
          }
          if (v91 >= 0) {
            LODWORD(v675) = v91;
          }
          else {
            uint64_t v675 = -v91;
          }
          unint64_t v991 = v674;
          int v1000 = v1008[0];
          CGBlt_copyBytes(2 * v14, v1008[0], v673, (char *)&v78[(v91 * v672) & (v91 >> 63)], 2 * v674, 2 * v675);
          if (v27)
          {
            uint64_t v22 = (_WORD *)v977;
            if (v1004)
            {
              uint64_t v676 = v993 - (int)v14;
              v677 = &v9[-2 * (int)v14 + 2];
              uint64_t v678 = v1002 - (int)v14;
              v679 = &v71[-2 * (int)v14 + 2];
              if (v974 >= 0)
              {
                v677 = v9;
                v679 = v71;
                uint64_t v676 = v993 + (int)v14;
                uint64_t v678 = v1002 + (int)v14;
              }
              float16x4_t v9 = &v677[2 * ((v676 * v672) & (v676 >> 63))];
              if (v676 >= 0) {
                unint64_t v680 = v676;
              }
              else {
                unint64_t v680 = -v676;
              }
              unint64_t v71 = &v679[2 * ((v678 * v672) & (v678 >> 63))];
              if (v678 >= 0) {
                uint64_t v681 = v678;
              }
              else {
                uint64_t v681 = -v678;
              }
              unint64_t v993 = v680;
              unint64_t v1002 = v681;
              CGBlt_copyBytes(2 * v14, v1000, v9, v71, 2 * v680, 2 * v681);
            }
            else
            {
              uint64_t v682 = v1002 - (int)v14;
              v683 = &v71[-2 * (int)v14 + 2];
              if (v974 >= 0)
              {
                v683 = v71;
                uint64_t v682 = v1002 + (int)v14;
              }
              uint64_t v684 = (v682 * v672) & (v682 >> 63);
              unint64_t v71 = &v683[2 * v684];
              if (v682 < 0) {
                uint64_t v682 = -v682;
              }
              unint64_t v1002 = v682;
              CGBlt_fillBytes(2 * v14, v1000, 1006648320, &v683[2 * v684], 2 * v682);
            }
            uint64_t v13 = v968;
          }
          else
          {
            uint64_t v13 = v968;
            uint64_t v22 = (_WORD *)v977;
          }
          uint64_t v69 = v976;
          uint64_t v70 = (char *)v996;
          if (!v976) {
            return 1;
          }
          goto LABEL_956;
        }
        if (!v27)
        {
          int v647 = v1008[0];
          uint64_t v70 = (char *)v996;
          v567 = v992;
          do
          {
            int v648 = v14;
            do
            {
              *float32x4_t v78 = *v22;
              v649 = &v22[v974];
              if ((unint64_t)v649 >= v67) {
                uint64_t v650 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v650 = 0;
              }
              v9 += 2 * (int)v46 + 2 * v650;
              uint64_t v22 = &v649[v650];
              v78 += v974;
              --v648;
            }
            while (v648);
            if (v990)
            {
              v651 = &v567[v991];
              if (v651 >= v990) {
                uint64_t v652 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v652 = 0;
              }
              v70 += 2 * v993 + 2 * v652;
              if (v651 >= v990) {
                uint64_t v653 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v653 = 0;
              }
              v567 = &v651[v653];
              v67 += 2 * v653 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v567;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            --v647;
          }
          while (v647);
LABEL_937:
          v992 = v567;
LABEL_955:
          v1008[0] = 0;
          uint64_t v69 = v976;
          uint64_t v22 = (_WORD *)v977;
          if (!v976) {
            return 1;
          }
          goto LABEL_956;
        }
        uint64_t v637 = 2 * (int)v27;
        uint64_t v638 = 2 * v974;
        if (!v46)
        {
          int v654 = v1008[0];
          uint64_t v70 = (char *)v996;
          uint64_t v141 = v992;
          do
          {
            int v655 = v14;
            do
            {
              *float32x4_t v78 = *v22;
              *(_WORD *)unint64_t v71 = COERCE_UNSIGNED_INT(1.0);
              v656 = &v22[v974];
              if ((unint64_t)v656 >= v67) {
                uint64_t v657 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v657 = 0;
              }
              v9 += 2 * v657;
              uint64_t v22 = &v656[v657];
              v71 += v637;
              float32x4_t v78 = (_WORD *)((char *)v78 + v638);
              --v655;
            }
            while (v655);
            if (v990)
            {
              v658 = &v141[v991];
              if (v658 >= v990) {
                uint64_t v659 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v659 = 0;
              }
              v70 += 2 * v993 + 2 * v659;
              if (v658 >= v990) {
                uint64_t v660 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v660 = 0;
              }
              uint64_t v141 = &v658[v660];
              v67 += 2 * v660 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v141;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            --v654;
          }
          while (v654);
LABEL_954:
          v992 = v141;
          goto LABEL_955;
        }
        uint64_t v639 = (int)v46;
        int v640 = v1008[0];
        uint64_t v70 = (char *)v996;
        unsigned int v94 = v992;
        do
        {
          int v641 = v14;
          do
          {
            *float32x4_t v78 = *v22;
            *(_WORD *)unint64_t v71 = *(_WORD *)v9;
            v642 = &v22[v974];
            if ((unint64_t)v642 >= v67) {
              uint64_t v643 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v643 = 0;
            }
            v9 += 2 * v639 + 2 * v643;
            uint64_t v22 = &v642[v643];
            v71 += v637;
            float32x4_t v78 = (_WORD *)((char *)v78 + v638);
            --v641;
          }
          while (v641);
          if (v990)
          {
            v644 = &v94[v991];
            if (v644 >= v990) {
              uint64_t v645 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v645 = 0;
            }
            v70 += 2 * v993 + 2 * v645;
            if (v644 >= v990) {
              uint64_t v646 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v646 = 0;
            }
            unsigned int v94 = &v644[v646];
            v67 += 2 * v646 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v94;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v640;
        }
        while (v640);
        goto LABEL_913;
      case 2:
        uint64_t v92 = (int)v46;
        if (v27)
        {
          int v93 = v1008[0];
          uint64_t v70 = (char *)v996;
          unsigned int v94 = v992;
          while (1)
          {
            int v95 = v14;
            do
            {
              if (*(short float *)v9 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                *float32x4_t v78 = *v22;
                _H2 = *(_WORD *)v9;
              }
              else
              {
                __asm { FCMP            H2, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_86;
                }
                __asm { FCVT            S2, H2 }
                _H3 = *v22;
                __asm { FCVT            S3, H3 }
                _H4 = *(short float *)v78;
                __asm { FCVT            S4, H4 }
                _S3 = _S3 + (float)(_S4 * (float)(1.0 - _S2));
                __asm { FCVT            H3, S3 }
                *float32x4_t v78 = LOWORD(_S3);
                LOWORD(_S3) = *(_WORD *)v71;
                __asm { FCVT            S3, H3 }
                _S2 = _S2 + (float)(_S3 * (float)(1.0 - _S2));
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)unint64_t v71 = _H2;
LABEL_86:
              float v106 = &v22[v974];
              if ((unint64_t)v106 >= v67) {
                uint64_t v107 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v107 = 0;
              }
              v9 += 2 * v92 + 2 * v107;
              uint64_t v22 = &v106[v107];
              v71 += 2 * (int)v27;
              v78 += v974;
              --v95;
            }
            while (v95);
            if (v990)
            {
              float v108 = &v94[v991];
              if (v108 >= v990) {
                uint64_t v109 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v109 = 0;
              }
              v70 += 2 * v993 + 2 * v109;
              if (v108 >= v990) {
                uint64_t v110 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v110 = 0;
              }
              unsigned int v94 = &v108[v110];
              v67 += 2 * v110 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v94;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            if (!--v93) {
              goto LABEL_913;
            }
          }
        }
        int v566 = v1008[0];
        uint64_t v70 = (char *)v996;
        v567 = v992;
LABEL_768:
        int v568 = v14;
        while (*(short float *)v9 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
        {
          __asm { FCMP            H2, #0 }
          if (!(_NF ^ _VF | _ZF))
          {
            __asm { FCVT            S2, H2 }
            _H3 = *v22;
            __asm { FCVT            S3, H3 }
            _H4 = *v78;
            __asm { FCVT            S4, H4 }
            _S2 = _S3 + (float)(_S4 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
LABEL_773:
            *float32x4_t v78 = _H2;
          }
          v577 = &v22[v974];
          if ((unint64_t)v577 >= v67) {
            uint64_t v578 = -(uint64_t)(int)v47;
          }
          else {
            uint64_t v578 = 0;
          }
          v9 += 2 * (int)v46 + 2 * v578;
          uint64_t v22 = &v577[v578];
          v78 += v974;
          if (!--v568)
          {
            if (v990)
            {
              uint64_t v579 = &v567[v991];
              if (v579 >= v990) {
                uint64_t v580 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v580 = 0;
              }
              v70 += 2 * v993 + 2 * v580;
              if (v579 >= v990) {
                uint64_t v581 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v581 = 0;
              }
              v567 = &v579[v581];
              v67 += 2 * v581 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v567;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            if (!--v566) {
              goto LABEL_937;
            }
            goto LABEL_768;
          }
        }
        _H2 = *v22;
        goto LABEL_773;
      case 3:
        if (v46)
        {
          uint64_t v111 = (int)v46;
          int v112 = v1008[0];
          uint64_t v70 = (char *)v996;
          unsigned int v94 = v992;
          do
          {
            int v113 = v14;
            do
            {
              __asm { FCMP            H2, #0 }
              if (!_ZF & _CF)
              {
                short float v115 = *(short float *)v22;
                if (_H2 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  *(short float *)float32x4_t v78 = v115;
                  short float v116 = *(short float *)v9;
                }
                else
                {
                  *(short float *)float32x4_t v78 = _H2 * v115;
                  short float v116 = _H2 * *(short float *)v9;
                }
                *(short float *)unint64_t v71 = v116;
              }
              else
              {
                *(_WORD *)unint64_t v71 = 0;
                *float32x4_t v78 = 0;
              }
              uint64_t v117 = &v22[v974];
              if ((unint64_t)v117 >= v67) {
                uint64_t v118 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v118 = 0;
              }
              v9 += 2 * v111 + 2 * v118;
              uint64_t v22 = &v117[v118];
              v71 += 2 * (int)v27;
              v78 += v974;
              --v113;
            }
            while (v113);
            if (v990)
            {
              unint64_t v119 = &v94[v991];
              if (v119 >= v990) {
                uint64_t v120 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v120 = 0;
              }
              v70 += 2 * v993 + 2 * v120;
              if (v119 >= v990) {
                uint64_t v121 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v121 = 0;
              }
              unsigned int v94 = &v119[v121];
              v67 += 2 * v121 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v94;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            --v112;
          }
          while (v112);
          goto LABEL_913;
        }
        int v582 = v1008[0];
        uint64_t v70 = (char *)v996;
        uint64_t v141 = v992;
        do
        {
          int v583 = v14;
          do
          {
            LOWORD(v584) = 0;
            __asm { FCMP            H2, #0 }
            if (!_ZF & _CF)
            {
              short float v584 = *(short float *)v22;
              if (_H2 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                short float v584 = _H2 * v584;
              }
            }
            *(short float *)float32x4_t v78 = v584;
            uint64_t v586 = &v22[v974];
            if ((unint64_t)v586 >= v67) {
              uint64_t v587 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v587 = 0;
            }
            v9 += 2 * v587;
            uint64_t v22 = &v586[v587];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v583;
          }
          while (v583);
          if (v990)
          {
            uint64_t v588 = &v141[v991];
            if (v588 >= v990) {
              uint64_t v589 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v589 = 0;
            }
            v70 += 2 * v993 + 2 * v589;
            if (v588 >= v990) {
              uint64_t v590 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v590 = 0;
            }
            uint64_t v141 = &v588[v590];
            v67 += 2 * v590 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v141;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v582;
        }
        while (v582);
        goto LABEL_954;
      case 4:
        int v122 = v1008[0];
        uint64_t v70 = (char *)v996;
        uint64_t v123 = v992;
        do
        {
          int v124 = v14;
          do
          {
            _H2 = *(_WORD *)v71;
            __asm { FCVT            S2, H2 }
            float v127 = 1.0 - _S2;
            if (v127 <= 0.0)
            {
              *(_WORD *)unint64_t v71 = 0;
              *float32x4_t v78 = 0;
            }
            else
            {
              if (v127 >= 1.0)
              {
                if (v46) {
                  _H2 = *(short float *)v9;
                }
                else {
                  LOWORD(_H2) = COERCE_UNSIGNED_INT(1.0);
                }
              }
              else
              {
                _H3 = *v22;
                __asm { FCVT            S3, H3 }
                _S3 = v127 * _S3;
                __asm { FCVT            H3, S3 }
                *float32x4_t v78 = LOWORD(_S3);
                if (v46)
                {
                  _H3 = *(short float *)v9;
                  __asm { FCVT            S3, H3 }
                }
                else
                {
                  _S3 = 1.0;
                }
                _S2 = v127 * _S3;
                __asm { FCVT            H2, S2 }
              }
              *(short float *)unint64_t v71 = _H2;
            }
            uint64_t v135 = &v22[v974];
            if ((unint64_t)v135 >= v67) {
              uint64_t v136 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v136 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v136;
            uint64_t v22 = &v135[v136];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v124;
          }
          while (v124);
          if (v990)
          {
            uint64_t v137 = &v123[v991];
            if (v137 >= v990) {
              uint64_t v138 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v138 = 0;
            }
            v70 += 2 * v993 + 2 * v138;
            if (v137 >= v990) {
              uint64_t v139 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v139 = 0;
            }
            uint64_t v123 = &v137[v139];
            v67 += 2 * v139 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v123;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v122;
        }
        while (v122);
        goto LABEL_321;
      case 5:
        int v140 = v1008[0];
        uint64_t v70 = (char *)v996;
        uint64_t v141 = v992;
        do
        {
          int v142 = v14;
          do
          {
            _H1 = *(_WORD *)v71;
            __asm { FCVT            S1, H1 }
            _H2 = *(short float *)v9;
            __asm { FCVT            S2, H2 }
            _H3 = *v22;
            __asm { FCVT            S3, H3 }
            _H4 = *v78;
            __asm { FCVT            S4, H4 }
            _S3 = (float)((float)(1.0 - _S2) * _S4) + (float)(_S3 * _S1);
            __asm { FCVT            H3, S3 }
            *float32x4_t v78 = LOWORD(_S3);
            _S1 = (float)((float)(1.0 - _S2) * _S1) + (float)(_S2 * _S1);
            __asm { FCVT            H1, S1 }
            *(_WORD *)unint64_t v71 = LOWORD(_S1);
            int v153 = &v22[v974];
            if ((unint64_t)v153 >= v67) {
              uint64_t v154 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v154 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v154;
            uint64_t v22 = &v153[v154];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v142;
          }
          while (v142);
          if (v990)
          {
            int v155 = &v141[v991];
            if (v155 >= v990) {
              uint64_t v156 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v156 = 0;
            }
            v70 += 2 * v993 + 2 * v156;
            if (v155 >= v990) {
              uint64_t v157 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v157 = 0;
            }
            uint64_t v141 = &v155[v157];
            v67 += 2 * v157 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v141;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v140;
        }
        while (v140);
        goto LABEL_954;
      case 6:
        int v158 = v1008[0];
        uint64_t v70 = (char *)v996;
        uint64_t v123 = v992;
        while (1)
        {
          int v159 = v14;
          do
          {
            _H1 = *(_WORD *)v71;
            __asm { FCVT            S1, H1 }
            float v162 = 1.0 - _S1;
            if ((float)(1.0 - _S1) >= 1.0)
            {
              *float32x4_t v78 = *v22;
              if (v46) {
                _H1 = *(short float *)v9;
              }
              else {
                LOWORD(_H1) = COERCE_UNSIGNED_INT(1.0);
              }
            }
            else
            {
              if (v162 <= 0.0) {
                goto LABEL_182;
              }
              _H3 = *v78;
              __asm { FCVT            S3, H3 }
              _H4 = *v22;
              __asm { FCVT            S4, H4 }
              _S3 = _S3 + (float)(_S4 * v162);
              __asm { FCVT            H3, S3 }
              *float32x4_t v78 = LOWORD(_S3);
              if (v46)
              {
                _H3 = *(short float *)v9;
                __asm { FCVT            S3, H3 }
              }
              else
              {
                _S3 = 1.0;
              }
              _S1 = _S1 + (float)(_S3 * v162);
              __asm { FCVT            H1, S1 }
            }
            *(short float *)unint64_t v71 = _H1;
LABEL_182:
            uint64_t v172 = &v22[v974];
            if ((unint64_t)v172 >= v67) {
              uint64_t v173 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v173 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v173;
            uint64_t v22 = &v172[v173];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v159;
          }
          while (v159);
          if (v990)
          {
            uint64_t v174 = &v123[v991];
            if (v174 >= v990) {
              uint64_t v175 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v175 = 0;
            }
            v70 += 2 * v993 + 2 * v175;
            if (v174 >= v990) {
              uint64_t v176 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v176 = 0;
            }
            uint64_t v123 = &v174[v176];
            v67 += 2 * v176 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v123;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v158)
          {
LABEL_321:
            v992 = v123;
            goto LABEL_955;
          }
        }
      case 7:
        uint64_t v177 = (int)v46;
        if (v27)
        {
          int v178 = v1008[0];
          uint64_t v70 = (char *)v996;
          unsigned int v94 = v992;
          do
          {
            int v179 = v14;
            do
            {
              __asm { FCMP            H2, #0 }
              if (!_ZF & _CF)
              {
                if (_H2 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  *(short float *)float32x4_t v78 = _H2 * *(short float *)v78;
                  *(short float *)unint64_t v71 = _H2 * *(short float *)v71;
                }
              }
              else
              {
                *(_WORD *)unint64_t v71 = 0;
                *float32x4_t v78 = 0;
              }
              float16x8_t v181 = &v22[v974];
              if ((unint64_t)v181 >= v67) {
                uint64_t v182 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v182 = 0;
              }
              v9 += 2 * v177 + 2 * v182;
              uint64_t v22 = &v181[v182];
              v71 += 2 * (int)v27;
              v78 += v974;
              --v179;
            }
            while (v179);
            if (v990)
            {
              float32x4_t v183 = &v94[v991];
              if (v183 >= v990) {
                uint64_t v184 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v184 = 0;
              }
              v70 += 2 * v993 + 2 * v184;
              if (v183 >= v990) {
                uint64_t v185 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v185 = 0;
              }
              unsigned int v94 = &v183[v185];
              v67 += 2 * v185 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v94;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            --v178;
          }
          while (v178);
LABEL_913:
          v992 = v94;
          goto LABEL_955;
        }
        int v591 = v1008[0];
        uint64_t v70 = (char *)v996;
        v567 = v992;
LABEL_811:
        int v592 = v14;
        while (1)
        {
          LOWORD(v593) = 0;
          __asm { FCMP            H1, #0 }
          if (!(!_ZF & _CF)) {
            goto LABEL_816;
          }
          if (_H1 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
            break;
          }
LABEL_817:
          uint64_t v595 = &v22[v974];
          if ((unint64_t)v595 >= v67) {
            uint64_t v596 = -(uint64_t)(int)v47;
          }
          else {
            uint64_t v596 = 0;
          }
          v9 += 2 * (int)v46 + 2 * v596;
          uint64_t v22 = &v595[v596];
          v78 += v974;
          if (!--v592)
          {
            if (v990)
            {
              unint64_t v597 = &v567[v991];
              if (v597 >= v990) {
                uint64_t v598 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v598 = 0;
              }
              v70 += 2 * v993 + 2 * v598;
              if (v597 >= v990) {
                uint64_t v599 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v599 = 0;
              }
              v567 = &v597[v599];
              v67 += 2 * v599 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v567;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            if (!--v591) {
              goto LABEL_937;
            }
            goto LABEL_811;
          }
        }
        short float v593 = _H1 * *(short float *)v78;
LABEL_816:
        *(short float *)float32x4_t v78 = v593;
        goto LABEL_817;
      case 8:
        uint64_t v186 = (int)v46;
        if (v27)
        {
          int v187 = v1008[0];
          uint64_t v70 = (char *)v996;
          unsigned int v94 = v992;
          do
          {
            int v188 = v14;
            do
            {
              _H2 = *(short float *)v9;
              __asm { FCVT            S2, H2 }
              float v191 = 1.0 - _S2;
              if (v191 <= 0.0)
              {
                *(_WORD *)unint64_t v71 = 0;
                *float32x4_t v78 = 0;
              }
              else if (v191 < 1.0)
              {
                _H3 = *v78;
                __asm { FCVT            S3, H3 }
                _S3 = v191 * _S3;
                __asm { FCVT            H3, S3 }
                *float32x4_t v78 = LOWORD(_S3);
                LOWORD(_S3) = *(_WORD *)v71;
                __asm { FCVT            S3, H3 }
                _S2 = v191 * _S3;
                __asm { FCVT            H2, S2 }
                *(_WORD *)unint64_t v71 = LOWORD(_S2);
              }
              float32x4_t v197 = &v22[v974];
              if ((unint64_t)v197 >= v67) {
                uint64_t v198 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v198 = 0;
              }
              v9 += 2 * v186 + 2 * v198;
              uint64_t v22 = &v197[v198];
              v71 += 2 * (int)v27;
              v78 += v974;
              --v188;
            }
            while (v188);
            if (v990)
            {
              float32x4_t v199 = &v94[v991];
              if (v199 >= v990) {
                uint64_t v200 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v200 = 0;
              }
              v70 += 2 * v993 + 2 * v200;
              if (v199 >= v990) {
                uint64_t v201 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v201 = 0;
              }
              unsigned int v94 = &v199[v201];
              v67 += 2 * v201 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v94;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            --v187;
          }
          while (v187);
          goto LABEL_913;
        }
        int v600 = v1008[0];
        uint64_t v70 = (char *)v996;
        v567 = v992;
LABEL_833:
        int v601 = v14;
        while (1)
        {
          _H1 = *(short float *)v9;
          __asm { FCVT            S1, H1 }
          float v604 = 1.0 - _S1;
          _H2 = 0;
          if (v604 <= 0.0) {
            goto LABEL_837;
          }
          if (v604 < 1.0) {
            break;
          }
LABEL_838:
          v609 = &v22[v974];
          if ((unint64_t)v609 >= v67) {
            uint64_t v610 = -(uint64_t)(int)v47;
          }
          else {
            uint64_t v610 = 0;
          }
          v9 += 2 * (int)v46 + 2 * v610;
          uint64_t v22 = &v609[v610];
          v78 += v974;
          if (!--v601)
          {
            if (v990)
            {
              v611 = &v567[v991];
              if (v611 >= v990) {
                uint64_t v612 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v612 = 0;
              }
              v70 += 2 * v993 + 2 * v612;
              if (v611 >= v990) {
                uint64_t v613 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v613 = 0;
              }
              v567 = &v611[v613];
              v67 += 2 * v613 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v567;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            if (!--v600) {
              goto LABEL_937;
            }
            goto LABEL_833;
          }
        }
        _H2 = *v78;
        __asm { FCVT            S2, H2 }
        _S1 = v604 * _S2;
        __asm { FCVT            H2, S1 }
LABEL_837:
        *float32x4_t v78 = _H2;
        goto LABEL_838;
      case 9:
        int v202 = v1008[0];
        uint64_t v70 = (char *)v996;
        uint64_t v141 = v992;
        do
        {
          int v203 = v14;
          do
          {
            _H1 = *(_WORD *)v71;
            __asm { FCVT            S1, H1 }
            _H2 = *(short float *)v9;
            __asm { FCVT            S2, H2 }
            _H3 = *v22;
            __asm { FCVT            S3, H3 }
            _H5 = *v78;
            __asm { FCVT            S5, H5 }
            _S3 = (float)(_S2 * _S5) + (float)(_S3 * (float)(1.0 - _S1));
            __asm { FCVT            H3, S3 }
            *float32x4_t v78 = LOWORD(_S3);
            _S1 = (float)(_S1 * _S2) + (float)(_S2 * (float)(1.0 - _S1));
            __asm { FCVT            H1, S1 }
            *(_WORD *)unint64_t v71 = LOWORD(_S1);
            int v214 = &v22[v974];
            if ((unint64_t)v214 >= v67) {
              uint64_t v215 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v215 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v215;
            uint64_t v22 = &v214[v215];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v203;
          }
          while (v203);
          if (v990)
          {
            unsigned int v216 = &v141[v991];
            if (v216 >= v990) {
              uint64_t v217 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v217 = 0;
            }
            v70 += 2 * v993 + 2 * v217;
            if (v216 >= v990) {
              uint64_t v218 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v218 = 0;
            }
            uint64_t v141 = &v216[v218];
            v67 += 2 * v218 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v141;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v202;
        }
        while (v202);
        goto LABEL_954;
      case 10:
        int v219 = v1008[0];
        uint64_t v70 = (char *)v996;
        uint64_t v141 = v992;
        do
        {
          int v220 = v14;
          do
          {
            _H1 = *(_WORD *)v71;
            __asm { FCVT            S1, H1 }
            _H2 = *(short float *)v9;
            __asm { FCVT            S2, H2 }
            _H3 = *v22;
            __asm { FCVT            S3, H3 }
            _H5 = *v78;
            __asm { FCVT            S5, H5 }
            _S3 = (float)((float)(1.0 - _S2) * _S5) + (float)(_S3 * (float)(1.0 - _S1));
            __asm { FCVT            H3, S3 }
            *float32x4_t v78 = LOWORD(_S3);
            _S1 = (float)((float)(1.0 - _S2) * _S1) + (float)(_S2 * (float)(1.0 - _S1));
            __asm { FCVT            H1, S1 }
            *(_WORD *)unint64_t v71 = LOWORD(_S1);
            float32x4_t v231 = &v22[v974];
            if ((unint64_t)v231 >= v67) {
              uint64_t v232 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v232 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v232;
            uint64_t v22 = &v231[v232];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v220;
          }
          while (v220);
          if (v990)
          {
            float32x4_t v233 = &v141[v991];
            if (v233 >= v990) {
              uint64_t v234 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v234 = 0;
            }
            v70 += 2 * v993 + 2 * v234;
            if (v233 >= v990) {
              uint64_t v235 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v235 = 0;
            }
            uint64_t v141 = &v233[v235];
            v67 += 2 * v235 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v141;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v219;
        }
        while (v219);
        goto LABEL_954;
      case 11:
        if (v27)
        {
          int v236 = v1008[0];
          uint64_t v70 = (char *)v996;
          uint64_t v123 = v992;
          do
          {
            int v237 = v14;
            do
            {
              if (v46)
              {
                _H1 = *(short float *)v9;
                __asm { FCVT            S1, H1 }
              }
              else
              {
                _S1 = 1.0;
              }
              _H2 = *(_WORD *)v71;
              __asm { FCVT            S2, H2 }
              float v242 = _S1 + _S2;
              _H4 = *v78;
              __asm { FCVT            S4, H4 }
              float v245 = _S2 - _S4;
              LOWORD(_S4) = *v22;
              __asm { FCVT            S4, H4 }
              float v247 = v245 + (float)(_S1 - _S4);
              if (v242 <= 1.0) {
                _S2 = v242;
              }
              else {
                _S2 = 1.0;
              }
              __asm { FCVT            H3, S2 }
              *(_WORD *)unint64_t v71 = _H3;
              _S1 = _S2 - v247;
              __asm { FCVT            H1, S1 }
              *float32x4_t v78 = LOWORD(_S1);
              float v251 = &v22[v974];
              if ((unint64_t)v251 >= v67) {
                uint64_t v252 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v252 = 0;
              }
              v9 += 2 * (int)v46 + 2 * v252;
              uint64_t v22 = &v251[v252];
              v71 += 2 * (int)v27;
              v78 += v974;
              --v237;
            }
            while (v237);
            if (v990)
            {
              float32x4_t v253 = &v123[v991];
              if (v253 >= v990) {
                uint64_t v254 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v254 = 0;
              }
              v70 += 2 * v993 + 2 * v254;
              if (v253 >= v990) {
                uint64_t v255 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v255 = 0;
              }
              uint64_t v123 = &v253[v255];
              v67 += 2 * v255 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v123;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            --v236;
          }
          while (v236);
          goto LABEL_321;
        }
        int v614 = v1008[0];
        uint64_t v70 = (char *)v996;
        v567 = v992;
        do
        {
          int v615 = v14;
          do
          {
            _S2 = 1.0;
            if (v46)
            {
              _H2 = *(short float *)v9;
              __asm { FCVT            S2, H2 }
            }
            _H3 = *v78;
            __asm { FCVT            S3, H3 }
            float v620 = 1.0 - _S3;
            LOWORD(_S3) = *v22;
            __asm { FCVT            S3, H3 }
            _S1 = 1.0 - (float)(v620 + (float)(_S2 - _S3));
            __asm { FCVT            H1, S1 }
            *float32x4_t v78 = LOWORD(_S1);
            v623 = &v22[v974];
            if ((unint64_t)v623 >= v67) {
              uint64_t v624 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v624 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v624;
            uint64_t v22 = &v623[v624];
            v78 += v974;
            --v615;
          }
          while (v615);
          if (v990)
          {
            v625 = &v567[v991];
            if (v625 >= v990) {
              uint64_t v626 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v626 = 0;
            }
            v70 += 2 * v993 + 2 * v626;
            if (v625 >= v990) {
              uint64_t v627 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v627 = 0;
            }
            v567 = &v625[v627];
            v67 += 2 * v627 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v567;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v614;
        }
        while (v614);
        goto LABEL_937;
      case 12:
        if (!v27)
        {
          int v628 = v1008[0];
          uint64_t v70 = (char *)v996;
          v567 = v992;
          do
          {
            int v629 = v14;
            do
            {
              *(short float *)float32x4_t v78 = *(short float *)v78 + *(short float *)v22;
              v630 = &v22[v974];
              if ((unint64_t)v630 >= v67) {
                uint64_t v631 = -(uint64_t)(int)v47;
              }
              else {
                uint64_t v631 = 0;
              }
              v9 += 2 * (int)v46 + 2 * v631;
              uint64_t v22 = &v630[v631];
              v78 += v974;
              --v629;
            }
            while (v629);
            if (v990)
            {
              v632 = &v567[v991];
              if (v632 >= v990) {
                uint64_t v633 = -(uint64_t)(v993 * v975);
              }
              else {
                uint64_t v633 = 0;
              }
              v70 += 2 * v993 + 2 * v633;
              if (v632 >= v990) {
                uint64_t v634 = -(uint64_t)(v991 * v975);
              }
              else {
                uint64_t v634 = 0;
              }
              v567 = &v632[v634];
              v67 += 2 * v634 + 2 * v991;
              float16x4_t v9 = v70;
              uint64_t v22 = v567;
            }
            else
            {
              v22 += v991;
              v9 += 2 * v993;
            }
            v78 += *(void *)v998;
            v71 += 2 * v1002;
            --v628;
          }
          while (v628);
          goto LABEL_937;
        }
        int v256 = v1008[0];
        uint64_t v70 = (char *)v996;
        uint64_t v123 = v992;
        do
        {
          int v257 = v14;
          do
          {
            if (v46)
            {
              _H1 = *(short float *)v9;
              __asm { FCVT            S1, H1 }
            }
            else
            {
              _S1 = 1.0;
            }
            _H2 = *(_WORD *)v71;
            __asm { FCVT            S2, H2 }
            _S1 = _S1 + _S2;
            if (_S1 > 1.0) {
              _S1 = 1.0;
            }
            *(short float *)float32x4_t v78 = *(short float *)v78 + *(short float *)v22;
            __asm { FCVT            H1, S1 }
            *(_WORD *)unint64_t v71 = _H1;
            float16x4_t v264 = &v22[v974];
            if ((unint64_t)v264 >= v67) {
              uint64_t v265 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v265 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v265;
            uint64_t v22 = &v264[v265];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v257;
          }
          while (v257);
          if (v990)
          {
            float16x4_t v266 = &v123[v991];
            if (v266 >= v990) {
              uint64_t v267 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v267 = 0;
            }
            v70 += 2 * v993 + 2 * v267;
            if (v266 >= v990) {
              uint64_t v268 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v268 = 0;
            }
            uint64_t v123 = &v266[v268];
            v67 += 2 * v268 + 2 * v991;
            float16x4_t v9 = v70;
            uint64_t v22 = v123;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          --v256;
        }
        while (v256);
        goto LABEL_321;
      case 13:
        int v269 = v1008[0];
        while (1)
        {
          int v270 = v14;
          do
          {
            _S2 = 1.0;
            _S1 = 1.0;
            if (v46)
            {
              __asm { FCMP            H1, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_339;
              }
              __asm { FCVT            S1, H1 }
            }
            if (v27)
            {
              __asm { FCMP            H2, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H1, S1 }
LABEL_337:
                *(_WORD *)unint64_t v71 = _H1;
                goto LABEL_339;
              }
              __asm { FCVT            S2, H2 }
            }
            _H3 = *v78;
            _H4 = *v22;
            __asm
            {
              FCVT            S3, H3
              FCVT            S4, H4
            }
            float v279 = _S3 * _S4;
            _S3 = (float)(_S3 * _S4) + (float)(_S3 * (float)(1.0 - _S1));
            if (_S1 == 1.0) {
              _S3 = v279;
            }
            float v281 = _S3 + (float)(_S4 * (float)(1.0 - _S2));
            if (_S2 != 1.0) {
              _S3 = v281;
            }
            __asm { FCVT            H3, S3 }
            if (v27)
            {
              _S1 = (float)(_S1 + _S2) - (float)(_S2 * _S1);
              __asm { FCVT            H1, S1 }
              *float32x4_t v78 = _H3;
              goto LABEL_337;
            }
            *float32x4_t v78 = _H3;
LABEL_339:
            float32x4_t v285 = &v22[v974];
            if ((unint64_t)v285 >= v67) {
              uint64_t v286 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v286 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v286;
            uint64_t v22 = &v285[v286];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v270;
          }
          while (v270);
          if (v990)
          {
            float32x4_t v287 = &v992[v991];
            if (v287 >= v990) {
              uint64_t v288 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v288 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v288);
            if (v287 >= v990) {
              uint64_t v289 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v289 = 0;
            }
            uint64_t v22 = &v287[v289];
            v67 += 2 * v289 + 2 * v991;
            v996 += 2 * v993 + 2 * v288;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v269) {
            goto LABEL_762;
          }
        }
      case 14:
        int v290 = v1008[0];
        while (1)
        {
          int v291 = v14;
          do
          {
            _S2 = 1.0;
            _S1 = 1.0;
            if (v46)
            {
              __asm { FCMP            H1, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_367;
              }
              __asm { FCVT            S1, H1 }
            }
            if (v27)
            {
              __asm { FCMP            H2, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H1, S1 }
LABEL_365:
                *(_WORD *)unint64_t v71 = _H1;
                goto LABEL_367;
              }
              __asm { FCVT            S2, H2 }
            }
            _H3 = *v78;
            _H4 = *v22;
            __asm
            {
              FCVT            S3, H3
              FCVT            S4, H4
            }
            _S3 = _S3 + (float)(_S4 * (float)(1.0 - _S3));
            __asm { FCVT            H3, S3 }
            if (v27)
            {
              _S1 = (float)(_S1 + _S2) - (float)(_S2 * _S1);
              __asm { FCVT            H1, S1 }
              *float32x4_t v78 = _H3;
              goto LABEL_365;
            }
            *float32x4_t v78 = _H3;
LABEL_367:
            float16x4_t v304 = &v22[v974];
            if ((unint64_t)v304 >= v67) {
              uint64_t v305 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v305 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v305;
            uint64_t v22 = &v304[v305];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v291;
          }
          while (v291);
          if (v990)
          {
            float16x4_t v306 = &v992[v991];
            if (v306 >= v990) {
              uint64_t v307 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v307 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v307);
            if (v306 >= v990) {
              uint64_t v308 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v308 = 0;
            }
            uint64_t v22 = &v306[v308];
            v67 += 2 * v308 + 2 * v991;
            v996 += 2 * v993 + 2 * v307;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v290) {
            goto LABEL_762;
          }
        }
      case 15:
        unint64_t v965 = v26;
        unint64_t v966 = v47;
        uint64_t v309 = (int)v46;
        int v310 = v1008[0];
        uint64_t v311 = 2 * (int)v27;
        uint64_t v312 = -(uint64_t)(int)v47;
        uint64_t v985 = v312;
        while (1)
        {
          int v980 = v310;
          int v313 = v14;
          do
          {
            _S1 = 1.0;
            _S3 = 1.0;
            if (v46)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_394;
              }
              __asm { FCVT            S3, H0 }
            }
            if (v27)
            {
              __asm { FCMP            H0, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H0, S3 }
                *(_WORD *)unint64_t v71 = _H0;
                goto LABEL_394;
              }
              __asm { FCVT            S1, H0 }
            }
            uint64_t v318 = v311;
            _Q0.n128_u16[0] = *v78;
            v7.n128_u16[0] = *v22;
            LODWORD(v27) = v1006;
            *float32x4_t v78 = PDAoverlayPDA(_Q0, _S1, v7, _S3);
            if (v1006) {
              *(_WORD *)unint64_t v71 = v319;
            }
            LODWORD(v46) = v1004;
            uint64_t v311 = v318;
            uint64_t v312 = v985;
LABEL_394:
            int8x8_t v321 = &v22[v974];
            if ((unint64_t)v321 >= v67) {
              uint64_t v322 = v312;
            }
            else {
              uint64_t v322 = 0;
            }
            v9 += 2 * v309 + 2 * v322;
            uint64_t v22 = &v321[v322];
            v71 += v311;
            v78 += v974;
            --v313;
          }
          while (v313);
          if (v990)
          {
            float v323 = &v992[v991];
            uint64_t v324 = -(uint64_t)(v993 * v975);
            if (v323 < v990) {
              uint64_t v324 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v324);
            uint64_t v325 = -(uint64_t)(v991 * v975);
            if (v323 < v990) {
              uint64_t v325 = 0;
            }
            uint64_t v22 = &v323[v325];
            v67 += 2 * v325 + 2 * v991;
            v996 += 2 * v993 + 2 * v324;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          int v310 = v980 - 1;
          if (v980 == 1) {
            goto LABEL_574;
          }
        }
      case 16:
        int v326 = v1008[0];
        while (1)
        {
          int v327 = v14;
          do
          {
            _S2 = 1.0;
            _S1 = 1.0;
            if (v46)
            {
              __asm { FCMP            H1, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_426;
              }
              __asm { FCVT            S1, H1 }
            }
            if (v27)
            {
              __asm { FCMP            H2, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H1, S1 }
LABEL_424:
                *(_WORD *)unint64_t v71 = _H1;
                goto LABEL_426;
              }
              __asm { FCVT            S2, H2 }
            }
            _H3 = *v78;
            _H4 = *v22;
            __asm
            {
              FCVT            S3, H3
              FCVT            S4, H4
            }
            float v336 = _S1 * _S3;
            if ((float)(_S2 * _S4) < (float)(_S1 * _S3)) {
              float v336 = _S2 * _S4;
            }
            _S3 = v336 + (float)(_S3 * (float)(1.0 - _S1));
            if (_S1 == 1.0) {
              _S3 = v336;
            }
            float v338 = _S3 + (float)(_S4 * (float)(1.0 - _S2));
            if (_S2 != 1.0) {
              _S3 = v338;
            }
            __asm { FCVT            H3, S3 }
            if (v27)
            {
              _S1 = (float)(_S1 + _S2) - (float)(_S2 * _S1);
              __asm { FCVT            H1, S1 }
              *float32x4_t v78 = _H3;
              goto LABEL_424;
            }
            *float32x4_t v78 = _H3;
LABEL_426:
            unsigned int v342 = &v22[v974];
            if ((unint64_t)v342 >= v67) {
              uint64_t v343 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v343 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v343;
            uint64_t v22 = &v342[v343];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v327;
          }
          while (v327);
          if (v990)
          {
            __n128 v344 = &v992[v991];
            if (v344 >= v990) {
              uint64_t v345 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v345 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v345);
            if (v344 >= v990) {
              uint64_t v346 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v346 = 0;
            }
            uint64_t v22 = &v344[v346];
            v67 += 2 * v346 + 2 * v991;
            v996 += 2 * v993 + 2 * v345;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v326) {
            goto LABEL_762;
          }
        }
      case 17:
        int v347 = v1008[0];
        while (1)
        {
          int v348 = v14;
          do
          {
            _S2 = 1.0;
            _S1 = 1.0;
            if (v46)
            {
              __asm { FCMP            H1, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_460;
              }
              __asm { FCVT            S1, H1 }
            }
            if (v27)
            {
              __asm { FCMP            H2, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H1, S1 }
LABEL_458:
                *(_WORD *)unint64_t v71 = _H1;
                goto LABEL_460;
              }
              __asm { FCVT            S2, H2 }
            }
            _H3 = *v78;
            _H4 = *v22;
            __asm
            {
              FCVT            S3, H3
              FCVT            S4, H4
            }
            float v357 = _S1 * _S3;
            if ((float)(_S2 * _S4) > (float)(_S1 * _S3)) {
              float v357 = _S2 * _S4;
            }
            _S3 = v357 + (float)(_S3 * (float)(1.0 - _S1));
            if (_S1 == 1.0) {
              _S3 = v357;
            }
            float v359 = _S3 + (float)(_S4 * (float)(1.0 - _S2));
            if (_S2 != 1.0) {
              _S3 = v359;
            }
            __asm { FCVT            H3, S3 }
            if (v27)
            {
              _S1 = (float)(_S1 + _S2) - (float)(_S2 * _S1);
              __asm { FCVT            H1, S1 }
              *float32x4_t v78 = _H3;
              goto LABEL_458;
            }
            *float32x4_t v78 = _H3;
LABEL_460:
            __int16 v363 = &v22[v974];
            if ((unint64_t)v363 >= v67) {
              uint64_t v364 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v364 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v364;
            uint64_t v22 = &v363[v364];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v348;
          }
          while (v348);
          if (v990)
          {
            unsigned int v365 = &v992[v991];
            if (v365 >= v990) {
              uint64_t v366 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v366 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v366);
            if (v365 >= v990) {
              uint64_t v367 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v367 = 0;
            }
            uint64_t v22 = &v365[v367];
            v67 += 2 * v367 + 2 * v991;
            v996 += 2 * v993 + 2 * v366;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v347) {
            goto LABEL_762;
          }
        }
      case 18:
        unint64_t v965 = v26;
        unint64_t v966 = v47;
        uint64_t v368 = (int)v46;
        int v369 = v1008[0];
        uint64_t v370 = 2 * (int)v27;
        uint64_t v371 = -(uint64_t)(int)v47;
        uint64_t v986 = v371;
        while (1)
        {
          int v981 = v369;
          int v372 = v14;
          do
          {
            _S1 = 1.0;
            _S3 = 1.0;
            if (v46)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_487;
              }
              __asm { FCVT            S3, H0 }
            }
            if (v27)
            {
              __asm { FCMP            H0, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H0, S3 }
                *(_WORD *)unint64_t v71 = _H0;
                goto LABEL_487;
              }
              __asm { FCVT            S1, H0 }
            }
            uint64_t v377 = v370;
            _Q0.n128_u16[0] = *v78;
            v7.n128_u16[0] = *v22;
            LODWORD(v27) = v1006;
            *float32x4_t v78 = PDAcolordodgePDA(_Q0, _S1, v7, _S3);
            if (v1006) {
              *(_WORD *)unint64_t v71 = v378;
            }
            LODWORD(v46) = v1004;
            uint64_t v370 = v377;
            uint64_t v371 = v986;
LABEL_487:
            int v380 = &v22[v974];
            if ((unint64_t)v380 >= v67) {
              uint64_t v381 = v371;
            }
            else {
              uint64_t v381 = 0;
            }
            v9 += 2 * v368 + 2 * v381;
            uint64_t v22 = &v380[v381];
            v71 += v370;
            v78 += v974;
            --v372;
          }
          while (v372);
          if (v990)
          {
            unsigned int v382 = &v992[v991];
            uint64_t v383 = -(uint64_t)(v993 * v975);
            if (v382 < v990) {
              uint64_t v383 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v383);
            uint64_t v384 = -(uint64_t)(v991 * v975);
            if (v382 < v990) {
              uint64_t v384 = 0;
            }
            uint64_t v22 = &v382[v384];
            v67 += 2 * v384 + 2 * v991;
            v996 += 2 * v993 + 2 * v383;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          int v369 = v981 - 1;
          if (v981 == 1) {
            goto LABEL_574;
          }
        }
      case 19:
        unint64_t v965 = v26;
        unint64_t v966 = v47;
        uint64_t v385 = (int)v46;
        int v386 = v1008[0];
        uint64_t v387 = 2 * (int)v27;
        uint64_t v388 = -(uint64_t)(int)v47;
        uint64_t v987 = v388;
        while (1)
        {
          int v982 = v386;
          int v389 = v14;
          do
          {
            _S1 = 1.0;
            _S3 = 1.0;
            if (v46)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_512;
              }
              __asm { FCVT            S3, H0 }
            }
            if (v27)
            {
              __asm { FCMP            H0, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H0, S3 }
                *(_WORD *)unint64_t v71 = _H0;
                goto LABEL_512;
              }
              __asm { FCVT            S1, H0 }
            }
            uint64_t v394 = v387;
            _Q0.n128_u16[0] = *v78;
            v7.n128_u16[0] = *v22;
            LODWORD(v27) = v1006;
            *float32x4_t v78 = PDAcolorburnPDA(_Q0, _S1, v7, _S3);
            if (v1006) {
              *(_WORD *)unint64_t v71 = v395;
            }
            LODWORD(v46) = v1004;
            uint64_t v387 = v394;
            uint64_t v388 = v987;
LABEL_512:
            unsigned int v397 = &v22[v974];
            if ((unint64_t)v397 >= v67) {
              uint64_t v398 = v388;
            }
            else {
              uint64_t v398 = 0;
            }
            v9 += 2 * v385 + 2 * v398;
            uint64_t v22 = &v397[v398];
            v71 += v387;
            v78 += v974;
            --v389;
          }
          while (v389);
          if (v990)
          {
            __n128 v399 = &v992[v991];
            uint64_t v400 = -(uint64_t)(v993 * v975);
            if (v399 < v990) {
              uint64_t v400 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v400);
            uint64_t v401 = -(uint64_t)(v991 * v975);
            if (v399 < v990) {
              uint64_t v401 = 0;
            }
            uint64_t v22 = &v399[v401];
            v67 += 2 * v401 + 2 * v991;
            v996 += 2 * v993 + 2 * v400;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          int v386 = v982 - 1;
          if (v982 == 1) {
            goto LABEL_574;
          }
        }
      case 20:
        unint64_t v965 = v26;
        unint64_t v966 = v47;
        uint64_t v402 = (int)v46;
        int v403 = v1008[0];
        uint64_t v404 = 2 * (int)v27;
        uint64_t v405 = -(uint64_t)(int)v47;
        uint64_t v988 = v405;
        while (1)
        {
          int v983 = v403;
          int v406 = v14;
          do
          {
            _S1 = 1.0;
            _S3 = 1.0;
            if (v46)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_537;
              }
              __asm { FCVT            S3, H0 }
            }
            if (v27)
            {
              __asm { FCMP            H0, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H0, S3 }
                *(_WORD *)unint64_t v71 = _H0;
                goto LABEL_537;
              }
              __asm { FCVT            S1, H0 }
            }
            uint64_t v411 = v404;
            _Q0.n128_u16[0] = *v78;
            v7.n128_u16[0] = *v22;
            LODWORD(v27) = v1006;
            *float32x4_t v78 = PDAsoftlightPDA(_Q0, _S1, v7, _S3);
            if (v1006) {
              *(_WORD *)unint64_t v71 = v412;
            }
            LODWORD(v46) = v1004;
            uint64_t v404 = v411;
            uint64_t v405 = v988;
LABEL_537:
            unsigned int v414 = &v22[v974];
            if ((unint64_t)v414 >= v67) {
              uint64_t v415 = v405;
            }
            else {
              uint64_t v415 = 0;
            }
            v9 += 2 * v402 + 2 * v415;
            uint64_t v22 = &v414[v415];
            v71 += v404;
            v78 += v974;
            --v406;
          }
          while (v406);
          if (v990)
          {
            __n128 v416 = &v992[v991];
            uint64_t v417 = -(uint64_t)(v993 * v975);
            if (v416 < v990) {
              uint64_t v417 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v417);
            uint64_t v418 = -(uint64_t)(v991 * v975);
            if (v416 < v990) {
              uint64_t v418 = 0;
            }
            uint64_t v22 = &v416[v418];
            v67 += 2 * v418 + 2 * v991;
            v996 += 2 * v993 + 2 * v417;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          int v403 = v983 - 1;
          if (v983 == 1) {
            goto LABEL_574;
          }
        }
      case 21:
        unint64_t v965 = v26;
        unint64_t v966 = v47;
        uint64_t v419 = (int)v46;
        int v420 = v1008[0];
        uint64_t v421 = 2 * (int)v27;
        uint64_t v422 = -(uint64_t)(int)v47;
        uint64_t v989 = v422;
        while (1)
        {
          int v984 = v420;
          int v423 = v14;
          do
          {
            _S1 = 1.0;
            _S3 = 1.0;
            if (v46)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_562;
              }
              __asm { FCVT            S3, H0 }
            }
            if (v27)
            {
              __asm { FCMP            H0, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H0, S3 }
                *(_WORD *)unint64_t v71 = _H0;
                goto LABEL_562;
              }
              __asm { FCVT            S1, H0 }
            }
            uint64_t v428 = v421;
            _Q0.n128_u16[0] = *v78;
            v7.n128_u16[0] = *v22;
            LODWORD(v27) = v1006;
            *float32x4_t v78 = PDAhardlightPDA(_Q0, _S1, v7, _S3);
            if (v1006) {
              *(_WORD *)unint64_t v71 = v429;
            }
            LODWORD(v46) = v1004;
            uint64_t v421 = v428;
            uint64_t v422 = v989;
LABEL_562:
            uint64_t v431 = &v22[v974];
            if ((unint64_t)v431 >= v67) {
              uint64_t v432 = v422;
            }
            else {
              uint64_t v432 = 0;
            }
            v9 += 2 * v419 + 2 * v432;
            uint64_t v22 = &v431[v432];
            v71 += v421;
            v78 += v974;
            --v423;
          }
          while (v423);
          if (v990)
          {
            unsigned int v433 = &v992[v991];
            uint64_t v434 = -(uint64_t)(v993 * v975);
            if (v433 < v990) {
              uint64_t v434 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v434);
            uint64_t v435 = -(uint64_t)(v991 * v975);
            if (v433 < v990) {
              uint64_t v435 = 0;
            }
            uint64_t v22 = &v433[v435];
            v67 += 2 * v435 + 2 * v991;
            v996 += 2 * v993 + 2 * v434;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          int v420 = v984 - 1;
          if (v984 == 1)
          {
LABEL_574:
            v1008[0] = 0;
            int v11 = v967;
            uint64_t v13 = v968;
            unint64_t v26 = v965;
            unint64_t v47 = v966;
            goto LABEL_763;
          }
        }
      case 22:
        int v436 = v1008[0];
        while (1)
        {
          int v437 = v14;
          do
          {
            _S1 = 1.0;
            _S0 = 1.0;
            if (v46)
            {
              __asm { FCMP            H0, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_590;
              }
              __asm { FCVT            S0, H0 }
            }
            if (v27)
            {
              __asm { FCMP            H1, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H0, S0 }
LABEL_588:
                *(_WORD *)unint64_t v71 = _H0;
                goto LABEL_590;
              }
              __asm { FCVT            S1, H1 }
            }
            _H2 = *v78;
            _H3 = *v22;
            __asm
            {
              FCVT            S2, H2
              FCVT            S3, H3
            }
            float v446 = _S2 + _S3;
            float v447 = _S0 * _S2;
            float v448 = _S1 * _S3;
            float v449 = v446 - v447;
            float v450 = v447 - v448;
            float v451 = v449 - v448;
            if (v450 < 0.0) {
              float v450 = -v450;
            }
            _S2 = v451 + v450;
            __asm { FCVT            H2, S2 }
            if (v27)
            {
              _S0 = (float)(_S0 + _S1) - (float)(_S1 * _S0);
              __asm { FCVT            H0, S0 }
              *float32x4_t v78 = _H2;
              goto LABEL_588;
            }
            *float32x4_t v78 = _H2;
LABEL_590:
            float16x4_t v456 = &v22[v974];
            if ((unint64_t)v456 >= v67) {
              uint64_t v457 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v457 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v457;
            uint64_t v22 = &v456[v457];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v437;
          }
          while (v437);
          if (v990)
          {
            int v458 = &v992[v991];
            if (v458 >= v990) {
              uint64_t v459 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v459 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v459);
            if (v458 >= v990) {
              uint64_t v460 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v460 = 0;
            }
            uint64_t v22 = &v458[v460];
            v67 += 2 * v460 + 2 * v991;
            v996 += 2 * v993 + 2 * v459;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v436)
          {
LABEL_762:
            v1008[0] = 0;
LABEL_763:
            uint64_t v22 = (_WORD *)v977;
            uint64_t v69 = v976;
LABEL_764:
            uint64_t v70 = (char *)v996;
            if (!v69) {
              return 1;
            }
LABEL_956:
            uint64_t v1007 = 0;
LABEL_957:
            uint64_t v996 = (uint64_t)v70;
            if (!shape_enum_clip_next(v69, (int *)&v1007 + 1, &v1007, v1018, v1008))
            {
              unint64_t v64 = (void *)v69;
              goto LABEL_1375;
            }
            uint64_t v976 = v69;
            uint64_t v977 = (uint64_t)v22;
            if (v990)
            {
              unint64_t v25 = v978;
              float32x4_t v78 = (_WORD *)(v972 + 2 * v978 * (int)v1007 + 2 * SHIDWORD(v1007));
              int v661 = ((int)v1007 + *(_DWORD *)(v13 + 60)) % v975;
              unint64_t v72 = v1018[0];
              int v662 = (HIDWORD(v1007) + *(_DWORD *)(v13 + 56)) % (int)v47;
              v663 = &v22[v991 * v661];
              uint64_t v22 = &v663[v662];
              unint64_t v67 = (unint64_t)&v663[(int)v47];
              uint64_t v27 = v1006;
              if (v1006) {
                unint64_t v71 = &v973[2 * v26 * (int)v1007 + 2 * SHIDWORD(v1007)];
              }
              unint64_t v664 = v1002;
              if (v1006) {
                unint64_t v664 = v26 - v1018[0];
              }
              unint64_t v1002 = v664;
              if (v1004) {
                uint64_t v46 = v1004;
              }
              else {
                uint64_t v46 = 0;
              }
              uint64_t v665 = v996;
              if (v1004) {
                uint64_t v665 = v971 + 2 * v993 * v661 + 2 * v662;
              }
              uint64_t v996 = v665;
              if (v1004) {
                float16x4_t v9 = (char *)(v971 + 2 * v993 * v661 + 2 * v662);
              }
              LODWORD(v14) = v1018[0];
              v992 = &v663[v662];
              int v969 = (HIDWORD(v1007) + *(_DWORD *)(v13 + 56)) % (int)v47;
              int v970 = ((int)v1007 + *(_DWORD *)(v13 + 60)) % v975;
            }
            else
            {
              int v666 = HIDWORD(v1007) * v974;
              LODWORD(v14) = v1018[0];
              int v667 = v1018[0] * v974;
              unint64_t v25 = v978;
              float32x4_t v78 = (_WORD *)(v972 + 2 * v978 * (int)v1007 + 2 * HIDWORD(v1007) * v974);
              unint64_t v72 = v1018[0] * v974;
              v22 += (int)v1007 * (int)v47 + HIDWORD(v1007) * v974;
              v990 = 0;
              unint64_t v991 = (int)v47 - v1018[0] * v974;
              uint64_t v46 = v1004;
              uint64_t v27 = v1006;
              if (v1006) {
                unint64_t v71 = &v973[2 * v26 * (int)v1007 + 2 * v666];
              }
              unint64_t v668 = v1002;
              if (v1006) {
                unint64_t v668 = v26 - v667;
              }
              unint64_t v1002 = v668;
              uint64_t v669 = v971 + 2 * (int)v1007 * v975 + 2 * v666;
              unint64_t v670 = v975 - v667;
              if (v1004) {
                float16x4_t v9 = (char *)v669;
              }
              unint64_t v671 = v993;
              if (v1004) {
                unint64_t v671 = v670;
              }
              unint64_t v993 = v671;
            }
            goto LABEL_66;
          }
        }
      case 23:
        int v461 = v1008[0];
        while (1)
        {
          int v462 = v14;
          do
          {
            _S2 = 1.0;
            _S1 = 1.0;
            if (v46)
            {
              __asm { FCMP            H1, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_618;
              }
              __asm { FCVT            S1, H1 }
            }
            if (v27)
            {
              __asm { FCMP            H2, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H1, S1 }
LABEL_616:
                *(_WORD *)unint64_t v71 = _H1;
                goto LABEL_618;
              }
              __asm { FCVT            S2, H2 }
            }
            _H3 = *v78;
            _H4 = *v22;
            __asm
            {
              FCVT            S3, H3
              FCVT            S4, H4
            }
            _S3 = (float)(_S3 + _S4) + (float)((float)(_S3 * _S4) * -2.0);
            __asm { FCVT            H3, S3 }
            if (v27)
            {
              _S1 = (float)(_S1 + _S2) - (float)(_S2 * _S1);
              __asm { FCVT            H1, S1 }
              *float32x4_t v78 = _H3;
              goto LABEL_616;
            }
            *float32x4_t v78 = _H3;
LABEL_618:
            int v475 = &v22[v974];
            if ((unint64_t)v475 >= v67) {
              uint64_t v476 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v476 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v476;
            uint64_t v22 = &v475[v476];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v462;
          }
          while (v462);
          if (v990)
          {
            uint64_t v477 = &v992[v991];
            if (v477 >= v990) {
              uint64_t v478 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v478 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v478);
            if (v477 >= v990) {
              uint64_t v479 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v479 = 0;
            }
            uint64_t v22 = &v477[v479];
            v67 += 2 * v479 + 2 * v991;
            v996 += 2 * v993 + 2 * v478;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v461) {
            goto LABEL_762;
          }
        }
      case 24:
        int v480 = v1008[0];
        while (1)
        {
          int v481 = v14;
          do
          {
            _S3 = 1.0;
            _S2 = 1.0;
            if (v46)
            {
              __asm { FCMP            H2, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_651;
              }
              __asm { FCVT            S2, H2 }
            }
            if (v27)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H2, S2 }
LABEL_649:
                *(_WORD *)unint64_t v71 = _H2;
                goto LABEL_651;
              }
              __asm { FCVT            S3, H3 }
            }
            _H4 = *v78;
            _H5 = *v22;
            __asm
            {
              FCVT            S4, H4
              FCVT            S5, H5
            }
            float v490 = _S4 - (float)(_S2 * _S4);
            if (_S2 == 1.0)
            {
              float v491 = 0.0;
            }
            else
            {
              _S4 = _S2 * _S4;
              float v491 = v490;
            }
            float v492 = (float)(v491 + _S5) - (float)(_S3 * _S5);
            if (_S3 == 1.0) {
              float v492 = v491;
            }
            _S4 = _S4 + v492;
            __asm { FCVT            H4, S4 }
            if (v27)
            {
              _S2 = (float)(_S2 + _S3) - (float)(_S2 * _S3);
              __asm { FCVT            H2, S2 }
              *float32x4_t v78 = _H4;
              goto LABEL_649;
            }
            *float32x4_t v78 = _H4;
LABEL_651:
            uint64_t v497 = &v22[v974];
            if ((unint64_t)v497 >= v67) {
              uint64_t v498 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v498 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v498;
            uint64_t v22 = &v497[v498];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v481;
          }
          while (v481);
          if (v990)
          {
            uint64_t v499 = &v992[v991];
            if (v499 >= v990) {
              uint64_t v500 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v500 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v500);
            if (v499 >= v990) {
              uint64_t v501 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v501 = 0;
            }
            uint64_t v22 = &v499[v501];
            v67 += 2 * v501 + 2 * v991;
            v996 += 2 * v993 + 2 * v500;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v480) {
            goto LABEL_762;
          }
        }
      case 25:
        int v502 = v1008[0];
        while (1)
        {
          int v503 = v14;
          do
          {
            _S3 = 1.0;
            _S2 = 1.0;
            if (v46)
            {
              __asm { FCMP            H2, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_684;
              }
              __asm { FCVT            S2, H2 }
            }
            if (v27)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H2, S2 }
LABEL_682:
                *(_WORD *)unint64_t v71 = _H2;
                goto LABEL_684;
              }
              __asm { FCVT            S3, H3 }
            }
            _H4 = *v78;
            _H5 = *v22;
            __asm
            {
              FCVT            S4, H4
              FCVT            S5, H5
            }
            float v512 = _S4 - (float)(_S2 * _S4);
            if (_S2 == 1.0)
            {
              float v513 = 0.0;
            }
            else
            {
              _S4 = _S2 * _S4;
              float v513 = v512;
            }
            float v514 = (float)(v513 + _S5) - (float)(_S3 * _S5);
            if (_S3 == 1.0) {
              float v514 = v513;
            }
            _S4 = _S4 + v514;
            __asm { FCVT            H4, S4 }
            if (v27)
            {
              _S2 = (float)(_S2 + _S3) - (float)(_S2 * _S3);
              __asm { FCVT            H2, S2 }
              *float32x4_t v78 = _H4;
              goto LABEL_682;
            }
            *float32x4_t v78 = _H4;
LABEL_684:
            unint64_t v519 = &v22[v974];
            if ((unint64_t)v519 >= v67) {
              uint64_t v520 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v520 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v520;
            uint64_t v22 = &v519[v520];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v503;
          }
          while (v503);
          if (v990)
          {
            uint64_t v521 = &v992[v991];
            if (v521 >= v990) {
              uint64_t v522 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v522 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v522);
            if (v521 >= v990) {
              uint64_t v523 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v523 = 0;
            }
            uint64_t v22 = &v521[v523];
            v67 += 2 * v523 + 2 * v991;
            v996 += 2 * v993 + 2 * v522;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v502) {
            goto LABEL_762;
          }
        }
      case 26:
        int v524 = v1008[0];
        while (1)
        {
          int v525 = v14;
          do
          {
            _S3 = 1.0;
            _S2 = 1.0;
            if (v46)
            {
              __asm { FCMP            H2, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_716;
              }
              __asm { FCVT            S2, H2 }
            }
            if (v27)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                *float32x4_t v78 = *v22;
                __asm { FCVT            H2, S2 }
LABEL_714:
                *(_WORD *)unint64_t v71 = _H2;
                goto LABEL_716;
              }
              __asm { FCVT            S3, H3 }
            }
            _H4 = *v22;
            _H5 = *v78;
            __asm
            {
              FCVT            S5, H5
              FCVT            S4, H4
            }
            float v534 = _S4 - (float)(_S3 * _S4);
            if (_S3 == 1.0) {
              float v534 = 0.0;
            }
            float v535 = (float)(v534 + _S5) - (float)(_S2 * _S5);
            if (_S2 != 1.0)
            {
              _S5 = _S2 * _S5;
              float v534 = v535;
            }
            _S4 = _S5 + v534;
            __asm { FCVT            H4, S4 }
            if (v27)
            {
              _S2 = (float)(_S2 + _S3) - (float)(_S2 * _S3);
              __asm { FCVT            H2, S2 }
              *float32x4_t v78 = _H4;
              goto LABEL_714;
            }
            *float32x4_t v78 = _H4;
LABEL_716:
            uint64_t v540 = &v22[v974];
            if ((unint64_t)v540 >= v67) {
              uint64_t v541 = -(uint64_t)(int)v47;
            }
            else {
              uint64_t v541 = 0;
            }
            v9 += 2 * (int)v46 + 2 * v541;
            uint64_t v22 = &v540[v541];
            v71 += 2 * (int)v27;
            v78 += v974;
            --v525;
          }
          while (v525);
          if (v990)
          {
            uint64_t v542 = &v992[v991];
            if (v542 >= v990) {
              uint64_t v543 = -(uint64_t)(v993 * v975);
            }
            else {
              uint64_t v543 = 0;
            }
            float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v543);
            if (v542 >= v990) {
              uint64_t v544 = -(uint64_t)(v991 * v975);
            }
            else {
              uint64_t v544 = 0;
            }
            uint64_t v22 = &v542[v544];
            v67 += 2 * v544 + 2 * v991;
            v996 += 2 * v993 + 2 * v543;
            v992 = v22;
          }
          else
          {
            v22 += v991;
            v9 += 2 * v993;
          }
          v78 += *(void *)v998;
          v71 += 2 * v1002;
          if (!--v524) {
            goto LABEL_762;
          }
        }
      case 27:
        int v545 = v1008[0];
        break;
      default:
        goto LABEL_763;
    }
LABEL_732:
    int v546 = v14;
    while (1)
    {
      _S3 = 1.0;
      _S2 = 1.0;
      if (!v46) {
        goto LABEL_736;
      }
      __asm { FCMP            H2, #0 }
      if (!(_NF ^ _VF | _ZF)) {
        break;
      }
LABEL_748:
      float v561 = &v22[v974];
      if ((unint64_t)v561 >= v67) {
        uint64_t v562 = -(uint64_t)(int)v47;
      }
      else {
        uint64_t v562 = 0;
      }
      v9 += 2 * (int)v46 + 2 * v562;
      uint64_t v22 = &v561[v562];
      v71 += 2 * (int)v27;
      v78 += v974;
      if (!--v546)
      {
        if (v990)
        {
          unint64_t v563 = &v992[v991];
          if (v563 >= v990) {
            uint64_t v564 = -(uint64_t)(v993 * v975);
          }
          else {
            uint64_t v564 = 0;
          }
          float16x4_t v9 = (char *)(v996 + 2 * v993 + 2 * v564);
          if (v563 >= v990) {
            uint64_t v565 = -(uint64_t)(v991 * v975);
          }
          else {
            uint64_t v565 = 0;
          }
          uint64_t v22 = &v563[v565];
          v67 += 2 * v565 + 2 * v991;
          v996 += 2 * v993 + 2 * v564;
          v992 = v22;
        }
        else
        {
          v22 += v991;
          v9 += 2 * v993;
        }
        v78 += *(void *)v998;
        v71 += 2 * v1002;
        if (!--v545) {
          goto LABEL_762;
        }
        goto LABEL_732;
      }
    }
    __asm { FCVT            S2, H2 }
LABEL_736:
    if (v27)
    {
      __asm { FCMP            H3, #0 }
      if (!(!_ZF & _CF))
      {
        *float32x4_t v78 = *v22;
        __asm { FCVT            H2, S2 }
LABEL_746:
        *(_WORD *)unint64_t v71 = _H2;
        goto LABEL_748;
      }
      __asm { FCVT            S3, H3 }
    }
    _H4 = *v78;
    _H5 = *v22;
    __asm
    {
      FCVT            S5, H5
      FCVT            S4, H4
    }
    float v555 = _S4 - (float)(_S2 * _S4);
    if (_S2 == 1.0) {
      float v555 = 0.0;
    }
    float v556 = (float)(v555 + _S5) - (float)(_S3 * _S5);
    if (_S3 != 1.0)
    {
      _S5 = _S3 * _S5;
      float v555 = v556;
    }
    _S4 = _S5 + v555;
    __asm { FCVT            H4, S4 }
    if (!v27)
    {
      *float32x4_t v78 = _H4;
      goto LABEL_748;
    }
    _S2 = (float)(_S2 + _S3) - (float)(_S2 * _S3);
    __asm { FCVT            H2, S2 }
    *float32x4_t v78 = _H4;
    goto LABEL_746;
  }
  v1018[0] = *(_DWORD *)(v4 + 4);
  v1008[0] = v16;
  if (v9) {
    _H10 = *(short float *)v9;
  }
  else {
    LOWORD(_H10) = COERCE_UNSIGNED_INT(1.0);
  }
  uint64_t v34 = *(void *)(v4 + 40);
  __asm { FCVT            S8, H10 }
  _Q0.n128_u32[0] = 1.0;
  unint64_t v40 = (unint64_t)*(int *)(v4 + 28) >> 1;
  uint64_t v42 = *(int *)(v4 + 12);
  uint64_t v41 = *(int *)(v4 + 16);
  if (v10)
  {
    unint64_t v43 = (unint64_t)*(int *)(v4 + 32) >> 1;
    uint64_t v1003 = v10 + 2 * (v42 + v43 * v41);
    unsigned int v995 = 1;
  }
  else
  {
    uint64_t v1003 = 0;
    unint64_t v43 = 0;
    unsigned int v995 = 0;
  }
  LOWORD(_S9) = **(_WORD **)(v4 + 88);
  *(float *)v8.i32 = 1.0 - _S8;
  uint64_t v48 = v42 + v41 * v40;
  unint64_t v49 = v34 + 2 * v48;
  int32x2_t v1001 = v8;
  unint64_t v994 = (unint64_t)*(int *)(v4 + 28) >> 1;
  *(void *)v997 = v49;
  if (v18)
  {
    shape_enum_clip_alloc(v3, v4, (int *)v18, 1, 1, 1, *(_DWORD *)(v4 + 104), *(_DWORD *)(v4 + 108), v14, v16);
    uint64_t v51 = v50;
    uint64_t v52 = v1003;
    unint64_t v53 = v43;
    if (v50) {
      goto LABEL_1370;
    }
    return 1;
  }
  uint64_t v1005 = 0;
  if (v10) {
    unint64_t v54 = v14;
  }
  else {
    unint64_t v54 = 0;
  }
  unint64_t v53 = v43 - v54;
  uint64_t v52 = v1003;
  unsigned int v55 = (float16x4_t *)(v34 + 2 * v48);
  unint64_t v56 = v14;
  while (2)
  {
    unint64_t v49 = v40 - v56;
    switch(v11)
    {
      case 0:
        unint64_t v685 = v43;
        unint64_t v686 = v40;
        int v687 = v14;
        uint64_t v688 = v49 + (int)v14;
        unsigned int v689 = v1008[0];
        uint64_t v690 = v1008[0] - 1;
        v691 = (char *)v55 + 2 * ((v688 * v690) & (v688 >> 63));
        if (v688 < 0) {
          uint64_t v688 = -v688;
        }
        CGBlt_fillBytes(2 * v687, v1008[0], 0, v691, 2 * v688);
        if (v10)
        {
          uint64_t v692 = v53 + v687;
          v52 += 2 * ((v692 * v690) & (v692 >> 63));
          if (v692 >= 0) {
            v53 += v687;
          }
          else {
            unint64_t v53 = -v692;
          }
          CGBlt_fillBytes(2 * v687, v689, 0, (char *)v52, 2 * v53);
        }
        unint64_t v40 = v686;
        unint64_t v43 = v685;
        int v11 = v967;
        uint64_t v13 = v968;
        goto LABEL_1367;
      case 1:
        uint64_t v693 = (int)v14;
        uint64_t v694 = v49 + (int)v14;
        if (v694 < 0)
        {
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v694 * (v1008[0] - 1));
          uint64_t v694 = -v694;
        }
        unint64_t v49 = *(void *)v997;
        int v695 = 0;
        v696 = *(unsigned __int16 **)(v13 + 88);
        if (v696) {
          int v695 = *v696;
        }
        int v697 = 2 * v14;
        signed int v698 = v1008[0];
        CGBlt_fillBytes(v697, v1008[0], v695 | (v695 << 16), (char *)v55, 2 * v694);
        if (v10)
        {
          v699 = (unsigned __int16 *)&_W_float16_alpha;
          if (*(void *)(v13 + 96)) {
            v699 = *(unsigned __int16 **)(v13 + 96);
          }
          v52 += 2 * (((v53 + v693) * (v698 - 1)) & ((uint64_t)(v53 + v693) >> 63));
          if ((uint64_t)(v53 + v693) >= 0) {
            v53 += v693;
          }
          else {
            unint64_t v53 = -(uint64_t)(v53 + v693);
          }
          CGBlt_fillBytes(v697, v698, *v699 | (*v699 << 16), (char *)v52, 2 * v53);
        }
        int v11 = v967;
        unint64_t v40 = v994;
        goto LABEL_1368;
      case 2:
        int v700 = v1008[0];
        unsigned int v701 = v14 >> 2;
        __asm { FCVT            S0, H9 }
        if (v10)
        {
          unsigned int v702 = v701 + 1;
          do
          {
            int v703 = v14;
            if ((int)v14 >= 4)
            {
              unsigned int v704 = v702;
              do
              {
                _H1 = v55->i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = _Q0.n128_f32[0] + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                v55->i16[0] = LOWORD(_S1);
                LOWORD(_S1) = *(_WORD *)v52;
                __asm { FCVT            S1, H1 }
                _S1 = _S8 + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                *(_WORD *)uint64_t v52 = LOWORD(_S1);
                LOWORD(_S1) = v55->i16[1];
                __asm { FCVT            S1, H1 }
                _S1 = _Q0.n128_f32[0] + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                v55->i16[1] = LOWORD(_S1);
                LOWORD(_S1) = *(_WORD *)(v52 + 2);
                __asm { FCVT            S1, H1 }
                _S1 = _S8 + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                *(_WORD *)(v52 + 2) = LOWORD(_S1);
                LOWORD(_S1) = v55->i16[2];
                __asm { FCVT            S1, H1 }
                _S1 = _Q0.n128_f32[0] + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                v55->i16[2] = LOWORD(_S1);
                LOWORD(_S1) = *(_WORD *)(v52 + 4);
                __asm { FCVT            S1, H1 }
                _S1 = _S8 + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                *(_WORD *)(v52 + 4) = LOWORD(_S1);
                LOWORD(_S1) = v55->i16[3];
                __asm { FCVT            S1, H1 }
                _S1 = _Q0.n128_f32[0] + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                v55->i16[3] = LOWORD(_S1);
                LOWORD(_S1) = *(_WORD *)(v52 + 6);
                __asm { FCVT            S1, H1 }
                _S1 = _S8 + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                *(_WORD *)(v52 + 6) = LOWORD(_S1);
                ++v55;
                --v704;
                v52 += 8 * v995;
              }
              while (v704 > 1);
              int v703 = v14 & 3;
            }
            if (v703 >= 1)
            {
              unsigned int v722 = v703 + 1;
              do
              {
                _H1 = v55->i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = _Q0.n128_f32[0] + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                v55->i16[0] = LOWORD(_S1);
                unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
                LOWORD(_S1) = *(_WORD *)v52;
                __asm { FCVT            S1, H1 }
                _S1 = _S8 + (float)(_S1 * *(float *)v8.i32);
                __asm { FCVT            H1, S1 }
                *(_WORD *)uint64_t v52 = LOWORD(_S1);
                v52 += 2 * v995;
                --v722;
              }
              while (v722 > 1);
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v700;
          }
          while (v700);
        }
        else
        {
          float32x4_t v956 = (float32x4_t)vdupq_lane_s32(v8, 0);
          float32x4_t v957 = (float32x4_t)vdupq_lane_s32((int32x2_t)_Q0.n128_u64[0], 0);
          unsigned int v958 = v701 + 1;
          do
          {
            int v959 = v14;
            if ((int)v14 >= 4)
            {
              unsigned int v960 = v958;
              do
              {
                float16x4_t *v55 = vcvt_f16_f32(vmlaq_f32(v957, v956, vcvtq_f32_f16(*v55)));
                ++v55;
                --v960;
                v52 += 8 * v995;
              }
              while (v960 > 1);
              int v959 = v14 & 3;
            }
            if (v959 >= 1)
            {
              unsigned int v961 = v959 + 1;
              do
              {
                _H3 = v55->i16[0];
                __asm { FCVT            S3, H3 }
                _S3 = _Q0.n128_f32[0] + (float)(_S3 * *(float *)v8.i32);
                __asm { FCVT            H3, S3 }
                v55->i16[0] = LOWORD(_S3);
                unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
                v52 += 2 * v995;
                --v961;
              }
              while (v961 > 1);
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v700;
          }
          while (v700);
        }
        goto LABEL_1366;
      case 3:
        int v728 = v1008[0];
        do
        {
          int v729 = v14;
          do
          {
            __asm { FCMP            H2, #0 }
            if (!_ZF & _CF)
            {
              if (_H2 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
              }
              else
              {
                *(short float *)v55->i16 = *(short float *)&_S9 * _H2;
                *(short float *)uint64_t v52 = _H10 * _H2;
              }
            }
            else
            {
              *(_WORD *)uint64_t v52 = 0;
              v55->i16[0] = 0;
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v729;
          }
          while (v729);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v728;
        }
        while (v728);
        goto LABEL_1366;
      case 4:
        __asm { FCVT            S0, H9; jumptable 000000018508335C case 4 }
        int v732 = v1008[0];
        do
        {
          int v733 = v14;
          do
          {
            _H3 = *(_WORD *)v52;
            __asm { FCVT            S3, H3 }
            float v736 = 1.0 - _S3;
            if (v736 <= 0.0)
            {
              *(_WORD *)uint64_t v52 = 0;
              v55->i16[0] = 0;
            }
            else if (v736 >= 1.0)
            {
              v55->i16[0] = _S9;
              *(short float *)uint64_t v52 = _H10;
            }
            else
            {
              _S4 = v736 * _S0;
              __asm { FCVT            H4, S4 }
              v55->i16[0] = LOWORD(_S4);
              _S3 = v736 * _S8;
              __asm { FCVT            H3, S3 }
              *(_WORD *)uint64_t v52 = LOWORD(_S3);
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v733;
          }
          while (v733);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v732;
        }
        while (v732);
        goto LABEL_1366;
      case 5:
        __asm { FCVT            S0, H9; jumptable 000000018508335C case 5 }
        int v740 = v1008[0];
        do
        {
          int v741 = v14;
          do
          {
            _H1 = *(_WORD *)v52;
            __asm { FCVT            S1, H1 }
            _H2 = v55->i16[0];
            __asm { FCVT            S2, H2 }
            _S2 = (float)(*(float *)v8.i32 * _S2) + (float)(_S0 * _S1);
            __asm { FCVT            H2, S2 }
            v55->i16[0] = LOWORD(_S2);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            _S1 = (float)(*(float *)v8.i32 * _S1) + (float)(_S8 * _S1);
            __asm { FCVT            H1, S1 }
            *(_WORD *)uint64_t v52 = LOWORD(_S1);
            v52 += 2 * v995;
            --v741;
          }
          while (v741);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v740;
        }
        while (v740);
        goto LABEL_1366;
      case 6:
        __asm { FCVT            S0, H9; jumptable 000000018508335C case 6 }
        int v749 = v1008[0];
        do
        {
          int v750 = v14;
          do
          {
            _H2 = *(_WORD *)v52;
            __asm { FCVT            S2, H2 }
            float v753 = 1.0 - _S2;
            if ((float)(1.0 - _S2) >= 1.0)
            {
              v55->i16[0] = _S9;
              _H2 = _H10;
            }
            else
            {
              if (v753 <= 0.0) {
                goto LABEL_1075;
              }
              _H4 = v55->i16[0];
              __asm { FCVT            S4, H4 }
              _S4 = _S4 + (float)(_S0 * v753);
              __asm { FCVT            H4, S4 }
              v55->i16[0] = LOWORD(_S4);
              _S2 = _S2 + (float)(_S8 * v753);
              __asm { FCVT            H2, S2 }
            }
            *(short float *)uint64_t v52 = _H2;
LABEL_1075:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v750;
          }
          while (v750);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v749;
        }
        while (v749);
LABEL_1366:
        v1008[0] = 0;
LABEL_1367:
        unint64_t v49 = *(void *)v997;
LABEL_1368:
        uint64_t v51 = v1005;
        if (!v1005) {
          return 1;
        }
        uint64_t v1007 = 0;
LABEL_1370:
        if (shape_enum_clip_next(v51, (int *)&v1007 + 1, &v1007, v1018, v1008))
        {
          uint64_t v1005 = v51;
          unsigned int v55 = (float16x4_t *)(v49 + 2 * v40 * (int)v1007 + 2 * SHIDWORD(v1007));
          unint64_t v56 = v1018[0];
          if (v10)
          {
            uint64_t v52 = v1003 + 2 * v43 * (int)v1007 + 2 * SHIDWORD(v1007);
            unint64_t v53 = v43 - v1018[0];
          }
          LODWORD(v14) = v1018[0];
          int32x2_t v8 = v1001;
          continue;
        }
        unint64_t v64 = (void *)v51;
LABEL_1375:
        free(v64);
        return 1;
      case 7:
        int v759 = v1008[0];
        uint64_t v760 = 2 * v995;
        if (v10)
        {
          do
          {
            int v761 = v14;
            do
            {
              *(short float *)v55->i16 = _H10 * *(short float *)v55->i16;
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              *(short float *)uint64_t v52 = _H10 * *(short float *)v52;
              v52 += v760;
              --v761;
            }
            while (v761);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v759;
          }
          while (v759);
        }
        else
        {
          do
          {
            int v762 = v14;
            do
            {
              *(short float *)v55->i16 = _H10 * *(short float *)v55->i16;
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              v52 += v760;
              --v762;
            }
            while (v762);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v759;
          }
          while (v759);
        }
        goto LABEL_1366;
      case 8:
        int v763 = v1008[0];
        uint64_t v764 = 2 * v995;
        if (v10)
        {
          do
          {
            int v765 = v14;
            do
            {
              _H0 = v55->i16[0];
              __asm { FCVT            S0, H0 }
              _S0 = *(float *)v8.i32 * _S0;
              __asm { FCVT            H0, S0 }
              v55->i16[0] = LOWORD(_S0);
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              LOWORD(_S0) = *(_WORD *)v52;
              __asm { FCVT            S0, H0 }
              _S0 = *(float *)v8.i32 * _S0;
              __asm { FCVT            H0, S0 }
              *(_WORD *)uint64_t v52 = LOWORD(_S0);
              v52 += v764;
              --v765;
            }
            while (v765);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v763;
          }
          while (v763);
        }
        else
        {
          do
          {
            int v771 = v14;
            do
            {
              _H0 = v55->i16[0];
              __asm { FCVT            S0, H0 }
              _S0 = *(float *)v8.i32 * _S0;
              __asm { FCVT            H0, S0 }
              v55->i16[0] = LOWORD(_S0);
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              v52 += v764;
              --v771;
            }
            while (v771);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v763;
          }
          while (v763);
        }
        goto LABEL_1366;
      case 9:
        __asm { FCVT            S0, H9; jumptable 000000018508335C case 9 }
        int v776 = v1008[0];
        do
        {
          int v777 = v14;
          do
          {
            _H2 = *(_WORD *)v52;
            __asm { FCVT            S2, H2 }
            _H4 = v55->i16[0];
            __asm { FCVT            S4, H4 }
            _S4 = (float)(_S8 * _S4) + (float)(_S0 * (float)(1.0 - _S2));
            __asm { FCVT            H4, S4 }
            v55->i16[0] = LOWORD(_S4);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            _S2 = (float)(_S8 * _S2) + (float)(_S8 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *(_WORD *)uint64_t v52 = LOWORD(_S2);
            v52 += 2 * v995;
            --v777;
          }
          while (v777);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v776;
        }
        while (v776);
        goto LABEL_1366;
      case 10:
        __asm { FCVT            S0, H9; jumptable 000000018508335C case 10 }
        int v785 = v1008[0];
        do
        {
          int v786 = v14;
          do
          {
            _H2 = *(_WORD *)v52;
            __asm { FCVT            S2, H2 }
            _H4 = v55->i16[0];
            __asm { FCVT            S4, H4 }
            _S4 = (float)(*(float *)v8.i32 * _S4) + (float)(_S0 * (float)(1.0 - _S2));
            __asm { FCVT            H4, S4 }
            v55->i16[0] = LOWORD(_S4);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            _S2 = (float)(*(float *)v8.i32 * _S2) + (float)(_S8 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *(_WORD *)uint64_t v52 = LOWORD(_S2);
            v52 += 2 * v995;
            --v786;
          }
          while (v786);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v785;
        }
        while (v785);
        goto LABEL_1366;
      case 11:
        __asm { FCVT            S0, H9; jumptable 000000018508335C case 11 }
        float v794 = _S8 - _S0;
        int v795 = v1008[0];
        uint64_t v796 = 2 * v995;
        if (v10)
        {
          do
          {
            int v797 = v14;
            do
            {
              _H2 = *(_WORD *)v52;
              __asm { FCVT            S2, H2 }
              _S3 = _S8 + _S2;
              _H4 = v55->i16[0];
              __asm { FCVT            S4, H4 }
              float v803 = v794 + (float)(_S2 - _S4);
              if (_S3 > 1.0) {
                _S3 = 1.0;
              }
              __asm { FCVT            H4, S3 }
              *(_WORD *)uint64_t v52 = _H4;
              _S2 = _S3 - v803;
              __asm { FCVT            H2, S2 }
              v55->i16[0] = LOWORD(_S2);
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              v52 += v796;
              --v797;
            }
            while (v797);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v795;
          }
          while (v795);
        }
        else
        {
          do
          {
            int v806 = v14;
            do
            {
              _H2 = v55->i16[0];
              __asm { FCVT            S2, H2 }
              _S2 = 1.0 - (float)(v794 + (float)(1.0 - _S2));
              __asm { FCVT            H2, S2 }
              v55->i16[0] = LOWORD(_S2);
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              v52 += v796;
              --v806;
            }
            while (v806);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v795;
          }
          while (v795);
        }
        goto LABEL_1366;
      case 12:
        int v810 = v1008[0];
        uint64_t v811 = 2 * v995;
        if (v10)
        {
          do
          {
            int v812 = v14;
            do
            {
              _H1 = *(_WORD *)v52;
              __asm { FCVT            S1, H1 }
              _S1 = _S8 + _S1;
              if (_S1 > 1.0) {
                _S1 = 1.0;
              }
              *(short float *)v55->i16 = *(short float *)&_S9 + *(short float *)v55->i16;
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              __asm { FCVT            H1, S1 }
              *(_WORD *)uint64_t v52 = _H1;
              v52 += v811;
              --v812;
            }
            while (v812);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v810;
          }
          while (v810);
        }
        else
        {
          do
          {
            int v817 = v14;
            do
            {
              *(short float *)v55->i16 = *(short float *)&_S9 + *(short float *)v55->i16;
              unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
              v52 += v811;
              --v817;
            }
            while (v817);
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
            v52 += 2 * v53;
            --v810;
          }
          while (v810);
        }
        goto LABEL_1366;
      case 13:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 13 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v819 = v1008[0];
        while (1)
        {
          int v820 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1143;
              }
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            _H4 = v55->i16[0];
            __asm { FCVT            S4, H4 }
            float v825 = _S0 * _S4;
            _S4 = (float)(_S0 * _S4) + (float)(_S4 * *(float *)v8.i32);
            if (_H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
              _S4 = v825;
            }
            if (_S3 != 1.0) {
              _S4 = _S4 + (float)(_S0 * (float)(1.0 - _S3));
            }
            __asm { FCVT            H4, S4 }
            if (v10)
            {
              _S3 = (float)(_S3 + _S8) - (float)(_S3 * _S8);
              __asm { FCVT            H3, S3 }
              v55->i16[0] = _H4;
              *(_WORD *)uint64_t v52 = LOWORD(_S3);
            }
            else
            {
              v55->i16[0] = _H4;
            }
LABEL_1143:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v820;
          }
          while (v820);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v819) {
            goto LABEL_1366;
          }
        }
      case 14:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 14 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v830 = v1008[0];
        do
        {
          int v831 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H2, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S2, H2 }
                _H3 = v55->i16[0];
                __asm { FCVT            S3, H3 }
                _S3 = _S3 + (float)(_S0 * (float)(1.0 - _S3));
                __asm { FCVT            H3, S3 }
                _S2 = (float)(_S8 + _S2) - (float)(_S2 * _S8);
                __asm { FCVT            H2, S2 }
                v55->i16[0] = LOWORD(_S3);
                *(_WORD *)uint64_t v52 = LOWORD(_S2);
              }
              else
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
              }
            }
            else
            {
              _H2 = v55->i16[0];
              __asm { FCVT            S2, H2 }
              _S2 = _S2 + (float)(_S0 * (float)(1.0 - _S2));
              __asm { FCVT            H2, S2 }
              v55->i16[0] = LOWORD(_S2);
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v831;
          }
          while (v831);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v830;
        }
        while (v830);
        goto LABEL_1366;
      case 15:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 15 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        int v841 = v1008[0];
        do
        {
          int v842 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H0, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S1, H0 }
                _Q0.n128_u16[0] = v55->i16[0];
                v7.n128_u32[0] = _S9;
                _Q0.n128_u64[0] = PDAoverlayPDA(_Q0, _S1, v7, _S8);
                v55->i16[0] = _Q0.n128_u16[0];
                *(_WORD *)uint64_t v52 = v844;
              }
              else
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
              }
            }
            else
            {
              _Q0.n128_u16[0] = v55->i16[0];
              v7.n128_u32[0] = _S9;
              _Q0.n128_u64[0] = PDAoverlayPDA(_Q0, 1.0, v7, _S8);
              v55->i16[0] = _Q0.n128_u16[0];
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v842;
          }
          while (v842);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v841;
        }
        while (v841);
        goto LABEL_1251;
      case 16:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 16 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v846 = v1008[0];
        while (1)
        {
          int v847 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1185;
              }
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            _H4 = v55->i16[0];
            __asm { FCVT            S4, H4 }
            float v852 = _S8 * _S4;
            if ((float)(_S3 * _S0) < (float)(_S8 * _S4)) {
              float v852 = _S3 * _S0;
            }
            _S4 = v852 + (float)(_S4 * *(float *)v8.i32);
            if (_H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
              _S4 = v852;
            }
            if (_S3 != 1.0) {
              _S4 = _S4 + (float)(_S0 * (float)(1.0 - _S3));
            }
            __asm { FCVT            H4, S4 }
            if (v10)
            {
              _S3 = (float)(_S3 + _S8) - (float)(_S3 * _S8);
              __asm { FCVT            H3, S3 }
              v55->i16[0] = _H4;
              *(_WORD *)uint64_t v52 = LOWORD(_S3);
            }
            else
            {
              v55->i16[0] = _H4;
            }
LABEL_1185:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v847;
          }
          while (v847);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v846) {
            goto LABEL_1366;
          }
        }
      case 17:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 17 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v857 = v1008[0];
        while (1)
        {
          int v858 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H3, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1205;
              }
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            _H4 = v55->i16[0];
            __asm { FCVT            S4, H4 }
            float v863 = _S8 * _S4;
            if ((float)(_S3 * _S0) > (float)(_S8 * _S4)) {
              float v863 = _S3 * _S0;
            }
            _S4 = v863 + (float)(_S4 * *(float *)v8.i32);
            if (_H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
              _S4 = v863;
            }
            if (_S3 != 1.0) {
              _S4 = _S4 + (float)(_S0 * (float)(1.0 - _S3));
            }
            __asm { FCVT            H4, S4 }
            if (v10)
            {
              _S3 = (float)(_S3 + _S8) - (float)(_S3 * _S8);
              __asm { FCVT            H3, S3 }
              v55->i16[0] = _H4;
              *(_WORD *)uint64_t v52 = LOWORD(_S3);
            }
            else
            {
              v55->i16[0] = _H4;
            }
LABEL_1205:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v858;
          }
          while (v858);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v857) {
            goto LABEL_1366;
          }
        }
      case 18:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 18 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        int v867 = v1008[0];
        do
        {
          int v868 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H0, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S1, H0 }
                _Q0.n128_u16[0] = v55->i16[0];
                v7.n128_u32[0] = _S9;
                _Q0.n128_u64[0] = PDAcolordodgePDA(_Q0, _S1, v7, _S8);
                v55->i16[0] = _Q0.n128_u16[0];
                *(_WORD *)uint64_t v52 = v870;
              }
              else
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
              }
            }
            else
            {
              _Q0.n128_u16[0] = v55->i16[0];
              v7.n128_u32[0] = _S9;
              _Q0.n128_u64[0] = PDAcolordodgePDA(_Q0, 1.0, v7, _S8);
              v55->i16[0] = _Q0.n128_u16[0];
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v868;
          }
          while (v868);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v867;
        }
        while (v867);
        goto LABEL_1251;
      case 19:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 19 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        int v871 = v1008[0];
        do
        {
          int v872 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H0, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S1, H0 }
                _Q0.n128_u16[0] = v55->i16[0];
                v7.n128_u32[0] = _S9;
                _Q0.n128_u64[0] = PDAcolorburnPDA(_Q0, _S1, v7, _S8);
                v55->i16[0] = _Q0.n128_u16[0];
                *(_WORD *)uint64_t v52 = v874;
              }
              else
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
              }
            }
            else
            {
              _Q0.n128_u16[0] = v55->i16[0];
              v7.n128_u32[0] = _S9;
              _Q0.n128_u64[0] = PDAcolorburnPDA(_Q0, 1.0, v7, _S8);
              v55->i16[0] = _Q0.n128_u16[0];
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v872;
          }
          while (v872);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v871;
        }
        while (v871);
        goto LABEL_1251;
      case 20:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 20 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        int v875 = v1008[0];
        do
        {
          int v876 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H0, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S1, H0 }
                _Q0.n128_u16[0] = v55->i16[0];
                v7.n128_u32[0] = _S9;
                _Q0.n128_u64[0] = PDAsoftlightPDA(_Q0, _S1, v7, _S8);
                v55->i16[0] = _Q0.n128_u16[0];
                *(_WORD *)uint64_t v52 = v878;
              }
              else
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
              }
            }
            else
            {
              _Q0.n128_u16[0] = v55->i16[0];
              v7.n128_u32[0] = _S9;
              _Q0.n128_u64[0] = PDAsoftlightPDA(_Q0, 1.0, v7, _S8);
              v55->i16[0] = _Q0.n128_u16[0];
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v876;
          }
          while (v876);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v875;
        }
        while (v875);
        goto LABEL_1251;
      case 21:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 21 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        int v879 = v1008[0];
        do
        {
          int v880 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H0, #0 }
              if (!_ZF & _CF)
              {
                __asm { FCVT            S1, H0 }
                _Q0.n128_u16[0] = v55->i16[0];
                v7.n128_u32[0] = _S9;
                _Q0.n128_u64[0] = PDAhardlightPDA(_Q0, _S1, v7, _S8);
                v55->i16[0] = _Q0.n128_u16[0];
                *(_WORD *)uint64_t v52 = v882;
              }
              else
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
              }
            }
            else
            {
              _Q0.n128_u16[0] = v55->i16[0];
              v7.n128_u32[0] = _S9;
              _Q0.n128_u64[0] = PDAhardlightPDA(_Q0, 1.0, v7, _S8);
              v55->i16[0] = _Q0.n128_u16[0];
            }
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v880;
          }
          while (v880);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          --v879;
        }
        while (v879);
LABEL_1251:
        v1008[0] = 0;
        int v11 = v967;
        uint64_t v13 = v968;
        unint64_t v40 = v994;
        goto LABEL_1367;
      case 22:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 22 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v884 = v1008[0];
        while (1)
        {
          int v885 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H1, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1265;
              }
              __asm { FCVT            S1, H1 }
            }
            else
            {
              _S1 = 1.0;
            }
            _H2 = v55->i16[0];
            __asm { FCVT            S2, H2 }
            float v890 = _S0 + _S2;
            float v891 = _S8 * _S2;
            float v892 = v890 - v891;
            float v893 = v891 - (float)(_S1 * _S0);
            float v894 = v892 - (float)(_S1 * _S0);
            if (v893 < 0.0) {
              float v893 = -v893;
            }
            _S2 = v894 + v893;
            __asm { FCVT            H2, S2 }
            if (v10)
            {
              _S1 = (float)(_S1 + _S8) - (float)(_S1 * _S8);
              __asm { FCVT            H1, S1 }
              v55->i16[0] = _H2;
              *(_WORD *)uint64_t v52 = LOWORD(_S1);
            }
            else
            {
              v55->i16[0] = _H2;
            }
LABEL_1265:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v885;
          }
          while (v885);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v884) {
            goto LABEL_1366;
          }
        }
      case 23:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 23 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v899 = v1008[0];
        while (1)
        {
          int v900 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H2, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1279;
              }
              __asm { FCVT            S2, H2 }
            }
            else
            {
              _S2 = 1.0;
            }
            _H3 = v55->i16[0];
            __asm { FCVT            S3, H3 }
            _S3 = (float)(_S0 + _S3) + (float)((float)(_S0 * _S3) * -2.0);
            __asm { FCVT            H3, S3 }
            if (v10)
            {
              _S2 = (float)(_S2 + _S8) - (float)(_S2 * _S8);
              __asm { FCVT            H2, S2 }
              v55->i16[0] = _H3;
              *(_WORD *)uint64_t v52 = LOWORD(_S2);
            }
            else
            {
              v55->i16[0] = _H3;
            }
LABEL_1279:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v900;
          }
          while (v900);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v899) {
            goto LABEL_1366;
          }
        }
      case 24:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 24 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v909 = v1008[0];
        while (1)
        {
          int v910 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H4, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1298;
              }
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            _H5 = v55->i16[0];
            __asm { FCVT            S5, H5 }
            float v915 = _S5 - (float)(_S8 * _S5);
            if (_H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
            {
              float v916 = 0.0;
            }
            else
            {
              _S5 = _S8 * _S5;
              float v916 = v915;
            }
            if (_S4 != 1.0) {
              float v916 = (float)(v916 + _S0) - (float)(_S4 * _S0);
            }
            _S5 = _S5 + v916;
            __asm { FCVT            H5, S5 }
            if (v10)
            {
              _S4 = (float)(_S4 + _S8) - (float)(_S4 * _S8);
              __asm { FCVT            H4, S4 }
              v55->i16[0] = _H5;
              *(_WORD *)uint64_t v52 = LOWORD(_S4);
            }
            else
            {
              v55->i16[0] = _H5;
            }
LABEL_1298:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v910;
          }
          while (v910);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v909) {
            goto LABEL_1366;
          }
        }
      case 25:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 25 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v921 = v1008[0];
        while (1)
        {
          int v922 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H4, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1317;
              }
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            _H5 = v55->i16[0];
            __asm { FCVT            S5, H5 }
            float v927 = _S5 - (float)(_S8 * _S5);
            if (_H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
            {
              float v928 = 0.0;
            }
            else
            {
              _S5 = _S8 * _S5;
              float v928 = v927;
            }
            if (_S4 != 1.0) {
              float v928 = (float)(v928 + _S0) - (float)(_S4 * _S0);
            }
            _S5 = _S5 + v928;
            __asm { FCVT            H5, S5 }
            if (v10)
            {
              _S4 = (float)(_S4 + _S8) - (float)(_S4 * _S8);
              __asm { FCVT            H4, S4 }
              v55->i16[0] = _H5;
              *(_WORD *)uint64_t v52 = LOWORD(_S4);
            }
            else
            {
              v55->i16[0] = _H5;
            }
LABEL_1317:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v922;
          }
          while (v922);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v921) {
            goto LABEL_1366;
          }
        }
      case 26:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 26 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v933 = v1008[0];
        while (1)
        {
          int v934 = v14;
          do
          {
            if (v10)
            {
              __asm { FCMP            H4, #0 }
              if (!(!_ZF & _CF))
              {
                v55->i16[0] = _S9;
                *(short float *)uint64_t v52 = _H10;
                goto LABEL_1335;
              }
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            _H5 = v55->i16[0];
            __asm { FCVT            S5, H5 }
            float v939 = _S0 - (float)(_S4 * _S0);
            if (_S4 == 1.0) {
              float v939 = 0.0;
            }
            float v940 = (float)(v939 + _S5) - (float)(_S8 * _S5);
            if (_H10 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
            {
              _S5 = _S8 * _S5;
              float v939 = v940;
            }
            _S5 = _S5 + v939;
            __asm { FCVT            H5, S5 }
            if (v10)
            {
              _S4 = (float)(_S4 + _S8) - (float)(_S4 * _S8);
              __asm { FCVT            H4, S4 }
              v55->i16[0] = _H5;
              *(_WORD *)uint64_t v52 = LOWORD(_S4);
            }
            else
            {
              v55->i16[0] = _H5;
            }
LABEL_1335:
            unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
            v52 += 2 * v995;
            --v934;
          }
          while (v934);
          unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
          v52 += 2 * v53;
          if (!--v933) {
            goto LABEL_1366;
          }
        }
      case 27:
        __asm { FCMP            H10, #0; jumptable 000000018508335C case 27 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_1367;
        }
        __asm { FCVT            S0, H9 }
        int v945 = v1008[0];
        break;
      default:
        goto LABEL_1368;
    }
    break;
  }
LABEL_1340:
  int v946 = v14;
  while (v10)
  {
    __asm { FCMP            H4, #0 }
    if (!_ZF & _CF)
    {
      __asm { FCVT            S4, H4 }
LABEL_1346:
      _H5 = v55->i16[0];
      __asm { FCVT            S5, H5 }
      float v951 = _S5 - (float)(_S8 * _S5);
      if (_H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
        float v951 = 0.0;
      }
      float v952 = _S4 * _S0;
      if (_S4 == 1.0) {
        float v952 = _S0;
      }
      else {
        float v951 = (float)(v951 + _S0) - (float)(_S4 * _S0);
      }
      _S5 = v952 + v951;
      __asm { FCVT            H5, S5 }
      if (v10)
      {
        _S4 = (float)(_S4 + _S8) - (float)(_S4 * _S8);
        __asm { FCVT            H4, S4 }
        v55->i16[0] = _H5;
        *(_WORD *)uint64_t v52 = LOWORD(_S4);
      }
      else
      {
        v55->i16[0] = _H5;
      }
      goto LABEL_1354;
    }
    v55->i16[0] = _S9;
    *(short float *)uint64_t v52 = _H10;
LABEL_1354:
    unsigned int v55 = (float16x4_t *)((char *)v55 + 2);
    v52 += 2 * v995;
    if (!--v946)
    {
      unsigned int v55 = (float16x4_t *)((char *)v55 + 2 * v49);
      v52 += 2 * v53;
      if (!--v945) {
        goto LABEL_1366;
      }
      goto LABEL_1340;
    }
  }
  _S4 = 1.0;
  goto LABEL_1346;
}

__int16 PDAoverlayPDA@<H0>(__n128 _Q0@<Q0>, float a2@<S1>, __n128 _Q2@<Q2>, float a4@<S3>)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S2, H2
  }
  float v10 = (float)(_S0 * _S2) + (float)(_S0 * _S2);
  BOOL v11 = (float)(a2 * 0.5) <= _S0;
  float v12 = (float)((float)((float)((float)(a2 + 1.0) * _S2) + (float)(_S0 * (float)(a4 + 1.0))) - v10) - (float)(a2 * a4);
  _S0 = (float)((float)((float)(1.0 - a2) * _S2) + (float)(_S0 * (float)(1.0 - a4))) + v10;
  if (v11) {
    _S0 = v12;
  }
  _S1 = (float)(a2 + a4) - (float)(a2 * a4);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
  }
  return result;
}

__int16 PDAcolordodgePDA@<H0>(__n128 _Q0@<Q0>, float a2@<S1>, __n128 _Q2@<Q2>, float a4@<S3>)
{
  __asm
  {
    FCVT            S4, H0
    FCVT            S2, H2
  }
  float v10 = 0.0;
  __asm { FCMP            H0, #0 }
  if (!_ZF)
  {
    if (_S2 == a4) {
      float v10 = 1.0;
    }
    else {
      float v10 = (float)((float)(a4 * a4) * _S4) / (float)(a4 - _S2);
    }
  }
  float v12 = v10 + (float)(_S4 * (float)(1.0 - a4));
  if (a4 == 1.0) {
    float v12 = v10;
  }
  float v13 = v12 + (float)(_S2 * (float)(1.0 - a2));
  if (a2 == 1.0) {
    _S0 = v12;
  }
  else {
    _S0 = v13;
  }
  _S1 = (float)(a2 + a4) - (float)(a2 * a4);
  if (_S0 > _S1) {
    _S0 = _S1;
  }
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
  }
  return result;
}

__int16 PDAcolorburnPDA@<H0>(__n128 _Q0@<Q0>, float a2@<S1>, __n128 _Q2@<Q2>, float a4@<S3>)
{
  __asm
  {
    FCVT            S6, H0
    FCVT            S5, H2
  }
  float v10 = (float)(a2 * a4) + (float)(_S6 * (float)(1.0 - a4));
  if (a4 == 1.0) {
    float v10 = a2 * a4;
  }
  if (a2 == 1.0) {
    _S4 = v10;
  }
  else {
    _S4 = v10 + (float)(_S5 * (float)(1.0 - a2));
  }
  float v12 = a2 - _S6;
  if (v12 != 0.0)
  {
    __asm { FCMP            H2, #0 }
    if (_ZF || (_S4 = _S4 - (float)((float)(v12 * (float)(a4 * a4)) / _S5), _S4 < 0.0)) {
      _S4 = 0.0;
    }
  }
  _S1 = (float)(a2 + a4) - (float)(a2 * a4);
  __asm
  {
    FCVT            H0, S4
    FCVT            H1, S1
  }
  return result;
}

__int16 PDAhardlightPDA@<H0>(__n128 _Q0@<Q0>, float a2@<S1>, __n128 _Q2@<Q2>, float a4@<S3>)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S2, H2
  }
  float v10 = (float)(_S0 * _S2) + (float)(_S0 * _S2);
  float v11 = (float)((float)((float)(1.0 - a2) * _S2) + (float)(_S0 * (float)(1.0 - a4))) + v10;
  _S0 = (float)((float)((float)((float)(a2 + 1.0) * _S2) + (float)(_S0 * (float)(a4 + 1.0))) - v10) - (float)(a2 * a4);
  if ((float)(a4 * 0.5) >= _S2) {
    _S0 = v11;
  }
  _S1 = (float)(a2 + a4) - (float)(a2 * a4);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
  }
  return result;
}

__int16 PDAsoftlightPDA@<H0>(__n128 _Q0@<Q0>, float a2@<S1>, __n128 _Q2@<Q2>, float a4@<S3>)
{
  __asm
  {
    FCVT            S4, H0
    FCVT            S0, H2
  }
  float v10 = 0.0;
  if (a2 != 0.0)
  {
    float v10 = (float)((float)(_S4 * _S0) + (float)(_S4 * _S0))
        - (float)((float)((float)(_S4 * _S4) * (float)((float)(_S0 + _S0) - a4)) / a2);
    if (v10 < 0.0) {
      float v10 = 0.0;
    }
  }
  float v11 = v10 + (float)(_S4 * (float)(1.0 - a4));
  if (a4 != 1.0) {
    float v10 = v11;
  }
  _S0 = v10 + (float)(_S0 * (float)(1.0 - a2));
  if (a2 == 1.0) {
    _S0 = v10;
  }
  _S1 = (float)(a2 + a4) - (float)(a2 * a4);
  __asm
  {
    FCVT            H0, S0
    FCVT            H1, S1
  }
  return result;
}

void Wf16_mark_constmask(uint64_t a1, int a2, __n128 _Q0, double a4, __n128 _Q2)
{
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 136);
  __n128 v7 = *(short float **)(a1 + 96);
  if (v7) {
    _H1 = *v7;
  }
  else {
    LOWORD(_H1) = COERCE_UNSIGNED_INT(1.0);
  }
  uint64_t v10 = *(int *)(a1 + 12);
  uint64_t v9 = *(int *)(a1 + 16);
  if (v5)
  {
    unint64_t v11 = (unint64_t)*(int *)(a1 + 32) >> 1;
    float v12 = (short float *)(v5 + 2 * (v10 + v11 * v9));
    uint64_t v13 = 1;
    if (!v6) {
      return;
    }
  }
  else
  {
    float v12 = 0;
    unint64_t v11 = 0;
    uint64_t v13 = 0;
    if (!v6) {
      return;
    }
  }
  int v14 = *(_DWORD *)(a1 + 4);
  unint64_t v15 = v11 - v14;
  if (v5) {
    unint64_t v16 = v11 - v14;
  }
  else {
    unint64_t v16 = v11;
  }
  int v17 = *(_DWORD *)(a1 + 8);
  unint64_t v18 = (unint64_t)*(int *)(a1 + 28) >> 1;
  _Q0.n128_u16[0] = **(_WORD **)(a1 + 88);
  __asm { FCVT            S8, H1 }
  uint64_t v23 = (int16x4_t *)(*(void *)(a1 + 40) + 2 * (v10 + v18 * v9));
  uint64_t v24 = *(int *)(a1 + 124);
  unint64_t v25 = v6 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v24;
  uint64_t v26 = v24 - v14;
  unint64_t v27 = v18 - v14;
  unint64_t v710 = v27;
  uint64_t v28 = v26;
  int v29 = v14;
  unint64_t v30 = v16;
  switch(a2)
  {
    case 0:
      if (v5)
      {
        uint64_t v31 = 2 * v13;
        do
        {
          int v32 = v14;
          do
          {
            int v33 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v33 == 255)
              {
                *(_WORD *)float v12 = 0;
                v23->i16[0] = 0;
              }
              else
              {
                _H2 = v23->i16[0];
                __asm { FCVT            S2, H2 }
                float v36 = (float)(v33 ^ 0xFFu) * 0.0039216;
                _S2 = v36 * _S2;
                __asm { FCVT            H2, S2 }
                v23->i16[0] = LOWORD(_S2);
                *(short float *)&_S2 = *v12;
                __asm { FCVT            S2, H2 }
                _S2 = v36 * _S2;
                __asm { FCVT            H2, S2 }
                *float v12 = *(short float *)&_S2;
              }
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            float v12 = (short float *)((char *)v12 + v31);
            --v32;
          }
          while (v32);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          v12 += v16;
          --v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          int v453 = v14;
          do
          {
            int v454 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              _H1 = 0;
              if (v454 != 255)
              {
                _H1 = v23->i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = (float)((float)(v454 ^ 0xFFu) * 0.0039216) * _S1;
                __asm { FCVT            H1, S1 }
              }
              v23->i16[0] = _H1;
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            --v453;
          }
          while (v453);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          --v17;
        }
        while (v17);
      }
      return;
    case 1:
      unsigned int v40 = v25 & 3;
      if (!v5)
      {
        int v459 = -1 << (8 * v40);
        if ((v25 & 3) != 0) {
          char v460 = v25 & 0xFC;
        }
        else {
          char v460 = v25;
        }
        if ((v25 & 3) != 0)
        {
          int v461 = (unsigned int *)(v25 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v459 = -1;
          int v461 = (unsigned int *)v25;
        }
        if ((v25 & 3) != 0) {
          int v462 = (int16x4_t *)((char *)v23 - 2 * (v25 & 3));
        }
        else {
          int v462 = v23;
        }
        if ((v25 & 3) != 0) {
          int v463 = v40 + v14;
        }
        else {
          int v463 = v14;
        }
        if ((((_BYTE)v463 + v460) & 3) != 0)
        {
          int v464 = 4 - (((_BYTE)v463 + v460) & 3);
          v40 += v464;
          unsigned int v465 = 0xFFFFFFFF >> (8 * v464);
          if (v463 >= 4) {
            unsigned int v466 = v465;
          }
          else {
            unsigned int v466 = 0;
          }
          if (v463 >= 4) {
            unsigned int v465 = -1;
          }
          v459 &= v465;
        }
        else
        {
          unsigned int v466 = 0;
        }
        uint64_t v623 = v26 - v40;
        int v624 = v463 >> 2;
        __asm { FCVT            S1, H0 }
        int16x4_t v626 = vdup_lane_s16((int16x4_t)_Q0.n128_u64[0], 0);
        unint64_t v627 = v27 - v40;
        while (1)
        {
          unsigned int v628 = *v461 & v459;
          int v629 = v624;
          unsigned int v630 = v466;
          if (!v628) {
            goto LABEL_563;
          }
LABEL_545:
          if (v628 == -1)
          {
            *int v462 = v626;
            goto LABEL_563;
          }
          while (1)
          {
            if ((_BYTE)v628)
            {
              _H5 = _Q0.n128_u16[0];
              if (v628 != 255)
              {
                float v632 = (float)v628 * 0.0039216;
                _S6 = v632 * _S1;
                __asm
                {
                  FCVT            H6, S6
                  FCVT            S6, H6
                }
                _H7 = v462->i16[0];
                __asm { FCVT            S7, H7 }
                _S5 = _S6 + (float)(_S7 * (float)(1.0 - v632));
                __asm { FCVT            H5, S5 }
              }
              v462->i16[0] = _H5;
            }
            if (BYTE1(v628))
            {
              _H5 = _Q0.n128_u16[0];
              if (BYTE1(v628) != 255)
              {
                float v639 = (float)BYTE1(v628) * 0.0039216;
                _S6 = v639 * _S1;
                __asm
                {
                  FCVT            H6, S6
                  FCVT            S6, H6
                }
                _H7 = v462->i16[1];
                __asm { FCVT            S7, H7 }
                _S5 = _S6 + (float)(_S7 * (float)(1.0 - v639));
                __asm { FCVT            H5, S5 }
              }
              v462->i16[1] = _H5;
            }
            if (BYTE2(v628))
            {
              _H5 = _Q0.n128_u16[0];
              if (BYTE2(v628) != 255)
              {
                float v646 = (float)BYTE2(v628) * 0.0039216;
                _S6 = v646 * _S1;
                __asm
                {
                  FCVT            H6, S6
                  FCVT            S6, H6
                }
                _H7 = v462->i16[2];
                __asm { FCVT            S7, H7 }
                _S5 = _S6 + (float)(_S7 * (float)(1.0 - v646));
                __asm { FCVT            H5, S5 }
              }
              v462->i16[2] = _H5;
            }
            unsigned int v652 = HIBYTE(v628);
            if (v652 == 255)
            {
              v462->i16[3] = _Q0.n128_u16[0];
            }
            else if (v652)
            {
              float v653 = (float)v652 * 0.0039216;
              _S6 = v653 * _S1;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              _H7 = v462->i16[3];
              __asm { FCVT            S7, H7 }
              _S5 = _S6 + (float)(_S7 * (float)(1.0 - v653));
              __asm { FCVT            H5, S5 }
              v462->i16[3] = LOWORD(_S5);
            }
LABEL_563:
            while (1)
            {
              int v659 = v629;
              ++v462;
              --v629;
              ++v461;
              if (v659 < 2) {
                break;
              }
              unsigned int v628 = *v461;
              if (*v461) {
                goto LABEL_545;
              }
            }
            if (!v630) {
              break;
            }
            unsigned int v630 = 0;
            unsigned int v628 = *v461 & v466;
          }
          int v461 = (unsigned int *)((char *)v461 + v623);
          int v462 = (int16x4_t *)((char *)v462 + 2 * v627);
          if (!--v17) {
            return;
          }
        }
      }
      int v41 = -1 << (8 * v40);
      uint64_t v42 = (unsigned int *)(v25 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v43 = 2 * (v25 & 3);
      int v44 = (int16x4_t *)((char *)v23 - v43);
      int v45 = &v12[v43 / 0xFFFFFFFFFFFFFFFELL];
      if ((v25 & 3) != 0) {
        char v46 = v25 & 0xFC;
      }
      else {
        char v46 = v25;
      }
      if ((v25 & 3) != 0)
      {
        int v47 = v40 + v14;
      }
      else
      {
        int v41 = -1;
        uint64_t v42 = (unsigned int *)v25;
        int v45 = v12;
        int v44 = v23;
        int v47 = v14;
      }
      if ((((_BYTE)v47 + v46) & 3) != 0)
      {
        int v48 = 4 - (((_BYTE)v47 + v46) & 3);
        v40 += v48;
        unsigned int v49 = 0xFFFFFFFF >> (8 * v48);
        if (v47 >= 4) {
          unsigned int v50 = v49;
        }
        else {
          unsigned int v50 = 0;
        }
        if (v47 >= 4) {
          unsigned int v49 = -1;
        }
        v41 &= v49;
      }
      else
      {
        unsigned int v50 = 0;
      }
      uint64_t v499 = v26 - v40;
      unint64_t v500 = v27 - v40;
      int v501 = v47 >> 2;
      __asm { FCVT            S2, H0 }
      unint64_t v503 = v15 - v40;
      do
      {
        unsigned int v504 = *v42 & v41;
        int v505 = v501;
        unsigned int v506 = v50;
        if (!v504) {
          goto LABEL_514;
        }
LABEL_493:
        if (v504 == -1)
        {
          v44->i16[0] = _Q0.n128_u16[0];
          short float *v45 = _H1;
          v44->i16[1] = _Q0.n128_u16[0];
          v45[1] = _H1;
          v44->i16[2] = _Q0.n128_u16[0];
          v45[2] = _H1;
LABEL_511:
          v44->i16[3] = _Q0.n128_u16[0];
          v45[3] = _H1;
          goto LABEL_514;
        }
        while (1)
        {
          if ((_BYTE)v504)
          {
            if (v504 == 255)
            {
              v44->i16[0] = _Q0.n128_u16[0];
              _H5 = _H1;
            }
            else
            {
              float v508 = (float)v504 * 0.0039216;
              _S6 = v508 * _S2;
              __asm { FCVT            H6, S6 }
              _S7 = v508 * _S8;
              __asm
              {
                FCVT            H7, S7
                FCVT            S6, H6
              }
              _H16 = v44->i16[0];
              __asm { FCVT            S16, H16 }
              float v514 = 1.0 - v508;
              _S6 = _S6 + (float)(_S16 * v514);
              __asm { FCVT            H6, S6 }
              v44->i16[0] = LOWORD(_S6);
              __asm { FCVT            S6, H7 }
              *(short float *)&_S7 = *v45;
              __asm { FCVT            S7, H7 }
              _S5 = _S6 + (float)(_S7 * v514);
              __asm { FCVT            H5, S5 }
            }
            short float *v45 = _H5;
          }
          if (BYTE1(v504))
          {
            if (BYTE1(v504) == 255)
            {
              v44->i16[1] = _Q0.n128_u16[0];
              _H5 = _H1;
            }
            else
            {
              float v520 = (float)BYTE1(v504) * 0.0039216;
              _S6 = v520 * _S2;
              __asm { FCVT            H6, S6 }
              _S7 = v520 * _S8;
              __asm
              {
                FCVT            H7, S7
                FCVT            S6, H6
              }
              _H16 = v44->i16[1];
              __asm { FCVT            S16, H16 }
              float v526 = 1.0 - v520;
              _S6 = _S6 + (float)(_S16 * v526);
              __asm { FCVT            H6, S6 }
              v44->i16[1] = LOWORD(_S6);
              __asm { FCVT            S6, H7 }
              *(short float *)&_S7 = v45[1];
              __asm { FCVT            S7, H7 }
              _S5 = _S6 + (float)(_S7 * v526);
              __asm { FCVT            H5, S5 }
            }
            v45[1] = _H5;
          }
          if (BYTE2(v504))
          {
            if (BYTE2(v504) == 255)
            {
              v44->i16[2] = _Q0.n128_u16[0];
              _H5 = _H1;
            }
            else
            {
              float v532 = (float)BYTE2(v504) * 0.0039216;
              _S6 = v532 * _S2;
              __asm { FCVT            H6, S6 }
              _S7 = v532 * _S8;
              __asm
              {
                FCVT            H7, S7
                FCVT            S6, H6
              }
              _H16 = v44->i16[2];
              __asm { FCVT            S16, H16 }
              float v538 = 1.0 - v532;
              _S6 = _S6 + (float)(_S16 * v538);
              __asm { FCVT            H6, S6 }
              v44->i16[2] = LOWORD(_S6);
              __asm { FCVT            S6, H7 }
              *(short float *)&_S7 = v45[2];
              __asm { FCVT            S7, H7 }
              _S5 = _S6 + (float)(_S7 * v538);
              __asm { FCVT            H5, S5 }
            }
            v45[2] = _H5;
          }
          unsigned int v543 = HIBYTE(v504);
          if (v543 == 255) {
            goto LABEL_511;
          }
          if (v543)
          {
            float v544 = (float)v543 * 0.0039216;
            _S6 = v544 * _S2;
            __asm { FCVT            H6, S6 }
            _S7 = v544 * _S8;
            __asm
            {
              FCVT            H7, S7
              FCVT            S6, H6
            }
            _H16 = v44->i16[3];
            __asm { FCVT            S16, H16 }
            float v550 = 1.0 - v544;
            _S6 = _S6 + (float)(_S16 * v550);
            __asm { FCVT            H6, S6 }
            v44->i16[3] = LOWORD(_S6);
            __asm { FCVT            S6, H7 }
            *(short float *)&_S7 = v45[3];
            __asm { FCVT            S7, H7 }
            _S5 = _S6 + (float)(_S7 * v550);
            __asm { FCVT            H5, S5 }
            v45[3] = *(short float *)&_S5;
          }
LABEL_514:
          while (1)
          {
            int v555 = v505;
            ++v44;
            v45 += 4;
            --v505;
            ++v42;
            if (v555 < 2) {
              break;
            }
            unsigned int v504 = *v42;
            if (*v42) {
              goto LABEL_493;
            }
          }
          if (!v506) {
            break;
          }
          unsigned int v506 = 0;
          unsigned int v504 = *v42 & v50;
        }
        uint64_t v42 = (unsigned int *)((char *)v42 + v499);
        int v44 = (int16x4_t *)((char *)v44 + 2 * v500);
        v45 += v503;
        --v17;
      }
      while (v17);
      return;
    case 2:
      float v51 = 1.0 - _S8;
      unsigned int v52 = v25 & 3;
      if (v5)
      {
        int v53 = -1 << (8 * v52);
        unint64_t v54 = (unsigned int *)(v25 & 0xFFFFFFFFFFFFFFFCLL);
        uint64_t v55 = 2 * (v25 & 3);
        unint64_t v56 = (int16x4_t *)((char *)v23 - v55);
        __n128 v57 = &v12[v55 / 0xFFFFFFFFFFFFFFFELL];
        if ((v25 & 3) != 0) {
          char v58 = v25 & 0xFC;
        }
        else {
          char v58 = v25;
        }
        if ((v25 & 3) != 0)
        {
          int v59 = v52 + v14;
        }
        else
        {
          int v53 = -1;
          unint64_t v54 = (unsigned int *)v25;
          __n128 v57 = v12;
          unint64_t v56 = v23;
          int v59 = v14;
        }
        if ((((_BYTE)v59 + v58) & 3) != 0)
        {
          int v60 = 4 - (((_BYTE)v59 + v58) & 3);
          v52 += v60;
          unsigned int v61 = 0xFFFFFFFF >> (8 * v60);
          if (v59 >= 4) {
            unsigned int v62 = v61;
          }
          else {
            unsigned int v62 = 0;
          }
          if (v59 >= 4) {
            unsigned int v61 = -1;
          }
          v53 &= v61;
        }
        else
        {
          unsigned int v62 = 0;
        }
        uint64_t v556 = v26 - v52;
        unint64_t v557 = v27 - v52;
        int v558 = v59 >> 2;
        __asm { FCVT            S0, H0 }
        unint64_t v560 = v15 - v52;
        while (1)
        {
          unsigned int v561 = *v54 & v53;
          int v562 = v558;
          unsigned int v563 = v62;
          if (!v561) {
            goto LABEL_535;
          }
LABEL_524:
          if (v561 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v561)
            {
              float v581 = (float)v561 * 0.0039216;
              _S5 = v581 * _S0;
              __asm { FCVT            H5, S5 }
              _S4 = v581 * _S8;
              __asm
              {
                FCVT            H4, S4
                FCVT            S4, H4
                FCVT            S5, H5
              }
              _H6 = v56->i16[0];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
              __asm { FCVT            H5, S5 }
              v56->i16[0] = LOWORD(_S5);
              *(short float *)&_S5 = *v57;
              __asm { FCVT            S5, H5 }
              _S4 = _S4 + (float)(_S5 * (float)(1.0 - _S4));
              __asm { FCVT            H4, S4 }
              short float *v57 = *(short float *)&_S4;
            }
            if ((v561 & 0xFF00) != 0)
            {
              float v591 = (float)BYTE1(v561) * 0.0039216;
              _S5 = v591 * _S0;
              __asm { FCVT            H5, S5 }
              _S4 = v591 * _S8;
              __asm
              {
                FCVT            H4, S4
                FCVT            S4, H4
                FCVT            S5, H5
              }
              _H6 = v56->i16[1];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
              __asm { FCVT            H5, S5 }
              v56->i16[1] = LOWORD(_S5);
              *(short float *)&_S5 = v57[1];
              __asm { FCVT            S5, H5 }
              _S4 = _S4 + (float)(_S5 * (float)(1.0 - _S4));
              __asm { FCVT            H4, S4 }
              v57[1] = *(short float *)&_S4;
            }
            if ((v561 & 0xFF0000) != 0)
            {
              float v601 = (float)BYTE2(v561) * 0.0039216;
              _S5 = v601 * _S0;
              __asm { FCVT            H5, S5 }
              _S4 = v601 * _S8;
              __asm
              {
                FCVT            H4, S4
                FCVT            S4, H4
                FCVT            S5, H5
              }
              _H6 = v56->i16[2];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
              __asm { FCVT            H5, S5 }
              v56->i16[2] = LOWORD(_S5);
              *(short float *)&_S5 = v57[2];
              __asm { FCVT            S5, H5 }
              _S4 = _S4 + (float)(_S5 * (float)(1.0 - _S4));
              __asm { FCVT            H4, S4 }
              v57[2] = *(short float *)&_S4;
            }
            unsigned int v611 = HIBYTE(v561);
            if (v611)
            {
              float v612 = (float)v611 * 0.0039216;
              _S5 = v612 * _S0;
              __asm { FCVT            H5, S5 }
              _S4 = v612 * _S8;
              __asm
              {
                FCVT            H4, S4
                FCVT            S4, H4
                FCVT            S5, H5
              }
              _H6 = v56->i16[3];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
              __asm { FCVT            H5, S5 }
              v56->i16[3] = LOWORD(_S5);
              *(short float *)&_S5 = v57[3];
              __asm { FCVT            S5, H5 }
              _S4 = _S4 + (float)(_S5 * (float)(1.0 - _S4));
              goto LABEL_534;
            }
LABEL_535:
            while (1)
            {
              int v622 = v562;
              ++v56;
              v57 += 4;
              --v562;
              ++v54;
              if (v622 < 2) {
                break;
              }
              unsigned int v561 = *v54;
              if (*v54) {
                goto LABEL_524;
              }
            }
            if (!v563) {
              break;
            }
            unsigned int v563 = 0;
            unsigned int v561 = *v54 & v62;
          }
          unint64_t v54 = (unsigned int *)((char *)v54 + v556);
          unint64_t v56 = (int16x4_t *)((char *)v56 + 2 * v557);
          v57 += v560;
          if (!--v17) {
            return;
          }
        }
        _H4 = v56->i16[0];
        __asm { FCVT            S4, H4 }
        _S4 = _S0 + (float)(_S4 * v51);
        __asm { FCVT            H4, S4 }
        v56->i16[0] = LOWORD(_S4);
        *(short float *)&_S4 = *v57;
        __asm { FCVT            S4, H4 }
        _S4 = _S8 + (float)(_S4 * v51);
        __asm { FCVT            H4, S4 }
        short float *v57 = *(short float *)&_S4;
        LOWORD(_S4) = v56->i16[1];
        __asm { FCVT            S4, H4 }
        _S4 = _S0 + (float)(_S4 * v51);
        __asm { FCVT            H4, S4 }
        v56->i16[1] = LOWORD(_S4);
        *(short float *)&_S4 = v57[1];
        __asm { FCVT            S4, H4 }
        _S4 = _S8 + (float)(_S4 * v51);
        __asm { FCVT            H4, S4 }
        v57[1] = *(short float *)&_S4;
        LOWORD(_S4) = v56->i16[2];
        __asm { FCVT            S4, H4 }
        _S4 = _S0 + (float)(_S4 * v51);
        __asm { FCVT            H4, S4 }
        v56->i16[2] = LOWORD(_S4);
        *(short float *)&_S4 = v57[2];
        __asm { FCVT            S4, H4 }
        _S4 = _S8 + (float)(_S4 * v51);
        __asm { FCVT            H4, S4 }
        v57[2] = *(short float *)&_S4;
        LOWORD(_S4) = v56->i16[3];
        __asm { FCVT            S4, H4 }
        _S4 = _S0 + (float)(_S4 * v51);
        __asm { FCVT            H4, S4 }
        v56->i16[3] = LOWORD(_S4);
        *(short float *)&_S4 = v57[3];
        __asm { FCVT            S4, H4 }
        _S4 = _S8 + (float)(_S4 * v51);
LABEL_534:
        __asm { FCVT            H4, S4 }
        *((_WORD *)v57 + 3) = _H4;
        goto LABEL_535;
      }
      int v467 = -1 << (8 * v52);
      if ((v25 & 3) != 0) {
        char v468 = v25 & 0xFC;
      }
      else {
        char v468 = v25;
      }
      if ((v25 & 3) != 0)
      {
        uint64_t v469 = (unsigned int *)(v25 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v467 = -1;
        uint64_t v469 = (unsigned int *)v25;
      }
      if ((v25 & 3) != 0) {
        unsigned int v470 = (int16x4_t *)((char *)v23 - 2 * (v25 & 3));
      }
      else {
        unsigned int v470 = v23;
      }
      if ((v25 & 3) != 0) {
        int v471 = v52 + v14;
      }
      else {
        int v471 = v14;
      }
      if ((((_BYTE)v471 + v468) & 3) != 0)
      {
        int v472 = 4 - (((_BYTE)v471 + v468) & 3);
        v52 += v472;
        unsigned int v473 = 0xFFFFFFFF >> (8 * v472);
        if (v471 >= 4) {
          unsigned int v474 = v473;
        }
        else {
          unsigned int v474 = 0;
        }
        if (v471 >= 4) {
          unsigned int v473 = -1;
        }
        v467 &= v473;
      }
      else
      {
        unsigned int v474 = 0;
      }
      uint64_t v660 = v26 - v52;
      int v661 = v471 >> 2;
      __asm { FCVT            S0, H0 }
      unint64_t v663 = v27 - v52;
      while (1)
      {
        unsigned int v664 = *v469 & v467;
        int v665 = v661;
        unsigned int v666 = v474;
        if (!v664) {
          goto LABEL_584;
        }
LABEL_573:
        if (v664 == -1) {
          break;
        }
        while (1)
        {
          if ((_BYTE)v664)
          {
            float v676 = (float)v664 * 0.0039216;
            _S5 = v676 * _S0;
            __asm { FCVT            H5, S5 }
            _S4 = v676 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCVT            S5, H5
            }
            _H6 = v470->i16[0];
            __asm
            {
              FCVT            S6, H6
              FCVT            S4, H4
            }
            _S4 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
            __asm { FCVT            H4, S4 }
            v470->i16[0] = LOWORD(_S4);
          }
          if ((v664 & 0xFF00) != 0)
          {
            float v684 = (float)BYTE1(v664) * 0.0039216;
            _S5 = v684 * _S0;
            __asm { FCVT            H5, S5 }
            _S4 = v684 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCVT            S5, H5
            }
            _H6 = v470->i16[1];
            __asm
            {
              FCVT            S6, H6
              FCVT            S4, H4
            }
            _S4 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
            __asm { FCVT            H4, S4 }
            v470->i16[1] = LOWORD(_S4);
          }
          if ((v664 & 0xFF0000) != 0)
          {
            float v692 = (float)BYTE2(v664) * 0.0039216;
            _S5 = v692 * _S0;
            __asm { FCVT            H5, S5 }
            _S4 = v692 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCVT            S5, H5
            }
            _H6 = v470->i16[2];
            __asm
            {
              FCVT            S6, H6
              FCVT            S4, H4
            }
            _S4 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
            __asm { FCVT            H4, S4 }
            v470->i16[2] = LOWORD(_S4);
          }
          unsigned int v700 = HIBYTE(v664);
          if (v700)
          {
            float v701 = (float)v700 * 0.0039216;
            _S5 = v701 * _S0;
            __asm { FCVT            H5, S5 }
            _S4 = v701 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCVT            S5, H5
            }
            _H6 = v470->i16[3];
            __asm
            {
              FCVT            S6, H6
              FCVT            S4, H4
            }
            _S4 = _S5 + (float)(_S6 * (float)(1.0 - _S4));
            goto LABEL_583;
          }
LABEL_584:
          while (1)
          {
            int v709 = v665;
            ++v470;
            --v665;
            ++v469;
            if (v709 < 2) {
              break;
            }
            unsigned int v664 = *v469;
            if (*v469) {
              goto LABEL_573;
            }
          }
          if (!v666) {
            break;
          }
          unsigned int v666 = 0;
          unsigned int v664 = *v469 & v474;
        }
        uint64_t v469 = (unsigned int *)((char *)v469 + v660);
        unsigned int v470 = (int16x4_t *)((char *)v470 + 2 * v663);
        if (!--v17) {
          return;
        }
      }
      _H4 = v470->i16[0];
      __asm { FCVT            S4, H4 }
      _S4 = _S0 + (float)(_S4 * v51);
      __asm { FCVT            H4, S4 }
      v470->i16[0] = LOWORD(_S4);
      LOWORD(_S4) = v470->i16[1];
      __asm { FCVT            S4, H4 }
      _S4 = _S0 + (float)(_S4 * v51);
      __asm { FCVT            H4, S4 }
      v470->i16[1] = LOWORD(_S4);
      LOWORD(_S4) = v470->i16[2];
      __asm { FCVT            S4, H4 }
      _S4 = _S0 + (float)(_S4 * v51);
      __asm { FCVT            H4, S4 }
      v470->i16[2] = LOWORD(_S4);
      LOWORD(_S4) = v470->i16[3];
      __asm { FCVT            S4, H4 }
      _S4 = _S0 + (float)(_S4 * v51);
LABEL_583:
      __asm { FCVT            H4, S4 }
      v470->i16[3] = _H4;
      goto LABEL_584;
    case 3:
      __asm { FCVT            S2, H0; jumptable 0000000185084AFC case 3 }
      uint64_t v64 = 2 * v13;
      do
      {
        int v65 = v14;
        do
        {
          unsigned int v66 = *(unsigned __int8 *)v25;
          if (*(unsigned char *)v25)
          {
            if (v66 == 255)
            {
              _H5 = _H1 * *v12;
              *(short float *)v23->i16 = *(short float *)_Q0.n128_u16 * *v12;
            }
            else
            {
              float v68 = (float)v66 * 0.0039216;
              _H6 = *v12;
              __asm { FCVT            S6, H6 }
              _S16 = (float)(v68 * _S6) * _S2;
              __asm { FCVT            H16, S16 }
              _S7 = (float)(v68 * _S6) * _S8;
              __asm
              {
                FCVT            H7, S7
                FCVT            S16, H16
              }
              _H17 = v23->i16[0];
              __asm { FCVT            S17, H17 }
              float v76 = 1.0 - v68;
              _S16 = _S16 + (float)(_S17 * v76);
              __asm { FCVT            H16, S16 }
              v23->i16[0] = LOWORD(_S16);
              __asm { FCVT            S7, H7 }
              _S5 = _S7 + (float)(_S6 * v76);
              __asm { FCVT            H5, S5 }
            }
            *float v12 = _H5;
          }
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v64);
          --v65;
        }
        while (v65);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        --v17;
      }
      while (v17);
      return;
    case 4:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 4 }
      uint64_t v81 = 2 * v13;
      do
      {
        int v82 = v14;
        do
        {
          unsigned int v83 = *(unsigned __int8 *)v25;
          if (*(unsigned char *)v25)
          {
            if (v83 == 255)
            {
              _H3 = *v12;
              __asm { FCVT            S3, H3 }
              float v86 = 1.0 - _S3;
              _S4 = v86 * _S0;
              __asm { FCVT            H4, S4 }
              _S3 = v86 * _S8;
              v23->i16[0] = LOWORD(_S4);
            }
            else
            {
              float v89 = (float)v83 * 0.0039216;
              _H4 = *v12;
              __asm { FCVT            S4, H4 }
              float v92 = v89 * (float)(1.0 - _S4);
              _S6 = v92 * _S0;
              __asm { FCVT            H6, S6 }
              _S5 = v92 * _S8;
              __asm
              {
                FCVT            H5, S5
                FCVT            S6, H6
              }
              _H7 = v23->i16[0];
              __asm { FCVT            S7, H7 }
              float v98 = 1.0 - v89;
              _S6 = _S6 + (float)(_S7 * v98);
              __asm { FCVT            H6, S6 }
              v23->i16[0] = LOWORD(_S6);
              __asm { FCVT            S5, H5 }
              _S3 = _S5 + (float)(_S4 * v98);
            }
            __asm { FCVT            H3, S3 }
            *(_WORD *)float v12 = _H3;
          }
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v81);
          --v82;
        }
        while (v82);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        --v17;
      }
      while (v17);
      return;
    case 5:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 5 }
      uint64_t v103 = 2 * v13;
      do
      {
        int v104 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            _H3 = *v12;
            __asm { FCVT            S3, H3 }
            float v107 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S5 = v107 * _S0;
            __asm { FCVT            H5, S5 }
            _S4 = v107 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
              FCVT            S5, H5
            }
            _H6 = v23->i16[0];
            __asm { FCVT            S6, H6 }
            _S5 = (float)((float)(1.0 - _S4) * _S6) + (float)(_S5 * _S3);
            __asm { FCVT            H5, S5 }
            v23->i16[0] = LOWORD(_S5);
            _S3 = (float)((float)(1.0 - _S4) * _S3) + (float)(_S4 * _S3);
            __asm { FCVT            H3, S3 }
            *float v12 = *(short float *)&_S3;
          }
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v103);
          --v104;
        }
        while (v104);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        --v17;
      }
      while (v17);
      return;
    case 6:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 6 }
      uint64_t v117 = 2 * v13;
      while (1)
      {
        int v118 = v14;
        do
        {
          unsigned int v119 = *(unsigned __int8 *)v25;
          if (!*(unsigned char *)v25) {
            goto LABEL_85;
          }
          _H3 = *v12;
          __asm { FCVT            S3, H3 }
          float v122 = 1.0 - _S3;
          if ((float)(1.0 - _S3) >= 1.0)
          {
            float v132 = (float)v119 * 0.0039216;
            _S4 = v132 * _S0;
            __asm { FCVT            H4, S4 }
            _S3 = v132 * _S8;
            v23->i16[0] = LOWORD(_S4);
          }
          else
          {
            if (v122 <= 0.0) {
              goto LABEL_85;
            }
            float v123 = (float)v119 * 0.0039216;
            _S6 = v123 * _S0;
            __asm { FCVT            H6, S6 }
            _S5 = v123 * _S8;
            __asm { FCVT            H5, S5 }
            _H7 = v23->i16[0];
            __asm
            {
              FCVT            S7, H7
              FCVT            S6, H6
            }
            _S6 = _S7 + (float)(_S6 * v122);
            __asm { FCVT            H6, S6 }
            v23->i16[0] = LOWORD(_S6);
            __asm { FCVT            S5, H5 }
            _S3 = _S3 + (float)(_S5 * v122);
          }
          __asm { FCVT            H3, S3 }
          *(_WORD *)float v12 = _H3;
LABEL_85:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v117);
          --v118;
        }
        while (v118);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 7:
      if (v5)
      {
        uint64_t v135 = 2 * v13;
        do
        {
          int v136 = v14;
          do
          {
            unsigned int v137 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v137 == 255)
              {
                *(short float *)v23->i16 = _H1 * *(short float *)v23->i16;
                _H3 = _H1 * *v12;
              }
              else
              {
                _H4 = v23->i16[0];
                __asm { FCVT            S4, H4 }
                float v141 = (float)((float)((float)v137 * 0.0039216) * _S8) + (float)(1.0 - (float)((float)v137 * 0.0039216));
                _S4 = v141 * _S4;
                __asm { FCVT            H4, S4 }
                v23->i16[0] = LOWORD(_S4);
                *(short float *)&_S4 = *v12;
                __asm { FCVT            S4, H4 }
                _S3 = v141 * _S4;
                __asm { FCVT            H3, S3 }
              }
              *float v12 = _H3;
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            float v12 = (short float *)((char *)v12 + v135);
            --v136;
          }
          while (v136);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          v12 += v16;
          --v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          int v475 = v14;
          do
          {
            unsigned int v476 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v476 == 255)
              {
                _H3 = _H1 * *(short float *)v23->i16;
              }
              else
              {
                _H4 = v23->i16[0];
                __asm { FCVT            S4, H4 }
                _S3 = (float)((float)((float)((float)v476 * 0.0039216) * _S8)
                            + (float)(1.0 - (float)((float)v476 * 0.0039216)))
                    * _S4;
                __asm { FCVT            H3, S3 }
              }
              *(short float *)v23->i16 = _H3;
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            --v475;
          }
          while (v475);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          --v17;
        }
        while (v17);
      }
      return;
    case 8:
      float v145 = 1.0 - _S8;
      if (v5)
      {
        uint64_t v146 = 2 * v13;
        do
        {
          int v147 = v14;
          do
          {
            unsigned int v148 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              _H3 = v23->i16[0];
              if (v148 == 255)
              {
                __asm { FCVT            S3, H3 }
                _S4 = v145 * _S3;
                float v152 = 1.0 - _S8;
              }
              else
              {
                __asm { FCVT            S4, H3 }
                float v152 = (float)((float)((float)v148 * -0.0039216) * _S8) + 1.0;
                _S4 = v152 * _S4;
              }
              __asm { FCVT            H4, S4 }
              v23->i16[0] = _H4;
              _H4 = *v12;
              __asm { FCVT            S4, H4 }
              _S3 = v152 * _S4;
              __asm { FCVT            H3, S3 }
              *float v12 = *(short float *)&_S3;
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            float v12 = (short float *)((char *)v12 + v146);
            --v147;
          }
          while (v147);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          v12 += v16;
          --v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          int v481 = v14;
          do
          {
            unsigned int v482 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              _H3 = v23->i16[0];
              if (v482 == 255)
              {
                __asm { FCVT            S3, H3 }
                _S3 = v145 * _S3;
              }
              else
              {
                __asm { FCVT            S3, H3 }
                _S3 = (float)((float)((float)((float)v482 * -0.0039216) * _S8) + 1.0) * _S3;
              }
              __asm { FCVT            H3, S3 }
              v23->i16[0] = _H3;
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            --v481;
          }
          while (v481);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          --v17;
        }
        while (v17);
      }
      return;
    case 9:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 9 }
      uint64_t v159 = 2 * v13;
      do
      {
        int v160 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v161 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _H4 = *v12;
            __asm { FCVT            S4, H4 }
            _S5 = v161 * _S0;
            __asm { FCVT            H5, S5 }
            _S6 = v161 * _S8;
            __asm
            {
              FCVT            H6, S6
              FCVT            S6, H6
              FCVT            S5, H5
            }
            _H16 = v23->i16[0];
            __asm { FCVT            S16, H16 }
            float v170 = (float)(1.0 - v161) + _S6;
            _S5 = (float)(v170 * _S16) + (float)(_S5 * (float)(1.0 - _S4));
            __asm { FCVT            H5, S5 }
            v23->i16[0] = LOWORD(_S5);
            _S3 = (float)(v170 * _S4) + (float)(_S6 * (float)(1.0 - _S4));
            __asm { FCVT            H3, S3 }
            *float v12 = *(short float *)&_S3;
          }
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v159);
          --v160;
        }
        while (v160);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        --v17;
      }
      while (v17);
      return;
    case 10:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 10 }
      uint64_t v174 = 2 * v13;
      do
      {
        int v175 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            _H3 = *v12;
            __asm { FCVT            S3, H3 }
            float v178 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S5 = v178 * _S0;
            __asm { FCVT            H5, S5 }
            _S4 = v178 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
              FCVT            S5, H5
            }
            _H7 = v23->i16[0];
            __asm { FCVT            S7, H7 }
            _S5 = (float)((float)(1.0 - _S4) * _S7) + (float)(_S5 * (float)(1.0 - _S3));
            __asm { FCVT            H5, S5 }
            v23->i16[0] = LOWORD(_S5);
            _S3 = (float)((float)(1.0 - _S4) * _S3) + (float)(_S4 * (float)(1.0 - _S3));
            __asm { FCVT            H3, S3 }
            *float v12 = *(short float *)&_S3;
          }
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v174);
          --v175;
        }
        while (v175);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        --v17;
      }
      while (v17);
      return;
    case 11:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 11 }
      if (v5)
      {
        uint64_t v188 = 2 * v13;
        do
        {
          int v189 = v14;
          do
          {
            if (*(unsigned char *)v25)
            {
              float v190 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              _S4 = v190 * _S0;
              __asm { FCVT            H4, S4 }
              _S3 = v190 * _S8;
              __asm { FCVT            H3, S3 }
              _H5 = *v12;
              __asm
              {
                FCVT            S5, H5
                FCVT            S3, H3
              }
              float v196 = _S3 + _S5;
              _H7 = v23->i16[0];
              __asm
              {
                FCVT            S7, H7
                FCVT            S4, H4
              }
              float v200 = (float)(_S3 - _S4) + (float)(_S5 - _S7);
              if (v196 <= 1.0) {
                _S4 = v196;
              }
              else {
                _S4 = 1.0;
              }
              __asm { FCVT            H5, S4 }
              *(_WORD *)float v12 = _H5;
              _S3 = _S4 - v200;
              __asm { FCVT            H3, S3 }
              v23->i16[0] = LOWORD(_S3);
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            float v12 = (short float *)((char *)v12 + v188);
            --v189;
          }
          while (v189);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          v12 += v16;
          --v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          int v488 = v14;
          do
          {
            if (*(unsigned char *)v25)
            {
              float v489 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              _S4 = v489 * _S0;
              __asm { FCVT            H4, S4 }
              _S3 = v489 * _S8;
              __asm { FCVT            H3, S3 }
              _H5 = v23->i16[0];
              __asm
              {
                FCVT            S5, H5
                FCVT            S3, H3
                FCVT            S4, H4
              }
              _S3 = 1.0 - (float)((float)(_S3 - _S4) + (float)(1.0 - _S5));
              __asm { FCVT            H3, S3 }
              v23->i16[0] = LOWORD(_S3);
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            --v488;
          }
          while (v488);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          --v17;
        }
        while (v17);
      }
      return;
    case 12:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 12 }
      if (v5)
      {
        uint64_t v205 = 2 * v13;
        do
        {
          int v206 = v14;
          do
          {
            if (*(unsigned char *)v25)
            {
              float v207 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              _S4 = v207 * _S0;
              __asm { FCVT            H4, S4 }
              _S3 = v207 * _S8;
              __asm { FCVT            H3, S3 }
              _H5 = *v12;
              __asm
              {
                FCVT            S5, H5
                FCVT            S3, H3
              }
              _S3 = _S3 + _S5;
              if (_S3 > 1.0) {
                _S3 = 1.0;
              }
              *(short float *)v23->i16 = *(short float *)v23->i16 + _H4;
              __asm { FCVT            H3, S3 }
              *(_WORD *)float v12 = _H3;
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            float v12 = (short float *)((char *)v12 + v205);
            --v206;
          }
          while (v206);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          v12 += v16;
          --v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          int v497 = v14;
          do
          {
            if (*(unsigned char *)v25)
            {
              _S2 = (float)((float)*(unsigned __int8 *)v25 * 0.0039216) * _S0;
              __asm { FCVT            H2, S2 }
              *(short float *)v23->i16 = *(short float *)v23->i16 + *(short float *)&_S2;
            }
            ++v25;
            uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
            --v497;
          }
          while (v497);
          v25 += v26;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
          --v17;
        }
        while (v17);
      }
      return;
    case 13:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 13 }
      uint64_t v217 = 2 * v13;
      while (1)
      {
        int v218 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v219 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S4 = v219 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S5 = v219 * _S0;
              __asm { FCVT            H5, S5 }
              if (v5)
              {
                __asm { FCMP            H6, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_160;
                }
                __asm { FCVT            S6, H6 }
              }
              else
              {
                _S6 = 1.0;
              }
              __asm { FCVT            S7, H4 }
              _H16 = v23->i16[0];
              __asm
              {
                FCVT            S16, H16
                FCVT            S5, H5
              }
              float v230 = _S5 * _S16;
              float v231 = (float)(_S5 * _S16) + (float)(_S16 * (float)(1.0 - _S7));
              if (_H4 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                _S4 = v230;
              }
              else {
                _S4 = v231;
              }
              float v233 = _S4 + (float)(_S5 * (float)(1.0 - _S6));
              if (_S6 != 1.0) {
                _S4 = v233;
              }
              __asm { FCVT            H5, S4 }
              if (v5)
              {
                _S4 = (float)(_S6 + _S7) - (float)(_S6 * _S7);
                __asm { FCVT            H4, S4 }
LABEL_160:
                v23->i16[0] = _H5;
                *float v12 = _H4;
                goto LABEL_162;
              }
              v23->i16[0] = _H5;
            }
          }
LABEL_162:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v217);
          --v218;
        }
        while (v218);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 14:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 14 }
      uint64_t v236 = 2 * v13;
      while (1)
      {
        int v237 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v238 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S3 = v238 * _S8;
            __asm
            {
              FCVT            H3, S3
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S4 = v238 * _S0;
              __asm { FCVT            H4, S4 }
              if (v5)
              {
                __asm { FCMP            H5, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_175;
                }
                __asm { FCVT            S5, H5 }
              }
              else
              {
                _S5 = 1.0;
              }
              _H6 = v23->i16[0];
              __asm
              {
                FCVT            S6, H6
                FCVT            S4, H4
              }
              _S4 = _S6 + (float)(_S4 * (float)(1.0 - _S6));
              __asm { FCVT            H4, S4 }
              if (v5)
              {
                __asm { FCVT            S3, H3 }
                _S3 = (float)(_S5 + _S3) - (float)(_S5 * _S3);
                __asm { FCVT            H3, S3 }
LABEL_175:
                v23->i16[0] = _H4;
                *(_WORD *)float v12 = _H3;
                goto LABEL_177;
              }
              v23->i16[0] = _H4;
            }
          }
LABEL_177:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v236);
          --v237;
        }
        while (v237);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 15:
      __asm { FCVT            S9, H0; jumptable 0000000185084AFC case 15 }
      uint64_t v252 = 2 * v13;
      while (1)
      {
        int v253 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v254 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S1 = v254 * _S8;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _Q0.n128_f32[0] = v254 * _S9;
              __asm { FCVT            H2, S0 }
              if (v5)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_189;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = v23->i16[0];
              _Q0.n128_u32[0] = PDAoverlayPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u32[0] = _Q0.n128_u32[0];
              if (v5)
              {
LABEL_189:
                v23->i16[0] = _Q2.n128_u16[0];
                *(_WORD *)float v12 = _H1;
                goto LABEL_191;
              }
              v23->i16[0] = _Q0.n128_u16[0];
            }
          }
LABEL_191:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v252);
          --v253;
        }
        while (v253);
        v25 += v28;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v710);
        v12 += v30;
        --v17;
        int v14 = v29;
        if (!v17) {
          return;
        }
      }
    case 16:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 16 }
      uint64_t v261 = 2 * v13;
      while (1)
      {
        int v262 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v263 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S4 = v263 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S5 = v263 * _S0;
              __asm { FCVT            H5, S5 }
              if (v5)
              {
                __asm { FCMP            H6, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_211;
                }
                __asm { FCVT            S6, H6 }
              }
              else
              {
                _S6 = 1.0;
              }
              __asm { FCVT            S7, H4 }
              _H16 = v23->i16[0];
              __asm
              {
                FCVT            S16, H16
                FCVT            S5, H5
              }
              float v274 = _S7 * _S16;
              if ((float)(_S6 * _S5) < (float)(_S7 * _S16)) {
                float v274 = _S6 * _S5;
              }
              float v275 = v274 + (float)(_S16 * (float)(1.0 - _S7));
              if (_H4 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                _S4 = v274;
              }
              else {
                _S4 = v275;
              }
              float v277 = _S4 + (float)(_S5 * (float)(1.0 - _S6));
              if (_S6 != 1.0) {
                _S4 = v277;
              }
              __asm { FCVT            H5, S4 }
              if (v5)
              {
                _S4 = (float)(_S6 + _S7) - (float)(_S6 * _S7);
                __asm { FCVT            H4, S4 }
LABEL_211:
                v23->i16[0] = _H5;
                *float v12 = _H4;
                goto LABEL_213;
              }
              v23->i16[0] = _H5;
            }
          }
LABEL_213:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v261);
          --v262;
        }
        while (v262);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 17:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 17 }
      uint64_t v280 = 2 * v13;
      while (1)
      {
        int v281 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v282 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S4 = v282 * _S8;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S5 = v282 * _S0;
              __asm { FCVT            H5, S5 }
              if (v5)
              {
                __asm { FCMP            H6, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_233;
                }
                __asm { FCVT            S6, H6 }
              }
              else
              {
                _S6 = 1.0;
              }
              __asm { FCVT            S7, H4 }
              _H16 = v23->i16[0];
              __asm
              {
                FCVT            S16, H16
                FCVT            S5, H5
              }
              float v293 = _S7 * _S16;
              if ((float)(_S6 * _S5) > (float)(_S7 * _S16)) {
                float v293 = _S6 * _S5;
              }
              float v294 = v293 + (float)(_S16 * (float)(1.0 - _S7));
              if (_H4 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                _S4 = v293;
              }
              else {
                _S4 = v294;
              }
              float v296 = _S4 + (float)(_S5 * (float)(1.0 - _S6));
              if (_S6 != 1.0) {
                _S4 = v296;
              }
              __asm { FCVT            H5, S4 }
              if (v5)
              {
                _S4 = (float)(_S6 + _S7) - (float)(_S6 * _S7);
                __asm { FCVT            H4, S4 }
LABEL_233:
                v23->i16[0] = _H5;
                *float v12 = _H4;
                goto LABEL_235;
              }
              v23->i16[0] = _H5;
            }
          }
LABEL_235:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v280);
          --v281;
        }
        while (v281);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 18:
      __asm { FCVT            S9, H0; jumptable 0000000185084AFC case 18 }
      uint64_t v299 = 2 * v13;
      while (1)
      {
        int v300 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v301 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S1 = v301 * _S8;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _Q0.n128_f32[0] = v301 * _S9;
              __asm { FCVT            H2, S0 }
              if (v5)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_247;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = v23->i16[0];
              _Q0.n128_u32[0] = PDAcolordodgePDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u32[0] = _Q0.n128_u32[0];
              if (v5)
              {
LABEL_247:
                v23->i16[0] = _Q2.n128_u16[0];
                *(_WORD *)float v12 = _H1;
                goto LABEL_249;
              }
              v23->i16[0] = _Q0.n128_u16[0];
            }
          }
LABEL_249:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v299);
          --v300;
        }
        while (v300);
        v25 += v28;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v710);
        v12 += v30;
        --v17;
        int v14 = v29;
        if (!v17) {
          return;
        }
      }
    case 19:
      __asm { FCVT            S9, H0; jumptable 0000000185084AFC case 19 }
      uint64_t v308 = 2 * v13;
      while (1)
      {
        int v309 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v310 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S1 = v310 * _S8;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _Q0.n128_f32[0] = v310 * _S9;
              __asm { FCVT            H2, S0 }
              if (v5)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_261;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = v23->i16[0];
              _Q0.n128_u32[0] = PDAcolorburnPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u32[0] = _Q0.n128_u32[0];
              if (v5)
              {
LABEL_261:
                v23->i16[0] = _Q2.n128_u16[0];
                *(_WORD *)float v12 = _H1;
                goto LABEL_263;
              }
              v23->i16[0] = _Q0.n128_u16[0];
            }
          }
LABEL_263:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v308);
          --v309;
        }
        while (v309);
        v25 += v28;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v710);
        v12 += v30;
        --v17;
        int v14 = v29;
        if (!v17) {
          return;
        }
      }
    case 20:
      __asm { FCVT            S9, H0; jumptable 0000000185084AFC case 20 }
      uint64_t v317 = 2 * v13;
      while (1)
      {
        int v318 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v319 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S1 = v319 * _S8;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _Q0.n128_f32[0] = v319 * _S9;
              __asm { FCVT            H2, S0 }
              if (v5)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_275;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = v23->i16[0];
              _Q0.n128_u32[0] = PDAsoftlightPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u32[0] = _Q0.n128_u32[0];
              if (v5)
              {
LABEL_275:
                v23->i16[0] = _Q2.n128_u16[0];
                *(_WORD *)float v12 = _H1;
                goto LABEL_277;
              }
              v23->i16[0] = _Q0.n128_u16[0];
            }
          }
LABEL_277:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v317);
          --v318;
        }
        while (v318);
        v25 += v28;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v710);
        v12 += v30;
        --v17;
        int v14 = v29;
        if (!v17) {
          return;
        }
      }
    case 21:
      __asm { FCVT            S9, H0; jumptable 0000000185084AFC case 21 }
      uint64_t v326 = 2 * v13;
      while (1)
      {
        int v327 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v328 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S1 = v328 * _S8;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _Q0.n128_f32[0] = v328 * _S9;
              __asm { FCVT            H2, S0 }
              if (v5)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_289;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = v23->i16[0];
              _Q0.n128_u32[0] = PDAhardlightPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u32[0] = _Q0.n128_u32[0];
              if (v5)
              {
LABEL_289:
                v23->i16[0] = _Q2.n128_u16[0];
                *(_WORD *)float v12 = _H1;
                goto LABEL_291;
              }
              v23->i16[0] = _Q0.n128_u16[0];
            }
          }
LABEL_291:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v326);
          --v327;
        }
        while (v327);
        v25 += v28;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v710);
        v12 += v30;
        --v17;
        int v14 = v29;
        if (!v17) {
          return;
        }
      }
    case 22:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 22 }
      uint64_t v335 = 2 * v13;
      while (1)
      {
        int v336 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v337 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S3 = v337 * _S8;
            __asm
            {
              FCVT            H3, S3
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S2 = v337 * _S0;
              __asm { FCVT            H2, S2 }
              if (v5)
              {
                __asm { FCMP            H4, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_306;
                }
                __asm { FCVT            S4, H4 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H3 }
              _H5 = v23->i16[0];
              __asm
              {
                FCVT            S5, H5
                FCVT            S2, H2
              }
              float v348 = _S2 + _S5;
              float v349 = _S3 * _S5;
              float v350 = _S4 * _S2;
              float v351 = v348 - v349;
              float v352 = v349 - v350;
              float v353 = v351 - v350;
              if (v352 < 0.0) {
                float v352 = -v352;
              }
              _S2 = v353 + v352;
              __asm { FCVT            H2, S2 }
              if (v5)
              {
                _S3 = (float)(_S4 + _S3) - (float)(_S4 * _S3);
                __asm { FCVT            H3, S3 }
LABEL_306:
                v23->i16[0] = _H2;
                *(_WORD *)float v12 = _H3;
                goto LABEL_308;
              }
              v23->i16[0] = _H2;
            }
          }
LABEL_308:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v335);
          --v336;
        }
        while (v336);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 23:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 23 }
      uint64_t v357 = 2 * v13;
      while (1)
      {
        int v358 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v359 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S3 = v359 * _S8;
            __asm
            {
              FCVT            H3, S3
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S4 = v359 * _S0;
              __asm { FCVT            H4, S4 }
              if (v5)
              {
                __asm { FCMP            H5, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_321;
                }
                __asm { FCVT            S5, H5 }
              }
              else
              {
                _S5 = 1.0;
              }
              _H6 = v23->i16[0];
              __asm
              {
                FCVT            S6, H6
                FCVT            S4, H4
              }
              _S4 = (float)(_S4 + _S6) + (float)((float)(_S4 * _S6) * -2.0);
              __asm { FCVT            H4, S4 }
              if (v5)
              {
                __asm { FCVT            S3, H3 }
                _S3 = (float)(_S5 + _S3) - (float)(_S5 * _S3);
                __asm { FCVT            H3, S3 }
LABEL_321:
                v23->i16[0] = _H4;
                *(_WORD *)float v12 = _H3;
                goto LABEL_323;
              }
              v23->i16[0] = _H4;
            }
          }
LABEL_323:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v357);
          --v358;
        }
        while (v358);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 24:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 24 }
      uint64_t v373 = 2 * v13;
      LOWORD(v374) = COERCE_UNSIGNED_INT(1.0);
      while (1)
      {
        int v375 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v376 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S5 = v376 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCMP            H5, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S6 = v376 * _S0;
              __asm { FCVT            H6, S6 }
              if (v5)
              {
                __asm { FCMP            H7, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_344;
                }
                __asm { FCVT            S7, H7 }
              }
              else
              {
                _S7 = 1.0;
              }
              __asm { FCVT            S16, H5 }
              _H17 = v23->i16[0];
              __asm
              {
                FCVT            S17, H17
                FCVT            S6, H6
              }
              _ZF = _H5 == v374;
              if (_H5 == v374) {
                float v388 = _S17;
              }
              else {
                float v388 = _S16 * _S17;
              }
              if (_ZF) {
                float v389 = 0.0;
              }
              else {
                float v389 = _S17 - (float)(_S16 * _S17);
              }
              float v390 = (float)(v389 + _S6) - (float)(_S7 * _S6);
              if (_S7 == 1.0) {
                float v390 = v389;
              }
              _S5 = v388 + v390;
              __asm { FCVT            H6, S5 }
              if (v5)
              {
                _S5 = (float)(_S7 + _S16) - (float)(_S7 * _S16);
                __asm { FCVT            H5, S5 }
LABEL_344:
                v23->i16[0] = _H6;
                *float v12 = _H5;
                goto LABEL_346;
              }
              v23->i16[0] = _H6;
            }
          }
LABEL_346:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v373);
          --v375;
        }
        while (v375);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 25:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 25 }
      uint64_t v394 = 2 * v13;
      LOWORD(v395) = COERCE_UNSIGNED_INT(1.0);
      while (1)
      {
        int v396 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v397 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S5 = v397 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCMP            H5, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S6 = v397 * _S0;
              __asm { FCVT            H6, S6 }
              if (v5)
              {
                __asm { FCMP            H7, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_367;
                }
                __asm { FCVT            S7, H7 }
              }
              else
              {
                _S7 = 1.0;
              }
              __asm { FCVT            S16, H5 }
              _H17 = v23->i16[0];
              __asm
              {
                FCVT            S17, H17
                FCVT            S6, H6
              }
              BOOL v408 = _H5 == v395;
              if (_H5 == v395) {
                float v409 = _S17;
              }
              else {
                float v409 = _S16 * _S17;
              }
              if (v408) {
                float v410 = 0.0;
              }
              else {
                float v410 = _S17 - (float)(_S16 * _S17);
              }
              float v411 = (float)(v410 + _S6) - (float)(_S7 * _S6);
              if (_S7 == 1.0) {
                float v411 = v410;
              }
              _S5 = v409 + v411;
              __asm { FCVT            H6, S5 }
              if (v5)
              {
                _S5 = (float)(_S7 + _S16) - (float)(_S7 * _S16);
                __asm { FCVT            H5, S5 }
LABEL_367:
                v23->i16[0] = _H6;
                *float v12 = _H5;
                goto LABEL_369;
              }
              v23->i16[0] = _H6;
            }
          }
LABEL_369:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v394);
          --v396;
        }
        while (v396);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 26:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 26 }
      uint64_t v415 = 2 * v13;
      LOWORD(v416) = COERCE_UNSIGNED_INT(1.0);
      while (1)
      {
        int v417 = v14;
        do
        {
          if (*(unsigned char *)v25)
          {
            float v418 = (float)*(unsigned __int8 *)v25 * 0.0039216;
            _S5 = v418 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCMP            H5, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _S6 = v418 * _S0;
              __asm { FCVT            H6, S6 }
              if (v5)
              {
                __asm { FCMP            H7, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_389;
                }
                __asm { FCVT            S7, H7 }
              }
              else
              {
                _S7 = 1.0;
              }
              __asm { FCVT            S16, H5 }
              _H17 = v23->i16[0];
              __asm
              {
                FCVT            S17, H17
                FCVT            S6, H6
              }
              float v429 = _S6 - (float)(_S7 * _S6);
              if (_S7 == 1.0) {
                float v429 = 0.0;
              }
              BOOL v430 = _H5 == v416;
              if (_H5 == v416) {
                float v431 = _S17;
              }
              else {
                float v431 = _S16 * _S17;
              }
              if (!v430) {
                float v429 = (float)(v429 + _S17) - (float)(_S16 * _S17);
              }
              _S5 = v431 + v429;
              __asm { FCVT            H6, S5 }
              if (v5)
              {
                _S5 = (float)(_S7 + _S16) - (float)(_S7 * _S16);
                __asm { FCVT            H5, S5 }
LABEL_389:
                v23->i16[0] = _H6;
                *float v12 = _H5;
                goto LABEL_391;
              }
              v23->i16[0] = _H6;
            }
          }
LABEL_391:
          ++v25;
          uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
          float v12 = (short float *)((char *)v12 + v415);
          --v417;
        }
        while (v417);
        v25 += v26;
        uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
        v12 += v16;
        if (!--v17) {
          return;
        }
      }
    case 27:
      __asm { FCVT            S0, H0; jumptable 0000000185084AFC case 27 }
      uint64_t v435 = 2 * v13;
      break;
    default:
      return;
  }
  do
  {
    int v436 = v14;
    do
    {
      if (*(unsigned char *)v25)
      {
        float v437 = (float)*(unsigned __int8 *)v25 * 0.0039216;
        _S5 = v437 * _S8;
        __asm
        {
          FCVT            H5, S5
          FCMP            H5, #0
        }
        if (!(_NF ^ _VF | _ZF))
        {
          _S6 = v437 * _S0;
          __asm { FCVT            H6, S6 }
          if (v5)
          {
            __asm { FCMP            H7, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_409;
            }
            __asm { FCVT            S7, H7 }
          }
          else
          {
            _S7 = 1.0;
          }
          __asm { FCVT            S16, H5 }
          _H17 = v23->i16[0];
          __asm
          {
            FCVT            S6, H6
            FCVT            S17, H17
          }
          float v448 = _S17 - (float)(_S16 * _S17);
          if (_H5 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
            float v449 = 0.0;
          }
          else {
            float v449 = v448;
          }
          float v450 = (float)(v449 + _S6) - (float)(_S7 * _S6);
          if (_S7 != 1.0)
          {
            _S6 = _S7 * _S6;
            float v449 = v450;
          }
          _S5 = _S6 + v449;
          __asm { FCVT            H6, S5 }
          if (v5)
          {
            _S5 = (float)(_S7 + _S16) - (float)(_S7 * _S16);
            __asm { FCVT            H5, S5 }
LABEL_409:
            v23->i16[0] = _H6;
            *float v12 = _H5;
            goto LABEL_411;
          }
          v23->i16[0] = _H6;
        }
      }
LABEL_411:
      ++v25;
      uint64_t v23 = (int16x4_t *)((char *)v23 + 2);
      float v12 = (short float *)((char *)v12 + v435);
      --v436;
    }
    while (v436);
    v25 += v26;
    uint64_t v23 = (int16x4_t *)((char *)v23 + 2 * v27);
    v12 += v16;
    --v17;
  }
  while (v17);
}

void Wf16_mark_pixelmask(uint64_t a1, int a2, __n128 _Q0, double a4, __n128 _Q2)
{
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 136);
  uint64_t v8 = *(int *)(a1 + 12);
  uint64_t v7 = *(int *)(a1 + 16);
  if (v5)
  {
    unint64_t v9 = (unint64_t)*(int *)(a1 + 32) >> 1;
    uint64_t v10 = (_WORD *)(v5 + 2 * (v8 + v9 * v7));
    int v11 = -1;
    if (!v6) {
      return;
    }
  }
  else
  {
    uint64_t v10 = 0;
    unint64_t v9 = 0;
    int v11 = 0;
    if (!v6) {
      return;
    }
  }
  int v13 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  unint64_t v15 = *(void *)(a1 + 88);
  uint64_t v14 = *(void *)(a1 + 96);
  unint64_t v16 = (unint64_t)*(int *)(a1 + 28) >> 1;
  int v17 = (char *)(*(void *)(a1 + 40) + 2 * (v8 + v16 * v7));
  uint64_t v18 = *(int *)(a1 + 124);
  int v19 = (unsigned char *)(v6 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v18);
  uint64_t v20 = *(int *)(a1 + 56);
  uint64_t v21 = *(int *)(a1 + 60);
  unint64_t v22 = *(int *)(a1 + 76);
  if ((*(_DWORD *)a1 & 0xFF00) == 0x100)
  {
    uint64_t v23 = v22 >> 1;
    if (v14)
    {
      unint64_t v24 = (unint64_t)*(int *)(a1 + 80) >> 1;
      v14 += 2 * (v20 + v24 * v21);
      int v1055 = -1;
    }
    else
    {
      unint64_t v24 = 0;
      int v1055 = 0;
    }
    unint64_t v27 = (char *)(v15 + 2 * (v20 + v23 * v21));
    if (v23 == v16 && v17 - v27 >= 1)
    {
      if (v13 >= (uint64_t)((unint64_t)(v17 - v27) >> 1))
      {
        v17 += 2 * v13 - 2;
        v27 += 2 * v13 - 2;
        v19 += v13 - 1;
        v10 += v11 & (v13 - 1);
        int v29 = -1;
        uint64_t v23 = (unint64_t)*(int *)(a1 + 28) >> 1;
        v14 += 2 * (v1055 & (v13 - 1));
        goto LABEL_16;
      }
      uint64_t v28 = v12 - 1;
      if (v17 <= &v27[2 * v16 * v28 - 2 + 2 * v13])
      {
        v17 += 2 * v16 * v28;
        uint64_t v23 = -(uint64_t)v16;
        v19 += v18 * v28;
        uint64_t v18 = -v18;
        v10 += v9 * v28;
        unint64_t v9 = -(uint64_t)v9;
        v11 &= 1u;
        v14 += 2 * v24 * v28;
        unint64_t v24 = -(uint64_t)v24;
        v1055 &= 1u;
        int v29 = 1;
        v27 += 2 * v16 * v28;
        unint64_t v16 = -(uint64_t)v16;
        goto LABEL_16;
      }
    }
    v11 &= 1u;
    v1055 &= 1u;
    int v29 = 1;
LABEL_16:
    unint64_t v30 = 0;
    v1049 = 0;
    unint64_t v15 = -1;
    int v26 = v24;
    int v25 = v23;
    goto LABEL_19;
  }
  int v25 = *(_DWORD *)(a1 + 64);
  int v26 = *(_DWORD *)(a1 + 68);
  uint64_t v23 = v22 >> 1;
  if (v14)
  {
    unint64_t v24 = (unint64_t)*(int *)(a1 + 80) >> 1;
    int v1055 = 1;
  }
  else
  {
    unint64_t v24 = 0;
    int v1055 = 0;
  }
  unint64_t v30 = v15 + 2 * v23 * v26;
  v11 &= 1u;
  int v29 = 1;
  v1049 = *(char **)(a1 + 88);
  unint64_t v27 = v1049;
LABEL_19:
  int v1056 = v11;
  int v31 = v29 * v13;
  if (v30)
  {
    uint64_t v32 = (int)v21 % v26;
    int v33 = &v27[2 * v23 * v32];
    uint64_t v34 = (int)v20 % v25;
    unint64_t v27 = &v33[2 * v34];
    unint64_t v15 = (unint64_t)&v33[2 * v25];
    if (v1055) {
      v14 += 2 * v24 * v32 + 2 * v34;
    }
    v1049 = &v33[2 * v34];
  }
  else
  {
    v23 -= v31;
    v24 -= v1055 * v13;
  }
  uint64_t v35 = v18 - v31;
  unint64_t v36 = v16 - v31;
  unint64_t v1048 = v9 - v1056 * v13;
  uint64_t v1035 = v23;
  int v1036 = v13;
  unint64_t v1033 = v36;
  uint64_t v1034 = v35;
  unint64_t v1037 = v30;
  switch(a2)
  {
    case 0:
      if (v1056)
      {
        do
        {
          int v37 = v13;
          do
          {
            unsigned int v38 = *v19;
            if (*v19)
            {
              if (v38 == 255)
              {
                *uint64_t v10 = 0;
                *(_WORD *)int v17 = 0;
              }
              else
              {
                _H3 = *(_WORD *)v17;
                __asm { FCVT            S3, H3 }
                float v44 = (float)((float)v38 * -0.0039216) + 1.0;
                _S3 = v44 * _S3;
                __asm { FCVT            H3, S3 }
                *(_WORD *)int v17 = LOWORD(_S3);
                LOWORD(_S3) = *v10;
                __asm { FCVT            S3, H3 }
                _S3 = v44 * _S3;
                __asm { FCVT            H3, S3 }
                *uint64_t v10 = LOWORD(_S3);
              }
            }
            v19 += v29;
            v10 += v1056;
            v17 += 2 * v29;
            --v37;
          }
          while (v37);
          v19 += v35;
          v17 += 2 * v36;
          v10 += v1048;
          --v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v872 = v13;
          do
          {
            unsigned int v873 = *v19;
            if (*v19)
            {
              _H2 = 0;
              if (v873 != 255)
              {
                _H2 = *(_WORD *)v17;
                __asm { FCVT            S2, H2 }
                _S2 = (float)((float)((float)v873 * -0.0039216) + 1.0) * _S2;
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)int v17 = _H2;
            }
            v19 += v29;
            v17 += 2 * v29;
            --v872;
          }
          while (v872);
          v19 += v35;
          v17 += 2 * v36;
          --v12;
        }
        while (v12);
      }
      return;
    case 1:
      if (v1056)
      {
        uint64_t v48 = v29;
        if (v1055)
        {
          uint64_t v49 = v26;
          uint64_t v50 = -(v23 * v26);
          uint64_t v51 = -(uint64_t)(v24 * v49);
          unsigned int v52 = (__int16 *)v14;
          uint64_t v53 = -(uint64_t)v25;
          do
          {
            int v54 = v13;
            do
            {
              unsigned int v55 = *v19;
              if (*v19)
              {
                if (v55 == 255)
                {
                  *(_WORD *)int v17 = *(_WORD *)v27;
                  _H2 = *v52;
                }
                else
                {
                  float v57 = (float)v55 * 0.0039216;
                  _H3 = *(_WORD *)v27;
                  __asm { FCVT            S3, H3 }
                  _H4 = *(_WORD *)v17;
                  __asm { FCVT            S4, H4 }
                  _S3 = (float)((float)(1.0 - v57) * _S4) + (float)(_S3 * v57);
                  __asm { FCVT            H3, S3 }
                  *(_WORD *)int v17 = LOWORD(_S3);
                  LOWORD(_S3) = *v52;
                  __asm { FCVT            S3, H3 }
                  LOWORD(_S4) = *v10;
                  __asm { FCVT            S4, H4 }
                  _S2 = (float)((float)(1.0 - v57) * _S4) + (float)(_S3 * v57);
                  __asm { FCVT            H2, S2 }
                }
                *uint64_t v10 = _H2;
              }
              v19 += v48;
              unsigned int v66 = &v27[2 * v48];
              unint64_t v67 = &v52[v1055];
              if ((unint64_t)v66 >= v15) {
                uint64_t v68 = v53;
              }
              else {
                uint64_t v68 = 0;
              }
              unsigned int v52 = &v67[v68];
              unint64_t v27 = &v66[2 * v68];
              v10 += v1056;
              v17 += 2 * v48;
              --v54;
            }
            while (v54);
            if (v30)
            {
              uint64_t v69 = &v1049[2 * v23];
              if ((unint64_t)v69 >= v30) {
                uint64_t v70 = v51;
              }
              else {
                uint64_t v70 = 0;
              }
              v14 += 2 * v24 + 2 * v70;
              if ((unint64_t)v69 >= v30) {
                uint64_t v71 = v50;
              }
              else {
                uint64_t v71 = 0;
              }
              unint64_t v27 = &v69[2 * v71];
              v15 += 2 * v71 + 2 * v23;
              unsigned int v52 = (__int16 *)v14;
              v1049 = v27;
            }
            else
            {
              v27 += 2 * v23;
              v52 += v24;
            }
            v19 += v35;
            v17 += 2 * v36;
            v10 += v1048;
            --v12;
          }
          while (v12);
        }
        else
        {
          uint64_t v1003 = -(uint64_t)v25;
          uint64_t v1004 = -(v23 * v26);
          do
          {
            int v1005 = v13;
            do
            {
              unsigned int v1006 = *v19;
              if (*v19)
              {
                if (v1006 == 255)
                {
                  *(_WORD *)int v17 = *(_WORD *)v27;
                  _H2 = COERCE_UNSIGNED_INT(1.0);
                }
                else
                {
                  float v1008 = (float)v1006 * 0.0039216;
                  _H3 = *(_WORD *)v27;
                  __asm { FCVT            S3, H3 }
                  _H4 = *(_WORD *)v17;
                  __asm { FCVT            S4, H4 }
                  _S3 = (float)((float)(1.0 - v1008) * _S4) + (float)(_S3 * v1008);
                  __asm { FCVT            H3, S3 }
                  *(_WORD *)int v17 = LOWORD(_S3);
                  LOWORD(_S3) = *v10;
                  __asm { FCVT            S3, H3 }
                  _S2 = v1008 + (float)((float)(1.0 - v1008) * _S3);
                  __asm { FCVT            H2, S2 }
                }
                *uint64_t v10 = _H2;
              }
              v19 += v48;
              long long v1016 = &v27[2 * v48];
              if ((unint64_t)v1016 >= v15) {
                uint64_t v1017 = v1003;
              }
              else {
                uint64_t v1017 = 0;
              }
              unint64_t v27 = &v1016[2 * v1017];
              v10 += v1056;
              v17 += 2 * v48;
              --v1005;
            }
            while (v1005);
            v19 += v35;
            v17 += 2 * v36;
            v1018 = v1049;
            v10 += v1048;
            uint64_t v1019 = &v1049[2 * v23];
            if ((unint64_t)v1019 >= v30) {
              uint64_t v1020 = v1004;
            }
            else {
              uint64_t v1020 = 0;
            }
            v1021 = &v1019[2 * v1020];
            uint64_t v1022 = v15 + 2 * v1020 + 2 * v23;
            if (v30)
            {
              unint64_t v15 = v1022;
              v1018 = v1021;
            }
            v1049 = v1018;
            if (v30) {
              unint64_t v27 = v1021;
            }
            else {
              v27 += 2 * v23;
            }
            --v12;
          }
          while (v12);
        }
      }
      else
      {
        uint64_t v878 = v29;
        uint64_t v879 = -(uint64_t)v25;
        uint64_t v880 = -(v23 * v26);
        uint64_t v881 = 2 * v29;
        do
        {
          int v882 = v13;
          do
          {
            unsigned int v883 = *v19;
            if (*v19)
            {
              if (v883 == 255)
              {
                _H2 = *(_WORD *)v27;
              }
              else
              {
                _H3 = *(_WORD *)v27;
                __asm { FCVT            S3, H3 }
                _H4 = *(_WORD *)v17;
                __asm { FCVT            S4, H4 }
                _S2 = (float)((float)(1.0 - (float)((float)v883 * 0.0039216)) * _S4)
                    + (float)(_S3 * (float)((float)v883 * 0.0039216));
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)int v17 = _H2;
            }
            v19 += v878;
            float v890 = &v27[2 * v878];
            if ((unint64_t)v890 >= v15) {
              uint64_t v891 = v879;
            }
            else {
              uint64_t v891 = 0;
            }
            unint64_t v27 = &v890[2 * v891];
            v17 += v881;
            --v882;
          }
          while (v882);
          v19 += v35;
          v17 += 2 * v36;
          float v892 = v1049;
          float v893 = &v1049[2 * v23];
          if ((unint64_t)v893 >= v30) {
            uint64_t v894 = v880;
          }
          else {
            uint64_t v894 = 0;
          }
          v895 = &v893[2 * v894];
          uint64_t v896 = v15 + 2 * v894 + 2 * v23;
          if (v30)
          {
            unint64_t v15 = v896;
            float v892 = v895;
          }
          v1049 = v892;
          if (v30) {
            unint64_t v27 = v895;
          }
          else {
            v27 += 2 * v23;
          }
          --v12;
        }
        while (v12);
      }
      return;
    case 2:
      uint64_t v72 = v29;
      if (v1056)
      {
        uint64_t v73 = -(uint64_t)v25;
        uint64_t v74 = v26;
        uint64_t v75 = -(v23 * v26);
        uint64_t v76 = -(uint64_t)(v24 * v74);
        int v77 = (short float *)v14;
        while (1)
        {
          int v78 = v13;
          do
          {
            unsigned int v79 = *v19;
            if (!*v19) {
              goto LABEL_73;
            }
            if (v79 == 255)
            {
              _H3 = *v77;
              if (*v77 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                *(_WORD *)int v17 = *(_WORD *)v27;
                goto LABEL_72;
              }
              __asm { FCMP            H3, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_73;
              }
              __asm { FCVT            S3, H3 }
              _H4 = *(_WORD *)v27;
              __asm { FCVT            S4, H4 }
              _H5 = *(_WORD *)v17;
              __asm { FCVT            S5, H5 }
              _S4 = _S4 + (float)(_S5 * (float)(1.0 - _S3));
              __asm { FCVT            H4, S4 }
              *(_WORD *)int v17 = LOWORD(_S4);
              LOWORD(_S4) = *v10;
              __asm { FCVT            S4, H4 }
              _S3 = _S3 + (float)(_S4 * (float)(1.0 - _S3));
            }
            else
            {
              float v90 = (float)v79 * 0.0039216;
              _H4 = *v77;
              __asm { FCVT            S4, H4 }
              _S4 = v90 * _S4;
              __asm
              {
                FCVT            H4, S4
                FCMP            H4, #0
              }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_73;
              }
              _H5 = *(_WORD *)v27;
              __asm
              {
                FCVT            S4, H4
                FCVT            S5, H5
              }
              _S3 = v90 * _S5;
              __asm
              {
                FCVT            H3, S3
                FCVT            S3, H3
              }
              LOWORD(_S5) = *(_WORD *)v17;
              __asm { FCVT            S5, H5 }
              _S3 = _S3 + (float)(_S5 * (float)(1.0 - _S4));
              __asm { FCVT            H3, S3 }
              *(_WORD *)int v17 = LOWORD(_S3);
              LOWORD(_S3) = *v10;
              __asm { FCVT            S3, H3 }
              _S3 = _S4 + (float)(_S3 * (float)(1.0 - _S4));
            }
            __asm { FCVT            H3, S3 }
LABEL_72:
            *(short float *)uint64_t v10 = _H3;
LABEL_73:
            v19 += v72;
            uint64_t v103 = &v27[2 * v72];
            int v104 = &v77[v1055];
            if ((unint64_t)v103 >= v15) {
              uint64_t v105 = v73;
            }
            else {
              uint64_t v105 = 0;
            }
            int v77 = &v104[v105];
            unint64_t v27 = &v103[2 * v105];
            v10 += v1056;
            v17 += 2 * v72;
            --v78;
          }
          while (v78);
          if (v30)
          {
            float v106 = &v1049[2 * v23];
            if ((unint64_t)v106 >= v30) {
              uint64_t v107 = v76;
            }
            else {
              uint64_t v107 = 0;
            }
            v14 += 2 * v24 + 2 * v107;
            if ((unint64_t)v106 >= v30) {
              uint64_t v108 = v75;
            }
            else {
              uint64_t v108 = 0;
            }
            unint64_t v27 = &v106[2 * v108];
            v15 += 2 * v108 + 2 * v23;
            int v77 = (short float *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v77 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          v10 += v1048;
          if (!--v12) {
            return;
          }
        }
      }
      uint64_t v897 = -(uint64_t)v25;
      uint64_t v898 = v26;
      uint64_t v899 = -(v23 * v26);
      uint64_t v900 = -(uint64_t)(v24 * v898);
      v901 = (short float *)v14;
LABEL_843:
      int v902 = v13;
      while (1)
      {
        unsigned int v903 = *v19;
        if (*v19)
        {
          if (v903 == 255)
          {
            if (*v901 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
            {
              _H3 = *(_WORD *)v27;
              goto LABEL_853;
            }
            __asm { FCMP            H3, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              __asm { FCVT            S3, H3 }
              _H4 = *(_WORD *)v27;
              __asm { FCVT            S4, H4 }
              _H5 = *(_WORD *)v17;
              __asm { FCVT            S5, H5 }
              _S3 = _S4 + (float)(_S5 * (float)(1.0 - _S3));
              goto LABEL_851;
            }
          }
          else
          {
            float v911 = (float)v903 * 0.0039216;
            _H4 = *v901;
            __asm { FCVT            S4, H4 }
            _S4 = v911 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H5 = *(_WORD *)v27;
              __asm
              {
                FCVT            S4, H4
                FCVT            S5, H5
              }
              _S3 = v911 * _S5;
              __asm
              {
                FCVT            H3, S3
                FCVT            S3, H3
              }
              LOWORD(_S5) = *(_WORD *)v17;
              __asm { FCVT            S5, H5 }
              _S3 = _S3 + (float)(_S5 * (float)(1.0 - _S4));
LABEL_851:
              __asm { FCVT            H3, S3 }
LABEL_853:
              *(_WORD *)int v17 = _H3;
            }
          }
        }
        v19 += v72;
        v923 = &v27[2 * v72];
        v924 = &v901[v1055];
        if ((unint64_t)v923 >= v15) {
          uint64_t v925 = v897;
        }
        else {
          uint64_t v925 = 0;
        }
        v901 = &v924[v925];
        unint64_t v27 = &v923[2 * v925];
        v17 += 2 * v72;
        if (!--v902)
        {
          if (v30)
          {
            v926 = &v1049[2 * v23];
            if ((unint64_t)v926 >= v30) {
              uint64_t v927 = v900;
            }
            else {
              uint64_t v927 = 0;
            }
            v14 += 2 * v24 + 2 * v927;
            if ((unint64_t)v926 >= v30) {
              uint64_t v928 = v899;
            }
            else {
              uint64_t v928 = 0;
            }
            unint64_t v27 = &v926[2 * v928];
            v15 += 2 * v928 + 2 * v23;
            v901 = (short float *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v901 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          if (!--v12) {
            return;
          }
          goto LABEL_843;
        }
      }
    case 3:
      uint64_t v109 = v29;
      uint64_t v110 = v26;
      uint64_t v111 = -(v23 * v26);
      uint64_t v112 = -(uint64_t)(v24 * v110);
      uint64_t v113 = 2 * v29;
      uint64_t v114 = -(uint64_t)v25;
      short float v115 = (__int16 *)v14;
      do
      {
        int v116 = v13;
        do
        {
          unsigned int v117 = *v19;
          if (*v19)
          {
            if (v117 == 255)
            {
              *(short float *)int v17 = *(short float *)v27 * *(short float *)v10;
              if (v1055)
              {
                _H1 = *v115;
                __asm { FCVT            S1, H1 }
              }
              else
              {
                _S1 = 1.0;
              }
              _H2 = *v10;
              __asm { FCVT            S2, H2 }
              _S1 = _S1 * _S2;
            }
            else
            {
              float v120 = (float)v117 * 0.0039216;
              _H1 = *v10;
              __asm { FCVT            S1, H1 }
              _H2 = *(_WORD *)v27;
              __asm { FCVT            S5, H2 }
              float v125 = v120 * _S1;
              _H4 = *(_WORD *)v17;
              __asm { FCVT            S6, H4 }
              _S4 = 1.0;
              float v129 = 1.0 - v120;
              _S5 = (float)(v129 * _S6) + (float)(_S5 * v125);
              __asm { FCVT            H5, S5 }
              *(_WORD *)int v17 = LOWORD(_S5);
              if (v1055)
              {
                _H4 = *v115;
                __asm { FCVT            S4, H4 }
              }
              _S1 = (float)(v129 * _S1) + (float)(_S4 * v125);
            }
            __asm { FCVT            H1, S1 }
            *uint64_t v10 = _H1;
          }
          v19 += v109;
          int v136 = &v27[2 * v109];
          unsigned int v137 = &v115[v1055];
          if ((unint64_t)v136 >= v15) {
            uint64_t v138 = v114;
          }
          else {
            uint64_t v138 = 0;
          }
          short float v115 = &v137[v138];
          unint64_t v27 = &v136[2 * v138];
          v10 += v1056;
          v17 += v113;
          --v116;
        }
        while (v116);
        if (v30)
        {
          uint64_t v139 = &v1049[2 * v23];
          if ((unint64_t)v139 >= v30) {
            uint64_t v140 = v112;
          }
          else {
            uint64_t v140 = 0;
          }
          v14 += 2 * v24 + 2 * v140;
          if ((unint64_t)v139 >= v30) {
            uint64_t v141 = v111;
          }
          else {
            uint64_t v141 = 0;
          }
          unint64_t v27 = &v139[2 * v141];
          v15 += 2 * v141 + 2 * v23;
          short float v115 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v115 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        --v12;
      }
      while (v12);
      return;
    case 4:
      uint64_t v142 = v29;
      uint64_t v143 = v26;
      uint64_t v144 = -(v23 * v26);
      uint64_t v145 = -(uint64_t)(v24 * v143);
      uint64_t v146 = 2 * v29;
      uint64_t v147 = -(uint64_t)v25;
      unsigned int v148 = (__int16 *)v14;
      do
      {
        int v149 = v13;
        do
        {
          unsigned int v150 = *v19;
          if (*v19)
          {
            if (v150 == 255)
            {
              _H2 = *(_WORD *)v27;
              __asm { FCVT            S3, H2 }
              _H2 = *v10;
              __asm { FCVT            S4, H2 }
              _S2 = 1.0;
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              *(_WORD *)int v17 = LOWORD(_S3);
              if (v1055)
              {
                _H2 = *v148;
                __asm { FCVT            S2, H2 }
              }
              _H3 = *v10;
              __asm { FCVT            S3, H3 }
              _S2 = _S2 * (float)(1.0 - _S3);
            }
            else
            {
              float v161 = (float)v150 * 0.0039216;
              _H2 = *v10;
              __asm { FCVT            S2, H2 }
              _H3 = *(_WORD *)v27;
              __asm { FCVT            S6, H3 }
              _S4 = 1.0;
              float v167 = v161 * (float)(1.0 - _S2);
              _H7 = *(_WORD *)v17;
              __asm { FCVT            S7, H7 }
              float v170 = 1.0 - v161;
              _S6 = (float)(v170 * _S7) + (float)(_S6 * v167);
              __asm { FCVT            H6, S6 }
              *(_WORD *)int v17 = LOWORD(_S6);
              if (v1055)
              {
                _H4 = *v148;
                __asm { FCVT            S4, H4 }
              }
              _S2 = (float)(v170 * _S2) + (float)(_S4 * v167);
            }
            __asm { FCVT            H2, S2 }
            *uint64_t v10 = _H2;
          }
          v19 += v142;
          uint64_t v174 = &v27[2 * v142];
          int v175 = &v148[v1055];
          if ((unint64_t)v174 >= v15) {
            uint64_t v176 = v147;
          }
          else {
            uint64_t v176 = 0;
          }
          unsigned int v148 = &v175[v176];
          unint64_t v27 = &v174[2 * v176];
          v10 += v1056;
          v17 += v146;
          --v149;
        }
        while (v149);
        if (v30)
        {
          uint64_t v177 = &v1049[2 * v23];
          if ((unint64_t)v177 >= v30) {
            uint64_t v178 = v145;
          }
          else {
            uint64_t v178 = 0;
          }
          v14 += 2 * v24 + 2 * v178;
          if ((unint64_t)v177 >= v30) {
            uint64_t v179 = v144;
          }
          else {
            uint64_t v179 = 0;
          }
          unint64_t v27 = &v177[2 * v179];
          v15 += 2 * v179 + 2 * v23;
          unsigned int v148 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v148 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        --v12;
      }
      while (v12);
      return;
    case 5:
      uint64_t v180 = v29;
      uint64_t v181 = v26;
      uint64_t v182 = -(v23 * v26);
      uint64_t v183 = -(uint64_t)(v24 * v181);
      uint64_t v184 = 2 * v29;
      uint64_t v185 = -(uint64_t)v25;
      uint64_t v186 = (__int16 *)v14;
      do
      {
        int v187 = v13;
        do
        {
          if (*v19)
          {
            _H2 = *v10;
            __asm { FCVT            S2, H2 }
            _H3 = *(_WORD *)v27;
            __asm { FCVT            S3, H3 }
            float v192 = (float)*v19 * 0.0039216;
            _S3 = v192 * _S3;
            __asm { FCVT            H3, S3 }
            _H5 = *v186;
            __asm { FCVT            S5, H5 }
            _S4 = v192 * _S5;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
              FCVT            S3, H3
            }
            LOWORD(_S5) = *(_WORD *)v17;
            __asm { FCVT            S5, H5 }
            _S3 = (float)((float)(1.0 - _S4) * _S5) + (float)(_S3 * _S2);
            __asm { FCVT            H3, S3 }
            *(_WORD *)int v17 = LOWORD(_S3);
            _S2 = (float)((float)(1.0 - _S4) * _S2) + (float)(_S4 * _S2);
            __asm { FCVT            H2, S2 }
            *uint64_t v10 = LOWORD(_S2);
          }
          v19 += v180;
          int v202 = &v27[2 * v180];
          int v203 = &v186[v1055];
          if ((unint64_t)v202 >= v15) {
            uint64_t v204 = v185;
          }
          else {
            uint64_t v204 = 0;
          }
          uint64_t v186 = &v203[v204];
          unint64_t v27 = &v202[2 * v204];
          v10 += v1056;
          v17 += v184;
          --v187;
        }
        while (v187);
        if (v30)
        {
          uint64_t v205 = &v1049[2 * v23];
          if ((unint64_t)v205 >= v30) {
            uint64_t v206 = v183;
          }
          else {
            uint64_t v206 = 0;
          }
          v14 += 2 * v24 + 2 * v206;
          if ((unint64_t)v205 >= v30) {
            uint64_t v207 = v182;
          }
          else {
            uint64_t v207 = 0;
          }
          unint64_t v27 = &v205[2 * v207];
          v15 += 2 * v207 + 2 * v23;
          uint64_t v186 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v186 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        --v12;
      }
      while (v12);
      return;
    case 6:
      uint64_t v208 = v29;
      uint64_t v209 = v26;
      uint64_t v210 = -(v23 * v26);
      uint64_t v211 = -(uint64_t)(v24 * v209);
      uint64_t v212 = 2 * v29;
      uint64_t v213 = -(uint64_t)v25;
      int v214 = (__int16 *)v14;
      while (1)
      {
        int v215 = v13;
        do
        {
          unsigned int v216 = *v19;
          if (!*v19) {
            goto LABEL_174;
          }
          _H2 = *v10;
          __asm { FCVT            S2, H2 }
          float v219 = 1.0 - _S2;
          if ((float)(1.0 - _S2) >= 1.0)
          {
            _H2 = *(_WORD *)v27;
            __asm { FCVT            S3, H2 }
            float v230 = (float)v216 * 0.0039216;
            _S3 = v230 * _S3;
            __asm { FCVT            H3, S3 }
            *(_WORD *)int v17 = LOWORD(_S3);
            if (v1055)
            {
              _H3 = *v214;
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            _S2 = v230 * _S3;
          }
          else
          {
            if (v219 <= 0.0) {
              goto LABEL_174;
            }
            _H4 = *(_WORD *)v17;
            __asm { FCVT            S4, H4 }
            _H5 = *(_WORD *)v27;
            __asm { FCVT            S5, H5 }
            float v224 = (float)((float)v216 * 0.0039216) * v219;
            _S4 = _S4 + (float)(_S5 * v224);
            __asm { FCVT            H4, S4 }
            *(_WORD *)int v17 = LOWORD(_S4);
            if (v1055)
            {
              _H4 = *v214;
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            _S2 = _S2 + (float)(_S4 * v224);
          }
          __asm { FCVT            H2, S2 }
          *uint64_t v10 = _H2;
LABEL_174:
          v19 += v208;
          uint64_t v236 = &v27[2 * v208];
          int v237 = &v214[v1055];
          if ((unint64_t)v236 >= v15) {
            uint64_t v238 = v213;
          }
          else {
            uint64_t v238 = 0;
          }
          int v214 = &v237[v238];
          unint64_t v27 = &v236[2 * v238];
          v10 += v1056;
          v17 += v212;
          --v215;
        }
        while (v215);
        if (v30)
        {
          float32x4_t v239 = &v1049[2 * v23];
          if ((unint64_t)v239 >= v30) {
            uint64_t v240 = v211;
          }
          else {
            uint64_t v240 = 0;
          }
          v14 += 2 * v24 + 2 * v240;
          if ((unint64_t)v239 >= v30) {
            uint64_t v241 = v210;
          }
          else {
            uint64_t v241 = 0;
          }
          unint64_t v27 = &v239[2 * v241];
          v15 += 2 * v241 + 2 * v23;
          int v214 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v214 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 7:
      uint64_t v242 = v29;
      if (v1056)
      {
        uint64_t v243 = v26;
        uint64_t v244 = -(v23 * v26);
        uint64_t v245 = -(uint64_t)(v24 * v243);
        uint64_t v246 = -(uint64_t)v25;
        float v247 = (short float *)v14;
        do
        {
          int v248 = v13;
          do
          {
            unsigned int v249 = *v19;
            if (*v19)
            {
              if (v249 == 255)
              {
                *(short float *)int v17 = *(short float *)v17 * *v247;
                _H2 = *(short float *)v10 * *v247;
              }
              else
              {
                float v251 = (float)v249 * 0.0039216;
                _H3 = *v10;
                __asm { FCVT            S3, H3 }
                _H4 = *(_WORD *)v17;
                __asm { FCVT            S4, H4 }
                _H5 = *v247;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v251) * _S4) + (float)(_S4 * (float)(v251 * _S5));
                __asm { FCVT            H4, S4 }
                *(_WORD *)int v17 = LOWORD(_S4);
                *(short float *)&_S4 = *v247;
                __asm { FCVT            S4, H4 }
                _S2 = (float)((float)(1.0 - v251) * _S3) + (float)(_S3 * (float)(v251 * _S4));
                __asm { FCVT            H2, S2 }
              }
              *(short float *)uint64_t v10 = _H2;
            }
            v19 += v242;
            uint64_t v261 = &v27[2 * v242];
            int v262 = &v247[v1055];
            if ((unint64_t)v261 >= v15) {
              uint64_t v263 = v246;
            }
            else {
              uint64_t v263 = 0;
            }
            float v247 = &v262[v263];
            unint64_t v27 = &v261[2 * v263];
            v10 += v1056;
            v17 += 2 * v242;
            --v248;
          }
          while (v248);
          if (v30)
          {
            float16x4_t v264 = &v1049[2 * v23];
            if ((unint64_t)v264 >= v30) {
              uint64_t v265 = v245;
            }
            else {
              uint64_t v265 = 0;
            }
            v14 += 2 * v24 + 2 * v265;
            if ((unint64_t)v264 >= v30) {
              uint64_t v266 = v244;
            }
            else {
              uint64_t v266 = 0;
            }
            unint64_t v27 = &v264[2 * v266];
            v15 += 2 * v266 + 2 * v23;
            float v247 = (short float *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v247 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          v10 += v1048;
          --v12;
        }
        while (v12);
      }
      else
      {
        uint64_t v929 = -(uint64_t)v25;
        uint64_t v930 = v26;
        uint64_t v931 = -(v23 * v26);
        uint64_t v932 = -(uint64_t)(v24 * v930);
        int v933 = (short float *)v14;
        do
        {
          int v934 = v13;
          do
          {
            unsigned int v935 = *v19;
            if (*v19)
            {
              if (v935 == 255)
              {
                _H2 = *(short float *)v17 * *v933;
              }
              else
              {
                _H3 = *(_WORD *)v17;
                __asm { FCVT            S3, H3 }
                _H4 = *v933;
                __asm { FCVT            S4, H4 }
                _S2 = (float)((float)(1.0 - (float)((float)v935 * 0.0039216)) * _S3)
                    + (float)(_S3 * (float)((float)((float)v935 * 0.0039216) * _S4));
                __asm { FCVT            H2, S2 }
              }
              *(short float *)int v17 = _H2;
            }
            v19 += v242;
            v942 = &v27[2 * v242];
            v943 = &v933[v1055];
            if ((unint64_t)v942 >= v15) {
              uint64_t v944 = v929;
            }
            else {
              uint64_t v944 = 0;
            }
            int v933 = &v943[v944];
            unint64_t v27 = &v942[2 * v944];
            v17 += 2 * v242;
            --v934;
          }
          while (v934);
          if (v30)
          {
            int v945 = &v1049[2 * v23];
            if ((unint64_t)v945 >= v30) {
              uint64_t v946 = v932;
            }
            else {
              uint64_t v946 = 0;
            }
            v14 += 2 * v24 + 2 * v946;
            if ((unint64_t)v945 >= v30) {
              uint64_t v947 = v931;
            }
            else {
              uint64_t v947 = 0;
            }
            unint64_t v27 = &v945[2 * v947];
            v15 += 2 * v947 + 2 * v23;
            int v933 = (short float *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v933 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          --v12;
        }
        while (v12);
      }
      return;
    case 8:
      uint64_t v267 = v29;
      if (v1056)
      {
        uint64_t v268 = -(uint64_t)v25;
        uint64_t v269 = v26;
        uint64_t v270 = -(v23 * v26);
        uint64_t v271 = -(uint64_t)(v24 * v269);
        float32x4_t v272 = (__int16 *)v14;
        do
        {
          int v273 = v13;
          do
          {
            unsigned int v274 = *v19;
            if (*v19)
            {
              _H2 = *(_WORD *)v17;
              if (v274 == 255)
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v272;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)int v17 = LOWORD(_S2);
                LOWORD(_S2) = *v272;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v272;
                __asm { FCVT            S3, H3 }
                float v284 = (float)v274 * 0.0039216;
                _S2 = (float)(1.0 - (float)(v284 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)int v17 = LOWORD(_S2);
                LOWORD(_S2) = *v272;
                __asm { FCVT            S2, H2 }
                _S2 = v284 * _S2;
              }
              _H3 = *v10;
              __asm { FCVT            S3, H3 }
              _S2 = (float)(1.0 - _S2) * _S3;
              __asm { FCVT            H2, S2 }
              *uint64_t v10 = LOWORD(_S2);
            }
            v19 += v267;
            int v290 = &v27[2 * v267];
            int v291 = &v272[v1055];
            if ((unint64_t)v290 >= v15) {
              uint64_t v292 = v268;
            }
            else {
              uint64_t v292 = 0;
            }
            float32x4_t v272 = &v291[v292];
            unint64_t v27 = &v290[2 * v292];
            v10 += v1056;
            v17 += 2 * v267;
            --v273;
          }
          while (v273);
          if (v30)
          {
            float v293 = &v1049[2 * v23];
            if ((unint64_t)v293 >= v30) {
              uint64_t v294 = v271;
            }
            else {
              uint64_t v294 = 0;
            }
            v14 += 2 * v24 + 2 * v294;
            if ((unint64_t)v293 >= v30) {
              uint64_t v295 = v270;
            }
            else {
              uint64_t v295 = 0;
            }
            unint64_t v27 = &v293[2 * v295];
            v15 += 2 * v295 + 2 * v23;
            float32x4_t v272 = (__int16 *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v272 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          v10 += v1048;
          --v12;
        }
        while (v12);
      }
      else
      {
        uint64_t v948 = -(uint64_t)v25;
        uint64_t v949 = v26;
        uint64_t v950 = -(v23 * v26);
        uint64_t v951 = -(uint64_t)(v24 * v949);
        float v952 = (__int16 *)v14;
        do
        {
          int v953 = v13;
          do
          {
            unsigned int v954 = *v19;
            if (*v19)
            {
              _H2 = *v952;
              if (v954 == 255)
              {
                __asm { FCVT            S2, H2 }
              }
              else
              {
                __asm { FCVT            S2, H2 }
                _S2 = (float)((float)v954 * 0.0039216) * _S2;
              }
              _H3 = *(_WORD *)v17;
              __asm { FCVT            S3, H3 }
              _S2 = (float)(1.0 - _S2) * _S3;
              __asm { FCVT            H2, S2 }
              *(_WORD *)int v17 = LOWORD(_S2);
            }
            v19 += v267;
            unsigned int v961 = &v27[2 * v267];
            v962 = &v952[v1055];
            if ((unint64_t)v961 >= v15) {
              uint64_t v963 = v948;
            }
            else {
              uint64_t v963 = 0;
            }
            float v952 = &v962[v963];
            unint64_t v27 = &v961[2 * v963];
            v17 += 2 * v267;
            --v953;
          }
          while (v953);
          if (v30)
          {
            v964 = &v1049[2 * v23];
            if ((unint64_t)v964 >= v30) {
              uint64_t v965 = v951;
            }
            else {
              uint64_t v965 = 0;
            }
            v14 += 2 * v24 + 2 * v965;
            if ((unint64_t)v964 >= v30) {
              uint64_t v966 = v950;
            }
            else {
              uint64_t v966 = 0;
            }
            unint64_t v27 = &v964[2 * v966];
            v15 += 2 * v966 + 2 * v23;
            float v952 = (__int16 *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v952 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          --v12;
        }
        while (v12);
      }
      return;
    case 9:
      uint64_t v296 = v29;
      uint64_t v297 = v26;
      uint64_t v298 = -(v23 * v26);
      uint64_t v299 = -(uint64_t)(v24 * v297);
      uint64_t v300 = 2 * v29;
      uint64_t v301 = -(uint64_t)v25;
      unsigned int v302 = (__int16 *)v14;
      do
      {
        int v303 = v13;
        do
        {
          if (*v19)
          {
            _H2 = *v10;
            __asm { FCVT            S2, H2 }
            float v306 = (float)*v19 * 0.0039216;
            _H4 = *(_WORD *)v27;
            __asm { FCVT            S4, H4 }
            _S4 = v306 * _S4;
            __asm { FCVT            H4, S4 }
            _H5 = *v302;
            __asm { FCVT            S5, H5 }
            _S5 = v306 * _S5;
            __asm
            {
              FCVT            H5, S5
              FCVT            S5, H5
              FCVT            S4, H4
            }
            _H7 = *(_WORD *)v17;
            __asm { FCVT            S7, H7 }
            float v317 = (float)(1.0 - v306) + _S5;
            _S4 = (float)(v317 * _S7) + (float)(_S4 * (float)(1.0 - _S2));
            __asm { FCVT            H4, S4 }
            *(_WORD *)int v17 = LOWORD(_S4);
            _S2 = (float)(v317 * _S2) + (float)(_S5 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *uint64_t v10 = LOWORD(_S2);
          }
          v19 += v296;
          int8x8_t v320 = &v27[2 * v296];
          int8x8_t v321 = &v302[v1055];
          if ((unint64_t)v320 >= v15) {
            uint64_t v322 = v301;
          }
          else {
            uint64_t v322 = 0;
          }
          unsigned int v302 = &v321[v322];
          unint64_t v27 = &v320[2 * v322];
          v10 += v1056;
          v17 += v300;
          --v303;
        }
        while (v303);
        if (v30)
        {
          float v323 = &v1049[2 * v23];
          if ((unint64_t)v323 >= v30) {
            uint64_t v324 = v299;
          }
          else {
            uint64_t v324 = 0;
          }
          v14 += 2 * v24 + 2 * v324;
          if ((unint64_t)v323 >= v30) {
            uint64_t v325 = v298;
          }
          else {
            uint64_t v325 = 0;
          }
          unint64_t v27 = &v323[2 * v325];
          v15 += 2 * v325 + 2 * v23;
          unsigned int v302 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v302 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        --v12;
      }
      while (v12);
      return;
    case 10:
      uint64_t v326 = v29;
      uint64_t v327 = v26;
      uint64_t v328 = -(v23 * v26);
      uint64_t v329 = -(uint64_t)(v24 * v327);
      uint64_t v330 = 2 * v29;
      uint64_t v331 = -(uint64_t)v25;
      int v332 = (__int16 *)v14;
      do
      {
        int v333 = v13;
        do
        {
          if (*v19)
          {
            _H2 = *v10;
            __asm { FCVT            S2, H2 }
            _H3 = *(_WORD *)v27;
            __asm { FCVT            S3, H3 }
            float v338 = (float)*v19 * 0.0039216;
            _S3 = v338 * _S3;
            __asm { FCVT            H3, S3 }
            _H5 = *v332;
            __asm { FCVT            S5, H5 }
            _S4 = v338 * _S5;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
              FCVT            S3, H3
            }
            _H6 = *(_WORD *)v17;
            __asm { FCVT            S6, H6 }
            _S3 = (float)((float)(1.0 - _S4) * _S6) + (float)(_S3 * (float)(1.0 - _S2));
            __asm { FCVT            H3, S3 }
            *(_WORD *)int v17 = LOWORD(_S3);
            _S2 = (float)((float)(1.0 - _S4) * _S2) + (float)(_S4 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *uint64_t v10 = LOWORD(_S2);
          }
          v19 += v326;
          float v349 = &v27[2 * v326];
          float v350 = &v332[v1055];
          if ((unint64_t)v349 >= v15) {
            uint64_t v351 = v331;
          }
          else {
            uint64_t v351 = 0;
          }
          int v332 = &v350[v351];
          unint64_t v27 = &v349[2 * v351];
          v10 += v1056;
          v17 += v330;
          --v333;
        }
        while (v333);
        if (v30)
        {
          float v352 = &v1049[2 * v23];
          if ((unint64_t)v352 >= v30) {
            uint64_t v353 = v329;
          }
          else {
            uint64_t v353 = 0;
          }
          v14 += 2 * v24 + 2 * v353;
          if ((unint64_t)v352 >= v30) {
            uint64_t v354 = v328;
          }
          else {
            uint64_t v354 = 0;
          }
          unint64_t v27 = &v352[2 * v354];
          v15 += 2 * v354 + 2 * v23;
          int v332 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v332 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        --v12;
      }
      while (v12);
      return;
    case 11:
      uint64_t v355 = v29;
      if (v1056)
      {
        uint64_t v356 = v26;
        uint64_t v357 = -(v23 * v26);
        uint64_t v358 = -(uint64_t)(v24 * v356);
        uint64_t v359 = -(uint64_t)v25;
        __n128 v360 = (__int16 *)v14;
        do
        {
          int v361 = v13;
          do
          {
            if (*v19)
            {
              if (v1055)
              {
                _H2 = *v360;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _H3 = *(_WORD *)v27;
              __asm { FCVT            S3, H3 }
              _S4 = (float)*v19 * 0.0039216;
              _S3 = _S4 * _S3;
              __asm { FCVT            H3, S3 }
              _S2 = _S4 * _S2;
              __asm { FCVT            H2, S2 }
              LOWORD(_S4) = *v10;
              __asm
              {
                FCVT            S4, H4
                FCVT            S2, H2
              }
              float v371 = _S4 + _S2;
              _H6 = *(_WORD *)v17;
              __asm
              {
                FCVT            S6, H6
                FCVT            S3, H3
              }
              float v375 = (float)(_S4 - _S6) + (float)(_S2 - _S3);
              if (v371 <= 1.0) {
                _S3 = v371;
              }
              else {
                _S3 = 1.0;
              }
              __asm { FCVT            H4, S3 }
              *uint64_t v10 = _H4;
              _S2 = _S3 - v375;
              __asm { FCVT            H2, S2 }
              *(_WORD *)int v17 = LOWORD(_S2);
            }
            v19 += v355;
            __int16 v379 = &v27[2 * v355];
            int v380 = &v360[v1055];
            if ((unint64_t)v379 >= v15) {
              uint64_t v381 = v359;
            }
            else {
              uint64_t v381 = 0;
            }
            __n128 v360 = &v380[v381];
            unint64_t v27 = &v379[2 * v381];
            v10 += v1056;
            v17 += 2 * v355;
            --v361;
          }
          while (v361);
          if (v30)
          {
            unsigned int v382 = &v1049[2 * v23];
            if ((unint64_t)v382 >= v30) {
              uint64_t v383 = v358;
            }
            else {
              uint64_t v383 = 0;
            }
            v14 += 2 * v24 + 2 * v383;
            if ((unint64_t)v382 >= v30) {
              uint64_t v384 = v357;
            }
            else {
              uint64_t v384 = 0;
            }
            unint64_t v27 = &v382[2 * v384];
            v15 += 2 * v384 + 2 * v23;
            __n128 v360 = (__int16 *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v360 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          v10 += v1048;
          --v12;
        }
        while (v12);
      }
      else
      {
        uint64_t v967 = -(uint64_t)v25;
        uint64_t v968 = v26;
        uint64_t v969 = -(v23 * v26);
        uint64_t v970 = -(uint64_t)(v24 * v968);
        uint64_t v971 = (__int16 *)v14;
        do
        {
          int v972 = v13;
          do
          {
            if (*v19)
            {
              if (v1055)
              {
                _H2 = *v971;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _H3 = *(_WORD *)v27;
              __asm { FCVT            S3, H3 }
              _S4 = (float)*v19 * 0.0039216;
              _S3 = _S4 * _S3;
              __asm { FCVT            H3, S3 }
              _S2 = _S4 * _S2;
              __asm { FCVT            H2, S2 }
              LOWORD(_S4) = *(_WORD *)v17;
              __asm
              {
                FCVT            S4, H4
                FCVT            S2, H2
                FCVT            S3, H3
              }
              _S2 = 1.0 - (float)((float)(1.0 - _S4) + (float)(_S2 - _S3));
              __asm { FCVT            H2, S2 }
              *(_WORD *)int v17 = LOWORD(_S2);
            }
            v19 += v355;
            int v984 = &v27[2 * v355];
            uint64_t v985 = &v971[v1055];
            if ((unint64_t)v984 >= v15) {
              uint64_t v986 = v967;
            }
            else {
              uint64_t v986 = 0;
            }
            uint64_t v971 = &v985[v986];
            unint64_t v27 = &v984[2 * v986];
            v17 += 2 * v355;
            --v972;
          }
          while (v972);
          if (v30)
          {
            uint64_t v987 = &v1049[2 * v23];
            if ((unint64_t)v987 >= v30) {
              uint64_t v988 = v970;
            }
            else {
              uint64_t v988 = 0;
            }
            v14 += 2 * v24 + 2 * v988;
            if ((unint64_t)v987 >= v30) {
              uint64_t v989 = v969;
            }
            else {
              uint64_t v989 = 0;
            }
            unint64_t v27 = &v987[2 * v989];
            v15 += 2 * v989 + 2 * v23;
            uint64_t v971 = (__int16 *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v971 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          --v12;
        }
        while (v12);
      }
      return;
    case 12:
      uint64_t v385 = v29;
      if (v1056)
      {
        uint64_t v386 = v26;
        uint64_t v387 = -(v23 * v26);
        uint64_t v388 = -(uint64_t)(v24 * v386);
        uint64_t v389 = -(uint64_t)v25;
        float v390 = (__int16 *)v14;
        do
        {
          int v391 = v13;
          do
          {
            if (*v19)
            {
              if (v1055)
              {
                _H2 = *v390;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _H3 = *(_WORD *)v27;
              __asm { FCVT            S3, H3 }
              _S4 = (float)*v19 * 0.0039216;
              _S3 = _S4 * _S3;
              __asm { FCVT            H3, S3 }
              _S2 = _S4 * _S2;
              __asm { FCVT            H2, S2 }
              LOWORD(_S4) = *v10;
              __asm
              {
                FCVT            S4, H4
                FCVT            S2, H2
              }
              _S2 = _S4 + _S2;
              if (_S2 > 1.0) {
                _S2 = 1.0;
              }
              *(short float *)int v17 = *(short float *)v17 + _H3;
              __asm { FCVT            H2, S2 }
              *uint64_t v10 = _H2;
            }
            v19 += v385;
            uint64_t v404 = &v27[2 * v385];
            uint64_t v405 = &v390[v1055];
            if ((unint64_t)v404 >= v15) {
              uint64_t v406 = v389;
            }
            else {
              uint64_t v406 = 0;
            }
            float v390 = &v405[v406];
            unint64_t v27 = &v404[2 * v406];
            v10 += v1056;
            v17 += 2 * v385;
            --v391;
          }
          while (v391);
          if (v30)
          {
            __n128 v407 = &v1049[2 * v23];
            if ((unint64_t)v407 >= v30) {
              uint64_t v408 = v388;
            }
            else {
              uint64_t v408 = 0;
            }
            v14 += 2 * v24 + 2 * v408;
            if ((unint64_t)v407 >= v30) {
              uint64_t v409 = v387;
            }
            else {
              uint64_t v409 = 0;
            }
            unint64_t v27 = &v407[2 * v409];
            v15 += 2 * v409 + 2 * v23;
            float v390 = (__int16 *)v14;
            v1049 = v27;
          }
          else
          {
            v27 += 2 * v23;
            v390 += v24;
          }
          v19 += v35;
          v17 += 2 * v36;
          v10 += v1048;
          --v12;
        }
        while (v12);
      }
      else
      {
        uint64_t v990 = -(uint64_t)v25;
        uint64_t v991 = -(v23 * v26);
        do
        {
          int v992 = v13;
          do
          {
            if (*v19)
            {
              _H1 = *(_WORD *)v27;
              __asm { FCVT            S1, H1 }
              _S1 = (float)((float)*v19 * 0.0039216) * _S1;
              __asm { FCVT            H1, S1 }
              *(short float *)int v17 = *(short float *)v17 + *(short float *)&_S1;
            }
            v19 += v385;
            uint64_t v996 = &v27[2 * v385];
            if ((unint64_t)v996 >= v15) {
              uint64_t v997 = v990;
            }
            else {
              uint64_t v997 = 0;
            }
            unint64_t v27 = &v996[2 * v997];
            v17 += 2 * v385;
            --v992;
          }
          while (v992);
          v19 += v35;
          v17 += 2 * v36;
          v998 = v1049;
          int v999 = &v1049[2 * v23];
          if ((unint64_t)v999 >= v30) {
            uint64_t v1000 = v991;
          }
          else {
            uint64_t v1000 = 0;
          }
          int32x2_t v1001 = &v999[2 * v1000];
          uint64_t v1002 = v15 + 2 * v1000 + 2 * v23;
          if (v30)
          {
            unint64_t v15 = v1002;
            v998 = v1001;
          }
          v1049 = v998;
          if (v30) {
            unint64_t v27 = v1001;
          }
          else {
            v27 += 2 * v23;
          }
          --v12;
        }
        while (v12);
      }
      return;
    case 13:
      uint64_t v410 = v29;
      uint64_t v411 = v26;
      uint64_t v412 = -(v23 * v26);
      uint64_t v413 = -(uint64_t)(v24 * v411);
      uint64_t v414 = 2 * v29;
      uint64_t v415 = -(uint64_t)v25;
      short float v416 = (__int16 *)v14;
      while (1)
      {
        int v417 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H3 = *v416;
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            float v420 = (float)*v19 * 0.0039216;
            _S3 = v420 * _S3;
            __asm
            {
              FCVT            H3, S3
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H5 = *(_WORD *)v27;
              __asm { FCVT            S5, H5 }
              _S4 = v420 * _S5;
              __asm { FCVT            H4, S4 }
              if (v1056)
              {
                __asm { FCMP            H5, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_342;
                }
                __asm { FCVT            S5, H5 }
              }
              else
              {
                _S5 = 1.0;
              }
              __asm { FCVT            S6, H3 }
              _H7 = *(_WORD *)v17;
              __asm
              {
                FCVT            S7, H7
                FCVT            S4, H4
              }
              float v433 = _S4 * _S7;
              float v434 = (float)(_S4 * _S7) + (float)(_S7 * (float)(1.0 - _S6));
              if (_H3 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                _S3 = v433;
              }
              else {
                _S3 = v434;
              }
              float v436 = _S3 + (float)(_S4 * (float)(1.0 - _S5));
              if (_S5 != 1.0) {
                _S3 = v436;
              }
              __asm { FCVT            H4, S3 }
              if (v1056)
              {
                _S3 = (float)(_S5 + _S6) - (float)(_S5 * _S6);
                __asm { FCVT            H3, S3 }
LABEL_342:
                *(_WORD *)int v17 = _H4;
                *(short float *)uint64_t v10 = _H3;
                goto LABEL_344;
              }
              *(_WORD *)int v17 = _H4;
            }
          }
LABEL_344:
          v19 += v410;
          int v438 = &v27[2 * v410];
          short float v439 = &v416[v1055];
          if ((unint64_t)v438 >= v15) {
            uint64_t v440 = v415;
          }
          else {
            uint64_t v440 = 0;
          }
          short float v416 = &v439[v440];
          unint64_t v27 = &v438[2 * v440];
          v10 += v1056;
          v17 += v414;
          --v417;
        }
        while (v417);
        if (v30)
        {
          uint64_t v441 = &v1049[2 * v23];
          if ((unint64_t)v441 >= v30) {
            uint64_t v442 = v413;
          }
          else {
            uint64_t v442 = 0;
          }
          v14 += 2 * v24 + 2 * v442;
          if ((unint64_t)v441 >= v30) {
            uint64_t v443 = v412;
          }
          else {
            uint64_t v443 = 0;
          }
          unint64_t v27 = &v441[2 * v443];
          v15 += 2 * v443 + 2 * v23;
          short float v416 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v416 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 14:
      uint64_t v444 = v29;
      uint64_t v445 = v26;
      uint64_t v446 = -(v23 * v26);
      uint64_t v447 = -(uint64_t)(v24 * v445);
      uint64_t v448 = 2 * v29;
      uint64_t v449 = -(uint64_t)v25;
      float v450 = (__int16 *)v14;
      while (1)
      {
        int v451 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H2 = *v450;
              __asm { FCVT            S2, H2 }
            }
            else
            {
              _S2 = 1.0;
            }
            float v454 = (float)*v19 * 0.0039216;
            _S2 = v454 * _S2;
            __asm
            {
              FCVT            H2, S2
              FCMP            H2, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H4 = *(_WORD *)v27;
              __asm { FCVT            S4, H4 }
              _S3 = v454 * _S4;
              __asm { FCVT            H3, S3 }
              if (v1056)
              {
                __asm { FCMP            H4, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_372;
                }
                __asm { FCVT            S4, H4 }
              }
              else
              {
                _S4 = 1.0;
              }
              _H5 = *(_WORD *)v17;
              __asm
              {
                FCVT            S5, H5
                FCVT            S3, H3
              }
              _S3 = _S5 + (float)(_S3 * (float)(1.0 - _S5));
              __asm { FCVT            H3, S3 }
              if (v1056)
              {
                __asm { FCVT            S2, H2 }
                _S2 = (float)(_S4 + _S2) - (float)(_S4 * _S2);
                __asm { FCVT            H2, S2 }
LABEL_372:
                *(_WORD *)int v17 = _H3;
                *uint64_t v10 = _H2;
                goto LABEL_374;
              }
              *(_WORD *)int v17 = _H3;
            }
          }
LABEL_374:
          v19 += v444;
          uint64_t v469 = &v27[2 * v444];
          unsigned int v470 = &v450[v1055];
          if ((unint64_t)v469 >= v15) {
            uint64_t v471 = v449;
          }
          else {
            uint64_t v471 = 0;
          }
          float v450 = &v470[v471];
          unint64_t v27 = &v469[2 * v471];
          v10 += v1056;
          v17 += v448;
          --v451;
        }
        while (v451);
        if (v30)
        {
          int v472 = &v1049[2 * v23];
          if ((unint64_t)v472 >= v30) {
            uint64_t v473 = v447;
          }
          else {
            uint64_t v473 = 0;
          }
          v14 += 2 * v24 + 2 * v473;
          if ((unint64_t)v472 >= v30) {
            uint64_t v474 = v446;
          }
          else {
            uint64_t v474 = 0;
          }
          unint64_t v27 = &v472[2 * v474];
          v15 += 2 * v474 + 2 * v23;
          float v450 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v450 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 15:
      uint64_t v475 = v29;
      uint64_t v476 = v1055;
      uint64_t v1023 = -(uint64_t)(v24 * v26);
      uint64_t v1028 = -(v23 * v26);
      uint64_t v477 = 2 * v29;
      uint64_t v478 = -(uint64_t)v25;
      uint64_t v479 = (__int16 *)v14;
      while (1)
      {
        uint64_t v1038 = v14;
        int v1043 = v12;
        int v480 = v13;
        unint64_t v1050 = v15;
        int v481 = v1055;
        do
        {
          if (*v19)
          {
            if (v481)
            {
              _H0 = *v479;
              __asm { FCVT            S1, H0 }
            }
            else
            {
              _S1 = 1.0;
            }
            float v484 = (float)*v19 * 0.0039216;
            _S1 = v484 * _S1;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H2 = *(_WORD *)v27;
              __asm { FCVT            S2, H2 }
              _Q0.n128_f32[0] = v484 * _Q2.n128_f32[0];
              __asm { FCVT            H2, S0 }
              if (v1056)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_402;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = *(_WORD *)v17;
              _Q0.n128_u16[0] = PDAoverlayPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u16[0] = _Q0.n128_u16[0];
              if (v1056)
              {
                unint64_t v15 = v1050;
                int v481 = v1055;
                uint64_t v476 = v1055;
LABEL_402:
                *(_WORD *)int v17 = _Q2.n128_u16[0];
                *uint64_t v10 = _H1;
                goto LABEL_404;
              }
              *(_WORD *)int v17 = _Q0.n128_u16[0];
              unint64_t v15 = v1050;
              int v481 = v1055;
              uint64_t v476 = v1055;
            }
          }
LABEL_404:
          v19 += v475;
          float v491 = &v27[2 * v475];
          if ((unint64_t)v491 >= v15) {
            uint64_t v492 = v478;
          }
          else {
            uint64_t v492 = 0;
          }
          v479 += v476 + v492;
          unint64_t v27 = &v491[2 * v492];
          v10 += v1056;
          v17 += v477;
          --v480;
        }
        while (v480);
        if (v1037)
        {
          int v13 = v1036;
          uint64_t v493 = &v1049[2 * v1035];
          int v494 = v1043;
          uint64_t v495 = v1023;
          if ((unint64_t)v493 < v1037) {
            uint64_t v495 = 0;
          }
          uint64_t v14 = v1038 + 2 * v24 + 2 * v495;
          uint64_t v496 = v1028;
          if ((unint64_t)v493 < v1037) {
            uint64_t v496 = 0;
          }
          unint64_t v27 = &v493[2 * v496];
          v15 += 2 * v496 + 2 * v1035;
          uint64_t v479 = (__int16 *)(v1038 + 2 * v24 + 2 * v495);
          v1049 = v27;
          unint64_t v498 = v1033;
          uint64_t v497 = v1034;
        }
        else
        {
          int v13 = v1036;
          v27 += 2 * v1035;
          unint64_t v498 = v1033;
          v479 += v24;
          uint64_t v14 = v1038;
          int v494 = v1043;
          uint64_t v497 = v1034;
        }
        v19 += v497;
        v17 += 2 * v498;
        v10 += v1048;
        int v12 = v494 - 1;
        if (!v12) {
          return;
        }
      }
    case 16:
      uint64_t v499 = v29;
      uint64_t v500 = v26;
      uint64_t v501 = -(v23 * v26);
      uint64_t v502 = -(uint64_t)(v24 * v500);
      uint64_t v503 = 2 * v29;
      uint64_t v504 = -(uint64_t)v25;
      int v505 = (__int16 *)v14;
      while (1)
      {
        int v506 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H3 = *v505;
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            float v509 = (float)*v19 * 0.0039216;
            _S3 = v509 * _S3;
            __asm
            {
              FCVT            H3, S3
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H5 = *(_WORD *)v27;
              __asm { FCVT            S5, H5 }
              _S4 = v509 * _S5;
              __asm { FCVT            H4, S4 }
              if (v1056)
              {
                __asm { FCMP            H5, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_437;
                }
                __asm { FCVT            S5, H5 }
              }
              else
              {
                _S5 = 1.0;
              }
              __asm { FCVT            S6, H3 }
              _H7 = *(_WORD *)v17;
              __asm
              {
                FCVT            S7, H7
                FCVT            S4, H4
              }
              float v522 = _S6 * _S7;
              if ((float)(_S5 * _S4) < (float)(_S6 * _S7)) {
                float v522 = _S5 * _S4;
              }
              float v523 = v522 + (float)(_S7 * (float)(1.0 - _S6));
              if (_H3 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                _S3 = v522;
              }
              else {
                _S3 = v523;
              }
              float v525 = _S3 + (float)(_S4 * (float)(1.0 - _S5));
              if (_S5 != 1.0) {
                _S3 = v525;
              }
              __asm { FCVT            H4, S3 }
              if (v1056)
              {
                _S3 = (float)(_S5 + _S6) - (float)(_S5 * _S6);
                __asm { FCVT            H3, S3 }
LABEL_437:
                *(_WORD *)int v17 = _H4;
                *(short float *)uint64_t v10 = _H3;
                goto LABEL_439;
              }
              *(_WORD *)int v17 = _H4;
            }
          }
LABEL_439:
          v19 += v499;
          uint64_t v527 = &v27[2 * v499];
          int v528 = &v505[v1055];
          if ((unint64_t)v527 >= v15) {
            uint64_t v529 = v504;
          }
          else {
            uint64_t v529 = 0;
          }
          int v505 = &v528[v529];
          unint64_t v27 = &v527[2 * v529];
          v10 += v1056;
          v17 += v503;
          --v506;
        }
        while (v506);
        if (v30)
        {
          double v530 = &v1049[2 * v23];
          if ((unint64_t)v530 >= v30) {
            uint64_t v531 = v502;
          }
          else {
            uint64_t v531 = 0;
          }
          v14 += 2 * v24 + 2 * v531;
          if ((unint64_t)v530 >= v30) {
            uint64_t v532 = v501;
          }
          else {
            uint64_t v532 = 0;
          }
          unint64_t v27 = &v530[2 * v532];
          v15 += 2 * v532 + 2 * v23;
          int v505 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v505 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 17:
      uint64_t v533 = v29;
      uint64_t v534 = v26;
      uint64_t v535 = -(v23 * v26);
      uint64_t v536 = -(uint64_t)(v24 * v534);
      uint64_t v537 = 2 * v29;
      uint64_t v538 = -(uint64_t)v25;
      v539 = (__int16 *)v14;
      while (1)
      {
        int v540 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H3 = *v539;
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            float v543 = (float)*v19 * 0.0039216;
            _S3 = v543 * _S3;
            __asm
            {
              FCVT            H3, S3
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H5 = *(_WORD *)v27;
              __asm { FCVT            S5, H5 }
              _S4 = v543 * _S5;
              __asm { FCVT            H4, S4 }
              if (v1056)
              {
                __asm { FCMP            H5, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_474;
                }
                __asm { FCVT            S5, H5 }
              }
              else
              {
                _S5 = 1.0;
              }
              __asm { FCVT            S6, H3 }
              _H7 = *(_WORD *)v17;
              __asm
              {
                FCVT            S7, H7
                FCVT            S4, H4
              }
              float v556 = _S6 * _S7;
              if ((float)(_S5 * _S4) > (float)(_S6 * _S7)) {
                float v556 = _S5 * _S4;
              }
              float v557 = v556 + (float)(_S7 * (float)(1.0 - _S6));
              if (_H3 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                _S3 = v556;
              }
              else {
                _S3 = v557;
              }
              float v559 = _S3 + (float)(_S4 * (float)(1.0 - _S5));
              if (_S5 != 1.0) {
                _S3 = v559;
              }
              __asm { FCVT            H4, S3 }
              if (v1056)
              {
                _S3 = (float)(_S5 + _S6) - (float)(_S5 * _S6);
                __asm { FCVT            H3, S3 }
LABEL_474:
                *(_WORD *)int v17 = _H4;
                *(short float *)uint64_t v10 = _H3;
                goto LABEL_476;
              }
              *(_WORD *)int v17 = _H4;
            }
          }
LABEL_476:
          v19 += v533;
          unsigned int v561 = &v27[2 * v533];
          int v562 = &v539[v1055];
          if ((unint64_t)v561 >= v15) {
            uint64_t v563 = v538;
          }
          else {
            uint64_t v563 = 0;
          }
          v539 = &v562[v563];
          unint64_t v27 = &v561[2 * v563];
          v10 += v1056;
          v17 += v537;
          --v540;
        }
        while (v540);
        if (v30)
        {
          uint64_t v564 = &v1049[2 * v23];
          if ((unint64_t)v564 >= v30) {
            uint64_t v565 = v536;
          }
          else {
            uint64_t v565 = 0;
          }
          v14 += 2 * v24 + 2 * v565;
          if ((unint64_t)v564 >= v30) {
            uint64_t v566 = v535;
          }
          else {
            uint64_t v566 = 0;
          }
          unint64_t v27 = &v564[2 * v566];
          v15 += 2 * v566 + 2 * v23;
          v539 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v539 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 18:
      uint64_t v567 = v29;
      uint64_t v568 = v1055;
      uint64_t v1024 = -(uint64_t)(v24 * v26);
      uint64_t v1029 = -(v23 * v26);
      uint64_t v569 = 2 * v29;
      uint64_t v570 = -(uint64_t)v25;
      unsigned int v571 = (__int16 *)v14;
      while (1)
      {
        uint64_t v1039 = v14;
        int v1044 = v12;
        int v572 = v13;
        unint64_t v1051 = v15;
        int v573 = v1055;
        do
        {
          if (*v19)
          {
            if (v573)
            {
              _H0 = *v571;
              __asm { FCVT            S1, H0 }
            }
            else
            {
              _S1 = 1.0;
            }
            float v576 = (float)*v19 * 0.0039216;
            _S1 = v576 * _S1;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H2 = *(_WORD *)v27;
              __asm { FCVT            S2, H2 }
              _Q0.n128_f32[0] = v576 * _Q2.n128_f32[0];
              __asm { FCVT            H2, S0 }
              if (v1056)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_504;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = *(_WORD *)v17;
              _Q0.n128_u16[0] = PDAcolordodgePDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u16[0] = _Q0.n128_u16[0];
              if (v1056)
              {
                unint64_t v15 = v1051;
                int v573 = v1055;
                uint64_t v568 = v1055;
LABEL_504:
                *(_WORD *)int v17 = _Q2.n128_u16[0];
                *uint64_t v10 = _H1;
                goto LABEL_506;
              }
              *(_WORD *)int v17 = _Q0.n128_u16[0];
              unint64_t v15 = v1051;
              int v573 = v1055;
              uint64_t v568 = v1055;
            }
          }
LABEL_506:
          v19 += v567;
          int v583 = &v27[2 * v567];
          if ((unint64_t)v583 >= v15) {
            uint64_t v584 = v570;
          }
          else {
            uint64_t v584 = 0;
          }
          v571 += v568 + v584;
          unint64_t v27 = &v583[2 * v584];
          v10 += v1056;
          v17 += v569;
          --v572;
        }
        while (v572);
        if (v1037)
        {
          int v13 = v1036;
          uint64_t v585 = &v1049[2 * v1035];
          int v586 = v1044;
          uint64_t v587 = v1024;
          if ((unint64_t)v585 < v1037) {
            uint64_t v587 = 0;
          }
          uint64_t v14 = v1039 + 2 * v24 + 2 * v587;
          uint64_t v588 = v1029;
          if ((unint64_t)v585 < v1037) {
            uint64_t v588 = 0;
          }
          unint64_t v27 = &v585[2 * v588];
          v15 += 2 * v588 + 2 * v1035;
          unsigned int v571 = (__int16 *)(v1039 + 2 * v24 + 2 * v587);
          v1049 = v27;
          unint64_t v590 = v1033;
          uint64_t v589 = v1034;
        }
        else
        {
          int v13 = v1036;
          v27 += 2 * v1035;
          unint64_t v590 = v1033;
          v571 += v24;
          uint64_t v14 = v1039;
          int v586 = v1044;
          uint64_t v589 = v1034;
        }
        v19 += v589;
        v17 += 2 * v590;
        v10 += v1048;
        int v12 = v586 - 1;
        if (!v12) {
          return;
        }
      }
    case 19:
      uint64_t v591 = v29;
      uint64_t v592 = v1055;
      uint64_t v1025 = -(uint64_t)(v24 * v26);
      uint64_t v1030 = -(v23 * v26);
      uint64_t v593 = 2 * v29;
      uint64_t v594 = -(uint64_t)v25;
      uint64_t v595 = (__int16 *)v14;
      while (1)
      {
        uint64_t v1040 = v14;
        int v1045 = v12;
        int v596 = v13;
        unint64_t v1052 = v15;
        int v597 = v1055;
        do
        {
          if (*v19)
          {
            if (v597)
            {
              _H0 = *v595;
              __asm { FCVT            S1, H0 }
            }
            else
            {
              _S1 = 1.0;
            }
            float v600 = (float)*v19 * 0.0039216;
            _S1 = v600 * _S1;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H2 = *(_WORD *)v27;
              __asm { FCVT            S2, H2 }
              _Q0.n128_f32[0] = v600 * _Q2.n128_f32[0];
              __asm { FCVT            H2, S0 }
              if (v1056)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_532;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = *(_WORD *)v17;
              _Q0.n128_u16[0] = PDAcolorburnPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u16[0] = _Q0.n128_u16[0];
              if (v1056)
              {
                unint64_t v15 = v1052;
                int v597 = v1055;
                uint64_t v592 = v1055;
LABEL_532:
                *(_WORD *)int v17 = _Q2.n128_u16[0];
                *uint64_t v10 = _H1;
                goto LABEL_534;
              }
              *(_WORD *)int v17 = _Q0.n128_u16[0];
              unint64_t v15 = v1052;
              int v597 = v1055;
              uint64_t v592 = v1055;
            }
          }
LABEL_534:
          v19 += v591;
          v607 = &v27[2 * v591];
          if ((unint64_t)v607 >= v15) {
            uint64_t v608 = v594;
          }
          else {
            uint64_t v608 = 0;
          }
          v595 += v592 + v608;
          unint64_t v27 = &v607[2 * v608];
          v10 += v1056;
          v17 += v593;
          --v596;
        }
        while (v596);
        if (v1037)
        {
          int v13 = v1036;
          v609 = &v1049[2 * v1035];
          int v610 = v1045;
          uint64_t v611 = v1025;
          if ((unint64_t)v609 < v1037) {
            uint64_t v611 = 0;
          }
          uint64_t v14 = v1040 + 2 * v24 + 2 * v611;
          uint64_t v612 = v1030;
          if ((unint64_t)v609 < v1037) {
            uint64_t v612 = 0;
          }
          unint64_t v27 = &v609[2 * v612];
          v15 += 2 * v612 + 2 * v1035;
          uint64_t v595 = (__int16 *)(v1040 + 2 * v24 + 2 * v611);
          v1049 = v27;
          unint64_t v614 = v1033;
          uint64_t v613 = v1034;
        }
        else
        {
          int v13 = v1036;
          v27 += 2 * v1035;
          unint64_t v614 = v1033;
          v595 += v24;
          uint64_t v14 = v1040;
          int v610 = v1045;
          uint64_t v613 = v1034;
        }
        v19 += v613;
        v17 += 2 * v614;
        v10 += v1048;
        int v12 = v610 - 1;
        if (!v12) {
          return;
        }
      }
    case 20:
      uint64_t v615 = v29;
      uint64_t v616 = v1055;
      uint64_t v1026 = -(uint64_t)(v24 * v26);
      uint64_t v1031 = -(v23 * v26);
      uint64_t v617 = 2 * v29;
      uint64_t v618 = -(uint64_t)v25;
      v619 = (__int16 *)v14;
      while (1)
      {
        uint64_t v1041 = v14;
        int v1046 = v12;
        int v620 = v13;
        unint64_t v1053 = v15;
        int v621 = v1055;
        do
        {
          if (*v19)
          {
            if (v621)
            {
              _H0 = *v619;
              __asm { FCVT            S1, H0 }
            }
            else
            {
              _S1 = 1.0;
            }
            float v624 = (float)*v19 * 0.0039216;
            _S1 = v624 * _S1;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H2 = *(_WORD *)v27;
              __asm { FCVT            S2, H2 }
              _Q0.n128_f32[0] = v624 * _Q2.n128_f32[0];
              __asm { FCVT            H2, S0 }
              if (v1056)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_560;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = *(_WORD *)v17;
              _Q0.n128_u16[0] = PDAsoftlightPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u16[0] = _Q0.n128_u16[0];
              if (v1056)
              {
                unint64_t v15 = v1053;
                int v621 = v1055;
                uint64_t v616 = v1055;
LABEL_560:
                *(_WORD *)int v17 = _Q2.n128_u16[0];
                *uint64_t v10 = _H1;
                goto LABEL_562;
              }
              *(_WORD *)int v17 = _Q0.n128_u16[0];
              unint64_t v15 = v1053;
              int v621 = v1055;
              uint64_t v616 = v1055;
            }
          }
LABEL_562:
          v19 += v615;
          uint64_t v631 = &v27[2 * v615];
          if ((unint64_t)v631 >= v15) {
            uint64_t v632 = v618;
          }
          else {
            uint64_t v632 = 0;
          }
          v619 += v616 + v632;
          unint64_t v27 = &v631[2 * v632];
          v10 += v1056;
          v17 += v617;
          --v620;
        }
        while (v620);
        if (v1037)
        {
          int v13 = v1036;
          uint64_t v633 = &v1049[2 * v1035];
          int v634 = v1046;
          uint64_t v635 = v1026;
          if ((unint64_t)v633 < v1037) {
            uint64_t v635 = 0;
          }
          uint64_t v14 = v1041 + 2 * v24 + 2 * v635;
          uint64_t v636 = v1031;
          if ((unint64_t)v633 < v1037) {
            uint64_t v636 = 0;
          }
          unint64_t v27 = &v633[2 * v636];
          v15 += 2 * v636 + 2 * v1035;
          v619 = (__int16 *)(v1041 + 2 * v24 + 2 * v635);
          v1049 = v27;
          unint64_t v638 = v1033;
          uint64_t v637 = v1034;
        }
        else
        {
          int v13 = v1036;
          v27 += 2 * v1035;
          unint64_t v638 = v1033;
          v619 += v24;
          uint64_t v14 = v1041;
          int v634 = v1046;
          uint64_t v637 = v1034;
        }
        v19 += v637;
        v17 += 2 * v638;
        v10 += v1048;
        int v12 = v634 - 1;
        if (!v12) {
          return;
        }
      }
    case 21:
      uint64_t v639 = v29;
      uint64_t v640 = v1055;
      uint64_t v1027 = -(uint64_t)(v24 * v26);
      uint64_t v1032 = -(v23 * v26);
      uint64_t v641 = 2 * v29;
      uint64_t v642 = -(uint64_t)v25;
      uint64_t v643 = (__int16 *)v14;
      do
      {
        uint64_t v1042 = v14;
        int v1047 = v12;
        int v644 = v13;
        unint64_t v1054 = v15;
        int v645 = v1055;
        do
        {
          if (*v19)
          {
            if (v645)
            {
              _H0 = *v643;
              __asm { FCVT            S1, H0 }
            }
            else
            {
              _S1 = 1.0;
            }
            float v648 = (float)*v19 * 0.0039216;
            _S1 = v648 * _S1;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H2 = *(_WORD *)v27;
              __asm { FCVT            S2, H2 }
              _Q0.n128_f32[0] = v648 * _Q2.n128_f32[0];
              __asm { FCVT            H2, S0 }
              if (v1056)
              {
                __asm { FCMP            H0, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_588;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S3, H1 }
              _Q0.n128_u16[0] = *(_WORD *)v17;
              _Q0.n128_u16[0] = PDAhardlightPDA(_Q0, _S4, _Q2, _S3);
              _Q2.n128_u16[0] = _Q0.n128_u16[0];
              if (v1056)
              {
                unint64_t v15 = v1054;
                int v645 = v1055;
                uint64_t v640 = v1055;
LABEL_588:
                *(_WORD *)int v17 = _Q2.n128_u16[0];
                *uint64_t v10 = _H1;
                goto LABEL_590;
              }
              *(_WORD *)int v17 = _Q0.n128_u16[0];
              unint64_t v15 = v1054;
              int v645 = v1055;
              uint64_t v640 = v1055;
            }
          }
LABEL_590:
          v19 += v639;
          int v655 = &v27[2 * v639];
          if ((unint64_t)v655 >= v15) {
            uint64_t v656 = v642;
          }
          else {
            uint64_t v656 = 0;
          }
          v643 += v640 + v656;
          unint64_t v27 = &v655[2 * v656];
          v10 += v1056;
          v17 += v641;
          --v644;
        }
        while (v644);
        if (v1037)
        {
          int v13 = v1036;
          uint64_t v657 = &v1049[2 * v1035];
          int v658 = v1047;
          uint64_t v659 = v1027;
          if ((unint64_t)v657 < v1037) {
            uint64_t v659 = 0;
          }
          uint64_t v14 = v1042 + 2 * v24 + 2 * v659;
          uint64_t v660 = v1032;
          if ((unint64_t)v657 < v1037) {
            uint64_t v660 = 0;
          }
          unint64_t v27 = &v657[2 * v660];
          v15 += 2 * v660 + 2 * v1035;
          uint64_t v643 = (__int16 *)(v1042 + 2 * v24 + 2 * v659);
          v1049 = v27;
          unint64_t v662 = v1033;
          uint64_t v661 = v1034;
        }
        else
        {
          int v13 = v1036;
          v27 += 2 * v1035;
          unint64_t v662 = v1033;
          v643 += v24;
          uint64_t v14 = v1042;
          int v658 = v1047;
          uint64_t v661 = v1034;
        }
        v19 += v661;
        v17 += 2 * v662;
        v10 += v1048;
        int v12 = v658 - 1;
      }
      while (v12);
      return;
    case 22:
      uint64_t v663 = v29;
      uint64_t v664 = v26;
      uint64_t v665 = -(v23 * v26);
      uint64_t v666 = -(uint64_t)(v24 * v664);
      uint64_t v667 = 2 * v29;
      uint64_t v668 = -(uint64_t)v25;
      uint64_t v669 = (__int16 *)v14;
      while (1)
      {
        int v670 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H1 = *v669;
              __asm { FCVT            S2, H1 }
            }
            else
            {
              _S2 = 1.0;
            }
            float v673 = (float)*v19 * 0.0039216;
            _S2 = v673 * _S2;
            __asm
            {
              FCVT            H2, S2
              FCMP            H2, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H3 = *(_WORD *)v27;
              __asm { FCVT            S3, H3 }
              _S1 = v673 * _S3;
              __asm { FCVT            H1, S1 }
              if (v1056)
              {
                __asm { FCMP            H3, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_618;
                }
                __asm { FCVT            S3, H3 }
              }
              else
              {
                _S3 = 1.0;
              }
              __asm { FCVT            S2, H2 }
              _H4 = *(_WORD *)v17;
              __asm
              {
                FCVT            S4, H4
                FCVT            S1, H1
              }
              float v686 = _S1 + _S4;
              float v687 = _S2 * _S4;
              float v688 = _S3 * _S1;
              float v689 = v686 - v687;
              float v690 = v687 - v688;
              float v691 = v689 - v688;
              if (v690 < 0.0) {
                float v690 = -v690;
              }
              _S1 = v691 + v690;
              __asm { FCVT            H1, S1 }
              if (v1056)
              {
                _S2 = (float)(_S3 + _S2) - (float)(_S3 * _S2);
                __asm { FCVT            H2, S2 }
LABEL_618:
                *(_WORD *)int v17 = _H1;
                *uint64_t v10 = _H2;
                goto LABEL_620;
              }
              *(_WORD *)int v17 = _H1;
            }
          }
LABEL_620:
          v19 += v663;
          uint64_t v694 = &v27[2 * v663];
          int v695 = &v669[v1055];
          if ((unint64_t)v694 >= v15) {
            uint64_t v696 = v668;
          }
          else {
            uint64_t v696 = 0;
          }
          uint64_t v669 = &v695[v696];
          unint64_t v27 = &v694[2 * v696];
          v10 += v1056;
          v17 += v667;
          --v670;
        }
        while (v670);
        if (v30)
        {
          int v697 = &v1049[2 * v23];
          if ((unint64_t)v697 >= v30) {
            uint64_t v698 = v666;
          }
          else {
            uint64_t v698 = 0;
          }
          v14 += 2 * v24 + 2 * v698;
          if ((unint64_t)v697 >= v30) {
            uint64_t v699 = v665;
          }
          else {
            uint64_t v699 = 0;
          }
          unint64_t v27 = &v697[2 * v699];
          v15 += 2 * v699 + 2 * v23;
          uint64_t v669 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v669 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 23:
      uint64_t v700 = v29;
      uint64_t v701 = v26;
      uint64_t v702 = -(v23 * v26);
      uint64_t v703 = -(uint64_t)(v24 * v701);
      uint64_t v704 = 2 * v29;
      uint64_t v705 = -(uint64_t)v25;
      v706 = (__int16 *)v14;
      while (1)
      {
        int v707 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H2 = *v706;
              __asm { FCVT            S2, H2 }
            }
            else
            {
              _S2 = 1.0;
            }
            float v710 = (float)*v19 * 0.0039216;
            _S2 = v710 * _S2;
            __asm
            {
              FCVT            H2, S2
              FCMP            H2, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H4 = *(_WORD *)v27;
              __asm { FCVT            S4, H4 }
              _S3 = v710 * _S4;
              __asm { FCVT            H3, S3 }
              if (v1056)
              {
                __asm { FCMP            H4, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_648;
                }
                __asm { FCVT            S4, H4 }
              }
              else
              {
                _S4 = 1.0;
              }
              _H5 = *(_WORD *)v17;
              __asm
              {
                FCVT            S5, H5
                FCVT            S3, H3
              }
              _S3 = (float)(_S3 + _S5) + (float)((float)(_S3 * _S5) * -2.0);
              __asm { FCVT            H3, S3 }
              if (v1056)
              {
                __asm { FCVT            S2, H2 }
                _S2 = (float)(_S4 + _S2) - (float)(_S4 * _S2);
                __asm { FCVT            H2, S2 }
LABEL_648:
                *(_WORD *)int v17 = _H3;
                *uint64_t v10 = _H2;
                goto LABEL_650;
              }
              *(_WORD *)int v17 = _H3;
            }
          }
LABEL_650:
          v19 += v700;
          v725 = &v27[2 * v700];
          v726 = &v706[v1055];
          if ((unint64_t)v725 >= v15) {
            uint64_t v727 = v705;
          }
          else {
            uint64_t v727 = 0;
          }
          v706 = &v726[v727];
          unint64_t v27 = &v725[2 * v727];
          v10 += v1056;
          v17 += v704;
          --v707;
        }
        while (v707);
        if (v30)
        {
          int v728 = &v1049[2 * v23];
          if ((unint64_t)v728 >= v30) {
            uint64_t v729 = v703;
          }
          else {
            uint64_t v729 = 0;
          }
          v14 += 2 * v24 + 2 * v729;
          if ((unint64_t)v728 >= v30) {
            uint64_t v730 = v702;
          }
          else {
            uint64_t v730 = 0;
          }
          unint64_t v27 = &v728[2 * v730];
          v15 += 2 * v730 + 2 * v23;
          v706 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v706 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 24:
      uint64_t v731 = v29;
      uint64_t v732 = v26;
      uint64_t v733 = -(v23 * v26);
      uint64_t v734 = -(uint64_t)(v24 * v732);
      LOWORD(v735) = COERCE_UNSIGNED_INT(1.0);
      uint64_t v736 = 2 * v29;
      uint64_t v737 = -(uint64_t)v25;
      v738 = (__int16 *)v14;
      while (1)
      {
        int v739 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H4 = *v738;
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            float v742 = (float)*v19 * 0.0039216;
            _S4 = v742 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H6 = *(_WORD *)v27;
              __asm { FCVT            S6, H6 }
              _S5 = v742 * _S6;
              __asm { FCVT            H5, S5 }
              if (v1056)
              {
                __asm { FCMP            H6, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_686;
                }
                __asm { FCVT            S6, H6 }
              }
              else
              {
                _S6 = 1.0;
              }
              __asm { FCVT            S7, H4 }
              _H16 = *(_WORD *)v17;
              __asm
              {
                FCVT            S16, H16
                FCVT            S5, H5
              }
              _ZF = _H4 == v735;
              if (_H4 == v735) {
                float v756 = _S16;
              }
              else {
                float v756 = _S7 * _S16;
              }
              if (_ZF) {
                float v757 = 0.0;
              }
              else {
                float v757 = _S16 - (float)(_S7 * _S16);
              }
              float v758 = (float)(v757 + _S5) - (float)(_S6 * _S5);
              if (_S6 == 1.0) {
                float v758 = v757;
              }
              _S4 = v756 + v758;
              __asm { FCVT            H5, S4 }
              if (v1056)
              {
                _S4 = (float)(_S6 + _S7) - (float)(_S6 * _S7);
                __asm { FCVT            H4, S4 }
LABEL_686:
                *(_WORD *)int v17 = _H5;
                *(short float *)uint64_t v10 = _H4;
                goto LABEL_688;
              }
              *(_WORD *)int v17 = _H5;
            }
          }
LABEL_688:
          v19 += v731;
          int v761 = &v27[2 * v731];
          int v762 = &v738[v1055];
          if ((unint64_t)v761 >= v15) {
            uint64_t v763 = v737;
          }
          else {
            uint64_t v763 = 0;
          }
          v738 = &v762[v763];
          unint64_t v27 = &v761[2 * v763];
          v10 += v1056;
          v17 += v736;
          --v739;
        }
        while (v739);
        if (v30)
        {
          uint64_t v764 = &v1049[2 * v23];
          if ((unint64_t)v764 >= v30) {
            uint64_t v765 = v734;
          }
          else {
            uint64_t v765 = 0;
          }
          v14 += 2 * v24 + 2 * v765;
          if ((unint64_t)v764 >= v30) {
            uint64_t v766 = v733;
          }
          else {
            uint64_t v766 = 0;
          }
          unint64_t v27 = &v764[2 * v766];
          v15 += 2 * v766 + 2 * v23;
          v738 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v738 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 25:
      uint64_t v767 = v29;
      uint64_t v768 = v26;
      uint64_t v769 = -(v23 * v26);
      uint64_t v770 = -(uint64_t)(v24 * v768);
      LOWORD(v771) = COERCE_UNSIGNED_INT(1.0);
      uint64_t v772 = 2 * v29;
      uint64_t v773 = -(uint64_t)v25;
      v774 = (__int16 *)v14;
      while (1)
      {
        int v775 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H4 = *v774;
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            float v778 = (float)*v19 * 0.0039216;
            _S4 = v778 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H6 = *(_WORD *)v27;
              __asm { FCVT            S6, H6 }
              _S5 = v778 * _S6;
              __asm { FCVT            H5, S5 }
              if (v1056)
              {
                __asm { FCMP            H6, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_724;
                }
                __asm { FCVT            S6, H6 }
              }
              else
              {
                _S6 = 1.0;
              }
              __asm { FCVT            S7, H4 }
              _H16 = *(_WORD *)v17;
              __asm
              {
                FCVT            S16, H16
                FCVT            S5, H5
              }
              BOOL v791 = _H4 == v771;
              if (_H4 == v771) {
                float v792 = _S16;
              }
              else {
                float v792 = _S7 * _S16;
              }
              if (v791) {
                float v793 = 0.0;
              }
              else {
                float v793 = _S16 - (float)(_S7 * _S16);
              }
              float v794 = (float)(v793 + _S5) - (float)(_S6 * _S5);
              if (_S6 == 1.0) {
                float v794 = v793;
              }
              _S4 = v792 + v794;
              __asm { FCVT            H5, S4 }
              if (v1056)
              {
                _S4 = (float)(_S6 + _S7) - (float)(_S6 * _S7);
                __asm { FCVT            H4, S4 }
LABEL_724:
                *(_WORD *)int v17 = _H5;
                *(short float *)uint64_t v10 = _H4;
                goto LABEL_726;
              }
              *(_WORD *)int v17 = _H5;
            }
          }
LABEL_726:
          v19 += v767;
          int v797 = &v27[2 * v767];
          v798 = &v774[v1055];
          if ((unint64_t)v797 >= v15) {
            uint64_t v799 = v773;
          }
          else {
            uint64_t v799 = 0;
          }
          v774 = &v798[v799];
          unint64_t v27 = &v797[2 * v799];
          v10 += v1056;
          v17 += v772;
          --v775;
        }
        while (v775);
        if (v30)
        {
          v800 = &v1049[2 * v23];
          if ((unint64_t)v800 >= v30) {
            uint64_t v801 = v770;
          }
          else {
            uint64_t v801 = 0;
          }
          v14 += 2 * v24 + 2 * v801;
          if ((unint64_t)v800 >= v30) {
            uint64_t v802 = v769;
          }
          else {
            uint64_t v802 = 0;
          }
          unint64_t v27 = &v800[2 * v802];
          v15 += 2 * v802 + 2 * v23;
          v774 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v774 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 26:
      uint64_t v803 = v29;
      uint64_t v804 = v26;
      uint64_t v805 = -(v23 * v26);
      uint64_t v806 = -(uint64_t)(v24 * v804);
      uint64_t v807 = 2 * v29;
      uint64_t v808 = -(uint64_t)v25;
      LOWORD(v809) = COERCE_UNSIGNED_INT(1.0);
      int v810 = (__int16 *)v14;
      while (1)
      {
        int v811 = v13;
        do
        {
          if (*v19)
          {
            if (v1055)
            {
              _H4 = *v810;
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            float v814 = (float)*v19 * 0.0039216;
            _S4 = v814 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              _H6 = *(_WORD *)v27;
              __asm { FCVT            S6, H6 }
              _S5 = v814 * _S6;
              __asm { FCVT            H5, S5 }
              if (v1056)
              {
                __asm { FCMP            H6, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_761;
                }
                __asm { FCVT            S6, H6 }
              }
              else
              {
                _S6 = 1.0;
              }
              __asm { FCVT            S7, H4 }
              _H16 = *(_WORD *)v17;
              __asm
              {
                FCVT            S16, H16
                FCVT            S5, H5
              }
              float v827 = _S5 - (float)(_S6 * _S5);
              if (_S6 == 1.0) {
                float v827 = 0.0;
              }
              BOOL v828 = _H4 == v809;
              if (_H4 == v809) {
                float v829 = _S16;
              }
              else {
                float v829 = _S7 * _S16;
              }
              if (!v828) {
                float v827 = (float)(v827 + _S16) - (float)(_S7 * _S16);
              }
              _S4 = v829 + v827;
              __asm { FCVT            H5, S4 }
              if (v1056)
              {
                _S4 = (float)(_S6 + _S7) - (float)(_S6 * _S7);
                __asm { FCVT            H4, S4 }
LABEL_761:
                *(_WORD *)int v17 = _H5;
                *(short float *)uint64_t v10 = _H4;
                goto LABEL_763;
              }
              *(_WORD *)int v17 = _H5;
            }
          }
LABEL_763:
          v19 += v803;
          v832 = &v27[2 * v803];
          v833 = &v810[v1055];
          if ((unint64_t)v832 >= v15) {
            uint64_t v834 = v808;
          }
          else {
            uint64_t v834 = 0;
          }
          int v810 = &v833[v834];
          unint64_t v27 = &v832[2 * v834];
          v10 += v1056;
          v17 += v807;
          --v811;
        }
        while (v811);
        if (v30)
        {
          v835 = &v1049[2 * v23];
          if ((unint64_t)v835 >= v30) {
            uint64_t v836 = v806;
          }
          else {
            uint64_t v836 = 0;
          }
          v14 += 2 * v24 + 2 * v836;
          if ((unint64_t)v835 >= v30) {
            uint64_t v837 = v805;
          }
          else {
            uint64_t v837 = 0;
          }
          unint64_t v27 = &v835[2 * v837];
          v15 += 2 * v837 + 2 * v23;
          int v810 = (__int16 *)v14;
          v1049 = v27;
        }
        else
        {
          v27 += 2 * v23;
          v810 += v24;
        }
        v19 += v35;
        v17 += 2 * v36;
        v10 += v1048;
        if (!--v12) {
          return;
        }
      }
    case 27:
      uint64_t v838 = v29;
      uint64_t v839 = v26;
      uint64_t v840 = -(v23 * v26);
      uint64_t v841 = -(uint64_t)(v24 * v839);
      uint64_t v842 = 2 * v29;
      uint64_t v843 = -(uint64_t)v25;
      __int16 v844 = (__int16 *)v14;
      break;
    default:
      return;
  }
LABEL_779:
  int v845 = v13;
  while (1)
  {
    if (!*v19) {
      goto LABEL_798;
    }
    if (v1055)
    {
      _H4 = *v844;
      __asm { FCVT            S4, H4 }
    }
    else
    {
      _S4 = 1.0;
    }
    float v848 = (float)*v19 * 0.0039216;
    _S4 = v848 * _S4;
    __asm
    {
      FCVT            H4, S4
      FCMP            H4, #0
    }
    if (_NF ^ _VF | _ZF) {
      goto LABEL_798;
    }
    _H6 = *(_WORD *)v27;
    __asm { FCVT            S6, H6 }
    _S5 = v848 * _S6;
    __asm { FCVT            H5, S5 }
    if (v1056)
    {
      __asm { FCMP            H6, #0 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_796;
      }
      __asm { FCVT            S6, H6 }
    }
    else
    {
      _S6 = 1.0;
    }
    __asm { FCVT            S7, H4 }
    _H16 = *(_WORD *)v17;
    __asm
    {
      FCVT            S5, H5
      FCVT            S16, H16
    }
    float v861 = _S16 - (float)(_S7 * _S16);
    if (_H4 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
      float v862 = 0.0;
    }
    else {
      float v862 = v861;
    }
    float v863 = (float)(v862 + _S5) - (float)(_S6 * _S5);
    if (_S6 != 1.0)
    {
      _S5 = _S6 * _S5;
      float v862 = v863;
    }
    _S4 = _S5 + v862;
    __asm { FCVT            H5, S4 }
    if (!v1056)
    {
      *(_WORD *)int v17 = _H5;
      goto LABEL_798;
    }
    _S4 = (float)(_S6 + _S7) - (float)(_S6 * _S7);
    __asm { FCVT            H4, S4 }
LABEL_796:
    *(_WORD *)int v17 = _H5;
    *(short float *)uint64_t v10 = _H4;
LABEL_798:
    v19 += v838;
    v866 = &v27[2 * v838];
    int v867 = &v844[v1055];
    if ((unint64_t)v866 >= v15) {
      uint64_t v868 = v843;
    }
    else {
      uint64_t v868 = 0;
    }
    __int16 v844 = &v867[v868];
    unint64_t v27 = &v866[2 * v868];
    v10 += v1056;
    v17 += v842;
    if (!--v845)
    {
      if (v30)
      {
        v869 = &v1049[2 * v23];
        if ((unint64_t)v869 >= v30) {
          uint64_t v870 = v841;
        }
        else {
          uint64_t v870 = 0;
        }
        v14 += 2 * v24 + 2 * v870;
        if ((unint64_t)v869 >= v30) {
          uint64_t v871 = v840;
        }
        else {
          uint64_t v871 = 0;
        }
        unint64_t v27 = &v869[2 * v871];
        v15 += 2 * v871 + 2 * v23;
        __int16 v844 = (__int16 *)v14;
        v1049 = v27;
      }
      else
      {
        v27 += 2 * v23;
        v844 += v24;
      }
      v19 += v35;
      v17 += 2 * v36;
      v10 += v1048;
      if (!--v12) {
        return;
      }
      goto LABEL_779;
    }
  }
}

uint64_t Wf16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (int *)*a1;
  memset(v30, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v25, (uint64_t)v30) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  unsigned int v19 = *(_DWORD *)a3;
  int v26 = v19;
  int v27 = v18;
  if (v19 != 68161829)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 <= 0x1B) {
        _CGHandleAssert("Wf16_image_inner", 12766, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_white_float16.cc", "index > SAMPLEF", "unexected format (%d)", v21, v22, v23, *(_DWORD *)a3);
      }
      int v25 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, int))WF16_image_sample[v20 + 1];
      if (v25)
      {
        int v24 = 136319269;
LABEL_20:
        int v26 = v24;
        goto LABEL_21;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        int v25 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W8_image_sample[2 * v20 + 2];
        if (v25)
        {
          int v24 = 34083076;
          goto LABEL_20;
        }
      }
      int v25 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W16_image_sample[2 * v20 + 2];
      if (v25)
      {
        int v26 = 68161828;
        goto LABEL_21;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v29 && (~v28 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v28 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      Wf16_mark_inner(*(void *)(*a1 + 56), v17);
      return 1;
    }
  }
  int v25 = Wf16_sample_Wf_inner;
LABEL_21:
  Wf16_image_mark((uint64_t)a2, (uint64_t)&v25, v8, v17);
  return 1;
}

void Wf16_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v794 = a3;
  uint64_t v806 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  int v795 = *(_DWORD *)(a1 + 8);
  unint64_t v5 = *(int *)(a1 + 28);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  float v8 = *(float *)(a2 + 184);
  unint64_t v9 = *(int **)(a1 + 136);
  uint64_t v796 = *(void *)(a2 + 96);
  uint64_t v802 = *(void *)(a2 + 104);
  int v805 = 0;
  *(void *)(a2 + 264) = &v805;
  uint64_t v793 = (int)v4;
  unint64_t v10 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v10 > 0x1FFFFFF) {
    return;
  }
  uint64_t v13 = *(int *)(a1 + 12);
  uint64_t v12 = *(int *)(a1 + 16);
  float v792 = (void *)a2;
  uint64_t v804 = *(int *)(a2 + 16);
  uint64_t v14 = (v804 + 6) * v10;
  if (v14 > 65439)
  {
    __n128 v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x2DF49CC5uLL);
    uint64_t v16 = v17;
    unsigned int v19 = v17;
    unsigned int v20 = v792;
    if (!v17) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    uint64_t v16 = (char *)&v787 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    unsigned int v19 = 0;
    unsigned int v20 = v792;
  }
  v789 = v19;
  unint64_t v21 = v5 >> 1;
  unint64_t v22 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v23 = v22 + ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v804) {
    uint64_t v24 = 4 * v10;
  }
  else {
    uint64_t v24 = 0;
  }
  unint64_t v25 = v23 + v24;
  v20[18] = v22;
  v20[19] = v25;
  v20[20] = v23;
  int v26 = v20;
  if (v7)
  {
    unint64_t v27 = (unint64_t)*(int *)(a1 + 32) >> 1;
    int v28 = (short float *)(v7 + 2 * (v13 + v27 * v12));
    uint64_t v29 = v793;
    uint64_t v800 = v27 - v793;
    uint64_t v30 = 1;
  }
  else
  {
    int v28 = 0;
    uint64_t v800 = 0;
    uint64_t v30 = 0;
    uint64_t v29 = v793;
  }
  uint64_t v31 = (unsigned __int16 *)(v6 + 2 * (v13 + v21 * v12));
  uint64_t v799 = v21 - v29;
  uint64_t v32 = *(int *)(a1 + 104);
  int v33 = *(_DWORD *)(a1 + 108);
  int v34 = *(unsigned __int8 *)(a1 + 2);
  if (v34 == 6 || v34 == 1)
  {
    int v35 = v794;
    uint64_t v36 = v796;
    uint64_t v37 = v802;
    if (!v9) {
      goto LABEL_608;
    }
    unint64_t v788 = v21;
    unsigned int v38 = 0;
    LODWORD(v804) = 0;
    uint64_t v39 = *(int *)(a1 + 124);
    unsigned int v40 = (unsigned __int8 *)v9 + v32 + (int)v39 * (uint64_t)v33;
    uint64_t v29 = v793;
    uint64_t v798 = v39 - v793;
LABEL_21:
    int v46 = v795;
    goto LABEL_22;
  }
  unint64_t v788 = v21;
  uint64_t v36 = v796;
  uint64_t v37 = v802;
  if (!v9)
  {
    uint64_t v798 = 0;
    unsigned int v38 = 0;
    unsigned int v40 = 0;
    LODWORD(v804) = 0;
    int v35 = v794;
    goto LABEL_21;
  }
  unint64_t v41 = v25;
  uint64_t v801 = v30;
  shape_enum_clip_alloc((uint64_t)v17, v18, v9, 1, 1, 1, v32, v33, v4, v795);
  if (!v42) {
    goto LABEL_608;
  }
  uint64_t v803 = v42;
  int v43 = 0;
  uint64_t v44 = (int)((v804 * v10 + 15) & 0xFFFFFFF0);
  if (!v804) {
    uint64_t v44 = 4 * v10;
  }
  uint64_t v45 = v793;
  uint64_t v798 = -v793;
  unsigned int v40 = (unsigned __int8 *)(v41 + v44 + 16);
  int v35 = v794;
  int v46 = v795;
LABEL_596:
  uint64_t v781 = v800 + v45;
  while (1)
  {
    LODWORD(v804) = v43;
    while (1)
    {
      int v782 = *((_DWORD *)v40 - 4);
      int v783 = v782 - v43;
      if (v782 > v43) {
        break;
      }
      unsigned int v38 = v803;
      if (v43 < *((_DWORD *)v40 - 3) + v782)
      {
        uint64_t v29 = v793;
        uint64_t v36 = v796;
        uint64_t v30 = v801;
LABEL_22:
        uint64_t v790 = -v29;
        uint64_t v791 = (v4 - 1) + 1;
        uint64_t v47 = 2 * v30;
        uint64_t v48 = v38;
        uint64_t v797 = v4;
        uint64_t v801 = v30;
        while (2)
        {
          uint64_t v802 = v37;
          uint64_t v803 = v48;
          *((_DWORD *)v26 + 60) = v46;
          ((void (*)(void *, uint64_t, uint64_t, uint64_t))*v26)(v26, v36, v37, v4);
          unsigned int v52 = (_WORD *)v26[20];
          uint64_t v53 = (unsigned __int8 *)v26[18];
          unsigned int v54 = *((_DWORD *)v26 + 2);
          if (v54 == *((_DWORD *)v26 + 3))
          {
            if (v8 >= 1.0)
            {
              int v57 = v801;
            }
            else
            {
              int v55 = v4;
              unint64_t v56 = (unsigned char *)v26[18];
              int v57 = v801;
              do
              {
                if (*v56)
                {
                  _H0 = *(short float *)v52;
                  __asm { FCVT            S0, H0 }
                  _S0 = v8 * _S0;
                  __asm { FCVT            H0, S0 }
                  _WORD *v52 = LOWORD(_S0);
                  LOWORD(_S0) = v52[1];
                  __asm { FCVT            S0, H0 }
                  _S0 = v8 * _S0;
                  __asm { FCVT            H0, S0 }
                  v52[1] = LOWORD(_S0);
                }
                ++v56;
                v52 += 2;
                --v55;
              }
              while (v55);
              v52 += 2 * v790;
              v53 += v791 + v790;
            }
          }
          else
          {
            uint64_t v66 = v26[19];
            int v67 = HIWORD(v54) & 0x3F;
            if (v67 == 16)
            {
              int v57 = v801;
              uint64_t v76 = 0;
              int v77 = v52 + 1;
              if (v8 >= 1.0)
              {
                do
                {
                  if (v53[v76])
                  {
                    unint64_t v81 = *(unsigned int *)(v66 + 4 * v76);
                    _S0 = *(float *)&_blt_float[v81 + 256] + *(float *)&_blt_float[BYTE1(v81) + 512];
                    __asm { FCVT            H0, S0 }
                    *(v77 - 1) = LOWORD(_S0);
                    _S0 = *(float *)&_blt_float[BYTE2(v81) + 256]
                        + *(float *)((char *)&_blt_float[512] + ((v81 >> 22) & 0x3FC));
                    __asm { FCVT            H0, S0 }
                    *int v77 = LOWORD(_S0);
                  }
                  ++v76;
                  v77 += 2;
                }
                while (v4 != v76);
              }
              else
              {
                do
                {
                  if (v53[v76])
                  {
                    unint64_t v78 = *(unsigned int *)(v66 + 4 * v76);
                    _S0 = v8
                        * (float)(*(float *)&_blt_float[v78 + 256]
                                + *(float *)&_blt_float[BYTE1(v78) + 512]);
                    __asm { FCVT            H0, S0 }
                    *(v77 - 1) = LOWORD(_S0);
                    _S0 = v8
                        * (float)(*(float *)&_blt_float[BYTE2(v78) + 256]
                                + *(float *)((char *)&_blt_float[512] + ((v78 >> 22) & 0x3FC)));
                    __asm { FCVT            H0, S0 }
                    *int v77 = LOWORD(_S0);
                  }
                  ++v76;
                  v77 += 2;
                }
                while (v4 != v76);
              }
            }
            else
            {
              _ZF = v67 == 32;
              int v57 = v801;
              uint64_t v68 = 0;
              if (_ZF)
              {
                uint64_t v69 = 0;
                if (v8 >= 1.0)
                {
                  do
                  {
                    if (v53[v68]) {
                      *(_DWORD *)&v52[v69] = *(_DWORD *)(v66 + v69 * 2);
                    }
                    v69 += 2;
                    ++v68;
                  }
                  while (v4 != v68);
                }
                else
                {
                  do
                  {
                    if (v53[v68])
                    {
                      _H0 = *(_WORD *)(v66 + v69 * 2);
                      __asm { FCVT            S0, H0 }
                      _S0 = v8 * _S0;
                      __asm { FCVT            H0, S0 }
                      uint64_t v73 = &v52[v69];
                      *uint64_t v73 = LOWORD(_S0);
                      LOWORD(_S0) = *(_WORD *)(v66 + v69 * 2 + 2);
                      __asm { FCVT            S0, H0 }
                      _S0 = v8 * _S0;
                      __asm { FCVT            H0, S0 }
                      v73[1] = LOWORD(_S0);
                    }
                    v69 += 2;
                    ++v68;
                  }
                  while (v4 != v68);
                }
              }
              else
              {
                unsigned int v84 = v52 + 1;
                if (v8 >= 1.0)
                {
                  do
                  {
                    if (v53[v68])
                    {
                      unint64_t v88 = *(unsigned int *)(v66 + 4 * v68);
                      _S0 = _blt_float[*(_DWORD *)(v66 + 4 * v68)];
                      __asm { FCVT            H0, S0 }
                      *(v84 - 1) = _S0;
                      _S0 = *(_DWORD *)((char *)_blt_float + ((v88 >> 22) & 0x3FC));
                      __asm { FCVT            H0, S0 }
                      *unsigned int v84 = _S0;
                    }
                    ++v68;
                    v84 += 2;
                  }
                  while (v4 != v68);
                }
                else
                {
                  do
                  {
                    if (v53[v68])
                    {
                      unint64_t v85 = *(unsigned int *)(v66 + 4 * v68);
                      _S0 = v8 * *(float *)&_blt_float[*(_DWORD *)(v66 + 4 * v68)];
                      __asm { FCVT            H0, S0 }
                      *(v84 - 1) = LOWORD(_S0);
                      _S0 = v8 * *(float *)((char *)_blt_float + ((v85 >> 22) & 0x3FC));
                      __asm { FCVT            H0, S0 }
                      *unsigned int v84 = LOWORD(_S0);
                    }
                    ++v68;
                    v84 += 2;
                  }
                  while (v4 != v68);
                }
              }
            }
          }
          uint64_t v91 = &xmmword_1850CE000;
          switch(v35)
          {
            case 0:
              uint64_t v92 = v40 != 0;
              int v93 = v4;
              unsigned int v94 = v40;
              if (v57)
              {
                do
                {
                  unsigned int v95 = *v53;
                  if (*v53)
                  {
                    if (v40) {
                      unsigned int v95 = (*v94 * v95 + ((*v94 * v95) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v95)
                    {
                      if (v95 == 255)
                      {
                        *(_WORD *)int v28 = 0;
                        *uint64_t v31 = 0;
                      }
                      else
                      {
                        _H0 = *v31;
                        __asm { FCVT            S0, H0 }
                        float v98 = (float)((float)v95 * -0.0039216) + 1.0;
                        _S0 = v98 * _S0;
                        __asm { FCVT            H0, S0 }
                        *uint64_t v31 = LOWORD(_S0);
                        *(short float *)&_S0 = *v28;
                        __asm { FCVT            S0, H0 }
                        _S0 = v98 * _S0;
                        __asm { FCVT            H0, S0 }
                        *int v28 = *(short float *)&_S0;
                      }
                    }
                  }
                  ++v53;
                  v94 += v92;
                  ++v31;
                  ++v28;
                  --v93;
                }
                while (v93);
              }
              else
              {
                do
                {
                  unsigned int v102 = *v53;
                  if (*v53)
                  {
                    if (v40) {
                      unsigned int v102 = (*v94 * v102 + ((*v94 * v102) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v102)
                    {
                      _H0 = 0;
                      if (v102 != 255)
                      {
                        _H0 = *v31;
                        __asm { FCVT            S0, H0 }
                        _S0 = (float)((float)((float)v102 * -0.0039216) + 1.0) * _S0;
                        __asm { FCVT            H0, S0 }
                      }
                      *uint64_t v31 = _H0;
                    }
                  }
                  ++v53;
                  v94 += v92;
                  ++v31;
                  --v93;
                }
                while (v93);
              }
              goto LABEL_512;
            case 1:
              unsigned __int8 v107 = *v53;
              if (v57)
              {
                uint64_t v108 = v31 - 1;
                uint64_t v109 = v52 + 1;
                uint64_t v110 = v53 + 1;
                uint64_t v111 = v28 - 1;
                int v112 = v4;
                if (v40)
                {
                  uint64_t v113 = v802;
                  do
                  {
                    if (v107)
                    {
                      unsigned int v114 = ((unsigned __int16)(*v40 * v107 + ((*v40 * v107) >> 8) + 1) >> 8);
                      if (v114)
                      {
                        if (v114 == 255)
                        {
                          v108[1] = *(v109 - 1);
                          _H0 = *v109;
                        }
                        else
                        {
                          float v116 = (float)v114 * 0.0039216;
                          _H1 = *(v109 - 1);
                          __asm { FCVT            S1, H1 }
                          _H2 = v108[1];
                          __asm { FCVT            S2, H2 }
                          _S1 = (float)((float)(1.0 - v116) * _S2) + (float)(_S1 * v116);
                          __asm { FCVT            H1, S1 }
                          v108[1] = LOWORD(_S1);
                          LOWORD(_S1) = *v109;
                          __asm { FCVT            S1, H1 }
                          *(short float *)&_S2 = v111[1];
                          __asm { FCVT            S2, H2 }
                          _S0 = (float)((float)(1.0 - v116) * _S2) + (float)(_S1 * v116);
                          __asm { FCVT            H0, S0 }
                        }
                        *((_WORD *)v111 + 1) = _H0;
                      }
                    }
                    unsigned __int8 v125 = *v110++;
                    unsigned __int8 v107 = v125;
                    ++v40;
                    ++v108;
                    v109 += 2;
                    ++v111;
                    --v112;
                  }
                  while (v112);
                  v40 += v798;
                }
                else
                {
                  uint64_t v113 = v802;
                  do
                  {
                    if (v107)
                    {
                      if (v107 == 255)
                      {
                        v108[1] = *(v109 - 1);
                        _H0 = *v109;
                      }
                      else
                      {
                        float v718 = (float)v107 * 0.0039216;
                        _H1 = *(v109 - 1);
                        __asm { FCVT            S1, H1 }
                        _H2 = v108[1];
                        __asm { FCVT            S2, H2 }
                        _S1 = (float)((float)(1.0 - v718) * _S2) + (float)(_S1 * v718);
                        __asm { FCVT            H1, S1 }
                        v108[1] = LOWORD(_S1);
                        LOWORD(_S1) = *v109;
                        __asm { FCVT            S1, H1 }
                        *(short float *)&_S2 = v111[1];
                        __asm { FCVT            S2, H2 }
                        _S0 = (float)((float)(1.0 - v718) * _S2) + (float)(_S1 * v718);
                        __asm { FCVT            H0, S0 }
                      }
                      *((_WORD *)v111 + 1) = _H0;
                    }
                    unsigned __int8 v727 = *v110++;
                    unsigned __int8 v107 = v727;
                    ++v108;
                    v109 += 2;
                    ++v111;
                    --v112;
                  }
                  while (v112);
                  unsigned int v40 = 0;
                }
                uint64_t v31 = &v108[v799 + 1];
                int v28 = &v111[v800 + 1];
                goto LABEL_515;
              }
              v677 = v53 + 1;
              uint64_t v678 = (short float *)(v31 - 1);
              int v679 = v4;
              if (v40)
              {
                uint64_t v113 = v802;
                do
                {
                  if (v107)
                  {
                    unsigned int v680 = ((unsigned __int16)(*v40 * v107 + ((*v40 * v107) >> 8) + 1) >> 8);
                    if (v680)
                    {
                      if (v680 == 255)
                      {
                        _H0 = *(short float *)v52;
                      }
                      else
                      {
                        _H1 = *(short float *)v52;
                        __asm { FCVT            S1, H1 }
                        _H2 = *((_WORD *)v678 + 1);
                        __asm { FCVT            S2, H2 }
                        _S0 = (float)((float)(1.0 - (float)((float)v680 * 0.0039216)) * _S2)
                            + (float)(_S1 * (float)((float)v680 * 0.0039216));
                        __asm { FCVT            H0, S0 }
                      }
                      v678[1] = _H0;
                    }
                  }
                  unsigned __int8 v687 = *v677++;
                  unsigned __int8 v107 = v687;
                  v52 += 2;
                  ++v40;
                  ++v678;
                  --v679;
                }
                while (v679);
                goto LABEL_542;
              }
              uint64_t v113 = v802;
              do
              {
                if (v107)
                {
                  if (v107 == 255)
                  {
                    _H0 = *(short float *)v52;
                  }
                  else
                  {
                    _H1 = *(short float *)v52;
                    __asm { FCVT            S1, H1 }
                    _H2 = *((_WORD *)v678 + 1);
                    __asm { FCVT            S2, H2 }
                    _S0 = (float)((float)(1.0 - (float)((float)v107 * 0.0039216)) * _S2)
                        + (float)(_S1 * (float)((float)v107 * 0.0039216));
                    __asm { FCVT            H0, S0 }
                  }
                  v678[1] = _H0;
                }
                unsigned __int8 v758 = *v677++;
                unsigned __int8 v107 = v758;
                v52 += 2;
                ++v678;
                --v679;
              }
              while (v679);
              goto LABEL_594;
            case 2:
              unsigned __int8 v126 = *v53;
              if (v57)
              {
                float v127 = v31 - 1;
                uint64_t v128 = v53 + 1;
                float v129 = v28 - 1;
                int v130 = v4;
                if (v40)
                {
                  uint64_t v113 = v802;
                  while (1)
                  {
                    if (!v126) {
                      goto LABEL_105;
                    }
                    unsigned int v131 = ((unsigned __int16)(*v40 * v126 + ((*v40 * v126) >> 8) + 1) >> 8);
                    if (!v131) {
                      goto LABEL_105;
                    }
                    if (v131 == 255)
                    {
                      _H0 = *((short float *)v52 + 1);
                      if (_H0 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                      {
                        v127[1] = *v52;
                        goto LABEL_104;
                      }
                      __asm { FCMP            H0, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        __asm { FCVT            S0, H0 }
                        _H1 = *(short float *)v52;
                        __asm { FCVT            S1, H1 }
                        _H2 = v127[1];
                        __asm { FCVT            S2, H2 }
                        _S1 = _S1 + (float)(_S2 * (float)(1.0 - _S0));
                        __asm { FCVT            H1, S1 }
                        v127[1] = LOWORD(_S1);
                        *(short float *)&_S1 = v129[1];
                        __asm { FCVT            S1, H1 }
                        _S0 = _S0 + (float)(_S1 * (float)(1.0 - _S0));
                        goto LABEL_102;
                      }
                    }
                    else
                    {
                      float v142 = (float)v131 * 0.0039216;
                      _H1 = v52[1];
                      __asm { FCVT            S1, H1 }
                      _S1 = v142 * _S1;
                      __asm
                      {
                        FCVT            H1, S1
                        FCMP            H1, #0
                      }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        _H2 = *(short float *)v52;
                        __asm
                        {
                          FCVT            S1, H1
                          FCVT            S2, H2
                        }
                        _S0 = v142 * _S2;
                        __asm
                        {
                          FCVT            H0, S0
                          FCVT            S0, H0
                        }
                        LOWORD(_S2) = v127[1];
                        __asm { FCVT            S2, H2 }
                        _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S1));
                        __asm { FCVT            H0, S0 }
                        v127[1] = LOWORD(_S0);
                        *(short float *)&_S0 = v129[1];
                        __asm { FCVT            S0, H0 }
                        _S0 = _S1 + (float)(_S0 * (float)(1.0 - _S1));
LABEL_102:
                        __asm { FCVT            H0, S0 }
LABEL_104:
                        v129[1] = _H0;
                      }
                    }
LABEL_105:
                    unsigned __int8 v155 = *v128++;
                    unsigned __int8 v126 = v155;
                    v52 += 2;
                    ++v40;
                    ++v127;
                    ++v129;
                    if (!--v130)
                    {
                      v40 += v798;
LABEL_573:
                      uint64_t v31 = &v127[v799 + 1];
                      int v28 = &v129[v800 + 1];
                      goto LABEL_515;
                    }
                  }
                }
                uint64_t v113 = v802;
                while (1)
                {
                  if (v126)
                  {
                    if (v126 == 255)
                    {
                      _H0 = *((short float *)v52 + 1);
                      if (_H0 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                      {
                        v127[1] = *v52;
                        goto LABEL_570;
                      }
                      __asm { FCMP            H0, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        __asm { FCVT            S0, H0 }
                        _H1 = *(short float *)v52;
                        __asm { FCVT            S1, H1 }
                        _H2 = v127[1];
                        __asm { FCVT            S2, H2 }
                        _S1 = _S1 + (float)(_S2 * (float)(1.0 - _S0));
                        __asm { FCVT            H1, S1 }
                        v127[1] = LOWORD(_S1);
                        *(short float *)&_S1 = v129[1];
                        __asm { FCVT            S1, H1 }
                        _S0 = _S0 + (float)(_S1 * (float)(1.0 - _S0));
                        goto LABEL_568;
                      }
                    }
                    else
                    {
                      float v738 = (float)v126 * 0.0039216;
                      _H1 = v52[1];
                      __asm { FCVT            S1, H1 }
                      _S1 = v738 * _S1;
                      __asm
                      {
                        FCVT            H1, S1
                        FCMP            H1, #0
                      }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        _H2 = *(short float *)v52;
                        __asm
                        {
                          FCVT            S1, H1
                          FCVT            S2, H2
                        }
                        _S0 = v738 * _S2;
                        __asm
                        {
                          FCVT            H0, S0
                          FCVT            S0, H0
                        }
                        LOWORD(_S2) = v127[1];
                        __asm { FCVT            S2, H2 }
                        _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S1));
                        __asm { FCVT            H0, S0 }
                        v127[1] = LOWORD(_S0);
                        *(short float *)&_S0 = v129[1];
                        __asm { FCVT            S0, H0 }
                        _S0 = _S1 + (float)(_S0 * (float)(1.0 - _S1));
LABEL_568:
                        __asm { FCVT            H0, S0 }
LABEL_570:
                        v129[1] = _H0;
                      }
                    }
                  }
                  unsigned __int8 v751 = *v128++;
                  unsigned __int8 v126 = v751;
                  v52 += 2;
                  ++v127;
                  ++v129;
                  if (!--v130)
                  {
                    unsigned int v40 = 0;
                    goto LABEL_573;
                  }
                }
              }
              if (v40)
              {
                uint64_t v678 = (short float *)(v31 - 1);
                float v688 = v53 + 1;
                int v689 = v4;
                uint64_t v113 = v802;
                while (1)
                {
                  if (!v126) {
                    goto LABEL_541;
                  }
                  unsigned int v690 = ((unsigned __int16)(*v40 * v126 + ((*v40 * v126) >> 8) + 1) >> 8);
                  if (!v690) {
                    goto LABEL_541;
                  }
                  if (v690 == 255)
                  {
                    if (*((short float *)v52 + 1) >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                    {
                      _H0 = *(short float *)v52;
                      goto LABEL_540;
                    }
                    __asm { FCMP            H0, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S0, H0 }
                      _H1 = *(short float *)v52;
                      __asm { FCVT            S1, H1 }
                      _H2 = *((_WORD *)v678 + 1);
                      __asm { FCVT            S2, H2 }
                      _S0 = _S1 + (float)(_S2 * (float)(1.0 - _S0));
                      goto LABEL_538;
                    }
                  }
                  else
                  {
                    float v698 = (float)v690 * 0.0039216;
                    _H1 = v52[1];
                    __asm { FCVT            S1, H1 }
                    _S1 = v698 * _S1;
                    __asm
                    {
                      FCVT            H1, S1
                      FCMP            H1, #0
                    }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      _H2 = *(short float *)v52;
                      __asm
                      {
                        FCVT            S1, H1
                        FCVT            S2, H2
                      }
                      _S0 = v698 * _S2;
                      __asm
                      {
                        FCVT            H0, S0
                        FCVT            S0, H0
                      }
                      *(short float *)&_S2 = v678[1];
                      __asm { FCVT            S2, H2 }
                      _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S1));
LABEL_538:
                      __asm { FCVT            H0, S0 }
LABEL_540:
                      v678[1] = _H0;
                    }
                  }
LABEL_541:
                  unsigned __int8 v710 = *v688++;
                  unsigned __int8 v126 = v710;
                  v52 += 2;
                  ++v40;
                  ++v678;
                  if (!--v689)
                  {
LABEL_542:
                    v40 += v798;
                    goto LABEL_595;
                  }
                }
              }
              int v759 = v53 + 1;
              uint64_t v678 = (short float *)(v31 - 1);
              int v760 = v4;
              uint64_t v113 = v802;
              do
              {
                if (!v126) {
                  goto LABEL_593;
                }
                if (v126 == 255)
                {
                  if (*((short float *)v52 + 1) >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                  {
                    _H0 = *(short float *)v52;
                    goto LABEL_592;
                  }
                  __asm { FCMP            H0, #0 }
                  if (_NF ^ _VF | _ZF) {
                    goto LABEL_593;
                  }
                  __asm { FCVT            S0, H0 }
                  _H1 = *(short float *)v52;
                  __asm { FCVT            S1, H1 }
                  _H2 = *((_WORD *)v678 + 1);
                  __asm { FCVT            S2, H2 }
                  _S0 = _S1 + (float)(_S2 * (float)(1.0 - _S0));
                }
                else
                {
                  float v768 = (float)v126 * 0.0039216;
                  _H1 = v52[1];
                  __asm { FCVT            S1, H1 }
                  _S1 = v768 * _S1;
                  __asm
                  {
                    FCVT            H1, S1
                    FCMP            H1, #0
                  }
                  if (_NF ^ _VF | _ZF) {
                    goto LABEL_593;
                  }
                  _H2 = *(short float *)v52;
                  __asm
                  {
                    FCVT            S1, H1
                    FCVT            S2, H2
                  }
                  _S0 = v768 * _S2;
                  __asm
                  {
                    FCVT            H0, S0
                    FCVT            S0, H0
                  }
                  *(short float *)&_S2 = v678[1];
                  __asm { FCVT            S2, H2 }
                  _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S1));
                }
                __asm { FCVT            H0, S0 }
LABEL_592:
                v678[1] = _H0;
LABEL_593:
                unsigned __int8 v780 = *v759++;
                unsigned __int8 v126 = v780;
                v52 += 2;
                ++v678;
                --v760;
              }
              while (v760);
LABEL_594:
              unsigned int v40 = 0;
LABEL_595:
              uint64_t v31 = (unsigned __int16 *)&v678[v799 + 1];
              v28 += v800;
LABEL_515:
              if (!--v46) {
                goto LABEL_606;
              }
              uint64_t v48 = 0;
              LODWORD(v804) = v804 + 1;
              v36 += v26[16];
              uint64_t v37 = v26[17] + v113;
              if (v803)
              {
                uint64_t v796 = v36;
                uint64_t v45 = v793;
                int v43 = v804;
                goto LABEL_596;
              }
              continue;
            case 3:
              uint64_t v156 = (short float *)(v52 + 1);
              int v157 = v4;
              unsigned int v94 = v40;
              do
              {
                unsigned int v158 = *v53;
                if (*v53)
                {
                  if (v40) {
                    unsigned int v158 = (*v94 * v158 + ((*v94 * v158) >> 8) + 1) >> 8;
                  }
                  if ((_BYTE)v158)
                  {
                    if (v158 == 255)
                    {
                      *(short float *)uint64_t v31 = *(v156 - 1) * *v28;
                      _H0 = *v156 * *v28;
                    }
                    else
                    {
                      float v160 = (float)v158 * 0.0039216;
                      _H1 = *(_WORD *)v28;
                      __asm { FCVT            S1, H1 }
                      _H2 = *((_WORD *)v156 - 1);
                      __asm { FCVT            S2, H2 }
                      float v165 = v160 * _S1;
                      _H4 = *v31;
                      __asm { FCVT            S4, H4 }
                      float v168 = 1.0 - v160;
                      _S2 = (float)(v168 * _S4) + (float)(_S2 * v165);
                      __asm { FCVT            H2, S2 }
                      *uint64_t v31 = LOWORD(_S2);
                      *(short float *)&_S2 = *v156;
                      __asm { FCVT            S2, H2 }
                      _S0 = (float)(v168 * _S1) + (float)(_S2 * v165);
                      __asm { FCVT            H0, S0 }
                    }
                    *int v28 = _H0;
                  }
                }
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v156 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                --v157;
              }
              while (v157);
              goto LABEL_512;
            case 4:
              uint64_t v172 = v52 + 1;
              int v173 = v4;
              unsigned int v94 = v40;
              do
              {
                unsigned int v174 = *v53;
                if (*v53)
                {
                  if (v40) {
                    unsigned int v174 = (*v94 * v174 + ((*v94 * v174) >> 8) + 1) >> 8;
                  }
                  if ((_BYTE)v174)
                  {
                    if (v174 == 255)
                    {
                      _H0 = *(v172 - 1);
                      __asm { FCVT            S0, H0 }
                      _H1 = *(_WORD *)v28;
                      __asm { FCVT            S1, H1 }
                      _S0 = (float)(1.0 - _S1) * _S0;
                      __asm { FCVT            H0, S0 }
                      *uint64_t v31 = LOWORD(_S0);
                      LOWORD(_S0) = *v172;
                      __asm { FCVT            S0, H0 }
                      *(short float *)&_S1 = *v28;
                      __asm { FCVT            S1, H1 }
                      _S0 = (float)(1.0 - _S1) * _S0;
                    }
                    else
                    {
                      float v183 = (float)v174 * 0.0039216;
                      _H1 = *(_WORD *)v28;
                      __asm { FCVT            S1, H1 }
                      _H2 = *(v172 - 1);
                      __asm { FCVT            S2, H2 }
                      float v188 = v183 * (float)(1.0 - _S1);
                      _H5 = *v31;
                      __asm { FCVT            S5, H5 }
                      float v191 = 1.0 - v183;
                      _S2 = (float)(v191 * _S5) + (float)(_S2 * v188);
                      __asm { FCVT            H2, S2 }
                      *uint64_t v31 = LOWORD(_S2);
                      LOWORD(_S2) = *v172;
                      __asm { FCVT            S2, H2 }
                      _S0 = (float)(v191 * _S1) + (float)(_S2 * v188);
                    }
                    __asm { FCVT            H0, S0 }
                    *(_WORD *)int v28 = _H0;
                  }
                }
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v172 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                --v173;
              }
              while (v173);
              goto LABEL_512;
            case 5:
              float32x4_t v195 = v52 + 1;
              int v196 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v197 = *v53;
                if (*v53)
                {
                  if (!v40) {
                    goto LABEL_134;
                  }
                  unsigned int v198 = *v94 * v197 + ((*v94 * v197) >> 8) + 1;
                  if (BYTE1(v198)) {
                    break;
                  }
                }
LABEL_135:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v195 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v196) {
                  goto LABEL_512;
                }
              }
              unsigned int v197 = v198 >> 8;
LABEL_134:
              _H0 = *(_WORD *)v28;
              __asm { FCVT            S0, H0 }
              _H1 = *(v195 - 1);
              __asm { FCVT            S1, H1 }
              float v203 = (float)v197 * 0.0039216;
              _S1 = v203 * _S1;
              __asm { FCVT            H1, S1 }
              _H3 = *v195;
              __asm { FCVT            S3, H3 }
              _S2 = v203 * _S3;
              __asm
              {
                FCVT            H2, S2
                FCVT            S2, H2
                FCVT            S1, H1
              }
              LOWORD(_S3) = *v31;
              __asm { FCVT            S3, H3 }
              _S1 = (float)((float)(1.0 - _S2) * _S3) + (float)(_S1 * _S0);
              __asm { FCVT            H1, S1 }
              *uint64_t v31 = LOWORD(_S1);
              _S0 = (float)((float)(1.0 - _S2) * _S0) + (float)(_S2 * _S0);
              __asm { FCVT            H0, S0 }
              *int v28 = *(short float *)&_S0;
              goto LABEL_135;
            case 6:
              uint64_t v213 = v52 + 1;
              int v214 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v215 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v216 = *v94 * v215 + ((*v94 * v215) >> 8) + 1;
                    if (!BYTE1(v216)) {
                      goto LABEL_147;
                    }
                    unsigned int v215 = v216 >> 8;
                  }
                  _H0 = *(_WORD *)v28;
                  __asm { FCVT            S0, H0 }
                  float v219 = 1.0 - _S0;
                  if ((float)(1.0 - _S0) >= 1.0)
                  {
                    _H0 = *(v213 - 1);
                    __asm { FCVT            S0, H0 }
                    float v230 = (float)v215 * 0.0039216;
                    _S0 = v230 * _S0;
                    __asm { FCVT            H0, S0 }
                    *uint64_t v31 = LOWORD(_S0);
                    LOWORD(_S0) = *v213;
                    __asm { FCVT            S0, H0 }
                    _S0 = v230 * _S0;
                    goto LABEL_146;
                  }
                  if (v219 > 0.0)
                  {
                    _H2 = *v31;
                    __asm { FCVT            S2, H2 }
                    _H3 = *(v213 - 1);
                    __asm { FCVT            S3, H3 }
                    float v224 = (float)((float)v215 * 0.0039216) * v219;
                    _S2 = _S2 + (float)(_S3 * v224);
                    __asm { FCVT            H2, S2 }
                    *uint64_t v31 = LOWORD(_S2);
                    LOWORD(_S2) = *v213;
                    __asm { FCVT            S2, H2 }
                    _S0 = _S0 + (float)(_S2 * v224);
LABEL_146:
                    __asm { FCVT            H0, S0 }
                    *(_WORD *)int v28 = _H0;
                  }
                }
LABEL_147:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v213 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v214) {
                  goto LABEL_512;
                }
              }
            case 7:
              uint64_t v234 = v40 != 0;
              uint64_t v235 = (short float *)(v52 + 1);
              int v236 = v4;
              unsigned int v94 = v40;
              if (v57)
              {
                do
                {
                  unsigned int v237 = *v53;
                  if (*v53)
                  {
                    if (v40) {
                      unsigned int v237 = (*v94 * v237 + ((*v94 * v237) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v237)
                    {
                      if (v237 == 255)
                      {
                        short float v238 = *v235;
                        *(short float *)uint64_t v31 = *(short float *)v31 * *v235;
                        _H0 = v238 * *v28;
                      }
                      else
                      {
                        float v240 = (float)v237 * 0.0039216;
                        _H1 = *(_WORD *)v28;
                        __asm { FCVT            S1, H1 }
                        _H2 = *v31;
                        __asm { FCVT            S2, H2 }
                        _H3 = *v235;
                        __asm { FCVT            S3, H3 }
                        float v247 = v240 * _S3;
                        float v248 = 1.0 - v240;
                        _S2 = (float)(v248 * _S2) + (float)(_S2 * v247);
                        __asm { FCVT            H2, S2 }
                        *uint64_t v31 = LOWORD(_S2);
                        _S0 = (float)(v248 * _S1) + (float)(_S1 * v247);
                        __asm { FCVT            H0, S0 }
                      }
                      *int v28 = _H0;
                    }
                  }
                  ++v53;
                  v94 += v234;
                  ++v31;
                  ++v28;
                  v235 += 2;
                  --v236;
                }
                while (v236);
              }
              else
              {
                do
                {
                  unsigned int v251 = *v53;
                  if (*v53)
                  {
                    if (v40) {
                      unsigned int v251 = (*v94 * v251 + ((*v94 * v251) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v251)
                    {
                      if (v251 == 255)
                      {
                        _H0 = *(short float *)v31 * *v235;
                      }
                      else
                      {
                        _H1 = *v31;
                        __asm { FCVT            S1, H1 }
                        _H2 = *v235;
                        __asm { FCVT            S2, H2 }
                        _S0 = (float)((float)(1.0 - (float)((float)v251 * 0.0039216)) * _S1)
                            + (float)(_S1 * (float)((float)((float)v251 * 0.0039216) * _S2));
                        __asm { FCVT            H0, S0 }
                      }
                      *(short float *)uint64_t v31 = _H0;
                    }
                  }
                  ++v53;
                  v94 += v234;
                  ++v31;
                  v235 += 2;
                  --v236;
                }
                while (v236);
              }
              goto LABEL_512;
            case 8:
              uint64_t v258 = v40 != 0;
              int8x16_t v259 = v52 + 1;
              int v260 = v4;
              unsigned int v94 = v40;
              if (v57)
              {
                do
                {
                  unsigned int v261 = *v53;
                  if (*v53)
                  {
                    if (v40) {
                      unsigned int v261 = (*v94 * v261 + ((*v94 * v261) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v261)
                    {
                      if (v261 == 255)
                      {
                        _H0 = *v31;
                        __asm { FCVT            S0, H0 }
                        _H1 = *v259;
                        __asm { FCVT            S1, H1 }
                        float v266 = 1.0 - _S1;
                        _S0 = v266 * _S0;
                        __asm { FCVT            H0, S0 }
                        *uint64_t v31 = LOWORD(_S0);
                        *(short float *)&_S0 = *v28;
                        __asm { FCVT            S0, H0 }
                        _S0 = v266 * _S0;
                      }
                      else
                      {
                        float v270 = (float)v261 * 0.0039216;
                        _H1 = *(_WORD *)v28;
                        __asm { FCVT            S1, H1 }
                        _H2 = *v31;
                        __asm { FCVT            S2, H2 }
                        _H3 = *v259;
                        __asm { FCVT            S3, H3 }
                        float v277 = v270 * (float)(1.0 - _S3);
                        float v278 = 1.0 - v270;
                        _S2 = (float)(v278 * _S2) + (float)(_S2 * v277);
                        __asm { FCVT            H2, S2 }
                        *uint64_t v31 = LOWORD(_S2);
                        _S0 = (float)(v278 * _S1) + (float)(_S1 * v277);
                      }
                      __asm { FCVT            H0, S0 }
                      *(_WORD *)int v28 = _H0;
                    }
                  }
                  ++v53;
                  v94 += v258;
                  ++v31;
                  ++v28;
                  v259 += 2;
                  --v260;
                }
                while (v260);
              }
              else
              {
                do
                {
                  unsigned int v281 = *v53;
                  if (*v53)
                  {
                    if (v40) {
                      unsigned int v281 = (*v94 * v281 + ((*v94 * v281) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v281)
                    {
                      if (v281 == 255)
                      {
                        _H0 = *v31;
                        __asm { FCVT            S0, H0 }
                        _H1 = *v259;
                        __asm { FCVT            S1, H1 }
                        _S0 = (float)(1.0 - _S1) * _S0;
                      }
                      else
                      {
                        _H1 = *v31;
                        __asm { FCVT            S1, H1 }
                        _H2 = *v259;
                        __asm { FCVT            S2, H2 }
                        _S0 = (float)((float)(1.0 - (float)((float)v281 * 0.0039216)) * _S1)
                            + (float)(_S1
                                    * (float)((float)((float)v281 * 0.0039216) * (float)(1.0 - _S2)));
                      }
                      __asm { FCVT            H0, S0 }
                      *uint64_t v31 = _H0;
                    }
                  }
                  ++v53;
                  v94 += v258;
                  ++v31;
                  v259 += 2;
                  --v260;
                }
                while (v260);
              }
              goto LABEL_512;
            case 9:
              uint64_t v292 = v52 + 1;
              int v293 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v294 = *v53;
                if (*v53)
                {
                  if (!v40) {
                    goto LABEL_196;
                  }
                  unsigned int v295 = *v94 * v294 + ((*v94 * v294) >> 8) + 1;
                  if (BYTE1(v295)) {
                    break;
                  }
                }
LABEL_197:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v292 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v293) {
                  goto LABEL_512;
                }
              }
              unsigned int v294 = v295 >> 8;
LABEL_196:
              _H0 = *(_WORD *)v28;
              __asm { FCVT            S0, H0 }
              float v298 = (float)v294 * 0.0039216;
              _H2 = *(v292 - 1);
              __asm { FCVT            S2, H2 }
              _S2 = v298 * _S2;
              __asm { FCVT            H2, S2 }
              _H3 = *v292;
              __asm { FCVT            S3, H3 }
              _S3 = v298 * _S3;
              __asm
              {
                FCVT            H3, S3
                FCVT            S3, H3
                FCVT            S2, H2
              }
              _H6 = *v31;
              __asm { FCVT            S6, H6 }
              float v309 = (float)(1.0 - v298) + _S3;
              _S2 = (float)(v309 * _S6) + (float)(_S2 * (float)(1.0 - _S0));
              __asm { FCVT            H2, S2 }
              *uint64_t v31 = LOWORD(_S2);
              _S0 = (float)(v309 * _S0) + (float)(_S3 * (float)(1.0 - _S0));
              __asm { FCVT            H0, S0 }
              *int v28 = *(short float *)&_S0;
              goto LABEL_197;
            case 10:
              uint64_t v312 = v52 + 1;
              int v313 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v314 = *v53;
                if (*v53)
                {
                  if (!v40) {
                    goto LABEL_204;
                  }
                  unsigned int v315 = *v94 * v314 + ((*v94 * v314) >> 8) + 1;
                  if (BYTE1(v315)) {
                    break;
                  }
                }
LABEL_205:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v312 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v313) {
                  goto LABEL_512;
                }
              }
              unsigned int v314 = v315 >> 8;
LABEL_204:
              _H0 = *(_WORD *)v28;
              __asm { FCVT            S0, H0 }
              _H1 = *(v312 - 1);
              __asm { FCVT            S1, H1 }
              float v320 = (float)v314 * 0.0039216;
              _S1 = v320 * _S1;
              __asm { FCVT            H1, S1 }
              _H3 = *v312;
              __asm { FCVT            S3, H3 }
              _S2 = v320 * _S3;
              __asm
              {
                FCVT            H2, S2
                FCVT            S2, H2
                FCVT            S1, H1
              }
              _H5 = *v31;
              __asm { FCVT            S5, H5 }
              _S1 = (float)((float)(1.0 - _S2) * _S5) + (float)(_S1 * (float)(1.0 - _S0));
              __asm { FCVT            H1, S1 }
              *uint64_t v31 = LOWORD(_S1);
              _S0 = (float)((float)(1.0 - _S2) * _S0) + (float)(_S2 * (float)(1.0 - _S0));
              __asm { FCVT            H0, S0 }
              *int v28 = *(short float *)&_S0;
              goto LABEL_205;
            case 11:
              uint64_t v331 = v40 != 0;
              int v332 = v4;
              int v333 = v40;
              if (v57)
              {
                while (1)
                {
                  unsigned int v334 = *v53;
                  if (*v53)
                  {
                    if (!v40) {
                      goto LABEL_212;
                    }
                    unsigned int v335 = *v333 * v334 + ((*v333 * v334) >> 8) + 1;
                    if (BYTE1(v335)) {
                      break;
                    }
                  }
LABEL_215:
                  ++v53;
                  v52 += 2;
                  v333 += v331;
                  ++v31;
                  ++v28;
                  if (!--v332) {
                    goto LABEL_550;
                  }
                }
                unsigned int v334 = v335 >> 8;
LABEL_212:
                _H1 = *(_WORD *)v28;
                __asm { FCVT            S1, H1 }
                _H2 = *v31;
                __asm { FCVT            S2, H2 }
                float v340 = _S1 - _S2;
                v51.i32[0] = *(_DWORD *)v52;
                float16x4_t v51 = (float16x4_t)vcvtq_f32_f16(v51).u64[0];
                _Q0.n128_u64[0] = (unint64_t)vmul_n_f32((float32x2_t)v51, (float)v334 * 0.0039216);
                _Q0 = (__n128)vcvtq_f32_f16(vcvt_f16_f32((float32x4_t)_Q0));
                _S1 = _Q0.n128_f32[1] + _S1;
                _Q0.n128_f32[0] = v340 + (float)(_Q0.n128_f32[1] - _Q0.n128_f32[0]);
                if (_S1 > 1.0) {
                  _S1 = 1.0;
                }
                __asm { FCVT            H2, S1 }
                *(_WORD *)int v28 = _H2;
                _S0 = _S1 - _Q0.n128_f32[0];
                __asm { FCVT            H0, S0 }
                *uint64_t v31 = LOWORD(_S0);
                goto LABEL_215;
              }
              while (1)
              {
                unsigned int v344 = *v53;
                if (*v53)
                {
                  if (!v40) {
                    goto LABEL_221;
                  }
                  unsigned int v345 = *v333 * v344 + ((*v333 * v344) >> 8) + 1;
                  if (BYTE1(v345)) {
                    break;
                  }
                }
LABEL_222:
                ++v53;
                v52 += 2;
                v333 += v331;
                ++v31;
                if (!--v332) {
                  goto LABEL_550;
                }
              }
              unsigned int v344 = v345 >> 8;
LABEL_221:
              _H1 = *v31;
              __asm { FCVT            S1, H1 }
              v51.i32[0] = *(_DWORD *)v52;
              _Q0.n128_u64[0] = (unint64_t)vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16(v51), (float)v344 * 0.0039216);
              _Q0 = (__n128)vcvtq_f32_f16(vcvt_f16_f32((float32x4_t)_Q0));
              float16x4_t v51 = (float16x4_t)vdup_lane_s32((int32x2_t)_Q0.n128_u64[0], 1);
              _Q0.n128_f32[0] = 1.0
                              - (float)((float)(1.0 - _S1)
                                      + vsub_f32((float32x2_t)v51, (float32x2_t)_Q0.n128_u64[0]).f32[0]);
              __asm { FCVT            H0, S0 }
              *uint64_t v31 = _Q0.n128_u16[0];
              goto LABEL_222;
            case 12:
              uint64_t v348 = v40 != 0;
              if (v57)
              {
                float v349 = v52 + 1;
                int v350 = v4;
                unsigned int v94 = v40;
                while (1)
                {
                  unsigned int v351 = *v53;
                  if (*v53)
                  {
                    if (!v40) {
                      goto LABEL_230;
                    }
                    unsigned int v352 = *v94 * v351 + ((*v94 * v351) >> 8) + 1;
                    if (BYTE1(v352)) {
                      break;
                    }
                  }
LABEL_233:
                  ++v53;
                  v94 += v348;
                  ++v31;
                  ++v28;
                  v349 += 2;
                  if (!--v350) {
                    goto LABEL_512;
                  }
                }
                unsigned int v351 = v352 >> 8;
LABEL_230:
                _H0 = *(v349 - 1);
                __asm { FCVT            S0, H0 }
                float v355 = (float)v351 * 0.0039216;
                _S0 = v355 * _S0;
                __asm { FCVT            H0, S0 }
                _H2 = *v349;
                __asm { FCVT            S2, H2 }
                _S1 = v355 * _S2;
                __asm { FCVT            H1, S1 }
                *(short float *)&_S2 = *v28;
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S1, H1
                }
                _S1 = _S2 + _S1;
                if (_S1 > 1.0) {
                  _S1 = 1.0;
                }
                *(short float *)uint64_t v31 = *(short float *)v31 + _H0;
                __asm { FCVT            H0, S1 }
                *(_WORD *)int v28 = _H0;
                goto LABEL_233;
              }
              int v711 = v4;
              int v333 = v40;
              while (1)
              {
                unsigned int v712 = *v53;
                if (*v53)
                {
                  if (!v40) {
                    goto LABEL_548;
                  }
                  unsigned int v713 = *v333 * v712 + ((*v333 * v712) >> 8) + 1;
                  if (BYTE1(v713)) {
                    break;
                  }
                }
LABEL_549:
                ++v53;
                v52 += 2;
                v333 += v348;
                ++v31;
                if (!--v711)
                {
LABEL_550:
                  unsigned int v40 = &v333[v798];
LABEL_513:
                  v31 += v799;
                  v28 += v800;
LABEL_514:
                  uint64_t v113 = v802;
                  goto LABEL_515;
                }
              }
              unsigned int v712 = v713 >> 8;
LABEL_548:
              _H0 = *(short float *)v52;
              __asm { FCVT            S0, H0 }
              _S0 = (float)((float)v712 * 0.0039216) * _S0;
              __asm { FCVT            H0, S0 }
              *(short float *)uint64_t v31 = *(short float *)v31 + *(short float *)&_S0;
              goto LABEL_549;
            case 13:
              unsigned int v365 = v52 + 1;
              int v366 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v367 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v368 = *v94 * v367 + ((*v94 * v367) >> 8) + 1;
                    if (!BYTE1(v368)) {
                      goto LABEL_253;
                    }
                    unsigned int v367 = v368 >> 8;
                  }
                  float v369 = (float)v367 * 0.0039216;
                  _H0 = *v365;
                  __asm { FCVT            S0, H0 }
                  _S0 = v369 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v365 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v369 * _S2;
                    __asm { FCVT            H1, S1 }
                    _S3 = 1.0;
                    if (!v57) {
                      goto LABEL_244;
                    }
                    __asm { FCMP            H3, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S3, H3 }
LABEL_244:
                      __asm { FCVT            S4, H0 }
                      _H5 = *v31;
                      __asm
                      {
                        FCVT            S5, H5
                        FCVT            S1, H1
                      }
                      float v384 = _S1 * _S5;
                      float v385 = (float)(_S1 * _S5) + (float)(_S5 * (float)(1.0 - _S4));
                      if (_H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                        _S0 = v384;
                      }
                      else {
                        _S0 = v385;
                      }
                      float v387 = _S0 + (float)(_S1 * (float)(1.0 - _S3));
                      if (_S3 != 1.0) {
                        _S0 = v387;
                      }
                      __asm { FCVT            H1, S0 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_253;
                      }
                      _S0 = (float)(_S3 + _S4) - (float)(_S3 * _S4);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *int v28 = _H0;
                  }
                }
LABEL_253:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v365 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v366) {
                  goto LABEL_512;
                }
              }
            case 14:
              uint64_t v389 = v52 + 1;
              int v390 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v391 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v392 = *v94 * v391 + ((*v94 * v391) >> 8) + 1;
                    if (!BYTE1(v392)) {
                      goto LABEL_268;
                    }
                    unsigned int v391 = v392 >> 8;
                  }
                  float v393 = (float)v391 * 0.0039216;
                  _H0 = *v389;
                  __asm { FCVT            S0, H0 }
                  _S0 = v393 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v389 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v393 * _S2;
                    __asm { FCVT            H1, S1 }
                    _S2 = 1.0;
                    if (!v57) {
                      goto LABEL_264;
                    }
                    __asm { FCMP            H2, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S2, H2 }
LABEL_264:
                      _H4 = *v31;
                      __asm
                      {
                        FCVT            S4, H4
                        FCVT            S1, H1
                      }
                      _S1 = _S4 + (float)(_S1 * (float)(1.0 - _S4));
                      __asm { FCVT            H1, S1 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_268;
                      }
                      __asm { FCVT            S0, H0 }
                      _S0 = (float)(_S2 + _S0) - (float)(_S2 * _S0);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *(_WORD *)int v28 = _H0;
                  }
                }
LABEL_268:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v389 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v390) {
                  goto LABEL_512;
                }
              }
            case 15:
              uint64_t v796 = v36;
              int v795 = v46;
              uint64_t v410 = v52 + 1;
              int v411 = v4;
              uint64_t v412 = v40;
              while (1)
              {
                unsigned int v413 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v414 = *v412 * v413 + ((*v412 * v413) >> 8) + 1;
                    if (!BYTE1(v414)) {
                      goto LABEL_284;
                    }
                    unsigned int v413 = v414 >> 8;
                  }
                  float v415 = (float)v413 * *((float *)v91 + 677);
                  _H1 = *v410;
                  __asm { FCVT            S1, H1 }
                  _S1 = v415 * _S1;
                  __asm
                  {
                    FCVT            H1, S1
                    FCMP            H1, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v410 - 1);
                    __asm { FCVT            S2, H2 }
                    _Q0.n128_f32[0] = v415 * _Q2.n128_f32[0];
                    __asm { FCVT            H2, S0 }
                    if (v57)
                    {
                      __asm { FCMP            H0, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        uint64_t v422 = v91;
                        __asm { FCVT            S4, H0 }
                        goto LABEL_280;
                      }
                    }
                    else
                    {
                      uint64_t v422 = v91;
                      _S4 = 1.0;
LABEL_280:
                      __asm { FCVT            S3, H1 }
                      _Q0.n128_u16[0] = *v31;
                      _Q0.n128_u16[0] = PDAoverlayPDA(_Q0, _S4, _Q2, _S3);
                      _Q2.n128_u16[0] = _Q0.n128_u16[0];
                      int v57 = v801;
                      if (!v801)
                      {
                        *uint64_t v31 = _Q0.n128_u16[0];
                        uint64_t v91 = v422;
                        uint64_t v4 = v797;
                        goto LABEL_284;
                      }
                      uint64_t v91 = v422;
                      uint64_t v4 = v797;
                    }
                    *uint64_t v31 = _Q2.n128_u16[0];
                    *(_WORD *)int v28 = _H1;
                  }
                }
LABEL_284:
                ++v53;
                v412 += v40 != 0;
                ++v31;
                v410 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v411) {
                  goto LABEL_393;
                }
              }
            case 16:
              double v425 = v52 + 1;
              int v426 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v427 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v428 = *v94 * v427 + ((*v94 * v427) >> 8) + 1;
                    if (!BYTE1(v428)) {
                      goto LABEL_306;
                    }
                    unsigned int v427 = v428 >> 8;
                  }
                  float v429 = (float)v427 * 0.0039216;
                  _H0 = *v425;
                  __asm { FCVT            S0, H0 }
                  _S0 = v429 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v425 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v429 * _S2;
                    __asm { FCVT            H1, S1 }
                    _S3 = 1.0;
                    if (!v57) {
                      goto LABEL_295;
                    }
                    __asm { FCMP            H3, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S3, H3 }
LABEL_295:
                      __asm { FCVT            S4, H0 }
                      _H5 = *v31;
                      __asm
                      {
                        FCVT            S5, H5
                        FCVT            S1, H1
                      }
                      float v444 = _S4 * _S5;
                      if ((float)(_S3 * _S1) < (float)(_S4 * _S5)) {
                        float v444 = _S3 * _S1;
                      }
                      float v445 = v444 + (float)(_S5 * (float)(1.0 - _S4));
                      if (_H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                        _S0 = v444;
                      }
                      else {
                        _S0 = v445;
                      }
                      float v447 = _S0 + (float)(_S1 * (float)(1.0 - _S3));
                      if (_S3 != 1.0) {
                        _S0 = v447;
                      }
                      __asm { FCVT            H1, S0 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_306;
                      }
                      _S0 = (float)(_S3 + _S4) - (float)(_S3 * _S4);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *int v28 = _H0;
                  }
                }
LABEL_306:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v425 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v426) {
                  goto LABEL_512;
                }
              }
            case 17:
              uint64_t v449 = v52 + 1;
              int v450 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v451 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v452 = *v94 * v451 + ((*v94 * v451) >> 8) + 1;
                    if (!BYTE1(v452)) {
                      goto LABEL_328;
                    }
                    unsigned int v451 = v452 >> 8;
                  }
                  float v453 = (float)v451 * 0.0039216;
                  _H0 = *v449;
                  __asm { FCVT            S0, H0 }
                  _S0 = v453 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v449 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v453 * _S2;
                    __asm { FCVT            H1, S1 }
                    _S3 = 1.0;
                    if (!v57) {
                      goto LABEL_317;
                    }
                    __asm { FCMP            H3, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S3, H3 }
LABEL_317:
                      __asm { FCVT            S4, H0 }
                      _H5 = *v31;
                      __asm
                      {
                        FCVT            S5, H5
                        FCVT            S1, H1
                      }
                      float v468 = _S4 * _S5;
                      if ((float)(_S3 * _S1) > (float)(_S4 * _S5)) {
                        float v468 = _S3 * _S1;
                      }
                      float v469 = v468 + (float)(_S5 * (float)(1.0 - _S4));
                      if (_H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                        _S0 = v468;
                      }
                      else {
                        _S0 = v469;
                      }
                      float v471 = _S0 + (float)(_S1 * (float)(1.0 - _S3));
                      if (_S3 != 1.0) {
                        _S0 = v471;
                      }
                      __asm { FCVT            H1, S0 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_328;
                      }
                      _S0 = (float)(_S3 + _S4) - (float)(_S3 * _S4);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *int v28 = _H0;
                  }
                }
LABEL_328:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v449 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v450) {
                  goto LABEL_512;
                }
              }
            case 18:
              uint64_t v796 = v36;
              int v795 = v46;
              uint64_t v473 = v52 + 1;
              int v474 = v4;
              uint64_t v412 = v40;
              while (1)
              {
                unsigned int v475 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v476 = *v412 * v475 + ((*v412 * v475) >> 8) + 1;
                    if (!BYTE1(v476)) {
                      goto LABEL_344;
                    }
                    unsigned int v475 = v476 >> 8;
                  }
                  float v477 = (float)v475 * *((float *)v91 + 677);
                  _H1 = *v473;
                  __asm { FCVT            S1, H1 }
                  _S1 = v477 * _S1;
                  __asm
                  {
                    FCVT            H1, S1
                    FCMP            H1, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v473 - 1);
                    __asm { FCVT            S2, H2 }
                    _Q0.n128_f32[0] = v477 * _Q2.n128_f32[0];
                    __asm { FCVT            H2, S0 }
                    if (v57)
                    {
                      __asm { FCMP            H0, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        float v484 = v91;
                        __asm { FCVT            S4, H0 }
                        goto LABEL_340;
                      }
                    }
                    else
                    {
                      float v484 = v91;
                      _S4 = 1.0;
LABEL_340:
                      __asm { FCVT            S3, H1 }
                      _Q0.n128_u16[0] = *v31;
                      _Q0.n128_u16[0] = PDAcolordodgePDA(_Q0, _S4, _Q2, _S3);
                      _Q2.n128_u16[0] = _Q0.n128_u16[0];
                      int v57 = v801;
                      if (!v801)
                      {
                        *uint64_t v31 = _Q0.n128_u16[0];
                        uint64_t v91 = v484;
                        uint64_t v4 = v797;
                        goto LABEL_344;
                      }
                      uint64_t v91 = v484;
                      uint64_t v4 = v797;
                    }
                    *uint64_t v31 = _Q2.n128_u16[0];
                    *(_WORD *)int v28 = _H1;
                  }
                }
LABEL_344:
                ++v53;
                v412 += v40 != 0;
                ++v31;
                v473 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v474) {
                  goto LABEL_393;
                }
              }
            case 19:
              uint64_t v796 = v36;
              int v795 = v46;
              uint64_t v487 = v52 + 1;
              int v488 = v4;
              uint64_t v412 = v40;
              while (1)
              {
                unsigned int v489 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v490 = *v412 * v489 + ((*v412 * v489) >> 8) + 1;
                    if (!BYTE1(v490)) {
                      goto LABEL_360;
                    }
                    unsigned int v489 = v490 >> 8;
                  }
                  float v491 = (float)v489 * *((float *)v91 + 677);
                  _H1 = *v487;
                  __asm { FCVT            S1, H1 }
                  _S1 = v491 * _S1;
                  __asm
                  {
                    FCVT            H1, S1
                    FCMP            H1, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v487 - 1);
                    __asm { FCVT            S2, H2 }
                    _Q0.n128_f32[0] = v491 * _Q2.n128_f32[0];
                    __asm { FCVT            H2, S0 }
                    if (v57)
                    {
                      __asm { FCMP            H0, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        unint64_t v498 = v91;
                        __asm { FCVT            S4, H0 }
                        goto LABEL_356;
                      }
                    }
                    else
                    {
                      unint64_t v498 = v91;
                      _S4 = 1.0;
LABEL_356:
                      __asm { FCVT            S3, H1 }
                      _Q0.n128_u16[0] = *v31;
                      _Q0.n128_u16[0] = PDAcolorburnPDA(_Q0, _S4, _Q2, _S3);
                      _Q2.n128_u16[0] = _Q0.n128_u16[0];
                      int v57 = v801;
                      if (!v801)
                      {
                        *uint64_t v31 = _Q0.n128_u16[0];
                        uint64_t v91 = v498;
                        uint64_t v4 = v797;
                        goto LABEL_360;
                      }
                      uint64_t v91 = v498;
                      uint64_t v4 = v797;
                    }
                    *uint64_t v31 = _Q2.n128_u16[0];
                    *(_WORD *)int v28 = _H1;
                  }
                }
LABEL_360:
                ++v53;
                v412 += v40 != 0;
                ++v31;
                v487 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v488) {
                  goto LABEL_393;
                }
              }
            case 20:
              uint64_t v796 = v36;
              int v795 = v46;
              uint64_t v501 = v52 + 1;
              int v502 = v4;
              uint64_t v412 = v40;
              while (1)
              {
                unsigned int v503 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v504 = *v412 * v503 + ((*v412 * v503) >> 8) + 1;
                    if (!BYTE1(v504)) {
                      goto LABEL_376;
                    }
                    unsigned int v503 = v504 >> 8;
                  }
                  float v505 = (float)v503 * *((float *)v91 + 677);
                  _H1 = *v501;
                  __asm { FCVT            S1, H1 }
                  _S1 = v505 * _S1;
                  __asm
                  {
                    FCVT            H1, S1
                    FCMP            H1, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v501 - 1);
                    __asm { FCVT            S2, H2 }
                    _Q0.n128_f32[0] = v505 * _Q2.n128_f32[0];
                    __asm { FCVT            H2, S0 }
                    if (v57)
                    {
                      __asm { FCMP            H0, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        float v512 = v91;
                        __asm { FCVT            S4, H0 }
                        goto LABEL_372;
                      }
                    }
                    else
                    {
                      float v512 = v91;
                      _S4 = 1.0;
LABEL_372:
                      __asm { FCVT            S3, H1 }
                      _Q0.n128_u16[0] = *v31;
                      _Q0.n128_u16[0] = PDAsoftlightPDA(_Q0, _S4, _Q2, _S3);
                      _Q2.n128_u16[0] = _Q0.n128_u16[0];
                      int v57 = v801;
                      if (!v801)
                      {
                        *uint64_t v31 = _Q0.n128_u16[0];
                        uint64_t v91 = v512;
                        uint64_t v4 = v797;
                        goto LABEL_376;
                      }
                      uint64_t v91 = v512;
                      uint64_t v4 = v797;
                    }
                    *uint64_t v31 = _Q2.n128_u16[0];
                    *(_WORD *)int v28 = _H1;
                  }
                }
LABEL_376:
                ++v53;
                v412 += v40 != 0;
                ++v31;
                v501 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v502) {
                  goto LABEL_393;
                }
              }
            case 21:
              uint64_t v796 = v36;
              int v795 = v46;
              int v515 = v52 + 1;
              int v516 = v4;
              uint64_t v412 = v40;
              while (1)
              {
                unsigned int v517 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v518 = *v412 * v517 + ((*v412 * v517) >> 8) + 1;
                    if (!BYTE1(v518)) {
                      goto LABEL_392;
                    }
                    unsigned int v517 = v518 >> 8;
                  }
                  float v519 = (float)v517 * *((float *)v91 + 677);
                  _H1 = *v515;
                  __asm { FCVT            S1, H1 }
                  _S1 = v519 * _S1;
                  __asm
                  {
                    FCVT            H1, S1
                    FCMP            H1, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v515 - 1);
                    __asm { FCVT            S2, H2 }
                    _Q0.n128_f32[0] = v519 * _Q2.n128_f32[0];
                    __asm { FCVT            H2, S0 }
                    if (v57)
                    {
                      __asm { FCMP            H0, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        float v526 = v91;
                        __asm { FCVT            S4, H0 }
                        goto LABEL_388;
                      }
                    }
                    else
                    {
                      float v526 = v91;
                      _S4 = 1.0;
LABEL_388:
                      __asm { FCVT            S3, H1 }
                      _Q0.n128_u16[0] = *v31;
                      _Q0.n128_u16[0] = PDAhardlightPDA(_Q0, _S4, _Q2, _S3);
                      _Q2.n128_u16[0] = _Q0.n128_u16[0];
                      int v57 = v801;
                      if (!v801)
                      {
                        *uint64_t v31 = _Q0.n128_u16[0];
                        uint64_t v91 = v526;
                        uint64_t v4 = v797;
                        goto LABEL_392;
                      }
                      uint64_t v91 = v526;
                      uint64_t v4 = v797;
                    }
                    *uint64_t v31 = _Q2.n128_u16[0];
                    *(_WORD *)int v28 = _H1;
                  }
                }
LABEL_392:
                ++v53;
                v412 += v40 != 0;
                ++v31;
                v515 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v516)
                {
LABEL_393:
                  unsigned int v40 = &v412[v798];
                  v31 += v799;
                  v28 += v800;
                  int v35 = v794;
                  int v46 = v795;
                  int v26 = v792;
                  uint64_t v36 = v796;
                  goto LABEL_514;
                }
              }
            case 22:
              uint64_t v529 = v52 + 1;
              int v530 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v531 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v532 = *v94 * v531 + ((*v94 * v531) >> 8) + 1;
                    if (!BYTE1(v532)) {
                      goto LABEL_410;
                    }
                    unsigned int v531 = v532 >> 8;
                  }
                  float v533 = (float)v531 * 0.0039216;
                  _H1 = *v529;
                  __asm { FCVT            S1, H1 }
                  _S1 = v533 * _S1;
                  __asm
                  {
                    FCVT            H1, S1
                    FCMP            H1, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v529 - 1);
                    __asm { FCVT            S2, H2 }
                    _S0 = v533 * _S2;
                    __asm { FCVT            H0, S0 }
                    if (v57)
                    {
                      __asm { FCMP            H2, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        __asm { FCVT            S2, H2 }
                        goto LABEL_404;
                      }
                    }
                    else
                    {
                      _S2 = 1.0;
LABEL_404:
                      __asm { FCVT            S1, H1 }
                      _H3 = *v31;
                      __asm
                      {
                        FCVT            S3, H3
                        FCVT            S0, H0
                      }
                      float v548 = _S0 + _S3;
                      float v549 = _S1 * _S3;
                      float v550 = _S2 * _S0;
                      float v551 = v548 - v549;
                      float v552 = v549 - v550;
                      float v553 = v551 - v550;
                      if (v552 < 0.0) {
                        float v552 = -v552;
                      }
                      _S0 = v553 + v552;
                      __asm { FCVT            H0, S0 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H0;
                        goto LABEL_410;
                      }
                      _S1 = (float)(_S2 + _S1) - (float)(_S2 * _S1);
                      __asm { FCVT            H1, S1 }
                    }
                    *uint64_t v31 = _H0;
                    *(_WORD *)int v28 = _H1;
                  }
                }
LABEL_410:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v529 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v530) {
                  goto LABEL_512;
                }
              }
            case 23:
              float v556 = v52 + 1;
              int v557 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v558 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v559 = *v94 * v558 + ((*v94 * v558) >> 8) + 1;
                    if (!BYTE1(v559)) {
                      goto LABEL_426;
                    }
                    unsigned int v558 = v559 >> 8;
                  }
                  float v560 = (float)v558 * 0.0039216;
                  _H0 = *v556;
                  __asm { FCVT            S0, H0 }
                  _S0 = v560 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v556 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v560 * _S2;
                    __asm { FCVT            H1, S1 }
                    if (v57)
                    {
                      __asm { FCMP            H2, #0 }
                      if (!(_NF ^ _VF | _ZF))
                      {
                        __asm { FCVT            S2, H2 }
                        goto LABEL_422;
                      }
                    }
                    else
                    {
                      _S2 = 1.0;
LABEL_422:
                      _H3 = *v31;
                      __asm
                      {
                        FCVT            S3, H3
                        FCVT            S1, H1
                      }
                      _S1 = (float)(_S1 + _S3) + (float)((float)(_S1 * _S3) * -2.0);
                      __asm { FCVT            H1, S1 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_426;
                      }
                      __asm { FCVT            S0, H0 }
                      _S0 = (float)(_S2 + _S0) - (float)(_S2 * _S0);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *(_WORD *)int v28 = _H0;
                  }
                }
LABEL_426:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v556 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v557) {
                  goto LABEL_512;
                }
              }
            case 24:
              v577 = v52 + 1;
              int v578 = v4;
              unsigned int v94 = v40;
              while (1)
              {
                unsigned int v579 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v580 = *v94 * v579 + ((*v94 * v579) >> 8) + 1;
                    if (!BYTE1(v580)) {
                      goto LABEL_448;
                    }
                    unsigned int v579 = v580 >> 8;
                  }
                  float v581 = (float)v579 * 0.0039216;
                  _H0 = *v577;
                  __asm { FCVT            S0, H0 }
                  _S0 = v581 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v577 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v581 * _S2;
                    __asm { FCVT            H1, S1 }
                    _S2 = 1.0;
                    if (!v57) {
                      goto LABEL_437;
                    }
                    __asm { FCMP            H2, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S2, H2 }
LABEL_437:
                      __asm { FCVT            S4, H0 }
                      _H5 = *v31;
                      __asm
                      {
                        FCVT            S5, H5
                        FCVT            S1, H1
                      }
                      float v596 = _S5 - (float)(_S4 * _S5);
                      _ZF = _H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
                      if (_H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                        float v598 = _S5;
                      }
                      else {
                        float v598 = _S4 * _S5;
                      }
                      float v599 = 0.0;
                      if (!_ZF) {
                        float v599 = v596;
                      }
                      float v600 = (float)(v599 + _S1) - (float)(_S2 * _S1);
                      if (_S2 == 1.0) {
                        float v600 = v599;
                      }
                      _S0 = v598 + v600;
                      __asm { FCVT            H1, S0 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_448;
                      }
                      _S0 = (float)(_S2 + _S4) - (float)(_S2 * _S4);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *int v28 = _H0;
                  }
                }
LABEL_448:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v577 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v578) {
                  goto LABEL_512;
                }
              }
            case 25:
              v603 = v52 + 1;
              unsigned int v94 = v40;
              int v604 = v4;
              while (1)
              {
                unsigned int v605 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v606 = *v94 * v605 + ((*v94 * v605) >> 8) + 1;
                    if (!BYTE1(v606)) {
                      goto LABEL_470;
                    }
                    unsigned int v605 = v606 >> 8;
                  }
                  float v607 = (float)v605 * 0.0039216;
                  _H0 = *v603;
                  __asm { FCVT            S0, H0 }
                  _S0 = v607 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v603 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v607 * _S2;
                    __asm { FCVT            H1, S1 }
                    _S2 = 1.0;
                    if (!v57) {
                      goto LABEL_459;
                    }
                    __asm { FCMP            H2, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S2, H2 }
LABEL_459:
                      __asm { FCVT            S4, H0 }
                      _H5 = *v31;
                      __asm
                      {
                        FCVT            S5, H5
                        FCVT            S1, H1
                      }
                      float v622 = _S5 - (float)(_S4 * _S5);
                      BOOL v623 = _H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
                      if (_H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                        float v624 = _S5;
                      }
                      else {
                        float v624 = _S4 * _S5;
                      }
                      float v625 = 0.0;
                      if (!v623) {
                        float v625 = v622;
                      }
                      float v626 = (float)(v625 + _S1) - (float)(_S2 * _S1);
                      if (_S2 == 1.0) {
                        float v626 = v625;
                      }
                      _S0 = v624 + v626;
                      __asm { FCVT            H1, S0 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_470;
                      }
                      _S0 = (float)(_S2 + _S4) - (float)(_S2 * _S4);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *int v28 = _H0;
                  }
                }
LABEL_470:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v603 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v604) {
                  goto LABEL_512;
                }
              }
            case 26:
              int v629 = v52 + 1;
              unsigned int v94 = v40;
              int v630 = v4;
              while (1)
              {
                unsigned int v631 = *v53;
                if (*v53)
                {
                  if (v40)
                  {
                    unsigned int v632 = *v94 * v631 + ((*v94 * v631) >> 8) + 1;
                    if (!BYTE1(v632)) {
                      goto LABEL_492;
                    }
                    unsigned int v631 = v632 >> 8;
                  }
                  float v633 = (float)v631 * 0.0039216;
                  _H0 = *v629;
                  __asm { FCVT            S0, H0 }
                  _S0 = v633 * _S0;
                  __asm
                  {
                    FCVT            H0, S0
                    FCMP            H0, #0
                  }
                  if (!(_NF ^ _VF | _ZF))
                  {
                    _H2 = *(v629 - 1);
                    __asm { FCVT            S2, H2 }
                    _S1 = v633 * _S2;
                    __asm { FCVT            H1, S1 }
                    _S2 = 1.0;
                    if (!v57) {
                      goto LABEL_481;
                    }
                    __asm { FCMP            H2, #0 }
                    if (!(_NF ^ _VF | _ZF))
                    {
                      __asm { FCVT            S2, H2 }
LABEL_481:
                      __asm { FCVT            S3, H0 }
                      _H5 = *v31;
                      __asm
                      {
                        FCVT            S5, H5
                        FCVT            S1, H1
                      }
                      float v648 = _S1 - (float)(_S2 * _S1);
                      if (_S2 == 1.0) {
                        float v648 = 0.0;
                      }
                      BOOL v649 = _H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
                      if (_H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                        float v650 = _S5;
                      }
                      else {
                        float v650 = _S3 * _S5;
                      }
                      if (!v649) {
                        float v648 = (float)(v648 + _S5) - (float)(_S3 * _S5);
                      }
                      _S0 = v650 + v648;
                      __asm { FCVT            H1, S0 }
                      if (!v57)
                      {
                        *uint64_t v31 = _H1;
                        goto LABEL_492;
                      }
                      _S0 = (float)(_S2 + _S3) - (float)(_S2 * _S3);
                      __asm { FCVT            H0, S0 }
                    }
                    *uint64_t v31 = _H1;
                    *int v28 = _H0;
                  }
                }
LABEL_492:
                ++v53;
                v94 += v40 != 0;
                ++v31;
                v629 += 2;
                int v28 = (short float *)((char *)v28 + v47);
                if (!--v630) {
                  goto LABEL_512;
                }
              }
            case 27:
              float v653 = v52 + 1;
              unsigned int v94 = v40;
              int v654 = v4;
              break;
            default:
              goto LABEL_514;
          }
          break;
        }
        while (2)
        {
          unsigned int v655 = *v53;
          if (*v53)
          {
            if (!v40) {
              goto LABEL_499;
            }
            unsigned int v656 = *v94 * v655 + ((*v94 * v655) >> 8) + 1;
            if (BYTE1(v656))
            {
              unsigned int v655 = v656 >> 8;
LABEL_499:
              float v657 = (float)v655 * 0.0039216;
              _H0 = *v653;
              __asm { FCVT            S0, H0 }
              _S0 = v657 * _S0;
              __asm
              {
                FCVT            H0, S0
                FCMP            H0, #0
              }
              if (!(_NF ^ _VF | _ZF))
              {
                _H2 = *(v653 - 1);
                __asm { FCVT            S2, H2 }
                _S1 = v657 * _S2;
                __asm { FCVT            H1, S1 }
                _S2 = 1.0;
                if (!v57) {
                  goto LABEL_503;
                }
                __asm { FCMP            H2, #0 }
                if (_NF ^ _VF | _ZF)
                {
LABEL_509:
                  *uint64_t v31 = _H1;
                  *int v28 = _H0;
                }
                else
                {
                  __asm { FCVT            S2, H2 }
LABEL_503:
                  __asm { FCVT            S4, H0 }
                  _H5 = *v31;
                  __asm
                  {
                    FCVT            S1, H1
                    FCVT            S5, H5
                  }
                  float v672 = _S5 - (float)(_S4 * _S5);
                  _ZF = _H0 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
                  float v673 = 0.0;
                  if (!_ZF) {
                    float v673 = v672;
                  }
                  float v674 = (float)(v673 + _S1) - (float)(_S2 * _S1);
                  if (_S2 != 1.0)
                  {
                    _S1 = _S2 * _S1;
                    float v673 = v674;
                  }
                  _S0 = _S1 + v673;
                  __asm { FCVT            H1, S0 }
                  if (v57)
                  {
                    _S0 = (float)(_S2 + _S4) - (float)(_S2 * _S4);
                    __asm { FCVT            H0, S0 }
                    goto LABEL_509;
                  }
                  *uint64_t v31 = _H1;
                }
              }
            }
          }
          ++v53;
          v94 += v40 != 0;
          ++v31;
          v653 += 2;
          int v28 = (short float *)((char *)v28 + v47);
          if (!--v654)
          {
LABEL_512:
            unsigned int v40 = &v94[v798];
            goto LABEL_513;
          }
          continue;
        }
      }
      int v784 = shape_enum_clip_scan((uint64_t)v803, (_DWORD *)v40 - 4);
      int v43 = v804;
      if (!v784) {
        goto LABEL_606;
      }
    }
    v46 -= v783;
    if (v46 < 1) {
      break;
    }
    uint64_t v785 = v26[17];
    v796 += v26[16] * v783;
    v37 += v785 * v783;
    v31 += v788 * v783;
    uint64_t v786 = v781 * v783;
    if (!v801) {
      uint64_t v786 = 0;
    }
    v28 += v786;
    int v43 = v782;
  }
LABEL_606:
  if (v803) {
    free(v803);
  }
LABEL_608:
  if (v789) {
    free(v789);
  }
}

uint64_t Wf16_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x1000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    uint64_t v12 = Wf16_shade_radial_W;
  }
  else if (*(void *)(v5 + 24))
  {
    uint64_t v12 = Wf16_shade_conic_W;
  }
  else if (v16 < 2)
  {
    uint64_t v12 = Wf16_shade_axial_W;
  }
  else
  {
    uint64_t v12 = Wf16_shade_custom_W;
  }
  uint64_t v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  Wf16_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

void Wf16_shade_axial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  uint64_t v6 = *(float **)(a1 + 272);
  float v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  float v8 = *(float *)(a1 + 336);
  float v9 = *(float *)(a1 + 344);
  float v10 = *(float *)(a1 + 304);
  float v11 = *(float *)(a1 + 308);
  unsigned int v12 = *(_DWORD *)(a1 + 320);
  unsigned int v13 = *(_DWORD *)(a1 + 324);
  uint64_t v16 = a1 + 144;
  int v14 = *(_DWORD **)(a1 + 144);
  int v15 = *(_WORD **)(v16 + 8);
  __n128 v17 = *(float **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v18 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v18 = v6;
  }
  uint64_t v19 = *(void *)(a1 + 32);
  uint64_t v20 = *(void *)(a1 + 40);
  if (v20) {
    unint64_t v21 = *(float **)(a1 + 40);
  }
  else {
    unint64_t v21 = v6;
  }
  if (v5 != 0.0)
  {
    for (unint64_t i = v15 + 1; ; i += 2)
    {
      unsigned int v24 = v12;
      if (v7 >= v10)
      {
        unsigned int v24 = v13;
        if (v7 <= v11) {
          unsigned int v24 = (int)(float)(v9 * (float)(v7 - v8));
        }
      }
      if ((v24 & 0x80000000) != 0)
      {
        if (!v17)
        {
          char v35 = 0;
          goto LABEL_31;
        }
        _S7 = *v18;
        _S16 = *v18 * *v17;
      }
      else
      {
        uint64_t v25 = v24;
        if (!v20) {
          uint64_t v25 = 0;
        }
        _S7 = v21[v25];
        if (v20) {
          float v27 = v21[v25];
        }
        else {
          float v27 = 1.0;
        }
        _S16 = *(float *)(v19 + 4 * v24) * v27;
      }
      __asm { FCVT            H16, S16 }
      *(i - 1) = _H16;
      __asm { FCVT            H7, S7 }
      *unint64_t i = _H7;
      char v35 = -1;
LABEL_31:
      float v7 = v5 + v7;
      *(unsigned char *)int v14 = v35;
      int v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v7 >= v10)
  {
    unsigned int v12 = v13;
    if (v7 <= v11) {
      unsigned int v12 = (int)(float)(v9 * (float)(v7 - v8));
    }
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      _S1 = *v18;
      _S0 = *v18 * *v17;
    }
    else
    {
      uint64_t v36 = v12;
      if (!v20) {
        uint64_t v36 = 0;
      }
      _S1 = v21[v36];
      float v38 = 1.0;
      if (v20) {
        float v38 = v21[v36];
      }
      _S0 = *(float *)(v19 + 4 * v12) * v38;
    }
    __asm
    {
      FCVT            H0, S0
      FCVT            H1, S1
    }
    int v42 = a4 + 4;
    do
    {
      *int v15 = _H0;
      v15[1] = _H1;
      v15[2] = _H0;
      v15[3] = _H1;
      v15[4] = _H0;
      v15[5] = _H1;
      v15[6] = _H0;
      v42 -= 4;
      v15[7] = _H1;
      v15 += 8;
      *v14++ = -1;
    }
    while (v42 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v22 = 4;
    }
    else {
      int v22 = a4;
    }
    bzero(v14, ((a4 - v22 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t Wf16_shade_custom_W(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  uint64_t v6 = *(void *)(result + 272);
  float32x2_t v7 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), *(float *)(v6 + 4) * (float)a3), v7, *(float *)(v6 + 4) * (float)a2));
  float32x4_t v8 = *(float32x4_t *)(result + 304);
  float v9 = *(float *)(result + 336);
  float v10 = *(float *)(result + 348);
  float v11 = *(float *)(result + 344);
  float v12 = *(float *)(result + 356);
  unsigned int v13 = *(char **)(result + 144);
  int v14 = *(float **)(result + 384);
  int v15 = *(float **)(result + 392);
  if (!v15) {
    int v15 = *(float **)(result + 272);
  }
  uint64_t v16 = *(void *)(result + 32);
  uint64_t v17 = *(void *)(result + 40);
  int v18 = *(_DWORD *)(result + 48);
  if (v17) {
    int v19 = *(_DWORD *)(result + 48);
  }
  else {
    int v19 = 0;
  }
  if (v17) {
    uint64_t v6 = *(void *)(result + 40);
  }
  uint64_t v20 = (_WORD *)(*(void *)(result + 152) + 2);
  do
  {
    float32x4_t v21 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v8, v21))), vmovn_s32(vcgtq_f32(v21, v8))), 0xFuLL))) & 1) == 0)
    {
      int v24 = (int)(float)(v12 * (float)(*(float *)&a6.i32[1] - v10));
      __int16 result = (int)(float)(v11 * (float)(*(float *)a6.i32 - v9));
      uint64_t v25 = v16 + 4 * v18 * v24;
      uint64_t v26 = (int)result;
      uint64_t v27 = v6 + 4 * v19 * v24;
      if (!v17) {
        uint64_t v26 = 0;
      }
      _S16 = *(float *)(v27 + 4 * v26);
      if (v17) {
        float v28 = *(float *)(v27 + 4 * v26);
      }
      else {
        float v28 = 1.0;
      }
      _S17 = *(float *)(v25 + 4 * (int)result) * v28;
      goto LABEL_18;
    }
    if (v14)
    {
      _S16 = *v15;
      _S17 = *v15 * *v14;
LABEL_18:
      __asm { FCVT            H17, S17 }
      *(v20 - 1) = _H17;
      __asm { FCVT            H16, S16 }
      _WORD *v20 = _H16;
      char v35 = -1;
      goto LABEL_20;
    }
    char v35 = 0;
LABEL_20:
    *(float32x2_t *)a6.i8 = vadd_f32(v7, *(float32x2_t *)a6.i8);
    *v13++ = v35;
    v20 += 2;
    --a4;
  }
  while (a4);
  return result;
}

void Wf16_shade_conic_W(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(void *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(void *)&a1[34] + 4) * (float)a2));
  float v8 = a1[42].f32[0];
  float v9 = a1[43].f32[0];
  float v10 = a1[38].f32[0];
  float v12 = (unsigned char *)a1[18];
  float v11 = (_WORD *)a1[19];
  float32x2_t v13 = a1[4];
  float32x2_t v14 = a1[5];
  if (v14) {
    float32x2_t v15 = a1[5];
  }
  else {
    float32x2_t v15 = a1[34];
  }
  float v16 = a1[38].f32[1] - v10;
  do
  {
    __n128 v38 = a6;
    float v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    signed int v18 = vcvtms_s32_f32(v17);
    float v19 = ceilf(v17);
    int v20 = (int)floorf(v17);
    unsigned int v21 = vcvtms_s32_f32(v9 + v17);
    float v22 = ceilf(v17 - v9);
    if (v17 < 0.0) {
      signed int v18 = v21;
    }
    if (v17 > v9) {
      float v19 = v22;
    }
    int v23 = (int)v19;
    uint64_t v24 = v18;
    if (!*(void *)&v14) {
      uint64_t v24 = 0;
    }
    float v25 = *(float *)(*(void *)&v13 + 4 * v18);
    uint64_t v26 = v23;
    if (!*(void *)&v14) {
      uint64_t v26 = 0;
    }
    float v27 = v17 - (float)v20;
    if (v14) {
      float v28 = *(float *)(*(void *)&v15 + 4 * v24);
    }
    else {
      float v28 = 1.0;
    }
    float v29 = v25 * v28;
    if (v14) {
      float v30 = *(float *)(*(void *)&v15 + 4 * v26);
    }
    else {
      float v30 = 1.0;
    }
    _S3 = *(float *)(*(void *)&v15 + 4 * v24)
        + (float)(v27 * (float)(*(float *)(*(void *)&v15 + 4 * v26) - *(float *)(*(void *)&v15 + 4 * v24)));
    _S0 = v29 + (float)(v27 * (float)((float)(*(float *)(*(void *)&v13 + 4 * v23) * v30) - v29));
    __asm
    {
      FCVT            H0, S0
      FCVT            H1, S3
    }
    *float v11 = LOWORD(_S0);
    v11[1] = _H1;
    a6.n128_u64[1] = v38.n128_u64[1];
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v38.n128_u64[0]);
    *v12++ = -1;
    v11 += 2;
    --a4;
  }
  while (a4);
}

void Wf16_shade_radial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float **)(a1 + 400);
  float v6 = *(float *)(a1 + 280);
  float v7 = *(float *)(a1 + 284);
  float v8 = *(float **)(a1 + 272);
  float v9 = v8[1];
  float v10 = v9 * (float)a2;
  float v11 = v9 * (float)a3;
  float v12 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v11) + (float)(v6 * v10));
  float v13 = *(float *)(a1 + 300) + (float)((float)(v11 * *(float *)(a1 + 292)) + (float)(v7 * v10));
  float v14 = *(float *)(a1 + 336);
  float v15 = *(float *)(a1 + 344);
  float v16 = *(float *)(a1 + 304);
  float v17 = *(float *)(a1 + 308);
  uint64_t v18 = *(unsigned int *)(a1 + 324);
  float v19 = v5[2];
  float v20 = v5[4];
  float v21 = v5[5];
  float v22 = v5[7];
  uint64_t v25 = a1 + 144;
  int v23 = *(char **)(a1 + 144);
  uint64_t v24 = *(_WORD **)(v25 + 8);
  uint64_t v26 = *(float **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    float v27 = *(float **)(a1 + 392);
  }
  else {
    float v27 = v8;
  }
  uint64_t v28 = *(void *)(a1 + 32);
  uint64_t v29 = *(void *)(a1 + 40);
  if (v29) {
    float v8 = *(float **)(a1 + 40);
  }
  if (v19 != 0.0 || v22 != 0.0 || v7 != 0.0)
  {
    unsigned int v33 = *(_DWORD *)(a1 + 320);
    float v34 = v5[3];
    float v35 = v5[8];
    float v36 = -v5[6];
    float v37 = v17 - v16;
    for (unint64_t i = v24 + 1; ; i += 2)
    {
      float v39 = v36 + (float)((float)(v12 + v12) * v19);
      float v40 = (float)((float)(v13 * v13) + (float)(v12 * v12)) - v22;
      if (v21 == 0.0)
      {
        float v47 = v40 / v39;
      }
      else
      {
        float v41 = (float)((float)(v21 * -4.0) * v40) + (float)(v39 * v39);
        if (v41 < 0.0) {
          goto LABEL_49;
        }
        float v42 = sqrtf(v41);
        float v43 = v35 * (float)(v39 - v42);
        float v44 = v39 + v42;
        float v45 = v35 * v44;
        BOOL v46 = (float)(v35 * v44) <= v43;
        if ((float)(v35 * v44) <= v43) {
          float v47 = v35 * v44;
        }
        else {
          float v47 = v43;
        }
        if (v46) {
          float v45 = v43;
        }
        if (v45 < 0.0)
        {
          _NF = v45 < v34;
LABEL_30:
          unsigned int v49 = v33;
          if (_NF) {
            goto LABEL_49;
          }
LABEL_31:
          if ((v49 & 0x80000000) == 0) {
            goto LABEL_43;
          }
          goto LABEL_49;
        }
        if (v45 <= 1.0)
        {
          float v50 = v16 + (float)(v45 * v37);
          goto LABEL_42;
        }
        if ((v18 & 0x80000000) == 0)
        {
          unsigned int v49 = v18;
          if (v45 <= v20)
          {
LABEL_43:
            uint64_t v51 = v49;
            if (!v29) {
              uint64_t v51 = 0;
            }
            _S25 = v8[v51];
            if (v29) {
              float v53 = v8[v51];
            }
            else {
              float v53 = 1.0;
            }
            _S26 = *(float *)(v28 + 4 * v49) * v53;
            goto LABEL_51;
          }
        }
      }
      if (v47 < 0.0)
      {
        _NF = v47 < v34;
        goto LABEL_30;
      }
      if (v47 > 1.0)
      {
        unsigned int v49 = v18;
        if (v47 > v20) {
          goto LABEL_49;
        }
        goto LABEL_31;
      }
      float v50 = v16 + (float)(v47 * v37);
LABEL_42:
      unsigned int v49 = (int)(float)(v15 * (float)(v50 - v14));
      if ((v49 & 0x80000000) == 0) {
        goto LABEL_43;
      }
LABEL_49:
      if (!v26)
      {
        char v60 = 0;
        goto LABEL_53;
      }
      _S25 = *v27;
      _S26 = *v27 * *v26;
LABEL_51:
      __asm { FCVT            H26, S26 }
      *(i - 1) = _H26;
      __asm { FCVT            H25, S25 }
      *unint64_t i = _H25;
      char v60 = -1;
LABEL_53:
      float v12 = v6 + v12;
      float v13 = v7 + v13;
      *v23++ = v60;
      if (!--a4) {
        return;
      }
    }
  }
  float v30 = v13 * v13;
  float v31 = -v21;
  if (v30 <= (float)-v21)
  {
    float v61 = fabsf(v5[8]);
    float v62 = v21 * -4.0;
    float v63 = v17 - v16;
    if (v29) {
      uint64_t v64 = v18;
    }
    else {
      uint64_t v64 = 0;
    }
    int v65 = v24 + 2;
    int v66 = a4 + 2;
    while (1)
    {
      float v67 = v30 + (float)(v12 * v12);
      float v68 = v6 + v12;
      float v69 = v30 + (float)(v68 * v68);
      if (v67 <= v31 || v69 <= v31)
      {
        float v71 = sqrtf(v62 * v69);
        float v72 = v61 * sqrtf(v62 * v67);
        float v73 = v61 * v71;
        uint64_t v74 = (int)(float)(v15 * (float)((float)(v16 + (float)(v72 * v63)) - v14));
        uint64_t v75 = (int)(float)(v15 * (float)((float)(v16 + (float)((float)(v61 * v71) * v63)) - v14));
        if (v72 > 1.0 || v73 > 1.0)
        {
          if (v72 <= 1.0)
          {
            if ((v74 & 0x80000000) != 0) {
              goto LABEL_100;
            }
            if (v29) {
              uint64_t v77 = (int)(float)(v15 * (float)((float)(v16 + (float)(v72 * v63)) - v14));
            }
            else {
              uint64_t v77 = 0;
            }
          }
          else if (v72 > v20 || (v77 = v64, uint64_t v74 = v18, (v18 & 0x80000000) != 0))
          {
LABEL_100:
            if (v26)
            {
              _S21 = *v27;
              _S22 = *v27 * *v26;
              goto LABEL_102;
            }
            char v95 = 0;
LABEL_103:
            if (v73 <= 1.0)
            {
              if ((v75 & 0x80000000) != 0) {
                goto LABEL_115;
              }
              if (v29) {
                uint64_t v101 = v75;
              }
              else {
                uint64_t v101 = 0;
              }
            }
            else if (v73 > v20 || (v101 = v64, uint64_t v75 = v18, (v18 & 0x80000000) != 0))
            {
LABEL_115:
              if (!v26) {
                goto LABEL_122;
              }
              _S20 = *v27;
              _S21 = *v27 * *v26;
              goto LABEL_117;
            }
            _S20 = v8[v101];
            if (v29) {
              float v103 = v8[v101];
            }
            else {
              float v103 = 1.0;
            }
            _S21 = *(float *)(v28 + 4 * v75) * v103;
LABEL_117:
            __asm { FCVT            H21, S21 }
            *int v65 = _H21;
            __asm { FCVT            H20, S20 }
            goto LABEL_118;
          }
          _S21 = v8[v77];
          if (v29) {
            float v97 = v8[v77];
          }
          else {
            float v97 = 1.0;
          }
          _S22 = *(float *)(v28 + 4 * v74) * v97;
LABEL_102:
          __asm { FCVT            H22, S22 }
          *(v65 - 2) = _H22;
          __asm { FCVT            H21, S21 }
          *(v65 - 1) = _H21;
          char v95 = -1;
          goto LABEL_103;
        }
        uint64_t v81 = (int)v74;
        if (!v29) {
          uint64_t v81 = 0;
        }
        _S20 = v8[v81];
        float v83 = *(float *)(v28 + 4 * (int)v74);
        uint64_t v84 = (int)v75;
        if (v29) {
          float v85 = v8[v81];
        }
        else {
          float v85 = 1.0;
        }
        _S21 = v83 * v85;
        if (!v29) {
          uint64_t v84 = 0;
        }
        _S22 = v8[v84];
        if (v29) {
          float v88 = v8[v84];
        }
        else {
          float v88 = 1.0;
        }
        _S23 = *(float *)(v28 + 4 * (int)v75) * v88;
        __asm { FCVT            H21, S21 }
        *(v65 - 2) = _H21;
        __asm { FCVT            H20, S20 }
        *(v65 - 1) = _H20;
        __asm { FCVT            H20, S23 }
        *int v65 = _H20;
        __asm { FCVT            H20, S22 }
      }
      else
      {
        if ((v18 & 0x80000000) != 0)
        {
          if (!v26)
          {
            char v95 = 0;
LABEL_122:
            char v106 = 0;
            goto LABEL_119;
          }
          _S20 = *v27;
          _S21 = *v27 * *v26;
        }
        else
        {
          _S20 = v8[v64];
          if (v29) {
            float v79 = v8[v64];
          }
          else {
            float v79 = 1.0;
          }
          _S21 = *(float *)(v28 + 4 * v18) * v79;
        }
        __asm { FCVT            H21, S21 }
        *(v65 - 2) = _H21;
        __asm { FCVT            H20, S20 }
        *(v65 - 1) = _H20;
        *int v65 = _H21;
      }
      char v95 = -1;
LABEL_118:
      v65[1] = _H20;
      char v106 = -1;
LABEL_119:
      float v12 = v6 + v68;
      *int v23 = v95;
      v23[1] = v106;
      v23 += 2;
      v65 += 4;
      v66 -= 2;
      if (v66 <= 2) {
        return;
      }
    }
  }
  if (v26 || (v18 & 0x80000000) == 0)
  {
    if ((v18 & 0x80000000) != 0)
    {
      _S1 = *v27;
      _S0 = *v27 * *v26;
    }
    else
    {
      if (v29) {
        uint64_t v107 = v18;
      }
      else {
        uint64_t v107 = 0;
      }
      _S1 = v8[v107];
      float v109 = 1.0;
      if (v29) {
        float v109 = v8[v107];
      }
      _S0 = *(float *)(v28 + 4 * v18) * v109;
    }
    __asm
    {
      FCVT            H0, S0
      FCVT            H1, S1
    }
    int v113 = a4 + 4;
    do
    {
      *uint64_t v24 = _H0;
      v24[1] = _H1;
      v24[2] = _H0;
      v24[3] = _H1;
      v24[4] = _H0;
      v24[5] = _H1;
      v24[6] = _H0;
      v113 -= 4;
      v24[7] = _H1;
      v24 += 8;
      *(_DWORD *)int v23 = -1;
      v23 += 4;
    }
    while (v113 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v32 = 4;
    }
    else {
      int v32 = a4;
    }
    bzero(v23, ((a4 - v32 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t Wf16_sample_CMYKf16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = *(void *)(result + 32);
  uint64_t v8 = *(void *)(result + 40);
  int v9 = *(_DWORD *)(result + 24);
  int v10 = *(_DWORD *)(result + 28);
  uint64_t v11 = *(void *)(result + 176);
  uint64_t v12 = *(void *)(result + 72);
  uint64_t v13 = *(void *)(result + 88);
  uint64_t v129 = *(void *)(result + 80);
  uint64_t v15 = *(void *)(result + 112);
  uint64_t v14 = *(void *)(result + 120);
  int v127 = *(_DWORD *)(result + 188);
  float v16 = (_WORD *)(*(void *)(result + 152) - 4);
  float v17 = (unsigned char *)(*(void *)(result + 144) - 1);
  int v18 = *(_DWORD *)(result + 260) - 1;
  int v19 = *(_DWORD *)(result + 256);
  unint64_t v20 = v8 + (v18 * v10) + 2 * (v19 - 1);
  int v125 = *(_DWORD *)(result + 240);
  unint64_t v21 = v7 + (v18 * v9) + 2 * (4 * v19) - 8;
  uint64_t v128 = *(void *)(result + 64);
  int v126 = a4;
  while (1)
  {
    if (a3 >= v12)
    {
      if (a3 <= v13)
      {
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        uint64_t v33 = v128;
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = *(void *)(result + 224) + v13;
        uint64_t v28 = v27 - a3 + (v26 >> 1);
        if (v28 < 1) {
          goto LABEL_39;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        uint64_t v33 = v128;
        unsigned int v31 = v29 | v127;
        uint64_t v32 = v27 - 0x1000000;
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v22 = *(void *)(result + 216);
      uint64_t v23 = v12 - *(void *)(result + 224);
      uint64_t v24 = a3 - v23 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_39;
      }
      if (v24 >= v22) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
      }
      uint64_t v33 = v128;
      unsigned int v31 = v25 | v127;
      uint64_t v32 = v23 + 0x1000000;
      uint64_t v30 = 512;
    }
    if (a2 >= v33)
    {
      if (a2 <= v129)
      {
        uint64_t v38 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v37 = a2;
      }
      else
      {
        uint64_t v39 = *(void *)(result + 192);
        uint64_t v40 = *(void *)(result + 200) + v129;
        uint64_t v41 = v40 - a2 + (v39 >> 1);
        if (v41 < 1) {
          goto LABEL_39;
        }
        if (v41 < v39) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v41) >> 32) >> 15)) | v127;
        }
        uint64_t v37 = v40 - 0x1000000;
        uint64_t v38 = 28;
      }
    }
    else
    {
      uint64_t v34 = *(void *)(result + 192);
      uint64_t v35 = v33 - *(void *)(result + 200);
      uint64_t v36 = a2 - v35 + (v34 >> 1);
      if (v36 < 1) {
        goto LABEL_39;
      }
      if (v36 < v34) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v127;
      }
      uint64_t v37 = v35 + 0x1000000;
      uint64_t v38 = 32;
    }
    if (v31 >= 0x400000) {
      break;
    }
LABEL_39:
    --a4;
    a2 += v15;
    a3 += v14;
    v16 += 2;
    *++float v17 = 0;
LABEL_40:
    if (!a4) {
      return result;
    }
  }
  uint64_t v42 = v32 >> 32;
  uint64_t v43 = v37 >> 32;
  uint64_t v44 = v7 + (int)v42 * (uint64_t)v9;
  unint64_t v45 = v44 + 8 * v43;
  BOOL v46 = *(float16x4_t **)(result + 32);
  if (v21 >= v45) {
    float v47 = (float16x4_t *)(v44 + 8 * v43);
  }
  else {
    float v47 = (float16x4_t *)v21;
  }
  if (v47 < v46) {
    float v47 = *(float16x4_t **)(result + 32);
  }
  if (v8)
  {
    unint64_t v48 = v8 + (int)v42 * (uint64_t)v10 + 2 * v43;
    unsigned int v49 = *(__int16 **)(result + 40);
    if (v20 >= v48) {
      float v50 = (__int16 *)v48;
    }
    else {
      float v50 = (__int16 *)v20;
    }
    if (v50 >= v49) {
      unsigned int v49 = v50;
    }
    _H5 = *v49;
  }
  else
  {
    unint64_t v48 = 0;
    _H5 = COERCE_UNSIGNED_INT(1.0);
  }
  _D6 = *v47;
  uint64_t v53 = v129;
  if (!v11) {
    goto LABEL_119;
  }
  unsigned int v54 = *(_DWORD *)(v11 + (v38 | v30));
LABEL_45:
  int v55 = v54 & 0xF;
  int v56 = HIBYTE(v54) & 3;
  switch(v55)
  {
    case 1:
      float v90 = (float16x4_t *)(v45 + SBYTE1(v54) * (uint64_t)v9);
      if (v21 < (unint64_t)v90) {
        float v90 = (float16x4_t *)v21;
      }
      if (v90 < v46) {
        float v90 = v46;
      }
      float16x4_t v91 = *v90;
      _H16 = COERCE_UNSIGNED_INT(1.0);
      if (v8)
      {
        int v93 = (__int16 *)(v48 + SBYTE1(v54) * (uint64_t)v10);
        if (v20 < (unint64_t)v93) {
          int v93 = (__int16 *)v20;
        }
        if ((unint64_t)v93 < *(void *)(result + 40)) {
          int v93 = *(__int16 **)(result + 40);
        }
        _H16 = *v93;
      }
      _Q17.i16[0] = interpolate_cmykaf[5 * v56 + 4];
      __asm { FCVT            S17, H17 }
      float32x4_t v94 = vcvtq_f32_f16(_D6);
      _D6 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v94, v94, *(float32x2_t *)_Q17.f32, 0), vcvtq_f32_f16(v91), _Q17.f32[0]));
      __asm { FCVT            S5, H5 }
      float v96 = _S5 - (float)(_S5 * _Q17.f32[0]);
      __asm { FCVT            S7, H16 }
      goto LABEL_117;
    case 2:
      int64_t v98 = (unint64_t)HIWORD(v54) << 56;
      float v99 = (float16x4_t *)(v45 + (v98 >> 53));
      if (v21 < (unint64_t)v99) {
        float v99 = (float16x4_t *)v21;
      }
      if (v99 < v46) {
        float v99 = v46;
      }
      float16x4_t v100 = *v99;
      _H7 = COERCE_UNSIGNED_INT(1.0);
      if (v8)
      {
        unsigned int v102 = (__int16 *)(v48 + (v98 >> 55));
        if (v20 < (unint64_t)v102) {
          unsigned int v102 = (__int16 *)v20;
        }
        if ((unint64_t)v102 < *(void *)(result + 40)) {
          unsigned int v102 = *(__int16 **)(result + 40);
        }
        _H7 = *v102;
      }
      _Q17.i16[0] = interpolate_cmykaf[5 * ((v54 >> 28) & 3) + 4];
      __asm { FCVT            S17, H17 }
      float32x4_t v103 = vcvtq_f32_f16(_D6);
      _D6 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v103, v103, *(float32x2_t *)_Q17.f32, 0), vcvtq_f32_f16(v100), _Q17.f32[0]));
      __asm { FCVT            S5, H5 }
      float v96 = _S5 - (float)(_S5 * _Q17.f32[0]);
      __asm { FCVT            S7, H7 }
LABEL_117:
      _S5 = v96 + (float)(_S7 * _Q17.f32[0]);
      goto LABEL_118;
    case 3:
      int64_t v57 = (unint64_t)HIWORD(v54) << 56;
      char v58 = (float16x4_t *)(v45 + (v57 >> 53));
      if (v21 < (unint64_t)v58) {
        char v58 = (float16x4_t *)v21;
      }
      if (v58 < v46) {
        char v58 = v46;
      }
      int v59 = (float16x4_t *)(v45 + SBYTE1(v54) * (uint64_t)v9);
      if (v21 >= (unint64_t)v59) {
        char v60 = v59;
      }
      else {
        char v60 = (float16x4_t *)v21;
      }
      if (v60 < v46) {
        char v60 = v46;
      }
      float v61 = (float16x4_t *)((char *)v59 + (v57 >> 53));
      if (v21 < (unint64_t)v61) {
        float v61 = (float16x4_t *)v21;
      }
      if (v61 < v46) {
        float v61 = v46;
      }
      float16x4_t v62 = *v60;
      float16x4_t v63 = *v61;
      _H18 = COERCE_UNSIGNED_INT(1.0);
      _H19 = COERCE_UNSIGNED_INT(1.0);
      _H20 = COERCE_UNSIGNED_INT(1.0);
      if (v8)
      {
        float v67 = (__int16 *)(v48 + (v57 >> 55));
        unint64_t v68 = *(void *)(result + 40);
        if (v20 < (unint64_t)v67) {
          float v67 = (__int16 *)v20;
        }
        if ((unint64_t)v67 < v68) {
          float v67 = *(__int16 **)(result + 40);
        }
        _H18 = *v67;
        unint64_t v69 = v48 + SBYTE1(v54) * (uint64_t)v10;
        if (v20 >= v69) {
          uint64_t v70 = (__int16 *)(v48 + SBYTE1(v54) * (uint64_t)v10);
        }
        else {
          uint64_t v70 = (__int16 *)v20;
        }
        if ((unint64_t)v70 < v68) {
          uint64_t v70 = *(__int16 **)(result + 40);
        }
        _H19 = *v70;
        float v71 = (__int16 *)(v69 + (v57 >> 55));
        if (v20 < (unint64_t)v71) {
          float v71 = (__int16 *)v20;
        }
        if ((unint64_t)v71 < v68) {
          float v71 = *(__int16 **)(result + 40);
        }
        _H20 = *v71;
      }
      _H21 = interpolate_cmykaf[5 * v56 + 4];
      __asm { FCVT            S21, H21 }
      _H22 = interpolate_cmykaf[5 * ((v54 >> 28) & 3) + 4];
      __asm { FCVT            S22, H22 }
      float32x4_t v77 = vcvtq_f32_f16(_D6);
      float32x4_t v78 = vcvtq_f32_f16(*v58);
      float32x4_t v79 = vcvtq_f32_f16(v62);
      _Q17 = vcvtq_f32_f16(v63);
      __asm
      {
        FCVT            S5, H5
        FCVT            S18, H18
      }
      float v82 = (float)(_S5 - (float)(_S5 * _D22.f32[0])) + (float)(_S18 * _D22.f32[0]);
      if (v82 < 1.0) {
        float v83 = v82;
      }
      else {
        float v83 = 1.0;
      }
      if (v82 > 1.0) {
        float v82 = 1.0;
      }
      if (v83 < 0.0) {
        float v82 = 0.0;
      }
      __asm
      {
        FCVT            S18, H19
        FCVT            S19, H20
      }
      float v86 = (float)(_S18 - (float)(_S18 * _D22.f32[0])) + (float)(_S19 * _D22.f32[0]);
      if (v86 < 1.0) {
        float v87 = v86;
      }
      else {
        float v87 = 1.0;
      }
      if (v86 > 1.0) {
        float v86 = 1.0;
      }
      if (v87 < 0.0) {
        float v86 = 0.0;
      }
      float32x4_t v88 = vmlaq_n_f32(vmlsq_lane_f32(v77, v77, _D22, 0), v78, _D22.f32[0]);
      _D6 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v88, v88, _D21, 0), vmlaq_n_f32(vmlsq_lane_f32(v79, v79, _D22, 0), _Q17, _D22.f32[0]), _D21.f32[0]));
      _S5 = (float)(v82 - (float)(v82 * _D21.f32[0])) + (float)(v86 * _D21.f32[0]);
      if (_S5 >= 1.0) {
        _S5 = 1.0;
      }
      if (_S5 <= 0.0) {
        _S5 = 0.0;
      }
LABEL_118:
      __asm { FCVT            H5, S5 }
      uint64_t v53 = v129;
      break;
  }
LABEL_119:
  ++v17;
  a2 += v15;
  uint64_t v105 = v53 - a2;
  v16 += 2;
  a3 += v14;
  uint64_t v106 = v13 - a3;
  while (1)
  {
    int v107 = a4;
    __asm { FCVT            S7, H5 }
    _H16 = _D6.i16[3];
    __asm
    {
      FCVT            S16, H16
      FCVT            S17, H6
    }
    _H18 = _D6.i16[1];
    __asm { FCVT            S18, H18 }
    _H6 = _D6.i16[2];
    __asm { FCVT            S6, H6 }
    _S6 = (float)((float)((float)((float)(_S7 - _S18) - _S16) * 0.59)
                + (float)((float)((float)(_S7 - _S17) - _S16) * 0.3))
        + (float)((float)((float)(_S7 - _S6) - _S16) * 0.11);
    __asm { FCVT            H6, S6 }
    *float v16 = LOWORD(_S6);
    v16[1] = _H5;
    *float v17 = v31 >> 22;
    if (!--a4) {
      return result;
    }
    if ((v106 | v105 | (a3 - v12) | (a2 - v128)) < 0) {
      goto LABEL_40;
    }
    unint64_t v45 = v7 + SHIDWORD(a3) * (uint64_t)v9 + 8 * (a2 >> 32);
    BOOL v46 = *(float16x4_t **)(result + 32);
    if (v21 >= v45) {
      unint64_t v117 = v7 + SHIDWORD(a3) * (uint64_t)v9 + 8 * (a2 >> 32);
    }
    else {
      unint64_t v117 = v21;
    }
    if (v117 >= (unint64_t)v46) {
      int v118 = (float16x4_t *)v117;
    }
    else {
      int v118 = *(float16x4_t **)(result + 32);
    }
    if (v8)
    {
      unint64_t v48 = v8 + SHIDWORD(a3) * (uint64_t)v10 + 2 * (a2 >> 32);
      unsigned int v119 = *(__int16 **)(result + 40);
      if (v20 >= v48) {
        unint64_t v120 = v8 + SHIDWORD(a3) * (uint64_t)v10 + 2 * (a2 >> 32);
      }
      else {
        unint64_t v120 = v20;
      }
      if (v120 >= (unint64_t)v119) {
        unsigned int v119 = (__int16 *)v120;
      }
      _H5 = *v119;
    }
    else
    {
      _H5 = COERCE_UNSIGNED_INT(1.0);
    }
    _D6 = *v118;
    if (v11)
    {
      unsigned int v54 = *(_DWORD *)(v11 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      unsigned int v121 = v54 & 0xF;
      if ((v54 & 0xF) != 0)
      {
        float v122 = *(unsigned int **)(result + 264);
        unsigned int v123 = *v122;
        if (v107 != v126 && a4 != 1 && v125 != 1 && v123 == 3 && v121 < 3) {
          v54 |= 3u;
        }
        unsigned int v31 = -1;
        if (v123 < v121) {
          *float v122 = v121;
        }
        uint64_t v53 = v129;
        goto LABEL_45;
      }
    }
    ++v17;
    v105 -= v15;
    v16 += 2;
    a3 += v14;
    v106 -= v14;
    a2 += v15;
    unsigned int v31 = -1;
  }
}

_WORD *CGFontIndexMapCreate(__int16 a1)
{
  __int16 result = malloc_type_calloc(1uLL, 0x208uLL, 0x1080040036EC52CuLL);
  _WORD *result = a1;
  return result;
}

uint64_t CGFontIndexMapCreateIdentity()
{
  return -1;
}

unsigned __int16 *CGFontIndexMapAddIndexes(unsigned __int16 *result, unsigned __int16 *a2, _WORD *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = result;
    if (result)
    {
      if (result != (unsigned __int16 *)-1)
      {
        float v5 = a2;
        if (a2)
        {
          float v6 = a3;
          if (a3)
          {
            uint64_t v7 = a4;
            do
            {
              unsigned int v9 = *v5++;
              unsigned int v8 = v9;
              LOWORD(v9) = *v6++;
              __int16 result = CGFontIndexMapAddIndex(v4, v8, v9);
              --v7;
            }
            while (v7);
          }
        }
      }
    }
  }
  return result;
}

unsigned __int16 *CGFontIndexMapAddRange(unsigned __int16 *result, int a2, unsigned int a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = result;
    if ((unint64_t)result + 1 >= 2)
    {
      __int16 v5 = a2;
      if (a3 + a2 <= 0x10000)
      {
        if (a3)
        {
          uint64_t v7 = 0;
          uint64_t v8 = a3;
          do
          {
            __int16 result = CGFontIndexMapAddIndex(v4, (unsigned __int16)(v7 + v5), *(_WORD *)(a4 + 2 * v7));
            ++v7;
          }
          while (v8 != v7);
        }
      }
    }
  }
  return result;
}

uint64_t CGFontIndexMapGetValue(unsigned __int16 *a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFLL;
  }
  if (a1 != (unsigned __int16 *)-1)
  {
    unint64_t v2 = atomic_load((unint64_t *)&a1[4 * (a2 >> 10) + 4]);
    if (v2) {
      return *(unsigned __int16 *)(v2 + 2 * (a2 & 0x3FF));
    }
    else {
      return *a1;
    }
  }
  return a2;
}

__int16 *CGFontIndexMapGetValues(__int16 *result, unsigned __int16 *a2, uint64_t a3, _WORD *a4)
{
  if (a3 && result && a2 && a4)
  {
    if (result == (__int16 *)-1)
    {
      do
      {
        __int16 v8 = *a2++;
        *a4++ = v8;
        --a3;
      }
      while (a3);
    }
    else
    {
      do
      {
        unsigned int v5 = *a2++;
        __int16 v4 = v5;
        unint64_t v6 = atomic_load((unint64_t *)((char *)result + (((unint64_t)v5 >> 7) & 0x1F8) + 8));
        if (v6) {
          __int16 v7 = *(_WORD *)(v6 + 2 * (v4 & 0x3FF));
        }
        else {
          __int16 v7 = *result;
        }
        *a4++ = v7;
        --a3;
      }
      while (a3);
    }
  }
  return result;
}

uint64_t CGFontIndexMapPrint(unsigned __int16 *a1, FILE *a2)
{
  if (a2) {
    unint64_t v2 = a2;
  }
  else {
    unint64_t v2 = (FILE *)*MEMORY[0x1E4F143D8];
  }
  if (a1 == (unsigned __int16 *)-1) {
    return fprintf(v2, "CGFontIndexMap %p: <identity>\n");
  }
  if (!a1) {
    return fprintf(v2, "CGFontIndexMap %p: <null>\n");
  }
  uint64_t result = fprintf(v2, "CGFontIndexMap %p: default value: %hu\n", a1, *a1);
  for (uint64_t i = 0; i != 0xFFFF; ++i)
  {
    unint64_t v6 = atomic_load((unint64_t *)&a1[4 * ((unsigned __int16)i >> 10) + 4]);
    if (v6)
    {
      int v7 = *(unsigned __int16 *)(v6 + 2 * (i & 0x3FF));
      if (v7 != *a1) {
        uint64_t result = fprintf(v2, "  %hu -> %hu\n", i, v7);
      }
    }
  }
  return result;
}

void __CGLibraryLoadlibFontRegistryDYLD_block_invoke()
{
  CGLibraryLoadlibFontRegistryDYLD_handle = (uint64_t)dlopen("/System/Library/PrivateFrameworks/FontServices.framework/FontServices", 5);
  if (!CGLibraryLoadlibFontRegistryDYLD_handle) {
    CGPostError((uint64_t)"Failed to load %s", v0, v1, v2, v3, v4, v5, v6, (char)"/System/Library/PrivateFrameworks/FontServices.framework/FontServices");
  }
}

__CFDictionary *CGPDFDocumentCopyInfoDictionary(CGPDFDocument *a1)
{
  CGPDFDictionaryRef Info = CGPDFDocumentGetInfo(a1);
  if (!Info) {
    return 0;
  }
  uint64_t v2 = Info;
  CGPDFArrayRef v13 = 0;
  CGPDFStringRef value = 0;
  CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (CGPDFDictionaryGetString(v2, "Title", &value)) {
    set_string_value(Mutable, @"kCGPDFDocumentTitle", value);
  }
  if (CGPDFDictionaryGetString(v2, "Author", &value)) {
    set_string_value(Mutable, @"kCGPDFDocumentAuthor", value);
  }
  if (CGPDFDictionaryGetString(v2, "Subject", &value)) {
    set_string_value(Mutable, @"kCGPDFDocumentSubject", value);
  }
  if (CGPDFDictionaryGetString(v2, "Creator", &value)) {
    set_string_value(Mutable, @"kCGPDFDocumentCreator", value);
  }
  if (CGPDFDictionaryGetString(v2, "Producer", &value)) {
    set_string_value(Mutable, @"kCGPDFDocumentProducer", value);
  }
  if (CGPDFDictionaryGetString(v2, "CreationDate", &value)) {
    set_date_value(Mutable, @"kCGPDFDocumentCreationDate", value);
  }
  if (CGPDFDictionaryGetString(v2, "ModDate", &value)) {
    set_date_value(Mutable, @"kCGPDFDocumentModificationDate", value);
  }
  if (CGPDFDictionaryGetArray(v2, "AAPL:Keywords", &v13))
  {
    CGPDFArrayRef v4 = v13;
    uint64_t v5 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (v4)
    {
      uint64_t v6 = *((void *)v4 + 2);
      if (v6)
      {
        size_t v7 = 0;
        CGPDFStringRef string = 0;
        do
        {
          if (CGPDFArrayGetString(v4, v7, &string))
          {
            CFStringRef v8 = CGPDFStringCopyTextString(string);
            if (v8)
            {
              CFStringRef v9 = v8;
              CFArrayAppendValue(v5, v8);
              CFRelease(v9);
            }
          }
          ++v7;
        }
        while (v6 != v7);
      }
    }
  }
  else
  {
    if (!CGPDFDictionaryGetString(v2, "Keywords", &value)) {
      return Mutable;
    }
    uint64_t v5 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFStringRef v10 = CGPDFStringCopyTextString(value);
    if (v10)
    {
      CFStringRef v11 = v10;
      CFArrayAppendValue(v5, v10);
      CFRelease(v11);
    }
  }
  if (v5)
  {
    if (CFArrayGetCount(v5) >= 1) {
      CFDictionarySetValue(Mutable, @"kCGPDFDocumentKeywords", v5);
    }
    CFRelease(v5);
  }
  return Mutable;
}

void set_string_value(__CFDictionary *a1, const void *a2, CGPDFStringRef string)
{
  CFStringRef v5 = CGPDFStringCopyTextString(string);
  if (v5)
  {
    CFStringRef v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

void set_date_value(__CFDictionary *a1, const void *a2, CGPDFStringRef string)
{
  CFDateRef v5 = CGPDFStringCopyDate(string);
  if (v5)
  {
    CFDateRef v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)23,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, uint16x8_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  float v17 = *result;
  unint64_t v18 = *a3;
  int v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFF000000FFLL;
  v22.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v21), v22);
  if (a8) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  int8x16_t v24 = vandq_s8(vdupq_n_s8(v23), v22);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a13.i64[0] = -1;
  a13.i64[1] = -1;
  while (1)
  {
    __int32 v28 = *(_DWORD *)v20;
    if (*(_DWORD *)v20 == -1)
    {
      uint64_t v35 = (unsigned __int8 *)&v20[v16];
      uint64_t v36 = (int8x16_t *)v20;
      do
        uint64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, (int8x16_t)a13)) & 0x80) != 0);
      do
      {
        uint64_t v38 = v37;
        uint64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          uint64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            uint64_t v38 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v20;
      unint64_t v41 = (char *)v38 - v20;
      do
      {
        int8x16_t v42 = vorrq_s8(*(int8x16_t *)((char *)v17 + v39), a9);
        int8x16_t v43 = vorrq_s8(*(int8x16_t *)((char *)v19 + v39), v24);
        int8x16_t v44 = vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CE030);
        int8x16_t v45 = vqtbl1q_s8(v43, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v46 = vminq_u8((uint8x16_t)v42, (uint8x16_t)v44);
        int8x16_t v47 = (int8x16_t)vminq_u8((uint8x16_t)v43, (uint8x16_t)v45);
        uint8x16_t v48 = (uint8x16_t)vmvnq_s8(v47);
        int8x16_t v49 = (int8x16_t)vcgtq_u8((uint8x16_t)(*(_OWORD *)&v47 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)), v48);
        uint8x16_t v50 = vabdq_u8(v48, (uint8x16_t)(*(_OWORD *)&v47 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
        uint16x8_t v51 = vmull_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v50.i8);
        uint16x8_t v52 = vmull_high_u8(v46, v50);
        uint16x8_t v53 = vminq_u16(v51, v27);
        uint16x8_t v54 = vminq_u16(v52, v27);
        uint8x16_t v55 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v53, v53, 8uLL), 8uLL), vrsraq_n_u16(v54, v54, 8uLL), 8uLL);
        int8x16_t v56 = vbslq_s8(v49, (int8x16_t)vqsubq_u8((uint8x16_t)v47, v55), (int8x16_t)vqaddq_u8((uint8x16_t)v47, v55));
        int8x16_t v15 = vceqzq_s8(v44);
        *(int8x16_t *)((char *)v19 + v39) = vbslq_s8(v15, v43, vbslq_s8(vceqzq_s8(v45), v42, (int8x16_t)vminq_u8((uint8x16_t)v56, (uint8x16_t)vqtbl1q_s8(v56, (int8x16_t)xmmword_1850CE030))));
        v20 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      int v19 = (_DWORD *)((char *)v19 + v39);
      float v17 = (unsigned __int32 *)((char *)v17 + v39);
      unint64_t v16 = v16 - v40 + v41;
      goto LABEL_37;
    }
    if (v28) {
      break;
    }
    unint64_t v29 = (unsigned __int8 *)&v20[v16];
    uint64_t v30 = (int8x16_t *)v20;
    do
      unsigned int v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      uint64_t v32 = v31;
      unsigned int v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        uint64_t v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          uint64_t v32 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v20;
    int64_t v34 = ((char *)v32 - v20) * a6;
    v17 += v34;
    v19 += v34;
    v20 += v34;
    v16 -= v33;
LABEL_37:
    if (v16 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v57 = 0;
  while (1)
  {
    v15.i32[0] = v28;
    int8x16_t v58 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v59 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v17 + v57), a9);
    int8x16_t v60 = vorrq_s8(vbicq_s8(v24, vceqzq_s8(v58)), *(int8x16_t *)((char *)v19 + v57));
    v94.val[1] = (int8x16_t)vmull_u8(*(uint8x8_t *)v59.i8, *(uint8x8_t *)v58.i8);
    uint16x8_t v61 = vmull_high_u8(v59, (uint8x16_t)v58);
    uint16x8_t v62 = vminq_u16((uint16x8_t)v94.val[1], v27);
    uint16x8_t v63 = vminq_u16(v61, v27);
    v94.val[0] = (int8x16_t)vrsraq_n_u16(v62, v62, 8uLL);
    uint16x8_t v64 = vrsraq_n_u16(v63, v63, 8uLL);
    *(uint8x8_t *)v94.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v94.val[0], 8uLL);
    *(uint8x8_t *)v94.val[1].i8 = vqrshrn_n_u16(v64, 8uLL);
    int8x16_t v65 = vqtbl2q_s8(v94, (int8x16_t)xmmword_1850CE040);
    v94.val[0] = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v94.val[0].i8, v64, 8uLL);
    int8x16_t v66 = vqtbl1q_s8(v60, (int8x16_t)xmmword_1850CE030);
    v94.val[1] = (int8x16_t)vminq_u8((uint8x16_t)v94.val[0], (uint8x16_t)v65);
    int8x16_t v67 = (int8x16_t)vminq_u8((uint8x16_t)v60, (uint8x16_t)v66);
    uint8x16_t v68 = (uint8x16_t)vmvnq_s8(v67);
    int8x16_t v69 = (int8x16_t)vcgtq_u8((uint8x16_t)(*(_OWORD *)&v67 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)), v68);
    uint8x16_t v70 = vabdq_u8(v68, (uint8x16_t)(*(_OWORD *)&v67 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
    uint16x8_t v71 = vmull_u8(*(uint8x8_t *)v94.val[1].i8, *(uint8x8_t *)v70.i8);
    v94.val[1] = (int8x16_t)vmull_high_u8((uint8x16_t)v94.val[1], v70);
    uint16x8_t v72 = vminq_u16(v71, v27);
    v94.val[1] = (int8x16_t)vminq_u16((uint16x8_t)v94.val[1], v27);
    uint8x16_t v73 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v72, v72, 8uLL), 8uLL), vrsraq_n_u16((uint16x8_t)v94.val[1], (uint16x8_t)v94.val[1], 8uLL), 8uLL);
    v94.val[1] = vbslq_s8(v69, (int8x16_t)vqsubq_u8((uint8x16_t)v67, v73), (int8x16_t)vqaddq_u8((uint8x16_t)v67, v73));
    int8x16_t v74 = vbslq_s8(vceqzq_s8(v66), v94.val[0], (int8x16_t)vminq_u8((uint8x16_t)v94.val[1], (uint8x16_t)vqtbl1q_s8(v94.val[1], (int8x16_t)xmmword_1850CE030)));
    int8x16_t v15 = vceqzq_s8(v65);
    *(int8x16_t *)((char *)v19 + v57) = vbslq_s8(v15, v60, v74);
    v20 += v25;
    v16 -= 4;
    if (v16 < 4) {
      break;
    }
    __int32 v28 = *(_DWORD *)v20;
    v57 += v26;
    if ((*(_DWORD *)v20 - 1) >= 0xFFFFFFFE)
    {
      float v17 = (unsigned __int32 *)((char *)v17 + v57);
      int v19 = (_DWORD *)((char *)v19 + v57);
      goto LABEL_37;
    }
  }
  float v17 = (unsigned __int32 *)((char *)v17 + v26 + v57);
  int v19 = (_DWORD *)((char *)v19 + v26 + v57);
LABEL_40:
  uint64_t v75 = v16 + a14;
  if (v75)
  {
    if (a7) {
      unsigned int v76 = 0;
    }
    else {
      unsigned int v76 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v76), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v77 = 0;
    }
    else {
      unsigned int v77 = -1;
    }
    int8x8_t v78 = vand_s8(vdup_n_s8(v77), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v79 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v17;
      uint16x8_t v80 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v81) = v80.i8[0];
      BYTE1(v81) = v80.i8[2];
      BYTE2(v81) = v80.i8[4];
      HIBYTE(v81) = v80.i8[6];
      v80.i32[0] = *v19;
      uint16x8_t v82 = vmovl_u8(*(uint8x8_t *)v80.i8);
      LOBYTE(v83) = v82.i8[0];
      BYTE1(v83) = v82.i8[2];
      BYTE2(v83) = v82.i8[4];
      HIBYTE(v83) = v82.i8[6];
      v82.i8[7] = 0;
      v82.i8[0] = *v20;
      v82.i8[1] = *v20;
      v82.i8[2] = *v20;
      *(__int32 *)((char *)v82.i32 + 3) = *v20;
      int8x8_t v84 = vorr_s8(vbic_s8(v78, vceqz_s8(*(int8x8_t *)v82.i8)), (int8x8_t)v83);
      uint16x8_t v85 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v81, *(int8x8_t *)a9.i8), *(uint8x8_t *)v82.i8), v79);
      a13 = vrsraq_n_u16(v85, v85, 8uLL);
      int8x8_t v86 = (int8x8_t)vqrshrn_n_u16(a13, 8uLL);
      *(int8x8_t *)a13.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v86, a13, 8uLL), (int8x8_t)0x404040400000000);
      *(int8x8_t *)v87.i8 = v84;
      v87.u64[1] = (unint64_t)v84;
      *(int8x8_t *)v87.i8 = vqtbl1_s8(v87, (int8x8_t)0x404040400000000);
      int8x8_t v88 = (int8x8_t)vmin_u8((uint8x8_t)v84, *(uint8x8_t *)v87.i8);
      uint8x8_t v89 = (uint8x8_t)vmvn_s8(v88);
      uint16x8_t v90 = vminq_u16(vmull_u8(vmin_u8((uint8x8_t)v86, *(uint8x8_t *)a13.i8), vabd_u8(v89, (uint8x8_t)(*(void *)&v88 & 0xFFFFFF00FFFFFF00))), v79);
      *(uint8x8_t *)v90.i8 = vqrshrn_n_u16(vrsraq_n_u16(v90, v90, 8uLL), 8uLL);
      *(int8x8_t *)v91.i8 = vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)(*(void *)&v88 & 0xFFFFFF00FFFFFF00), v89), (int8x8_t)vqsub_u8((uint8x8_t)v88, *(uint8x8_t *)v90.i8), (int8x8_t)vqadd_u8((uint8x8_t)v88, *(uint8x8_t *)v90.i8));
      v91.i64[1] = v91.i64[0];
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)a13.i8), v84, vbsl_s8(vceqz_s8(*(int8x8_t *)v87.i8), v86, (int8x8_t)vmin_u8(*(uint8x8_t *)v91.i8, (uint8x8_t)vqtbl1_s8(v91, (int8x8_t)0x404040400000000))));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a13, a9));
      *int v19 = a13.i32[0];
      uint64_t v92 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v92 >= v18) {
        uint64_t v93 = -(uint64_t)a5;
      }
      else {
        uint64_t v93 = 0;
      }
      float v17 = &v92[v93];
      v19 += a6;
      --v75;
    }
    while (v75);
  }
  _WORD *result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)22,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, double a13, uint8x8_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v18 = a16;
  int v19 = *result;
  unint64_t v20 = *a3;
  unsigned int v21 = *a2;
  int8x16_t v22 = *a4;
  if (a16 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFF000000FFLL;
  v24.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v23), v24);
  if (a8) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = vandq_s8(vdupq_n_s8(v25), v24);
  uint64_t v27 = 4 * a6;
  uint64_t v28 = 16 * a6;
  uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  v30.i64[0] = -65536;
  v30.i64[1] = -65536;
  a14.i32[1] = 67372036;
  v31.i64[0] = -1;
  v31.i64[1] = -1;
  while (1)
  {
    __int32 v32 = *(_DWORD *)v22;
    if (*(_DWORD *)v22 == -1)
    {
      uint64_t v39 = (unsigned __int8 *)&v22[v18];
      int64_t v40 = (int8x16_t *)v22;
      do
        unint64_t v41 = v40++;
      while (v40 <= (int8x16_t *)v39 && (vminvq_u8((uint8x16_t)vceqq_s8(*v41, v31)) & 0x80) != 0);
      do
      {
        int8x16_t v42 = v41;
        unint64_t v41 = (int8x16_t *)((char *)v41 + 4);
      }
      while (v41 <= (int8x16_t *)v39 && v42->i32[0] == -1);
      if (v42 < (int8x16_t *)v39)
      {
        while (v42->u8[0] == 255)
        {
          int8x16_t v42 = (int8x16_t *)((char *)v42 + 1);
          if (v42 >= (int8x16_t *)v39)
          {
            int8x16_t v42 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      uint64_t v43 = 0;
      int64_t v44 = (char *)v42 - v22;
      unint64_t v45 = (char *)v42 - v22;
      do
      {
        int8x16_t v46 = vorrq_s8(*(int8x16_t *)((char *)v19 + v43), a9);
        int8x16_t v47 = vorrq_s8(*(int8x16_t *)((char *)v21 + v43), v26);
        int8x16_t v48 = vqtbl1q_s8(v46, (int8x16_t)xmmword_1850CE030);
        int8x16_t v49 = vqtbl1q_s8(v47, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v50 = vminq_u8((uint8x16_t)v46, (uint8x16_t)v48);
        uint8x16_t v51 = vminq_u8((uint8x16_t)v47, (uint8x16_t)v49);
        uint8x16_t v52 = (uint8x16_t)vmvnq_s8(v48);
        uint8x16_t v53 = (uint8x16_t)vmvnq_s8(v49);
        v99.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v49.i8), (uint16x8_t)vandq_s8((int8x16_t)vmull_u8(*(uint8x8_t *)v51.i8, *(uint8x8_t *)v48.i8), v30)), vmull_u8(*(uint8x8_t *)v51.i8, *(uint8x8_t *)v52.i8)), vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v53.i8));
        uint16x8_t v54 = vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_high_u8(v50, (uint8x16_t)v49), (uint16x8_t)vandq_s8((int8x16_t)vmull_high_u8(v51, (uint8x16_t)v48), v30)), vmull_high_u8(v51, v52)), vmull_high_u8(v50, v53));
        uint16x8_t v55 = vminq_u16((uint16x8_t)v99.val[1], v29);
        uint16x8_t v56 = vminq_u16(v54, v29);
        v99.val[0] = (int8x16_t)vrsraq_n_u16(v55, v55, 8uLL);
        uint16x8_t v57 = vrsraq_n_u16(v56, v56, 8uLL);
        *(uint8x8_t *)v99.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v99.val[0], 8uLL);
        *(uint8x8_t *)v99.val[1].i8 = vqrshrn_n_u16(v57, 8uLL);
        int8x16_t v17 = (int8x16_t)vminq_u8(vqrshrn_high_n_u16(*(uint8x8_t *)v99.val[0].i8, v57, 8uLL), (uint8x16_t)vqtbl2q_s8(v99, (int8x16_t)xmmword_1850CE040));
        int8x16_t v16 = vceqzq_s8(v48);
        *(int8x16_t *)((char *)v21 + v43) = vbslq_s8(v16, v47, vbslq_s8(vceqzq_s8(v49), v46, v17));
        v22 += v27;
        v45 -= 4;
        v43 += v28;
      }
      while (v45 > 3);
      unsigned int v21 = (_DWORD *)((char *)v21 + v43);
      int v19 = (_DWORD *)((char *)v19 + v43);
      unint64_t v18 = v18 - v44 + v45;
      goto LABEL_37;
    }
    if (v32) {
      break;
    }
    int64_t v33 = (unsigned __int8 *)&v22[v18];
    int64_t v34 = (int8x16_t *)v22;
    do
      uint64_t v35 = v34++;
    while (v34 <= (int8x16_t *)v33 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v35)) & 0x80) != 0);
    do
    {
      uint64_t v36 = v35;
      uint64_t v35 = (int8x16_t *)((char *)v35 + 4);
    }
    while (v35 <= (int8x16_t *)v33 && !v36->i32[0]);
    if (v36 < (int8x16_t *)v33)
    {
      while (!v36->i8[0])
      {
        uint64_t v36 = (int8x16_t *)((char *)v36 + 1);
        if (v36 >= (int8x16_t *)v33)
        {
          uint64_t v36 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    int64_t v37 = (char *)v36 - v22;
    int64_t v38 = ((char *)v36 - v22) * a6;
    v19 += v38;
    v21 += v38;
    v22 += v38;
    v18 -= v37;
LABEL_37:
    if (v18 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v58 = 0;
  while (1)
  {
    v16.i32[0] = v32;
    int8x16_t v59 = vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v60 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v58), a9);
    int8x16_t v61 = vorrq_s8(vbicq_s8(v26, vceqzq_s8(v59)), *(int8x16_t *)((char *)v21 + v58));
    uint16x8_t v62 = vminq_u16(vmull_u8(*(uint8x8_t *)v60.i8, *(uint8x8_t *)v59.i8), v29);
    uint16x8_t v63 = vminq_u16(vmull_high_u8(v60, (uint8x16_t)v59), v29);
    uint16x8_t v64 = vrsraq_n_u16(v63, v63, 8uLL);
    *(uint8x8_t *)v60.i8 = vqrshrn_n_u16(vrsraq_n_u16(v62, v62, 8uLL), 8uLL);
    *(uint8x8_t *)v17.i8 = vqrshrn_n_u16(v64, 8uLL);
    int8x16_t v65 = vqtbl2q_s8(*(int8x16x2_t *)(&v17 - 1), (int8x16_t)xmmword_1850CE040);
    int8x16_t v66 = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v60.i8, v64, 8uLL);
    int8x16_t v67 = vqtbl1q_s8(v61, (int8x16_t)xmmword_1850CE030);
    uint8x16_t v68 = vminq_u8((uint8x16_t)v66, (uint8x16_t)v65);
    uint8x16_t v69 = vminq_u8((uint8x16_t)v61, (uint8x16_t)v67);
    uint8x16_t v70 = (uint8x16_t)vmvnq_s8(v65);
    uint8x16_t v71 = (uint8x16_t)vmvnq_s8(v67);
    v100.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_u8(*(uint8x8_t *)v68.i8, *(uint8x8_t *)v67.i8), (uint16x8_t)vandq_s8((int8x16_t)vmull_u8(*(uint8x8_t *)v69.i8, *(uint8x8_t *)v65.i8), v30)), vmull_u8(*(uint8x8_t *)v69.i8, *(uint8x8_t *)v70.i8)), vmull_u8(*(uint8x8_t *)v68.i8, *(uint8x8_t *)v71.i8));
    uint16x8_t v72 = vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_high_u8(v68, (uint8x16_t)v67), (uint16x8_t)vandq_s8((int8x16_t)vmull_high_u8(v69, (uint8x16_t)v65), v30)), vmull_high_u8(v69, v70)), vmull_high_u8(v68, v71));
    uint16x8_t v73 = vminq_u16((uint16x8_t)v100.val[1], v29);
    uint16x8_t v74 = vminq_u16(v72, v29);
    v100.val[0] = (int8x16_t)vrsraq_n_u16(v73, v73, 8uLL);
    uint16x8_t v75 = vrsraq_n_u16(v74, v74, 8uLL);
    *(uint8x8_t *)v100.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v100.val[0], 8uLL);
    *(uint8x8_t *)v100.val[1].i8 = vqrshrn_n_u16(v75, 8uLL);
    int8x16_t v17 = (int8x16_t)vminq_u8(vqrshrn_high_n_u16(*(uint8x8_t *)v100.val[0].i8, v75, 8uLL), (uint8x16_t)vqtbl2q_s8(v100, (int8x16_t)xmmword_1850CE040));
    int8x16_t v16 = vbslq_s8(vceqzq_s8(v67), v66, v17);
    *(int8x16_t *)((char *)v21 + v58) = vbslq_s8(vceqzq_s8(v65), v61, v16);
    v22 += v27;
    v18 -= 4;
    if (v18 < 4) {
      break;
    }
    __int32 v32 = *(_DWORD *)v22;
    v58 += v28;
    if ((*(_DWORD *)v22 - 1) >= 0xFFFFFFFE)
    {
      int v19 = (_DWORD *)((char *)v19 + v58);
      unsigned int v21 = (_DWORD *)((char *)v21 + v58);
      goto LABEL_37;
    }
  }
  int v19 = (_DWORD *)((char *)v19 + v28 + v58);
  unsigned int v21 = (_DWORD *)((char *)v21 + v28 + v58);
LABEL_40:
  uint64_t v76 = v18 + a15;
  if (v76)
  {
    if (a7) {
      unsigned int v77 = 0;
    }
    else {
      unsigned int v77 = -1;
    }
    int8x8_t v78 = vdup_n_s8(v77);
    if (a8) {
      unsigned int v79 = 0;
    }
    else {
      unsigned int v79 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(v78, (int8x8_t)0xFF000000FFLL);
    int8x8_t v80 = vand_s8(vdup_n_s8(v79), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v81 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    v82.i64[0] = -65536;
    v82.i64[1] = -65536;
    do
    {
      a14.i32[0] = *v19;
      uint16x8_t v83 = vmovl_u8(a14);
      LOBYTE(v84) = v83.i8[0];
      BYTE1(v84) = v83.i8[2];
      BYTE2(v84) = v83.i8[4];
      HIBYTE(v84) = v83.i8[6];
      v83.i32[0] = *v21;
      uint16x8_t v85 = vmovl_u8(*(uint8x8_t *)v83.i8);
      LOBYTE(v86) = v85.i8[0];
      BYTE1(v86) = v85.i8[2];
      BYTE2(v86) = v85.i8[4];
      HIBYTE(v86) = v85.i8[6];
      v85.i8[7] = 0;
      v85.i8[0] = *v22;
      v85.i8[1] = *v22;
      v85.i8[2] = *v22;
      *(__int32 *)((char *)v85.i32 + 3) = *v22;
      int8x8_t v87 = vorr_s8(vbic_s8(v80, vceqz_s8(*(int8x8_t *)v85.i8)), (int8x8_t)v86);
      uint16x8_t v88 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v84, *(int8x8_t *)a9.i8), *(uint8x8_t *)v85.i8), v81);
      int8x16_t v89 = (int8x16_t)vrsraq_n_u16(v88, v88, 8uLL);
      int8x8_t v90 = (int8x8_t)vqrshrn_n_u16((uint16x8_t)v89, 8uLL);
      *(int8x8_t *)v89.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v90, (uint16x8_t)v89, 8uLL), (int8x8_t)0x404040400000000);
      *(int8x8_t *)v91.i8 = v87;
      v91.u64[1] = (unint64_t)v87;
      *(int8x8_t *)v91.i8 = vqtbl1_s8(v91, (int8x8_t)0x404040400000000);
      uint8x8_t v92 = vmin_u8((uint8x8_t)v90, *(uint8x8_t *)v89.i8);
      uint8x8_t v93 = vmin_u8((uint8x8_t)v87, *(uint8x8_t *)v91.i8);
      uint16x8_t v94 = vminq_u16(vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_u8(v92, *(uint8x8_t *)v91.i8), (uint16x8_t)vandq_s8((int8x16_t)vmull_u8(v93, *(uint8x8_t *)v89.i8), v82)), vmull_u8(v93, (uint8x8_t)vmvn_s8(*(int8x8_t *)v89.i8))), vmull_u8(v92, (uint8x8_t)vmvn_s8(*(int8x8_t *)v91.i8))), v81);
      uint16x8_t v95 = vrsraq_n_u16(v94, v94, 8uLL);
      uint8x8_t v96 = vqrshrn_n_u16(v95, 8uLL);
      *(int8x8_t *)v89.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v89.i8), v87, vbsl_s8(vceqz_s8(*(int8x8_t *)v91.i8), v90, (int8x8_t)vmin_u8(v96, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v96, v95, 8uLL), (int8x8_t)0x404040400000000))));
      a14 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v89, a9));
      *unsigned int v21 = a14.i32[0];
      float v97 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v97 >= v20) {
        uint64_t v98 = -(uint64_t)a5;
      }
      else {
        uint64_t v98 = 0;
      }
      int v19 = &v97[v98];
      v21 += a6;
      --v76;
    }
    while (v76);
  }
  _WORD *result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)21,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, double a13, uint8x8_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v19 = a16;
  unint64_t v20 = *result;
  unint64_t v21 = *a3;
  int8x16_t v22 = *a2;
  unsigned int v23 = *a4;
  if (a16 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v25.i64[0] = 0xFF000000FFLL;
  v25.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v24), v25);
  if (a8) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = -1;
  }
  int8x16_t v27 = vandq_s8(vdupq_n_s8(v26), v25);
  uint64_t v28 = 4 * a6;
  uint64_t v29 = 16 * a6;
  uint16x8_t v30 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a14.i32[1] = 67372036;
  v31.i64[0] = -1;
  v31.i64[1] = -1;
  while (1)
  {
    __int32 v32 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 == -1)
    {
      uint64_t v39 = (unsigned __int8 *)&v23[v19];
      int64_t v40 = (int8x16_t *)v23;
      do
        unint64_t v41 = v40++;
      while (v40 <= (int8x16_t *)v39 && (vminvq_u8((uint8x16_t)vceqq_s8(*v41, v31)) & 0x80) != 0);
      do
      {
        int8x16_t v42 = v41;
        unint64_t v41 = (int8x16_t *)((char *)v41 + 4);
      }
      while (v41 <= (int8x16_t *)v39 && v42->i32[0] == -1);
      if (v42 < (int8x16_t *)v39)
      {
        while (v42->u8[0] == 255)
        {
          int8x16_t v42 = (int8x16_t *)((char *)v42 + 1);
          if (v42 >= (int8x16_t *)v39)
          {
            int8x16_t v42 = (int8x16_t *)&v23[v19];
            break;
          }
        }
      }
      uint64_t v43 = 0;
      int64_t v44 = (char *)v42 - v23;
      unint64_t v45 = (char *)v42 - v23;
      do
      {
        int8x16_t v46 = vorrq_s8(*(int8x16_t *)((char *)v20 + v43), a9);
        int8x16_t v47 = vorrq_s8(*(int8x16_t *)((char *)v22 + v43), v27);
        int8x16_t v48 = vqtbl1q_s8(v46, (int8x16_t)xmmword_1850CE030);
        int8x16_t v49 = vqtbl1q_s8(v47, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v50 = vminq_u8((uint8x16_t)v46, (uint8x16_t)v48);
        uint8x16_t v51 = vminq_u8((uint8x16_t)v47, (uint8x16_t)v49);
        int8x16_t v52 = (int8x16_t)vcgeq_u8(vrhaddq_u8((uint8x16_t)v48, (uint8x16_t)0), v50);
        int8x16_t v53 = vzip1q_s8(v52, v52);
        uint16x8_t v54 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v51.i8);
        uint16x8_t v55 = vmull_high_u8(v50, v51);
        uint8x16_t v56 = vqsubq_u8((uint8x16_t)v49, v51);
        uint8x16_t v57 = vqsubq_u8((uint8x16_t)v48, v50);
        uint16x8_t v58 = vmull_u8(*(uint8x8_t *)v56.i8, *(uint8x8_t *)v57.i8);
        uint16x8_t v59 = vmull_high_u8(v56, v57);
        uint16x8_t v60 = (uint16x8_t)vbslq_s8(vzip2q_s8(v52, v52), (int8x16_t)vqaddq_u16(v55, v55), (int8x16_t)vqsubq_u16(vmull_high_u8((uint8x16_t)v49, (uint8x16_t)v48), vqaddq_u16(v59, v59)));
        uint16x8_t v61 = (uint16x8_t)vbslq_s8(v53, (int8x16_t)vqaddq_u16(v54, v54), (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v48.i8), vqaddq_u16(v58, v58)));
        uint8x16_t v62 = (uint8x16_t)vmvnq_s8(v48);
        uint16x8_t v63 = vmull_u8(*(uint8x8_t *)v51.i8, *(uint8x8_t *)v62.i8);
        uint16x8_t v64 = vqaddq_u16(v60, vmull_high_u8(v51, v62));
        uint8x16_t v65 = (uint8x16_t)vmvnq_s8(v49);
        uint16x8_t v66 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v65.i8);
        uint16x8_t v67 = vmull_high_u8(v50, v65);
        v127.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(v61, v63), v66);
        uint16x8_t v68 = vqaddq_u16(v64, v67);
        uint16x8_t v69 = vminq_u16((uint16x8_t)v127.val[1], v30);
        uint16x8_t v70 = vminq_u16(v68, v30);
        v127.val[0] = (int8x16_t)vrsraq_n_u16(v69, v69, 8uLL);
        uint16x8_t v71 = vrsraq_n_u16(v70, v70, 8uLL);
        *(uint8x8_t *)v127.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v127.val[0], 8uLL);
        *(uint8x8_t *)v127.val[1].i8 = vqrshrn_n_u16(v71, 8uLL);
        int8x16_t v18 = (int8x16_t)vminq_u8(vqrshrn_high_n_u16(*(uint8x8_t *)v127.val[0].i8, v71, 8uLL), (uint8x16_t)vqtbl2q_s8(v127, (int8x16_t)xmmword_1850CE040));
        int8x16_t v17 = vceqzq_s8(v49);
        int8x16_t v16 = vceqzq_s8(v48);
        *(int8x16_t *)((char *)v22 + v43) = vbslq_s8(v16, v47, vbslq_s8(v17, v46, v18));
        v23 += v28;
        v45 -= 4;
        v43 += v29;
      }
      while (v45 > 3);
      int8x16_t v22 = (_DWORD *)((char *)v22 + v43);
      unint64_t v20 = (_DWORD *)((char *)v20 + v43);
      unint64_t v19 = v19 - v44 + v45;
      goto LABEL_37;
    }
    if (v32) {
      break;
    }
    int64_t v33 = (unsigned __int8 *)&v23[v19];
    int64_t v34 = (int8x16_t *)v23;
    do
      uint64_t v35 = v34++;
    while (v34 <= (int8x16_t *)v33 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v35)) & 0x80) != 0);
    do
    {
      uint64_t v36 = v35;
      uint64_t v35 = (int8x16_t *)((char *)v35 + 4);
    }
    while (v35 <= (int8x16_t *)v33 && !v36->i32[0]);
    if (v36 < (int8x16_t *)v33)
    {
      while (!v36->i8[0])
      {
        uint64_t v36 = (int8x16_t *)((char *)v36 + 1);
        if (v36 >= (int8x16_t *)v33)
        {
          uint64_t v36 = (int8x16_t *)&v23[v19];
          break;
        }
      }
    }
    int64_t v37 = (char *)v36 - v23;
    int64_t v38 = ((char *)v36 - v23) * a6;
    v20 += v38;
    v22 += v38;
    v23 += v38;
    v19 -= v37;
LABEL_37:
    if (v19 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v72 = 0;
  while (1)
  {
    v16.i32[0] = v32;
    int8x16_t v73 = vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v74 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v20 + v72), a9);
    int8x16_t v75 = vorrq_s8(vbicq_s8(v27, vceqzq_s8(v73)), *(int8x16_t *)((char *)v22 + v72));
    uint16x8_t v76 = vminq_u16(vmull_u8(*(uint8x8_t *)v74.i8, *(uint8x8_t *)v73.i8), v30);
    uint16x8_t v77 = vminq_u16(vmull_high_u8(v74, (uint8x16_t)v73), v30);
    uint16x8_t v78 = vrsraq_n_u16(v77, v77, 8uLL);
    *(uint8x8_t *)v74.i8 = vqrshrn_n_u16(vrsraq_n_u16(v76, v76, 8uLL), 8uLL);
    *(uint8x8_t *)v18.i8 = vqrshrn_n_u16(v78, 8uLL);
    int8x16_t v79 = vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CE040);
    int8x16_t v17 = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v74.i8, v78, 8uLL);
    int8x16_t v80 = vqtbl1q_s8(v75, (int8x16_t)xmmword_1850CE030);
    uint8x16_t v81 = vminq_u8((uint8x16_t)v17, (uint8x16_t)v79);
    uint8x16_t v82 = vminq_u8((uint8x16_t)v75, (uint8x16_t)v80);
    int8x16_t v83 = (int8x16_t)vcgeq_u8(vrhaddq_u8((uint8x16_t)v79, (uint8x16_t)0), v81);
    int8x16_t v84 = vzip1q_s8(v83, v83);
    uint16x8_t v85 = vmull_u8(*(uint8x8_t *)v81.i8, *(uint8x8_t *)v82.i8);
    uint16x8_t v86 = vmull_high_u8(v81, v82);
    uint8x16_t v87 = vqsubq_u8((uint8x16_t)v80, v82);
    uint8x16_t v88 = vqsubq_u8((uint8x16_t)v79, v81);
    uint16x8_t v89 = vmull_u8(*(uint8x8_t *)v87.i8, *(uint8x8_t *)v88.i8);
    uint16x8_t v90 = vmull_high_u8(v87, v88);
    uint16x8_t v91 = (uint16x8_t)vbslq_s8(vzip2q_s8(v83, v83), (int8x16_t)vqaddq_u16(v86, v86), (int8x16_t)vqsubq_u16(vmull_high_u8((uint8x16_t)v80, (uint8x16_t)v79), vqaddq_u16(v90, v90)));
    uint16x8_t v92 = (uint16x8_t)vbslq_s8(v84, (int8x16_t)vqaddq_u16(v85, v85), (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v80.i8, *(uint8x8_t *)v79.i8), vqaddq_u16(v89, v89)));
    uint8x16_t v93 = (uint8x16_t)vmvnq_s8(v79);
    uint16x8_t v94 = vmull_u8(*(uint8x8_t *)v82.i8, *(uint8x8_t *)v93.i8);
    uint16x8_t v95 = vqaddq_u16(v91, vmull_high_u8(v82, v93));
    uint8x16_t v96 = (uint8x16_t)vmvnq_s8(v80);
    uint16x8_t v97 = vmull_u8(*(uint8x8_t *)v81.i8, *(uint8x8_t *)v96.i8);
    uint16x8_t v98 = vmull_high_u8(v81, v96);
    v128.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(v92, v94), v97);
    uint16x8_t v99 = vqaddq_u16(v95, v98);
    uint16x8_t v100 = vminq_u16((uint16x8_t)v128.val[1], v30);
    uint16x8_t v101 = vminq_u16(v99, v30);
    v128.val[0] = (int8x16_t)vrsraq_n_u16(v100, v100, 8uLL);
    uint16x8_t v102 = vrsraq_n_u16(v101, v101, 8uLL);
    *(uint8x8_t *)v128.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v128.val[0], 8uLL);
    *(uint8x8_t *)v128.val[1].i8 = vqrshrn_n_u16(v102, 8uLL);
    int8x16_t v18 = (int8x16_t)vminq_u8(vqrshrn_high_n_u16(*(uint8x8_t *)v128.val[0].i8, v102, 8uLL), (uint8x16_t)vqtbl2q_s8(v128, (int8x16_t)xmmword_1850CE040));
    int8x16_t v16 = vbslq_s8(vceqzq_s8(v80), v17, v18);
    *(int8x16_t *)((char *)v22 + v72) = vbslq_s8(vceqzq_s8(v79), v75, v16);
    v23 += v28;
    v19 -= 4;
    if (v19 < 4) {
      break;
    }
    __int32 v32 = *(_DWORD *)v23;
    v72 += v29;
    if ((*(_DWORD *)v23 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v20 = (_DWORD *)((char *)v20 + v72);
      int8x16_t v22 = (_DWORD *)((char *)v22 + v72);
      goto LABEL_37;
    }
  }
  unint64_t v20 = (_DWORD *)((char *)v20 + v29 + v72);
  int8x16_t v22 = (_DWORD *)((char *)v22 + v29 + v72);
LABEL_40:
  uint64_t v103 = v19 + a15;
  if (v103)
  {
    if (a7) {
      unsigned int v104 = 0;
    }
    else {
      unsigned int v104 = -1;
    }
    int8x8_t v105 = vdup_n_s8(v104);
    if (a8) {
      unsigned int v106 = 0;
    }
    else {
      unsigned int v106 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(v105, (int8x8_t)0xFF000000FFLL);
    int8x8_t v107 = vand_s8(vdup_n_s8(v106), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v108 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a14.i32[0] = *v20;
      uint16x8_t v109 = vmovl_u8(a14);
      LOBYTE(v110) = v109.i8[0];
      BYTE1(v110) = v109.i8[2];
      BYTE2(v110) = v109.i8[4];
      HIBYTE(v110) = v109.i8[6];
      v109.i32[0] = *v22;
      uint16x8_t v111 = vmovl_u8(*(uint8x8_t *)v109.i8);
      LOBYTE(v112) = v111.i8[0];
      BYTE1(v112) = v111.i8[2];
      BYTE2(v112) = v111.i8[4];
      HIBYTE(v112) = v111.i8[6];
      v111.i8[7] = 0;
      v111.i8[0] = *v23;
      v111.i8[1] = *v23;
      v111.i8[2] = *v23;
      *(__int32 *)((char *)v111.i32 + 3) = *v23;
      int8x8_t v113 = vorr_s8(vbic_s8(v107, vceqz_s8(*(int8x8_t *)v111.i8)), (int8x8_t)v112);
      uint16x8_t v114 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v110, *(int8x8_t *)a9.i8), *(uint8x8_t *)v111.i8), v108);
      int8x16_t v115 = (int8x16_t)vrsraq_n_u16(v114, v114, 8uLL);
      int8x8_t v116 = (int8x8_t)vqrshrn_n_u16((uint16x8_t)v115, 8uLL);
      *(int8x8_t *)v115.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v116, (uint16x8_t)v115, 8uLL), (int8x8_t)0x404040400000000);
      *(int8x8_t *)v117.i8 = v113;
      v117.u64[1] = (unint64_t)v113;
      *(int8x8_t *)v117.i8 = vqtbl1_s8(v117, (int8x8_t)0x404040400000000);
      uint8x8_t v118 = vmin_u8((uint8x8_t)v116, *(uint8x8_t *)v115.i8);
      uint8x8_t v119 = vmin_u8((uint8x8_t)v113, *(uint8x8_t *)v117.i8);
      *(uint8x8_t *)v17.i8 = vcge_u8(vrhadd_u8(*(uint8x8_t *)v115.i8, 0), v118);
      uint16x8_t v120 = vmull_u8(v118, v119);
      uint16x8_t v121 = vmull_u8(vqsub_u8(*(uint8x8_t *)v117.i8, v119), vqsub_u8(*(uint8x8_t *)v115.i8, v118));
      uint16x8_t v122 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vbslq_s8(vzip1q_s8(v17, v17), (int8x16_t)vqaddq_u16(v120, v120), (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v117.i8, *(uint8x8_t *)v115.i8), vqaddq_u16(v121, v121))), vmull_u8(v119, (uint8x8_t)vmvn_s8(*(int8x8_t *)v115.i8))), vmull_u8(v118, (uint8x8_t)vmvn_s8(*(int8x8_t *)v117.i8))), v108);
      uint16x8_t v123 = vrsraq_n_u16(v122, v122, 8uLL);
      uint8x8_t v124 = vqrshrn_n_u16(v123, 8uLL);
      int8x16_t v17 = (int8x16_t)vqrshrn_high_n_u16(v124, v123, 8uLL);
      *(int8x8_t *)v115.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v115.i8), v113, vbsl_s8(vceqz_s8(*(int8x8_t *)v117.i8), v116, (int8x8_t)vmin_u8(v124, (uint8x8_t)vqtbl1_s8(v17, (int8x8_t)0x404040400000000))));
      a14 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v115, a9));
      *int8x16_t v22 = a14.i32[0];
      int v125 = &v20[a6];
      v23 += a6;
      if ((unint64_t)v125 >= v21) {
        uint64_t v126 = -(uint64_t)a5;
      }
      else {
        uint64_t v126 = 0;
      }
      unint64_t v20 = &v125[v126];
      v22 += a6;
      --v103;
    }
    while (v103);
  }
  _WORD *result = v20;
  *a3 = v21;
  *a2 = v22;
  *a4 = v23;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)20,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, uint8x8_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v18 = a15;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  unint64_t v21 = *a2;
  int8x16_t v22 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFF000000FFLL;
  v24.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v23), v24);
  if (a8) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = vandq_s8(vdupq_n_s8(v25), v24);
  uint64_t v27 = 4 * a6;
  uint64_t v28 = 16 * a6;
  uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a13.i32[1] = 67372036;
  v30.i64[0] = -1;
  v30.i64[1] = -1;
  while (1)
  {
    __int32 v31 = *(_DWORD *)v22;
    if (*(_DWORD *)v22 == -1)
    {
      int64_t v38 = (unsigned __int8 *)&v22[v18];
      uint64_t v39 = (int8x16_t *)v22;
      do
        int64_t v40 = v39++;
      while (v39 <= (int8x16_t *)v38 && (vminvq_u8((uint8x16_t)vceqq_s8(*v40, v30)) & 0x80) != 0);
      do
      {
        unint64_t v41 = v40;
        int64_t v40 = (int8x16_t *)((char *)v40 + 4);
      }
      while (v40 <= (int8x16_t *)v38 && v41->i32[0] == -1);
      if (v41 < (int8x16_t *)v38)
      {
        while (v41->u8[0] == 255)
        {
          unint64_t v41 = (int8x16_t *)((char *)v41 + 1);
          if (v41 >= (int8x16_t *)v38)
          {
            unint64_t v41 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      uint64_t v42 = 0;
      int64_t v43 = (char *)v41 - v22;
      unint64_t v44 = (char *)v41 - v22;
      do
      {
        int8x16_t v45 = vorrq_s8(*(int8x16_t *)((char *)v19 + v42), a9);
        int8x16_t v46 = vorrq_s8(*(int8x16_t *)((char *)v21 + v42), v26);
        int8x16_t v47 = vqtbl1q_s8(v45, (int8x16_t)xmmword_1850CE030);
        int8x16_t v48 = vqtbl1q_s8(v46, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v49 = vminq_u8((uint8x16_t)v45, (uint8x16_t)v47);
        uint8x16_t v50 = vminq_u8((uint8x16_t)v46, (uint8x16_t)v48);
        uint16x8_t v51 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v50.i8);
        uint16x8_t v52 = vmull_high_u8(v50, v50);
        int8x8_t v53 = (int8x8_t)vextq_s8(v48, v48, 8uLL).u64[0];
        *(int8x8_t *)v51.i8 = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v51.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v48.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v51)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v48.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))));
        int16x8_t v54 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v52.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v53, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v52)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v53, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))))));
        uint16x8_t v55 = vmull_u8(*(uint8x8_t *)v51.i8, *(uint8x8_t *)v47.i8);
        uint16x8_t v56 = vmull_u8((uint8x8_t)vqmovun_s16(v54), (uint8x8_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL));
        uint8x16_t v57 = vqsubq_u8(v50, (uint8x16_t)vqmovun_high_s16(*(int8x8_t *)v51.i8, v54));
        uint16x8_t v58 = vmull_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v49.i8);
        uint16x8_t v59 = vmull_high_u8(v57, v49);
        uint16x8_t v60 = vqaddq_u16(v55, vqaddq_u16(v58, v58));
        uint16x8_t v61 = vqaddq_u16(v56, vqaddq_u16(v59, v59));
        uint8x16_t v62 = (uint8x16_t)vmvnq_s8(v47);
        uint16x8_t v63 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v62.i8);
        uint16x8_t v64 = vmull_high_u8(v50, v62);
        uint16x8_t v65 = vqaddq_u16(v60, v63);
        uint16x8_t v66 = vqaddq_u16(v61, v64);
        uint8x16_t v67 = (uint8x16_t)vmvnq_s8(v48);
        uint16x8_t v68 = vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v67.i8);
        uint16x8_t v69 = vmull_high_u8(v49, v67);
        v135.val[1] = (int8x16_t)vqaddq_u16(v65, v68);
        uint16x8_t v70 = vqaddq_u16(v66, v69);
        uint16x8_t v71 = vminq_u16((uint16x8_t)v135.val[1], v29);
        uint16x8_t v72 = vminq_u16(v70, v29);
        v135.val[0] = (int8x16_t)vrsraq_n_u16(v71, v71, 8uLL);
        uint16x8_t v73 = vrsraq_n_u16(v72, v72, 8uLL);
        *(uint8x8_t *)v135.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v135.val[0], 8uLL);
        *(uint8x8_t *)v135.val[1].i8 = vqrshrn_n_u16(v73, 8uLL);
        uint8x16_t v74 = (uint8x16_t)vqtbl2q_s8(v135, (int8x16_t)xmmword_1850CE040);
        uint8x16_t v17 = vqrshrn_high_n_u16(*(uint8x8_t *)v135.val[0].i8, v73, 8uLL);
        int8x16_t v16 = (int8x16_t)vminq_u8(v17, v74);
        int8x16_t v15 = vceqzq_s8(v47);
        *(int8x16_t *)((char *)v21 + v42) = vbslq_s8(v15, v46, vbslq_s8(vceqzq_s8(v48), v45, v16));
        v22 += v27;
        v44 -= 4;
        v42 += v28;
      }
      while (v44 > 3);
      unint64_t v21 = (_DWORD *)((char *)v21 + v42);
      unint64_t v19 = (_DWORD *)((char *)v19 + v42);
      unint64_t v18 = v18 - v43 + v44;
      goto LABEL_37;
    }
    if (v31) {
      break;
    }
    __int32 v32 = (unsigned __int8 *)&v22[v18];
    int64_t v33 = (int8x16_t *)v22;
    do
      int64_t v34 = v33++;
    while (v33 <= (int8x16_t *)v32 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v34)) & 0x80) != 0);
    do
    {
      uint64_t v35 = v34;
      int64_t v34 = (int8x16_t *)((char *)v34 + 4);
    }
    while (v34 <= (int8x16_t *)v32 && !v35->i32[0]);
    if (v35 < (int8x16_t *)v32)
    {
      while (!v35->i8[0])
      {
        uint64_t v35 = (int8x16_t *)((char *)v35 + 1);
        if (v35 >= (int8x16_t *)v32)
        {
          uint64_t v35 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    int64_t v36 = (char *)v35 - v22;
    int64_t v37 = ((char *)v35 - v22) * a6;
    v19 += v37;
    v21 += v37;
    v22 += v37;
    v18 -= v36;
LABEL_37:
    if (v18 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v75 = 0;
  while (1)
  {
    v15.i32[0] = v31;
    int8x16_t v76 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v77 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v75), a9);
    int8x16_t v78 = vorrq_s8(vbicq_s8(v26, vceqzq_s8(v76)), *(int8x16_t *)((char *)v21 + v75));
    uint16x8_t v79 = vminq_u16(vmull_u8(*(uint8x8_t *)v77.i8, *(uint8x8_t *)v76.i8), v29);
    uint16x8_t v80 = vminq_u16(vmull_high_u8(v77, (uint8x16_t)v76), v29);
    uint16x8_t v81 = vrsraq_n_u16(v80, v80, 8uLL);
    *(uint8x8_t *)v16.i8 = vqrshrn_n_u16(vrsraq_n_u16(v79, v79, 8uLL), 8uLL);
    *(uint8x8_t *)v17.i8 = vqrshrn_n_u16(v81, 8uLL);
    int8x16_t v82 = vqtbl2q_s8(*(int8x16x2_t *)v16.i8, (int8x16_t)xmmword_1850CE040);
    int8x16_t v83 = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v16.i8, v81, 8uLL);
    int8x16_t v84 = vqtbl1q_s8(v78, (int8x16_t)xmmword_1850CE030);
    uint8x16_t v85 = vminq_u8((uint8x16_t)v83, (uint8x16_t)v82);
    uint8x16_t v86 = vminq_u8((uint8x16_t)v78, (uint8x16_t)v84);
    uint16x8_t v87 = vmull_u8(*(uint8x8_t *)v86.i8, *(uint8x8_t *)v86.i8);
    uint16x8_t v88 = vmull_high_u8(v86, v86);
    int8x8_t v89 = (int8x8_t)vextq_s8(v84, v84, 8uLL).u64[0];
    *(int8x8_t *)v87.i8 = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v87.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v84.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v87)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v84.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))));
    int16x8_t v90 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v88.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v89, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v88)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v89, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))))));
    uint16x8_t v91 = vmull_u8(*(uint8x8_t *)v87.i8, *(uint8x8_t *)v82.i8);
    uint16x8_t v92 = vmull_u8((uint8x8_t)vqmovun_s16(v90), (uint8x8_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL));
    uint8x16_t v93 = vqsubq_u8(v86, (uint8x16_t)vqmovun_high_s16(*(int8x8_t *)v87.i8, v90));
    uint16x8_t v94 = vmull_u8(*(uint8x8_t *)v93.i8, *(uint8x8_t *)v85.i8);
    uint16x8_t v95 = vmull_high_u8(v93, v85);
    uint16x8_t v96 = vqaddq_u16(v91, vqaddq_u16(v94, v94));
    uint16x8_t v97 = vqaddq_u16(v92, vqaddq_u16(v95, v95));
    uint8x16_t v98 = (uint8x16_t)vmvnq_s8(v82);
    uint16x8_t v99 = vmull_u8(*(uint8x8_t *)v86.i8, *(uint8x8_t *)v98.i8);
    uint16x8_t v100 = vmull_high_u8(v86, v98);
    uint16x8_t v101 = vqaddq_u16(v96, v99);
    uint16x8_t v102 = vqaddq_u16(v97, v100);
    uint8x16_t v103 = (uint8x16_t)vmvnq_s8(v84);
    uint16x8_t v104 = vmull_u8(*(uint8x8_t *)v85.i8, *(uint8x8_t *)v103.i8);
    uint16x8_t v105 = vmull_high_u8(v85, v103);
    v136.val[1] = (int8x16_t)vqaddq_u16(v101, v104);
    uint16x8_t v106 = vqaddq_u16(v102, v105);
    uint16x8_t v107 = vminq_u16((uint16x8_t)v136.val[1], v29);
    uint16x8_t v108 = vminq_u16(v106, v29);
    v136.val[0] = (int8x16_t)vrsraq_n_u16(v107, v107, 8uLL);
    uint16x8_t v109 = vrsraq_n_u16(v108, v108, 8uLL);
    *(uint8x8_t *)v136.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v136.val[0], 8uLL);
    *(uint8x8_t *)v136.val[1].i8 = vqrshrn_n_u16(v109, 8uLL);
    uint8x16_t v110 = (uint8x16_t)vqtbl2q_s8(v136, (int8x16_t)xmmword_1850CE040);
    uint8x16_t v17 = vqrshrn_high_n_u16(*(uint8x8_t *)v136.val[0].i8, v109, 8uLL);
    int8x16_t v16 = (int8x16_t)vminq_u8(v17, v110);
    int8x16_t v15 = vbslq_s8(vceqzq_s8(v84), v83, v16);
    *(int8x16_t *)((char *)v21 + v75) = vbslq_s8(vceqzq_s8(v82), v78, v15);
    v22 += v27;
    v18 -= 4;
    if (v18 < 4) {
      break;
    }
    __int32 v31 = *(_DWORD *)v22;
    v75 += v28;
    if ((*(_DWORD *)v22 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v19 = (_DWORD *)((char *)v19 + v75);
      unint64_t v21 = (_DWORD *)((char *)v21 + v75);
      goto LABEL_37;
    }
  }
  unint64_t v19 = (_DWORD *)((char *)v19 + v28 + v75);
  unint64_t v21 = (_DWORD *)((char *)v21 + v28 + v75);
LABEL_40:
  uint64_t v111 = v18 + a14;
  if (v111)
  {
    if (a7) {
      unsigned int v112 = 0;
    }
    else {
      unsigned int v112 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v112), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v113 = 0;
    }
    else {
      unsigned int v113 = -1;
    }
    int8x8_t v114 = vand_s8(vdup_n_s8(v113), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v115 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v19;
      uint16x8_t v116 = vmovl_u8(a13);
      LOBYTE(v117) = v116.i8[0];
      BYTE1(v117) = v116.i8[2];
      BYTE2(v117) = v116.i8[4];
      HIBYTE(v117) = v116.i8[6];
      v116.i32[0] = *v21;
      int8x16_t v118 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v116.i8);
      LOBYTE(v119) = v118.i8[0];
      BYTE1(v119) = v118.i8[2];
      BYTE2(v119) = v118.i8[4];
      HIBYTE(v119) = v118.i8[6];
      v120.i8[7] = 0;
      v120.i8[0] = *v22;
      v120.i8[1] = *v22;
      v120.i8[2] = *v22;
      *(__int32 *)((char *)v120.i32 + 3) = *v22;
      *(int8x8_t *)v118.i8 = vorr_s8(vbic_s8(v114, vceqz_s8(v120)), (int8x8_t)v119);
      uint16x8_t v121 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v117, *(int8x8_t *)a9.i8), (uint8x8_t)v120), v115);
      uint16x8_t v122 = vrsraq_n_u16(v121, v121, 8uLL);
      int8x8_t v123 = (int8x8_t)vqrshrn_n_u16(v122, 8uLL);
      *(int8x8_t *)v122.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v123, v122, 8uLL), (int8x8_t)0x404040400000000);
      v124.i64[0] = v118.i64[0];
      v124.i64[1] = v118.i64[0];
      *(int8x8_t *)v124.i8 = vqtbl1_s8(v124, (int8x8_t)0x404040400000000);
      uint8x8_t v125 = vmin_u8((uint8x8_t)v123, *(uint8x8_t *)v122.i8);
      uint8x8_t v126 = vmin_u8(*(uint8x8_t *)v118.i8, *(uint8x8_t *)v124.i8);
      uint16x8_t v127 = vmull_u8(v126, v126);
      *(int8x8_t *)v127.i8 = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v127.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v118.u8[0]) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v127)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v118.u8[4]) & 0xFF00FF00FF00FFLL)))))));
      uint16x8_t v128 = vmull_u8(*(uint8x8_t *)v127.i8, *(uint8x8_t *)v122.i8);
      uint16x8_t v129 = vmull_u8(vqsub_u8(v126, *(uint8x8_t *)v127.i8), v125);
      uint16x8_t v130 = vminq_u16(vqaddq_u16(vqaddq_u16(vqaddq_u16(v128, vqaddq_u16(v129, v129)), vmull_u8(v126, (uint8x8_t)vmvn_s8(*(int8x8_t *)v122.i8))), vmull_u8(v125, (uint8x8_t)vmvn_s8(*(int8x8_t *)v124.i8))), v115);
      uint16x8_t v131 = vrsraq_n_u16(v130, v130, 8uLL);
      uint8x8_t v132 = vqrshrn_n_u16(v131, 8uLL);
      *(int8x8_t *)v118.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v122.i8), *(int8x8_t *)v118.i8, vbsl_s8(vceqz_s8(*(int8x8_t *)v124.i8), v123, (int8x8_t)vmin_u8(v132, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v132, v131, 8uLL), (int8x8_t)0x404040400000000))));
      a13 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v118, a9));
      *unint64_t v21 = a13.i32[0];
      int v133 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v133 >= v20) {
        uint64_t v134 = -(uint64_t)a5;
      }
      else {
        uint64_t v134 = 0;
      }
      unint64_t v19 = &v133[v134];
      v21 += a6;
      --v111;
    }
    while (v111);
  }
  _WORD *result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)19,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, double a13, int8x16_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v19 = a16;
  unint64_t v20 = *result;
  unint64_t v21 = *a3;
  int8x16_t v22 = *a2;
  unsigned int v23 = *a4;
  if (a16 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v25.i64[0] = 0xFF000000FFLL;
  v25.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v24), v25);
  if (a8) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = -1;
  }
  int8x16_t v27 = vandq_s8(vdupq_n_s8(v26), v25);
  uint64_t v28 = 4 * a6;
  uint64_t v29 = 16 * a6;
  float32x4_t v30 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  a14.i64[0] = -1;
  a14.i64[1] = -1;
  while (1)
  {
    __int32 v31 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 == -1)
    {
      int64_t v38 = (unsigned __int8 *)&v23[v19];
      uint64_t v39 = (int8x16_t *)v23;
      do
        int64_t v40 = v39++;
      while (v39 <= (int8x16_t *)v38 && (vminvq_u8((uint8x16_t)vceqq_s8(*v40, a14)) & 0x80) != 0);
      do
      {
        unint64_t v41 = v40;
        int64_t v40 = (int8x16_t *)((char *)v40 + 4);
      }
      while (v40 <= (int8x16_t *)v38 && v41->i32[0] == -1);
      if (v41 < (int8x16_t *)v38)
      {
        while (v41->u8[0] == 255)
        {
          unint64_t v41 = (int8x16_t *)((char *)v41 + 1);
          if (v41 >= (int8x16_t *)v38)
          {
            unint64_t v41 = (int8x16_t *)&v23[v19];
            break;
          }
        }
      }
      uint64_t v42 = 0;
      int64_t v43 = (char *)v41 - v23;
      unint64_t v44 = (char *)v41 - v23;
      do
      {
        int8x16_t v45 = vorrq_s8(*(int8x16_t *)((char *)v20 + v42), a9);
        int8x16_t v46 = vorrq_s8(*(int8x16_t *)((char *)v22 + v42), v27);
        int8x16_t v47 = vqtbl1q_s8(v45, (int8x16_t)xmmword_1850CE030);
        int8x16_t v48 = vqtbl1q_s8(v46, (int8x16_t)xmmword_1850CE030);
        int8x16_t v49 = (int8x16_t)vminq_u8((uint8x16_t)v45, (uint8x16_t)v47);
        uint8x16_t v50 = vminq_u8((uint8x16_t)v46, (uint8x16_t)v48);
        int8x16_t v51 = (int8x16_t)vqsubq_u8((uint8x16_t)v48, v50);
        float32x4_t v52 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
        float32x4_t v53 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v51.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
        int8x8_t v54 = (int8x8_t)vextq_s8(v51, v51, 8uLL).u64[0];
        float32x4_t v55 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v54, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
        float32x4_t v56 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v54, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
        uint16x8_t v57 = vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v47.i8);
        uint16x8_t v58 = vmull_high_u8((uint8x16_t)v47, (uint8x16_t)v47);
        int8x8_t v59 = (int8x8_t)vextq_s8(v49, v49, 8uLL).u64[0];
        uint64_t v60 = *(void *)&vzip2_s8(*(int8x8_t *)v49.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
        uint64_t v61 = *(void *)&vzip1_s8(*(int8x8_t *)v49.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
        uint16x8_t v62 = vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v48.i8);
        uint16x8_t v63 = vmull_high_u8((uint8x16_t)v47, (uint8x16_t)v48);
        uint8x16_t v64 = (uint8x16_t)vmvnq_s8(v47);
        uint16x8_t v65 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v64.i8);
        uint16x8_t v66 = vmull_high_u8(v50, v64);
        uint8x16_t v67 = (uint8x16_t)vmvnq_s8(v48);
        uint16x8_t v68 = vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v67.i8);
        uint16x8_t v69 = vmull_high_u8((uint8x16_t)v49, v67);
        int32x4_t v18 = vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v65)), vcvtq_f32_u32(vmovl_high_u16(v68))), vcvtq_f32_u32(vmovl_high_u16(v62))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v53, vcvtq_f32_u32(vmovl_high_u16(v57))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v60))), (int8x16_t)vceqzq_f32(v53))), v30));
        int16x8_t v70 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v65.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v68.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v62.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v52, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v57.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v61))), (int8x16_t)vceqzq_f32(v52))), v30))), v18);
        *(int8x8_t *)v70.i8 = vqmovun_s16(v70);
        int16x8_t v71 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v66.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v69.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v63.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v55, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v58.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v59, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))), (int8x16_t)vceqzq_f32(v55))), v30))), vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(
                        vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v66)), vcvtq_f32_u32(vmovl_high_u16(v69))),
                        vcvtq_f32_u32(vmovl_high_u16(v63))),
                      (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v56, vcvtq_f32_u32(vmovl_high_u16(v58))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v59, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))), (int8x16_t)vceqzq_f32(v56))), v30)));
        *(int8x8_t *)v18.i8 = vqmovun_s16(v71);
        int8x16_t v17 = (int8x16_t)vminq_u8((uint8x16_t)vqmovun_high_s16(*(int8x8_t *)v70.i8, v71), (uint8x16_t)vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CE040));
        int8x16_t v16 = vceqzq_s8(v47);
        *(int8x16_t *)((char *)v22 + v42) = vbslq_s8(v16, v46, vbslq_s8(vceqzq_s8(v48), v45, v17));
        v23 += v28;
        v44 -= 4;
        v42 += v29;
      }
      while (v44 > 3);
      int8x16_t v22 = (_DWORD *)((char *)v22 + v42);
      unint64_t v20 = (unsigned __int32 *)((char *)v20 + v42);
      unint64_t v19 = v19 - v43 + v44;
      goto LABEL_37;
    }
    if (v31) {
      break;
    }
    __int32 v32 = (unsigned __int8 *)&v23[v19];
    int64_t v33 = (int8x16_t *)v23;
    do
      int64_t v34 = v33++;
    while (v33 <= (int8x16_t *)v32 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v34)) & 0x80) != 0);
    do
    {
      uint64_t v35 = v34;
      int64_t v34 = (int8x16_t *)((char *)v34 + 4);
    }
    while (v34 <= (int8x16_t *)v32 && !v35->i32[0]);
    if (v35 < (int8x16_t *)v32)
    {
      while (!v35->i8[0])
      {
        uint64_t v35 = (int8x16_t *)((char *)v35 + 1);
        if (v35 >= (int8x16_t *)v32)
        {
          uint64_t v35 = (int8x16_t *)&v23[v19];
          break;
        }
      }
    }
    int64_t v36 = (char *)v35 - v23;
    int64_t v37 = ((char *)v35 - v23) * a6;
    v20 += v37;
    v22 += v37;
    v23 += v37;
    v19 -= v36;
LABEL_37:
    if (v19 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v72 = 0;
  while (1)
  {
    v16.i32[0] = v31;
    int8x16_t v73 = vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v74 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v20 + v72), a9);
    int8x16_t v75 = vorrq_s8(vbicq_s8(v27, vceqzq_s8(v73)), *(int8x16_t *)((char *)v22 + v72));
    uint16x8_t v76 = vmull_u8(*(uint8x8_t *)v74.i8, *(uint8x8_t *)v73.i8);
    uint16x8_t v77 = vmull_high_u8(v74, (uint8x16_t)v73);
    uint16x8_t v78 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    uint16x8_t v79 = vminq_u16(v76, v78);
    uint16x8_t v80 = vminq_u16(v77, v78);
    uint16x8_t v81 = vrsraq_n_u16(v80, v80, 8uLL);
    *(uint8x8_t *)v17.i8 = vqrshrn_n_u16(vrsraq_n_u16(v79, v79, 8uLL), 8uLL);
    *(uint8x8_t *)v18.i8 = vqrshrn_n_u16(v81, 8uLL);
    int8x16_t v82 = vqtbl2q_s8(*(int8x16x2_t *)v17.i8, (int8x16_t)xmmword_1850CE040);
    int8x16_t v83 = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v17.i8, v81, 8uLL);
    int8x16_t v84 = vqtbl1q_s8(v75, (int8x16_t)xmmword_1850CE030);
    int8x16_t v85 = (int8x16_t)vminq_u8((uint8x16_t)v83, (uint8x16_t)v82);
    uint8x16_t v86 = vminq_u8((uint8x16_t)v75, (uint8x16_t)v84);
    int8x16_t v87 = (int8x16_t)vqsubq_u8((uint8x16_t)v84, v86);
    float32x4_t v88 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v87.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
    *(int8x8_t *)v18.i8 = vzip2_s8(*(int8x8_t *)v87.i8, *(int8x8_t *)a9.i8);
    v18.i32[0] &= 0xFF00FFu;
    v18.i16[2] = v18.u8[4];
    v18.i16[3] = v18.u8[6];
    float32x4_t v89 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v18.i8));
    int8x8_t v90 = (int8x8_t)vextq_s8(v87, v87, 8uLL).u64[0];
    float32x4_t v91 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v90, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
    float32x4_t v92 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v90, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
    uint16x8_t v93 = vmull_u8(*(uint8x8_t *)v82.i8, *(uint8x8_t *)v82.i8);
    uint16x8_t v94 = vmull_high_u8((uint8x16_t)v82, (uint8x16_t)v82);
    int8x8_t v95 = (int8x8_t)vextq_s8(v85, v85, 8uLL).u64[0];
    uint64_t v96 = *(void *)&vzip2_s8(*(int8x8_t *)v85.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
    uint64_t v97 = *(void *)&vzip1_s8(*(int8x8_t *)v85.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
    uint16x8_t v98 = vmull_u8(*(uint8x8_t *)v82.i8, *(uint8x8_t *)v84.i8);
    uint16x8_t v99 = vmull_high_u8((uint8x16_t)v82, (uint8x16_t)v84);
    uint8x16_t v100 = (uint8x16_t)vmvnq_s8(v82);
    uint16x8_t v101 = vmull_u8(*(uint8x8_t *)v86.i8, *(uint8x8_t *)v100.i8);
    uint16x8_t v102 = vmull_high_u8(v86, v100);
    uint8x16_t v103 = (uint8x16_t)vmvnq_s8(v84);
    uint16x8_t v104 = vmull_u8(*(uint8x8_t *)v85.i8, *(uint8x8_t *)v103.i8);
    uint16x8_t v105 = vmull_high_u8((uint8x16_t)v85, v103);
    int32x4_t v18 = vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v101)), vcvtq_f32_u32(vmovl_high_u16(v104))), vcvtq_f32_u32(vmovl_high_u16(v98))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v89, vcvtq_f32_u32(vmovl_high_u16(v93))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v96))), (int8x16_t)vceqzq_f32(v89))), v30));
    int16x8_t v106 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v101.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v104.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v98.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v88, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v93.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v97))), (int8x16_t)vceqzq_f32(v88))), v30))), v18);
    *(int8x8_t *)v106.i8 = vqmovun_s16(v106);
    int16x8_t v107 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v102.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v105.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v99.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v91, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v94.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v95, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))), (int8x16_t)vceqzq_f32(v91))), v30))), vcvtnq_s32_f32(vmulq_f32(
                 vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v102)), vcvtq_f32_u32(vmovl_high_u16(v105))), vcvtq_f32_u32(vmovl_high_u16(v99))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v92, vcvtq_f32_u32(vmovl_high_u16(v94))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v95, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))), (int8x16_t)vceqzq_f32(v92))), v30)));
    *(int8x8_t *)v18.i8 = vqmovun_s16(v107);
    int8x16_t v17 = (int8x16_t)vminq_u8((uint8x16_t)vqmovun_high_s16(*(int8x8_t *)v106.i8, v107), (uint8x16_t)vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CE040));
    int8x16_t v16 = vbslq_s8(vceqzq_s8(v84), v83, v17);
    *(int8x16_t *)((char *)v22 + v72) = vbslq_s8(vceqzq_s8(v82), v75, v16);
    v23 += v28;
    v19 -= 4;
    if (v19 < 4) {
      break;
    }
    __int32 v31 = *(_DWORD *)v23;
    v72 += v29;
    if ((*(_DWORD *)v23 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v20 = (unsigned __int32 *)((char *)v20 + v72);
      int8x16_t v22 = (_DWORD *)((char *)v22 + v72);
      goto LABEL_37;
    }
  }
  unint64_t v20 = (unsigned __int32 *)((char *)v20 + v29 + v72);
  int8x16_t v22 = (_DWORD *)((char *)v22 + v29 + v72);
LABEL_40:
  uint64_t v108 = v19 + a15;
  if (v108)
  {
    if (a7) {
      unsigned int v109 = 0;
    }
    else {
      unsigned int v109 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v109), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v110 = 0;
    }
    else {
      unsigned int v110 = -1;
    }
    int8x8_t v111 = vand_s8(vdup_n_s8(v110), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v112 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    float32x4_t v113 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      a14.i32[0] = *v20;
      uint16x8_t v114 = vmovl_u8(*(uint8x8_t *)a14.i8);
      LOBYTE(v115) = v114.i8[0];
      BYTE1(v115) = v114.i8[2];
      BYTE2(v115) = v114.i8[4];
      HIBYTE(v115) = v114.i8[6];
      v114.i32[0] = *v22;
      a14 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v114.i8);
      LOBYTE(v116) = a14.i8[0];
      BYTE1(v116) = a14.i8[2];
      BYTE2(v116) = a14.i8[4];
      HIBYTE(v116) = a14.i8[6];
      v117.i8[7] = 0;
      v117.i8[0] = *v23;
      v117.i8[1] = *v23;
      v117.i8[2] = *v23;
      *(__int32 *)((char *)v117.i32 + 3) = *v23;
      *(int8x8_t *)a14.i8 = vorr_s8(vbic_s8(v111, vceqz_s8(v117)), (int8x8_t)v116);
      uint16x8_t v118 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v115, *(int8x8_t *)a9.i8), (uint8x8_t)v117), v112);
      uint16x8_t v119 = vrsraq_n_u16(v118, v118, 8uLL);
      int8x8_t v120 = (int8x8_t)vqrshrn_n_u16(v119, 8uLL);
      *(int8x8_t *)v119.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v120, v119, 8uLL), (int8x8_t)0x404040400000000);
      v121.i64[0] = a14.i64[0];
      v121.i64[1] = a14.i64[0];
      *(int8x8_t *)v121.i8 = vqtbl1_s8(v121, (int8x8_t)0x404040400000000);
      int8x8_t v122 = (int8x8_t)vmin_u8((uint8x8_t)v120, *(uint8x8_t *)v119.i8);
      uint8x8_t v123 = vmin_u8(*(uint8x8_t *)a14.i8, *(uint8x8_t *)v121.i8);
      int8x8_t v124 = (int8x8_t)vqsub_u8(*(uint8x8_t *)v121.i8, v123);
      float32x4_t v125 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v124, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      float32x4_t v126 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v124, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      uint16x8_t v127 = vmull_u8(*(uint8x8_t *)v119.i8, *(uint8x8_t *)v119.i8);
      uint64_t v128 = *(void *)&vzip2_s8(v122, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      uint64_t v129 = *(void *)&vzip1_s8(v122, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      uint16x8_t v130 = vmull_u8(*(uint8x8_t *)v119.i8, *(uint8x8_t *)v121.i8);
      uint16x8_t v131 = vmull_u8(v123, (uint8x8_t)vmvn_s8(*(int8x8_t *)v119.i8));
      uint16x8_t v132 = vmull_u8((uint8x8_t)v122, (uint8x8_t)vmvn_s8(*(int8x8_t *)v121.i8));
      int16x8_t v133 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v131.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v132.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v130.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v125, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v127.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v129))), (int8x16_t)vceqzq_f32(v125))), v113))), vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(
                       vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v131)), vcvtq_f32_u32(vmovl_high_u16(v132))),
                       vcvtq_f32_u32(vmovl_high_u16(v130))),
                     (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v126, vcvtq_f32_u32(vmovl_high_u16(v127))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v128))), (int8x16_t)vceqzq_f32(v126))), v113)));
      *(int8x8_t *)v131.i8 = vqmovun_s16(v133);
      *(int8x8_t *)a14.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v119.i8), *(int8x8_t *)a14.i8, vbsl_s8(vceqz_s8(*(int8x8_t *)v121.i8), v120, (int8x8_t)vmin_u8(*(uint8x8_t *)v131.i8, (uint8x8_t)vqtbl1_s8(vqmovun_high_s16(*(int8x8_t *)v131.i8, v133), (int8x8_t)0x404040400000000))));
      *(int8x8_t *)a14.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a14, a9));
      *int8x16_t v22 = a14.i32[0];
      uint64_t v134 = &v20[a6];
      v23 += a6;
      if ((unint64_t)v134 >= v21) {
        uint64_t v135 = -(uint64_t)a5;
      }
      else {
        uint64_t v135 = 0;
      }
      unint64_t v20 = &v134[v135];
      v22 += a6;
      --v108;
    }
    while (v108);
  }
  _WORD *result = v20;
  *a3 = v21;
  *a2 = v22;
  *a4 = v23;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)18,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, uint8x8_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v18 = a15;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  unint64_t v21 = *a2;
  int8x16_t v22 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFF000000FFLL;
  v24.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v23), v24);
  if (a8) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = vandq_s8(vdupq_n_s8(v25), v24);
  uint64_t v27 = 4 * a6;
  uint64_t v28 = 16 * a6;
  uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a13.i32[1] = 67372036;
  v30.i64[0] = -1;
  v30.i64[1] = -1;
  while (1)
  {
    __int32 v31 = *(_DWORD *)v22;
    if (*(_DWORD *)v22 == -1)
    {
      int64_t v38 = (unsigned __int8 *)&v22[v18];
      uint64_t v39 = (int8x16_t *)v22;
      do
        int64_t v40 = v39++;
      while (v39 <= (int8x16_t *)v38 && (vminvq_u8((uint8x16_t)vceqq_s8(*v40, v30)) & 0x80) != 0);
      do
      {
        unint64_t v41 = v40;
        int64_t v40 = (int8x16_t *)((char *)v40 + 4);
      }
      while (v40 <= (int8x16_t *)v38 && v41->i32[0] == -1);
      if (v41 < (int8x16_t *)v38)
      {
        while (v41->u8[0] == 255)
        {
          unint64_t v41 = (int8x16_t *)((char *)v41 + 1);
          if (v41 >= (int8x16_t *)v38)
          {
            unint64_t v41 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      uint64_t v42 = 0;
      unint64_t v43 = (char *)v41 - v22;
      unint64_t v44 = v43;
      do
      {
        int8x16_t v45 = vorrq_s8(*(int8x16_t *)((char *)v19 + v42), a9);
        int8x16_t v46 = vorrq_s8(*(int8x16_t *)((char *)v21 + v42), v26);
        int8x16_t v47 = vqtbl1q_s8(v45, (int8x16_t)xmmword_1850CE030);
        int8x16_t v48 = vqtbl1q_s8(v46, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v49 = vminq_u8((uint8x16_t)v45, (uint8x16_t)v47);
        int8x16_t v50 = (int8x16_t)vminq_u8((uint8x16_t)v46, (uint8x16_t)v48);
        uint8x16_t v51 = (uint8x16_t)vmvnq_s8(v48);
        uint16x8_t v52 = vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v51.i8);
        v126.val[1] = (int8x16_t)vmull_high_u8(v49, v51);
        unsigned long long v53 = *(_OWORD *)&v49 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00);
        int8x16_t v54 = vbicq_s8(vtstq_s8(v50, v50), (int8x16_t)vcgtq_u8((uint8x16_t)v47, (uint8x16_t)v53));
        int8x16_t v55 = vorrq_s8((int8x16_t)vqsubq_u8((uint8x16_t)v47, (uint8x16_t)v53), vceqzq_s8(v50));
        uint64_t v56 = *(void *)&vzip1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
        uint64_t v57 = *(void *)&vzip2_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
        v55.i64[0] = vextq_s8(v55, v55, 8uLL).u64[0];
        uint16x8_t v58 = vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v47.i8);
        uint16x8_t v59 = vmull_high_u8((uint8x16_t)v47, (uint8x16_t)v47);
        int8x8_t v60 = (int8x8_t)vextq_s8(v50, v50, 8uLL).u64[0];
        int8x16_t v61 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v58.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v56))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v50.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v58))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v57)))));
        int8x16_t v62 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v60, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v59.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v60, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v59))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))))));
        uint8x16_t v63 = (uint8x16_t)vmvnq_s8(v47);
        uint16x8_t v64 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v63.i8);
        uint16x8_t v65 = vmull_high_u8((uint8x16_t)v50, v63);
        uint16x8_t v66 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8(v61, (int8x16_t)vmovl_s8(*(int8x8_t *)v54.i8)), v64), v52), v29);
        uint16x8_t v67 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8(v62, (int8x16_t)vmovl_high_s8(v54)), v65), (uint16x8_t)v126.val[1]), v29);
        v126.val[0] = (int8x16_t)vrsraq_n_u16(v66, v66, 8uLL);
        uint16x8_t v68 = vrsraq_n_u16(v67, v67, 8uLL);
        *(uint8x8_t *)v126.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v126.val[0], 8uLL);
        *(uint8x8_t *)v126.val[1].i8 = vqrshrn_n_u16(v68, 8uLL);
        uint8x16_t v69 = (uint8x16_t)vqtbl2q_s8(v126, (int8x16_t)xmmword_1850CE040);
        uint8x16_t v17 = vqrshrn_high_n_u16(*(uint8x8_t *)v126.val[0].i8, v68, 8uLL);
        int8x16_t v16 = (int8x16_t)vminq_u8(v17, v69);
        int8x16_t v15 = vceqzq_s8(v47);
        *(int8x16_t *)((char *)v21 + v42) = vbslq_s8(v15, v46, vbslq_s8(vceqzq_s8(v48), v45, v16));
        v22 += v27;
        v44 -= 4;
        v42 += v28;
      }
      while (v44 > 3);
      unint64_t v21 = (_DWORD *)((char *)v21 + v42);
      unint64_t v19 = (_DWORD *)((char *)v19 + v42);
      unint64_t v18 = v18 - v43 + v44;
      goto LABEL_37;
    }
    if (v31) {
      break;
    }
    __int32 v32 = (unsigned __int8 *)&v22[v18];
    int64_t v33 = (int8x16_t *)v22;
    do
      int64_t v34 = v33++;
    while (v33 <= (int8x16_t *)v32 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v34)) & 0x80) != 0);
    do
    {
      uint64_t v35 = v34;
      int64_t v34 = (int8x16_t *)((char *)v34 + 4);
    }
    while (v34 <= (int8x16_t *)v32 && !v35->i32[0]);
    if (v35 < (int8x16_t *)v32)
    {
      while (!v35->i8[0])
      {
        uint64_t v35 = (int8x16_t *)((char *)v35 + 1);
        if (v35 >= (int8x16_t *)v32)
        {
          uint64_t v35 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    int64_t v36 = (char *)v35 - v22;
    int64_t v37 = ((char *)v35 - v22) * a6;
    v19 += v37;
    v21 += v37;
    v22 += v37;
    v18 -= v36;
LABEL_37:
    if (v18 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v70 = 0;
  while (1)
  {
    v15.i32[0] = v31;
    int8x16_t v71 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v72 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v70), a9);
    int8x16_t v73 = vorrq_s8(vbicq_s8(v26, vceqzq_s8(v71)), *(int8x16_t *)((char *)v21 + v70));
    uint16x8_t v74 = vminq_u16(vmull_u8(*(uint8x8_t *)v72.i8, *(uint8x8_t *)v71.i8), v29);
    uint16x8_t v75 = vminq_u16(vmull_high_u8(v72, (uint8x16_t)v71), v29);
    uint16x8_t v76 = vrsraq_n_u16(v75, v75, 8uLL);
    *(uint8x8_t *)v16.i8 = vqrshrn_n_u16(vrsraq_n_u16(v74, v74, 8uLL), 8uLL);
    *(uint8x8_t *)v17.i8 = vqrshrn_n_u16(v76, 8uLL);
    int8x16_t v77 = vqtbl2q_s8(*(int8x16x2_t *)v16.i8, (int8x16_t)xmmword_1850CE040);
    int8x16_t v78 = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v16.i8, v76, 8uLL);
    int8x16_t v79 = vqtbl1q_s8(v73, (int8x16_t)xmmword_1850CE030);
    uint8x16_t v80 = vminq_u8((uint8x16_t)v78, (uint8x16_t)v77);
    int8x16_t v81 = (int8x16_t)vminq_u8((uint8x16_t)v73, (uint8x16_t)v79);
    uint8x16_t v82 = (uint8x16_t)vmvnq_s8(v79);
    uint16x8_t v83 = vmull_u8(*(uint8x8_t *)v80.i8, *(uint8x8_t *)v82.i8);
    v127.val[1] = (int8x16_t)vmull_high_u8(v80, v82);
    unsigned long long v84 = *(_OWORD *)&v80 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00);
    int8x16_t v85 = vbicq_s8(vtstq_s8(v81, v81), (int8x16_t)vcgtq_u8((uint8x16_t)v77, (uint8x16_t)v84));
    int8x16_t v86 = vorrq_s8((int8x16_t)vqsubq_u8((uint8x16_t)v77, (uint8x16_t)v84), vceqzq_s8(v81));
    uint64_t v87 = *(void *)&vzip1_s8(*(int8x8_t *)v86.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
    uint64_t v88 = *(void *)&vzip2_s8(*(int8x8_t *)v86.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
    v86.i64[0] = vextq_s8(v86, v86, 8uLL).u64[0];
    uint16x8_t v89 = vmull_u8(*(uint8x8_t *)v77.i8, *(uint8x8_t *)v77.i8);
    uint16x8_t v90 = vmull_high_u8((uint8x16_t)v77, (uint8x16_t)v77);
    int8x8_t v91 = (int8x8_t)vextq_s8(v81, v81, 8uLL).u64[0];
    int8x16_t v92 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v81.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v89.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v87))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v81.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v89))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v88)))));
    int8x16_t v93 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v91, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v90.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v86.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v91, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v90))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v86.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))))));
    uint8x16_t v94 = (uint8x16_t)vmvnq_s8(v77);
    uint16x8_t v95 = vmull_u8(*(uint8x8_t *)v81.i8, *(uint8x8_t *)v94.i8);
    uint16x8_t v96 = vmull_high_u8((uint8x16_t)v81, v94);
    uint16x8_t v97 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8(v92, (int8x16_t)vmovl_s8(*(int8x8_t *)v85.i8)), v95), v83), v29);
    uint16x8_t v98 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8(v93, (int8x16_t)vmovl_high_s8(v85)), v96), (uint16x8_t)v127.val[1]), v29);
    v127.val[0] = (int8x16_t)vrsraq_n_u16(v97, v97, 8uLL);
    uint16x8_t v99 = vrsraq_n_u16(v98, v98, 8uLL);
    *(uint8x8_t *)v127.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v127.val[0], 8uLL);
    *(uint8x8_t *)v127.val[1].i8 = vqrshrn_n_u16(v99, 8uLL);
    uint8x16_t v100 = (uint8x16_t)vqtbl2q_s8(v127, (int8x16_t)xmmword_1850CE040);
    uint8x16_t v17 = vqrshrn_high_n_u16(*(uint8x8_t *)v127.val[0].i8, v99, 8uLL);
    int8x16_t v16 = (int8x16_t)vminq_u8(v17, v100);
    int8x16_t v15 = vbslq_s8(vceqzq_s8(v79), v78, v16);
    *(int8x16_t *)((char *)v21 + v70) = vbslq_s8(vceqzq_s8(v77), v73, v15);
    v22 += v27;
    v18 -= 4;
    if (v18 < 4) {
      break;
    }
    __int32 v31 = *(_DWORD *)v22;
    v70 += v28;
    if ((*(_DWORD *)v22 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v19 = (_DWORD *)((char *)v19 + v70);
      unint64_t v21 = (_DWORD *)((char *)v21 + v70);
      goto LABEL_37;
    }
  }
  unint64_t v19 = (_DWORD *)((char *)v19 + v28 + v70);
  unint64_t v21 = (_DWORD *)((char *)v21 + v28 + v70);
LABEL_40:
  uint64_t v101 = v18 + a14;
  if (v101)
  {
    if (a7) {
      unsigned int v102 = 0;
    }
    else {
      unsigned int v102 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v102), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v103 = 0;
    }
    else {
      unsigned int v103 = -1;
    }
    int8x8_t v104 = vand_s8(vdup_n_s8(v103), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v105 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v19;
      uint16x8_t v106 = vmovl_u8(a13);
      LOBYTE(v107) = v106.i8[0];
      BYTE1(v107) = v106.i8[2];
      BYTE2(v107) = v106.i8[4];
      HIBYTE(v107) = v106.i8[6];
      v106.i32[0] = *v21;
      int8x16_t v108 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v106.i8);
      LOBYTE(v109) = v108.i8[0];
      BYTE1(v109) = v108.i8[2];
      BYTE2(v109) = v108.i8[4];
      HIBYTE(v109) = v108.i8[6];
      v110.i8[7] = 0;
      v110.i8[0] = *v22;
      v110.i8[1] = *v22;
      v110.i8[2] = *v22;
      *(__int32 *)((char *)v110.i32 + 3) = *v22;
      *(int8x8_t *)v108.i8 = vorr_s8(vbic_s8(v104, vceqz_s8(v110)), (int8x8_t)v109);
      uint16x8_t v111 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v107, *(int8x8_t *)a9.i8), (uint8x8_t)v110), v105);
      uint16x8_t v112 = vrsraq_n_u16(v111, v111, 8uLL);
      int8x8_t v113 = (int8x8_t)vqrshrn_n_u16(v112, 8uLL);
      *(int8x8_t *)v112.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v113, v112, 8uLL), (int8x8_t)0x404040400000000);
      v114.i64[0] = v108.i64[0];
      v114.i64[1] = v108.i64[0];
      *(int8x8_t *)v114.i8 = vqtbl1_s8(v114, (int8x8_t)0x404040400000000);
      uint8x8_t v115 = vmin_u8((uint8x8_t)v113, *(uint8x8_t *)v112.i8);
      int8x8_t v116 = (int8x8_t)vmin_u8(*(uint8x8_t *)v108.i8, *(uint8x8_t *)v114.i8);
      uint16x8_t v117 = vmull_u8(v115, (uint8x8_t)vmvn_s8(*(int8x8_t *)v114.i8));
      *(void *)&v115 &= 0xFFFFFF00FFFFFF00;
      int8x16_t v118 = (int8x16_t)vmovl_s8(vbic_s8(vtst_s8(v116, v116), (int8x8_t)vcgt_u8(*(uint8x8_t *)v112.i8, v115)));
      int8x8_t v119 = vorr_s8((int8x8_t)vqsub_u8(*(uint8x8_t *)v112.i8, v115), vceqz_s8(v116));
      uint16x8_t v120 = vmull_u8(*(uint8x8_t *)v112.i8, *(uint8x8_t *)v112.i8);
      uint16x8_t v121 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8((int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v116, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v120.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v119, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v116, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v120))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v119, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))),
                                 v118),
                   vmull_u8((uint8x8_t)v116, (uint8x8_t)vmvn_s8(*(int8x8_t *)v112.i8))),
                 v117),
               v105);
      uint16x8_t v122 = vrsraq_n_u16(v121, v121, 8uLL);
      uint8x8_t v123 = vqrshrn_n_u16(v122, 8uLL);
      *(int8x8_t *)v108.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v112.i8), *(int8x8_t *)v108.i8, vbsl_s8(vceqz_s8(*(int8x8_t *)v114.i8), v113, (int8x8_t)vmin_u8(v123, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v123, v122, 8uLL), (int8x8_t)0x404040400000000))));
      a13 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v108, a9));
      *unint64_t v21 = a13.i32[0];
      int8x8_t v124 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v124 >= v20) {
        uint64_t v125 = -(uint64_t)a5;
      }
      else {
        uint64_t v125 = 0;
      }
      unint64_t v19 = &v124[v125];
      v21 += a6;
      --v101;
    }
    while (v101);
  }
  _WORD *result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)17,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, int8x16_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  uint8x16_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFF000000FFLL;
  v22.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v21), v22);
  if (a8) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  int8x16_t v24 = vandq_s8(vdupq_n_s8(v23), v22);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a13.i64[0] = -1;
  a13.i64[1] = -1;
  while (1)
  {
    __int32 v28 = *(_DWORD *)v20;
    if (*(_DWORD *)v20 == -1)
    {
      uint64_t v35 = (unsigned __int8 *)&v20[v16];
      int64_t v36 = (int8x16_t *)v20;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, a13)) & 0x80) != 0);
      do
      {
        int64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          int64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            int64_t v38 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v20;
      unint64_t v41 = (char *)v38 - v20;
      do
      {
        int8x16_t v42 = vorrq_s8(*(int8x16_t *)((char *)v17 + v39), a9);
        int8x16_t v43 = vorrq_s8(*(int8x16_t *)((char *)v19 + v39), v24);
        int8x16_t v44 = vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CE030);
        int8x16_t v45 = vqtbl1q_s8(v43, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v46 = vminq_u8((uint8x16_t)v42, (uint8x16_t)v44);
        uint8x16_t v47 = vminq_u8((uint8x16_t)v43, (uint8x16_t)v45);
        uint16x8_t v48 = vmull_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v45.i8);
        uint8x16_t v49 = (uint8x16_t)vmvnq_s8(v45);
        uint16x8_t v50 = vmull_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v49.i8);
        uint8x16_t v51 = (uint8x16_t)vmvnq_s8(v44);
        uint16x8_t v52 = vqaddq_u16(vqaddq_u16(vmaxq_u16(vmull_high_u8(v46, (uint8x16_t)v45), vmull_high_u8(v47, (uint8x16_t)v44)), vmull_high_u8(v46, v49)), vmull_high_u8(v47, v51));
        uint16x8_t v53 = vminq_u16(vqaddq_u16(vqaddq_u16(vmaxq_u16(v48, vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v44.i8)), v50), vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v51.i8)), v27);
        uint16x8_t v54 = vminq_u16(v52, v27);
        int8x16_t v15 = vceqzq_s8(v44);
        *(int8x16_t *)((char *)v19 + v39) = vbslq_s8(v15, v43, vbslq_s8(vceqzq_s8(v45), v42, (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v53, v53, 8uLL), 8uLL), vrsraq_n_u16(v54, v54, 8uLL), 8uLL)));
        v20 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      unint64_t v19 = (_DWORD *)((char *)v19 + v39);
      uint8x16_t v17 = (unsigned __int32 *)((char *)v17 + v39);
      unint64_t v16 = v16 - v40 + v41;
      goto LABEL_37;
    }
    if (v28) {
      break;
    }
    uint16x8_t v29 = (unsigned __int8 *)&v20[v16];
    int8x16_t v30 = (int8x16_t *)v20;
    do
      __int32 v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      __int32 v32 = v31;
      __int32 v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        __int32 v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          __int32 v32 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v20;
    int64_t v34 = ((char *)v32 - v20) * a6;
    v17 += v34;
    v19 += v34;
    v20 += v34;
    v16 -= v33;
LABEL_37:
    if (v16 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v55 = 0;
  while (1)
  {
    v15.i32[0] = v28;
    int8x16_t v56 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v57 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v17 + v55), a9);
    int8x16_t v58 = vorrq_s8(vbicq_s8(v24, vceqzq_s8(v56)), *(int8x16_t *)((char *)v19 + v55));
    v91.val[1] = (int8x16_t)vmull_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v56.i8);
    uint16x8_t v59 = vmull_high_u8(v57, (uint8x16_t)v56);
    uint16x8_t v60 = vminq_u16((uint16x8_t)v91.val[1], v27);
    uint16x8_t v61 = vminq_u16(v59, v27);
    v91.val[0] = (int8x16_t)vrsraq_n_u16(v60, v60, 8uLL);
    uint16x8_t v62 = vrsraq_n_u16(v61, v61, 8uLL);
    *(uint8x8_t *)v91.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v91.val[0], 8uLL);
    *(uint8x8_t *)v91.val[1].i8 = vqrshrn_n_u16(v62, 8uLL);
    int8x16_t v63 = vqtbl2q_s8(v91, (int8x16_t)xmmword_1850CE040);
    v91.val[0] = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v91.val[0].i8, v62, 8uLL);
    int8x16_t v64 = vqtbl1q_s8(v58, (int8x16_t)xmmword_1850CE030);
    v91.val[1] = (int8x16_t)vminq_u8((uint8x16_t)v91.val[0], (uint8x16_t)v63);
    uint8x16_t v65 = vminq_u8((uint8x16_t)v58, (uint8x16_t)v64);
    uint16x8_t v66 = vmull_u8(*(uint8x8_t *)v91.val[1].i8, *(uint8x8_t *)v64.i8);
    uint8x16_t v67 = (uint8x16_t)vmvnq_s8(v64);
    uint16x8_t v68 = vmull_u8(*(uint8x8_t *)v91.val[1].i8, *(uint8x8_t *)v67.i8);
    uint8x16_t v69 = (uint8x16_t)vmvnq_s8(v63);
    v91.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(vmaxq_u16(vmull_high_u8((uint8x16_t)v91.val[1], (uint8x16_t)v64), vmull_high_u8(v65, (uint8x16_t)v63)), vmull_high_u8((uint8x16_t)v91.val[1], v67)), vmull_high_u8(v65, v69));
    uint16x8_t v70 = vminq_u16(vqaddq_u16(vqaddq_u16(vmaxq_u16(v66, vmull_u8(*(uint8x8_t *)v65.i8, *(uint8x8_t *)v63.i8)), v68), vmull_u8(*(uint8x8_t *)v65.i8, *(uint8x8_t *)v69.i8)), v27);
    v91.val[1] = (int8x16_t)vminq_u16((uint16x8_t)v91.val[1], v27);
    int8x16_t v71 = vbslq_s8(vceqzq_s8(v64), v91.val[0], (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v70, v70, 8uLL), 8uLL), vrsraq_n_u16((uint16x8_t)v91.val[1], (uint16x8_t)v91.val[1], 8uLL), 8uLL));
    int8x16_t v15 = vceqzq_s8(v63);
    *(int8x16_t *)((char *)v19 + v55) = vbslq_s8(v15, v58, v71);
    v20 += v25;
    v16 -= 4;
    if (v16 < 4) {
      break;
    }
    __int32 v28 = *(_DWORD *)v20;
    v55 += v26;
    if ((*(_DWORD *)v20 - 1) >= 0xFFFFFFFE)
    {
      uint8x16_t v17 = (unsigned __int32 *)((char *)v17 + v55);
      unint64_t v19 = (_DWORD *)((char *)v19 + v55);
      goto LABEL_37;
    }
  }
  uint8x16_t v17 = (unsigned __int32 *)((char *)v17 + v26 + v55);
  unint64_t v19 = (_DWORD *)((char *)v19 + v26 + v55);
LABEL_40:
  uint64_t v72 = v16 + a14;
  if (v72)
  {
    if (a7) {
      unsigned int v73 = 0;
    }
    else {
      unsigned int v73 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v73), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v74 = 0;
    }
    else {
      unsigned int v74 = -1;
    }
    int8x8_t v75 = vand_s8(vdup_n_s8(v74), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v76 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v17;
      uint16x8_t v77 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v78) = v77.i8[0];
      BYTE1(v78) = v77.i8[2];
      BYTE2(v78) = v77.i8[4];
      HIBYTE(v78) = v77.i8[6];
      v77.i32[0] = *v19;
      uint16x8_t v79 = vmovl_u8(*(uint8x8_t *)v77.i8);
      LOBYTE(v80) = v79.i8[0];
      BYTE1(v80) = v79.i8[2];
      BYTE2(v80) = v79.i8[4];
      HIBYTE(v80) = v79.i8[6];
      v79.i8[7] = 0;
      v79.i8[0] = *v20;
      v79.i8[1] = *v20;
      v79.i8[2] = *v20;
      *(__int32 *)((char *)v79.i32 + 3) = *v20;
      int8x8_t v81 = vorr_s8(vbic_s8(v75, vceqz_s8(*(int8x8_t *)v79.i8)), (int8x8_t)v80);
      uint16x8_t v82 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v78, *(int8x8_t *)a9.i8), *(uint8x8_t *)v79.i8), v76);
      uint16x8_t v83 = vrsraq_n_u16(v82, v82, 8uLL);
      int8x8_t v84 = (int8x8_t)vqrshrn_n_u16(v83, 8uLL);
      int8x16_t v85 = (int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v84, v83, 8uLL);
      *(int8x8_t *)v83.i8 = v81;
      a13.u64[1] = (unint64_t)v81;
      *(int8x8_t *)v85.i8 = vqtbl1_s8(v85, (int8x8_t)0x404040400000000);
      *(int8x8_t *)a13.i8 = vqtbl1_s8(a13, (int8x8_t)0x404040400000000);
      uint8x8_t v86 = vmin_u8((uint8x8_t)v84, *(uint8x8_t *)v85.i8);
      uint8x8_t v87 = vmin_u8((uint8x8_t)v81, *(uint8x8_t *)a13.i8);
      uint16x8_t v88 = vminq_u16(vqaddq_u16(vqaddq_u16(vmaxq_u16(vmull_u8(v86, *(uint8x8_t *)a13.i8), vmull_u8(v87, *(uint8x8_t *)v85.i8)), vmull_u8(v86, (uint8x8_t)vmvn_s8(*(int8x8_t *)a13.i8))), vmull_u8(v87, (uint8x8_t)vmvn_s8(*(int8x8_t *)v85.i8))), v76);
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v85.i8), v81, vbsl_s8(vceqz_s8(*(int8x8_t *)a13.i8), v84, (int8x8_t)vqrshrn_n_u16(vrsraq_n_u16(v88, v88, 8uLL), 8uLL)));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a13, a9));
      *unint64_t v19 = a13.i32[0];
      uint16x8_t v89 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v89 >= v18) {
        uint64_t v90 = -(uint64_t)a5;
      }
      else {
        uint64_t v90 = 0;
      }
      uint8x16_t v17 = &v89[v90];
      v19 += a6;
      --v72;
    }
    while (v72);
  }
  _WORD *result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)16,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, int8x16_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  uint8x16_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFF000000FFLL;
  v22.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v21), v22);
  if (a8) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  int8x16_t v24 = vandq_s8(vdupq_n_s8(v23), v22);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a13.i64[0] = -1;
  a13.i64[1] = -1;
  while (1)
  {
    __int32 v28 = *(_DWORD *)v20;
    if (*(_DWORD *)v20 == -1)
    {
      uint64_t v35 = (unsigned __int8 *)&v20[v16];
      int64_t v36 = (int8x16_t *)v20;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, a13)) & 0x80) != 0);
      do
      {
        int64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          int64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            int64_t v38 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v20;
      unint64_t v41 = (char *)v38 - v20;
      do
      {
        int8x16_t v42 = vorrq_s8(*(int8x16_t *)((char *)v17 + v39), a9);
        int8x16_t v43 = vorrq_s8(*(int8x16_t *)((char *)v19 + v39), v24);
        int8x16_t v44 = vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CE030);
        int8x16_t v45 = vqtbl1q_s8(v43, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v46 = vminq_u8((uint8x16_t)v42, (uint8x16_t)v44);
        uint8x16_t v47 = vminq_u8((uint8x16_t)v43, (uint8x16_t)v45);
        uint16x8_t v48 = vmull_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v45.i8);
        uint8x16_t v49 = (uint8x16_t)vmvnq_s8(v45);
        uint16x8_t v50 = vmull_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v49.i8);
        uint8x16_t v51 = (uint8x16_t)vmvnq_s8(v44);
        uint16x8_t v52 = vqaddq_u16(vqaddq_u16(vminq_u16(vmull_high_u8(v47, (uint8x16_t)v44), vmull_high_u8(v46, (uint8x16_t)v45)), vmull_high_u8(v46, v49)), vmull_high_u8(v47, v51));
        uint16x8_t v53 = vminq_u16(vqaddq_u16(vqaddq_u16(vminq_u16(vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v44.i8), v48), v50), vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v51.i8)), v27);
        uint16x8_t v54 = vminq_u16(v52, v27);
        int8x16_t v15 = vceqzq_s8(v44);
        *(int8x16_t *)((char *)v19 + v39) = vbslq_s8(v15, v43, vbslq_s8(vceqzq_s8(v45), v42, (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v53, v53, 8uLL), 8uLL), vrsraq_n_u16(v54, v54, 8uLL), 8uLL)));
        v20 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      unint64_t v19 = (_DWORD *)((char *)v19 + v39);
      uint8x16_t v17 = (unsigned __int32 *)((char *)v17 + v39);
      unint64_t v16 = v16 - v40 + v41;
      goto LABEL_37;
    }
    if (v28) {
      break;
    }
    uint16x8_t v29 = (unsigned __int8 *)&v20[v16];
    int8x16_t v30 = (int8x16_t *)v20;
    do
      __int32 v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      __int32 v32 = v31;
      __int32 v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        __int32 v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          __int32 v32 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v20;
    int64_t v34 = ((char *)v32 - v20) * a6;
    v17 += v34;
    v19 += v34;
    v20 += v34;
    v16 -= v33;
LABEL_37:
    if (v16 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v55 = 0;
  while (1)
  {
    v15.i32[0] = v28;
    int8x16_t v56 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v57 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v17 + v55), a9);
    int8x16_t v58 = vorrq_s8(vbicq_s8(v24, vceqzq_s8(v56)), *(int8x16_t *)((char *)v19 + v55));
    v91.val[1] = (int8x16_t)vmull_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v56.i8);
    uint16x8_t v59 = vmull_high_u8(v57, (uint8x16_t)v56);
    uint16x8_t v60 = vminq_u16((uint16x8_t)v91.val[1], v27);
    uint16x8_t v61 = vminq_u16(v59, v27);
    v91.val[0] = (int8x16_t)vrsraq_n_u16(v60, v60, 8uLL);
    uint16x8_t v62 = vrsraq_n_u16(v61, v61, 8uLL);
    *(uint8x8_t *)v91.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v91.val[0], 8uLL);
    *(uint8x8_t *)v91.val[1].i8 = vqrshrn_n_u16(v62, 8uLL);
    int8x16_t v63 = vqtbl2q_s8(v91, (int8x16_t)xmmword_1850CE040);
    v91.val[0] = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v91.val[0].i8, v62, 8uLL);
    int8x16_t v64 = vqtbl1q_s8(v58, (int8x16_t)xmmword_1850CE030);
    v91.val[1] = (int8x16_t)vminq_u8((uint8x16_t)v91.val[0], (uint8x16_t)v63);
    uint8x16_t v65 = vminq_u8((uint8x16_t)v58, (uint8x16_t)v64);
    uint16x8_t v66 = vmull_u8(*(uint8x8_t *)v91.val[1].i8, *(uint8x8_t *)v64.i8);
    uint8x16_t v67 = (uint8x16_t)vmvnq_s8(v64);
    uint16x8_t v68 = vmull_u8(*(uint8x8_t *)v91.val[1].i8, *(uint8x8_t *)v67.i8);
    uint8x16_t v69 = (uint8x16_t)vmvnq_s8(v63);
    v91.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(vminq_u16(vmull_high_u8(v65, (uint8x16_t)v63), vmull_high_u8((uint8x16_t)v91.val[1], (uint8x16_t)v64)), vmull_high_u8((uint8x16_t)v91.val[1], v67)), vmull_high_u8(v65, v69));
    uint16x8_t v70 = vminq_u16(vqaddq_u16(vqaddq_u16(vminq_u16(vmull_u8(*(uint8x8_t *)v65.i8, *(uint8x8_t *)v63.i8), v66), v68), vmull_u8(*(uint8x8_t *)v65.i8, *(uint8x8_t *)v69.i8)), v27);
    v91.val[1] = (int8x16_t)vminq_u16((uint16x8_t)v91.val[1], v27);
    int8x16_t v71 = vbslq_s8(vceqzq_s8(v64), v91.val[0], (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v70, v70, 8uLL), 8uLL), vrsraq_n_u16((uint16x8_t)v91.val[1], (uint16x8_t)v91.val[1], 8uLL), 8uLL));
    int8x16_t v15 = vceqzq_s8(v63);
    *(int8x16_t *)((char *)v19 + v55) = vbslq_s8(v15, v58, v71);
    v20 += v25;
    v16 -= 4;
    if (v16 < 4) {
      break;
    }
    __int32 v28 = *(_DWORD *)v20;
    v55 += v26;
    if ((*(_DWORD *)v20 - 1) >= 0xFFFFFFFE)
    {
      uint8x16_t v17 = (unsigned __int32 *)((char *)v17 + v55);
      unint64_t v19 = (_DWORD *)((char *)v19 + v55);
      goto LABEL_37;
    }
  }
  uint8x16_t v17 = (unsigned __int32 *)((char *)v17 + v26 + v55);
  unint64_t v19 = (_DWORD *)((char *)v19 + v26 + v55);
LABEL_40:
  uint64_t v72 = v16 + a14;
  if (v72)
  {
    if (a7) {
      unsigned int v73 = 0;
    }
    else {
      unsigned int v73 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v73), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v74 = 0;
    }
    else {
      unsigned int v74 = -1;
    }
    int8x8_t v75 = vand_s8(vdup_n_s8(v74), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v76 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v17;
      uint16x8_t v77 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v78) = v77.i8[0];
      BYTE1(v78) = v77.i8[2];
      BYTE2(v78) = v77.i8[4];
      HIBYTE(v78) = v77.i8[6];
      v77.i32[0] = *v19;
      uint16x8_t v79 = vmovl_u8(*(uint8x8_t *)v77.i8);
      LOBYTE(v80) = v79.i8[0];
      BYTE1(v80) = v79.i8[2];
      BYTE2(v80) = v79.i8[4];
      HIBYTE(v80) = v79.i8[6];
      v79.i8[7] = 0;
      v79.i8[0] = *v20;
      v79.i8[1] = *v20;
      v79.i8[2] = *v20;
      *(__int32 *)((char *)v79.i32 + 3) = *v20;
      int8x8_t v81 = vorr_s8(vbic_s8(v75, vceqz_s8(*(int8x8_t *)v79.i8)), (int8x8_t)v80);
      uint16x8_t v82 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v78, *(int8x8_t *)a9.i8), *(uint8x8_t *)v79.i8), v76);
      uint16x8_t v83 = vrsraq_n_u16(v82, v82, 8uLL);
      int8x8_t v84 = (int8x8_t)vqrshrn_n_u16(v83, 8uLL);
      int8x16_t v85 = (int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v84, v83, 8uLL);
      *(int8x8_t *)v83.i8 = v81;
      a13.u64[1] = (unint64_t)v81;
      *(int8x8_t *)v85.i8 = vqtbl1_s8(v85, (int8x8_t)0x404040400000000);
      *(int8x8_t *)a13.i8 = vqtbl1_s8(a13, (int8x8_t)0x404040400000000);
      uint8x8_t v86 = vmin_u8((uint8x8_t)v84, *(uint8x8_t *)v85.i8);
      uint8x8_t v87 = vmin_u8((uint8x8_t)v81, *(uint8x8_t *)a13.i8);
      uint16x8_t v88 = vminq_u16(vqaddq_u16(vqaddq_u16(vminq_u16(vmull_u8(v86, *(uint8x8_t *)a13.i8), vmull_u8(v87, *(uint8x8_t *)v85.i8)), vmull_u8(v86, (uint8x8_t)vmvn_s8(*(int8x8_t *)a13.i8))), vmull_u8(v87, (uint8x8_t)vmvn_s8(*(int8x8_t *)v85.i8))), v76);
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v85.i8), v81, vbsl_s8(vceqz_s8(*(int8x8_t *)a13.i8), v84, (int8x8_t)vqrshrn_n_u16(vrsraq_n_u16(v88, v88, 8uLL), 8uLL)));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a13, a9));
      *unint64_t v19 = a13.i32[0];
      uint16x8_t v89 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v89 >= v18) {
        uint64_t v90 = -(uint64_t)a5;
      }
      else {
        uint64_t v90 = 0;
      }
      uint8x16_t v17 = &v89[v90];
      v19 += a6;
      --v72;
    }
    while (v72);
  }
  _WORD *result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)15,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, double a13, uint16x8_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v17 = a16;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a16 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v22 = 0;
  }
  else {
    unsigned int v22 = -1;
  }
  v23.i64[0] = 0xFF000000FFLL;
  v23.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v22), v23);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8(vdupq_n_s8(v24), v23);
  uint64_t v26 = 4 * a6;
  uint64_t v27 = 16 * a6;
  uint16x8_t v28 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a14.i64[0] = -1;
  a14.i64[1] = -1;
  while (1)
  {
    __int32 v29 = *(_DWORD *)v21;
    if (*(_DWORD *)v21 == -1)
    {
      int64_t v36 = (unsigned __int8 *)&v21[v17];
      int64_t v37 = (int8x16_t *)v21;
      do
        int64_t v38 = v37++;
      while (v37 <= (int8x16_t *)v36 && (vminvq_u8((uint8x16_t)vceqq_s8(*v38, (int8x16_t)a14)) & 0x80) != 0);
      do
      {
        uint64_t v39 = v38;
        int64_t v38 = (int8x16_t *)((char *)v38 + 4);
      }
      while (v38 <= (int8x16_t *)v36 && v39->i32[0] == -1);
      if (v39 < (int8x16_t *)v36)
      {
        while (v39->u8[0] == 255)
        {
          uint64_t v39 = (int8x16_t *)((char *)v39 + 1);
          if (v39 >= (int8x16_t *)v36)
          {
            uint64_t v39 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      uint64_t v40 = 0;
      int64_t v41 = (char *)v39 - v21;
      unint64_t v42 = (char *)v39 - v21;
      do
      {
        int8x16_t v43 = vorrq_s8(*(int8x16_t *)((char *)v18 + v40), a9);
        int8x16_t v44 = vorrq_s8(*(int8x16_t *)((char *)v20 + v40), v25);
        int8x16_t v45 = vqtbl1q_s8(v43, (int8x16_t)xmmword_1850CE030);
        int8x16_t v46 = vqtbl1q_s8(v44, (int8x16_t)xmmword_1850CE030);
        int8x16_t v47 = (int8x16_t)vminq_u8((uint8x16_t)v43, (uint8x16_t)v45);
        int8x16_t v48 = (int8x16_t)vminq_u8((uint8x16_t)v44, (uint8x16_t)v46);
        uint8x16_t v49 = (uint8x16_t)vsubq_s8(v45, v47);
        uint8x16_t v50 = (uint8x16_t)vsubq_s8(v46, v48);
        int8x16_t v51 = (int8x16_t)vcgtq_u8(vrhaddq_u8((uint8x16_t)v46, (uint8x16_t)0), (uint8x16_t)v48);
        int8x16_t v52 = (int8x16_t)vqaddq_u16(vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v48.i8), vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v47.i8));
        int8x16_t v53 = (int8x16_t)vqaddq_u16(vmull_high_u8(v49, (uint8x16_t)v48), vmull_high_u8(v50, (uint8x16_t)v47));
        uint16x8_t v54 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_s8(*(int8x8_t *)v51.i8), v52, (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v45.i8, *(uint8x8_t *)v46.i8), (uint16x8_t)v52)), v28);
        uint16x8_t v55 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_high_s8(v51), v53, (int8x16_t)vqsubq_u16(vmull_high_u8((uint8x16_t)v45, (uint8x16_t)v46), (uint16x8_t)v53)), v28);
        int8x16_t v16 = vceqzq_s8(v45);
        *(int8x16_t *)((char *)v20 + v40) = vbslq_s8(v16, v44, vbslq_s8(vceqzq_s8(v46), v43, vsubq_s8(vaddq_s8(v48, v47), (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v54, v54, 8uLL), 8uLL), vrsraq_n_u16(v55, v55, 8uLL), 8uLL))));
        v21 += v26;
        v42 -= 4;
        v40 += v27;
      }
      while (v42 > 3);
      unint64_t v20 = (_DWORD *)((char *)v20 + v40);
      unint64_t v18 = (unsigned __int32 *)((char *)v18 + v40);
      unint64_t v17 = v17 - v41 + v42;
      goto LABEL_37;
    }
    if (v29) {
      break;
    }
    int8x16_t v30 = (unsigned __int8 *)&v21[v17];
    __int32 v31 = (int8x16_t *)v21;
    do
      __int32 v32 = v31++;
    while (v31 <= (int8x16_t *)v30 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v32)) & 0x80) != 0);
    do
    {
      int64_t v33 = v32;
      __int32 v32 = (int8x16_t *)((char *)v32 + 4);
    }
    while (v32 <= (int8x16_t *)v30 && !v33->i32[0]);
    if (v33 < (int8x16_t *)v30)
    {
      while (!v33->i8[0])
      {
        int64_t v33 = (int8x16_t *)((char *)v33 + 1);
        if (v33 >= (int8x16_t *)v30)
        {
          int64_t v33 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    int64_t v34 = (char *)v33 - v21;
    int64_t v35 = ((char *)v33 - v21) * a6;
    v18 += v35;
    v20 += v35;
    v21 += v35;
    v17 -= v34;
LABEL_37:
    if (v17 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v56 = 0;
  while (1)
  {
    v16.i32[0] = v29;
    int8x16_t v57 = vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v58 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v18 + v56), a9);
    int8x16_t v59 = vorrq_s8(vbicq_s8(v25, vceqzq_s8(v57)), *(int8x16_t *)((char *)v20 + v56));
    v95.val[1] = (int8x16_t)vmull_u8(*(uint8x8_t *)v58.i8, *(uint8x8_t *)v57.i8);
    uint16x8_t v60 = vmull_high_u8(v58, (uint8x16_t)v57);
    uint16x8_t v61 = vminq_u16((uint16x8_t)v95.val[1], v28);
    uint16x8_t v62 = vminq_u16(v60, v28);
    v95.val[0] = (int8x16_t)vrsraq_n_u16(v61, v61, 8uLL);
    uint16x8_t v63 = vrsraq_n_u16(v62, v62, 8uLL);
    *(uint8x8_t *)v95.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v95.val[0], 8uLL);
    *(uint8x8_t *)v95.val[1].i8 = vqrshrn_n_u16(v63, 8uLL);
    int8x16_t v64 = vqtbl2q_s8(v95, (int8x16_t)xmmword_1850CE040);
    v95.val[0] = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v95.val[0].i8, v63, 8uLL);
    int8x16_t v65 = vqtbl1q_s8(v59, (int8x16_t)xmmword_1850CE030);
    v95.val[1] = (int8x16_t)vminq_u8((uint8x16_t)v95.val[0], (uint8x16_t)v64);
    int8x16_t v66 = (int8x16_t)vminq_u8((uint8x16_t)v59, (uint8x16_t)v65);
    uint8x16_t v67 = (uint8x16_t)vsubq_s8(v64, v95.val[1]);
    uint8x16_t v68 = (uint8x16_t)vsubq_s8(v65, v66);
    int8x16_t v69 = (int8x16_t)vcgtq_u8(vrhaddq_u8((uint8x16_t)v65, (uint8x16_t)0), (uint8x16_t)v66);
    int8x16_t v70 = (int8x16_t)vqaddq_u16(vmull_u8(*(uint8x8_t *)v67.i8, *(uint8x8_t *)v66.i8), vmull_u8(*(uint8x8_t *)v68.i8, *(uint8x8_t *)v95.val[1].i8));
    int8x16_t v71 = (int8x16_t)vqaddq_u16(vmull_high_u8(v67, (uint8x16_t)v66), vmull_high_u8(v68, (uint8x16_t)v95.val[1]));
    uint16x8_t v72 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_s8(*(int8x8_t *)v69.i8), v70, (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v64.i8, *(uint8x8_t *)v65.i8), (uint16x8_t)v70)), v28);
    uint16x8_t v73 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_high_s8(v69), v71, (int8x16_t)vqsubq_u16(vmull_high_u8((uint8x16_t)v64, (uint8x16_t)v65), (uint16x8_t)v71)), v28);
    int8x16_t v74 = vbslq_s8(vceqzq_s8(v65), v95.val[0], vsubq_s8(vaddq_s8(v66, v95.val[1]), (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v72, v72, 8uLL), 8uLL), vrsraq_n_u16(v73, v73, 8uLL), 8uLL)));
    int8x16_t v16 = vceqzq_s8(v64);
    *(int8x16_t *)((char *)v20 + v56) = vbslq_s8(v16, v59, v74);
    v21 += v26;
    v17 -= 4;
    if (v17 < 4) {
      break;
    }
    __int32 v29 = *(_DWORD *)v21;
    v56 += v27;
    if ((*(_DWORD *)v21 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v18 = (unsigned __int32 *)((char *)v18 + v56);
      unint64_t v20 = (_DWORD *)((char *)v20 + v56);
      goto LABEL_37;
    }
  }
  unint64_t v18 = (unsigned __int32 *)((char *)v18 + v27 + v56);
  unint64_t v20 = (_DWORD *)((char *)v20 + v27 + v56);
LABEL_40:
  uint64_t v75 = v17 + a15;
  if (v75)
  {
    if (a7) {
      unsigned int v76 = 0;
    }
    else {
      unsigned int v76 = -1;
    }
    int8x8_t v77 = vdup_n_s8(v76);
    if (a8) {
      unsigned int v78 = 0;
    }
    else {
      unsigned int v78 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(v77, (int8x8_t)0xFF000000FFLL);
    int8x8_t v79 = vand_s8(vdup_n_s8(v78), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v80 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a14.i32[0] = *v18;
      uint16x8_t v81 = vmovl_u8(*(uint8x8_t *)a14.i8);
      LOBYTE(v82) = v81.i8[0];
      BYTE1(v82) = v81.i8[2];
      BYTE2(v82) = v81.i8[4];
      HIBYTE(v82) = v81.i8[6];
      v81.i32[0] = *v20;
      uint16x8_t v83 = vmovl_u8(*(uint8x8_t *)v81.i8);
      LOBYTE(v84) = v83.i8[0];
      BYTE1(v84) = v83.i8[2];
      BYTE2(v84) = v83.i8[4];
      HIBYTE(v84) = v83.i8[6];
      v83.i8[7] = 0;
      v83.i8[0] = *v21;
      v83.i8[1] = *v21;
      v83.i8[2] = *v21;
      *(__int32 *)((char *)v83.i32 + 3) = *v21;
      int8x8_t v85 = vorr_s8(vbic_s8(v79, vceqz_s8(*(int8x8_t *)v83.i8)), (int8x8_t)v84);
      uint16x8_t v86 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v82, *(int8x8_t *)a9.i8), *(uint8x8_t *)v83.i8), v80);
      a14 = vrsraq_n_u16(v86, v86, 8uLL);
      int8x8_t v87 = (int8x8_t)vqrshrn_n_u16(a14, 8uLL);
      *(int8x8_t *)a14.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v87, a14, 8uLL), (int8x8_t)0x404040400000000);
      *(int8x8_t *)v88.i8 = v85;
      v88.u64[1] = (unint64_t)v85;
      *(int8x8_t *)v88.i8 = vqtbl1_s8(v88, (int8x8_t)0x404040400000000);
      int8x8_t v89 = (int8x8_t)vmin_u8((uint8x8_t)v87, *(uint8x8_t *)a14.i8);
      int8x8_t v90 = (int8x8_t)vmin_u8((uint8x8_t)v85, *(uint8x8_t *)v88.i8);
      int8x16_t v91 = (int8x16_t)vqaddq_u16(vmull_u8((uint8x8_t)vsub_s8(*(int8x8_t *)a14.i8, v89), (uint8x8_t)v90), vmull_u8((uint8x8_t)vsub_s8(*(int8x8_t *)v88.i8, v90), (uint8x8_t)v89));
      uint16x8_t v92 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_s8((int8x8_t)vcgt_u8(vrhadd_u8(*(uint8x8_t *)v88.i8, 0), (uint8x8_t)v90)), v91, (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)a14.i8, *(uint8x8_t *)v88.i8), (uint16x8_t)v91)), v80);
      *(int8x8_t *)a14.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)a14.i8), v85, vbsl_s8(vceqz_s8(*(int8x8_t *)v88.i8), v87, vsub_s8(vadd_s8(v90, v89), (int8x8_t)vqrshrn_n_u16(vrsraq_n_u16(v92, v92, 8uLL), 8uLL))));
      *(int8x8_t *)a14.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a14, a9));
      _DWORD *v20 = a14.i32[0];
      int8x16_t v93 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v93 >= v19) {
        uint64_t v94 = -(uint64_t)a5;
      }
      else {
        uint64_t v94 = 0;
      }
      unint64_t v18 = &v93[v94];
      v20 += a6;
      --v75;
    }
    while (v75);
  }
  _WORD *result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)14,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, uint16x8_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFF000000FFLL;
  v22.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v21), v22);
  if (a8) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  int8x16_t v24 = vandq_s8(vdupq_n_s8(v23), v22);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a13.i64[0] = -1;
  a13.i64[1] = -1;
  while (1)
  {
    __int32 v28 = *(_DWORD *)v20;
    if (*(_DWORD *)v20 == -1)
    {
      int64_t v35 = (unsigned __int8 *)&v20[v16];
      int64_t v36 = (int8x16_t *)v20;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, (int8x16_t)a13)) & 0x80) != 0);
      do
      {
        int64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          int64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            int64_t v38 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v20;
      unint64_t v41 = (char *)v38 - v20;
      do
      {
        int8x16_t v42 = vorrq_s8(*(int8x16_t *)((char *)v17 + v39), a9);
        int8x16_t v43 = vorrq_s8(*(int8x16_t *)((char *)v19 + v39), v24);
        uint8x16_t v44 = (uint8x16_t)vbicq_s8(v43, vceqzq_s8(vqtbl1q_s8(v43, (int8x16_t)xmmword_1850CE030)));
        uint16x8_t v45 = vminq_u16(vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v44.i8), v27);
        uint16x8_t v46 = vminq_u16(vmull_high_u8((uint8x16_t)v42, v44), v27);
        int8x16_t v15 = vceqzq_s8(vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CE030));
        *(int8x16_t *)((char *)v19 + v39) = vbslq_s8(v15, v43, (int8x16_t)vqaddq_u8(vqsubq_u8((uint8x16_t)v42, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v45, v45, 8uLL), 8uLL), vrsraq_n_u16(v46, v46, 8uLL), 8uLL)), v44));
        v20 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      unint64_t v19 = (_DWORD *)((char *)v19 + v39);
      unint64_t v17 = (unsigned __int32 *)((char *)v17 + v39);
      unint64_t v16 = v16 - v40 + v41;
      goto LABEL_37;
    }
    if (v28) {
      break;
    }
    __int32 v29 = (unsigned __int8 *)&v20[v16];
    int8x16_t v30 = (int8x16_t *)v20;
    do
      __int32 v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      __int32 v32 = v31;
      __int32 v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        __int32 v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          __int32 v32 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v20;
    int64_t v34 = ((char *)v32 - v20) * a6;
    v17 += v34;
    v19 += v34;
    v20 += v34;
    v16 -= v33;
LABEL_37:
    if (v16 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v47 = 0;
  while (1)
  {
    v15.i32[0] = v28;
    int8x16_t v48 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v49 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v17 + v47), a9);
    int8x16_t v50 = vorrq_s8(vbicq_s8(v24, vceqzq_s8(v48)), *(int8x16_t *)((char *)v19 + v47));
    v76.val[1] = (int8x16_t)vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v48.i8);
    uint16x8_t v51 = vmull_high_u8(v49, (uint8x16_t)v48);
    uint16x8_t v52 = vminq_u16((uint16x8_t)v76.val[1], v27);
    uint16x8_t v53 = vminq_u16(v51, v27);
    v76.val[0] = (int8x16_t)vrsraq_n_u16(v52, v52, 8uLL);
    uint16x8_t v54 = vrsraq_n_u16(v53, v53, 8uLL);
    *(uint8x8_t *)v76.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v76.val[0], 8uLL);
    *(uint8x8_t *)v76.val[1].i8 = vqrshrn_n_u16(v54, 8uLL);
    int8x16_t v55 = vqtbl2q_s8(v76, (int8x16_t)xmmword_1850CE040);
    int8x16_t v56 = vbicq_s8(v50, vceqzq_s8(vqtbl1q_s8(v50, (int8x16_t)xmmword_1850CE030)));
    uint16x8_t v57 = vmull_u8(*(uint8x8_t *)v76.val[0].i8, *(uint8x8_t *)v56.i8);
    v76.val[0] = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v76.val[0].i8, v54, 8uLL);
    uint16x8_t v58 = vminq_u16(v57, v27);
    v76.val[1] = (int8x16_t)vminq_u16(vmull_u8(*(uint8x8_t *)v76.val[1].i8, (uint8x8_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)), v27);
    int8x16_t v59 = (int8x16_t)vqaddq_u8(vqsubq_u8((uint8x16_t)v76.val[0], vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v58, v58, 8uLL), 8uLL), vrsraq_n_u16((uint16x8_t)v76.val[1], (uint16x8_t)v76.val[1], 8uLL), 8uLL)), (uint8x16_t)v56);
    int8x16_t v15 = vceqzq_s8(v55);
    *(int8x16_t *)((char *)v19 + v47) = vbslq_s8(v15, v50, v59);
    v20 += v25;
    v16 -= 4;
    if (v16 < 4) {
      break;
    }
    __int32 v28 = *(_DWORD *)v20;
    v47 += v26;
    if ((*(_DWORD *)v20 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v17 = (unsigned __int32 *)((char *)v17 + v47);
      unint64_t v19 = (_DWORD *)((char *)v19 + v47);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (unsigned __int32 *)((char *)v17 + v26 + v47);
  unint64_t v19 = (_DWORD *)((char *)v19 + v26 + v47);
LABEL_40:
  uint64_t v60 = v16 + a14;
  if (v60)
  {
    if (a7) {
      unsigned int v61 = 0;
    }
    else {
      unsigned int v61 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v61), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v62 = 0;
    }
    else {
      unsigned int v62 = -1;
    }
    int8x8_t v63 = vand_s8(vdup_n_s8(v62), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v64 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v17;
      uint16x8_t v65 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v66) = v65.i8[0];
      BYTE1(v66) = v65.i8[2];
      BYTE2(v66) = v65.i8[4];
      HIBYTE(v66) = v65.i8[6];
      v65.i32[0] = *v19;
      uint16x8_t v67 = vmovl_u8(*(uint8x8_t *)v65.i8);
      LOBYTE(v68) = v67.i8[0];
      BYTE1(v68) = v67.i8[2];
      BYTE2(v68) = v67.i8[4];
      HIBYTE(v68) = v67.i8[6];
      v67.i8[7] = 0;
      v67.i8[0] = *v20;
      v67.i8[1] = *v20;
      v67.i8[2] = *v20;
      *(__int32 *)((char *)v67.i32 + 3) = *v20;
      int8x8_t v69 = vorr_s8(vbic_s8(v63, vceqz_s8(*(int8x8_t *)v67.i8)), (int8x8_t)v68);
      uint16x8_t v70 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v66, *(int8x8_t *)a9.i8), *(uint8x8_t *)v67.i8), v64);
      a13 = vrsraq_n_u16(v70, v70, 8uLL);
      uint8x8_t v71 = vqrshrn_n_u16(a13, 8uLL);
      *(int8x8_t *)v72.i8 = v69;
      v72.u64[1] = (unint64_t)v69;
      *(int8x8_t *)v72.i8 = vbic_s8(v69, vceqz_s8(vqtbl1_s8(v72, (int8x8_t)0x404040400000000)));
      uint16x8_t v73 = vminq_u16(vmull_u8(v71, *(uint8x8_t *)v72.i8), v64);
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v71, a13, 8uLL), (int8x8_t)0x404040400000000)), v69, (int8x8_t)vqadd_u8(vqsub_u8(v71, vqrshrn_n_u16(vrsraq_n_u16(v73, v73, 8uLL), 8uLL)), *(uint8x8_t *)v72.i8));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a13, a9));
      *unint64_t v19 = a13.i32[0];
      int8x16_t v74 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v74 >= v18) {
        uint64_t v75 = -(uint64_t)a5;
      }
      else {
        uint64_t v75 = 0;
      }
      unint64_t v17 = &v74[v75];
      v19 += a6;
      --v60;
    }
    while (v60);
  }
  _WORD *result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)13,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, uint16x8_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFF000000FFLL;
  v22.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v21), v22);
  if (a8) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  int8x16_t v24 = vandq_s8(vdupq_n_s8(v23), v22);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a13.i64[0] = -1;
  a13.i64[1] = -1;
  while (1)
  {
    __int32 v28 = *(_DWORD *)v20;
    if (*(_DWORD *)v20 == -1)
    {
      int64_t v35 = (unsigned __int8 *)&v20[v16];
      int64_t v36 = (int8x16_t *)v20;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, (int8x16_t)a13)) & 0x80) != 0);
      do
      {
        int64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          int64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            int64_t v38 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v20;
      unint64_t v41 = (char *)v38 - v20;
      do
      {
        int8x16_t v42 = vorrq_s8(*(int8x16_t *)((char *)v17 + v39), a9);
        int8x16_t v43 = vorrq_s8(*(int8x16_t *)((char *)v19 + v39), v24);
        int8x16_t v44 = vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CE030);
        int8x16_t v45 = vqtbl1q_s8(v43, (int8x16_t)xmmword_1850CE030);
        int8x16_t v46 = vceqzq_s8(v45);
        uint8x16_t v47 = (uint8x16_t)vbicq_s8(v43, v46);
        uint16x8_t v48 = vminq_u16(vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v47.i8), v27);
        uint16x8_t v49 = vminq_u16(vmull_high_u8((uint8x16_t)v42, v47), v27);
        uint8x16_t v50 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v48, v48, 8uLL), 8uLL), vrsraq_n_u16(v49, v49, 8uLL), 8uLL);
        uint8x16_t v51 = (uint8x16_t)vmvnq_s8(v45);
        uint8x16_t v52 = (uint8x16_t)vmvnq_s8(v44);
        uint16x8_t v53 = vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v51.i8);
        uint16x8_t v54 = vqaddq_u16(vmull_high_u8((uint8x16_t)v42, v51), vmull_high_u8(v47, v52));
        uint16x8_t v55 = vminq_u16(vqaddq_u16(v53, vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v52.i8)), v27);
        uint16x8_t v56 = vminq_u16(v54, v27);
        int8x16_t v15 = vceqzq_s8(v44);
        *(int8x16_t *)((char *)v19 + v39) = vbslq_s8(v15, v43, vbslq_s8(v46, v42, (int8x16_t)vqaddq_u8(v50, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v55, v55, 8uLL), 8uLL), vrsraq_n_u16(v56, v56, 8uLL), 8uLL))));
        v20 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      unint64_t v19 = (_DWORD *)((char *)v19 + v39);
      unint64_t v17 = (unsigned __int32 *)((char *)v17 + v39);
      unint64_t v16 = v16 - v40 + v41;
      goto LABEL_37;
    }
    if (v28) {
      break;
    }
    __int32 v29 = (unsigned __int8 *)&v20[v16];
    int8x16_t v30 = (int8x16_t *)v20;
    do
      __int32 v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      __int32 v32 = v31;
      __int32 v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        __int32 v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          __int32 v32 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v20;
    int64_t v34 = ((char *)v32 - v20) * a6;
    v17 += v34;
    v19 += v34;
    v20 += v34;
    v16 -= v33;
LABEL_37:
    if (v16 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v57 = 0;
  while (1)
  {
    v15.i32[0] = v28;
    int8x16_t v58 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v59 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v17 + v57), a9);
    int8x16_t v60 = vorrq_s8(vbicq_s8(v24, vceqzq_s8(v58)), *(int8x16_t *)((char *)v19 + v57));
    v98.val[1] = (int8x16_t)vmull_u8(*(uint8x8_t *)v59.i8, *(uint8x8_t *)v58.i8);
    uint16x8_t v61 = vmull_high_u8(v59, (uint8x16_t)v58);
    uint16x8_t v62 = vminq_u16((uint16x8_t)v98.val[1], v27);
    uint16x8_t v63 = vminq_u16(v61, v27);
    v98.val[0] = (int8x16_t)vrsraq_n_u16(v62, v62, 8uLL);
    uint16x8_t v64 = vrsraq_n_u16(v63, v63, 8uLL);
    *(uint8x8_t *)v98.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v98.val[0], 8uLL);
    *(uint8x8_t *)v98.val[1].i8 = vqrshrn_n_u16(v64, 8uLL);
    int8x16_t v65 = vqtbl2q_s8(v98, (int8x16_t)xmmword_1850CE040);
    int8x16_t v66 = vqtbl1q_s8(v60, (int8x16_t)xmmword_1850CE030);
    int8x16_t v67 = vceqzq_s8(v66);
    int8x16_t v68 = vbicq_s8(v60, v67);
    uint16x8_t v69 = vmull_u8(*(uint8x8_t *)v98.val[0].i8, *(uint8x8_t *)v68.i8);
    int8x16_t v70 = vmvnq_s8(v66);
    uint16x8_t v71 = vmull_u8(*(uint8x8_t *)v98.val[0].i8, *(uint8x8_t *)v70.i8);
    uint16x8_t v72 = vmull_u8(*(uint8x8_t *)v98.val[1].i8, (uint8x8_t)*(_OWORD *)&vextq_s8(v70, v70, 8uLL));
    v98.val[0] = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v98.val[0].i8, v64, 8uLL);
    uint16x8_t v73 = vminq_u16(v69, v27);
    v98.val[1] = (int8x16_t)vminq_u16(vmull_u8(*(uint8x8_t *)v98.val[1].i8, (uint8x8_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL)), v27);
    uint8x16_t v74 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v73, v73, 8uLL), 8uLL), vrsraq_n_u16((uint16x8_t)v98.val[1], (uint16x8_t)v98.val[1], 8uLL), 8uLL);
    v98.val[1] = vmvnq_s8(v65);
    uint16x8_t v75 = vmull_u8(*(uint8x8_t *)v68.i8, *(uint8x8_t *)v98.val[1].i8);
    v98.val[1] = (int8x16_t)vqaddq_u16(v72, vmull_high_u8((uint8x16_t)v68, (uint8x16_t)v98.val[1]));
    uint16x8_t v76 = vminq_u16(vqaddq_u16(v71, v75), v27);
    v98.val[1] = (int8x16_t)vminq_u16((uint16x8_t)v98.val[1], v27);
    int8x16_t v77 = vbslq_s8(v67, v98.val[0], (int8x16_t)vqaddq_u8(v74, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v76, v76, 8uLL), 8uLL), vrsraq_n_u16((uint16x8_t)v98.val[1], (uint16x8_t)v98.val[1], 8uLL), 8uLL)));
    int8x16_t v15 = vceqzq_s8(v65);
    *(int8x16_t *)((char *)v19 + v57) = vbslq_s8(v15, v60, v77);
    v20 += v25;
    v16 -= 4;
    if (v16 < 4) {
      break;
    }
    __int32 v28 = *(_DWORD *)v20;
    v57 += v26;
    if ((*(_DWORD *)v20 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v17 = (unsigned __int32 *)((char *)v17 + v57);
      unint64_t v19 = (_DWORD *)((char *)v19 + v57);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (unsigned __int32 *)((char *)v17 + v26 + v57);
  unint64_t v19 = (_DWORD *)((char *)v19 + v26 + v57);
LABEL_40:
  uint64_t v78 = v16 + a14;
  if (v78)
  {
    if (a7) {
      unsigned int v79 = 0;
    }
    else {
      unsigned int v79 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v79), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v80 = 0;
    }
    else {
      unsigned int v80 = -1;
    }
    int8x8_t v81 = vand_s8(vdup_n_s8(v80), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v82 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v17;
      uint16x8_t v83 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v84) = v83.i8[0];
      BYTE1(v84) = v83.i8[2];
      BYTE2(v84) = v83.i8[4];
      HIBYTE(v84) = v83.i8[6];
      v83.i32[0] = *v19;
      uint16x8_t v85 = vmovl_u8(*(uint8x8_t *)v83.i8);
      LOBYTE(v86) = v85.i8[0];
      BYTE1(v86) = v85.i8[2];
      BYTE2(v86) = v85.i8[4];
      HIBYTE(v86) = v85.i8[6];
      v85.i8[7] = 0;
      v85.i8[0] = *v20;
      v85.i8[1] = *v20;
      v85.i8[2] = *v20;
      *(__int32 *)((char *)v85.i32 + 3) = *v20;
      int8x8_t v87 = vorr_s8(vbic_s8(v81, vceqz_s8(*(int8x8_t *)v85.i8)), (int8x8_t)v86);
      uint16x8_t v88 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v84, *(int8x8_t *)a9.i8), *(uint8x8_t *)v85.i8), v82);
      int8x16_t v89 = (int8x16_t)vrsraq_n_u16(v88, v88, 8uLL);
      int8x8_t v90 = (int8x8_t)vqrshrn_n_u16((uint16x8_t)v89, 8uLL);
      int8x16_t v91 = (int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v90, (uint16x8_t)v89, 8uLL);
      *(int8x8_t *)v89.i8 = v87;
      v89.u64[1] = (unint64_t)v87;
      *(int8x8_t *)v91.i8 = vqtbl1_s8(v91, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v89.i8 = vqtbl1_s8(v89, (int8x8_t)0x404040400000000);
      int8x8_t v92 = vceqz_s8(*(int8x8_t *)v89.i8);
      uint8x8_t v93 = (uint8x8_t)vbic_s8(v87, v92);
      uint16x8_t v94 = vminq_u16(vmull_u8((uint8x8_t)v90, v93), v82);
      uint16x8_t v95 = vminq_u16(vqaddq_u16(vmull_u8((uint8x8_t)v90, (uint8x8_t)vmvn_s8(*(int8x8_t *)v89.i8)), vmull_u8(v93, (uint8x8_t)vmvn_s8(*(int8x8_t *)v91.i8))), v82);
      a13 = vrsraq_n_u16(v95, v95, 8uLL);
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v91.i8), v87, vbsl_s8(v92, v90, (int8x8_t)vqadd_u8(vqrshrn_n_u16(vrsraq_n_u16(v94, v94, 8uLL), 8uLL), vqrshrn_n_u16(a13, 8uLL))));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a13, a9));
      *unint64_t v19 = a13.i32[0];
      uint16x8_t v96 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v96 >= v18) {
        uint64_t v97 = -(uint64_t)a5;
      }
      else {
        uint64_t v97 = 0;
      }
      unint64_t v17 = &v96[v97];
      v19 += a6;
      --v78;
    }
    while (v78);
  }
  _WORD *result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)12,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int8x16_t a8, double a9, uint8x8_t a10, double a11, double a12, double a13, uint8x16_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a17 < 4) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v22 = 0;
  }
  else {
    unsigned int v22 = -1;
  }
  v23.i64[0] = 0xFF000000FFLL;
  v23.i64[1] = 0xFF000000FFLL;
  a8 = vandq_s8(vdupq_n_s8(v22), v23);
  uint64_t v24 = 4 * a6;
  uint64_t v25 = 16 * a6;
  v26.i64[0] = -1;
  v26.i64[1] = -1;
  a10.i32[1] = 16843009;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  while (1)
  {
    unsigned __int32 v28 = *(_DWORD *)v21;
    if (*(_DWORD *)v21 == -1)
    {
      int64_t v35 = (unsigned __int8 *)&v21[v17];
      int64_t v36 = (int8x16_t *)v21;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, v26)) & 0x80) != 0);
      do
      {
        int64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          int64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            int64_t v38 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v21;
      unint64_t v41 = (char *)v38 - v21;
      do
      {
        *(uint8x16_t *)((char *)v20 + v39) = vqaddq_u8(*(uint8x16_t *)((char *)v20 + v39), (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v18 + v39), a8));
        v21 += v24;
        v41 -= 4;
        v39 += v25;
      }
      while (v41 > 3);
      unint64_t v20 = (_DWORD *)((char *)v20 + v39);
      unint64_t v18 = (_DWORD *)((char *)v18 + v39);
      unint64_t v17 = v17 - v40 + v41;
      goto LABEL_34;
    }
    if (v28) {
      break;
    }
    __int32 v29 = (unsigned __int8 *)&v21[v17];
    int8x16_t v30 = (int8x16_t *)v21;
    do
      __int32 v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      __int32 v32 = v31;
      __int32 v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        __int32 v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          __int32 v32 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v21;
    int64_t v34 = ((char *)v32 - v21) * a6;
    v18 += v34;
    v20 += v34;
    v21 += v34;
    v17 -= v33;
LABEL_34:
    if (v17 <= 3) {
      goto LABEL_37;
    }
  }
  uint64_t v42 = 0;
  while (1)
  {
    a14.i32[0] = v28;
    uint8x16_t v43 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a14, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v44 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v18 + v42), a8);
    uint16x8_t v45 = vmull_u8(*(uint8x8_t *)v44.i8, *(uint8x8_t *)v43.i8);
    uint16x8_t v46 = vmull_high_u8(v44, v43);
    uint16x8_t v47 = vminq_u16(v45, v27);
    uint16x8_t v48 = vminq_u16(v46, v27);
    a14 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v47, v47, 8uLL), 8uLL), vrsraq_n_u16(v48, v48, 8uLL), 8uLL);
    *(uint8x16_t *)((char *)v20 + v42) = vqaddq_u8(*(uint8x16_t *)((char *)v20 + v42), a14);
    v21 += v24;
    v17 -= 4;
    if (v17 < 4) {
      break;
    }
    unsigned __int32 v28 = *(_DWORD *)v21;
    v42 += v25;
    if ((*(_DWORD *)v21 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v18 = (_DWORD *)((char *)v18 + v42);
      unint64_t v20 = (_DWORD *)((char *)v20 + v42);
      goto LABEL_34;
    }
  }
  unint64_t v18 = (_DWORD *)((char *)v18 + v25 + v42);
  unint64_t v20 = (_DWORD *)((char *)v20 + v25 + v42);
LABEL_37:
  uint64_t v49 = v17 + a16;
  if (v49)
  {
    if (a7) {
      unsigned int v50 = 0;
    }
    else {
      unsigned int v50 = -1;
    }
    *(int8x8_t *)a8.i8 = vand_s8(vdup_n_s8(v50), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v51 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a10.i32[0] = *v18;
      uint16x8_t v52 = vmovl_u8(a10);
      LOBYTE(v53) = v52.i8[0];
      BYTE1(v53) = v52.i8[2];
      BYTE2(v53) = v52.i8[4];
      HIBYTE(v53) = v52.i8[6];
      v52.i32[0] = *v20;
      uint16x8_t v54 = vmovl_u8(*(uint8x8_t *)v52.i8);
      LOBYTE(v55) = v54.i8[0];
      BYTE1(v55) = v54.i8[2];
      BYTE2(v55) = v54.i8[4];
      HIBYTE(v55) = v54.i8[6];
      v54.i8[7] = 0;
      v54.i8[0] = *v21;
      v54.i8[1] = *v21;
      v54.i8[2] = *v21;
      *(__int32 *)((char *)v54.i32 + 3) = *v21;
      uint16x8_t v56 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v53, *(int8x8_t *)a8.i8), *(uint8x8_t *)v54.i8), v51);
      int8x16_t v57 = (int8x16_t)vrsraq_n_u16(v56, v56, 8uLL);
      *(uint8x8_t *)v57.i8 = vqadd_u8((uint8x8_t)v55, vqrshrn_n_u16((uint16x8_t)v57, 8uLL));
      a10 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v57, a8));
      _DWORD *v20 = a10.i32[0];
      int8x16_t v58 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v58 >= v19) {
        uint64_t v59 = -(uint64_t)a5;
      }
      else {
        uint64_t v59 = 0;
      }
      unint64_t v18 = &v58[v59];
      v20 += a6;
      --v49;
    }
    while (v49);
  }
  _WORD *result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)11,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, int8x16_t a9, double a10, double a11, double a12, uint8x8_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v17 = a15;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a15 < 4) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v22 = 0;
  }
  else {
    unsigned int v22 = -1;
  }
  v23.i64[0] = 0xFF000000FFLL;
  v23.i64[1] = 0xFF000000FFLL;
  a9 = vandq_s8(vdupq_n_s8(v22), v23);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8(vdupq_n_s8(v24), v23);
  uint64_t v26 = 4 * a6;
  uint64_t v27 = 16 * a6;
  v28.i64[0] = -1;
  v28.i64[1] = -1;
  a13.i32[1] = 16843009;
  uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  while (1)
  {
    __int32 v30 = *(_DWORD *)v21;
    if (*(_DWORD *)v21 == -1)
    {
      int64_t v37 = (unsigned __int8 *)&v21[v17];
      int64_t v38 = (int8x16_t *)v21;
      do
        uint64_t v39 = v38++;
      while (v38 <= (int8x16_t *)v37 && (vminvq_u8((uint8x16_t)vceqq_s8(*v39, v28)) & 0x80) != 0);
      do
      {
        int64_t v40 = v39;
        uint64_t v39 = (int8x16_t *)((char *)v39 + 4);
      }
      while (v39 <= (int8x16_t *)v37 && v40->i32[0] == -1);
      if (v40 < (int8x16_t *)v37)
      {
        while (v40->u8[0] == 255)
        {
          int64_t v40 = (int8x16_t *)((char *)v40 + 1);
          if (v40 >= (int8x16_t *)v37)
          {
            int64_t v40 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      uint64_t v41 = 0;
      int64_t v42 = (char *)v40 - v21;
      unint64_t v43 = (char *)v40 - v21;
      do
      {
        int8x16_t v44 = vorrq_s8(*(int8x16_t *)((char *)v18 + v41), a9);
        int8x16_t v45 = vorrq_s8(*(int8x16_t *)((char *)v20 + v41), v25);
        int8x16_t v15 = vqtbl1q_s8(v44, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v46 = (uint8x16_t)vqtbl1q_s8(v45, (int8x16_t)xmmword_1850CE030);
        *(uint8x16_t *)((char *)v20 + v41) = vqsubq_u8(vqaddq_u8(v46, (uint8x16_t)v15), vqaddq_u8(vqsubq_u8((uint8x16_t)v15, (uint8x16_t)v44), vqsubq_u8(v46, (uint8x16_t)v45)));
        v21 += v26;
        v43 -= 4;
        v41 += v27;
      }
      while (v43 > 3);
      unint64_t v20 = (_DWORD *)((char *)v20 + v41);
      unint64_t v18 = (_DWORD *)((char *)v18 + v41);
      unint64_t v17 = v17 - v42 + v43;
      goto LABEL_37;
    }
    if (v30) {
      break;
    }
    __int32 v31 = (unsigned __int8 *)&v21[v17];
    __int32 v32 = (int8x16_t *)v21;
    do
      int64_t v33 = v32++;
    while (v32 <= (int8x16_t *)v31 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v33)) & 0x80) != 0);
    do
    {
      int64_t v34 = v33;
      int64_t v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= (int8x16_t *)v31 && !v34->i32[0]);
    if (v34 < (int8x16_t *)v31)
    {
      while (!v34->i8[0])
      {
        int64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= (int8x16_t *)v31)
        {
          int64_t v34 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    int64_t v35 = (char *)v34 - v21;
    int64_t v36 = ((char *)v34 - v21) * a6;
    v18 += v36;
    v20 += v36;
    v21 += v36;
    v17 -= v35;
LABEL_37:
    if (v17 <= 3) {
      goto LABEL_40;
    }
  }
  uint64_t v47 = 0;
  while (1)
  {
    int8x16_t v48 = *(int8x16_t *)((char *)v20 + v47);
    v15.i32[0] = v30;
    int8x16_t v49 = vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v50 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v18 + v47), a9);
    int8x16_t v51 = vceqzq_s8(v49);
    int8x16_t v52 = vorrq_s8(vbicq_s8(v25, v51), v48);
    uint16x8_t v53 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v49.i8);
    uint16x8_t v54 = vmull_high_u8(v50, (uint8x16_t)v49);
    uint16x8_t v55 = vminq_u16(v53, v29);
    uint16x8_t v56 = vminq_u16(v54, v29);
    uint16x8_t v57 = vrsraq_n_u16(v56, v56, 8uLL);
    *(uint8x8_t *)v53.i8 = vqrshrn_n_u16(vrsraq_n_u16(v55, v55, 8uLL), 8uLL);
    *(uint8x8_t *)v16.i8 = vqrshrn_n_u16(v57, 8uLL);
    uint8x16_t v58 = (uint8x16_t)vqtbl2q_s8(*(int8x16x2_t *)(&v16 - 1), (int8x16_t)xmmword_1850CE040);
    uint8x16_t v59 = vqrshrn_high_n_u16(*(uint8x8_t *)v53.i8, v57, 8uLL);
    uint8x16_t v60 = (uint8x16_t)vqtbl1q_s8(v52, (int8x16_t)xmmword_1850CE030);
    uint8x16_t v16 = vqaddq_u8(v60, v58);
    int8x16_t v15 = (int8x16_t)vqsubq_u8(v58, v59);
    *(int8x16_t *)((char *)v20 + v47) = vbslq_s8(v51, v48, (int8x16_t)vqsubq_u8(v16, vqaddq_u8((uint8x16_t)v15, vqsubq_u8(v60, (uint8x16_t)v52))));
    v21 += v26;
    v17 -= 4;
    if (v17 < 4) {
      break;
    }
    __int32 v30 = *(_DWORD *)v21;
    v47 += v27;
    if ((*(_DWORD *)v21 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v18 = (_DWORD *)((char *)v18 + v47);
      unint64_t v20 = (_DWORD *)((char *)v20 + v47);
      goto LABEL_37;
    }
  }
  unint64_t v18 = (_DWORD *)((char *)v18 + v27 + v47);
  unint64_t v20 = (_DWORD *)((char *)v20 + v27 + v47);
LABEL_40:
  uint64_t v61 = v17 + a14;
  if (v61)
  {
    if (a7) {
      unsigned int v62 = 0;
    }
    else {
      unsigned int v62 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v62), (int8x8_t)0xFF000000FFLL);
    if (a8) {
      unsigned int v63 = 0;
    }
    else {
      unsigned int v63 = -1;
    }
    int8x8_t v64 = vand_s8(vdup_n_s8(v63), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v65 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v18;
      uint16x8_t v66 = vmovl_u8(a13);
      LOBYTE(v67) = v66.i8[0];
      BYTE1(v67) = v66.i8[2];
      BYTE2(v67) = v66.i8[4];
      HIBYTE(v67) = v66.i8[6];
      v66.i32[0] = *v20;
      uint16x8_t v68 = vmovl_u8(*(uint8x8_t *)v66.i8);
      LOBYTE(v69) = v68.i8[0];
      BYTE1(v69) = v68.i8[2];
      BYTE2(v69) = v68.i8[4];
      HIBYTE(v69) = v68.i8[6];
      v68.i8[7] = 0;
      v68.i8[0] = *v21;
      v68.i8[1] = *v21;
      v68.i8[2] = *v21;
      *(__int32 *)((char *)v68.i32 + 3) = *v21;
      int8x8_t v70 = vceqz_s8(*(int8x8_t *)v68.i8);
      uint8x8_t v71 = (uint8x8_t)vorr_s8(vbic_s8(v64, v70), (int8x8_t)v69);
      uint16x8_t v72 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v67, *(int8x8_t *)a9.i8), *(uint8x8_t *)v68.i8), v65);
      int8x16_t v73 = (int8x16_t)vrsraq_n_u16(v72, v72, 8uLL);
      uint8x8_t v74 = vqrshrn_n_u16((uint16x8_t)v73, 8uLL);
      int8x16_t v75 = (int8x16_t)vqrshrn_high_n_u16(v74, (uint16x8_t)v73, 8uLL);
      *(uint8x8_t *)v73.i8 = v71;
      v73.u64[1] = (unint64_t)v71;
      *(int8x8_t *)v75.i8 = vqtbl1_s8(v75, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v73.i8 = vqtbl1_s8(v73, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v73.i8 = vbsl_s8(v70, (int8x8_t)v69, (int8x8_t)vqsub_u8(vqadd_u8(*(uint8x8_t *)v73.i8, *(uint8x8_t *)v75.i8), vqadd_u8(vqsub_u8(*(uint8x8_t *)v75.i8, v74), vqsub_u8(*(uint8x8_t *)v73.i8, v71))));
      a13 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v73, a9));
      _DWORD *v20 = a13.i32[0];
      uint16x8_t v76 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v76 >= v19) {
        uint64_t v77 = -(uint64_t)a5;
      }
      else {
        uint64_t v77 = 0;
      }
      unint64_t v18 = &v76[v77];
      v20 += a6;
      --v61;
    }
    while (v61);
  }
  _WORD *result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)10,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, uint16x8_t a9, double a10, double a11, double a12, double a13, uint16x8_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v19 = a18;
  unint64_t v20 = *result;
  unint64_t v21 = *a3;
  unsigned int v22 = *a2;
  int8x16_t v23 = *a4;
  if (a18 < 4) {
    goto LABEL_34;
  }
  uint64_t v24 = 4 * a6;
  uint64_t v25 = 16 * a6;
  uint16x8_t v26 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v27 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 == -1)
    {
      int64_t v34 = (unsigned __int8 *)&v23[v19];
      int64_t v35 = (int8x16_t *)v23;
      do
        int64_t v36 = v35++;
      while (v35 <= (int8x16_t *)v34 && (vminvq_u8((uint8x16_t)vceqq_s8(*v36, (int8x16_t)a9)) & 0x80) != 0);
      do
      {
        int64_t v37 = v36;
        int64_t v36 = (int8x16_t *)((char *)v36 + 4);
      }
      while (v36 <= (int8x16_t *)v34 && v37->i32[0] == -1);
      if (v37 < (int8x16_t *)v34)
      {
        while (v37->u8[0] == 255)
        {
          int64_t v37 = (int8x16_t *)((char *)v37 + 1);
          if (v37 >= (int8x16_t *)v34)
          {
            int64_t v37 = (int8x16_t *)&v23[v19];
            break;
          }
        }
      }
      uint64_t v38 = 0;
      int64_t v39 = (char *)v37 - v23;
      unint64_t v40 = (char *)v37 - v23;
      do
      {
        int8x16_t v41 = *(int8x16_t *)((char *)v20 + v38);
        int8x16_t v42 = *(int8x16_t *)((char *)v22 + v38);
        uint8x16_t v43 = (uint8x16_t)vqtbl1q_s8(vmvnq_s8(v42), (int8x16_t)xmmword_1850CE030);
        uint8x16_t v44 = (uint8x16_t)vqtbl1q_s8(vmvnq_s8(v41), (int8x16_t)xmmword_1850CE030);
        uint16x8_t v18 = vmull_u8(*(uint8x8_t *)v41.i8, *(uint8x8_t *)v43.i8);
        uint16x8_t v45 = vmull_high_u8((uint8x16_t)v41, v43);
        a14 = vqaddq_u16(v18, vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v44.i8));
        uint16x8_t v46 = vqaddq_u16(v45, vmull_high_u8((uint8x16_t)v42, v44));
        uint16x8_t v47 = vminq_u16(a14, v26);
        uint16x8_t v48 = vminq_u16(v46, v26);
        *(uint8x16_t *)((char *)v22 + v38) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v47, v47, 8uLL), 8uLL), vrsraq_n_u16(v48, v48, 8uLL), 8uLL);
        v23 += v24;
        v40 -= 4;
        v38 += v25;
      }
      while (v40 > 3);
      unsigned int v22 = (_DWORD *)((char *)v22 + v38);
      unint64_t v20 = (unsigned __int32 *)((char *)v20 + v38);
      unint64_t v19 = v19 - v39 + v40;
      goto LABEL_31;
    }
    if (v27) {
      break;
    }
    int8x16_t v28 = (unsigned __int8 *)&v23[v19];
    uint16x8_t v29 = (int8x16_t *)v23;
    do
      __int32 v30 = v29++;
    while (v29 <= (int8x16_t *)v28 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v30)) & 0x80) != 0);
    do
    {
      __int32 v31 = v30;
      __int32 v30 = (int8x16_t *)((char *)v30 + 4);
    }
    while (v30 <= (int8x16_t *)v28 && !v31->i32[0]);
    if (v31 < (int8x16_t *)v28)
    {
      while (!v31->i8[0])
      {
        __int32 v31 = (int8x16_t *)((char *)v31 + 1);
        if (v31 >= (int8x16_t *)v28)
        {
          __int32 v31 = (int8x16_t *)&v23[v19];
          break;
        }
      }
    }
    int64_t v32 = (char *)v31 - v23;
    int64_t v33 = ((char *)v31 - v23) * a6;
    v20 += v33;
    v22 += v33;
    v23 += v33;
    v19 -= v32;
LABEL_31:
    if (v19 <= 3) {
      goto LABEL_34;
    }
  }
  uint64_t v49 = 0;
  while (1)
  {
    uint8x16_t v50 = *(uint8x16_t *)((char *)v20 + v49);
    int8x16_t v51 = *(int8x16_t *)((char *)v22 + v49);
    a14.i32[0] = v27;
    uint8x16_t v52 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a14, (int8x16_t)xmmword_1850CD8E0);
    uint16x8_t v53 = vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v52.i8);
    uint16x8_t v54 = vmull_high_u8(v50, v52);
    uint16x8_t v55 = vminq_u16(v53, v26);
    uint16x8_t v56 = vminq_u16(v54, v26);
    *(uint8x8_t *)v53.i8 = vqrshrn_n_u16(vrsraq_n_u16(v55, v55, 8uLL), 8uLL);
    *(uint8x8_t *)v18.i8 = vqrshrn_n_u16(vrsraq_n_u16(v56, v56, 8uLL), 8uLL);
    int8x16_t v57 = vqtbl1q_s8(vmvnq_s8(v51), (int8x16_t)xmmword_1850CE030);
    uint8x16_t v58 = (uint8x16_t)vmvnq_s8(vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CE040));
    uint16x8_t v59 = vmull_u8(*(uint8x8_t *)v53.i8, *(uint8x8_t *)v57.i8);
    a14 = vmull_u8(*(uint8x8_t *)v18.i8, (uint8x8_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL));
    uint16x8_t v60 = vmull_u8(*(uint8x8_t *)v51.i8, *(uint8x8_t *)v58.i8);
    uint16x8_t v61 = vmull_high_u8((uint8x16_t)v51, v58);
    uint16x8_t v62 = vminq_u16(vqaddq_u16(v59, v60), v26);
    uint16x8_t v63 = vminq_u16(vqaddq_u16(a14, v61), v26);
    *(uint8x16_t *)((char *)v22 + v49) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v62, v62, 8uLL), 8uLL), vrsraq_n_u16(v63, v63, 8uLL), 8uLL);
    v23 += v24;
    v19 -= 4;
    if (v19 < 4) {
      break;
    }
    unsigned __int32 v27 = *(_DWORD *)v23;
    v49 += v25;
    if ((*(_DWORD *)v23 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v20 = (unsigned __int32 *)((char *)v20 + v49);
      unsigned int v22 = (_DWORD *)((char *)v22 + v49);
      goto LABEL_31;
    }
  }
  unint64_t v20 = (unsigned __int32 *)((char *)v20 + v25 + v49);
  unsigned int v22 = (_DWORD *)((char *)v22 + v25 + v49);
LABEL_34:
  uint64_t v64 = v19 + a17;
  if (v64)
  {
    int8x16_t v65 = (int8x16_t)vdupq_n_s16(0xFE01u);
    do
    {
      a9.i32[0] = *v20;
      uint16x8_t v66 = vmovl_u8(*(uint8x8_t *)a9.i8);
      LOBYTE(v67) = v66.i8[0];
      BYTE1(v67) = v66.i8[2];
      BYTE2(v67) = v66.i8[4];
      HIBYTE(v67) = v66.i8[6];
      v66.i32[0] = *v22;
      uint16x8_t v68 = vmovl_u8(*(uint8x8_t *)v66.i8);
      LOBYTE(v69) = v68.i8[0];
      BYTE1(v69) = v68.i8[2];
      BYTE2(v69) = v68.i8[4];
      HIBYTE(v69) = v68.i8[6];
      v68.i8[7] = 0;
      v68.i8[0] = *v23;
      v68.i8[1] = *v23;
      v68.i8[2] = *v23;
      *(__int32 *)((char *)v68.i32 + 3) = *v23;
      uint16x8_t v70 = vminq_u16(vmull_u8((uint8x8_t)v67, *(uint8x8_t *)v68.i8), (uint16x8_t)v65);
      *(uint8x8_t *)v70.i8 = vqrshrn_n_u16(vrsraq_n_u16(v70, v70, 8uLL), 8uLL);
      *(int8x8_t *)v71.i8 = vmvn_s8((int8x8_t)v69);
      v71.i64[1] = v71.i64[0];
      *(int8x8_t *)v72.i8 = vmvn_s8(*(int8x8_t *)v70.i8);
      v72.i64[1] = v72.i64[0];
      uint16x8_t v73 = vminq_u16(vqaddq_u16(vmull_u8(*(uint8x8_t *)v70.i8, (uint8x8_t)vqtbl1_s8(v71, (int8x8_t)0x404040400000000)), vmull_u8((uint8x8_t)v69, (uint8x8_t)vqtbl1_s8(v72, (int8x8_t)0x404040400000000))), (uint16x8_t)v65);
      a9 = vrsraq_n_u16(v73, v73, 8uLL);
      *(uint8x8_t *)a9.i8 = vqrshrn_n_u16(a9, 8uLL);
      *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a9, v65));
      *unsigned int v22 = a9.i32[0];
      uint8x8_t v74 = &v20[a6];
      v23 += a6;
      if ((unint64_t)v74 >= v21) {
        uint64_t v75 = -(uint64_t)a5;
      }
      else {
        uint64_t v75 = 0;
      }
      unint64_t v20 = &v74[v75];
      v22 += a6;
      --v64;
    }
    while (v64);
  }
  _WORD *result = v20;
  *a3 = v21;
  *a2 = v22;
  *a4 = v23;
  return result;
}