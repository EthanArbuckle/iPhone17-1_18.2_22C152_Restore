unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)9,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, uint16x8_t a9, double a10, double a11, double a12, double a13, uint16x8_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  uint16x8_t v18;
  unint64_t v19;
  unsigned __int32 *v20;
  unint64_t v21;
  _DWORD *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint16x8_t v26;
  unsigned __int32 v27;
  unsigned __int8 *v28;
  int8x16_t *v29;
  int8x16_t *v30;
  int8x16_t *v31;
  int64_t v32;
  int64_t v33;
  unsigned __int8 *v34;
  int8x16_t *v35;
  int8x16_t *v36;
  int8x16_t *v37;
  uint64_t v38;
  int64_t v39;
  unint64_t v40;
  int8x16_t v41;
  int8x16_t v42;
  uint8x16_t v43;
  uint8x16_t v44;
  uint16x8_t v45;
  uint16x8_t v46;
  uint16x8_t v47;
  uint16x8_t v48;
  uint16x8_t v49;
  uint16x8_t v50;
  uint64_t v51;
  uint8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  uint16x8_t v55;
  uint16x8_t v56;
  uint16x8_t v57;
  uint8x16_t v58;
  int8x16_t v59;
  uint16x8_t v60;
  uint16x8_t v61;
  uint8x16_t v62;
  uint16x8_t v63;
  uint16x8_t v64;
  uint16x8_t v65;
  uint16x8_t v66;
  uint64_t v67;
  int8x16_t v68;
  uint16x8_t v69;
  unsigned int v70;
  uint16x8_t v71;
  unsigned int v72;
  uint16x8_t v73;
  uint16x8_t v74;
  int8x16_t v75;
  uint8x8_t v76;
  uint16x8_t v77;
  unsigned __int32 *v78;
  uint64_t v79;

  v19 = a18;
  v20 = *result;
  v21 = *a3;
  v22 = *a2;
  v23 = *a4;
  if (a18 < 4) {
    goto LABEL_34;
  }
  v24 = 4 * a6;
  v25 = 16 * a6;
  v26 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    v27 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 == -1)
    {
      v34 = (unsigned __int8 *)&v23[v19];
      v35 = (int8x16_t *)v23;
      do
        v36 = v35++;
      while (v35 <= (int8x16_t *)v34 && (vminvq_u8((uint8x16_t)vceqq_s8(*v36, (int8x16_t)a9)) & 0x80) != 0);
      do
      {
        v37 = v36;
        v36 = (int8x16_t *)((char *)v36 + 4);
      }
      while (v36 <= (int8x16_t *)v34 && v37->i32[0] == -1);
      if (v37 < (int8x16_t *)v34)
      {
        while (v37->u8[0] == 255)
        {
          v37 = (int8x16_t *)((char *)v37 + 1);
          if (v37 >= (int8x16_t *)v34)
          {
            v37 = (int8x16_t *)&v23[v19];
            break;
          }
        }
      }
      v38 = 0;
      v39 = (char *)v37 - v23;
      v40 = (char *)v37 - v23;
      do
      {
        v41 = *(int8x16_t *)((char *)v20 + v38);
        v42 = *(int8x16_t *)((char *)v22 + v38);
        v43 = (uint8x16_t)vqtbl1q_s8(v41, (int8x16_t)xmmword_1850CE030);
        v44 = (uint8x16_t)vqtbl1q_s8(vmvnq_s8(v42), (int8x16_t)xmmword_1850CE030);
        v18 = vmull_u8(*(uint8x8_t *)v41.i8, *(uint8x8_t *)v44.i8);
        v45 = vmull_high_u8((uint8x16_t)v41, v44);
        v46 = vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v43.i8);
        v47 = vmull_high_u8((uint8x16_t)v42, v43);
        a14 = vqaddq_u16(v18, v46);
        v48 = vqaddq_u16(v45, v47);
        v49 = vminq_u16(a14, v26);
        v50 = vminq_u16(v48, v26);
        *(uint8x16_t *)((char *)v22 + v38) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v49, v49, 8uLL), 8uLL), vrsraq_n_u16(v50, v50, 8uLL), 8uLL);
        v23 += v24;
        v40 -= 4;
        v38 += v25;
      }
      while (v40 > 3);
      v22 = (_DWORD *)((char *)v22 + v38);
      v20 = (unsigned __int32 *)((char *)v20 + v38);
      v19 = v19 - v39 + v40;
      goto LABEL_31;
    }
    if (v27) {
      break;
    }
    v28 = (unsigned __int8 *)&v23[v19];
    v29 = (int8x16_t *)v23;
    do
      v30 = v29++;
    while (v29 <= (int8x16_t *)v28 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v30)) & 0x80) != 0);
    do
    {
      v31 = v30;
      v30 = (int8x16_t *)((char *)v30 + 4);
    }
    while (v30 <= (int8x16_t *)v28 && !v31->i32[0]);
    if (v31 < (int8x16_t *)v28)
    {
      while (!v31->i8[0])
      {
        v31 = (int8x16_t *)((char *)v31 + 1);
        if (v31 >= (int8x16_t *)v28)
        {
          v31 = (int8x16_t *)&v23[v19];
          break;
        }
      }
    }
    v32 = (char *)v31 - v23;
    v33 = ((char *)v31 - v23) * a6;
    v20 += v33;
    v22 += v33;
    v23 += v33;
    v19 -= v32;
LABEL_31:
    if (v19 <= 3) {
      goto LABEL_34;
    }
  }
  v51 = 0;
  while (1)
  {
    v52 = *(uint8x16_t *)((char *)v20 + v51);
    v53 = *(int8x16_t *)((char *)v22 + v51);
    a14.i32[0] = v27;
    v54 = vqtbl1q_s8((int8x16_t)a14, (int8x16_t)xmmword_1850CD8E0);
    v55 = vminq_u16(vmull_u8(*(uint8x8_t *)v52.i8, *(uint8x8_t *)v54.i8), v26);
    v56 = vminq_u16(vmull_high_u8(v52, (uint8x16_t)v54), v26);
    v57 = vrsraq_n_u16(v55, v55, 8uLL);
    *(uint8x8_t *)v57.i8 = vqrshrn_n_u16(v57, 8uLL);
    *(uint8x8_t *)v18.i8 = vqrshrn_n_u16(vrsraq_n_u16(v56, v56, 8uLL), 8uLL);
    v58 = (uint8x16_t)vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CE040);
    v59 = vqtbl1q_s8(vmvnq_s8(v53), (int8x16_t)xmmword_1850CE030);
    v60 = vmull_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v59.i8);
    v61 = vmull_u8(*(uint8x8_t *)v18.i8, (uint8x8_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL));
    v62 = (uint8x16_t)vmvnq_s8(v54);
    v18 = vqaddq_u16(v60, vmull_u8(*(uint8x8_t *)v53.i8, *(uint8x8_t *)v62.i8));
    a14 = vqaddq_u16(v61, vmull_high_u8((uint8x16_t)v53, v62));
    v63 = vmull_u8(*(uint8x8_t *)v53.i8, *(uint8x8_t *)v58.i8);
    v64 = vmull_high_u8((uint8x16_t)v53, v58);
    v65 = vminq_u16(vqaddq_u16(v18, v63), v26);
    v66 = vminq_u16(vqaddq_u16(a14, v64), v26);
    *(uint8x16_t *)((char *)v22 + v51) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v65, v65, 8uLL), 8uLL), vrsraq_n_u16(v66, v66, 8uLL), 8uLL);
    v23 += v24;
    v19 -= 4;
    if (v19 < 4) {
      break;
    }
    v27 = *(_DWORD *)v23;
    v51 += v25;
    if ((*(_DWORD *)v23 - 1) >= 0xFFFFFFFE)
    {
      v20 = (unsigned __int32 *)((char *)v20 + v51);
      v22 = (_DWORD *)((char *)v22 + v51);
      goto LABEL_31;
    }
  }
  v20 = (unsigned __int32 *)((char *)v20 + v25 + v51);
  v22 = (_DWORD *)((char *)v22 + v25 + v51);
LABEL_34:
  v67 = v19 + a17;
  if (v67)
  {
    v68 = (int8x16_t)vdupq_n_s16(0xFE01u);
    do
    {
      a9.i32[0] = *v20;
      v69 = vmovl_u8(*(uint8x8_t *)a9.i8);
      LOBYTE(v70) = v69.i8[0];
      BYTE1(v70) = v69.i8[2];
      BYTE2(v70) = v69.i8[4];
      HIBYTE(v70) = v69.i8[6];
      v69.i32[0] = *v22;
      v71 = vmovl_u8(*(uint8x8_t *)v69.i8);
      LOBYTE(v72) = v71.i8[0];
      BYTE1(v72) = v71.i8[2];
      BYTE2(v72) = v71.i8[4];
      HIBYTE(v72) = v71.i8[6];
      v71.i8[7] = 0;
      v71.i8[0] = *v23;
      v71.i8[1] = *v23;
      v71.i8[2] = *v23;
      *(__int32 *)((char *)v71.i32 + 3) = *v23;
      v73 = vminq_u16(vmull_u8((uint8x8_t)v70, *(uint8x8_t *)v71.i8), (uint16x8_t)v68);
      v74 = vrsraq_n_u16(v73, v73, 8uLL);
      *(int8x8_t *)v75.i8 = vmvn_s8((int8x8_t)v72);
      v75.i64[1] = v75.i64[0];
      v76 = vqrshrn_n_u16(v74, 8uLL);
      v77 = vminq_u16(vqaddq_u16(vqaddq_u16(vmull_u8(v76, (uint8x8_t)vqtbl1_s8(v75, (int8x8_t)0x404040400000000)), vmull_u8((uint8x8_t)v72, (uint8x8_t)vmvn_s8(*(int8x8_t *)v71.i8))), vmull_u8((uint8x8_t)v72, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v76, v74, 8uLL), (int8x8_t)0x404040400000000))), (uint16x8_t)v68);
      a9 = vrsraq_n_u16(v77, v77, 8uLL);
      *(uint8x8_t *)a9.i8 = vqrshrn_n_u16(a9, 8uLL);
      *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a9, v68));
      *v22 = a9.i32[0];
      v78 = &v20[a6];
      v23 += a6;
      if ((unint64_t)v78 >= v21) {
        v79 = -(uint64_t)a5;
      }
      else {
        v79 = 0;
      }
      v20 = &v78[v79];
      v22 += a6;
      --v67;
    }
    while (v67);
  }
  *result = v20;
  *a3 = v21;
  *a2 = v22;
  *a4 = v23;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)8,_argb8_t>(unsigned __int32 **result, unsigned __int32 **a2, unint64_t *a3, char **a4, int a5, int a6, int8x16_t a7, double a8, uint16x8_t a9, double a10, __n128 a11, double a12, uint8x16_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  v18 = *result;
  unint64_t v19 = *a3;
  v20 = *a2;
  v21 = *a4;
  if (a17 < 4) {
    goto LABEL_34;
  }
  uint64_t v22 = 4 * a6;
  uint64_t v23 = 16 * a6;
  a7.i64[1] = 0xC0C0C0C08080808;
  uint16x8_t v24 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v25 = *(_DWORD *)v21;
    if (*(_DWORD *)v21 == -1)
    {
      v32 = (unsigned __int8 *)&v21[v17];
      v33 = (int8x16_t *)v21;
      do
        v34 = v33++;
      while (v33 <= (int8x16_t *)v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, (int8x16_t)a9)) & 0x80) != 0);
      do
      {
        v35 = v34;
        v34 = (int8x16_t *)((char *)v34 + 4);
      }
      while (v34 <= (int8x16_t *)v32 && v35->i32[0] == -1);
      if (v35 < (int8x16_t *)v32)
      {
        while (v35->u8[0] == 255)
        {
          v35 = (int8x16_t *)((char *)v35 + 1);
          if (v35 >= (int8x16_t *)v32)
          {
            v35 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      uint64_t v36 = 0;
      int64_t v37 = (char *)v35 - v21;
      unint64_t v38 = (char *)v35 - v21;
      do
      {
        uint8x16_t v39 = *(uint8x16_t *)((char *)v20 + v36);
        uint8x16_t v40 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)((char *)v18 + v36), (int8x16_t)xmmword_1850CE030);
        uint16x8_t v41 = vminq_u16(vmull_u8(*(uint8x8_t *)v39.i8, *(uint8x8_t *)v40.i8), v24);
        uint16x8_t v42 = vminq_u16(vmull_high_u8(v39, v40), v24);
        a13 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v41, v41, 8uLL), 8uLL), vrsraq_n_u16(v42, v42, 8uLL), 8uLL);
        a11 = (__n128)vqsubq_u8(v39, a13);
        *(__n128 *)((char *)v20 + v36) = a11;
        v21 += v22;
        v38 -= 4;
        v36 += v23;
      }
      while (v38 > 3);
      v20 = (unsigned __int32 *)((char *)v20 + v36);
      v18 = (unsigned __int32 *)((char *)v18 + v36);
      unint64_t v17 = v17 - v37 + v38;
      goto LABEL_31;
    }
    if (v25) {
      break;
    }
    v26 = (unsigned __int8 *)&v21[v17];
    v27 = (int8x16_t *)v21;
    do
    {
      v28 = v27++;
      if (v27 > (int8x16_t *)v26) {
        break;
      }
      a11 = (__n128)vceqzq_s8(*v28);
    }
    while ((vminvq_u8((uint8x16_t)a11) & 0x80) != 0);
    do
    {
      v29 = v28;
      v28 = (int8x16_t *)((char *)v28 + 4);
    }
    while (v28 <= (int8x16_t *)v26 && !v29->i32[0]);
    if (v29 < (int8x16_t *)v26)
    {
      while (!v29->i8[0])
      {
        v29 = (int8x16_t *)((char *)v29 + 1);
        if (v29 >= (int8x16_t *)v26)
        {
          v29 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    int64_t v30 = (char *)v29 - v21;
    int64_t v31 = ((char *)v29 - v21) * a6;
    v18 += v31;
    v20 += v31;
    v21 += v31;
    v17 -= v30;
LABEL_31:
    if (v17 <= 3) {
      goto LABEL_34;
    }
  }
  uint64_t v43 = 0;
  while (1)
  {
    int8x16_t v44 = *(int8x16_t *)((char *)v20 + v43);
    a13.i32[0] = v25;
    uint8x16_t v45 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a13, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v46 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)((char *)v18 + v43), (int8x16_t)xmmword_1850CE030);
    uint16x8_t v47 = vmull_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v45.i8);
    uint16x8_t v48 = vmull_high_u8(v46, v45);
    uint16x8_t v49 = vminq_u16(v47, v24);
    uint16x8_t v50 = vminq_u16(v48, v24);
    uint16x8_t v51 = vminq_u16(vmull_u8(*(uint8x8_t *)v44.i8, vqrshrn_n_u16(vrsraq_n_u16(v49, v49, 8uLL), 8uLL)), v24);
    uint16x8_t v52 = vminq_u16(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), vqrshrn_n_u16(vrsraq_n_u16(v50, v50, 8uLL), 8uLL)), v24);
    a13 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v51, v51, 8uLL), 8uLL), vrsraq_n_u16(v52, v52, 8uLL), 8uLL);
    a11 = (__n128)vqsubq_u8((uint8x16_t)v44, a13);
    *(__n128 *)((char *)v20 + v43) = a11;
    v21 += v22;
    v17 -= 4;
    if (v17 < 4) {
      break;
    }
    unsigned __int32 v25 = *(_DWORD *)v21;
    v43 += v23;
    if ((*(_DWORD *)v21 - 1) >= 0xFFFFFFFE)
    {
      v18 = (unsigned __int32 *)((char *)v18 + v43);
      v20 = (unsigned __int32 *)((char *)v20 + v43);
      goto LABEL_31;
    }
  }
  v18 = (unsigned __int32 *)((char *)v18 + v23 + v43);
  v20 = (unsigned __int32 *)((char *)v20 + v23 + v43);
LABEL_34:
  uint64_t v53 = v17 + a16;
  if (v53)
  {
    a7.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v54 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a9.i32[0] = *v20;
      uint16x8_t v55 = vmovl_u8(*(uint8x8_t *)a9.i8);
      LOBYTE(v56) = v55.i8[0];
      BYTE1(v56) = v55.i8[2];
      BYTE2(v56) = v55.i8[4];
      HIBYTE(v56) = v55.i8[6];
      v55.i8[7] = 0;
      v55.i8[0] = *v21;
      v55.i8[1] = *v21;
      v55.i8[2] = *v21;
      *(__int32 *)((char *)v55.i32 + 3) = *v21;
      a11.n128_u32[0] = *v18;
      a11.n128_u64[1] = a11.n128_u64[0];
      a11.n128_u64[0] = (unint64_t)vqtbl1_s8((int8x16_t)a11, (int8x8_t)0xFFFFFFFF00000000);
      uint16x8_t v57 = vminq_u16(vmull_u8((uint8x8_t)a11.n128_u64[0], *(uint8x8_t *)v55.i8), v54);
      uint16x8_t v58 = vminq_u16(vmull_u8((uint8x8_t)v56, vqrshrn_n_u16(vrsraq_n_u16(v57, v57, 8uLL), 8uLL)), v54);
      a9 = vrsraq_n_u16(v58, v58, 8uLL);
      *(uint8x8_t *)a9.i8 = vqsub_u8((uint8x8_t)v56, vqrshrn_n_u16(a9, 8uLL));
      *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a9, a7));
      unsigned __int32 *v20 = a9.i32[0];
      v59 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v59 >= v19) {
        uint64_t v60 = -(uint64_t)a5;
      }
      else {
        uint64_t v60 = 0;
      }
      v18 = &v59[v60];
      v20 += a6;
      --v53;
    }
    while (v53);
  }
  *result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)7,_argb8_t>(unsigned __int32 **result, unsigned __int32 **a2, unint64_t *a3, char **a4, int a5, int a6, int8x16_t a7, double a8, uint16x8_t a9, double a10, __n128 a11, double a12, uint16x8_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  v18 = *result;
  unint64_t v19 = *a3;
  v20 = *a2;
  v21 = *a4;
  if (a17 < 4) {
    goto LABEL_34;
  }
  uint64_t v22 = 4 * a6;
  uint64_t v23 = 16 * a6;
  a7.i64[1] = 0xC0C0C0C08080808;
  uint16x8_t v24 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v25 = *(_DWORD *)v21;
    if (*(_DWORD *)v21 == -1)
    {
      v32 = (unsigned __int8 *)&v21[v17];
      v33 = (int8x16_t *)v21;
      do
        v34 = v33++;
      while (v33 <= (int8x16_t *)v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, (int8x16_t)a9)) & 0x80) != 0);
      do
      {
        v35 = v34;
        v34 = (int8x16_t *)((char *)v34 + 4);
      }
      while (v34 <= (int8x16_t *)v32 && v35->i32[0] == -1);
      if (v35 < (int8x16_t *)v32)
      {
        while (v35->u8[0] == 255)
        {
          v35 = (int8x16_t *)((char *)v35 + 1);
          if (v35 >= (int8x16_t *)v32)
          {
            v35 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      uint64_t v36 = 0;
      int64_t v37 = (char *)v35 - v21;
      unint64_t v38 = (char *)v35 - v21;
      do
      {
        uint8x16_t v39 = *(uint8x16_t *)((char *)v20 + v36);
        uint8x16_t v40 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)((char *)v18 + v36), (int8x16_t)xmmword_1850CE030);
        a13 = vmull_u8(*(uint8x8_t *)v39.i8, *(uint8x8_t *)v40.i8);
        uint16x8_t v41 = vmull_high_u8(v39, v40);
        uint16x8_t v42 = vminq_u16(a13, v24);
        uint16x8_t v43 = vminq_u16(v41, v24);
        a11 = (__n128)vrsraq_n_u16(v43, v43, 8uLL);
        *(uint8x16_t *)((char *)v20 + v36) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v42, v42, 8uLL), 8uLL), (uint16x8_t)a11, 8uLL);
        v21 += v22;
        v38 -= 4;
        v36 += v23;
      }
      while (v38 > 3);
      v20 = (unsigned __int32 *)((char *)v20 + v36);
      v18 = (unsigned __int32 *)((char *)v18 + v36);
      unint64_t v17 = v17 - v37 + v38;
      goto LABEL_31;
    }
    if (v25) {
      break;
    }
    v26 = (unsigned __int8 *)&v21[v17];
    v27 = (int8x16_t *)v21;
    do
    {
      v28 = v27++;
      if (v27 > (int8x16_t *)v26) {
        break;
      }
      a11 = (__n128)vceqzq_s8(*v28);
    }
    while ((vminvq_u8((uint8x16_t)a11) & 0x80) != 0);
    do
    {
      v29 = v28;
      v28 = (int8x16_t *)((char *)v28 + 4);
    }
    while (v28 <= (int8x16_t *)v26 && !v29->i32[0]);
    if (v29 < (int8x16_t *)v26)
    {
      while (!v29->i8[0])
      {
        v29 = (int8x16_t *)((char *)v29 + 1);
        if (v29 >= (int8x16_t *)v26)
        {
          v29 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    int64_t v30 = (char *)v29 - v21;
    int64_t v31 = ((char *)v29 - v21) * a6;
    v18 += v31;
    v20 += v31;
    v21 += v31;
    v17 -= v30;
LABEL_31:
    if (v17 <= 3) {
      goto LABEL_34;
    }
  }
  uint64_t v44 = 0;
  while (1)
  {
    uint8x16_t v45 = *(uint8x16_t *)((char *)v20 + v44);
    a13.i32[0] = v25;
    uint8x16_t v46 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a13, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v47 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)((char *)v18 + v44), (int8x16_t)xmmword_1850CE030);
    uint16x8_t v48 = vminq_u16(vmull_u8(*(uint8x8_t *)v46.i8, *(uint8x8_t *)v47.i8), v24);
    uint16x8_t v49 = vminq_u16(vmull_high_u8(v46, v47), v24);
    uint8x16_t v50 = vqsubq_u8(v46, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v48, v48, 8uLL), 8uLL), vrsraq_n_u16(v49, v49, 8uLL), 8uLL));
    uint16x8_t v51 = vminq_u16(vmull_u8(*(uint8x8_t *)v45.i8, *(uint8x8_t *)v50.i8), v24);
    uint16x8_t v52 = vminq_u16(vmull_high_u8(v45, v50), v24);
    a13 = (uint16x8_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v51, v51, 8uLL), 8uLL), vrsraq_n_u16(v52, v52, 8uLL), 8uLL);
    a11 = (__n128)vqsubq_u8(v45, (uint8x16_t)a13);
    *(__n128 *)((char *)v20 + v44) = a11;
    v21 += v22;
    v17 -= 4;
    if (v17 < 4) {
      break;
    }
    unsigned __int32 v25 = *(_DWORD *)v21;
    v44 += v23;
    if ((*(_DWORD *)v21 - 1) >= 0xFFFFFFFE)
    {
      v18 = (unsigned __int32 *)((char *)v18 + v44);
      v20 = (unsigned __int32 *)((char *)v20 + v44);
      goto LABEL_31;
    }
  }
  v18 = (unsigned __int32 *)((char *)v18 + v23 + v44);
  v20 = (unsigned __int32 *)((char *)v20 + v23 + v44);
LABEL_34:
  uint64_t v53 = v17 + a16;
  if (v53)
  {
    a7.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v54 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a9.i32[0] = *v20;
      uint16x8_t v55 = vmovl_u8(*(uint8x8_t *)a9.i8);
      LOBYTE(v56) = v55.i8[0];
      BYTE1(v56) = v55.i8[2];
      BYTE2(v56) = v55.i8[4];
      HIBYTE(v56) = v55.i8[6];
      v55.i8[7] = 0;
      v55.i8[0] = *v21;
      v55.i8[1] = *v21;
      v55.i8[2] = *v21;
      *(__int32 *)((char *)v55.i32 + 3) = *v21;
      a11.n128_u32[0] = *v18;
      a11.n128_u64[1] = a11.n128_u64[0];
      a11 = (__n128)vminq_u16(vmull_u8(*(uint8x8_t *)v55.i8, (uint8x8_t)vqtbl1_s8((int8x16_t)a11, (int8x8_t)0xFFFFFFFF00000000)), v54);
      a11.n128_u64[0] = (unint64_t)vqrshrn_n_u16(vrsraq_n_u16((uint16x8_t)a11, (uint16x8_t)a11, 8uLL), 8uLL);
      uint16x8_t v57 = vminq_u16(vmull_u8((uint8x8_t)v56, vqsub_u8(*(uint8x8_t *)v55.i8, (uint8x8_t)a11.n128_u64[0])), v54);
      a9 = vrsraq_n_u16(v57, v57, 8uLL);
      *(uint8x8_t *)a9.i8 = vqsub_u8((uint8x8_t)v56, vqrshrn_n_u16(a9, 8uLL));
      *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a9, a7));
      unsigned __int32 *v20 = a9.i32[0];
      uint16x8_t v58 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v58 >= v19) {
        uint64_t v59 = -(uint64_t)a5;
      }
      else {
        uint64_t v59 = 0;
      }
      v18 = &v58[v59];
      v20 += a6;
      --v53;
    }
    while (v53);
  }
  *result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)6,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int8x16_t a8, double a9, double a10, uint16x8_t a11, double a12, double a13, double a14, int8x16_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v18 = a18;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  v21 = *a2;
  uint64_t v22 = *a4;
  if (a18 < 4) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFF000000FFLL;
  v24.i64[1] = 0xFF000000FFLL;
  a8 = vandq_s8(vdupq_n_s8(v23), v24);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a11.i64[0] = -1;
  a11.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v28 = *(_DWORD *)v22;
    if (*(_DWORD *)v22 == -1)
    {
      v35 = (unsigned __int8 *)&v22[v18];
      uint64_t v36 = (int8x16_t *)v22;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, (int8x16_t)a11)) & 0x80) != 0);
      do
      {
        unint64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          unint64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            unint64_t v38 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v22;
      unint64_t v41 = (char *)v38 - v22;
      do
      {
        int8x16_t v42 = *(int8x16_t *)((char *)v21 + v39);
        uint8x16_t v43 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v39), a8);
        int8x16_t v44 = vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v45 = (uint8x16_t)vbicq_s8(v42, vceqzq_s8(v44));
        uint8x16_t v46 = (uint8x16_t)vmvnq_s8(v44);
        uint16x8_t v47 = vmull_u8(*(uint8x8_t *)v43.i8, *(uint8x8_t *)v46.i8);
        uint16x8_t v48 = vmull_high_u8(v43, v46);
        uint16x8_t v49 = vminq_u16(v47, v27);
        uint16x8_t v50 = vminq_u16(v48, v27);
        a15 = (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v49, v49, 8uLL), 8uLL), vrsraq_n_u16(v50, v50, 8uLL), 8uLL);
        *(uint8x16_t *)((char *)v21 + v39) = vqaddq_u8(v45, (uint8x16_t)a15);
        v22 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      v21 = (_DWORD *)((char *)v21 + v39);
      unint64_t v19 = (unsigned __int32 *)((char *)v19 + v39);
      unint64_t v18 = v18 - v40 + v41;
      goto LABEL_34;
    }
    if (v28) {
      break;
    }
    v29 = (unsigned __int8 *)&v22[v18];
    int64_t v30 = (int8x16_t *)v22;
    do
      int64_t v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      v32 = v31;
      int64_t v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          v32 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v22;
    int64_t v34 = ((char *)v32 - v22) * a6;
    v19 += v34;
    v21 += v34;
    v22 += v34;
    v18 -= v33;
LABEL_34:
    if (v18 <= 3) {
      goto LABEL_37;
    }
  }
  uint64_t v51 = 0;
  while (1)
  {
    int8x16_t v52 = *(int8x16_t *)((char *)v21 + v51);
    a15.i32[0] = v28;
    int8x16_t v53 = vqtbl1q_s8(a15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v54 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v51), a8);
    uint16x8_t v55 = vminq_u16(vmull_u8(*(uint8x8_t *)v54.i8, *(uint8x8_t *)v53.i8), v27);
    uint16x8_t v56 = vminq_u16(vmull_high_u8(v54, (uint8x16_t)v53), v27);
    int8x16_t v57 = vqtbl1q_s8(v52, (int8x16_t)xmmword_1850CE030);
    uint8x16_t v58 = (uint8x16_t)vbicq_s8(v52, vceqzq_s8(v57));
    int8x16_t v59 = vmvnq_s8(v57);
    uint16x8_t v60 = vminq_u16(vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v55, v55, 8uLL), 8uLL), *(uint8x8_t *)v59.i8), v27);
    uint16x8_t v61 = vminq_u16(vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v56, v56, 8uLL), 8uLL), (uint8x8_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL)), v27);
    a15 = vceqzq_s8(v53);
    *(int8x16_t *)((char *)v21 + v51) = vbslq_s8(a15, v52, (int8x16_t)vqaddq_u8(v58, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v60, v60, 8uLL), 8uLL), vrsraq_n_u16(v61, v61, 8uLL), 8uLL)));
    v22 += v25;
    v18 -= 4;
    if (v18 < 4) {
      break;
    }
    unsigned __int32 v28 = *(_DWORD *)v22;
    v51 += v26;
    if ((*(_DWORD *)v22 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v19 = (unsigned __int32 *)((char *)v19 + v51);
      v21 = (_DWORD *)((char *)v21 + v51);
      goto LABEL_34;
    }
  }
  unint64_t v19 = (unsigned __int32 *)((char *)v19 + v26 + v51);
  v21 = (_DWORD *)((char *)v21 + v26 + v51);
LABEL_37:
  uint64_t v62 = v18 + a17;
  if (v62)
  {
    if (a7) {
      unsigned int v63 = 0;
    }
    else {
      unsigned int v63 = -1;
    }
    *(int8x8_t *)a8.i8 = vand_s8(vdup_n_s8(v63), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v64 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a11.i32[0] = *v19;
      uint16x8_t v65 = vmovl_u8(*(uint8x8_t *)a11.i8);
      LOBYTE(v66) = v65.i8[0];
      BYTE1(v66) = v65.i8[2];
      BYTE2(v66) = v65.i8[4];
      HIBYTE(v66) = v65.i8[6];
      v65.i32[0] = *v21;
      v65.i64[0] = vmovl_u8(*(uint8x8_t *)v65.i8).u64[0];
      LOBYTE(v67) = v65.i8[0];
      BYTE1(v67) = v65.i8[2];
      BYTE2(v67) = v65.i8[4];
      HIBYTE(v67) = v65.i8[6];
      v68.i8[7] = 0;
      v68.i8[0] = *v22;
      v68.i8[1] = *v22;
      v68.i8[2] = *v22;
      *(__int32 *)((char *)v68.i32 + 3) = *v22;
      uint16x8_t v69 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v66, *(int8x8_t *)a8.i8), v68), v64);
      *(int8x8_t *)v65.i8 = vqtbl1_s8(vdupq_lane_s8(*(int8x8_t *)v65.i8, 0), (int8x8_t)0xFFFFFFFF00000000);
      uint8x8_t v70 = (uint8x8_t)vbic_s8((int8x8_t)v67, vceqz_s8(*(int8x8_t *)v65.i8));
      uint16x8_t v71 = vminq_u16(vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v69, v69, 8uLL), 8uLL), (uint8x8_t)vmvn_s8(*(int8x8_t *)v65.i8)), v64);
      a11 = vrsraq_n_u16(v71, v71, 8uLL);
      *(int8x8_t *)a11.i8 = vbsl_s8(vceqz_s8((int8x8_t)v68), (int8x8_t)v67, (int8x8_t)vqadd_u8(v70, vqrshrn_n_u16(a11, 8uLL)));
      *(int8x8_t *)a11.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a11, a8));
      _DWORD *v21 = a11.i32[0];
      v72 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v72 >= v20) {
        uint64_t v73 = -(uint64_t)a5;
      }
      else {
        uint64_t v73 = 0;
      }
      unint64_t v19 = &v72[v73];
      v21 += a6;
      --v62;
    }
    while (v62);
  }
  *result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)5,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, double a9, uint8x8_t a10, double a11, double a12, double a13, uint16x8_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v19 = a18;
  unint64_t v20 = *result;
  unint64_t v21 = *a3;
  uint64_t v22 = *a2;
  unsigned int v23 = *a4;
  if (a18 < 4) {
    goto LABEL_34;
  }
  uint64_t v24 = 4 * a6;
  uint64_t v25 = 16 * a6;
  uint16x8_t v26 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  v27.i64[0] = -1;
  v27.i64[1] = -1;
  a10.i32[1] = 16843009;
  while (1)
  {
    unsigned __int32 v28 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 == -1)
    {
      v35 = (unsigned __int8 *)&v23[v19];
      uint64_t v36 = (int8x16_t *)v23;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, v27)) & 0x80) != 0);
      do
      {
        unint64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          unint64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            unint64_t v38 = (int8x16_t *)&v23[v19];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v23;
      unint64_t v41 = (char *)v38 - v23;
      do
      {
        int8x16_t v42 = *(int8x16_t *)((char *)v20 + v39);
        int8x16_t v43 = *(int8x16_t *)((char *)v22 + v39);
        uint8x16_t v44 = (uint8x16_t)vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v45 = (uint8x16_t)vqtbl1q_s8(v43, (int8x16_t)xmmword_1850CE030);
        uint16x8_t v46 = vminq_u16(vmull_u8(*(uint8x8_t *)v43.i8, *(uint8x8_t *)v44.i8), v26);
        uint16x8_t v47 = vminq_u16(vmull_high_u8((uint8x16_t)v43, v44), v26);
        uint8x16_t v18 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v46, v46, 8uLL), 8uLL), vrsraq_n_u16(v47, v47, 8uLL), 8uLL);
        uint16x8_t v48 = vminq_u16(vmull_u8(*(uint8x8_t *)v45.i8, *(uint8x8_t *)v42.i8), v26);
        uint16x8_t v49 = vminq_u16(vmull_high_u8(v45, (uint8x16_t)v42), v26);
        a14 = (uint16x8_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v48, v48, 8uLL), 8uLL), vrsraq_n_u16(v49, v49, 8uLL), 8uLL);
        *(uint8x16_t *)((char *)v22 + v39) = vqaddq_u8(vqsubq_u8((uint8x16_t)v43, v18), (uint8x16_t)a14);
        v23 += v24;
        v41 -= 4;
        v39 += v25;
      }
      while (v41 > 3);
      uint64_t v22 = (_DWORD *)((char *)v22 + v39);
      unint64_t v20 = (_DWORD *)((char *)v20 + v39);
      unint64_t v19 = v19 - v40 + v41;
      goto LABEL_31;
    }
    if (v28) {
      break;
    }
    v29 = (unsigned __int8 *)&v23[v19];
    int64_t v30 = (int8x16_t *)v23;
    do
      int64_t v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      v32 = v31;
      int64_t v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          v32 = (int8x16_t *)&v23[v19];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v23;
    int64_t v34 = ((char *)v32 - v23) * a6;
    v20 += v34;
    v22 += v34;
    v23 += v34;
    v19 -= v33;
LABEL_31:
    if (v19 <= 3) {
      goto LABEL_34;
    }
  }
  uint64_t v50 = 0;
  while (1)
  {
    uint8x16_t v51 = *(uint8x16_t *)((char *)v20 + v50);
    int8x16_t v52 = *(int8x16_t *)((char *)v22 + v50);
    a14.i32[0] = v28;
    uint8x16_t v53 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a14, (int8x16_t)xmmword_1850CD8E0);
    uint16x8_t v54 = vmull_u8(*(uint8x8_t *)v51.i8, *(uint8x8_t *)v53.i8);
    uint16x8_t v55 = vmull_high_u8(v51, v53);
    uint16x8_t v56 = vminq_u16(v54, v26);
    uint16x8_t v57 = vminq_u16(v55, v26);
    *(uint8x8_t *)v54.i8 = vqrshrn_n_u16(vrsraq_n_u16(v56, v56, 8uLL), 8uLL);
    *(uint8x8_t *)v18.i8 = vqrshrn_n_u16(vrsraq_n_u16(v57, v57, 8uLL), 8uLL);
    uint8x16_t v58 = (uint8x16_t)vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CE040);
    int8x16_t v59 = vqtbl1q_s8(v52, (int8x16_t)xmmword_1850CE030);
    uint16x8_t v60 = vminq_u16(vmull_u8(*(uint8x8_t *)v52.i8, *(uint8x8_t *)v58.i8), v26);
    uint16x8_t v61 = vminq_u16(vmull_high_u8((uint8x16_t)v52, v58), v26);
    uint8x16_t v62 = vqsubq_u8((uint8x16_t)v52, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v60, v60, 8uLL), 8uLL), vrsraq_n_u16(v61, v61, 8uLL), 8uLL));
    uint16x8_t v63 = vminq_u16(vmull_u8(*(uint8x8_t *)v59.i8, *(uint8x8_t *)v54.i8), v26);
    uint16x8_t v64 = vminq_u16(vmull_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL), *(uint8x8_t *)v18.i8), v26);
    a14 = vrsraq_n_u16(v64, v64, 8uLL);
    *(uint8x16_t *)((char *)v22 + v50) = vqaddq_u8(v62, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v63, v63, 8uLL), 8uLL), a14, 8uLL));
    v23 += v24;
    v19 -= 4;
    if (v19 < 4) {
      break;
    }
    unsigned __int32 v28 = *(_DWORD *)v23;
    v50 += v25;
    if ((*(_DWORD *)v23 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v20 = (_DWORD *)((char *)v20 + v50);
      uint64_t v22 = (_DWORD *)((char *)v22 + v50);
      goto LABEL_31;
    }
  }
  unint64_t v20 = (_DWORD *)((char *)v20 + v25 + v50);
  uint64_t v22 = (_DWORD *)((char *)v22 + v25 + v50);
LABEL_34:
  uint64_t v65 = v19 + a17;
  if (v65)
  {
    int8x16_t v66 = (int8x16_t)vdupq_n_s16(0xFE01u);
    do
    {
      a10.i32[0] = *v20;
      uint16x8_t v67 = vmovl_u8(a10);
      LOBYTE(v68) = v67.i8[0];
      BYTE1(v68) = v67.i8[2];
      BYTE2(v68) = v67.i8[4];
      HIBYTE(v68) = v67.i8[6];
      v67.i32[0] = *v22;
      v67.i64[0] = vmovl_u8(*(uint8x8_t *)v67.i8).u64[0];
      LOBYTE(v69) = v67.i8[0];
      BYTE1(v69) = v67.i8[2];
      BYTE2(v69) = v67.i8[4];
      HIBYTE(v69) = v67.i8[6];
      v70.i8[7] = 0;
      v70.i8[0] = *v23;
      v70.i8[1] = *v23;
      v70.i8[2] = *v23;
      *(__int32 *)((char *)v70.i32 + 3) = *v23;
      uint16x8_t v71 = vminq_u16(vmull_u8((uint8x8_t)v68, v70), (uint16x8_t)v66);
      uint16x8_t v72 = vrsraq_n_u16(v71, v71, 8uLL);
      uint8x8_t v73 = vqrshrn_n_u16(v72, 8uLL);
      uint16x8_t v74 = vminq_u16(vmull_u8((uint8x8_t)v69, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v73, v72, 8uLL), (int8x8_t)0x404040400000000)), (uint16x8_t)v66);
      uint16x8_t v75 = vminq_u16(vmull_u8((uint8x8_t)vqtbl1_s8(vdupq_lane_s8(*(int8x8_t *)v67.i8, 0), (int8x8_t)0xFFFFFFFF00000000), v73), (uint16x8_t)v66);
      int8x16_t v76 = (int8x16_t)vrsraq_n_u16(v75, v75, 8uLL);
      *(uint8x8_t *)v76.i8 = vqadd_u8(vqsub_u8((uint8x8_t)v69, vqrshrn_n_u16(vrsraq_n_u16(v74, v74, 8uLL), 8uLL)), vqrshrn_n_u16((uint16x8_t)v76, 8uLL));
      a10 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v76, v66));
      *uint64_t v22 = a10.i32[0];
      v77 = &v20[a6];
      v23 += a6;
      if ((unint64_t)v77 >= v21) {
        uint64_t v78 = -(uint64_t)a5;
      }
      else {
        uint64_t v78 = 0;
      }
      unint64_t v20 = &v77[v78];
      v22 += a6;
      --v65;
    }
    while (v65);
  }
  *result = v20;
  *a3 = v21;
  *a2 = v22;
  *a4 = v23;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)4,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int8x16_t a8, double a9, double a10, uint16x8_t a11, double a12, double a13, double a14, uint16x8_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v18 = a18;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  unint64_t v21 = *a2;
  uint64_t v22 = *a4;
  if (a18 < 4) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFF000000FFLL;
  v24.i64[1] = 0xFF000000FFLL;
  a8 = vandq_s8(vdupq_n_s8(v23), v24);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a11.i64[0] = -1;
  a11.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v28 = *(_DWORD *)v22;
    if (*(_DWORD *)v22 == -1)
    {
      v35 = (unsigned __int8 *)&v22[v18];
      uint64_t v36 = (int8x16_t *)v22;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, (int8x16_t)a11)) & 0x80) != 0);
      do
      {
        unint64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          unint64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            unint64_t v38 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v22;
      unint64_t v41 = (char *)v38 - v22;
      do
      {
        uint8x16_t v42 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v39), a8);
        uint8x16_t v43 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)((char *)v21 + v39), (int8x16_t)xmmword_1850CE030);
        uint16x8_t v44 = vminq_u16(vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v43.i8), v27);
        uint16x8_t v45 = vminq_u16(vmull_high_u8(v42, v43), v27);
        a15 = (uint16x8_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v44, v44, 8uLL), 8uLL), vrsraq_n_u16(v45, v45, 8uLL), 8uLL);
        *(uint8x16_t *)((char *)v21 + v39) = vqsubq_u8(v42, (uint8x16_t)a15);
        v22 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      unint64_t v21 = (_DWORD *)((char *)v21 + v39);
      unint64_t v19 = (unsigned __int32 *)((char *)v19 + v39);
      unint64_t v18 = v18 - v40 + v41;
      goto LABEL_34;
    }
    if (v28) {
      break;
    }
    v29 = (unsigned __int8 *)&v22[v18];
    int64_t v30 = (int8x16_t *)v22;
    do
      int64_t v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      v32 = v31;
      int64_t v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          v32 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v22;
    int64_t v34 = ((char *)v32 - v22) * a6;
    v19 += v34;
    v21 += v34;
    v22 += v34;
    v18 -= v33;
LABEL_34:
    if (v18 <= 3) {
      goto LABEL_37;
    }
  }
  uint64_t v46 = 0;
  while (1)
  {
    int8x16_t v47 = *(int8x16_t *)((char *)v21 + v46);
    a15.i32[0] = v28;
    int8x16_t v48 = vqtbl1q_s8((int8x16_t)a15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v49 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v46), a8);
    uint16x8_t v50 = vminq_u16(vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v48.i8), v27);
    uint16x8_t v51 = vminq_u16(vmull_high_u8(v49, (uint8x16_t)v48), v27);
    uint8x16_t v52 = (uint8x16_t)vmvnq_s8(v48);
    int8x16_t v53 = vqtbl1q_s8(vmvnq_s8(v47), (int8x16_t)xmmword_1850CE030);
    uint16x8_t v54 = vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v52.i8);
    uint16x8_t v55 = vmull_high_u8((uint8x16_t)v47, v52);
    a15 = vqaddq_u16(v54, vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v50, v50, 8uLL), 8uLL), *(uint8x8_t *)v53.i8));
    uint16x8_t v56 = vqaddq_u16(v55, vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v51, v51, 8uLL), 8uLL), (uint8x8_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL)));
    uint16x8_t v57 = vminq_u16(a15, v27);
    uint16x8_t v58 = vminq_u16(v56, v27);
    *(uint8x16_t *)((char *)v21 + v46) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v57, v57, 8uLL), 8uLL), vrsraq_n_u16(v58, v58, 8uLL), 8uLL);
    v22 += v25;
    v18 -= 4;
    if (v18 < 4) {
      break;
    }
    unsigned __int32 v28 = *(_DWORD *)v22;
    v46 += v26;
    if ((*(_DWORD *)v22 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v19 = (unsigned __int32 *)((char *)v19 + v46);
      unint64_t v21 = (_DWORD *)((char *)v21 + v46);
      goto LABEL_34;
    }
  }
  unint64_t v19 = (unsigned __int32 *)((char *)v19 + v26 + v46);
  unint64_t v21 = (_DWORD *)((char *)v21 + v26 + v46);
LABEL_37:
  uint64_t v59 = v18 + a17;
  if (v59)
  {
    if (a7) {
      unsigned int v60 = 0;
    }
    else {
      unsigned int v60 = -1;
    }
    *(int8x8_t *)a8.i8 = vand_s8(vdup_n_s8(v60), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v61 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a11.i32[0] = *v19;
      uint16x8_t v62 = vmovl_u8(*(uint8x8_t *)a11.i8);
      LOBYTE(v63) = v62.i8[0];
      BYTE1(v63) = v62.i8[2];
      BYTE2(v63) = v62.i8[4];
      HIBYTE(v63) = v62.i8[6];
      v62.i32[0] = *v21;
      uint16x8_t v64 = vmovl_u8(*(uint8x8_t *)v62.i8);
      LOBYTE(v65) = v64.i8[0];
      BYTE1(v65) = v64.i8[2];
      BYTE2(v65) = v64.i8[4];
      HIBYTE(v65) = v64.i8[6];
      v64.i8[7] = 0;
      v64.i8[0] = *v22;
      v64.i8[1] = *v22;
      v64.i8[2] = *v22;
      *(__int32 *)((char *)v64.i32 + 3) = *v22;
      uint16x8_t v66 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v63, *(int8x8_t *)a8.i8), *(uint8x8_t *)v64.i8), v61);
      *(int8x8_t *)v67.i8 = vmvn_s8((int8x8_t)v65);
      v67.i64[1] = v67.i64[0];
      uint16x8_t v68 = vminq_u16(vqaddq_u16(vmull_u8((uint8x8_t)v65, (uint8x8_t)vmvn_s8(*(int8x8_t *)v64.i8)), vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v66, v66, 8uLL), 8uLL), (uint8x8_t)vqtbl1_s8(v67, (int8x8_t)0x404040400000000))), v61);
      a11 = vrsraq_n_u16(v68, v68, 8uLL);
      *(uint8x8_t *)a11.i8 = vqrshrn_n_u16(a11, 8uLL);
      *(int8x8_t *)a11.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a11, a8));
      _DWORD *v21 = a11.i32[0];
      unsigned int v69 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v69 >= v20) {
        uint64_t v70 = -(uint64_t)a5;
      }
      else {
        uint64_t v70 = 0;
      }
      unint64_t v19 = &v69[v70];
      v21 += a6;
      --v59;
    }
    while (v59);
  }
  *result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)3,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int8x16_t a8, double a9, double a10, uint16x8_t a11, double a12, double a13, double a14, uint16x8_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v18 = a18;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  unint64_t v21 = *a2;
  uint64_t v22 = *a4;
  if (a18 < 4) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFF000000FFLL;
  v24.i64[1] = 0xFF000000FFLL;
  a8 = vandq_s8(vdupq_n_s8(v23), v24);
  uint64_t v25 = 4 * a6;
  uint64_t v26 = 16 * a6;
  uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a11.i64[0] = -1;
  a11.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v28 = *(_DWORD *)v22;
    if (*(_DWORD *)v22 == -1)
    {
      v35 = (unsigned __int8 *)&v22[v18];
      uint64_t v36 = (int8x16_t *)v22;
      do
        int64_t v37 = v36++;
      while (v36 <= (int8x16_t *)v35 && (vminvq_u8((uint8x16_t)vceqq_s8(*v37, (int8x16_t)a11)) & 0x80) != 0);
      do
      {
        unint64_t v38 = v37;
        int64_t v37 = (int8x16_t *)((char *)v37 + 4);
      }
      while (v37 <= (int8x16_t *)v35 && v38->i32[0] == -1);
      if (v38 < (int8x16_t *)v35)
      {
        while (v38->u8[0] == 255)
        {
          unint64_t v38 = (int8x16_t *)((char *)v38 + 1);
          if (v38 >= (int8x16_t *)v35)
          {
            unint64_t v38 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      uint64_t v39 = 0;
      int64_t v40 = (char *)v38 - v22;
      unint64_t v41 = (char *)v38 - v22;
      do
      {
        uint8x16_t v42 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v39), a8);
        uint8x16_t v43 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)((char *)v21 + v39), (int8x16_t)xmmword_1850CE030);
        a15 = vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v43.i8);
        uint16x8_t v44 = vmull_high_u8(v42, v43);
        uint16x8_t v45 = vminq_u16(a15, v27);
        uint16x8_t v46 = vminq_u16(v44, v27);
        *(uint8x16_t *)((char *)v21 + v39) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v45, v45, 8uLL), 8uLL), vrsraq_n_u16(v46, v46, 8uLL), 8uLL);
        v22 += v25;
        v41 -= 4;
        v39 += v26;
      }
      while (v41 > 3);
      unint64_t v21 = (_DWORD *)((char *)v21 + v39);
      unint64_t v19 = (unsigned __int32 *)((char *)v19 + v39);
      unint64_t v18 = v18 - v40 + v41;
      goto LABEL_34;
    }
    if (v28) {
      break;
    }
    v29 = (unsigned __int8 *)&v22[v18];
    int64_t v30 = (int8x16_t *)v22;
    do
      int64_t v31 = v30++;
    while (v30 <= (int8x16_t *)v29 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v31)) & 0x80) != 0);
    do
    {
      v32 = v31;
      int64_t v31 = (int8x16_t *)((char *)v31 + 4);
    }
    while (v31 <= (int8x16_t *)v29 && !v32->i32[0]);
    if (v32 < (int8x16_t *)v29)
    {
      while (!v32->i8[0])
      {
        v32 = (int8x16_t *)((char *)v32 + 1);
        if (v32 >= (int8x16_t *)v29)
        {
          v32 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    int64_t v33 = (char *)v32 - v22;
    int64_t v34 = ((char *)v32 - v22) * a6;
    v19 += v34;
    v21 += v34;
    v22 += v34;
    v18 -= v33;
LABEL_34:
    if (v18 <= 3) {
      goto LABEL_37;
    }
  }
  uint64_t v47 = 0;
  while (1)
  {
    int8x16_t v48 = *(int8x16_t *)((char *)v21 + v47);
    a15.i32[0] = v28;
    int8x16_t v49 = vqtbl1q_s8((int8x16_t)a15, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v50 = (uint8x16_t)vorrq_s8(*(int8x16_t *)((char *)v19 + v47), a8);
    int8x16_t v51 = vqtbl1q_s8(v48, (int8x16_t)xmmword_1850CE030);
    uint16x8_t v52 = vminq_u16(vmull_u8(*(uint8x8_t *)v50.i8, *(uint8x8_t *)v49.i8), v27);
    uint16x8_t v53 = vminq_u16(vmull_high_u8(v50, (uint8x16_t)v49), v27);
    uint8x16_t v54 = (uint8x16_t)vmvnq_s8(v49);
    uint16x8_t v55 = vmull_u8(*(uint8x8_t *)v48.i8, *(uint8x8_t *)v54.i8);
    uint16x8_t v56 = vmull_high_u8((uint8x16_t)v48, v54);
    a15 = vqaddq_u16(v55, vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v52, v52, 8uLL), 8uLL), *(uint8x8_t *)v51.i8));
    uint16x8_t v57 = vqaddq_u16(v56, vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v53, v53, 8uLL), 8uLL), (uint8x8_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL)));
    uint16x8_t v58 = vminq_u16(a15, v27);
    uint16x8_t v59 = vminq_u16(v57, v27);
    *(uint8x16_t *)((char *)v21 + v47) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v58, v58, 8uLL), 8uLL), vrsraq_n_u16(v59, v59, 8uLL), 8uLL);
    v22 += v25;
    v18 -= 4;
    if (v18 < 4) {
      break;
    }
    unsigned __int32 v28 = *(_DWORD *)v22;
    v47 += v26;
    if ((*(_DWORD *)v22 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v19 = (unsigned __int32 *)((char *)v19 + v47);
      unint64_t v21 = (_DWORD *)((char *)v21 + v47);
      goto LABEL_34;
    }
  }
  unint64_t v19 = (unsigned __int32 *)((char *)v19 + v26 + v47);
  unint64_t v21 = (_DWORD *)((char *)v21 + v26 + v47);
LABEL_37:
  uint64_t v60 = v18 + a17;
  if (v60)
  {
    if (a7) {
      unsigned int v61 = 0;
    }
    else {
      unsigned int v61 = -1;
    }
    *(int8x8_t *)a8.i8 = vand_s8(vdup_n_s8(v61), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v62 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a11.i32[0] = *v19;
      uint16x8_t v63 = vmovl_u8(*(uint8x8_t *)a11.i8);
      LOBYTE(v64) = v63.i8[0];
      BYTE1(v64) = v63.i8[2];
      BYTE2(v64) = v63.i8[4];
      HIBYTE(v64) = v63.i8[6];
      v63.i32[0] = *v21;
      v63.i64[0] = vmovl_u8(*(uint8x8_t *)v63.i8).u64[0];
      LOBYTE(v65) = v63.i8[0];
      BYTE1(v65) = v63.i8[2];
      BYTE2(v65) = v63.i8[4];
      HIBYTE(v65) = v63.i8[6];
      v66.i8[7] = 0;
      v66.i8[0] = *v22;
      v66.i8[1] = *v22;
      v66.i8[2] = *v22;
      *(__int32 *)((char *)v66.i32 + 3) = *v22;
      uint16x8_t v67 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v64, *(int8x8_t *)a8.i8), v66), v62);
      uint16x8_t v68 = vminq_u16(vqaddq_u16(vmull_u8((uint8x8_t)v65, (uint8x8_t)vmvn_s8((int8x8_t)v66)), vmull_u8(vqrshrn_n_u16(vrsraq_n_u16(v67, v67, 8uLL), 8uLL), (uint8x8_t)vqtbl1_s8(vdupq_lane_s8(*(int8x8_t *)v63.i8, 0), (int8x8_t)0xFFFFFFFF00000000))), v62);
      a11 = vrsraq_n_u16(v68, v68, 8uLL);
      *(uint8x8_t *)a11.i8 = vqrshrn_n_u16(a11, 8uLL);
      *(int8x8_t *)a11.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a11, a8));
      _DWORD *v21 = a11.i32[0];
      unsigned int v69 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v69 >= v20) {
        uint64_t v70 = -(uint64_t)a5;
      }
      else {
        uint64_t v70 = 0;
      }
      unint64_t v19 = &v69[v70];
      v21 += a6;
      --v60;
    }
    while (v60);
  }
  *result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)2,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, uint16x8_t a9, double a10, double a11, double a12, double a13, uint16x8_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v19 = a18;
  unint64_t v20 = *result;
  unint64_t v21 = *a3;
  uint64_t v22 = *a2;
  unsigned int v23 = *a4;
  if (a18 < 4) {
    goto LABEL_34;
  }
  uint64_t v24 = 4 * a6;
  uint64_t v25 = 16 * a6;
  uint16x8_t v26 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v27 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 == -1)
    {
      int64_t v34 = (unsigned __int8 *)&v23[v19];
      v35 = (int8x16_t *)v23;
      do
        uint64_t v36 = v35++;
      while (v35 <= (int8x16_t *)v34 && (vminvq_u8((uint8x16_t)vceqq_s8(*v36, (int8x16_t)a9)) & 0x80) != 0);
      do
      {
        int64_t v37 = v36;
        uint64_t v36 = (int8x16_t *)((char *)v36 + 4);
      }
      while (v36 <= (int8x16_t *)v34 && v37->i32[0] == -1);
      if (v37 < (int8x16_t *)v34)
      {
        while (v37->u8[0] == 255)
        {
          int64_t v37 = (int8x16_t *)((char *)v37 + 1);
          if (v37 >= (int8x16_t *)v34)
          {
            int64_t v37 = (int8x16_t *)&v23[v19];
            break;
          }
        }
      }
      uint64_t v38 = 0;
      int64_t v39 = (char *)v37 - v23;
      unint64_t v40 = (char *)v37 - v23;
      do
      {
        int8x16_t v41 = *(int8x16_t *)((char *)v20 + v38);
        uint8x16_t v42 = *(uint8x16_t *)((char *)v22 + v38);
        int8x16_t v43 = vqtbl1q_s8(v41, (int8x16_t)xmmword_1850CE030);
        uint8x16_t v44 = (uint8x16_t)vbicq_s8(v41, vceqzq_s8(v43));
        uint16x8_t v45 = vminq_u16(vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v43.i8), v26);
        uint16x8_t v46 = vminq_u16(vmull_high_u8(v42, (uint8x16_t)v43), v26);
        a14 = vrsraq_n_u16(v46, v46, 8uLL);
        *(uint8x16_t *)((char *)v22 + v38) = vqaddq_u8(v44, vqsubq_u8(v42, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v45, v45, 8uLL), 8uLL), a14, 8uLL)));
        v23 += v24;
        v40 -= 4;
        v38 += v25;
      }
      while (v40 > 3);
      uint64_t v22 = (_DWORD *)((char *)v22 + v38);
      unint64_t v20 = (unsigned __int32 *)((char *)v20 + v38);
      unint64_t v19 = v19 - v39 + v40;
      goto LABEL_31;
    }
    if (v27) {
      break;
    }
    unsigned __int32 v28 = (unsigned __int8 *)&v23[v19];
    v29 = (int8x16_t *)v23;
    do
      int64_t v30 = v29++;
    while (v29 <= (int8x16_t *)v28 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v30)) & 0x80) != 0);
    do
    {
      int64_t v31 = v30;
      int64_t v30 = (int8x16_t *)((char *)v30 + 4);
    }
    while (v30 <= (int8x16_t *)v28 && !v31->i32[0]);
    if (v31 < (int8x16_t *)v28)
    {
      while (!v31->i8[0])
      {
        int64_t v31 = (int8x16_t *)((char *)v31 + 1);
        if (v31 >= (int8x16_t *)v28)
        {
          int64_t v31 = (int8x16_t *)&v23[v19];
          break;
        }
      }
    }
    int64_t v32 = (char *)v31 - v23;
    int64_t v33 = ((char *)v31 - v23) * a6;
    v20 += v33;
    v22 += v33;
    v23 += v33;
    v19 -= v32;
LABEL_31:
    if (v19 <= 3) {
      goto LABEL_34;
    }
  }
  uint64_t v47 = 0;
  while (1)
  {
    uint8x16_t v48 = *(uint8x16_t *)((char *)v20 + v47);
    uint8x16_t v49 = *(uint8x16_t *)((char *)v22 + v47);
    a14.i32[0] = v27;
    uint8x16_t v50 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a14, (int8x16_t)xmmword_1850CD8E0);
    uint16x8_t v51 = vmull_u8(*(uint8x8_t *)v48.i8, *(uint8x8_t *)v50.i8);
    uint16x8_t v52 = vmull_high_u8(v48, v50);
    uint16x8_t v53 = vminq_u16(v51, v26);
    uint16x8_t v54 = vminq_u16(v52, v26);
    uint16x8_t v55 = vrsraq_n_u16(v54, v54, 8uLL);
    *(uint8x8_t *)v51.i8 = vqrshrn_n_u16(vrsraq_n_u16(v53, v53, 8uLL), 8uLL);
    *(uint8x8_t *)&long long v18 = vqrshrn_n_u16(v55, 8uLL);
    int8x16_t v56 = vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CE040);
    uint8x16_t v57 = (uint8x16_t)vbicq_s8((int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v51.i8, v55, 8uLL), vceqzq_s8(v56));
    uint16x8_t v58 = vminq_u16(vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v56.i8), v26);
    uint16x8_t v59 = vminq_u16(vmull_high_u8(v49, (uint8x16_t)v56), v26);
    a14 = vrsraq_n_u16(v59, v59, 8uLL);
    *(uint8x16_t *)((char *)v22 + v47) = vqaddq_u8(v57, vqsubq_u8(v49, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v58, v58, 8uLL), 8uLL), a14, 8uLL)));
    v23 += v24;
    v19 -= 4;
    if (v19 < 4) {
      break;
    }
    unsigned __int32 v27 = *(_DWORD *)v23;
    v47 += v25;
    if ((*(_DWORD *)v23 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v20 = (unsigned __int32 *)((char *)v20 + v47);
      uint64_t v22 = (_DWORD *)((char *)v22 + v47);
      goto LABEL_31;
    }
  }
  unint64_t v20 = (unsigned __int32 *)((char *)v20 + v25 + v47);
  uint64_t v22 = (_DWORD *)((char *)v22 + v25 + v47);
LABEL_34:
  uint64_t v60 = v19 + a17;
  if (v60)
  {
    int8x16_t v61 = (int8x16_t)vdupq_n_s16(0xFE01u);
    do
    {
      a9.i32[0] = *v20;
      uint16x8_t v62 = vmovl_u8(*(uint8x8_t *)a9.i8);
      LOBYTE(v63) = v62.i8[0];
      BYTE1(v63) = v62.i8[2];
      BYTE2(v63) = v62.i8[4];
      HIBYTE(v63) = v62.i8[6];
      v62.i32[0] = *v22;
      uint16x8_t v64 = vmovl_u8(*(uint8x8_t *)v62.i8);
      LOBYTE(v65) = v64.i8[0];
      BYTE1(v65) = v64.i8[2];
      BYTE2(v65) = v64.i8[4];
      HIBYTE(v65) = v64.i8[6];
      v64.i8[7] = 0;
      v64.i8[0] = *v23;
      v64.i8[1] = *v23;
      v64.i8[2] = *v23;
      *(__int32 *)((char *)v64.i32 + 3) = *v23;
      uint16x8_t v66 = vminq_u16(vmull_u8((uint8x8_t)v63, *(uint8x8_t *)v64.i8), (uint16x8_t)v61);
      uint16x8_t v67 = vrsraq_n_u16(v66, v66, 8uLL);
      int8x8_t v68 = (int8x8_t)vqrshrn_n_u16(v67, 8uLL);
      *(int8x8_t *)v67.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v68, v67, 8uLL), (int8x8_t)0x404040400000000);
      uint8x8_t v69 = (uint8x8_t)vbic_s8(v68, vceqz_s8(*(int8x8_t *)v67.i8));
      uint16x8_t v70 = vminq_u16(vmull_u8((uint8x8_t)v65, *(uint8x8_t *)v67.i8), (uint16x8_t)v61);
      a9 = vrsraq_n_u16(v70, v70, 8uLL);
      *(uint8x8_t *)a9.i8 = vqadd_u8(v69, vqsub_u8((uint8x8_t)v65, vqrshrn_n_u16(a9, 8uLL)));
      *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a9, v61));
      *uint64_t v22 = a9.i32[0];
      uint16x8_t v71 = &v20[a6];
      v23 += a6;
      if ((unint64_t)v71 >= v21) {
        uint64_t v72 = -(uint64_t)a5;
      }
      else {
        uint64_t v72 = 0;
      }
      unint64_t v20 = &v71[v72];
      v22 += a6;
      --v60;
    }
    while (v60);
  }
  *result = v20;
  *a3 = v21;
  *a2 = v22;
  *a4 = v23;
  return result;
}

_DWORD **vec::template_mark_pixelmask_row<(CGCompositeOperation)1,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, uint8x8_t a8, double a9, double a10, double a11, int8x16_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v16 = a16;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a16 < 4) {
    goto LABEL_34;
  }
  uint64_t v21 = 4 * a6;
  uint64_t v22 = 16 * a6;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  a8.i32[1] = 16843009;
  uint16x8_t v24 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  while (1)
  {
    unsigned __int32 v25 = *(_DWORD *)v20;
    if (*(_DWORD *)v20 == -1)
    {
      int64_t v32 = (unsigned __int8 *)&v20[v16];
      int64_t v33 = (int8x16_t *)v20;
      do
        int64_t v34 = v33++;
      while (v33 <= (int8x16_t *)v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, v23)) & 0x80) != 0);
      do
      {
        v35 = v34;
        int64_t v34 = (int8x16_t *)((char *)v34 + 4);
      }
      while (v34 <= (int8x16_t *)v32 && v35->i32[0] == -1);
      if (v35 < (int8x16_t *)v32)
      {
        while (v35->u8[0] == 255)
        {
          v35 = (int8x16_t *)((char *)v35 + 1);
          if (v35 >= (int8x16_t *)v32)
          {
            v35 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      uint64_t v36 = 0;
      int64_t v37 = (char *)v35 - v20;
      unint64_t v38 = (char *)v35 - v20;
      do
      {
        *(_OWORD *)((char *)v19 + v36) = *(_OWORD *)((char *)v17 + v36);
        v20 += v21;
        v38 -= 4;
        v36 += v22;
      }
      while (v38 > 3);
      unint64_t v19 = (_DWORD *)((char *)v19 + v36);
      unint64_t v17 = (_DWORD *)((char *)v17 + v36);
      unint64_t v16 = v16 - v37 + v38;
      goto LABEL_31;
    }
    if (v25) {
      break;
    }
    uint16x8_t v26 = (unsigned __int8 *)&v20[v16];
    unsigned __int32 v27 = (int8x16_t *)v20;
    do
      unsigned __int32 v28 = v27++;
    while (v27 <= (int8x16_t *)v26 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v28)) & 0x80) != 0);
    do
    {
      v29 = v28;
      unsigned __int32 v28 = (int8x16_t *)((char *)v28 + 4);
    }
    while (v28 <= (int8x16_t *)v26 && !v29->i32[0]);
    if (v29 < (int8x16_t *)v26)
    {
      while (!v29->i8[0])
      {
        v29 = (int8x16_t *)((char *)v29 + 1);
        if (v29 >= (int8x16_t *)v26)
        {
          v29 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    int64_t v30 = (char *)v29 - v20;
    int64_t v31 = ((char *)v29 - v20) * a6;
    v17 += v31;
    v19 += v31;
    v20 += v31;
    v16 -= v30;
LABEL_31:
    if (v16 <= 3) {
      goto LABEL_34;
    }
  }
  uint64_t v39 = 0;
  while (1)
  {
    uint8x16_t v40 = *(uint8x16_t *)((char *)v17 + v39);
    uint8x16_t v41 = *(uint8x16_t *)((char *)v19 + v39);
    a12.i32[0] = v25;
    a12 = vqtbl1q_s8(a12, (int8x16_t)xmmword_1850CD8E0);
    uint8x16_t v42 = (uint8x16_t)vmvnq_s8(a12);
    uint16x8_t v43 = vmlal_u8(vmull_u8(*(uint8x8_t *)v41.i8, *(uint8x8_t *)v42.i8), *(uint8x8_t *)v40.i8, *(uint8x8_t *)a12.i8);
    uint16x8_t v44 = vmlal_high_u8(vmull_high_u8(v41, v42), v40, (uint8x16_t)a12);
    uint16x8_t v45 = vminq_u16(v43, v24);
    uint16x8_t v46 = vminq_u16(v44, v24);
    *(uint8x16_t *)((char *)v19 + v39) = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v45, v45, 8uLL), 8uLL), vrsraq_n_u16(v46, v46, 8uLL), 8uLL);
    v20 += v21;
    v16 -= 4;
    if (v16 < 4) {
      break;
    }
    unsigned __int32 v25 = *(_DWORD *)v20;
    v39 += v22;
    if ((*(_DWORD *)v20 - 1) >= 0xFFFFFFFE)
    {
      unint64_t v17 = (_DWORD *)((char *)v17 + v39);
      unint64_t v19 = (_DWORD *)((char *)v19 + v39);
      goto LABEL_31;
    }
  }
  unint64_t v17 = (_DWORD *)((char *)v17 + v22 + v39);
  unint64_t v19 = (_DWORD *)((char *)v19 + v22 + v39);
LABEL_34:
  uint64_t v47 = v16 + a15;
  if (v47)
  {
    int8x16_t v48 = (int8x16_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.i32[0] = *v17;
      uint16x8_t v49 = vmovl_u8(a8);
      LOBYTE(v50) = v49.i8[0];
      BYTE1(v50) = v49.i8[2];
      BYTE2(v50) = v49.i8[4];
      HIBYTE(v50) = v49.i8[6];
      v49.i32[0] = *v19;
      uint16x8_t v51 = vmovl_u8(*(uint8x8_t *)v49.i8);
      LOBYTE(v52) = v51.i8[0];
      BYTE1(v52) = v51.i8[2];
      BYTE2(v52) = v51.i8[4];
      HIBYTE(v52) = v51.i8[6];
      v51.i8[7] = 0;
      v51.i8[0] = *v20;
      v51.i8[1] = *v20;
      v51.i8[2] = *v20;
      *(__int32 *)((char *)v51.i32 + 3) = *v20;
      uint16x8_t v53 = vminq_u16(vmlal_u8(vmull_u8((uint8x8_t)v52, (uint8x8_t)vmvn_s8(*(int8x8_t *)v51.i8)), (uint8x8_t)v50, *(uint8x8_t *)v51.i8), (uint16x8_t)v48);
      int8x16_t v54 = (int8x16_t)vrsraq_n_u16(v53, v53, 8uLL);
      *(uint8x8_t *)v54.i8 = vqrshrn_n_u16((uint16x8_t)v54, 8uLL);
      a8 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v54, v48));
      *unint64_t v19 = a8.i32[0];
      uint16x8_t v55 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v55 >= v18) {
        uint64_t v56 = -(uint64_t)a5;
      }
      else {
        uint64_t v56 = 0;
      }
      unint64_t v17 = &v55[v56];
      v19 += a6;
      --v47;
    }
    while (v47);
  }
  *result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

uint64_t *vec::template_mark_pixelmask_row<(CGCompositeOperation)0,_argb8_t>(uint64_t *result, uint8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, uint16x8_t a8, double a9, double a10, double a11, uint16x8_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v16 = a16;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a16 < 4) {
    goto LABEL_33;
  }
  uint64_t v21 = 4 * a6;
  uint64_t v22 = 16 * a6;
  a8.i64[0] = -1;
  a8.i64[1] = -1;
  uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  while (1)
  {
    unsigned __int32 v24 = *(_DWORD *)v20;
    if (*(_DWORD *)v20 == -1)
    {
      int64_t v34 = (unsigned __int8 *)&v20[v16];
      v35 = (int8x16_t *)v20;
      do
        uint64_t v36 = v35++;
      while (v35 <= (int8x16_t *)v34 && (vminvq_u8((uint8x16_t)vceqq_s8(*v36, (int8x16_t)a8)) & 0x80) != 0);
      do
      {
        int64_t v37 = v36;
        uint64_t v36 = (int8x16_t *)((char *)v36 + 4);
      }
      while (v36 <= (int8x16_t *)v34 && v37->i32[0] == -1);
      if (v37 < (int8x16_t *)v34)
      {
        while (v37->u8[0] == 255)
        {
          int64_t v37 = (int8x16_t *)((char *)v37 + 1);
          if (v37 >= (int8x16_t *)v34)
          {
            int64_t v37 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      uint64_t v38 = 0;
      int64_t v39 = (char *)v37 - v20;
      unint64_t v40 = (char *)v37 - v20;
      do
      {
        *(_OWORD *)&v19->i8[v38] = 0uLL;
        v20 += v21;
        v40 -= 4;
        v38 += v22;
      }
      while (v40 > 3);
      unint64_t v19 = (uint8x8_t *)((char *)v19 + v38);
      v17 += v38;
      unint64_t v16 = v16 - v39 + v40;
      goto LABEL_30;
    }
    if (v24) {
      break;
    }
    unsigned __int32 v25 = (unsigned __int8 *)&v20[v16];
    uint16x8_t v26 = (int8x16_t *)v20;
    do
      unsigned __int32 v27 = v26++;
    while (v26 <= (int8x16_t *)v25 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v27)) & 0x80) != 0);
    do
    {
      unsigned __int32 v28 = v27;
      unsigned __int32 v27 = (int8x16_t *)((char *)v27 + 4);
    }
    while (v27 <= (int8x16_t *)v25 && !v28->i32[0]);
    if (v28 < (int8x16_t *)v25)
    {
      while (!v28->i8[0])
      {
        unsigned __int32 v28 = (int8x16_t *)((char *)v28 + 1);
        if (v28 >= (int8x16_t *)v25)
        {
          unsigned __int32 v28 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    int64_t v29 = (char *)v28 - v20;
    int64_t v30 = ((char *)v28 - v20) * a6;
    v17 += 4 * v30;
    unint64_t v19 = (uint8x8_t *)((char *)v19 + 4 * v30);
    v20 += v30;
    v16 -= v29;
LABEL_30:
    if (v16 <= 3) {
      goto LABEL_33;
    }
  }
  while (1)
  {
    a12.i32[0] = v24;
    uint8x16_t v31 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a12, (int8x16_t)xmmword_1850CD8E0);
    uint16x8_t v32 = vminq_u16(vmull_u8(*v19, *(uint8x8_t *)v31.i8), v23);
    uint16x8_t v33 = vminq_u16(vmull_high_u8(*(uint8x16_t *)v19->i8, v31), v23);
    a12 = vrsraq_n_u16(v33, v33, 8uLL);
    *(uint8x16_t *)v19->i8 = vqsubq_u8(*(uint8x16_t *)v19->i8, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v32, v32, 8uLL), 8uLL), a12, 8uLL));
    v20 += v21;
    v16 -= 4;
    if (v16 < 4) {
      break;
    }
    unsigned __int32 v24 = *(_DWORD *)v20;
    v17 += v22;
    unint64_t v19 = (uint8x8_t *)((char *)v19 + v22);
    if ((*(_DWORD *)v20 - 1) >= 0xFFFFFFFE) {
      goto LABEL_30;
    }
  }
  v17 += v22;
  unint64_t v19 = (uint8x8_t *)((char *)v19 + v22);
LABEL_33:
  uint64_t v41 = v16 + a15;
  if (v41)
  {
    int8x16_t v42 = (int8x16_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.i32[0] = v19->i32[0];
      uint16x8_t v43 = vmovl_u8(*(uint8x8_t *)a8.i8);
      LOBYTE(v44) = v43.i8[0];
      BYTE1(v44) = v43.i8[2];
      BYTE2(v44) = v43.i8[4];
      HIBYTE(v44) = v43.i8[6];
      v43.i8[7] = 0;
      v43.i8[0] = *v20;
      v43.i8[1] = *v20;
      v43.i8[2] = *v20;
      *(__int32 *)((char *)v43.i32 + 3) = *v20;
      uint16x8_t v45 = vminq_u16(vmull_u8((uint8x8_t)v44, *(uint8x8_t *)v43.i8), (uint16x8_t)v42);
      a8 = vrsraq_n_u16(v45, v45, 8uLL);
      *(uint8x8_t *)a8.i8 = vqsub_u8((uint8x8_t)v44, vqrshrn_n_u16(a8, 8uLL));
      *(int8x8_t *)a8.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, v42));
      v19->i32[0] = a8.i32[0];
      unint64_t v46 = v17 + 4 * a6;
      v20 += a6;
      if (v46 >= v18) {
        uint64_t v47 = -(uint64_t)a5;
      }
      else {
        uint64_t v47 = 0;
      }
      unint64_t v17 = v46 + 4 * v47;
      unint64_t v19 = (uint8x8_t *)((char *)v19 + 4 * a6);
      --v41;
    }
    while (v41);
  }
  *result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)23,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, int8x16_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      int8x16_t v26 = vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v28 = vminq_u8((uint8x16_t)v24, (uint8x16_t)v26);
      int8x16_t v29 = (int8x16_t)vminq_u8((uint8x16_t)v25, (uint8x16_t)v27);
      uint8x16_t v30 = (uint8x16_t)vmvnq_s8(v29);
      int8x16_t v31 = (int8x16_t)vcgtq_u8((uint8x16_t)(*(_OWORD *)&v29 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)), v30);
      uint8x16_t v32 = vabdq_u8(v30, (uint8x16_t)(*(_OWORD *)&v29 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00)));
      uint16x8_t v33 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v32.i8);
      uint16x8_t v34 = vmull_high_u8(v28, v32);
      uint16x8_t v35 = vminq_u16(v33, v23);
      uint16x8_t v36 = vminq_u16(v34, v23);
      uint8x16_t v37 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v35, v35, 8uLL), 8uLL), vrsraq_n_u16(v36, v36, 8uLL), 8uLL);
      int8x16_t v38 = vbslq_s8(v31, (int8x16_t)vqsubq_u8((uint8x16_t)v29, v37), (int8x16_t)vqaddq_u8((uint8x16_t)v29, v37));
      a13 = vbslq_s8(vceqzq_s8(v26), v25, vbslq_s8(vceqzq_s8(v27), v24, (int8x16_t)vminq_u8((uint8x16_t)v38, (uint8x16_t)vqtbl1q_s8(v38, (int8x16_t)xmmword_1850CE030))));
      *(int8x16_t *)&v17[v18] = a13;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v39 = v14 + a8;
  if (v39)
  {
    if (a6) {
      unsigned int v40 = 0;
    }
    else {
      unsigned int v40 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v40), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v41 = 0;
    }
    else {
      unsigned int v41 = -1;
    }
    int8x8_t v42 = vand_s8(vdup_n_s8(v41), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v43 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v44 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v45) = v44.i8[0];
      BYTE1(v45) = v44.i8[2];
      BYTE2(v45) = v44.i8[4];
      HIBYTE(v45) = v44.i8[6];
      v44.i32[0] = *v17;
      a13 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v44.i8);
      LOBYTE(v46) = a13.i8[0];
      BYTE1(v46) = a13.i8[2];
      BYTE2(v46) = a13.i8[4];
      HIBYTE(v46) = a13.i8[6];
      *(int8x8_t *)a13.i8 = vorr_s8((int8x8_t)v45, *(int8x8_t *)a9.i8);
      int8x8_t v47 = vorr_s8((int8x8_t)v46, v42);
      v48.i64[0] = a13.i64[0];
      v48.i64[1] = a13.i64[0];
      *(int8x8_t *)v48.i8 = vqtbl1_s8(v48, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v49.i8 = v47;
      v49.u64[1] = (unint64_t)v47;
      *(int8x8_t *)v49.i8 = vqtbl1_s8(v49, (int8x8_t)0x404040400000000);
      int8x8_t v50 = (int8x8_t)vmin_u8((uint8x8_t)v47, *(uint8x8_t *)v49.i8);
      uint8x8_t v51 = (uint8x8_t)vmvn_s8(v50);
      uint16x8_t v52 = vminq_u16(vmull_u8(vmin_u8(*(uint8x8_t *)a13.i8, *(uint8x8_t *)v48.i8), vabd_u8(v51, (uint8x8_t)(*(void *)&v50 & 0xFFFFFF00FFFFFF00))), v43);
      *(uint8x8_t *)v52.i8 = vqrshrn_n_u16(vrsraq_n_u16(v52, v52, 8uLL), 8uLL);
      *(int8x8_t *)v53.i8 = vbsl_s8((int8x8_t)vcgt_u8((uint8x8_t)(*(void *)&v50 & 0xFFFFFF00FFFFFF00), v51), (int8x8_t)vqsub_u8((uint8x8_t)v50, *(uint8x8_t *)v52.i8), (int8x8_t)vqadd_u8((uint8x8_t)v50, *(uint8x8_t *)v52.i8));
      v53.i64[1] = v53.i64[0];
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v48.i8), v47, vbsl_s8(vceqz_s8(*(int8x8_t *)v49.i8), *(int8x8_t *)a13.i8, (int8x8_t)vmin_u8(*(uint8x8_t *)v53.i8, (uint8x8_t)vqtbl1_s8(v53, (int8x8_t)0x404040400000000))));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a13, a9));
      *unint64_t v17 = a13.i32[0];
      int8x16_t v54 = &v15[a5];
      if ((unint64_t)v54 >= v16) {
        uint64_t v55 = -(uint64_t)a4;
      }
      else {
        uint64_t v55 = 0;
      }
      v15 = &v54[v55];
      v17 += a5;
      --v39;
    }
    while (v39);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)22,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, double a13, int8x16_t a14, unint64_t a15)
{
  unint64_t v15 = a15;
  unint64_t v16 = *result;
  unint64_t v17 = *a3;
  uint64_t v18 = *a2;
  if (a15 >= 4)
  {
    uint64_t v19 = 0;
    if (a6) {
      unsigned int v20 = 0;
    }
    else {
      unsigned int v20 = -1;
    }
    int8x16_t v21 = vdupq_n_s8(v20);
    v22.i64[0] = 0xFF000000FFLL;
    v22.i64[1] = 0xFF000000FFLL;
    if (a7) {
      unsigned int v23 = 0;
    }
    else {
      unsigned int v23 = -1;
    }
    a9 = vandq_s8(v21, v22);
    int8x16_t v24 = vandq_s8(vdupq_n_s8(v23), v22);
    uint16x8_t v25 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    a14.i64[0] = -65536;
    a14.i64[1] = -65536;
    do
    {
      int8x16_t v26 = vorrq_s8(*(int8x16_t *)&v16[v19], a9);
      int8x16_t v27 = vorrq_s8(*(int8x16_t *)&v18[v19], v24);
      int8x16_t v28 = vqtbl1q_s8(v26, (int8x16_t)xmmword_1850CE030);
      int8x16_t v29 = vqtbl1q_s8(v27, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v30 = vminq_u8((uint8x16_t)v26, (uint8x16_t)v28);
      uint8x16_t v31 = vminq_u8((uint8x16_t)v27, (uint8x16_t)v29);
      uint8x16_t v32 = (uint8x16_t)vmvnq_s8(v28);
      uint8x16_t v33 = (uint8x16_t)vmvnq_s8(v29);
      v57.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_u8(*(uint8x8_t *)v30.i8, *(uint8x8_t *)v29.i8), (uint16x8_t)vandq_s8((int8x16_t)vmull_u8(*(uint8x8_t *)v31.i8, *(uint8x8_t *)v28.i8), a14)), vmull_u8(*(uint8x8_t *)v31.i8, *(uint8x8_t *)v32.i8)), vmull_u8(*(uint8x8_t *)v30.i8, *(uint8x8_t *)v33.i8));
      uint16x8_t v34 = vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_high_u8(v30, (uint8x16_t)v29), (uint16x8_t)vandq_s8((int8x16_t)vmull_high_u8(v31, (uint8x16_t)v28), a14)), vmull_high_u8(v31, v32)), vmull_high_u8(v30, v33));
      uint16x8_t v35 = vminq_u16((uint16x8_t)v57.val[1], v25);
      uint16x8_t v36 = vminq_u16(v34, v25);
      v57.val[0] = (int8x16_t)vrsraq_n_u16(v35, v35, 8uLL);
      uint16x8_t v37 = vrsraq_n_u16(v36, v36, 8uLL);
      *(uint8x8_t *)v57.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v57.val[0], 8uLL);
      *(uint8x8_t *)v57.val[1].i8 = vqrshrn_n_u16(v37, 8uLL);
      *(int8x16_t *)&v18[v19] = vbslq_s8(vceqzq_s8(v28), v27, vbslq_s8(vceqzq_s8(v29), v26, (int8x16_t)vminq_u8(vqrshrn_high_n_u16(*(uint8x8_t *)v57.val[0].i8, v37, 8uLL), (uint8x16_t)vqtbl2q_s8(v57, (int8x16_t)xmmword_1850CE040))));
      v15 -= 4;
      v19 += 4 * a5;
    }
    while (v15 > 3);
    uint64_t v18 = (_DWORD *)((char *)v18 + v19 * 4);
    unint64_t v16 = (unsigned __int32 *)((char *)v16 + v19 * 4);
  }
  uint64_t v38 = v15 + a8;
  if (v38)
  {
    if (a6) {
      unsigned int v39 = 0;
    }
    else {
      unsigned int v39 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v39), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v40 = 0;
    }
    else {
      unsigned int v40 = -1;
    }
    int8x8_t v41 = vand_s8(vdup_n_s8(v40), (int8x8_t)0xFF000000FFLL);
    v42.i64[0] = -65536;
    v42.i64[1] = -65536;
    uint16x8_t v43 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a14.i32[0] = *v16;
      uint16x8_t v44 = vmovl_u8(*(uint8x8_t *)a14.i8);
      LOBYTE(v45) = v44.i8[0];
      BYTE1(v45) = v44.i8[2];
      BYTE2(v45) = v44.i8[4];
      HIBYTE(v45) = v44.i8[6];
      v44.i32[0] = *v18;
      a14 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v44.i8);
      LOBYTE(v46) = a14.i8[0];
      BYTE1(v46) = a14.i8[2];
      BYTE2(v46) = a14.i8[4];
      HIBYTE(v46) = a14.i8[6];
      *(int8x8_t *)a14.i8 = vorr_s8((int8x8_t)v45, *(int8x8_t *)a9.i8);
      int8x8_t v47 = vorr_s8((int8x8_t)v46, v41);
      v48.i64[0] = a14.i64[0];
      v48.i64[1] = a14.i64[0];
      *(int8x8_t *)v48.i8 = vqtbl1_s8(v48, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v49.i8 = v47;
      v49.u64[1] = (unint64_t)v47;
      *(int8x8_t *)v49.i8 = vqtbl1_s8(v49, (int8x8_t)0x404040400000000);
      uint8x8_t v50 = vmin_u8(*(uint8x8_t *)a14.i8, *(uint8x8_t *)v48.i8);
      uint8x8_t v51 = vmin_u8((uint8x8_t)v47, *(uint8x8_t *)v49.i8);
      uint16x8_t v52 = vminq_u16(vqaddq_u16(vqaddq_u16(vabdq_u16(vmull_u8(v50, *(uint8x8_t *)v49.i8), (uint16x8_t)vandq_s8((int8x16_t)vmull_u8(v51, *(uint8x8_t *)v48.i8), v42)), vmull_u8(v51, (uint8x8_t)vmvn_s8(*(int8x8_t *)v48.i8))), vmull_u8(v50, (uint8x8_t)vmvn_s8(*(int8x8_t *)v49.i8))), v43);
      uint16x8_t v53 = vrsraq_n_u16(v52, v52, 8uLL);
      uint8x8_t v54 = vqrshrn_n_u16(v53, 8uLL);
      *(int8x8_t *)a14.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v48.i8), v47, vbsl_s8(vceqz_s8(*(int8x8_t *)v49.i8), *(int8x8_t *)a14.i8, (int8x8_t)vmin_u8(v54, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v54, v53, 8uLL), (int8x8_t)0x404040400000000))));
      *(int8x8_t *)a14.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a14, a9));
      _DWORD *v18 = a14.i32[0];
      uint64_t v55 = &v16[a5];
      if ((unint64_t)v55 >= v17) {
        uint64_t v56 = -(uint64_t)a4;
      }
      else {
        uint64_t v56 = 0;
      }
      unint64_t v16 = &v55[v56];
      v18 += a5;
      --v38;
    }
    while (v38);
  }
  *result = v16;
  *a3 = v17;
  *a2 = v18;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)21,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, double a13, int8x16_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  uint64_t v19 = *a2;
  if (a15 >= 4)
  {
    uint64_t v20 = 0;
    if (a6) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vdupq_n_s8(v21);
    v23.i64[0] = 0xFF000000FFLL;
    v23.i64[1] = 0xFF000000FFLL;
    if (a7) {
      unsigned int v24 = 0;
    }
    else {
      unsigned int v24 = -1;
    }
    a9 = vandq_s8(v22, v23);
    int8x16_t v25 = vandq_s8(vdupq_n_s8(v24), v23);
    uint16x8_t v26 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    a14 = 0uLL;
    do
    {
      int8x16_t v27 = vorrq_s8(*(int8x16_t *)&v17[v20], a9);
      int8x16_t v28 = vorrq_s8(*(int8x16_t *)&v19[v20], v25);
      int8x16_t v29 = vqtbl1q_s8(v27, (int8x16_t)xmmword_1850CE030);
      int8x16_t v30 = vqtbl1q_s8(v28, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v31 = vminq_u8((uint8x16_t)v27, (uint8x16_t)v29);
      uint8x16_t v32 = vminq_u8((uint8x16_t)v28, (uint8x16_t)v30);
      int8x16_t v33 = (int8x16_t)vcgeq_u8(vrhaddq_u8((uint8x16_t)v29, (uint8x16_t)0), v31);
      int8x16_t v34 = vzip1q_s8(v33, v33);
      uint16x8_t v35 = vmull_u8(*(uint8x8_t *)v31.i8, *(uint8x8_t *)v32.i8);
      uint16x8_t v36 = vmull_high_u8(v31, v32);
      uint8x16_t v37 = vqsubq_u8((uint8x16_t)v30, v32);
      uint8x16_t v38 = vqsubq_u8((uint8x16_t)v29, v31);
      uint16x8_t v39 = vmull_u8(*(uint8x8_t *)v37.i8, *(uint8x8_t *)v38.i8);
      uint16x8_t v40 = vmull_high_u8(v37, v38);
      uint16x8_t v41 = (uint16x8_t)vbslq_s8(vzip2q_s8(v33, v33), (int8x16_t)vqaddq_u16(v36, v36), (int8x16_t)vqsubq_u16(vmull_high_u8((uint8x16_t)v30, (uint8x16_t)v29), vqaddq_u16(v40, v40)));
      uint16x8_t v42 = (uint16x8_t)vbslq_s8(v34, (int8x16_t)vqaddq_u16(v35, v35), (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v30.i8, *(uint8x8_t *)v29.i8), vqaddq_u16(v39, v39)));
      uint8x16_t v43 = (uint8x16_t)vmvnq_s8(v29);
      uint16x8_t v44 = vmull_u8(*(uint8x8_t *)v32.i8, *(uint8x8_t *)v43.i8);
      uint16x8_t v45 = vqaddq_u16(v41, vmull_high_u8(v32, v43));
      uint8x16_t v46 = (uint8x16_t)vmvnq_s8(v30);
      uint16x8_t v47 = vmull_u8(*(uint8x8_t *)v31.i8, *(uint8x8_t *)v46.i8);
      uint16x8_t v48 = vmull_high_u8(v31, v46);
      v74.val[1] = (int8x16_t)vqaddq_u16(vqaddq_u16(v42, v44), v47);
      uint16x8_t v49 = vqaddq_u16(v45, v48);
      uint16x8_t v50 = vminq_u16((uint16x8_t)v74.val[1], v26);
      uint16x8_t v51 = vminq_u16(v49, v26);
      v74.val[0] = (int8x16_t)vrsraq_n_u16(v50, v50, 8uLL);
      uint16x8_t v52 = vrsraq_n_u16(v51, v51, 8uLL);
      *(uint8x8_t *)v74.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v74.val[0], 8uLL);
      *(uint8x8_t *)v74.val[1].i8 = vqrshrn_n_u16(v52, 8uLL);
      uint8x16_t v53 = (uint8x16_t)vqtbl2q_s8(v74, (int8x16_t)xmmword_1850CE040);
      int8x16_t v15 = (int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v74.val[0].i8, v52, 8uLL);
      *(int8x16_t *)&v19[v20] = vbslq_s8(vceqzq_s8(v29), v28, vbslq_s8(vceqzq_s8(v30), v27, (int8x16_t)vminq_u8((uint8x16_t)v15, v53)));
      v16 -= 4;
      v20 += 4 * a5;
    }
    while (v16 > 3);
    uint64_t v19 = (_DWORD *)((char *)v19 + v20 * 4);
    unint64_t v17 = (unsigned __int32 *)((char *)v17 + v20 * 4);
  }
  uint64_t v54 = v16 + a8;
  if (v54)
  {
    if (a6) {
      unsigned int v55 = 0;
    }
    else {
      unsigned int v55 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v55), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v56 = 0;
    }
    else {
      unsigned int v56 = -1;
    }
    int8x8_t v57 = vand_s8(vdup_n_s8(v56), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v58 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a14.i32[0] = *v17;
      uint16x8_t v59 = vmovl_u8(*(uint8x8_t *)a14.i8);
      LOBYTE(v60) = v59.i8[0];
      BYTE1(v60) = v59.i8[2];
      BYTE2(v60) = v59.i8[4];
      HIBYTE(v60) = v59.i8[6];
      v59.i32[0] = *v19;
      a14 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v59.i8);
      LOBYTE(v61) = a14.i8[0];
      BYTE1(v61) = a14.i8[2];
      BYTE2(v61) = a14.i8[4];
      HIBYTE(v61) = a14.i8[6];
      *(int8x8_t *)a14.i8 = vorr_s8((int8x8_t)v60, *(int8x8_t *)a9.i8);
      int8x8_t v62 = vorr_s8((int8x8_t)v61, v57);
      v63.i64[0] = a14.i64[0];
      v63.i64[1] = a14.i64[0];
      *(int8x8_t *)v64.i8 = v62;
      v64.u64[1] = (unint64_t)v62;
      *(int8x8_t *)v63.i8 = vqtbl1_s8(v63, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v64.i8 = vqtbl1_s8(v64, (int8x8_t)0x404040400000000);
      uint8x8_t v65 = vmin_u8(*(uint8x8_t *)a14.i8, *(uint8x8_t *)v63.i8);
      uint8x8_t v66 = vmin_u8((uint8x8_t)v62, *(uint8x8_t *)v64.i8);
      *(uint8x8_t *)v15.i8 = vcge_u8(vrhadd_u8(*(uint8x8_t *)v63.i8, 0), v65);
      uint16x8_t v67 = vmull_u8(v65, v66);
      uint16x8_t v68 = vmull_u8(vqsub_u8(*(uint8x8_t *)v64.i8, v66), vqsub_u8(*(uint8x8_t *)v63.i8, v65));
      uint16x8_t v69 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vbslq_s8(vzip1q_s8(v15, v15), (int8x16_t)vqaddq_u16(v67, v67), (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v64.i8, *(uint8x8_t *)v63.i8), vqaddq_u16(v68, v68))), vmull_u8(v66, (uint8x8_t)vmvn_s8(*(int8x8_t *)v63.i8))), vmull_u8(v65, (uint8x8_t)vmvn_s8(*(int8x8_t *)v64.i8))), v58);
      uint16x8_t v70 = vrsraq_n_u16(v69, v69, 8uLL);
      uint8x8_t v71 = vqrshrn_n_u16(v70, 8uLL);
      int8x16_t v15 = (int8x16_t)vqrshrn_high_n_u16(v71, v70, 8uLL);
      *(int8x8_t *)a14.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v63.i8), v62, vbsl_s8(vceqz_s8(*(int8x8_t *)v64.i8), *(int8x8_t *)a14.i8, (int8x8_t)vmin_u8(v71, (uint8x8_t)vqtbl1_s8(v15, (int8x8_t)0x404040400000000))));
      *(int8x8_t *)a14.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a14, a9));
      *uint64_t v19 = a14.i32[0];
      uint64_t v72 = &v17[a5];
      if ((unint64_t)v72 >= v18) {
        uint64_t v73 = -(uint64_t)a4;
      }
      else {
        uint64_t v73 = 0;
      }
      unint64_t v17 = &v72[v73];
      v19 += a5;
      --v54;
    }
    while (v54);
  }
  *result = v17;
  *a3 = v18;
  *a2 = v19;
  return result;
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)20,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, uint8x8_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  int8x16_t v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    a13.i32[1] = 67372036;
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      int8x16_t v26 = vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v28 = vminq_u8((uint8x16_t)v24, (uint8x16_t)v26);
      uint8x16_t v29 = vminq_u8((uint8x16_t)v25, (uint8x16_t)v27);
      uint16x8_t v30 = vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v29.i8);
      uint16x8_t v31 = vmull_high_u8(v29, v29);
      int8x8_t v32 = (int8x8_t)vextq_s8(v27, v27, 8uLL).u64[0];
      *(int8x8_t *)v30.i8 = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v30.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v30)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v27.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))));
      int16x8_t v33 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v31.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v32, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v31)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v32, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))))));
      uint16x8_t v34 = vmull_u8(*(uint8x8_t *)v30.i8, *(uint8x8_t *)v26.i8);
      uint16x8_t v35 = vmull_u8((uint8x8_t)vqmovun_s16(v33), (uint8x8_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
      uint8x16_t v36 = vqsubq_u8(v29, (uint8x16_t)vqmovun_high_s16(*(int8x8_t *)v30.i8, v33));
      uint16x8_t v37 = vmull_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v28.i8);
      uint16x8_t v38 = vmull_high_u8(v36, v28);
      uint16x8_t v39 = vqaddq_u16(v34, vqaddq_u16(v37, v37));
      uint16x8_t v40 = vqaddq_u16(v35, vqaddq_u16(v38, v38));
      uint8x16_t v41 = (uint8x16_t)vmvnq_s8(v26);
      uint16x8_t v42 = vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v41.i8);
      uint16x8_t v43 = vmull_high_u8(v29, v41);
      uint16x8_t v44 = vqaddq_u16(v39, v42);
      uint16x8_t v45 = vqaddq_u16(v40, v43);
      uint8x16_t v46 = (uint8x16_t)vmvnq_s8(v27);
      uint16x8_t v47 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v46.i8);
      uint16x8_t v48 = vmull_high_u8(v28, v46);
      v75.val[1] = (int8x16_t)vqaddq_u16(v44, v47);
      uint16x8_t v49 = vqaddq_u16(v45, v48);
      uint16x8_t v50 = vminq_u16((uint16x8_t)v75.val[1], v23);
      uint16x8_t v51 = vminq_u16(v49, v23);
      v75.val[0] = (int8x16_t)vrsraq_n_u16(v50, v50, 8uLL);
      uint16x8_t v52 = vrsraq_n_u16(v51, v51, 8uLL);
      *(uint8x8_t *)v75.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v75.val[0], 8uLL);
      *(uint8x8_t *)v75.val[1].i8 = vqrshrn_n_u16(v52, 8uLL);
      *(int8x16_t *)&v17[v18] = vbslq_s8(vceqzq_s8(v26), v25, vbslq_s8(vceqzq_s8(v27), v24, (int8x16_t)vminq_u8(vqrshrn_high_n_u16(*(uint8x8_t *)v75.val[0].i8, v52, 8uLL), (uint8x16_t)vqtbl2q_s8(v75, (int8x16_t)xmmword_1850CE040))));
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    int8x16_t v15 = (_DWORD *)((char *)v15 + v18 * 4);
  }
  uint64_t v53 = v14 + a8;
  if (v53)
  {
    if (a6) {
      unsigned int v54 = 0;
    }
    else {
      unsigned int v54 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v54), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v55 = 0;
    }
    else {
      unsigned int v55 = -1;
    }
    int8x8_t v56 = vand_s8(vdup_n_s8(v55), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v57 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v58 = vmovl_u8(a13);
      LOBYTE(v59) = v58.i8[0];
      BYTE1(v59) = v58.i8[2];
      BYTE2(v59) = v58.i8[4];
      HIBYTE(v59) = v58.i8[6];
      v58.i32[0] = *v17;
      int8x16_t v60 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v58.i8);
      LOBYTE(v61) = v60.i8[0];
      BYTE1(v61) = v60.i8[2];
      BYTE2(v61) = v60.i8[4];
      HIBYTE(v61) = v60.i8[6];
      *(int8x8_t *)v60.i8 = vorr_s8((int8x8_t)v59, *(int8x8_t *)a9.i8);
      int8x8_t v62 = vorr_s8((int8x8_t)v61, v56);
      v63.i64[0] = v60.i64[0];
      v63.i64[1] = v60.i64[0];
      *(int8x8_t *)v63.i8 = vqtbl1_s8(v63, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v64.i8 = v62;
      v64.u64[1] = (unint64_t)v62;
      *(int8x8_t *)v64.i8 = vqtbl1_s8(v64, (int8x8_t)0x404040400000000);
      uint8x8_t v65 = vmin_u8(*(uint8x8_t *)v60.i8, *(uint8x8_t *)v63.i8);
      uint8x8_t v66 = vmin_u8((uint8x8_t)v62, *(uint8x8_t *)v64.i8);
      uint16x8_t v67 = vmull_u8(v66, v66);
      *(int8x8_t *)v67.i8 = vqmovun_s16(vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v67.i8)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v62.u8[0]) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmovl_high_u16(v67)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v62.u8[4]) & 0xFF00FF00FF00FFLL)))))));
      uint16x8_t v68 = vmull_u8(*(uint8x8_t *)v67.i8, *(uint8x8_t *)v63.i8);
      uint16x8_t v69 = vmull_u8(vqsub_u8(v66, *(uint8x8_t *)v67.i8), v65);
      uint16x8_t v70 = vminq_u16(vqaddq_u16(vqaddq_u16(vqaddq_u16(v68, vqaddq_u16(v69, v69)), vmull_u8(v66, (uint8x8_t)vmvn_s8(*(int8x8_t *)v63.i8))), vmull_u8(v65, (uint8x8_t)vmvn_s8(*(int8x8_t *)v64.i8))), v57);
      uint16x8_t v71 = vrsraq_n_u16(v70, v70, 8uLL);
      uint8x8_t v72 = vqrshrn_n_u16(v71, 8uLL);
      *(int8x8_t *)v60.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v63.i8), v62, vbsl_s8(vceqz_s8(*(int8x8_t *)v64.i8), *(int8x8_t *)v60.i8, (int8x8_t)vmin_u8(v72, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v72, v71, 8uLL), (int8x8_t)0x404040400000000))));
      a13 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v60, a9));
      *unint64_t v17 = a13.i32[0];
      uint64_t v73 = &v15[a5];
      if ((unint64_t)v73 >= v16) {
        uint64_t v74 = -(uint64_t)a4;
      }
      else {
        uint64_t v74 = 0;
      }
      int8x16_t v15 = &v73[v74];
      v17 += a5;
      --v53;
    }
    while (v53);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)19,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, uint8x8_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  int8x16_t v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    a13.i32[1] = 67372036;
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      int8x16_t v26 = vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      int8x16_t v28 = (int8x16_t)vminq_u8((uint8x16_t)v24, (uint8x16_t)v26);
      uint8x16_t v29 = vminq_u8((uint8x16_t)v25, (uint8x16_t)v27);
      int8x16_t v30 = (int8x16_t)vqsubq_u8((uint8x16_t)v27, v29);
      float32x4_t v31 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      float32x4_t v32 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      int8x8_t v33 = (int8x8_t)vextq_s8(v30, v30, 8uLL).u64[0];
      float32x4_t v34 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v33, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      float32x4_t v35 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v33, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      uint16x8_t v36 = vmull_u8(*(uint8x8_t *)v26.i8, *(uint8x8_t *)v26.i8);
      uint16x8_t v37 = vmull_high_u8((uint8x16_t)v26, (uint8x16_t)v26);
      int8x8_t v38 = (int8x8_t)vextq_s8(v28, v28, 8uLL).u64[0];
      uint64_t v39 = *(void *)&vzip2_s8(*(int8x8_t *)v28.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      uint64_t v40 = *(void *)&vzip1_s8(*(int8x8_t *)v28.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      uint16x8_t v41 = vmull_u8(*(uint8x8_t *)v26.i8, *(uint8x8_t *)v27.i8);
      uint16x8_t v42 = vmull_high_u8((uint8x16_t)v26, (uint8x16_t)v27);
      uint8x16_t v43 = (uint8x16_t)vmvnq_s8(v26);
      uint16x8_t v44 = vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v43.i8);
      uint16x8_t v45 = vmull_high_u8(v29, v43);
      uint8x16_t v46 = (uint8x16_t)vmvnq_s8(v27);
      uint16x8_t v47 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v46.i8);
      uint16x8_t v48 = vmull_high_u8((uint8x16_t)v28, v46);
      v76.val[1] = (int8x16_t)vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v44)), vcvtq_f32_u32(vmovl_high_u16(v47))), vcvtq_f32_u32(vmovl_high_u16(v41))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v32, vcvtq_f32_u32(vmovl_high_u16(v36))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v39))), (int8x16_t)vceqzq_f32(v32))), v23));
      v76.val[0] = (int8x16_t)vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v44.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v47.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v41.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v31, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v36.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v40))), (int8x16_t)vceqzq_f32(v31))), v23))), (int32x4_t)v76.val[1]);
      *(int8x8_t *)v76.val[0].i8 = vqmovun_s16((int16x8_t)v76.val[0]);
      int16x8_t v49 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v45.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v48.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v42.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v34, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v37.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v38, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))), (int8x16_t)vceqzq_f32(v34))), v23))), vcvtnq_s32_f32(vmulq_f32(
                  vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v45)), vcvtq_f32_u32(vmovl_high_u16(v48))), vcvtq_f32_u32(vmovl_high_u16(v42))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v35, vcvtq_f32_u32(vmovl_high_u16(v37))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v38, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))), (int8x16_t)vceqzq_f32(v35))), v23)));
      *(int8x8_t *)v76.val[1].i8 = vqmovun_s16(v49);
      *(int8x16_t *)&v17[v18] = vbslq_s8(vceqzq_s8(v26), v25, vbslq_s8(vceqzq_s8(v27), v24, (int8x16_t)vminq_u8((uint8x16_t)vqmovun_high_s16(*(int8x8_t *)v76.val[0].i8, v49), (uint8x16_t)vqtbl2q_s8(v76, (int8x16_t)xmmword_1850CE040))));
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    int8x16_t v15 = (_DWORD *)((char *)v15 + v18 * 4);
  }
  uint64_t v50 = v14 + a8;
  if (v50)
  {
    if (a6) {
      unsigned int v51 = 0;
    }
    else {
      unsigned int v51 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v51), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v52 = 0;
    }
    else {
      unsigned int v52 = -1;
    }
    int8x8_t v53 = vand_s8(vdup_n_s8(v52), (int8x8_t)0xFF000000FFLL);
    float32x4_t v54 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v55 = vmovl_u8(a13);
      LOBYTE(v56) = v55.i8[0];
      BYTE1(v56) = v55.i8[2];
      BYTE2(v56) = v55.i8[4];
      HIBYTE(v56) = v55.i8[6];
      v55.i32[0] = *v17;
      int8x16_t v57 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v55.i8);
      LOBYTE(v58) = v57.i8[0];
      BYTE1(v58) = v57.i8[2];
      BYTE2(v58) = v57.i8[4];
      HIBYTE(v58) = v57.i8[6];
      int8x8_t v59 = vorr_s8((int8x8_t)v56, *(int8x8_t *)a9.i8);
      *(int8x8_t *)v57.i8 = vorr_s8((int8x8_t)v58, v53);
      *(int8x8_t *)v60.i8 = v59;
      v60.u64[1] = (unint64_t)v59;
      *(int8x8_t *)v60.i8 = vqtbl1_s8(v60, (int8x8_t)0x404040400000000);
      v61.i64[0] = v57.i64[0];
      v61.i64[1] = v57.i64[0];
      *(int8x8_t *)v61.i8 = vqtbl1_s8(v61, (int8x8_t)0x404040400000000);
      int8x8_t v62 = (int8x8_t)vmin_u8((uint8x8_t)v59, *(uint8x8_t *)v60.i8);
      uint8x8_t v63 = vmin_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v61.i8);
      int8x8_t v64 = (int8x8_t)vqsub_u8(*(uint8x8_t *)v61.i8, v63);
      float32x4_t v65 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v64, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      float32x4_t v66 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v64, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)));
      uint16x8_t v67 = vmull_u8(*(uint8x8_t *)v60.i8, *(uint8x8_t *)v60.i8);
      uint64_t v68 = *(void *)&vzip2_s8(v62, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      uint64_t v69 = *(void *)&vzip1_s8(v62, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      uint16x8_t v70 = vmull_u8(*(uint8x8_t *)v60.i8, *(uint8x8_t *)v61.i8);
      uint16x8_t v71 = vmull_u8(v63, (uint8x8_t)vmvn_s8(*(int8x8_t *)v60.i8));
      uint16x8_t v72 = vmull_u8((uint8x8_t)v62, (uint8x8_t)vmvn_s8(*(int8x8_t *)v61.i8));
      int16x8_t v73 = vqmovn_high_s32(vqmovn_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v71.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v72.i8))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v70.i8))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v65, vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v67.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v69))), (int8x16_t)vceqzq_f32(v65))), v54))), vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(
                      vaddq_f32(vcvtq_f32_u32(vmovl_high_u16(v71)), vcvtq_f32_u32(vmovl_high_u16(v72))),
                      vcvtq_f32_u32(vmovl_high_u16(v70))),
                    (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v66, vcvtq_f32_u32(vmovl_high_u16(v67))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v68))), (int8x16_t)vceqzq_f32(v66))), v54)));
      *(int8x8_t *)v71.i8 = vqmovun_s16(v73);
      *(int8x8_t *)v57.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v60.i8), *(int8x8_t *)v57.i8, vbsl_s8(vceqz_s8(*(int8x8_t *)v61.i8), v59, (int8x8_t)vmin_u8(*(uint8x8_t *)v71.i8, (uint8x8_t)vqtbl1_s8(vqmovun_high_s16(*(int8x8_t *)v71.i8, v73), (int8x8_t)0x404040400000000))));
      a13 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v57, a9));
      *unint64_t v17 = a13.i32[0];
      uint64_t v74 = &v15[a5];
      if ((unint64_t)v74 >= v16) {
        uint64_t v75 = -(uint64_t)a4;
      }
      else {
        uint64_t v75 = 0;
      }
      int8x16_t v15 = &v74[v75];
      v17 += a5;
      --v50;
    }
    while (v50);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)18,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, uint8x8_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  int8x16_t v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    a13.i32[1] = 67372036;
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      int8x16_t v26 = vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v28 = vminq_u8((uint8x16_t)v24, (uint8x16_t)v26);
      int8x16_t v29 = (int8x16_t)vminq_u8((uint8x16_t)v25, (uint8x16_t)v27);
      uint8x16_t v30 = (uint8x16_t)vmvnq_s8(v27);
      uint16x8_t v31 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v30.i8);
      v71.val[1] = (int8x16_t)vmull_high_u8(v28, v30);
      unsigned long long v32 = *(_OWORD *)&v28 & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00);
      int8x16_t v33 = vbicq_s8(vtstq_s8(v29, v29), (int8x16_t)vcgtq_u8((uint8x16_t)v26, (uint8x16_t)v32));
      int8x16_t v34 = vorrq_s8((int8x16_t)vqsubq_u8((uint8x16_t)v26, (uint8x16_t)v32), vceqzq_s8(v29));
      uint64_t v35 = *(void *)&vzip1_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      uint64_t v36 = *(void *)&vzip2_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL;
      v34.i64[0] = vextq_s8(v34, v34, 8uLL).u64[0];
      uint16x8_t v37 = vmull_u8(*(uint8x8_t *)v26.i8, *(uint8x8_t *)v26.i8);
      uint16x8_t v38 = vmull_high_u8((uint8x16_t)v26, (uint8x16_t)v26);
      int8x8_t v39 = (int8x8_t)vextq_s8(v29, v29, 8uLL).u64[0];
      int8x16_t v40 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v37.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v35))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v37))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v36)))));
      int8x16_t v41 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v39, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v38.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v39, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v38))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))))));
      uint8x16_t v42 = (uint8x16_t)vmvnq_s8(v26);
      uint16x8_t v43 = vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v42.i8);
      uint16x8_t v44 = vmull_high_u8((uint8x16_t)v29, v42);
      uint16x8_t v45 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8(v40, (int8x16_t)vmovl_s8(*(int8x8_t *)v33.i8)), v43), v31), v23);
      uint16x8_t v46 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8(v41, (int8x16_t)vmovl_high_s8(v33)), v44), (uint16x8_t)v71.val[1]), v23);
      v71.val[0] = (int8x16_t)vrsraq_n_u16(v45, v45, 8uLL);
      uint16x8_t v47 = vrsraq_n_u16(v46, v46, 8uLL);
      *(uint8x8_t *)v71.val[0].i8 = vqrshrn_n_u16((uint16x8_t)v71.val[0], 8uLL);
      *(uint8x8_t *)v71.val[1].i8 = vqrshrn_n_u16(v47, 8uLL);
      *(int8x16_t *)&v17[v18] = vbslq_s8(vceqzq_s8(v26), v25, vbslq_s8(vceqzq_s8(v27), v24, (int8x16_t)vminq_u8(vqrshrn_high_n_u16(*(uint8x8_t *)v71.val[0].i8, v47, 8uLL), (uint8x16_t)vqtbl2q_s8(v71, (int8x16_t)xmmword_1850CE040))));
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    int8x16_t v15 = (_DWORD *)((char *)v15 + v18 * 4);
  }
  uint64_t v48 = v14 + a8;
  if (v48)
  {
    if (a6) {
      unsigned int v49 = 0;
    }
    else {
      unsigned int v49 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v49), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v50 = 0;
    }
    else {
      unsigned int v50 = -1;
    }
    int8x8_t v51 = vand_s8(vdup_n_s8(v50), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v52 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v53 = vmovl_u8(a13);
      LOBYTE(v54) = v53.i8[0];
      BYTE1(v54) = v53.i8[2];
      BYTE2(v54) = v53.i8[4];
      HIBYTE(v54) = v53.i8[6];
      v53.i32[0] = *v17;
      int8x16_t v55 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v53.i8);
      LOBYTE(v56) = v55.i8[0];
      BYTE1(v56) = v55.i8[2];
      BYTE2(v56) = v55.i8[4];
      HIBYTE(v56) = v55.i8[6];
      *(int8x8_t *)v55.i8 = vorr_s8((int8x8_t)v54, *(int8x8_t *)a9.i8);
      int8x8_t v57 = vorr_s8((int8x8_t)v56, v51);
      v58.i64[0] = v55.i64[0];
      v58.i64[1] = v55.i64[0];
      *(int8x8_t *)v58.i8 = vqtbl1_s8(v58, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v59.i8 = v57;
      v59.u64[1] = (unint64_t)v57;
      *(int8x8_t *)v59.i8 = vqtbl1_s8(v59, (int8x8_t)0x404040400000000);
      uint8x8_t v60 = vmin_u8(*(uint8x8_t *)v55.i8, *(uint8x8_t *)v58.i8);
      int8x8_t v61 = (int8x8_t)vmin_u8((uint8x8_t)v57, *(uint8x8_t *)v59.i8);
      uint16x8_t v62 = vmull_u8(v60, (uint8x8_t)vmvn_s8(*(int8x8_t *)v59.i8));
      *(void *)&v60 &= 0xFFFFFF00FFFFFF00;
      int8x16_t v63 = (int8x16_t)vmovl_s8(vbic_s8(vtst_s8(v61, v61), (int8x8_t)vcgt_u8(*(uint8x8_t *)v58.i8, v60)));
      int8x8_t v64 = vorr_s8((int8x8_t)vqsub_u8(*(uint8x8_t *)v58.i8, v60), vceqz_s8(v61));
      uint16x8_t v65 = vmull_u8(*(uint8x8_t *)v58.i8, *(uint8x8_t *)v58.i8);
      uint16x8_t v66 = vminq_u16(vqaddq_u16(vqaddq_u16((uint16x8_t)vorrq_s8((int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v61, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v65.i8))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip1_s8(v64, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))), vcvtnq_s32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v61, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL))), vcvtq_f32_u32(vmovl_high_u16(v65))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vzip2_s8(v64, *(int8x8_t *)a9.i8) & 0xFF00FF00FF00FFLL)))))),
                                v63),
                  vmull_u8((uint8x8_t)v61, (uint8x8_t)vmvn_s8(*(int8x8_t *)v58.i8))),
                v62),
              v52);
      uint16x8_t v67 = vrsraq_n_u16(v66, v66, 8uLL);
      uint8x8_t v68 = vqrshrn_n_u16(v67, 8uLL);
      *(int8x8_t *)v55.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v58.i8), v57, vbsl_s8(vceqz_s8(*(int8x8_t *)v59.i8), *(int8x8_t *)v55.i8, (int8x8_t)vmin_u8(v68, (uint8x8_t)vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16(v68, v67, 8uLL), (int8x8_t)0x404040400000000))));
      a13 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v55, a9));
      *unint64_t v17 = a13.i32[0];
      uint64_t v69 = &v15[a5];
      if ((unint64_t)v69 >= v16) {
        uint64_t v70 = -(uint64_t)a4;
      }
      else {
        uint64_t v70 = 0;
      }
      int8x16_t v15 = &v69[v70];
      v17 += a5;
      --v48;
    }
    while (v48);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)17,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, int8x16_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  int8x16_t v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      int8x16_t v26 = vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v28 = vminq_u8((uint8x16_t)v24, (uint8x16_t)v26);
      uint8x16_t v29 = vminq_u8((uint8x16_t)v25, (uint8x16_t)v27);
      uint16x8_t v30 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v27.i8);
      uint8x16_t v31 = (uint8x16_t)vmvnq_s8(v27);
      uint16x8_t v32 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v31.i8);
      uint8x16_t v33 = (uint8x16_t)vmvnq_s8(v26);
      uint16x8_t v34 = vqaddq_u16(vqaddq_u16(vmaxq_u16(vmull_high_u8(v28, (uint8x16_t)v27), vmull_high_u8(v29, (uint8x16_t)v26)), vmull_high_u8(v28, v31)), vmull_high_u8(v29, v33));
      uint16x8_t v35 = vminq_u16(vqaddq_u16(vqaddq_u16(vmaxq_u16(v30, vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v26.i8)), v32), vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v33.i8)), v23);
      uint16x8_t v36 = vminq_u16(v34, v23);
      a13 = vbslq_s8(vceqzq_s8(v26), v25, vbslq_s8(vceqzq_s8(v27), v24, (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v35, v35, 8uLL), 8uLL), vrsraq_n_u16(v36, v36, 8uLL), 8uLL)));
      *(int8x16_t *)&v17[v18] = a13;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    int8x16_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v37 = v14 + a8;
  if (v37)
  {
    if (a6) {
      unsigned int v38 = 0;
    }
    else {
      unsigned int v38 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v38), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v39 = 0;
    }
    else {
      unsigned int v39 = -1;
    }
    int8x8_t v40 = vand_s8(vdup_n_s8(v39), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v41 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v42 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v43) = v42.i8[0];
      BYTE1(v43) = v42.i8[2];
      BYTE2(v43) = v42.i8[4];
      HIBYTE(v43) = v42.i8[6];
      v42.i32[0] = *v17;
      a13 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v42.i8);
      LOBYTE(v44) = a13.i8[0];
      BYTE1(v44) = a13.i8[2];
      BYTE2(v44) = a13.i8[4];
      HIBYTE(v44) = a13.i8[6];
      *(int8x8_t *)a13.i8 = vorr_s8((int8x8_t)v43, *(int8x8_t *)a9.i8);
      int8x8_t v45 = vorr_s8((int8x8_t)v44, v40);
      v46.i64[0] = a13.i64[0];
      v46.i64[1] = a13.i64[0];
      *(int8x8_t *)v46.i8 = vqtbl1_s8(v46, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v47.i8 = v45;
      v47.u64[1] = (unint64_t)v45;
      *(int8x8_t *)v47.i8 = vqtbl1_s8(v47, (int8x8_t)0x404040400000000);
      uint8x8_t v48 = vmin_u8(*(uint8x8_t *)a13.i8, *(uint8x8_t *)v46.i8);
      uint8x8_t v49 = vmin_u8((uint8x8_t)v45, *(uint8x8_t *)v47.i8);
      uint16x8_t v50 = vminq_u16(vqaddq_u16(vqaddq_u16(vmaxq_u16(vmull_u8(v48, *(uint8x8_t *)v47.i8), vmull_u8(v49, *(uint8x8_t *)v46.i8)), vmull_u8(v48, (uint8x8_t)vmvn_s8(*(int8x8_t *)v47.i8))), vmull_u8(v49, (uint8x8_t)vmvn_s8(*(int8x8_t *)v46.i8))), v41);
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v46.i8), v45, vbsl_s8(vceqz_s8(*(int8x8_t *)v47.i8), *(int8x8_t *)a13.i8, (int8x8_t)vqrshrn_n_u16(vrsraq_n_u16(v50, v50, 8uLL), 8uLL)));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a13, a9));
      *unint64_t v17 = a13.i32[0];
      int8x8_t v51 = &v15[a5];
      if ((unint64_t)v51 >= v16) {
        uint64_t v52 = -(uint64_t)a4;
      }
      else {
        uint64_t v52 = 0;
      }
      int8x16_t v15 = &v51[v52];
      v17 += a5;
      --v37;
    }
    while (v37);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)16,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, int8x16_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  int8x16_t v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      int8x16_t v26 = vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v28 = vminq_u8((uint8x16_t)v24, (uint8x16_t)v26);
      uint8x16_t v29 = vminq_u8((uint8x16_t)v25, (uint8x16_t)v27);
      uint16x8_t v30 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v27.i8);
      uint8x16_t v31 = (uint8x16_t)vmvnq_s8(v27);
      uint16x8_t v32 = vmull_u8(*(uint8x8_t *)v28.i8, *(uint8x8_t *)v31.i8);
      uint8x16_t v33 = (uint8x16_t)vmvnq_s8(v26);
      uint16x8_t v34 = vqaddq_u16(vqaddq_u16(vminq_u16(vmull_high_u8(v29, (uint8x16_t)v26), vmull_high_u8(v28, (uint8x16_t)v27)), vmull_high_u8(v28, v31)), vmull_high_u8(v29, v33));
      uint16x8_t v35 = vminq_u16(vqaddq_u16(vqaddq_u16(vminq_u16(vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v26.i8), v30), v32), vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v33.i8)), v23);
      uint16x8_t v36 = vminq_u16(v34, v23);
      a13 = vbslq_s8(vceqzq_s8(v26), v25, vbslq_s8(vceqzq_s8(v27), v24, (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v35, v35, 8uLL), 8uLL), vrsraq_n_u16(v36, v36, 8uLL), 8uLL)));
      *(int8x16_t *)&v17[v18] = a13;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    int8x16_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v37 = v14 + a8;
  if (v37)
  {
    if (a6) {
      unsigned int v38 = 0;
    }
    else {
      unsigned int v38 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v38), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v39 = 0;
    }
    else {
      unsigned int v39 = -1;
    }
    int8x8_t v40 = vand_s8(vdup_n_s8(v39), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v41 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v42 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v43) = v42.i8[0];
      BYTE1(v43) = v42.i8[2];
      BYTE2(v43) = v42.i8[4];
      HIBYTE(v43) = v42.i8[6];
      v42.i32[0] = *v17;
      a13 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v42.i8);
      LOBYTE(v44) = a13.i8[0];
      BYTE1(v44) = a13.i8[2];
      BYTE2(v44) = a13.i8[4];
      HIBYTE(v44) = a13.i8[6];
      *(int8x8_t *)a13.i8 = vorr_s8((int8x8_t)v43, *(int8x8_t *)a9.i8);
      int8x8_t v45 = vorr_s8((int8x8_t)v44, v40);
      v46.i64[0] = a13.i64[0];
      v46.i64[1] = a13.i64[0];
      *(int8x8_t *)v46.i8 = vqtbl1_s8(v46, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v47.i8 = v45;
      v47.u64[1] = (unint64_t)v45;
      *(int8x8_t *)v47.i8 = vqtbl1_s8(v47, (int8x8_t)0x404040400000000);
      uint8x8_t v48 = vmin_u8(*(uint8x8_t *)a13.i8, *(uint8x8_t *)v46.i8);
      uint8x8_t v49 = vmin_u8((uint8x8_t)v45, *(uint8x8_t *)v47.i8);
      uint16x8_t v50 = vminq_u16(vqaddq_u16(vqaddq_u16(vminq_u16(vmull_u8(v48, *(uint8x8_t *)v47.i8), vmull_u8(v49, *(uint8x8_t *)v46.i8)), vmull_u8(v48, (uint8x8_t)vmvn_s8(*(int8x8_t *)v47.i8))), vmull_u8(v49, (uint8x8_t)vmvn_s8(*(int8x8_t *)v46.i8))), v41);
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v46.i8), v45, vbsl_s8(vceqz_s8(*(int8x8_t *)v47.i8), *(int8x8_t *)a13.i8, (int8x8_t)vqrshrn_n_u16(vrsraq_n_u16(v50, v50, 8uLL), 8uLL)));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a13, a9));
      *unint64_t v17 = a13.i32[0];
      int8x8_t v51 = &v15[a5];
      if ((unint64_t)v51 >= v16) {
        uint64_t v52 = -(uint64_t)a4;
      }
      else {
        uint64_t v52 = 0;
      }
      int8x16_t v15 = &v51[v52];
      v17 += a5;
      --v37;
    }
    while (v37);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)15,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, double a13, int8x16_t a14, unint64_t a15)
{
  unint64_t v15 = a15;
  unint64_t v16 = *result;
  unint64_t v17 = *a3;
  uint64_t v18 = *a2;
  if (a15 >= 4)
  {
    uint64_t v19 = 0;
    if (a6) {
      unsigned int v20 = 0;
    }
    else {
      unsigned int v20 = -1;
    }
    v21.i64[0] = 0xFF000000FFLL;
    v21.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v20), v21);
    if (a7) {
      unsigned int v22 = 0;
    }
    else {
      unsigned int v22 = -1;
    }
    int8x16_t v23 = vandq_s8(vdupq_n_s8(v22), v21);
    uint16x8_t v24 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v16[v19], a9);
      int8x16_t v26 = vorrq_s8(*(int8x16_t *)&v18[v19], v23);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      int8x16_t v28 = vqtbl1q_s8(v26, (int8x16_t)xmmword_1850CE030);
      int8x16_t v29 = (int8x16_t)vminq_u8((uint8x16_t)v25, (uint8x16_t)v27);
      int8x16_t v30 = (int8x16_t)vminq_u8((uint8x16_t)v26, (uint8x16_t)v28);
      uint8x16_t v31 = (uint8x16_t)vsubq_s8(v27, v29);
      uint8x16_t v32 = (uint8x16_t)vsubq_s8(v28, v30);
      int8x16_t v33 = (int8x16_t)vcgtq_u8(vrhaddq_u8((uint8x16_t)v28, (uint8x16_t)0), (uint8x16_t)v30);
      int8x16_t v34 = (int8x16_t)vqaddq_u16(vmull_u8(*(uint8x8_t *)v31.i8, *(uint8x8_t *)v30.i8), vmull_u8(*(uint8x8_t *)v32.i8, *(uint8x8_t *)v29.i8));
      int8x16_t v35 = (int8x16_t)vqaddq_u16(vmull_high_u8(v31, (uint8x16_t)v30), vmull_high_u8(v32, (uint8x16_t)v29));
      uint16x8_t v36 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_s8(*(int8x8_t *)v33.i8), v34, (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v27.i8, *(uint8x8_t *)v28.i8), (uint16x8_t)v34)), v24);
      uint16x8_t v37 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_high_s8(v33), v35, (int8x16_t)vqsubq_u16(vmull_high_u8((uint8x16_t)v27, (uint8x16_t)v28), (uint16x8_t)v35)), v24);
      a14 = vbslq_s8(vceqzq_s8(v27), v26, vbslq_s8(vceqzq_s8(v28), v25, vsubq_s8(vaddq_s8(v30, v29), (int8x16_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v36, v36, 8uLL), 8uLL), vrsraq_n_u16(v37, v37, 8uLL), 8uLL))));
      *(int8x16_t *)&v18[v19] = a14;
      v15 -= 4;
      v19 += 4 * a5;
    }
    while (v15 > 3);
    uint64_t v18 = (_DWORD *)((char *)v18 + v19 * 4);
    unint64_t v16 = (unsigned __int32 *)((char *)v16 + v19 * 4);
  }
  uint64_t v38 = v15 + a8;
  if (v38)
  {
    if (a6) {
      unsigned int v39 = 0;
    }
    else {
      unsigned int v39 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v39), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v40 = 0;
    }
    else {
      unsigned int v40 = -1;
    }
    int8x8_t v41 = vand_s8(vdup_n_s8(v40), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v42 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a14.i32[0] = *v16;
      uint16x8_t v43 = vmovl_u8(*(uint8x8_t *)a14.i8);
      LOBYTE(v44) = v43.i8[0];
      BYTE1(v44) = v43.i8[2];
      BYTE2(v44) = v43.i8[4];
      HIBYTE(v44) = v43.i8[6];
      v43.i32[0] = *v18;
      a14 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v43.i8);
      LOBYTE(v45) = a14.i8[0];
      BYTE1(v45) = a14.i8[2];
      BYTE2(v45) = a14.i8[4];
      HIBYTE(v45) = a14.i8[6];
      *(int8x8_t *)a14.i8 = vorr_s8((int8x8_t)v44, *(int8x8_t *)a9.i8);
      int8x8_t v46 = vorr_s8((int8x8_t)v45, v41);
      v47.i64[0] = a14.i64[0];
      v47.i64[1] = a14.i64[0];
      *(int8x8_t *)v47.i8 = vqtbl1_s8(v47, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v48.i8 = v46;
      v48.u64[1] = (unint64_t)v46;
      *(int8x8_t *)v48.i8 = vqtbl1_s8(v48, (int8x8_t)0x404040400000000);
      int8x8_t v49 = (int8x8_t)vmin_u8(*(uint8x8_t *)a14.i8, *(uint8x8_t *)v47.i8);
      int8x8_t v50 = (int8x8_t)vmin_u8((uint8x8_t)v46, *(uint8x8_t *)v48.i8);
      int8x16_t v51 = (int8x16_t)vqaddq_u16(vmull_u8((uint8x8_t)vsub_s8(*(int8x8_t *)v47.i8, v49), (uint8x8_t)v50), vmull_u8((uint8x8_t)vsub_s8(*(int8x8_t *)v48.i8, v50), (uint8x8_t)v49));
      uint16x8_t v52 = vminq_u16((uint16x8_t)vbslq_s8((int8x16_t)vmovl_s8((int8x8_t)vcgt_u8(vrhadd_u8(*(uint8x8_t *)v48.i8, 0), (uint8x8_t)v50)), v51, (int8x16_t)vqsubq_u16(vmull_u8(*(uint8x8_t *)v47.i8, *(uint8x8_t *)v48.i8), (uint16x8_t)v51)), v42);
      *(int8x8_t *)a14.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v47.i8), v46, vbsl_s8(vceqz_s8(*(int8x8_t *)v48.i8), *(int8x8_t *)a14.i8, vsub_s8(vadd_s8(v50, v49), (int8x8_t)vqrshrn_n_u16(vrsraq_n_u16(v52, v52, 8uLL), 8uLL))));
      *(int8x8_t *)a14.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a14, a9));
      _DWORD *v18 = a14.i32[0];
      uint16x8_t v53 = &v16[a5];
      if ((unint64_t)v53 >= v17) {
        uint64_t v54 = -(uint64_t)a4;
      }
      else {
        uint64_t v54 = 0;
      }
      unint64_t v16 = &v53[v54];
      v18 += a5;
      --v38;
    }
    while (v38);
  }
  *result = v16;
  *a3 = v17;
  *a2 = v18;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)14,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, int8x16_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  unint64_t v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      uint8x16_t v26 = (uint8x16_t)vbicq_s8(v25, vceqzq_s8(vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030)));
      uint16x8_t v27 = vminq_u16(vmull_u8(*(uint8x8_t *)v24.i8, *(uint8x8_t *)v26.i8), v23);
      uint16x8_t v28 = vminq_u16(vmull_high_u8((uint8x16_t)v24, v26), v23);
      a13 = vbslq_s8(vceqzq_s8(vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030)), v25, (int8x16_t)vqaddq_u8(vqsubq_u8((uint8x16_t)v24, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v27, v27, 8uLL), 8uLL), vrsraq_n_u16(v28, v28, 8uLL), 8uLL)), v26));
      *(int8x16_t *)&v17[v18] = a13;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v29 = v14 + a8;
  if (v29)
  {
    if (a6) {
      unsigned int v30 = 0;
    }
    else {
      unsigned int v30 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v30), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v31 = 0;
    }
    else {
      unsigned int v31 = -1;
    }
    int8x8_t v32 = vand_s8(vdup_n_s8(v31), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v33 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v34 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v35) = v34.i8[0];
      BYTE1(v35) = v34.i8[2];
      BYTE2(v35) = v34.i8[4];
      HIBYTE(v35) = v34.i8[6];
      v34.i32[0] = *v17;
      uint16x8_t v36 = vmovl_u8(*(uint8x8_t *)v34.i8);
      LOBYTE(v37) = v36.i8[0];
      BYTE1(v37) = v36.i8[2];
      BYTE2(v37) = v36.i8[4];
      HIBYTE(v37) = v36.i8[6];
      *(int8x8_t *)v36.i8 = vorr_s8((int8x8_t)v35, *(int8x8_t *)a9.i8);
      int8x8_t v38 = vorr_s8((int8x8_t)v37, v32);
      *(int8x8_t *)v39.i8 = v38;
      v39.u64[1] = (unint64_t)v38;
      *(int8x8_t *)v39.i8 = vbic_s8(v38, vceqz_s8(vqtbl1_s8(v39, (int8x8_t)0x404040400000000)));
      uint16x8_t v40 = vminq_u16(vmull_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v39.i8), v33);
      a13.i64[1] = v36.i64[0];
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(vqtbl1_s8(a13, (int8x8_t)0x404040400000000)), v38, (int8x8_t)vqadd_u8(vqsub_u8(*(uint8x8_t *)v36.i8, vqrshrn_n_u16(vrsraq_n_u16(v40, v40, 8uLL), 8uLL)), *(uint8x8_t *)v39.i8));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a13, a9));
      *unint64_t v17 = a13.i32[0];
      int8x8_t v41 = &v15[a5];
      if ((unint64_t)v41 >= v16) {
        uint64_t v42 = -(uint64_t)a4;
      }
      else {
        uint64_t v42 = 0;
      }
      unint64_t v15 = &v41[v42];
      v17 += a5;
      --v29;
    }
    while (v29);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)13,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, double a12, int8x16_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  unint64_t v15 = *result;
  unint64_t v16 = *a3;
  unint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    if (a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = -1;
    }
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    a9 = vandq_s8(vdupq_n_s8(v19), v20);
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v15[v18], a9);
      int8x16_t v25 = vorrq_s8(*(int8x16_t *)&v17[v18], v22);
      int8x16_t v26 = vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      int8x16_t v27 = vqtbl1q_s8(v25, (int8x16_t)xmmword_1850CE030);
      int8x16_t v28 = vceqzq_s8(v27);
      uint8x16_t v29 = (uint8x16_t)vbicq_s8(v25, v28);
      uint16x8_t v30 = vminq_u16(vmull_u8(*(uint8x8_t *)v24.i8, *(uint8x8_t *)v29.i8), v23);
      uint16x8_t v31 = vminq_u16(vmull_high_u8((uint8x16_t)v24, v29), v23);
      uint8x16_t v32 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v30, v30, 8uLL), 8uLL), vrsraq_n_u16(v31, v31, 8uLL), 8uLL);
      uint8x16_t v33 = (uint8x16_t)vmvnq_s8(v27);
      uint8x16_t v34 = (uint8x16_t)vmvnq_s8(v26);
      uint16x8_t v35 = vmull_u8(*(uint8x8_t *)v24.i8, *(uint8x8_t *)v33.i8);
      uint16x8_t v36 = vqaddq_u16(vmull_high_u8((uint8x16_t)v24, v33), vmull_high_u8(v29, v34));
      uint16x8_t v37 = vminq_u16(vqaddq_u16(v35, vmull_u8(*(uint8x8_t *)v29.i8, *(uint8x8_t *)v34.i8)), v23);
      uint16x8_t v38 = vminq_u16(v36, v23);
      a13 = vbslq_s8(vceqzq_s8(v26), v25, vbslq_s8(v28, v24, (int8x16_t)vqaddq_u8(v32, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v37, v37, 8uLL), 8uLL), vrsraq_n_u16(v38, v38, 8uLL), 8uLL))));
      *(int8x16_t *)&v17[v18] = a13;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    unint64_t v17 = (_DWORD *)((char *)v17 + v18 * 4);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v39 = v14 + a8;
  if (v39)
  {
    if (a6) {
      unsigned int v40 = 0;
    }
    else {
      unsigned int v40 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v40), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v41 = 0;
    }
    else {
      unsigned int v41 = -1;
    }
    int8x8_t v42 = vand_s8(vdup_n_s8(v41), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v43 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a13.i32[0] = *v15;
      uint16x8_t v44 = vmovl_u8(*(uint8x8_t *)a13.i8);
      LOBYTE(v45) = v44.i8[0];
      BYTE1(v45) = v44.i8[2];
      BYTE2(v45) = v44.i8[4];
      HIBYTE(v45) = v44.i8[6];
      v44.i32[0] = *v17;
      a13 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v44.i8);
      LOBYTE(v46) = a13.i8[0];
      BYTE1(v46) = a13.i8[2];
      BYTE2(v46) = a13.i8[4];
      HIBYTE(v46) = a13.i8[6];
      *(int8x8_t *)a13.i8 = vorr_s8((int8x8_t)v45, *(int8x8_t *)a9.i8);
      int8x8_t v47 = vorr_s8((int8x8_t)v46, v42);
      v48.i64[0] = a13.i64[0];
      v48.i64[1] = a13.i64[0];
      *(int8x8_t *)v48.i8 = vqtbl1_s8(v48, (int8x8_t)0x404040400000000);
      *(int8x8_t *)v49.i8 = v47;
      v49.u64[1] = (unint64_t)v47;
      *(int8x8_t *)v49.i8 = vqtbl1_s8(v49, (int8x8_t)0x404040400000000);
      int8x8_t v50 = vceqz_s8(*(int8x8_t *)v49.i8);
      uint8x8_t v51 = (uint8x8_t)vbic_s8(v47, v50);
      uint16x8_t v52 = vminq_u16(vmull_u8(*(uint8x8_t *)a13.i8, v51), v43);
      uint16x8_t v53 = vminq_u16(vqaddq_u16(vmull_u8(*(uint8x8_t *)a13.i8, (uint8x8_t)vmvn_s8(*(int8x8_t *)v49.i8)), vmull_u8(v51, (uint8x8_t)vmvn_s8(*(int8x8_t *)v48.i8))), v43);
      *(int8x8_t *)a13.i8 = vbsl_s8(vceqz_s8(*(int8x8_t *)v48.i8), v47, vbsl_s8(v50, *(int8x8_t *)a13.i8, (int8x8_t)vqadd_u8(vqrshrn_n_u16(vrsraq_n_u16(v52, v52, 8uLL), 8uLL), vqrshrn_n_u16(vrsraq_n_u16(v53, v53, 8uLL), 8uLL))));
      *(int8x8_t *)a13.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a13, a9));
      *unint64_t v17 = a13.i32[0];
      uint64_t v54 = &v15[a5];
      if ((unint64_t)v54 >= v16) {
        uint64_t v55 = -(uint64_t)a4;
      }
      else {
        uint64_t v55 = 0;
      }
      unint64_t v15 = &v54[v55];
      v17 += a5;
      --v39;
    }
    while (v39);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)12,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int8x16_t a7, uint64_t a8, uint64_t a9, unint64_t a10)
{
  unint64_t v10 = a10;
  v11 = *result;
  unint64_t v12 = *a3;
  v13 = *a2;
  if (a10 >= 4)
  {
    uint64_t v14 = 0;
    if (a6) {
      unsigned int v15 = 0;
    }
    else {
      unsigned int v15 = -1;
    }
    v16.i64[0] = 0xFF000000FFLL;
    v16.i64[1] = 0xFF000000FFLL;
    a7 = vandq_s8(vdupq_n_s8(v15), v16);
    do
    {
      *(uint8x16_t *)&v13[v14] = vqaddq_u8(*(uint8x16_t *)&v13[v14], (uint8x16_t)vorrq_s8(*(int8x16_t *)&v11[v14], a7));
      v10 -= 4;
      v14 += 4 * a5;
    }
    while (v10 > 3);
    v13 = (_DWORD *)((char *)v13 + v14 * 4);
    v11 = (_DWORD *)((char *)v11 + v14 * 4);
  }
  uint64_t v17 = v10 + a9;
  if (v17)
  {
    if (a6) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = -1;
    }
    v19.i32[1] = 255;
    *(int8x8_t *)a7.i8 = vand_s8(vdup_n_s8(v18), (int8x8_t)0xFF000000FFLL);
    do
    {
      v19.i32[0] = *v11;
      uint16x8_t v20 = vmovl_u8(v19);
      LOBYTE(v21) = v20.i8[0];
      BYTE1(v21) = v20.i8[2];
      BYTE2(v21) = v20.i8[4];
      HIBYTE(v21) = v20.i8[6];
      v20.i32[0] = *v13;
      int8x16_t v22 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v20.i8);
      LOBYTE(v23) = v22.i8[0];
      BYTE1(v23) = v22.i8[2];
      BYTE2(v23) = v22.i8[4];
      HIBYTE(v23) = v22.i8[6];
      *(uint8x8_t *)v22.i8 = vqadd_u8((uint8x8_t)v23, (uint8x8_t)vorr_s8((int8x8_t)v21, *(int8x8_t *)a7.i8));
      uint8x8_t v19 = (uint8x8_t)vmovn_s16((int16x8_t)vzip1q_s8(v22, a7));
      _DWORD *v13 = v19.i32[0];
      int8x16_t v24 = &v11[a5];
      if ((unint64_t)v24 >= v12) {
        uint64_t v25 = -(uint64_t)a4;
      }
      else {
        uint64_t v25 = 0;
      }
      v11 = &v24[v25];
      v13 += a5;
      --v17;
    }
    while (v17);
  }
  *result = v11;
  *a3 = v12;
  *a2 = v13;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)11,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, int8x16_t a9, double a10, double a11, int8x16_t a12, unint64_t a13)
{
  unint64_t v13 = a13;
  uint64_t v14 = *result;
  unint64_t v15 = *a3;
  int8x16_t v16 = *a2;
  if (a13 >= 4)
  {
    uint64_t v17 = 0;
    if (a6) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = -1;
    }
    int8x16_t v19 = vdupq_n_s8(v18);
    v20.i64[0] = 0xFF000000FFLL;
    v20.i64[1] = 0xFF000000FFLL;
    if (a7) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = -1;
    }
    a9 = vandq_s8(v19, v20);
    int8x16_t v22 = vandq_s8(vdupq_n_s8(v21), v20);
    do
    {
      int8x16_t v23 = vorrq_s8(*(int8x16_t *)&v14[v17], a9);
      int8x16_t v24 = vorrq_s8(*(int8x16_t *)&v16[v17], v22);
      uint8x16_t v25 = (uint8x16_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v26 = (uint8x16_t)vqtbl1q_s8(v24, (int8x16_t)xmmword_1850CE030);
      a12 = (int8x16_t)vqsubq_u8(vqaddq_u8(v26, v25), vqaddq_u8(vqsubq_u8(v25, (uint8x16_t)v23), vqsubq_u8(v26, (uint8x16_t)v24)));
      *(int8x16_t *)&v16[v17] = a12;
      v13 -= 4;
      v17 += 4 * a5;
    }
    while (v13 > 3);
    int8x16_t v16 = (_DWORD *)((char *)v16 + v17 * 4);
    uint64_t v14 = (unsigned __int32 *)((char *)v14 + v17 * 4);
  }
  uint64_t v27 = v13 + a8;
  if (v27)
  {
    if (a6) {
      unsigned int v28 = 0;
    }
    else {
      unsigned int v28 = -1;
    }
    *(int8x8_t *)a9.i8 = vand_s8(vdup_n_s8(v28), (int8x8_t)0xFF000000FFLL);
    if (a7) {
      unsigned int v29 = 0;
    }
    else {
      unsigned int v29 = -1;
    }
    int8x8_t v30 = vand_s8(vdup_n_s8(v29), (int8x8_t)0xFF000000FFLL);
    do
    {
      a12.i32[0] = *v14;
      uint16x8_t v31 = vmovl_u8(*(uint8x8_t *)a12.i8);
      LOBYTE(v32) = v31.i8[0];
      BYTE1(v32) = v31.i8[2];
      BYTE2(v32) = v31.i8[4];
      HIBYTE(v32) = v31.i8[6];
      v31.i32[0] = *v16;
      a12 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v31.i8);
      LOBYTE(v33) = a12.i8[0];
      BYTE1(v33) = a12.i8[2];
      BYTE2(v33) = a12.i8[4];
      HIBYTE(v33) = a12.i8[6];
      *(int8x8_t *)a12.i8 = vorr_s8((int8x8_t)v32, *(int8x8_t *)a9.i8);
      uint8x8_t v34 = (uint8x8_t)vorr_s8((int8x8_t)v33, v30);
      v35.i64[0] = a12.i64[0];
      v35.i64[1] = a12.i64[0];
      *(int8x8_t *)v35.i8 = vqtbl1_s8(v35, (int8x8_t)0x404040400000000);
      *(uint8x8_t *)v36.i8 = v34;
      v36.u64[1] = (unint64_t)v34;
      *(int8x8_t *)v36.i8 = vqtbl1_s8(v36, (int8x8_t)0x404040400000000);
      *(uint8x8_t *)a12.i8 = vqsub_u8(vqadd_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v35.i8), vqadd_u8(vqsub_u8(*(uint8x8_t *)v35.i8, *(uint8x8_t *)a12.i8), vqsub_u8(*(uint8x8_t *)v36.i8, v34)));
      *(int8x8_t *)a12.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a12, a9));
      *int8x16_t v16 = a12.i32[0];
      uint16x8_t v37 = &v14[a5];
      if ((unint64_t)v37 >= v15) {
        uint64_t v38 = -(uint64_t)a4;
      }
      else {
        uint64_t v38 = 0;
      }
      uint64_t v14 = &v37[v38];
      v16 += a5;
      --v27;
    }
    while (v27);
  }
  *result = v14;
  *a3 = v15;
  *a2 = v16;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)10,_argb8_t>(unsigned __int32 **result, unsigned __int32 **a2, unint64_t *a3, int a4, int a5, int8x16_t a6, double a7, uint16x8_t a8, double a9, uint16x8_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  unint64_t v15 = *result;
  unint64_t v16 = *a3;
  uint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    a6.i64[1] = 0xC0C0C0C08080808;
    uint16x8_t v19 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v20 = *(int8x16_t *)&v15[v18];
      int8x16_t v21 = *(int8x16_t *)&v17[v18];
      uint8x16_t v22 = (uint8x16_t)vqtbl1q_s8(vmvnq_s8(v21), (int8x16_t)xmmword_1850CE030);
      uint8x16_t v23 = (uint8x16_t)vqtbl1q_s8(vmvnq_s8(v20), (int8x16_t)xmmword_1850CE030);
      uint16x8_t v24 = vmull_u8(*(uint8x8_t *)v20.i8, *(uint8x8_t *)v22.i8);
      uint16x8_t v25 = vmull_high_u8((uint8x16_t)v20, v22);
      a10 = vqaddq_u16(v24, vmull_u8(*(uint8x8_t *)v21.i8, *(uint8x8_t *)v23.i8));
      uint16x8_t v26 = vqaddq_u16(v25, vmull_high_u8((uint8x16_t)v21, v23));
      uint16x8_t v27 = vminq_u16(a10, v19);
      uint16x8_t v28 = vminq_u16(v26, v19);
      a8 = vrsraq_n_u16(v28, v28, 8uLL);
      *(uint8x16_t *)&v17[v18] = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v27, v27, 8uLL), 8uLL), a8, 8uLL);
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    uint64_t v17 = (unsigned __int32 *)((char *)v17 + v18 * 4);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v29 = v14 + a13;
  if (v29)
  {
    a6.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v30 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.i32[0] = *v15;
      int8x8_t v31 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a8.i8).u64[0];
      LOBYTE(v32) = v31.i8[0];
      BYTE1(v32) = v31.i8[2];
      BYTE2(v32) = v31.i8[4];
      HIBYTE(v32) = v31.i8[6];
      a10.i32[0] = *v17;
      int8x8_t v33 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a10.i8).u64[0];
      LOBYTE(v34) = v33.i8[0];
      BYTE1(v34) = v33.i8[2];
      BYTE2(v34) = v33.i8[4];
      HIBYTE(v34) = v33.i8[6];
      *(int8x8_t *)a10.i8 = vmvn_s8(vqtbl1_s8(vdupq_lane_s8(v33, 0), (int8x8_t)0xFFFFFFFF00000000));
      uint16x8_t v35 = vminq_u16(vqaddq_u16(vmull_u8((uint8x8_t)v32, *(uint8x8_t *)a10.i8), vmull_u8((uint8x8_t)v34, (uint8x8_t)vmvn_s8(vqtbl1_s8(vdupq_lane_s8(v31, 0), (int8x8_t)0xFFFFFFFF00000000)))), v30);
      a8 = vrsraq_n_u16(v35, v35, 8uLL);
      *(uint8x8_t *)a8.i8 = vqrshrn_n_u16(a8, 8uLL);
      *(int8x8_t *)a8.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, a6));
      *uint64_t v17 = a8.i32[0];
      int8x16_t v36 = &v15[a5];
      if ((unint64_t)v36 >= v16) {
        uint64_t v37 = -(uint64_t)a4;
      }
      else {
        uint64_t v37 = 0;
      }
      unint64_t v15 = &v36[v37];
      v17 += a5;
      --v29;
    }
    while (v29);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)9,_argb8_t>(unsigned __int32 **result, unsigned __int32 **a2, unint64_t *a3, int a4, int a5, int8x16_t a6, double a7, __n128 a8, double a9, uint16x8_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  unint64_t v15 = *result;
  unint64_t v16 = *a3;
  uint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    a6.i64[1] = 0xC0C0C0C08080808;
    uint16x8_t v19 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v20 = *(int8x16_t *)&v15[v18];
      int8x16_t v21 = *(int8x16_t *)&v17[v18];
      uint8x16_t v22 = (uint8x16_t)vqtbl1q_s8(v20, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v23 = (uint8x16_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CE030);
      uint16x8_t v24 = vminq_u16(vmull_u8(*(uint8x8_t *)v20.i8, *(uint8x8_t *)v23.i8), v19);
      uint16x8_t v25 = vminq_u16(vmull_high_u8((uint8x16_t)v20, v23), v19);
      uint8x16_t v26 = vqsubq_u8((uint8x16_t)v20, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v24, v24, 8uLL), 8uLL), vrsraq_n_u16(v25, v25, 8uLL), 8uLL));
      uint16x8_t v27 = vmull_u8(*(uint8x8_t *)v22.i8, *(uint8x8_t *)v21.i8);
      uint16x8_t v28 = vmull_high_u8(v22, (uint8x16_t)v21);
      uint16x8_t v29 = vminq_u16(v27, v19);
      uint16x8_t v30 = vminq_u16(v28, v19);
      a10 = (uint16x8_t)vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v29, v29, 8uLL), 8uLL), vrsraq_n_u16(v30, v30, 8uLL), 8uLL);
      a8 = (__n128)vqaddq_u8(v26, (uint8x16_t)a10);
      *(__n128 *)&v17[v18] = a8;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    uint64_t v17 = (unsigned __int32 *)((char *)v17 + v18 * 4);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v31 = v14 + a13;
  if (v31)
  {
    a6.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v32 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.n128_u32[0] = *v15;
      int8x8_t v33 = (int8x8_t)vmovl_u8((uint8x8_t)a8.n128_u64[0]).u64[0];
      LOBYTE(v34) = v33.i8[0];
      BYTE1(v34) = v33.i8[2];
      BYTE2(v34) = v33.i8[4];
      HIBYTE(v34) = v33.i8[6];
      a10.i32[0] = *v17;
      int8x8_t v35 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a10.i8).u64[0];
      LOBYTE(v36) = v35.i8[0];
      BYTE1(v36) = v35.i8[2];
      BYTE2(v36) = v35.i8[4];
      HIBYTE(v36) = v35.i8[6];
      a10 = vminq_u16(vmull_u8((uint8x8_t)v34, (uint8x8_t)vqtbl1_s8(vdupq_lane_s8(v35, 0), (int8x8_t)0xFFFFFFFF00000000)), v32);
      *(uint8x8_t *)a10.i8 = vqrshrn_n_u16(vrsraq_n_u16(a10, a10, 8uLL), 8uLL);
      uint16x8_t v37 = vminq_u16(vmull_u8((uint8x8_t)vqtbl1_s8(vdupq_lane_s8(v33, 0), (int8x8_t)0xFFFFFFFF00000000), (uint8x8_t)v36), v32);
      a8 = (__n128)vrsraq_n_u16(v37, v37, 8uLL);
      a8.n128_u64[0] = (unint64_t)vqadd_u8(vqsub_u8((uint8x8_t)v34, *(uint8x8_t *)a10.i8), vqrshrn_n_u16((uint16x8_t)a8, 8uLL));
      a8.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, a6));
      *uint64_t v17 = a8.n128_u32[0];
      uint64_t v38 = &v15[a5];
      if ((unint64_t)v38 >= v16) {
        uint64_t v39 = -(uint64_t)a4;
      }
      else {
        uint64_t v39 = 0;
      }
      unint64_t v15 = &v38[v39];
      v17 += a5;
      --v31;
    }
    while (v31);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)8,_argb8_t>(_DWORD **result, unsigned __int32 **a2, unint64_t *a3, int a4, int a5, int8x16_t a6, double a7, __n128 a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  unint64_t v12 = a12;
  unint64_t v13 = *result;
  unint64_t v14 = *a3;
  unint64_t v15 = *a2;
  if (a12 >= 4)
  {
    uint64_t v16 = 0;
    a6.i64[1] = 0xC0C0C0C08080808;
    uint16x8_t v17 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      uint8x16_t v18 = *(uint8x16_t *)&v15[v16];
      uint8x16_t v19 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)&v13[v16], (int8x16_t)xmmword_1850CE030);
      uint16x8_t v20 = vminq_u16(vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v19.i8), v17);
      uint16x8_t v21 = vminq_u16(vmull_high_u8(v18, v19), v17);
      a8 = (__n128)vqsubq_u8(v18, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v20, v20, 8uLL), 8uLL), vrsraq_n_u16(v21, v21, 8uLL), 8uLL));
      *(__n128 *)&v15[v16] = a8;
      v12 -= 4;
      v16 += 4 * a5;
    }
    while (v12 > 3);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v16 * 4);
    unint64_t v13 = (_DWORD *)((char *)v13 + v16 * 4);
  }
  uint64_t v22 = v12 + a11;
  if (v22)
  {
    a6.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v23 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.n128_u32[0] = *v15;
      int8x16_t v24 = (int8x16_t)vmovl_u8((uint8x8_t)a8.n128_u64[0]);
      LOBYTE(v25) = v24.i8[0];
      BYTE1(v25) = v24.i8[2];
      BYTE2(v25) = v24.i8[4];
      HIBYTE(v25) = v24.i8[6];
      v24.i32[0] = *v13;
      v24.i64[1] = v24.i64[0];
      uint16x8_t v26 = vminq_u16(vmull_u8((uint8x8_t)v25, (uint8x8_t)vqtbl1_s8(v24, (int8x8_t)0xFFFFFFFF00000000)), v23);
      a8 = (__n128)vrsraq_n_u16(v26, v26, 8uLL);
      a8.n128_u64[0] = (unint64_t)vqsub_u8((uint8x8_t)v25, vqrshrn_n_u16((uint16x8_t)a8, 8uLL));
      a8.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, a6));
      unsigned __int32 *v15 = a8.n128_u32[0];
      uint16x8_t v27 = &v13[a5];
      if ((unint64_t)v27 >= v14) {
        uint64_t v28 = -(uint64_t)a4;
      }
      else {
        uint64_t v28 = 0;
      }
      unint64_t v13 = &v27[v28];
      v15 += a5;
      --v22;
    }
    while (v22);
  }
  *result = v13;
  *a3 = v14;
  *a2 = v15;
  return result;
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)7,_argb8_t>(_DWORD **result, unsigned __int32 **a2, unint64_t *a3, int a4, int a5, int8x16_t a6, double a7, uint16x8_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  unint64_t v12 = a12;
  unint64_t v13 = *result;
  unint64_t v14 = *a3;
  unint64_t v15 = *a2;
  if (a12 >= 4)
  {
    uint64_t v16 = 0;
    a6.i64[1] = 0xC0C0C0C08080808;
    uint16x8_t v17 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      uint8x16_t v18 = *(uint8x16_t *)&v15[v16];
      uint8x16_t v19 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)&v13[v16], (int8x16_t)xmmword_1850CE030);
      uint16x8_t v20 = vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v19.i8);
      uint16x8_t v21 = vmull_high_u8(v18, v19);
      uint16x8_t v22 = vminq_u16(v20, v17);
      uint16x8_t v23 = vminq_u16(v21, v17);
      a8 = vrsraq_n_u16(v23, v23, 8uLL);
      *(uint8x16_t *)&v15[v16] = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v22, v22, 8uLL), 8uLL), a8, 8uLL);
      v12 -= 4;
      v16 += 4 * a5;
    }
    while (v12 > 3);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v16 * 4);
    unint64_t v13 = (_DWORD *)((char *)v13 + v16 * 4);
  }
  uint64_t v24 = v12 + a11;
  if (v24)
  {
    a6.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v25 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.i32[0] = *v15;
      int8x16_t v26 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a8.i8);
      LOBYTE(v27) = v26.i8[0];
      BYTE1(v27) = v26.i8[2];
      BYTE2(v27) = v26.i8[4];
      HIBYTE(v27) = v26.i8[6];
      v26.i32[0] = *v13;
      v26.i64[1] = v26.i64[0];
      uint16x8_t v28 = vminq_u16(vmull_u8((uint8x8_t)v27, (uint8x8_t)vqtbl1_s8(v26, (int8x8_t)0xFFFFFFFF00000000)), v25);
      a8 = vrsraq_n_u16(v28, v28, 8uLL);
      *(uint8x8_t *)a8.i8 = vqrshrn_n_u16(a8, 8uLL);
      *(int8x8_t *)a8.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, a6));
      unsigned __int32 *v15 = a8.i32[0];
      uint16x8_t v29 = &v13[a5];
      if ((unint64_t)v29 >= v14) {
        uint64_t v30 = -(uint64_t)a4;
      }
      else {
        uint64_t v30 = 0;
      }
      unint64_t v13 = &v29[v30];
      v15 += a5;
      --v24;
    }
    while (v24);
  }
  *result = v13;
  *a3 = v14;
  *a2 = v15;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)6,_argb8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, int a4, int a5, int a6, int8x16_t a7, double a8, double a9, __n128 a10, uint64_t a11, uint64_t a12, unint64_t a13)
{
  unint64_t v13 = a13;
  unint64_t v14 = *result;
  unint64_t v15 = *a3;
  uint64_t v16 = *a2;
  if (a13 >= 4)
  {
    uint64_t v17 = 0;
    if (a6) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = -1;
    }
    v19.i64[0] = 0xFF000000FFLL;
    v19.i64[1] = 0xFF000000FFLL;
    a7 = vandq_s8(vdupq_n_s8(v18), v19);
    uint16x8_t v20 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v21 = *(int8x16_t *)&v16[v17];
      uint8x16_t v22 = (uint8x16_t)vorrq_s8(*(int8x16_t *)&v14[v17], a7);
      int8x16_t v23 = vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v24 = (uint8x16_t)vbicq_s8(v21, vceqzq_s8(v23));
      uint8x16_t v25 = (uint8x16_t)vmvnq_s8(v23);
      uint16x8_t v26 = vmull_u8(*(uint8x8_t *)v22.i8, *(uint8x8_t *)v25.i8);
      uint16x8_t v27 = vmull_high_u8(v22, v25);
      uint16x8_t v28 = vminq_u16(v26, v20);
      uint16x8_t v29 = vminq_u16(v27, v20);
      a10 = (__n128)vqaddq_u8(v24, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v28, v28, 8uLL), 8uLL), vrsraq_n_u16(v29, v29, 8uLL), 8uLL));
      *(__n128 *)&v16[v17] = a10;
      v13 -= 4;
      v17 += 4 * a5;
    }
    while (v13 > 3);
    uint64_t v16 = (_DWORD *)((char *)v16 + v17 * 4);
    unint64_t v14 = (unsigned __int32 *)((char *)v14 + v17 * 4);
  }
  uint64_t v30 = v13 + a12;
  if (v30)
  {
    if (a6) {
      unsigned int v31 = 0;
    }
    else {
      unsigned int v31 = -1;
    }
    *(int8x8_t *)a7.i8 = vand_s8(vdup_n_s8(v31), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v32 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a10.n128_u32[0] = *v14;
      uint16x8_t v33 = vmovl_u8((uint8x8_t)a10.n128_u64[0]);
      LOBYTE(v34) = v33.i8[0];
      BYTE1(v34) = v33.i8[2];
      BYTE2(v34) = v33.i8[4];
      HIBYTE(v34) = v33.i8[6];
      v33.i32[0] = *v16;
      v33.i64[0] = vmovl_u8(*(uint8x8_t *)v33.i8).u64[0];
      LOBYTE(v35) = v33.i8[0];
      BYTE1(v35) = v33.i8[2];
      BYTE2(v35) = v33.i8[4];
      HIBYTE(v35) = v33.i8[6];
      *(int8x8_t *)v33.i8 = vqtbl1_s8(vdupq_lane_s8(*(int8x8_t *)v33.i8, 0), (int8x8_t)0xFFFFFFFF00000000);
      uint8x8_t v36 = (uint8x8_t)vbic_s8((int8x8_t)v35, vceqz_s8(*(int8x8_t *)v33.i8));
      uint16x8_t v37 = vminq_u16(vmull_u8((uint8x8_t)vorr_s8((int8x8_t)v34, *(int8x8_t *)a7.i8), (uint8x8_t)vmvn_s8(*(int8x8_t *)v33.i8)), v32);
      a10 = (__n128)vrsraq_n_u16(v37, v37, 8uLL);
      a10.n128_u64[0] = (unint64_t)vqadd_u8(v36, vqrshrn_n_u16((uint16x8_t)a10, 8uLL));
      a10.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a10, a7));
      *uint64_t v16 = a10.n128_u32[0];
      uint64_t v38 = &v14[a5];
      if ((unint64_t)v38 >= v15) {
        uint64_t v39 = -(uint64_t)a4;
      }
      else {
        uint64_t v39 = 0;
      }
      unint64_t v14 = &v38[v39];
      v16 += a5;
      --v30;
    }
    while (v30);
  }
  *result = v14;
  *a3 = v15;
  *a2 = v16;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)5,_argb8_t>(unsigned __int32 **result, unsigned __int32 **a2, unint64_t *a3, int a4, int a5, int8x16_t a6, double a7, __n128 a8, double a9, uint8x16_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  unint64_t v15 = *result;
  unint64_t v16 = *a3;
  uint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    a6.i64[1] = 0xC0C0C0C08080808;
    uint16x8_t v19 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v20 = *(int8x16_t *)&v15[v18];
      int8x16_t v21 = *(int8x16_t *)&v17[v18];
      uint8x16_t v22 = (uint8x16_t)vqtbl1q_s8(v20, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v23 = (uint8x16_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CE030);
      uint16x8_t v24 = vminq_u16(vmull_u8(*(uint8x8_t *)v21.i8, *(uint8x8_t *)v22.i8), v19);
      uint16x8_t v25 = vminq_u16(vmull_high_u8((uint8x16_t)v21, v22), v19);
      uint8x16_t v26 = vqsubq_u8((uint8x16_t)v21, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v24, v24, 8uLL), 8uLL), vrsraq_n_u16(v25, v25, 8uLL), 8uLL));
      uint16x8_t v27 = vminq_u16(vmull_u8(*(uint8x8_t *)v23.i8, *(uint8x8_t *)v20.i8), v19);
      uint16x8_t v28 = vminq_u16(vmull_high_u8(v23, (uint8x16_t)v20), v19);
      a10 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v27, v27, 8uLL), 8uLL), vrsraq_n_u16(v28, v28, 8uLL), 8uLL);
      a8 = (__n128)vqaddq_u8(v26, a10);
      *(__n128 *)&v17[v18] = a8;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    uint64_t v17 = (unsigned __int32 *)((char *)v17 + v18 * 4);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v29 = v14 + a13;
  if (v29)
  {
    a6.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v30 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.n128_u32[0] = *v15;
      int8x8_t v31 = (int8x8_t)vmovl_u8((uint8x8_t)a8.n128_u64[0]).u64[0];
      LOBYTE(v32) = v31.i8[0];
      BYTE1(v32) = v31.i8[2];
      BYTE2(v32) = v31.i8[4];
      HIBYTE(v32) = v31.i8[6];
      a10.i32[0] = *v17;
      int8x8_t v33 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a10.i8).u64[0];
      LOBYTE(v34) = v33.i8[0];
      BYTE1(v34) = v33.i8[2];
      BYTE2(v34) = v33.i8[4];
      HIBYTE(v34) = v33.i8[6];
      *(int8x8_t *)a10.i8 = vqtbl1_s8(vdupq_lane_s8(v33, 0), (int8x8_t)0xFFFFFFFF00000000);
      uint16x8_t v35 = vminq_u16(vmull_u8((uint8x8_t)v34, (uint8x8_t)vqtbl1_s8(vdupq_lane_s8(v31, 0), (int8x8_t)0xFFFFFFFF00000000)), v30);
      a8 = (__n128)vrsraq_n_u16(v35, v35, 8uLL);
      uint16x8_t v36 = vminq_u16(vmull_u8(*(uint8x8_t *)a10.i8, (uint8x8_t)v32), v30);
      a8.n128_u64[0] = (unint64_t)vqadd_u8(vqsub_u8((uint8x8_t)v34, vqrshrn_n_u16((uint16x8_t)a8, 8uLL)), vqrshrn_n_u16(vrsraq_n_u16(v36, v36, 8uLL), 8uLL));
      a8.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, a6));
      *uint64_t v17 = a8.n128_u32[0];
      uint16x8_t v37 = &v15[a5];
      if ((unint64_t)v37 >= v16) {
        uint64_t v38 = -(uint64_t)a4;
      }
      else {
        uint64_t v38 = 0;
      }
      unint64_t v15 = &v37[v38];
      v17 += a5;
      --v29;
    }
    while (v29);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)4,_argb8_t>(unsigned __int32 **result, __int32 **a2, unint64_t *a3, int a4, int a5, int a6, int8x16_t a7, double a8, double a9, int8x16_t a10, uint64_t a11, uint64_t a12, unint64_t a13)
{
  unint64_t v13 = a13;
  unint64_t v14 = *result;
  unint64_t v15 = *a3;
  unint64_t v16 = *a2;
  if (a13 >= 4)
  {
    uint64_t v17 = 0;
    if (a6) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = -1;
    }
    v19.i64[0] = 0xFF000000FFLL;
    v19.i64[1] = 0xFF000000FFLL;
    a7 = vandq_s8(vdupq_n_s8(v18), v19);
    uint16x8_t v20 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      uint8x16_t v21 = (uint8x16_t)vorrq_s8(*(int8x16_t *)&v14[v17], a7);
      uint8x16_t v22 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)&v16[v17], (int8x16_t)xmmword_1850CE030);
      uint16x8_t v23 = vminq_u16(vmull_u8(*(uint8x8_t *)v21.i8, *(uint8x8_t *)v22.i8), v20);
      uint16x8_t v24 = vminq_u16(vmull_high_u8(v21, v22), v20);
      a10 = (int8x16_t)vqsubq_u8(v21, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v23, v23, 8uLL), 8uLL), vrsraq_n_u16(v24, v24, 8uLL), 8uLL));
      *(int8x16_t *)&v16[v17] = a10;
      v13 -= 4;
      v17 += 4 * a5;
    }
    while (v13 > 3);
    unint64_t v16 = (__int32 *)((char *)v16 + v17 * 4);
    unint64_t v14 = (unsigned __int32 *)((char *)v14 + v17 * 4);
  }
  uint64_t v25 = v13 + a12;
  if (v25)
  {
    if (a6) {
      unsigned int v26 = 0;
    }
    else {
      unsigned int v26 = -1;
    }
    *(int8x8_t *)a7.i8 = vand_s8(vdup_n_s8(v26), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a10.i32[0] = *v14;
      a10 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a10.i8);
      v28.i32[1] = 0;
      LOBYTE(v29) = a10.i8[0];
      BYTE1(v29) = a10.i8[2];
      BYTE2(v29) = a10.i8[4];
      HIBYTE(v29) = a10.i8[6];
      *(int8x8_t *)a10.i8 = vorr_s8((int8x8_t)v29, *(int8x8_t *)a7.i8);
      v28.i32[0] = *v16;
      v28.i64[1] = *v16;
      uint16x8_t v30 = vminq_u16(vmull_u8(*(uint8x8_t *)a10.i8, (uint8x8_t)vqtbl1_s8(v28, (int8x8_t)0xFFFFFFFF00000000)), v27);
      *(uint8x8_t *)a10.i8 = vqsub_u8(*(uint8x8_t *)a10.i8, vqrshrn_n_u16(vrsraq_n_u16(v30, v30, 8uLL), 8uLL));
      *(int8x8_t *)a10.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a10, a7));
      *unint64_t v16 = a10.i32[0];
      int8x8_t v31 = &v14[a5];
      if ((unint64_t)v31 >= v15) {
        uint64_t v32 = -(uint64_t)a4;
      }
      else {
        uint64_t v32 = 0;
      }
      unint64_t v14 = &v31[v32];
      v16 += a5;
      --v25;
    }
    while (v25);
  }
  *result = v14;
  *a3 = v15;
  *a2 = v16;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)3,_argb8_t>(unsigned __int32 **result, __int32 **a2, unint64_t *a3, int a4, int a5, int a6, int8x16_t a7, double a8, double a9, uint16x8_t a10, uint64_t a11, uint64_t a12, unint64_t a13)
{
  unint64_t v13 = a13;
  unint64_t v14 = *result;
  unint64_t v15 = *a3;
  unint64_t v16 = *a2;
  if (a13 >= 4)
  {
    uint64_t v17 = 0;
    if (a6) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = -1;
    }
    v19.i64[0] = 0xFF000000FFLL;
    v19.i64[1] = 0xFF000000FFLL;
    a7 = vandq_s8(vdupq_n_s8(v18), v19);
    uint16x8_t v20 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      uint8x16_t v21 = (uint8x16_t)vorrq_s8(*(int8x16_t *)&v14[v17], a7);
      uint8x16_t v22 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)&v16[v17], (int8x16_t)xmmword_1850CE030);
      uint16x8_t v23 = vmull_u8(*(uint8x8_t *)v21.i8, *(uint8x8_t *)v22.i8);
      uint16x8_t v24 = vmull_high_u8(v21, v22);
      uint16x8_t v25 = vminq_u16(v23, v20);
      uint16x8_t v26 = vminq_u16(v24, v20);
      a10 = vrsraq_n_u16(v26, v26, 8uLL);
      *(uint8x16_t *)&v16[v17] = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v25, v25, 8uLL), 8uLL), a10, 8uLL);
      v13 -= 4;
      v17 += 4 * a5;
    }
    while (v13 > 3);
    unint64_t v16 = (__int32 *)((char *)v16 + v17 * 4);
    unint64_t v14 = (unsigned __int32 *)((char *)v14 + v17 * 4);
  }
  uint64_t v27 = v13 + a12;
  if (v27)
  {
    if (a6) {
      unsigned int v28 = 0;
    }
    else {
      unsigned int v28 = -1;
    }
    *(int8x8_t *)a7.i8 = vand_s8(vdup_n_s8(v28), (int8x8_t)0xFF000000FFLL);
    uint16x8_t v29 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a10.i32[0] = *v14;
      uint16x8_t v30 = vmovl_u8(*(uint8x8_t *)a10.i8);
      v31.i32[1] = 0;
      LOBYTE(v32) = v30.i8[0];
      BYTE1(v32) = v30.i8[2];
      BYTE2(v32) = v30.i8[4];
      HIBYTE(v32) = v30.i8[6];
      *(int8x8_t *)v30.i8 = vorr_s8((int8x8_t)v32, *(int8x8_t *)a7.i8);
      v31.i32[0] = *v16;
      v31.i64[1] = *v16;
      uint16x8_t v33 = vminq_u16(vmull_u8(*(uint8x8_t *)v30.i8, (uint8x8_t)vqtbl1_s8(v31, (int8x8_t)0xFFFFFFFF00000000)), v29);
      a10 = vrsraq_n_u16(v33, v33, 8uLL);
      *(uint8x8_t *)a10.i8 = vqrshrn_n_u16(a10, 8uLL);
      *(int8x8_t *)a10.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a10, a7));
      *unint64_t v16 = a10.i32[0];
      unsigned int v34 = &v14[a5];
      if ((unint64_t)v34 >= v15) {
        uint64_t v35 = -(uint64_t)a4;
      }
      else {
        uint64_t v35 = 0;
      }
      unint64_t v14 = &v34[v35];
      v16 += a5;
      --v27;
    }
    while (v27);
  }
  *result = v14;
  *a3 = v15;
  *a2 = v16;
  return result;
}

unsigned __int32 **vec::template_mark_pixelshape_row<(CGCompositeOperation)2,_argb8_t>(unsigned __int32 **result, unsigned __int32 **a2, unint64_t *a3, int a4, int a5, int8x16_t a6, double a7, __n128 a8, double a9, uint16x8_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t a14)
{
  unint64_t v14 = a14;
  unint64_t v15 = *result;
  unint64_t v16 = *a3;
  uint64_t v17 = *a2;
  if (a14 >= 4)
  {
    uint64_t v18 = 0;
    a6.i64[1] = 0xC0C0C0C08080808;
    uint16x8_t v19 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      int8x16_t v20 = *(int8x16_t *)&v15[v18];
      uint8x16_t v21 = *(uint8x16_t *)&v17[v18];
      int8x16_t v22 = vqtbl1q_s8(v20, (int8x16_t)xmmword_1850CE030);
      uint8x16_t v23 = (uint8x16_t)vbicq_s8(v20, vceqzq_s8(v22));
      uint16x8_t v24 = vminq_u16(vmull_u8(*(uint8x8_t *)v21.i8, *(uint8x8_t *)v22.i8), v19);
      uint16x8_t v25 = vminq_u16(vmull_high_u8(v21, (uint8x16_t)v22), v19);
      a10 = vrsraq_n_u16(v25, v25, 8uLL);
      a8 = (__n128)vqaddq_u8(v23, vqsubq_u8(v21, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v24, v24, 8uLL), 8uLL), a10, 8uLL)));
      *(__n128 *)&v17[v18] = a8;
      v14 -= 4;
      v18 += 4 * a5;
    }
    while (v14 > 3);
    uint64_t v17 = (unsigned __int32 *)((char *)v17 + v18 * 4);
    unint64_t v15 = (unsigned __int32 *)((char *)v15 + v18 * 4);
  }
  uint64_t v26 = v14 + a13;
  if (v26)
  {
    a6.i64[0] = 0xFFFFFFFF00000000;
    uint16x8_t v27 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.n128_u32[0] = *v15;
      int8x8_t v28 = (int8x8_t)vmovl_u8((uint8x8_t)a8.n128_u64[0]).u64[0];
      LOBYTE(v29) = v28.i8[0];
      BYTE1(v29) = v28.i8[2];
      BYTE2(v29) = v28.i8[4];
      HIBYTE(v29) = v28.i8[6];
      a10.i32[0] = *v17;
      a10 = vmovl_u8(*(uint8x8_t *)a10.i8);
      LOBYTE(v30) = a10.i8[0];
      BYTE1(v30) = a10.i8[2];
      BYTE2(v30) = a10.i8[4];
      HIBYTE(v30) = a10.i8[6];
      int8x8_t v31 = vqtbl1_s8(vdupq_lane_s8(v28, 0), (int8x8_t)0xFFFFFFFF00000000);
      *(int8x8_t *)a10.i8 = vceqz_s8(v31);
      uint16x8_t v32 = vminq_u16(vmull_u8((uint8x8_t)v30, (uint8x8_t)v31), v27);
      a8 = (__n128)vrsraq_n_u16(v32, v32, 8uLL);
      a8.n128_u64[0] = (unint64_t)vqadd_u8((uint8x8_t)vbic_s8((int8x8_t)v29, *(int8x8_t *)a10.i8), vqsub_u8((uint8x8_t)v30, vqrshrn_n_u16((uint16x8_t)a8, 8uLL)));
      a8.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, a6));
      *uint64_t v17 = a8.n128_u32[0];
      uint16x8_t v33 = &v15[a5];
      if ((unint64_t)v33 >= v16) {
        uint64_t v34 = -(uint64_t)a4;
      }
      else {
        uint64_t v34 = 0;
      }
      unint64_t v15 = &v33[v34];
      v17 += a5;
      --v26;
    }
    while (v26);
  }
  *result = v15;
  *a3 = v16;
  *a2 = v17;
  return result;
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)1,_argb8_t>(_DWORD **result, _DWORD **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 4)
  {
    uint64_t v13 = 0;
    do
    {
      *(_OWORD *)&v12[v13] = *(_OWORD *)&v10[v13];
      v9 -= 4;
      v13 += 4 * a5;
    }
    while (v9 > 3);
    unint64_t v12 = (_DWORD *)((char *)v12 + v13 * 4);
    unint64_t v10 = (_DWORD *)((char *)v10 + v13 * 4);
  }
  for (uint64_t i = v9 + a8; i; --i)
  {
    *unint64_t v12 = *v10;
    unint64_t v15 = &v10[a5];
    if ((unint64_t)v15 >= v11) {
      uint64_t v16 = -(uint64_t)a4;
    }
    else {
      uint64_t v16 = 0;
    }
    unint64_t v10 = &v15[v16];
    v12 += a5;
  }
  *result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint64_t *vec::template_mark_pixelshape_row<(CGCompositeOperation)0,_argb8_t>(uint64_t *result, _DWORD **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 4)
  {
    uint64_t v13 = 0;
    do
    {
      *(_OWORD *)&v12[v13] = 0uLL;
      v9 -= 4;
      v13 += 4 * a5;
    }
    while (v9 > 3);
    unint64_t v12 = (_DWORD *)((char *)v12 + v13 * 4);
    v10 += v13 * 4;
  }
  for (uint64_t i = v9 + a8; i; --i)
  {
    *unint64_t v12 = 0;
    unint64_t v15 = v10 + 4 * a5;
    if (v15 >= v11) {
      uint64_t v16 = -(uint64_t)a4;
    }
    else {
      uint64_t v16 = 0;
    }
    unint64_t v10 = v15 + 4 * v16;
    v12 += a5;
  }
  *result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

void rgba32_mark_pixelshape_template(uint64_t a1, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0) {
    return;
  }
  int8x8_t v50 = (uint64_t (*)(int, int, int, int, int, int, int, int, uint64_t))vec::template_mark_pixelshape_row<(CGCompositeOperation)0,_argb8_t>;
  if (a2 <= 0x17) {
    int8x8_t v50 = vec::MethodList<_argb8_t>::shapeMethods[a2];
  }
  int v2 = *(_DWORD *)(a1 + 4);
  int v3 = *(_DWORD *)(a1 + 8);
  uint64_t v4 = v2;
  int v56 = v3;
  int v57 = v2;
  unint64_t v5 = *(int *)(a1 + 28);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v9 = *(void *)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 96);
  uint64_t v54 = v9;
  unint64_t v10 = *(int **)(a1 + 136);
  int v11 = *(unsigned __int8 *)(a1 + 1) << 8;
  unint64_t v12 = v5 >> 2;
  BOOL v49 = v7 != 0;
  unint64_t v13 = v6 + 4 * (*(int *)(a1 + 12) + (v5 >> 2) * *(int *)(a1 + 16));
  unint64_t v55 = v13;
  int v14 = *(_DWORD *)(a1 + 104);
  int v15 = *(_DWORD *)(a1 + 108);
  uint64_t v16 = *(int *)(a1 + 56);
  uint64_t v17 = *(int *)(a1 + 60);
  unint64_t v18 = *(int *)(a1 + 76);
  if (v11 != 256)
  {
    unint64_t v51 = *(unsigned int *)(a1 + 64);
    unint64_t v23 = v18 >> 2;
    unint64_t v24 = (v18 >> 2) * *(int *)(a1 + 68);
    int v43 = *(_DWORD *)(a1 + 68);
    uint64_t v53 = v9;
    unint64_t v25 = v9 + 4 * v24;
    BOOL v26 = v8 != 0;
    if (v10)
    {
      uint64_t v22 = 1;
      uint64_t v20 = v9;
      goto LABEL_21;
    }
    unint64_t v46 = v13;
    if (v9)
    {
      uint16x8_t v44 = 0;
      uint64_t v45 = v9;
      uint64_t v27 = v9 + 4 * v23 * ((int)v17 % v43);
      uint64_t v20 = v27 + 4 * ((int)v16 % (int)v51);
      uint64_t v28 = v27 + 4 * (int)v51;
      uint64_t v53 = v28;
      uint64_t v54 = v20;
      uint64_t v22 = 1;
      uint64_t v9 = v20;
      goto LABEL_25;
    }
    uint64_t v28 = 0;
    uint64_t v20 = 0;
    uint64_t v22 = 1;
LABEL_24:
    unint64_t v25 = 0;
    uint16x8_t v44 = 0;
    uint64_t v45 = v20;
    uint64_t v9 = 0;
    v23 -= v4;
    goto LABEL_25;
  }
  unint64_t v19 = v18 >> 2;
  uint64_t v20 = v9 + 4 * (v16 + v19 * v17);
  uint64_t v53 = -1;
  uint64_t v54 = v20;
  unint64_t v51 = v19;
  if (v19 != v12)
  {
    uint64_t v22 = 1;
    goto LABEL_19;
  }
  if ((uint64_t)(v13 - v20) >= 1)
  {
    if (v2 >= (uint64_t)((v13 - v20) >> 2))
    {
      v13 += 4 * (v2 - 1);
      unint64_t v55 = v13;
      v20 += 4 * (v2 - 1);
      uint64_t v54 = v20;
      uint64_t v22 = 0xFFFFFFFFLL;
      goto LABEL_18;
    }
    uint64_t v21 = v12 * (v3 - 1);
    if (v13 <= v20 + 4 * v21 + 4 * (v2 - 1))
    {
      v13 += 4 * v21;
      unint64_t v55 = v13;
      unint64_t v12 = -(uint64_t)v12;
      uint64_t v54 = v20 + 4 * v21;
      uint64_t v22 = 1;
      uint64_t v20 = v54;
      goto LABEL_18;
    }
  }
  uint64_t v22 = 1;
LABEL_18:
  unint64_t v51 = v12;
LABEL_19:
  BOOL v26 = v8 != 0;
  if (!v10)
  {
    unint64_t v46 = v13;
    int v43 = 0;
    uint64_t v4 = (int)v22 * v2;
    uint64_t v28 = -1;
    unint64_t v23 = v51;
    goto LABEL_24;
  }
  unint64_t v25 = 0;
  uint64_t v9 = 0;
  int v43 = 0;
  unint64_t v23 = v51;
LABEL_21:
  shape_enum_clip_alloc(a1, a2, v10, v22, v12, 1, v14, v15, v2, v3);
  unsigned int v30 = v29;
  if (v29)
  {
    while (shape_enum_clip_next((uint64_t)v30, (int *)&v52 + 1, &v52, &v57, &v56))
    {
      uint64_t v45 = v20;
      unint64_t v46 = v13;
      uint16x8_t v44 = v30;
      if (v25)
      {
        uint64_t v40 = v13 + 4 * v12 * (int)v52 + 4 * SHIDWORD(v52);
        int v2 = v57;
        uint64_t v41 = v20 + 4 * v23 * (((int)v52 + *(_DWORD *)(a1 + 60)) % v43);
        uint64_t v20 = v41 + 4 * ((HIDWORD(v52) + *(_DWORD *)(a1 + 56)) % (int)v51);
        uint64_t v28 = v41 + 4 * (int)v51;
        uint64_t v53 = v28;
        LODWORD(v4) = v57;
        uint64_t v9 = v20;
      }
      else
      {
        int v2 = v57;
        LODWORD(v4) = v57 * v22;
        uint64_t v40 = v13 + 4 * v12 * (int)v52 + 4 * HIDWORD(v52) * (int)v22;
        v20 += 4 * (int)v52 * (int)v51 + 4 * HIDWORD(v52) * (int)v22;
        unint64_t v23 = (int)v51 - v57 * (int)v22;
        uint64_t v28 = v53;
      }
      unint64_t v55 = v40;
      uint64_t v54 = v20;
      uint64_t v4 = (int)v4;
      int v3 = v56;
LABEL_25:
      unint64_t v48 = v12;
      uint64_t v31 = v12 - v4;
      unint64_t v32 = v2 & ~(v2 >> 31);
      if ((unint64_t)(v28 - v20) >> 2 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = (unint64_t)(v28 - v20) >> 2;
      }
      unint64_t v34 = v32 - v33;
      if (v3 >= 1) {
        int v35 = 1;
      }
      else {
        int v35 = v3;
      }
      int v47 = v35;
      int v36 = v3 + 1;
      do
      {
        v50((int)&v54, (int)&v55, (int)&v53, v51, v22, v26, v49, v34, v33);
        v55 += 4 * v31;
        if (v25)
        {
          unint64_t v37 = v9 + 4 * v23;
          if (v37 >= v25) {
            uint64_t v38 = -(uint64_t)(v23 * v43);
          }
          else {
            uint64_t v38 = 0;
          }
          uint64_t v39 = v37 + 4 * v38;
          v53 += 4 * v38 + 4 * v23;
          uint64_t v9 = v39;
        }
        else
        {
          uint64_t v39 = v54 + 4 * v23;
        }
        uint64_t v54 = v39;
        --v36;
      }
      while (v36 > 1);
      int v56 = v47 - 1;
      unint64_t v12 = v48;
      uint64_t v20 = v45;
      unint64_t v13 = v46;
      unsigned int v30 = v44;
      if (!v44) {
        return;
      }
      uint64_t v52 = 0;
    }
    free(v30);
  }
}

uint64_t rgba32_mark_pixelmask_template(uint64_t result, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return result;
  }
  int v2 = a2 > 0x17
     ? vec::template_mark_pixelmask_row<(CGCompositeOperation)0,_argb8_t>
     : (uint64_t *(*)(uint64_t *, uint8x8_t **, unint64_t *, char **, int, int, double, uint16x8_t, double, double, double, uint16x8_t, uint64_t, uint64_t, uint64_t, unint64_t))vec::MethodList<_argb8_t>::maskMethods[a2];
  unint64_t v34 = v2;
  uint64_t v3 = *(void *)(result + 88);
  uint64_t v4 = *(void *)(result + 136);
  int v5 = *(_DWORD *)result;
  int64_t v6 = *(int *)(result + 4);
  uint64_t v7 = *(int *)(result + 8);
  unint64_t v8 = (unint64_t)*(int *)(result + 28) >> 2;
  unint64_t v9 = *(void *)(result + 40) + 4 * (*(int *)(result + 12) + v8 * *(int *)(result + 16));
  uint64_t v37 = v3;
  unint64_t v38 = v9;
  if (!v4) {
    return result;
  }
  uint64_t v10 = *(int *)(result + 124);
  uint64_t v11 = v4 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v10;
  uint64_t v35 = v11;
  uint64_t v12 = *(int *)(result + 56);
  uint64_t v13 = *(int *)(result + 60);
  int v14 = v5 & 0xFF00;
  unint64_t v15 = *(int *)(result + 76);
  if (v14 != 256)
  {
    unint64_t v16 = *(unsigned int *)(result + 64);
    uint64_t v20 = *(int *)(result + 68);
    unint64_t v21 = v15 >> 2;
    unint64_t v22 = v3 + 4 * (v15 >> 2) * v20;
    uint64_t v36 = v3;
    uint64_t v19 = 1;
    uint64_t v17 = v3;
    uint64_t v23 = v3;
    goto LABEL_18;
  }
  unint64_t v16 = v15 >> 2;
  uint64_t v17 = v3 + 4 * (v12 + (v15 >> 2) * v13);
  uint64_t v36 = -1;
  uint64_t v37 = v17;
  if (v16 == v8)
  {
    if ((uint64_t)(v9 - v17) >= 1)
    {
      if (v6 >= (uint64_t)((v9 - v17) >> 2))
      {
        v17 += 4 * (v6 - 1);
        uint64_t v37 = v17;
        unint64_t v38 = v9 + 4 * (v6 - 1);
        uint64_t v35 = v11 + v6 - 1;
        uint64_t v19 = 0xFFFFFFFFLL;
        goto LABEL_16;
      }
      uint64_t v18 = v8 * (v7 - 1);
      if (v9 <= v17 + 4 * v18 + 4 * ((int)v6 - 1))
      {
        uint64_t v37 = v17 + 4 * v18;
        unint64_t v38 = v9 + 4 * v18;
        unint64_t v8 = -(uint64_t)v8;
        uint64_t v35 = v11 + v10 * (v7 - 1);
        uint64_t v10 = -v10;
        uint64_t v19 = 1;
        uint64_t v17 = v37;
        goto LABEL_16;
      }
    }
    uint64_t v19 = 1;
LABEL_16:
    unint64_t v16 = v8;
    goto LABEL_17;
  }
  uint64_t v19 = 1;
LABEL_17:
  LODWORD(v20) = 0;
  uint64_t v23 = 0;
  unint64_t v22 = 0;
  unint64_t v21 = v16;
LABEL_18:
  if (v22)
  {
    uint64_t v24 = v17 + 4 * v21 * ((int)v13 % (int)v20);
    uint64_t v36 = v24 + 4 * (int)v16;
    uint64_t v37 = v24 + 4 * ((int)v12 % (int)v16);
    uint64_t v23 = v37;
  }
  else
  {
    v21 -= (int)v6 * (uint64_t)(int)v19;
  }
  uint64_t v25 = v10 - (int)v6 * (uint64_t)(int)v19;
  unint64_t v26 = v8 - (int)v6 * (uint64_t)(int)v19;
  uint64_t v33 = -(uint64_t)(v21 * (int)v20);
  int v27 = v7 + 1;
  do
  {
    unint64_t v28 = v16;
    uint64_t v29 = v19;
    result = ((uint64_t (*)(uint64_t *, unint64_t *, uint64_t *, uint64_t *))v34)(&v37, &v38, &v36, &v35);
    v35 += v25;
    v38 += 4 * v26;
    if (v22)
    {
      unint64_t v30 = v23 + 4 * v21;
      uint64_t v31 = v33;
      if (v30 < v22) {
        uint64_t v31 = 0;
      }
      uint64_t v32 = v30 + 4 * v31;
      v36 += 4 * v31 + 4 * v21;
      uint64_t v23 = v32;
    }
    else
    {
      uint64_t v32 = v37 + 4 * v21;
    }
    uint64_t v19 = v29;
    unint64_t v16 = v28;
    uint64_t v37 = v32;
    --v27;
  }
  while (v27 > 1);
  return result;
}

char *CGRegionEnumeratorCreate(char *result)
{
  if (result)
  {
    uint64_t v1 = *((void *)result + 2);
    result = (char *)malloc_type_malloc(0x38uLL, 0xEB07EEC6uLL);
    *(_DWORD *)result = 0;
    *(_OWORD *)(result + 4) = xmmword_1850CDCD0;
    *(int32x2_t *)(result + 20) = vdup_n_s32(0x7FFFFFFEu);
    *((void *)result + 5) = 0;
    *((void *)result + 6) = 0;
    *((void *)result + 4) = 0;
    if ((_UNKNOWN *)v1 != &the_empty_shape && *(_DWORD *)(v1 + 4 * *(int *)(v1 + 4)) != 0x7FFFFFFF)
    {
      *((_DWORD *)result + 1) = 1;
      *((void *)result + 4) = v1;
      *((void *)result + 5) = v1 + 8;
    }
  }
  return result;
}

void CGRegionEnumeratorCreateWithDirection(uint64_t a1, int a2, int a3)
{
  if (a1)
  {
    if (a2) {
      int v3 = -1;
    }
    else {
      int v3 = 1;
    }
    if (a3) {
      int v4 = -1;
    }
    else {
      int v4 = 1;
    }
    shape_enum_alloc(a1, *(_DWORD **)(a1 + 16), v3, v4);
  }
}

uint64_t CGRegionForwardEnumeratorMake@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 16);
    a2[2] = 0;
    if ((_UNKNOWN *)v2 == &the_empty_shape)
    {
      uint64_t v2 = 0;
      uint64_t v3 = 0;
    }
    else if (*(_DWORD *)(v2 + 4 * *(int *)(v2 + 4)) == 0x7FFFFFFF)
    {
      uint64_t v2 = 0;
      uint64_t v3 = 0;
    }
    else
    {
      uint64_t v3 = v2 + 8;
    }
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    a2[2] = 0;
  }
  *a2 = v2;
  a2[1] = v3;
  return result;
}

BOOL CGRegionEnumeratorGetNextBounds(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  return shape_enum_next(a1, a2, a3, a4, a5) != 0;
}

BOOL CGRegionEnumeratorGetNextRect(uint64_t a1, double *a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v3 = shape_enum_next(a1, (_DWORD *)&v9 + 1, &v9, (_DWORD *)&v8 + 1, &v8);
  if (v3)
  {
    double v4 = (double)(int)v9;
    double v5 = (double)(HIDWORD(v8) - HIDWORD(v9));
    double v6 = (double)((int)v8 - (int)v9);
    *a2 = (double)SHIDWORD(v9);
    a2[1] = v4;
    a2[2] = v5;
    a2[3] = v6;
  }
  return v3 != 0;
}

uint64_t CGRegionForwardEnumeratorGetNextBounds(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("CGRegionForwardEnumeratorGetNextBounds", 69, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGRegionEnumerator.c", "e != NULL", "region enumerator is missing", a6, a7, a8, v8);
  }
  return shape_forward_enum_next(a1, a2, a3, a4, a5);
}

double CGRegionForwardEnumeratorGetNextRect(uint64_t a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  if (CGRegionForwardEnumeratorGetNextBounds(a1, (_DWORD *)&v14 + 1, &v14, (_DWORD *)&v13 + 1, &v13, a6, a7, a8))
  {
    double result = (double)SHIDWORD(v14);
    double v10 = (double)(int)v14;
    double v11 = (double)(HIDWORD(v13) - HIDWORD(v14));
    double v12 = (double)((int)v13 - (int)v14);
    *a2 = (double)SHIDWORD(v14);
    a2[1] = v10;
    a2[2] = v11;
    a2[3] = v12;
  }
  return result;
}

uint64_t op_EX(uint64_t result)
{
  return result;
}

uint64_t op_BX(uint64_t result)
{
  return result;
}

void op_BI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  v77 = 0;
  *(_OWORD *)bytes = 0u;
  long long v76 = 0u;
  if (!pdf_scanner_read_compound_object(a1, (uint64_t)bytes, 0, *(unsigned int *)(a1 + 72), 1, a6, a7, a8))return; {
  int v16 = *(_DWORD *)&bytes[8];
  }
  if (*(_DWORD *)&bytes[8] != 8)
  {
    pdf_error("failed to build inline image dictionary.");
    if ((v16 - 5) <= 4) {
      pdf_object_release_compound_value((uint64_t)bytes);
    }
    return;
  }
  uint64_t v17 = v77;
  if (!v77) {
    return;
  }
  uint64_t v18 = *(void *)(a1 + 64);
  if (v18) {
    uint64_t v19 = *(void *)(v18 + 16);
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = CGPDFSourceGetc(v19, v9, v10, v11, v12, v13, v14, v15);
  int v27 = v20;
  if (v20 > 0x20
    || ((1 << v20) & 0x100001601) == 0
    && (v20 != 13 || (int v27 = CGPDFSourceGetc(v19, v20, v21, v22, v23, v24, v25, v26), v27 != 10)))
  {
    CGPDFSourceUngetc((void *)v19, v27);
  }
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  unint64_t v36 = 0;
  while (1)
  {
    if (!v19)
    {
      pdf_error("failed to find end of inline image.");
      goto LABEL_53;
    }
    if (*(unsigned char *)(v19 + 208)) {
      break;
    }
    UInt8 v37 = CGPDFSourceGetc(v19, v28, v29, v30, v31, v32, v33, v34);
    unint64_t v38 = &bytes[v36];
    bytes[v36] = v37;
    if (v37 == 69)
    {
      UInt8 v39 = CGPDFSourceGetc(v19, v28, v29, v30, v31, v32, v33, v34);
      bytes[v36 + 1] = v39;
      if (v39 != 73)
      {
        v36 += 2;
        goto LABEL_31;
      }
      UInt8 v40 = CGPDFSourceGetc(v19, v28, v29, v30, v31, v32, v33, v34);
      bytes[v36 + 2] = v40;
      if ((v40 > 0x20u || ((1 << v40) & 0x100003601) == 0) && !*(unsigned char *)(v19 + 208))
      {
        v36 += 3;
        goto LABEL_31;
      }
      CFDataAppendBytes(Mutable, bytes, v36);
      uint64_t v41 = CGPDFStreamCreateWithData(v17, 1, Mutable);
      if (v41)
      {
        int8x8_t v42 = (const void *)v41;
        int v74 = 0;
        int v43 = CGPDFStreamCreateFilterChain(v41, &v74);
        if (v43)
        {
          unint64_t v51 = v43;
          if (v74 == 1)
          {
            do
            {
              while (1)
              {
                int v52 = CGPDFSourceGetc((uint64_t)v51, v44, v45, v46, v47, v48, v49, v50);
                if (v52 == 255) {
                  break;
                }
                if (v52 == -1) {
                  goto LABEL_45;
                }
              }
            }
            while (CGPDFSourceGetc((uint64_t)v51, v44, v45, v46, v47, v48, v49, v50) != 217);
LABEL_49:
            CFRelease(v51);
            CFRelease(v42);
            goto LABEL_53;
          }
          uint64_t Inline = CGPDFImageCreateInline(*(void *)(a1 + 56), (uint64_t)v42);
          if (Inline)
          {
            if (*(unsigned char *)(Inline + 16))
            {
              uint64_t v57 = *(void *)(Inline + 64);
            }
            else
            {
              uint64_t v58 = *(void *)(Inline + 72);
              if (v58) {
                uint64_t v58 = *(void *)(*(void *)(v58 + 24) + 48);
              }
              uint64_t v57 = *(void *)(Inline + 64) * v58;
            }
            unint64_t v59 = *(void *)(Inline + 56) * ((unint64_t)(*(void *)(Inline + 48) * v57 + 7) >> 3);
            CFRelease((CFTypeRef)Inline);
            if (!v59) {
              goto LABEL_49;
            }
            while (CGPDFSourceGetc((uint64_t)v51, v60, v61, v62, v63, v64, v65, v66) != -1)
            {
              if (!--v59) {
                goto LABEL_49;
              }
            }
          }
LABEL_45:
          CFRelease(v51);
        }
        CFRelease(v42);
      }
      uint64_t v54 = Mutable;
      uint64_t v53 = v38;
      CFIndex v55 = 3;
LABEL_48:
      CFDataAppendBytes(v54, v53, v55);
      unint64_t v36 = 0;
    }
    else
    {
      ++v36;
LABEL_31:
      if (v36 >= 0x7FD)
      {
        uint64_t v53 = bytes;
        uint64_t v54 = Mutable;
        CFIndex v55 = v36;
        goto LABEL_48;
      }
    }
  }
  pdf_error("failed to find end of inline image.");
  if (v36) {
    CFDataAppendBytes(Mutable, bytes, v36);
  }
LABEL_53:
  if (Mutable)
  {
    uint64_t v67 = CGPDFStreamCreateWithData(v17, 1, Mutable);
    CFRelease(v17);
    CFRelease(Mutable);
    if (v67)
    {
      *(_OWORD *)bytes = 0u;
      long long v76 = 0u;
      *(_DWORD *)&bytes[8] = 9;
      v77 = (const void *)v67;
      int v68 = *(_DWORD *)(a1 + 72);
      uint64_t v69 = *(int *)(a1 + 76);
      if (v68 >= (int)v69)
      {
        *(_DWORD *)(a1 + 76) = 2 * v69;
        uint64_t v70 = (char *)malloc_type_realloc(*(void **)(a1 + 80), 80 * v69, 0x103204077D336DFuLL);
        *(void *)(a1 + 80) = v70;
      }
      else
      {
        uint64_t v70 = *(char **)(a1 + 80);
      }
      int8x16x2_t v71 = &v70[40 * *(int *)(a1 + 72)];
      *(_OWORD *)int8x16x2_t v71 = *(_OWORD *)bytes;
      *((_OWORD *)v71 + 1) = v76;
      *((void *)v71 + 4) = v77;
      ++*(_DWORD *)(a1 + 72);
      uint64_t v72 = *(void *)(a1 + 24);
      int16x8_t v73 = *(void (**)(uint64_t, void))(v72 + 8 * (int)CGPDFGetOperatorForName("EI", 2uLL, 0));
      if (v73) {
        v73(a1, *(void *)(a1 + 16));
      }
      pdf_object_release_compound_value((uint64_t)bytes);
      if (*(_DWORD *)(a1 + 72) > v68) {
        *(_DWORD *)(a1 + 72) = v68;
      }
    }
  }
  else
  {
    CFRelease(v17);
  }
}

uint64_t pdf_scanner_read_compound_object(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  size_t __n = 0;
  if ((int)a3 > 1000)
  {
    if ((a4 & 0x80000000) != 0 || (*(_DWORD *)(a1 + 72) & 0x80000000) != 0) {
      pdf_error("Fatal: Attempted to remove more than args stack count. Argument stack is inconsistent.");
    }
    pdf_error("failed to build compound object: nesting too deep.");
    return 0;
  }
  int v13 = 0;
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  uint64_t v14 = (a3 + 1);
  while (2)
  {
    int v15 = pdf_lexer_scan(*(void *)(a1 + 64), (uint64_t)&v50, a3, a4, a5, a6, a7, a8);
    switch(v15)
    {
      case 0:
      case 15:
        if (pdf_scanner_advance_stream((void *)a1)) {
          continue;
        }
        if (v8 < 0 || (int v31 = *(_DWORD *)(a1 + 72), v31 < v13))
        {
          pdf_error("Fatal: Attempted to remove more than args stack count. Argument stack is inconsistent.");
          int v31 = *(_DWORD *)(a1 + 72);
        }
        if (!v13) {
          goto LABEL_65;
        }
        if (v31 <= v8) {
          pdf_error("Fatal: Attempted to remove beyond args stack count. Argument stack is inconsistent.");
        }
        uint64_t v32 = v8;
        uint64_t v33 = v13 + v8;
        uint64_t v34 = 40 * v8;
        do
        {
          uint64_t v35 = *(void *)(a1 + 80) + v34;
          if ((*(_DWORD *)(v35 + 8) - 5) <= 4) {
            pdf_object_release_compound_value(v35);
          }
          ++v32;
          v34 += 40;
        }
        while (v32 < v33);
        goto LABEL_64;
      case 1:
        pdf_scanner_handle_choke((uint64_t)&v50);
        if (v8 < 0 || (int v31 = *(_DWORD *)(a1 + 72), v31 < v13))
        {
          pdf_error("Fatal: Attempted to remove more than args stack count. Argument stack is inconsistent.");
          int v31 = *(_DWORD *)(a1 + 72);
        }
        if (!v13) {
          goto LABEL_65;
        }
        if (v31 <= v8) {
          pdf_error("Fatal: Attempted to remove beyond args stack count. Argument stack is inconsistent.");
        }
        uint64_t v36 = v8;
        uint64_t v37 = v13 + v8;
        uint64_t v38 = 40 * v8;
        do
        {
          uint64_t v39 = *(void *)(a1 + 80) + v38;
          if ((*(_DWORD *)(v39 + 8) - 5) <= 4) {
            pdf_object_release_compound_value(v39);
          }
          ++v36;
          v38 += 40;
        }
        while (v36 < v37);
        goto LABEL_64;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 8:
      case 13:
        goto LABEL_12;
      case 7:
        operator_name_string = pdf_lexer_get_operator_name_string(*(void *)(a1 + 64), &__n);
        uint64_t v20 = operator_name_string;
        size_t v21 = __n;
        if (!a5 || strncmp(operator_name_string, "BI", __n) && strncmp(v20, "ID", v21))
        {
          uint64_t v22 = *(void *)(a1 + 72);
          uint64_t v23 = *(void *)(a1 + 80);
          *(void *)(a1 + 72) = 0x800000000;
          *(void *)(a1 + 80) = malloc_type_malloc(0x140uLL, 0x103204077D336DFuLL);
          pdf_scanner_handle_xname(a1);
          if ((DWORD2(v50) - 5) <= 4) {
            pdf_object_release_compound_value((uint64_t)&v50);
          }
          uint64_t v24 = *(unsigned int *)(a1 + 72);
          if ((v24 & 0x80000000) != 0)
          {
            pdf_error("Fatal: Attempted to remove more than args stack count. Argument stack is inconsistent.");
          }
          else if (v24)
          {
            uint64_t v25 = 0;
            uint64_t v26 = 40 * v24;
            do
            {
              uint64_t v27 = *(void *)(a1 + 80) + v25;
              if ((*(_DWORD *)(v27 + 8) - 5) <= 4) {
                pdf_object_release_compound_value(v27);
              }
              v25 += 40;
            }
            while (v26 != v25);
          }
          *(void *)(a1 + 72) = v22;
          *(void *)(a1 + 80) = v23;
          continue;
        }
        if ((DWORD2(v50) - 5) <= 4) {
          pdf_object_release_compound_value((uint64_t)&v50);
        }
LABEL_68:
        object_list = pdf_scanner_create_object_list(a1, v13);
        uint64_t v41 = (pthread_mutex_t *)CGPDFDictionaryCreateWithObjects(0, (void **)object_list);
        if (!v41)
        {
          pdf_error("failed to build dictionary during parsing.");
          if (object_list)
          {
            do
            {
              uint64_t v48 = (void *)*object_list;
              if ((*((_DWORD *)object_list + 2) - 5) <= 4) {
                pdf_object_release_compound_value((uint64_t)object_list);
              }
              free(object_list);
              object_list = v48;
            }
            while (v48);
          }
          return 0;
        }
        int v42 = 8;
LABEL_70:
        *(_DWORD *)(a2 + 8) = v42;
        *(void *)(a2 + 32) = v41;
        return 1;
      case 9:
      case 11:
        if (!pdf_scanner_read_compound_object(a1, &v50, v14, *(unsigned int *)(a1 + 72), a5)) {
          continue;
        }
LABEL_12:
        int v16 = *(_DWORD *)(a1 + 72);
        uint64_t v17 = *(int *)(a1 + 76);
        if (v16 >= (int)v17)
        {
          *(_DWORD *)(a1 + 76) = 2 * v17;
          uint64_t v18 = (char *)malloc_type_realloc(*(void **)(a1 + 80), 80 * v17, 0x103204077D336DFuLL);
          *(void *)(a1 + 80) = v18;
          int v16 = *(_DWORD *)(a1 + 72);
        }
        else
        {
          uint64_t v18 = *(char **)(a1 + 80);
        }
        uint64_t v28 = &v18[40 * v16];
        long long v29 = v50;
        long long v30 = v51;
        *((void *)v28 + 4) = v52;
        *(_OWORD *)uint64_t v28 = v29;
        *((_OWORD *)v28 + 1) = v30;
        ++*(_DWORD *)(a1 + 72);
        ++v13;
        continue;
      case 10:
        goto LABEL_68;
      case 12:
        UInt8 v40 = pdf_scanner_create_object_list(a1, v13);
        uint64_t v41 = CGPDFArrayCreateWithObjects(0, v40);
        if (v41)
        {
          int v42 = 7;
          goto LABEL_70;
        }
        pdf_error("failed to build array during parsing.");
        if (!v40) {
          return 0;
        }
        do
        {
          uint64_t v49 = (void *)*v40;
          if ((*((_DWORD *)v40 + 2) - 5) <= 4) {
            pdf_object_release_compound_value((uint64_t)v40);
          }
          free(v40);
          uint64_t result = 0;
          UInt8 v40 = v49;
        }
        while (v49);
        return result;
      default:
        pdf_error("encountered unexpected object type: %d.", v15);
        if (v8 < 0 || (int v31 = *(_DWORD *)(a1 + 72), v31 < v13))
        {
          pdf_error("Fatal: Attempted to remove more than args stack count. Argument stack is inconsistent.");
          int v31 = *(_DWORD *)(a1 + 72);
        }
        if (!v13) {
          goto LABEL_65;
        }
        if (v31 <= v8) {
          pdf_error("Fatal: Attempted to remove beyond args stack count. Argument stack is inconsistent.");
        }
        uint64_t v43 = v8;
        uint64_t v44 = v13 + v8;
        uint64_t v45 = 40 * v8;
        do
        {
          uint64_t v46 = *(void *)(a1 + 80) + v45;
          if ((*(_DWORD *)(v46 + 8) - 5) <= 4) {
            pdf_object_release_compound_value(v46);
          }
          ++v43;
          v45 += 40;
        }
        while (v43 < v44);
LABEL_64:
        int v31 = *(_DWORD *)(a1 + 72);
LABEL_65:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 72) = v31 - v13;
        return result;
    }
  }
}

void *pdf_scanner_create_object_list(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 72) < a2) {
    pdf_error("Attempting to create args list from args count for more objects than the stack has.");
  }
  if (a2 < 1)
  {
    uint64_t result = 0;
  }
  else
  {
    double v4 = 0;
    double v5 = 0;
    int v6 = -a2;
    do
    {
      uint64_t result = malloc_type_malloc(0x28uLL, 0x103204077D336DFuLL);
      int v8 = result;
      if (v4)
      {
        *double v5 = result;
        uint64_t result = v4;
      }
      uint64_t v9 = *(void *)(a1 + 80) + 40 * (v6 + *(_DWORD *)(a1 + 72));
      long long v11 = *(_OWORD *)v9;
      long long v10 = *(_OWORD *)(v9 + 16);
      v8[4] = *(void *)(v9 + 32);
      *(_OWORD *)int v8 = v11;
      *((_OWORD *)v8 + 1) = v10;
      *int v8 = 0;
      double v4 = result;
      double v5 = v8;
    }
    while (!__CFADD__(v6++, 1));
  }
  *(_DWORD *)(a1 + 72) -= a2;
  return result;
}

void pdf_scanner_handle_choke(uint64_t a1)
{
  if (a1 && *(_DWORD *)(a1 + 8) == 6)
  {
    uint64_t v1 = *(void *)(a1 + 32);
    if (v1)
    {
      if (*(void *)(v1 + 24)) {
        decrypt_string(*(void *)(a1 + 32));
      }
      if (*(void *)(v1 + 72) >= 0x33uLL)
      {
        if (*(void *)(v1 + 24)) {
          decrypt_string(v1);
        }
        return;
      }
      if (*(void *)(v1 + 24)) {
        decrypt_string(v1);
      }
    }
    return;
  }

  pdf_error("encountered unexpected input.");
}

CGPDFScannerRef CGPDFScannerRetain(CGPDFScannerRef scanner)
{
  if (scanner) {
    CFRetain(scanner);
  }
  return scanner;
}

void CGPDFScannerRelease(CGPDFScannerRef scanner)
{
  if (scanner) {
    CFRelease(scanner);
  }
}

void CGPDFScannerStop(CGPDFScannerRef s)
{
  if (s) {
    *((unsigned char *)s + 136) = 1;
  }
}

CGPDFContentStreamRef CGPDFScannerGetContentStream(CGPDFScannerRef scanner)
{
  return (CGPDFContentStreamRef)*((void *)scanner + 7);
}

BOOL CGPDFScannerPopObject(CGPDFScannerRef scanner, CGPDFObjectRef *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
  }
  else
  {
    if (value) {
      *value = (CGPDFObjectRef)(*((void *)scanner + 10) + 40 * (v2 - 1));
    }
    *((_DWORD *)scanner + 18) = v2 - 1;
  }
  return v2 > 0;
}

BOOL CGPDFScannerPopBoolean(CGPDFScannerRef scanner, CGPDFBoolean *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
    return 0;
  }
  uint64_t v3 = *((void *)scanner + 10);
  unsigned int v4 = v2 - 1;
  *((_DWORD *)scanner + 18) = v4;
  if (!v3 || *(_DWORD *)(v3 + 40 * v4 + 8) != 2) {
    return 0;
  }
  if (value) {
    *value = *(unsigned char *)(v3 + 40 * v4 + 32);
  }
  return 1;
}

BOOL CGPDFScannerPopInteger(CGPDFScannerRef scanner, CGPDFInteger *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
    return 0;
  }
  uint64_t v3 = *((void *)scanner + 10);
  unsigned int v4 = v2 - 1;
  *((_DWORD *)scanner + 18) = v4;
  if (!v3) {
    return 0;
  }
  int v5 = *(_DWORD *)(v3 + 40 * v4 + 8);
  if (v5 != 12 && v5 != 3) {
    return 0;
  }
  if (value) {
    *value = *(void *)(v3 + 40 * v4 + 32);
  }
  return 1;
}

BOOL CGPDFScannerPopString(CGPDFScannerRef scanner, CGPDFStringRef *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
    return 0;
  }
  uint64_t v3 = *((void *)scanner + 10);
  unsigned int v4 = v2 - 1;
  *((_DWORD *)scanner + 18) = v4;
  if (!v3 || *(_DWORD *)(v3 + 40 * v4 + 8) != 6) {
    return 0;
  }
  if (value) {
    *value = *(CGPDFStringRef *)(v3 + 40 * v4 + 32);
  }
  return 1;
}

BOOL CGPDFScannerPopArray(CGPDFScannerRef scanner, CGPDFArrayRef *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
    return 0;
  }
  uint64_t v3 = *((void *)scanner + 10);
  unsigned int v4 = v2 - 1;
  *((_DWORD *)scanner + 18) = v4;
  if (!v3 || *(_DWORD *)(v3 + 40 * v4 + 8) != 7) {
    return 0;
  }
  if (value) {
    *value = *(CGPDFArrayRef *)(v3 + 40 * v4 + 32);
  }
  return 1;
}

BOOL CGPDFScannerPopDictionary(CGPDFScannerRef scanner, CGPDFDictionaryRef *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
    return 0;
  }
  uint64_t v3 = *((void *)scanner + 10);
  unsigned int v4 = v2 - 1;
  *((_DWORD *)scanner + 18) = v4;
  if (!v3 || *(_DWORD *)(v3 + 40 * v4 + 8) != 8) {
    return 0;
  }
  if (value) {
    *value = *(CGPDFDictionaryRef *)(v3 + 40 * v4 + 32);
  }
  return 1;
}

BOOL CGPDFScannerPopStream(CGPDFScannerRef scanner, CGPDFStreamRef *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
    return 0;
  }
  uint64_t v3 = *((void *)scanner + 10);
  unsigned int v4 = v2 - 1;
  *((_DWORD *)scanner + 18) = v4;
  if (!v3 || *(_DWORD *)(v3 + 40 * v4 + 8) != 9) {
    return 0;
  }
  if (value) {
    *value = *(CGPDFStreamRef *)(v3 + 40 * v4 + 32);
  }
  return 1;
}

BOOL GetNamedArrayCommandFromObject(uint64_t a1, CGPDFArray **a2, const char **a3)
{
  if (a1 && *(_DWORD *)(a1 + 8) == 7 && (uint64_t v3 = *(CGPDFArray **)(a1 + 32), (*a2 = v3) != 0) && *((void *)v3 + 2)) {
    return CGPDFArrayGetName(v3, 0, a3);
  }
  else {
    return 0;
  }
}

void CreateColorSpaceFromInlineObject(uint64_t a1, CGColorSpaceRef *a2)
{
  if (!a1 || (int v4 = *(_DWORD *)(a1 + 8), v4 == 12))
  {
    *a2 = 0;
    goto LABEL_4;
  }
  *a2 = 0;
  if (v4 != 7)
  {
    if (v4 == 5)
    {
      int v5 = *(const char **)(a1 + 32);
      if (!strcmp(v5, "CMYK"))
      {
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
      }
      else if (!strcmp(v5, "G"))
      {
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceGray();
      }
      else
      {
        if (strcmp(v5, "RGB")) {
          goto LABEL_4;
        }
        CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceRGB();
      }
      *a2 = DeviceCMYK;
      return;
    }
LABEL_4:
    CreateColorSpaceFromObject((CGColorSpaceRef)a1, a2);
    return;
  }
  __s1 = 0;
  int v8 = 0;
  if (GetNamedArrayCommandFromObject(a1, &v8, (const char **)&__s1))
  {
    if (!strcmp(__s1, "I"))
    {
      CreateIndexedColorSpace(v8, a2);
      return;
    }
    goto LABEL_4;
  }
}

void CreateIndexedColorSpace(CGPDFArray *a1, CGColorSpaceRef *a2)
{
  *a2 = 0;
  CFTypeRef cf = 0;
  CGPDFObjectRef value = 0;
  CGPDFArrayGetObject(a1, 1uLL, &value);
  CreateColorSpaceFromObject(value, (CGColorSpaceRef *)&cf);
  int v4 = (CGColorSpace *)cf;
  if (cf)
  {
    uint64_t v5 = *(void *)(*((void *)cf + 3) + 48);
    if (v5)
    {
      CGPDFInteger v18 = 0;
      CGPDFArrayGetInteger(a1, 2uLL, &v18);
      CGPDFInteger v6 = v18;
      CGPDFArrayGetObject(a1, 3uLL, &value);
      if (value)
      {
        unint64_t v7 = v5 + v5 * v6;
        int v8 = *((_DWORD *)value + 2);
        if (v8 == 6)
        {
          uint64_t v17 = 0;
          CGPDFArrayGetString(a1, 3uLL, (CGPDFStringRef *)&v17);
          long long v11 = v17;
          if (v17)
          {
            if (v17[3]) {
              decrypt_string((uint64_t)v17);
            }
            unint64_t v12 = v11[9];
          }
          else
          {
            unint64_t v12 = 0;
          }
          if (v12 >= v7)
          {
            int v15 = v17;
            if (v17)
            {
              if (v17[3]) {
                decrypt_string((uint64_t)v17);
              }
              int v16 = (const unsigned __int8 *)(v15 + 10);
            }
            else
            {
              int v16 = 0;
            }
            *a2 = CGColorSpaceCreateIndexed(v4, v18, v16);
          }
        }
        else if (v8 == 9)
        {
          uint64_t v9 = (UInt8 *)malloc_type_malloc(v7, 0xC485A3F2uLL);
          if (value && *((_DWORD *)value + 2) == 9) {
            long long v10 = (CGPDFStream *)*((void *)value + 4);
          }
          else {
            long long v10 = 0;
          }
          LODWORD(v17) = 0;
          CFDataRef v13 = CGPDFStreamCopyData(v10, (CGPDFDataFormat *)&v17);
          if (v13)
          {
            CFDataRef v14 = v13;
            if (CFDataGetLength(v13) >= v7)
            {
              v21.location = 0;
              v21.length = v7;
              CFDataGetBytes(v14, v21, v9);
              *a2 = CGColorSpaceCreateIndexed(v4, v18, v9);
            }
            CFRelease(v14);
          }
          free(v9);
        }
      }
    }
    CFRelease(v4);
  }
}

CGColorSpaceRef CreateColorSpaceFromObject(CGColorSpaceRef result, CGColorSpaceRef *a2)
{
  blackPoint[3] = *(CGFloat *)MEMORY[0x1E4F143B8];
  *a2 = 0;
  if (!result) {
    return result;
  }
  int v3 = *((_DWORD *)result + 2);
  if (v3 == 7)
  {
    __s1 = 0;
    CGPDFObjectRef value = 0;
    uint64_t result = (CGColorSpaceRef)GetNamedArrayCommandFromObject((uint64_t)result, (CGPDFArray **)&value, (const char **)&__s1);
    if (!result) {
      return result;
    }
    if (CreateColorSpaceFromObject_pred != -1) {
      dispatch_once(&CreateColorSpaceFromObject_pred, &__block_literal_global_21791);
    }
    CFArrayRef v5 = (const __CFArray *)pthread_getspecific(cp_colorspaces_key);
    if (v5)
    {
      CFArrayRef Mutable = v5;
      CFIndex Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        CFIndex v9 = 0;
        do
        {
          long long v10 = value;
          if (v10 == CFArrayGetValueAtIndex(Mutable, v9)) {
            return (CGColorSpaceRef)fwrite("invalid color space: color space cannot have a circular reference.\n", 0x43uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
          }
        }
        while (v8 != ++v9);
      }
    }
    else
    {
      CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 100, 0);
    }
    CFArrayAppendValue(Mutable, value);
    pthread_setspecific(cp_colorspaces_key, Mutable);
    long long v11 = __s1;
    if (!strcmp(__s1, "CalGray"))
    {
      unint64_t v12 = (CGPDFArray *)value;
      dict[0] = 0;
      *a2 = 0;
      if (!CGPDFArrayGetDictionary(v12, 1uLL, dict)) {
        goto LABEL_49;
      }
      memset(blackPoint, 0, 24);
      gamma[0] = 0.0;
      if (!GetArrayValues(dict[0], "WhitePoint", (uint64_t)&whitePoint, 3)) {
        goto LABEL_49;
      }
      GetArrayValues(dict[0], "BlackPoint", (uint64_t)blackPoint, 3);
      CGPDFDictionaryGetNumber(dict[0], "Gamma", gamma);
      CGColorSpaceRef Pattern = CGColorSpaceCreateCalibratedGray(&whitePoint, blackPoint, gamma[0]);
    }
    else
    {
      if (strcmp(v11, "CalRGB"))
      {
        if (!strcmp(v11, "Lab"))
        {
          CreateLabColorSpace((CGPDFArray *)value, a2);
        }
        else if (!strcmp(v11, "ICCBased"))
        {
          CreateICCBasedColorSpace((CGPDFArray *)value, a2);
        }
        else if (!strcmp(v11, "Indexed"))
        {
          CreateIndexedColorSpace(value, a2);
        }
        else
        {
          if (strcmp(v11, "DeviceN"))
          {
            if (strcmp(v11, "Pattern"))
            {
              if (!strcmp(v11, "Separation")) {
                CreateSeparationColorSpace((CGPDFArray *)value, (uint64_t *)a2);
              }
              goto LABEL_49;
            }
            if (value && *((void *)value + 2) >= 2uLL)
            {
              CGFloat whitePoint = 0.0;
              CGPDFArrayGetObject((CGPDFArrayRef)value, 1uLL, (CGPDFObjectRef *)&whitePoint);
              blackPoint[0] = 0.0;
              CreateColorSpaceFromObject(*(void *)&whitePoint, blackPoint);
              CGFloat v15 = blackPoint[0];
              if (*(void *)&blackPoint[0])
              {
                *a2 = CGColorSpaceCreatePattern(*(CGColorSpaceRef *)&blackPoint[0]);
                CFRelease(*(CFTypeRef *)&v15);
              }
              goto LABEL_49;
            }
            CGColorSpaceRef Pattern = CGColorSpaceCreatePattern(0);
            goto LABEL_48;
          }
          CreateDeviceNColorSpace((CGPDFArray *)value, (uint64_t *)a2);
        }
LABEL_49:
        v31.length = CFArrayGetCount(Mutable);
        v31.location = 0;
        CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(Mutable, v31, value);
        CFArrayRemoveValueAtIndex(Mutable, FirstIndexOfValue);
        return (CGColorSpaceRef)pthread_setspecific(cp_colorspaces_key, Mutable);
      }
      CFDataRef v14 = (CGPDFArray *)value;
      CGPDFDictionaryRef v19 = 0;
      *a2 = 0;
      if (!CGPDFArrayGetDictionary(v14, 1uLL, &v19)) {
        goto LABEL_49;
      }
      memset(dict, 0, sizeof(dict));
      *(_OWORD *)gamma = xmmword_185296170;
      uint64_t v28 = 0x3FF0000000000000;
      uint64_t v22 = 0;
      long long v24 = 0u;
      long long v21 = 0u;
      CGFloat whitePoint = 1.0;
      uint64_t v23 = 0x3FF0000000000000;
      uint64_t v25 = 0;
      uint64_t v26 = 0x3FF0000000000000;
      if (!GetArrayValues(v19, "WhitePoint", (uint64_t)blackPoint, 3)) {
        goto LABEL_49;
      }
      GetArrayValues(v19, "BlackPoint", (uint64_t)dict, 3);
      GetArrayValues(v19, "Gamma", (uint64_t)gamma, 3);
      GetArrayValues(v19, "Matrix", (uint64_t)&whitePoint, 9);
      CGColorSpaceRef Pattern = CGColorSpaceCreateCalibratedRGB(blackPoint, (const CGFloat *)dict, gamma, &whitePoint);
    }
LABEL_48:
    *a2 = Pattern;
    goto LABEL_49;
  }
  if (v3 != 5) {
    return result;
  }
  int v4 = (const char *)*((void *)result + 4);
  if (!strcmp(v4, "DeviceCMYK"))
  {
    uint64_t result = CGColorSpaceCreateDeviceCMYK();
  }
  else if (!strcmp(v4, "DeviceGray"))
  {
    uint64_t result = CGColorSpaceCreateDeviceGray();
  }
  else if (!strcmp(v4, "DeviceRGB"))
  {
    uint64_t result = CGColorSpaceCreateDeviceRGB();
  }
  else
  {
    uint64_t result = (CGColorSpaceRef)strcmp(v4, "Pattern");
    if (result) {
      return result;
    }
    uint64_t result = CGColorSpaceCreatePattern(0);
  }
  *a2 = result;
  return result;
}

BOOL GetArrayValues(CGPDFDictionary *a1, const char *a2, uint64_t a3, int a4)
{
  CGPDFArrayRef value = 0;
  BOOL result = CGPDFDictionaryGetArray(a1, a2, &value);
  if (result)
  {
    CGPDFArrayRef v7 = value;
    if (value) {
      CGPDFArrayRef v7 = (CGPDFArrayRef)*((void *)value + 2);
    }
    if (v7 == (CGPDFArrayRef)a4)
    {
      if (a4 >= 1)
      {
        size_t v8 = 0;
        do
        {
          uint64_t v9 = 0;
          CGPDFArrayGetNumber(value, v8, (CGPDFReal *)&v9);
          *(void *)(a3 + 8 * v8++) = v9;
        }
        while (a4 != v8);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CGColorSpaceRef CreateLabColorSpace(CGPDFArray *a1, void *a2)
{
  whitePoint[3] = *(CGFloat *)MEMORY[0x1E4F143B8];
  CGPDFDictionaryRef value = 0;
  *a2 = 0;
  CGColorSpaceRef result = (CGColorSpaceRef)CGPDFArrayGetDictionary(a1, 1uLL, &value);
  if (result)
  {
    memset(blackPoint, 0, sizeof(blackPoint));
    *(_OWORD *)range = xmmword_185296188;
    long long v6 = unk_185296198;
    CGColorSpaceRef result = (CGColorSpaceRef)GetArrayValues(value, "WhitePoint", (uint64_t)whitePoint, 3);
    if (result)
    {
      GetArrayValues(value, "BlackPoint", (uint64_t)blackPoint, 3);
      GetArrayValues(value, "Range", (uint64_t)range, 4);
      CGColorSpaceRef result = CGColorSpaceCreateLab(whitePoint, blackPoint, range);
      *a2 = result;
    }
  }
  return result;
}

void CreateICCBasedColorSpace(CGPDFArray *a1, CGColorSpaceRef *a2)
{
  *a2 = 0;
  CGPDFStreamRef value = 0;
  if (!CGPDFArrayGetStream(a1, 1uLL, &value)) {
    return;
  }
  CGPDFInteger v26 = 0;
  if (!value) {
    return;
  }
  int v3 = (CGPDFDictionary *)*((void *)value + 6);
  if (!v3
    || !CGPDFDictionaryGetInteger(*((CGPDFDictionaryRef *)value + 6), "N", &v26)
    || v26 > 4
    || (v26 & 0xFFFFFFFFFFFFFFFDLL) == 0)
  {
    return;
  }
  CGPDFObjectRef v25 = 0;
  if (!CGPDFDictionaryGetObject(v3, "Alternate", &v25))
  {
    if (v26 == 3)
    {
LABEL_18:
      CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
      goto LABEL_19;
    }
    if (v26 == 1) {
      goto LABEL_16;
    }
LABEL_17:
    CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceCMYK();
    goto LABEL_19;
  }
  if (!v25 || *((_DWORD *)v25 + 2) != 5) {
    return;
  }
  int v4 = (const char *)*((void *)v25 + 4);
  if (!strcmp(v4, "DeviceCMYK")) {
    goto LABEL_17;
  }
  if (strcmp(v4, "DeviceGray"))
  {
    if (strcmp(v4, "DeviceRGB")) {
      return;
    }
    goto LABEL_18;
  }
LABEL_16:
  CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceGray();
LABEL_19:
  long long v6 = DeviceRGB;
  uint64_t v7 = (2 * v26);
  size_t v8 = (CGFloat *)malloc_type_malloc(8 * (int)v7, 0x100004000313F17uLL);
  uint64_t v9 = v8;
  if ((int)v7 >= 1)
  {
    int8x16_t v10 = (int8x16_t)xmmword_1850CD8A0;
    int8x16_t v11 = (int8x16_t)vdupq_n_s64(1uLL);
    __asm { FMOV            V2.2D, #1.0 }
    int64x2_t v17 = vdupq_n_s64(2uLL);
    CGPDFInteger v18 = (int8x16_t *)v8;
    uint64_t v19 = v7;
    do
    {
      *v18++ = vbicq_s8(_Q2, (int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v10, v11)));
      int8x16_t v10 = (int8x16_t)vaddq_s64((int64x2_t)v10, v17);
      v19 -= 2;
    }
    while (v19);
  }
  GetArrayValues(v3, "Range", (uint64_t)v8, v7);
  CGPDFDataFormat format = CGPDFDataFormatRaw;
  CFDataRef v20 = CGPDFStreamCopyData(value, &format);
  if (v20)
  {
    CFDataRef v21 = v20;
    uint64_t v22 = CGDataProviderCreateWithCFData(v20);
    if (v22)
    {
      uint64_t v23 = v22;
      *a2 = CGColorSpaceCreateICCBased(v26, v9, v22, v6);
      CGDataProviderRelease(v23);
    }
    CFRelease(v21);
  }
  CGColorSpaceRelease(v6);
  free(v9);
}

void CreateDeviceNColorSpace(CGPDFArray *a1, uint64_t *a2)
{
  CGPDFArrayRef value = 0;
  *a2 = 0;
  if (CGPDFArrayGetArray(a1, 1uLL, &value))
  {
    CGPDFObjectRef v17 = 0;
    if (CGPDFArrayGetObject(a1, 2uLL, &v17))
    {
      CGPDFObjectRef v16 = 0;
      if (CGPDFArrayGetObject(a1, 3uLL, &v16))
      {
        CGFloat v15 = 0;
        CreateColorSpaceFromObject(v17, &v15);
        if (value)
        {
          unint64_t v4 = *((void *)value + 2);
          CFArrayRef v5 = malloc_type_malloc(8 * v4, 0x10040436913F5uLL);
          long long v6 = v5;
          if (v4)
          {
            size_t v7 = 0;
            size_t v8 = (const char **)v5;
            while (CGPDFArrayGetName(value, v7, v8))
            {
              ++v7;
              ++v8;
              if (v4 == v7)
              {
                Function = CGPDFFunctionCreateFunction((char *)v16);
                CFDataRef v13 = v15;
                unint64_t v14 = v4;
                goto LABEL_12;
              }
            }
            CFDataRef v13 = v15;
LABEL_15:
            CGColorSpaceRelease(v13);
            free(v6);
            return;
          }
        }
        else
        {
          long long v6 = malloc_type_malloc(0, 0x10040436913F5uLL);
        }
        Function = CGPDFFunctionCreateFunction((char *)v16);
        CFDataRef v13 = v15;
        unint64_t v14 = 0;
LABEL_12:
        *a2 = CGColorSpaceCreateDeviceN(v14, (uint64_t)v6, v13, Function, 0, v9, v10, v11);
        if (Function) {
          CFRelease(Function);
        }
        goto LABEL_15;
      }
    }
  }
}

void CreateSeparationColorSpace(CGPDFArray *a1, uint64_t *a2)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  CGPDFArrayRef value = 0;
  if (CGPDFArrayGetName(a1, 1uLL, (const char **)&value))
  {
    CGPDFObjectRef v11 = 0;
    if (CGPDFArrayGetObject(a1, 2uLL, &v11))
    {
      CGPDFObjectRef v10 = 0;
      if (CGPDFArrayGetObject(a1, 3uLL, &v10))
      {
        v13[0] = value;
        uint64_t v9 = 0;
        CreateColorSpaceFromObject(v11, &v9);
        Function = CGPDFFunctionCreateFunction((char *)v10);
        CFArrayRef v5 = v9;
        *a2 = CGColorSpaceCreateDeviceN(1uLL, (uint64_t)v13, v9, Function, 0, v6, v7, v8);
        if (v5) {
          CGColorSpaceRelease(v5);
        }
        if (Function) {
          CFRelease(Function);
        }
      }
    }
  }
}

uint64_t __CreateColorSpaceFromObject_block_invoke()
{
  return pthread_key_create((pthread_key_t *)&cp_colorspaces_key, (void (__cdecl *)(void *))cp_build_colorspace_destroy);
}

void cp_build_colorspace_destroy(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CGColorSpaceRef CreateColorSpaceFromName(const char *a1, CGColorSpaceRef *a2)
{
  if (!strcmp(a1, "DeviceGray"))
  {
    CGColorSpaceRef result = CGColorSpaceCreateDeviceGray();
  }
  else if (!strcmp(a1, "DeviceRGB"))
  {
    CGColorSpaceRef result = CGColorSpaceCreateDeviceRGB();
  }
  else if (!strcmp(a1, "DeviceCMYK"))
  {
    CGColorSpaceRef result = CGColorSpaceCreateDeviceCMYK();
  }
  else if (!strcmp(a1, "Pattern"))
  {
    CGColorSpaceRef result = CGColorSpaceCreatePattern(0);
  }
  else
  {
    CGColorSpaceRef result = 0;
  }
  *a2 = result;
  return result;
}

void CGPDFStreamFinalize(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 48);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = *(const void **)(a1 + 72);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t CGPDFStreamCreateWithData(const void *a1, char a2, const __CFData *a3)
{
  if (!a3) {
    return 0;
  }
  if (CGPDFStreamGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFStreamGetTypeID_onceToken, &__block_literal_global_21818);
  }
  uint64_t cftype = pdf_create_cftype();
  if (cftype)
  {
    CGDataProviderRef v7 = CGDataProviderCreateWithCFData(a3);
    if (v7)
    {
      CGDataProviderRef v8 = v7;
      *(void *)(cftype + 16) = 0;
      *(void *)(cftype + 24) = 0;
      *(void *)(cftype + 32) = 0;
      *(unsigned char *)(cftype + 40) = a2;
      if (a1) {
        CFRetain(a1);
      }
      *(void *)(cftype + 48) = a1;
      *(void *)(cftype + 56) = 0;
      CFIndex Length = CFDataGetLength(a3);
      *(void *)(cftype + 64) = Length;
      CGPDFObjectRef v10 = CGPDFSourceCreate(v8, 0, Length);
      *(void *)(cftype + 72) = v10;
      *(_DWORD *)(cftype + 80) = 0;
      if (v10) {
        CFRelease(v8);
      }
      return cftype;
    }
    return 0;
  }
  return cftype;
}

CFTypeRef CGPDFStreamRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void CGPDFStreamRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CGPDFDictionaryRef CGPDFStreamGetDictionary(CGPDFDictionaryRef stream)
{
  if (stream) {
    return (CGPDFDictionaryRef)*((void *)stream + 6);
  }
  return stream;
}

uint64_t CGPDFStreamGetObjectReference(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

CFDataRef CGPDFStreamCopyRawData(uint64_t *a1)
{
  uint64_t v1 = a1[8];
  if (v1 < 1) {
    return 0;
  }
  Copy = CGPDFSourceCreateCopy(a1[9], a1[7], v1);
  if (!Copy) {
    return 0;
  }
  int v3 = Copy;
  unint64_t v4 = malloc_type_calloc(1uLL, v1, 0xD504CC28uLL);
  uint64_t v10 = CGPDFSourceRead((uint64_t)v3, (uint64_t)v4, v1, v5, v6, v7, v8, v9);
  CFRelease(v3);
  if (v10 != v1)
  {
    free(v4);
    return 0;
  }
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];

  return CFDataCreateWithBytesNoCopy(v11, (const UInt8 *)v4, v1, v12);
}

uint64_t CGPDFStreamCreateDataProvider(const void *a1, int *a2)
{
  unint64_t v4 = (CFTypeRef *)malloc_type_malloc(0x10uLL, 0x566C45D1uLL);
  __CFSetLastAllocationEventName();
  if (!v4) {
    return 0;
  }
  if (!a1)
  {
    *unint64_t v4 = 0;
    v4[1] = 0;
    goto LABEL_8;
  }
  CFRetain(a1);
  *unint64_t v4 = a1;
  FilterChain = CGPDFStreamCreateFilterChain((uint64_t)a1, a2);
  v4[1] = FilterChain;
  if (!FilterChain)
  {
LABEL_8:
    chain_release(v4);
    return 0;
  }

  return CGDataProviderCreateSequentialWithInternalCallbacks((uint64_t)v4, (uint64_t)&chain_callbacks, v6, v7, v8, v9, v10, v11);
}

void chain_release(CFTypeRef *a1)
{
  CFTypeRef v2 = a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  if (*a1) {
    CFRelease(*a1);
  }

  free(a1);
}

uint64_t chain_has_error(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1 && (CFTypeRef v2 = *(uint64_t (**)(void))(v1 + 72)) != 0) {
    return v2(*(void *)(v1 + 80));
  }
  else {
    return 0;
  }
}

void chain_rewind(uint64_t a1)
{
  CFTypeRef v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 8) = 0;
  }
}

void *chain_skip_bytes(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGColorSpaceRef result = (void *)a1[1];
  if (result || (CGColorSpaceRef result = CGPDFStreamCreateFilterChain(*a1, 0), (a1[1] = (uint64_t)result) != 0))
  {
    uint64_t v11 = result[11];
    if (result[18])
    {
      uint64_t v12 = result[24];
      v11 += result[15];
    }
    else
    {
      uint64_t v12 = result[16];
    }
    uint64_t v13 = v12 - v11 + result[14];
    CGPDFSourceSetPosition((uint64_t)result, v13 + a2, a3, a4, a5, a6, a7, a8);
    unint64_t v14 = (void *)a1[1];
    if (v14)
    {
      uint64_t v15 = v14[14];
      uint64_t v16 = v14[11];
      if (v14[18]) {
        uint64_t v17 = v14[24] - (v14[15] + v16);
      }
      else {
        uint64_t v17 = v14[16] - v16;
      }
      uint64_t v18 = v17 + v15;
    }
    else
    {
      uint64_t v18 = -1;
    }
    return (void *)(v18 - v13);
  }
  return result;
}

uint64_t chain_get_bytes(uint64_t *a1, uint64_t __dst, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  FilterChain = (unsigned char *)a1[1];
  if (!FilterChain)
  {
    FilterChain = CGPDFStreamCreateFilterChain(*a1, 0);
    a1[1] = (uint64_t)FilterChain;
    if (!FilterChain) {
      return 0;
    }
  }
  uint64_t v12 = CGPDFSourceRead((uint64_t)FilterChain, __dst, __n, a4, a5, a6, a7, a8);
  uint64_t v13 = a1[1];
  if (v13)
  {
    unint64_t v14 = *(unsigned int (**)(void))(v13 + 72);
    if (v14)
    {
      if (v14(*(void *)(v13 + 80))) {
        return 0;
      }
    }
  }
  return v12;
}

uint64_t CGPDFStreamGetData(uint64_t a1, uint64_t a2, size_t a3)
{
  int v14 = 0;
  uint64_t v5 = CGPDFStreamCreateFilterChain(a1, &v14);
  uint64_t v11 = v5;
  if (!v5 || v14)
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
    if (!v11) {
      return result;
    }
  }
  else
  {
    uint64_t v12 = CGPDFSourceRead((uint64_t)v5, a2, a3, v6, v7, v8, v9, v10);
  }
  CFRelease(v11);
  return v12;
}

uint64_t CGPDFStreamSetAssociation(uint64_t a1, const void *a2, const char *a3)
{
  return CGPDFDictionarySetAssociation(*(void *)(a1 + 48), a2, a3);
}

const void *CGPDFStreamCopyAssociation(uint64_t a1, const char *a2)
{
  return CGPDFDictionaryCopyAssociation(*(void *)(a1 + 48), a2);
}

uint64_t CGPDFStreamPrint(uint64_t a1, FILE *a2)
{
  return stream_print(a1, a2, 0, 0);
}

uint64_t stream_print(uint64_t result, FILE *a2, int a3, int a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v6 = result;
    int v16 = 0;
    if (a2) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (FILE *)*MEMORY[0x1E4F143C8];
    }
    CGPDFDictionaryPrintWithIndent(*(void *)(result + 48), v7, 0);
    fprintf(v7, "%*s\n", a3, "");
    fprintf(v7, "%*sstream\n", a3, "");
    if (a4)
    {
      uint64_t v8 = CGPDFStreamCreateFilterChain(v6, &v16);
      if (v8)
      {
        int v14 = v8;
        while (1)
        {
          size_t v15 = CGPDFSourceRead((uint64_t)v14, (uint64_t)__ptr, 0x400uLL, v9, v10, v11, v12, v13);
          if (!v15) {
            break;
          }
          fwrite(__ptr, 1uLL, v15, v7);
        }
        CFRelease(v14);
      }
    }
    else
    {
      fprintf(v7, "%*s...\n", a3, "");
    }
    return fprintf(v7, "%*sendstream\n", a3, "");
  }
  return result;
}

uint64_t CGPDFStreamPrintWithIndent(uint64_t a1, FILE *a2, int a3)
{
  return stream_print(a1, a2, a3, 0);
}

uint64_t CGPDFStreamPrintContents(uint64_t a1, FILE *a2)
{
  return stream_print(a1, a2, 0, 1);
}

uint64_t CGPDFStreamPrintContentsWithIndent(uint64_t a1, FILE *a2, int a3)
{
  return stream_print(a1, a2, a3, 1);
}

CFDataRef create_alpha_image(uint64_t a1)
{
  CFDataRef result = CGDataProviderCreateWithCopyOfData(*(void *)(a1 + 120), *(void *)(a1 + 136) * *(void *)(a1 + 16));
  if (result)
  {
    int v3 = result;
    if (*(void *)(a1 + 128) < 9uLL) {
      CGBitmapInfo v4 = 0;
    }
    else {
      CGBitmapInfo v4 = *(_DWORD *)(a1 + 40) & 0x7100;
    }
    DeviceGray = CGColorSpaceCreateDeviceGray();
    CGImageRef v6 = CGImageCreate(*(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 128), *(void *)(a1 + 128), *(void *)(a1 + 136), DeviceGray, v4, v3, 0, 1, kCGRenderingIntentDefault);
    CGColorSpaceRelease(DeviceGray);
    CGDataProviderRelease(v3);
    return v6;
  }
  return result;
}

void CGBitmapContextWriteImageToFile(CGContext *a1, char *a2)
{
  if (*((_DWORD *)a1 + 6) == 4)
  {
    CGImageRef Image = CGBitmapContextCreateImage(a1);
    CGImageWriteToFile(Image, a2);
    if (Image)
    {
      CFRelease(Image);
    }
  }
}

void CGBitmapContextDumpContentToFile(CGContext *a1, char *a2)
{
  CGImageRef Image = CGBitmapContextCreateImage(a1);
  CGImageDumpToFile((uint64_t)Image, a2);
  if (Image)
  {
    CFRelease(Image);
  }
}

void CGImageBlockRelease(void *a1)
{
  if (a1)
  {
    CFTypeRef v2 = (void (*)(void, void *))a1[9];
    if (v2) {
      v2(a1[7], a1);
    }
    free(a1);
  }
}

uint64_t CGImageBlockGetBitmapInfo(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 48);
  }
  return result;
}

uint64_t CGPDFGetUnicharGuessForGlyphName(const char *a1, _WORD *a2)
{
  if (!a1) {
    return 0;
  }
  if (!strcmp(a1, ".notdef")) {
    return 0;
  }
  CFStringRef v4 = CFStringCreateWithCString(0, a1, 0x600u);
  if (!v4) {
    return 0;
  }
  CFStringRef v5 = v4;
  if (get_name_table_predicate != -1) {
    dispatch_once(&get_name_table_predicate, &__block_literal_global_21909);
  }
  CFDictionaryRef v6 = (const __CFDictionary *)get_name_table_name_table;
  os_unfair_lock_lock(&CGPDFGetUnicharGuessForGlyphName_lock);
  unsigned int Value = CFDictionaryGetValue(v6, v5);
  if (!Value)
  {
    __endptr = 0;
    int v8 = *(unsigned __int8 *)a1;
    if ((v8 | 0x20) == 0x78)
    {
      uint64_t v9 = strtol(a1 + 1, &__endptr, 16);
      if (__endptr != a1 + 1 && !*__endptr)
      {
        uint64_t v10 = v9;
        if ((unint64_t)(v9 - 32) < 0x5F || (unint64_t)(v9 - 160) <= 0x5F) {
          goto LABEL_26;
        }
      }
      LOBYTE(v8) = *a1;
    }
    if ((v8 & 0x80) != 0)
    {
      if (!__maskrune_l((char)v8, 0x100uLL, 0))
      {
LABEL_22:
        unsigned int Value = 0;
        goto LABEL_23;
      }
    }
    else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v8 + 60) & 0x100) == 0)
    {
      goto LABEL_22;
    }
    uint64_t v12 = a1 + 1;
    uint64_t v13 = strtol(v12, &__endptr, 10);
    if (__endptr == v12) {
      goto LABEL_22;
    }
    if (*__endptr) {
      goto LABEL_22;
    }
    uint64_t v10 = v13;
    if ((unint64_t)(v13 - 32) >= 0x5F && (unint64_t)(v13 - 160) >= 0x60) {
      goto LABEL_22;
    }
LABEL_26:
    unsigned int Value = set_value(v6, v5, v10);
  }
LABEL_23:
  os_unfair_lock_unlock(&CGPDFGetUnicharGuessForGlyphName_lock);
  CFRelease(v5);

  return utf32_to_utf16(Value, a2);
}

const void *set_value(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFDataRef result = CFDictionaryGetValue(a1, a2);
  if (!result)
  {
    CFDictionarySetValue(a1, a2, (const void *)a3);
    return (const void *)a3;
  }
  return result;
}

uint64_t utf32_to_utf16(unsigned int a1, _WORD *a2)
{
  if (!a1) {
    return 0;
  }
  if (!HIWORD(a1))
  {
    if (a2) {
      *a2 = a1;
    }
    return 1;
  }
  if ((a1 - 0x10000) >> 20) {
    return 0;
  }
  if (a2)
  {
    *a2 = (a1 >> 10) - 10304;
    a2[1] = a1 & 0x3FF | 0xDC00;
  }
  return 2;
}

CFMutableDictionaryRef __get_name_table_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], 0);
  get_name_table_name_table = (uint64_t)result;
  return result;
}

uint64_t CGPDFGetUnicharGuessForCID(unsigned int a1, _WORD *a2)
{
  if (get_cid_table_predicate != -1) {
    dispatch_once(&get_cid_table_predicate, &__block_literal_global_4_21915);
  }
  CFDictionaryRef v4 = (const __CFDictionary *)get_cid_table_cid_table;
  os_unfair_lock_lock(&CGPDFGetUnicharGuessForCID_lock);
  unsigned int Value = CFDictionaryGetValue(v4, (const void *)a1);
  if (!Value)
  {
    uint64_t v6 = next_default_value_default_value;
    if (next_default_value_default_value == 1114109) {
      int v7 = 1113088;
    }
    else {
      int v7 = next_default_value_default_value + 1;
    }
    next_default_value_default_CGPDFArrayRef value = v7;
    unsigned int Value = set_value(v4, (const void *)a1, v6);
  }
  os_unfair_lock_unlock(&CGPDFGetUnicharGuessForCID_lock);

  return utf32_to_utf16(Value, a2);
}

CFMutableDictionaryRef __get_cid_table_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(0, 0, 0, 0);
  get_cid_table_cid_table = (uint64_t)result;
  return result;
}

uint64_t CGPDFCMapCreate(uint64_t a1)
{
  CGPDFObjectRef value = (CGPDFObjectRef)a1;
  if (CGPDFCMapGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFCMapGetTypeID_onceToken, &__block_literal_global_21920);
  }
  uint64_t cftype = pdf_create_cftype();
  if (cftype)
  {
    CGPDFDataFormat format = CGPDFDataFormatRaw;
    if (a1)
    {
      int v3 = *(_DWORD *)(a1 + 8);
      if (v3 == 9)
      {
        int v7 = *(CGPDFStream **)(a1 + 32);
        if (v7) {
          int v8 = (CGPDFDictionary *)*((void *)v7 + 6);
        }
        else {
          int v8 = 0;
        }
        if (CGPDFDictionaryGetObject(v8, "UseCMap", &value))
        {
          pdf_error("embedded CMap files with /UseCMap entries aren't handled yet.");
        }
        else
        {
          CFDataRef v9 = CGPDFStreamCopyData(v7, &format);
          if (v9 && format == CGPDFDataFormatRaw)
          {
            uint64_t v10 = cmap_vtable;
            if ((cmap_vtable || (pthread_once(&load_vtable_once, do_load_vtable), (uint64_t v10 = cmap_vtable) != 0))
              && (uint64_t v11 = *(uint64_t (**)(CFDataRef))(v10 + 8)) != 0)
            {
              uint64_t v12 = v11(v9);
              *(void *)(cftype + 16) = v12;
              if (v12)
              {
                CFRelease(v9);
                goto LABEL_8;
              }
            }
            else
            {
              *(void *)(cftype + 16) = 0;
            }
            pdf_error("failed to parse embedded CMap.");
            CFRelease((CFTypeRef)cftype);
            CFStringRef v5 = v9;
LABEL_11:
            CFRelease(v5);
            return 0;
          }
          pdf_error("invalid embedded CMap stream.");
          if (v9) {
            CFRelease(v9);
          }
        }
LABEL_10:
        CFStringRef v5 = (const void *)cftype;
        goto LABEL_11;
      }
      if (v3 == 5)
      {
        uint64_t v4 = cg_cmap_create_with_name(*(void *)(a1 + 32));
        *(void *)(cftype + 16) = v4;
        if (v4)
        {
LABEL_8:
          *(_DWORD *)(cftype + 32) = 0;
          return cftype;
        }
        goto LABEL_10;
      }
    }
    pdf_error("invalid CMap: not a name or stream.");
    goto LABEL_10;
  }
  return cftype;
}

uint64_t __CGPDFCMapGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFCMapGetTypeID_class);
  CGPDFCMapGetTypeID_id = result;
  return result;
}

void CGPDFCMapFinalize(uint64_t a1)
{
  if (cmap_vtable)
  {
    CFTypeRef v2 = *(void (**)(void))(cmap_vtable + 16);
    if (v2) {
      v2(*(void *)(a1 + 16));
    }
  }
  int v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
  }
}

void CGPDFCMapRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGPDFCMapCreateWithName(uint64_t a1)
{
  if (CGPDFCMapGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFCMapGetTypeID_onceToken, &__block_literal_global_21920);
  }
  uint64_t cftype = pdf_create_cftype();
  if (cftype)
  {
    uint64_t v3 = cg_cmap_create_with_name(a1);
    *(void *)(cftype + 16) = v3;
    if (v3)
    {
      *(_DWORD *)(cftype + 32) = 0;
    }
    else
    {
      CFRelease((CFTypeRef)cftype);
      return 0;
    }
  }
  return cftype;
}

CFTypeRef CGPDFCMapRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t CGPDFCMapGetName(uint64_t a1)
{
  if (a1 && cmap_vtable && (uint64_t v1 = *(uint64_t (**)(void))(cmap_vtable + 24)) != 0) {
    return v1(*(void *)(a1 + 16));
  }
  else {
    return 0;
  }
}

uint64_t CGPDFCMapGetROS(uint64_t a1)
{
  if (a1 && cmap_vtable && (uint64_t v1 = *(uint64_t (**)(void))(cmap_vtable + 32)) != 0) {
    return v1(*(void *)(a1 + 16));
  }
  else {
    return 0;
  }
}

BOOL CGPDFCMapIsHorizontal(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (cmap_vtable)
  {
    uint64_t v1 = *(unsigned int (**)(void))(cmap_vtable + 40);
    if (v1) {
      return v1(*(void *)(a1 + 16)) == 0;
    }
  }
  return 1;
}

uint64_t CGPDFCMapGetCIDsForText(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, __n128 a6)
{
  uint64_t v6 = 0;
  v22[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v7 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        MEMORY[0x1F4188790](a1, a6);
        int v14 = (char *)v22 - v13;
        if (v12 <= 0x1FFFFFFFFFFFFFFELL) {
          size_t v15 = (char *)v22 - v13;
        }
        else {
          size_t v15 = 0;
        }
        if (v12 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000066) {
          size_t v15 = (char *)malloc_type_malloc(8 * a3, 0xB02DCE6uLL);
        }
        if (v15)
        {
          if (cmap_vtable
            && (int v16 = *(uint64_t (**)(void, unsigned char *, uint64_t, uint64_t, char *))(cmap_vtable + 48)) != 0)
          {
            uint64_t v17 = v16(*(void *)(a1 + 16), v7, a3, a4, v15);
            uint64_t v6 = v17;
            if (a5 && v17)
            {
              for (uint64_t i = 0; i != v17; ++i)
              {
                uint64_t v19 = *(void *)&v15[8 * i];
                BOOL v20 = v19 == 1 && *v7 == 32;
                *(unsigned char *)(a5 + i) = v20;
                v7 += v19;
              }
            }
          }
          else
          {
            uint64_t v6 = 0;
          }
          if (v15 != v14) {
            free(v15);
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v6;
}

char *CGPDFCMapGetUnicodeCMap(uint64_t a1)
{
  uint64_t result = *(char **)(a1 + 24);
  if (!result)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
    if (*(void *)(a1 + 24))
    {
LABEL_3:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
      return *(char **)(a1 + 24);
    }
    if (cmap_vtable && (uint64_t v3 = *(uint64_t (**)(void))(cmap_vtable + 32)) != 0)
    {
      uint64_t result = (char *)v3(*(void *)(a1 + 16));
      if (result)
      {
        uint64_t v4 = result;
        uint64_t result = strrchr(result, 45);
        if (result)
        {
          int64_t v5 = result - v4;
          uint64_t result = (char *)malloc_type_malloc(result - v4 + 6, 0x44A537B1uLL);
          if (result)
          {
            uint64_t v6 = result;
            size_t v7 = v5 + 1;
            int v8 = strncpy(result, v4, v7);
            strcpy(&v8[v7], "UCS2");
            *(void *)(a1 + 24) = CGPDFCMapCreateWithName((uint64_t)v8);
            free(v6);
            goto LABEL_3;
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFCMapGetMaxUnicodes(uint64_t a1)
{
  if (a1 && cmap_vtable && (uint64_t v1 = *(uint64_t (**)(void))(cmap_vtable + 56)) != 0) {
    return v1(*(void *)(a1 + 16));
  }
  else {
    return 0;
  }
}

uint64_t CGPDFCMapGetUnicodesForIndex(uint64_t a1, unint64_t a2)
{
  if (a1 && !(a2 >> 16) && cmap_vtable && (CFTypeRef v2 = *(uint64_t (**)(void, void))(cmap_vtable + 64)) != 0) {
    return v2(*(void *)(a1 + 16), (unsigned __int16)a2);
  }
  else {
    return 0;
  }
}

uint64_t CGPDFCMapGetIndexForUnicodes(uint64_t a1)
{
  if (a1 && cmap_vtable && (uint64_t v1 = *(uint64_t (**)(void))(cmap_vtable + 72)) != 0) {
    return v1(*(void *)(a1 + 16));
  }
  else {
    return 0;
  }
}

uint64_t CGPDFCMapGetZapfTable(uint64_t a1)
{
  if (a1 && cmap_vtable && (uint64_t v1 = *(uint64_t (**)(void))(cmap_vtable + 80)) != 0) {
    return v1(*(void *)(a1 + 16));
  }
  else {
    return 0;
  }
}

uint64_t CGFontGetFontSubsetFormat(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 336))(*(void *)(result + 112));
  }
  return result;
}

uint64_t CGFontCreateFontSubset(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 344))(*(void *)(result + 112));
  }
  return result;
}

BOOL CGFontCanCreatePostScriptSubset(CGFontRef font, CGFontPostScriptFormat format)
{
  if (font) {
    LOBYTE(font) = (*(uint64_t (**)(void, void))(*((void *)font + 2) + 368))(*((void *)font + 14), *(void *)&format);
  }
  return (char)font;
}

CFDataRef CGFontCreatePostScriptSubset(CGFontRef font, CFStringRef subsetName, CGFontPostScriptFormat format, const CGGlyph *glyphs, size_t count, const CGGlyph *encoding)
{
  if (font && subsetName && (glyphs || !count)) {
    return (CFDataRef)(*(uint64_t (**)(void))(*((void *)font + 2) + 352))(*((void *)font + 14));
  }
  else {
    return 0;
  }
}

CFDataRef CGFontCreatePostScriptEncoding(CFDataRef font, const CGGlyph *encoding)
{
  if (font) {
    return (CFDataRef)(*(uint64_t (**)(void, const CGGlyph *))(*((void *)font + 2) + 360))(*((void *)font + 14), encoding);
  }
  return font;
}

BOOL CheckParagraphUnilined(void *a1)
{
  return ((int)[a1 leftOrder] < 1
       || objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "paragraphsLeft"), "objectAtIndex:", 0), "count") <= 1)&& ((int)objc_msgSend(a1, "rightOrder") < 1|| objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "paragraphsRight"), "objectAtIndex:", 0), "count") <= 1);
}

CGColorSpaceRef image_can_be_converted_to_indexed(uint64_t a1)
{
  unint64_t Size = CGImageGetSize((void *)a1);
  if (Size * v3 < 0x3E8) {
    return 0;
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
  if (CGColorSpaceGetType(ColorSpace) == 7 || CGColorSpaceGetType(ColorSpace) == 9) {
    return 0;
  }
  BOOL v6 = CGImageGetAlphaInfo((CGImageRef)a1) == kCGImageAlphaPremultipliedLast
    || CGImageGetAlphaInfo((CGImageRef)a1) == kCGImageAlphaPremultipliedFirst;
  if (CGImageGetAlphaInfo((CGImageRef)a1))
  {
    if (!ColorSpace) {
      return 0;
    }
    BOOL v7 = *(void *)(*((void *)ColorSpace + 3) + 48) != 1;
  }
  else
  {
    BOOL v7 = 0;
  }
  CGColorSpaceRef result = 0;
  if (!v6 && !v7)
  {
    CGColorSpaceRef result = CGImageGetColorSpace((CGImageRef)a1);
    if (result)
    {
      if (*(void *)(*((void *)result + 3) + 48) == 1 && CGImageGetDecodeType((CGImage *)a1) != 2)
      {
        if (!a1) {
          return (CGColorSpaceRef)1;
        }
        int v8 = *(_DWORD *)(a1 + 36);
        if ((v8 & 0x2000000) == 0) {
          return (CGColorSpaceRef)((v8 & 0x8000000) == 0);
        }
      }
      return 0;
    }
  }
  return result;
}

CGImageRef copy_image_with_color_space_and_one_component(CGImage *image, CGColorSpace *a2, size_t a3)
{
  if (image)
  {
    size_t v6 = *((void *)image + 5);
    size_t v5 = *((void *)image + 6);
    size_t v7 = *((void *)image + 9);
  }
  else
  {
    size_t v5 = 0;
    size_t v6 = 0;
    size_t v7 = 0;
  }
  CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(image);
  DataProviderInternal = CGImageGetDataProviderInternal((char *)image, 0);
  CGImageGetDecode(image);
  BOOL shouldInterpolate = CGImageGetShouldInterpolate(image);
  CGColorRenderingIntent intent = CGImageGetRenderingIntent(image);
  unsigned int DecodeType = CGImageGetDecodeType(image);
  if (DecodeType >= 2) {
    _CGHandleAssert("copy_image_with_color_space_and_one_component", 72, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "decode_type == kCGDecodeDefault || decode_type == kCGDecodeInvert", "decode variety (%d) not supported", v13, v14, v15, 2);
  }
  if (DecodeType)
  {
    if (!image) {
      return 0;
    }
    unint64_t v16 = *((void *)image + 8) - 1;
    if (v16 >= 8 || ((0xADu >> v16) & 1) == 0) {
      return 0;
    }
    decode = (const CGFloat *)*(&off_1E52CE7A8 + v16);
  }
  else
  {
    decode = 0;
  }
  return CGImageCreate(v6, v5, a3, a3, v7, a2, BitmapInfo, (CGDataProviderRef)DataProviderInternal, decode, shouldInterpolate, intent);
}

CGImageRef CGImageCreate8BitIndexed(CGImage *a1)
{
  if (!image_can_be_converted_to_indexed((uint64_t)a1)) {
    return 0;
  }
  if (!a1)
  {
    LOBYTE(v5) = 0;
LABEL_9:
    _CGHandleAssert("CGImageCreate8BitIndexed", 432, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGImageGetBitsPerComponent(image) == 8", "bpc %lu", v2, v3, v4, v5);
  }
  uint64_t v5 = *((void *)a1 + 7);
  if (v5 != 8) {
    goto LABEL_9;
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  if (!ColorSpace || *(void *)(*((void *)ColorSpace + 3) + 48) != 1)
  {
    CGColorSpaceRef v11 = CGImageGetColorSpace(a1);
    if (v11) {
      uint64_t v15 = *(void *)(*((void *)v11 + 3) + 48);
    }
    else {
      LOBYTE(v15) = 0;
    }
    _CGHandleAssert("CGImageCreate8BitIndexed", 433, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 1", "color components %lu", v12, v13, v14, v15);
  }
  size_t v7 = CGImageGetColorSpace(a1);
  Indexed = CGColorSpaceCreateIndexed(v7, 0xFFuLL, CGImageCreate8BitIndexed_index_table);
  CGImageRef v9 = copy_image_with_color_space_and_one_component(a1, Indexed, 8uLL);
  CGColorSpaceRelease(Indexed);
  return v9;
}

void *CGPDFDrawingContextDrawText(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)result;
    CGPDFGStateSynchronizeContextForText(result[4], (CGContextRef)result[11]);
    CGColorSpaceRef result = *(void **)(a2 + 168);
    if (result)
    {
      return CGPDFTextLayoutDrawGlyphs(result, (void (*)(uint64_t, uint64_t, long long *, uint64_t, uint64_t, char *, char *, void, uint64_t))draw_glyphs_22097, v3, v4);
    }
  }
  return result;
}

void draw_glyphs_22097(CGPDFContentStreamRef *a1, uint64_t a2, float64x2_t *a3, const CGPoint *a4, uint64_t a5, const CGGlyph *a6, uint64_t a7, unsigned __int8 *a8, size_t a9)
{
  size_t v15 = a9;
  if (a2 && *(_DWORD *)(a2 + 200) == 5)
  {
    float64x2_t v16 = a3[1];
    *(float64x2_t *)&v48.a = *a3;
    *(float64x2_t *)&v48.c = v16;
    *(float64x2_t *)&v48.tx = a3[2];
    Procedures = CGPDFFontGetProcedures(a2);
    if (!Procedures) {
      return;
    }
    uint64_t v18 = Procedures;
    CGPDFDictionaryRef value = 0;
    if (!CGPDFDictionaryGetDictionary(*(CGPDFDictionaryRef *)(a2 + 16), "Resources", &value)) {
      CGPDFDictionaryRef value = 0;
    }
    uint64_t v19 = a1[11];
    CGContextSaveGState(v19);
    CGContextSetInterpolationQuality(v19, kCGInterpolationHigh);
    CGAffineTransform transform = v48;
    CGContextConcatCTM(v19, &transform);
    if (a9)
    {
      BOOL v20 = (_OWORD *)(a2 + 56);
      p_y = &a4->y;
      do
      {
        int v22 = *a8++;
        uint64_t v23 = (CGPDFStream *)v18[v22];
        if (v23)
        {
          CGContextSaveGState(v19);
          CGContextTranslateCTM(v19, *(p_y - 1), *p_y);
          long long v24 = v20[1];
          *(_OWORD *)&transform.a = *v20;
          *(_OWORD *)&transform.c = v24;
          *(_OWORD *)&transform.tx = v20[2];
          CGContextConcatCTM(v19, &transform);
          CGPDFDrawingContextDrawGlyphStream(a1, v23, value, (uint64_t)v19);
          CGContextRestoreGState(v19);
        }
        p_y += 2;
        --v15;
      }
      while (v15);
    }
    CGPDFObjectRef v25 = v19;
LABEL_20:
    CGContextRestoreGState(v25);
    return;
  }
  if (CGPDFFontGetMutator(a2))
  {
    if (!a9) {
      return;
    }
    float64x2_t v45 = a3[1];
    float64x2_t v46 = *a3;
    float64x2_t v43 = a3[2];
    *(_OWORD *)font = 0u;
    memset(&transform, 0, sizeof(transform));
    CGPDFInteger v26 = a1[11];
    CGContextSaveGState(v26);
    uint64_t Mutator = CGPDFFontGetMutator(a2);
    uint64_t v28 = &a4->y;
    do
    {
      float64x2_t v44 = vmlaq_n_f64(vmlaq_n_f64(v43, v46, *(v28 - 1)), v45, *v28);
      unsigned int v29 = *a8++;
      CGPDFFontMutatorGetMutation(Mutator, v29, (uint64_t)&transform);
      CGContextSetFont(v26, font[1]);
      if (BYTE2(transform.a))
      {
        float64x2_t v31 = v45;
        float64x2_t v30 = v46;
        float64x2_t v32 = v44;
      }
      else
      {
        float64x2_t v30 = vmlaq_n_f64(vmulq_n_f64(v45, transform.c), v46, transform.b);
        float64x2_t v31 = vmlaq_n_f64(vmulq_n_f64(v45, transform.tx), v46, transform.d);
        float64x2_t v32 = vaddq_f64(v44, vmlaq_n_f64(vmulq_n_f64(v45, *(double *)font), v46, transform.ty));
      }
      *(float64x2_t *)&v48.a = v30;
      *(float64x2_t *)&v48.c = v31;
      *(float64x2_t *)&v48.tx = v32;
      CGContextSetTextMatrix(v26, &v48);
      CGContextShowGlyphsAtPositions(v26, (const CGGlyph *)&transform, &CGPointZero, 1uLL);
      v28 += 2;
      --v15;
    }
    while (v15);
    CGPDFObjectRef v25 = v26;
    goto LABEL_20;
  }
  float64x2_t v33 = a3[1];
  *(float64x2_t *)&v48.a = *a3;
  *(float64x2_t *)&v48.c = v33;
  *(float64x2_t *)&v48.tx = a3[2];
  if (a9)
  {
    uint64_t v34 = a1[11];
    uint64_t v35 = (CGFont *)CGPDFFontGetFont(a2);
    CGContextSetFont(v34, v35);
    uint64_t v36 = a1[11];
    CGAffineTransform transform = v48;
    CGContextSetTextMatrix(v36, &transform);
    if (CGPDFFontIsEmbedded(a2))
    {
      uint64_t v37 = a1[11];
      uint64_t v38 = a6;
      uint64_t v39 = a4;
      size_t v40 = a9;
    }
    else
    {
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      do
      {
        if (a6[v42])
        {
          ++v42;
        }
        else
        {
          CGContextShowGlyphsAtPositions(a1[11], &a6[v41], &a4[v41], v42 - v41);
          uint64_t v41 = ++v42;
        }
      }
      while (v42 != a9);
      uint64_t v37 = a1[11];
      uint64_t v38 = &a6[v41];
      size_t v40 = a9 - v41;
      uint64_t v39 = &a4[v41];
    }
    CGContextShowGlyphsAtPositions(v37, v38, v39, v40);
  }
}

void clip_to_glyphs_22101(uint64_t a1, uint64_t a2, float64x2_t *a3, uint64_t a4, uint64_t a5, __int16 *a6, uint64_t a7, unsigned __int8 *a8, uint64_t a9)
{
  if (!a2 || *(_DWORD *)(a2 + 200) != 5)
  {
    uint64_t v15 = a9;
    long long v30 = 0u;
    memset(&v31, 0, sizeof(v31));
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t Mutator = CGPDFFontGetMutator(a2);
    if (Mutator)
    {
      if (a9)
      {
        uint64_t v17 = Mutator;
        uint64_t v18 = (double *)(a4 + 8);
        do
        {
          unsigned int v19 = *a8++;
          CGPDFFontMutatorGetMutation(v17, v19, (uint64_t)&v27);
          float64x2_t v20 = *a3;
          float64x2_t v21 = a3[1];
          float64x2_t v22 = vmlaq_n_f64(vmlaq_n_f64(a3[2], *a3, *(v18 - 1)), v21, *v18);
          *(float64x2_t *)&v31.a = *a3;
          *(float64x2_t *)&v31.c = v21;
          *(float64x2_t *)&v31.tx = v22;
          if (!BYTE2(v27))
          {
            *(float64x2_t *)&v31.a = vmlaq_n_f64(vmulq_n_f64(v21, *(double *)&v28), v20, *((double *)&v27 + 1));
            *(float64x2_t *)&v31.c = vmlaq_n_f64(vmulq_n_f64(v21, *(double *)&v29), v20, *((double *)&v28 + 1));
            *(float64x2_t *)&v31.tx = vaddq_f64(v22, vmlaq_n_f64(vmulq_n_f64(v21, *(double *)&v30), v20, *((double *)&v29 + 1)));
          }
          CGTextClippingAppendGlyphs(a1, *((const void **)&v30 + 1), &v31, (__int16 *)&v27, (long long *)&CGPointZero, 1);
          v18 += 2;
          --v15;
        }
        while (v15);
      }
    }
    else if (a9)
    {
      uint64_t v23 = (double *)(a4 + 8);
      do
      {
        float64x2_t v24 = a3[1];
        float64x2_t v25 = vmlaq_n_f64(vmlaq_n_f64(a3[2], *a3, *(v23 - 1)), v24, *v23);
        *(float64x2_t *)&v31.a = *a3;
        *(float64x2_t *)&v31.c = v24;
        *(float64x2_t *)&v31.tx = v25;
        Font = (const void *)CGPDFFontGetFont(a2);
        CGTextClippingAppendGlyphs(a1, Font, &v31, a6++, (long long *)&CGPointZero, 1);
        v23 += 2;
        --v15;
      }
      while (v15);
    }
  }
}

void *PDFOutputIntentCreate(uint64_t a1, const void *a2)
{
  uint64_t v2 = 0;
  if (!a1) {
    return v2;
  }
  if (!a2) {
    return v2;
  }
  uint64_t v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (!v2) {
    return v2;
  }
  *uint64_t v2 = a1;
  v2[1] = CFRetain(a2);
  *((unsigned char *)v2 + 24) = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  v2[2] = Mutable;
  if (!Mutable) {
    goto LABEL_20;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a2, @"kCGPDFContextOutputIntents");
  if (!Value || (CFArrayRef v7 = Value, v8 = CFGetTypeID(Value), v8 != CFArrayGetTypeID()))
  {
    uint64_t v13 = CFDictionaryGetValue((CFDictionaryRef)a2, @"kCGPDFContextOutputIntent");
    if (is_valid_output_intent((const __CFDictionary *)v13, 0))
    {
      CFArrayAppendValue((CFMutableArrayRef)v2[2], v13);
      goto LABEL_16;
    }
LABEL_20:
    PDFOutputIntentRelease(v2);
    return 0;
  }
  CFIndex Count = CFArrayGetCount(v7);
  if (Count)
  {
    CFIndex v10 = Count;
    for (CFIndex i = 0; i != v10; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
      if (is_valid_output_intent((const __CFDictionary *)ValueAtIndex, i))
      {
        CFArrayAppendValue((CFMutableArrayRef)v2[2], ValueAtIndex);
      }
      else if (!i)
      {
        goto LABEL_20;
      }
    }
  }
LABEL_16:
  if (!CFArrayGetCount((CFArrayRef)v2[2])) {
    goto LABEL_20;
  }
  uint64_t v14 = CFDictionaryGetValue((CFDictionaryRef)a2, @"GTS_PDFXVersion");
  if (v14 && CFEqual(v14, @"PDF/X-3:2002")) {
    *((unsigned char *)v2 + 24) = 1;
  }
  return v2;
}

void PDFOutputIntentRelease(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[1];
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = (const void *)a1[2];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

CFDictionaryRef is_valid_output_intent(const __CFDictionary *result, uint64_t a2)
{
  if (result)
  {
    CFDictionaryRef v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 != CFDictionaryGetTypeID()) {
      return 0;
    }
    CGColorSpaceRef result = (const __CFDictionary *)CFDictionaryGetValue(v3, @"S");
    if (!result) {
      return result;
    }
    CFDictionaryRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    if (v6 != CFStringGetTypeID()) {
      return 0;
    }
    int v7 = CFEqual(v5, @"GTS_PDFX");
    if (a2)
    {
      if (!v7)
      {
LABEL_12:
        CGColorSpaceRef result = (const __CFDictionary *)CFDictionaryGetValue(v3, @"OutputConditionIdentifier");
        if (result)
        {
          CFTypeID v8 = CFGetTypeID(result);
          return (const __CFDictionary *)(v8 == CFStringGetTypeID());
        }
        return result;
      }
    }
    else if (v7)
    {
      goto LABEL_12;
    }
    CGColorSpaceRef result = (const __CFDictionary *)CFEqual(v5, @"GTS_PDFA1");
    if (!result) {
      return result;
    }
    goto LABEL_12;
  }
  return result;
}

unsigned char *PDFOutputIntentGetIsX3(unsigned char *result)
{
  if (result)
  {
    if (result[24] && (int v1 = *(_DWORD *)(*(void *)result + 4), v1 <= 1)) {
      return (unsigned char *)(v1 != 1 || *(_DWORD *)(*(void *)result + 8) < 4);
    }
    else {
      return 0;
    }
  }
  return result;
}

const void *get_string(const __CFDictionary *a1, const void *a2)
{
  CGColorSpaceRef result = CFDictionaryGetValue(a1, a2);
  if (result)
  {
    CFDictionaryRef v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFStringGetTypeID()) {
      return v3;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t evaluate_range(uint64_t result, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v6 = result;
  int v7 = (double *)(a3[3] + 16 * a2);
  double v8 = *v7;
  double v9 = v7[1] - *v7;
  unint64_t v10 = *a3;
  double v11 = v9 / (double)(*a3 - 1);
  if (a2)
  {
    if (v10)
    {
      unint64_t v13 = 0;
      uint64_t v14 = a2 - 1;
      do
      {
        *(double *)(a3[6] + 8 * a2) = v8 + (double)v13 * v11;
        CGColorSpaceRef result = evaluate_range(v6, v14, a3, a4);
        ++v13;
      }
      while (v13 < *a3);
    }
  }
  else if (v10)
  {
    unint64_t v15 = 0;
    float64x2_t v16 = (double *)(a4 + 8);
    do
    {
      uint64_t v17 = (char *)a3[6];
      uint64_t v18 = (double *)a3[7];
      *(double *)uint64_t v17 = v8 + (double)v15 * v11;
      CGColorSpaceRef result = CGFunctionEvaluate(*(void *)(v6 + 16), v17, v18);
      unint64_t v19 = a3[4];
      if (v19)
      {
        float64x2_t v20 = (double *)a3[7];
        float64x2_t v21 = v16;
        do
        {
          double v22 = *v20;
          if (*v20 < *(v21 - 1))
          {
            *(v21 - 1) = v22;
            double v22 = *v20;
          }
          if (v22 > *v21) {
            double *v21 = v22;
          }
          v21 += 2;
          ++v20;
          --v19;
        }
        while (v19);
      }
      ++v15;
    }
    while (v15 < *a3);
  }
  return result;
}

void emit_samples(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  int v7 = (double *)(a4[3] + 16 * a3);
  double v8 = *v7;
  double v9 = (v7[1] - *v7) / (double)(*a4 - 1);
  if (a3)
  {
    if (*a4)
    {
      unint64_t v11 = 0;
      uint64_t v12 = a3 - 1;
      do
      {
        *(double *)(a4[6] + 8 * a3) = v8 + (double)v11 * v9;
        emit_samples(a1, a2, v12, a4);
        ++v11;
      }
      while (v11 < *a4);
    }
  }
  else
  {
    unint64_t v13 = a4[5];
    uint64_t v14 = (char *)malloc_type_malloc(a4[4], 0x100004077774924uLL);
    if (*a4)
    {
      unint64_t v15 = 0;
      float64x2_t v21 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
      do
      {
        float64x2_t v16 = (char *)a4[6];
        uint64_t v17 = (double *)a4[7];
        *(double *)float64x2_t v16 = v8 + (double)v15 * v9;
        CGFunctionEvaluate(a1[2], v16, v17);
        unint64_t v18 = a1[4];
        unint64_t v19 = a1[5];
        if (v18 <= v19)
        {
          do
          {
            float64x2_t v20 = (float64x2_t)vbslq_s8((int8x16_t)vceqq_f64(vabsq_f64(*(float64x2_t *)(v13 + 16 * v18)), v21), (int8x16_t)xmmword_1850CE050, *(int8x16_t *)(v13 + 16 * v18));
            v14[v18 - a1[4]] = (int)((*(double *)(a4[7] + 8 * v18) - v20.f64[0])
                                   / vsubq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v20, 1), v20).f64[0]
                                   * 255.0
                                   + 0.5);
            ++v18;
            unint64_t v19 = a1[5];
          }
          while (v18 <= v19);
          unint64_t v18 = a1[4];
        }
        CGDataConsumerPutBytes(*(void *)(a2 + 24), (uint64_t)v14, v19 - v18 + 1);
        ++v15;
      }
      while (v15 < *a4);
    }
    free(v14);
  }
}

uint64_t CIF10_sample_CIF10_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v90 = *(void *)(result + 80);
  uint64_t v92 = *(void *)(result + 88);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 8;
  uint64_t v12 = *(void *)(result + 144) - 1;
  if (v5) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = 0xFF00000000;
  }
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  float64x2_t v16 = (unsigned __int8 *)(v5 + (v15 - 1) + (v14 * v7));
  int v89 = *(_DWORD *)(result + 188);
  unint64_t v17 = v4 + (v14 * v6) + 4 * v15 - 8;
  uint64_t v91 = *(void *)(result + 64);
  uint64_t v93 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v93)
      {
        if (a3 <= v92)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
          uint64_t v29 = v91;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v92;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_43;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          uint64_t v29 = v91;
          unsigned int v27 = v89 | v25;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v93 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_43;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v29 = v91;
        unsigned int v27 = v89 | v21;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v29) {
        break;
      }
      uint64_t v30 = *(void *)(result + 192);
      uint64_t v31 = v29 - *(void *)(result + 200);
      uint64_t v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v89;
        }
        uint64_t v33 = v31 + 0x1000000;
        uint64_t v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 8;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v90)
    {
      uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v33 = a2;
      goto LABEL_29;
    }
    uint64_t v35 = *(void *)(result + 192);
    uint64_t v36 = *(void *)(result + 200) + v90;
    uint64_t v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1) {
      goto LABEL_43;
    }
    if (v37 < v35) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v89;
    }
    uint64_t v33 = v36 - 0x1000000;
    uint64_t v34 = 28;
LABEL_29:
    if (v27 < 0x400000) {
      goto LABEL_43;
    }
    uint64_t v38 = v28 >> 32;
    uint64_t v39 = v33 >> 32;
    uint64_t v40 = v4 + (int)v38 * (uint64_t)v6;
    unint64_t v41 = v40 + 4 * v39;
    uint64_t v42 = *(unsigned int **)(result + 32);
    if (v17 >= v41) {
      float64x2_t v43 = (unsigned int *)(v40 + 4 * v39);
    }
    else {
      float64x2_t v43 = (unsigned int *)v17;
    }
    if (v43 < v42) {
      float64x2_t v43 = *(unsigned int **)(result + 32);
    }
    unint64_t v44 = *v43;
    if (v5)
    {
      unint64_t v45 = v5 + (int)v38 * (uint64_t)v7 + v39;
      float64x2_t v46 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v45) {
        uint64_t v47 = (unsigned __int8 *)v45;
      }
      else {
        uint64_t v47 = v16;
      }
      if (v47 >= v46) {
        float64x2_t v46 = v47;
      }
      v44 |= (unint64_t)*v46 << 32;
      if (!v8) {
        goto LABEL_104;
      }
    }
    else
    {
      unint64_t v45 = 0;
      if (!v8) {
        goto LABEL_104;
      }
    }
    unsigned int v48 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    int v49 = v48 & 0xF;
    int v50 = HIBYTE(v48) & 3;
    switch(v49)
    {
      case 1:
        uint64_t v70 = (unsigned int *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 < (unint64_t)v70) {
          uint64_t v70 = (unsigned int *)v17;
        }
        if (v70 < v42) {
          uint64_t v70 = v42;
        }
        unint64_t v71 = *v70;
        if (v5)
        {
          uint64_t v72 = (unsigned __int8 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          if (v16 < v72) {
            uint64_t v72 = v16;
          }
          if ((unint64_t)v72 < *(void *)(result + 40)) {
            uint64_t v72 = *(unsigned __int8 **)(result + 40);
          }
          v71 |= (unint64_t)*v72 << 32;
        }
        uint64_t v73 = interpolate_cif10a[v50];
        char v74 = v50 + 1;
        unint64_t v68 = v44 - ((v73 & v44) >> v74);
        unint64_t v75 = (v73 & v71) >> v74;
        goto LABEL_103;
      case 2:
        long long v76 = (unsigned int *)(v41 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 54));
        if (v17 < (unint64_t)v76) {
          long long v76 = (unsigned int *)v17;
        }
        if (v76 < v42) {
          long long v76 = v42;
        }
        uint64_t v77 = *v76;
        if (v5)
        {
          uint64_t v78 = (unsigned __int8 *)(v45 + SBYTE2(v48));
          if (v16 < v78) {
            uint64_t v78 = v16;
          }
          if ((unint64_t)v78 < *(void *)(result + 40)) {
            uint64_t v78 = *(unsigned __int8 **)(result + 40);
          }
          v77 |= (unint64_t)*v78 << 32;
        }
        int v79 = (v48 >> 28) & 3;
        uint64_t v80 = interpolate_cif10a[v79];
        char v67 = v79 + 1;
        unint64_t v68 = v44 - ((v80 & v44) >> v67);
        unint64_t v69 = v80 & v77;
        goto LABEL_102;
      case 3:
        int64_t v51 = (unint64_t)HIWORD(v48) << 56;
        uint64_t v52 = (unsigned int *)(v41 + (v51 >> 54));
        if (v17 < (unint64_t)v52) {
          uint64_t v52 = (unsigned int *)v17;
        }
        if (v52 < v42) {
          uint64_t v52 = v42;
        }
        unint64_t v53 = *v52;
        unint64_t v54 = v41 + SBYTE1(v48) * (uint64_t)v6;
        if (v17 >= v54) {
          CFIndex v55 = (unsigned int *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        }
        else {
          CFIndex v55 = (unsigned int *)v17;
        }
        if (v55 < v42) {
          CFIndex v55 = v42;
        }
        unint64_t v88 = *v55;
        int v56 = (unsigned int *)(v54 + (v51 >> 54));
        if (v17 < (unint64_t)v56) {
          int v56 = (unsigned int *)v17;
        }
        if (v56 < v42) {
          int v56 = v42;
        }
        unint64_t v57 = *v56;
        if (v5)
        {
          uint64_t v58 = (unsigned __int8 *)(v45 + SBYTE2(v48));
          unint64_t v59 = *(void *)(result + 40);
          if (v16 < v58) {
            uint64_t v58 = v16;
          }
          if ((unint64_t)v58 < v59) {
            uint64_t v58 = *(unsigned __int8 **)(result + 40);
          }
          v53 |= (unint64_t)*v58 << 32;
          unint64_t v60 = v45 + SBYTE1(v48) * (uint64_t)v7;
          if ((unint64_t)v16 >= v60) {
            uint64_t v61 = (unsigned __int8 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          }
          else {
            uint64_t v61 = v16;
          }
          if ((unint64_t)v61 < v59) {
            uint64_t v61 = *(unsigned __int8 **)(result + 40);
          }
          v88 |= (unint64_t)*v61 << 32;
          uint64_t v62 = (unsigned __int8 *)(v60 + SBYTE2(v48));
          if (v16 < v62) {
            uint64_t v62 = v16;
          }
          if ((unint64_t)v62 < v59) {
            uint64_t v62 = *(unsigned __int8 **)(result + 40);
          }
          v57 |= (unint64_t)*v62 << 32;
        }
        uint64_t v63 = interpolate_cif10a[v50];
        unint64_t v64 = v44 - ((v63 & v44) >> (v50 + 1)) + ((v63 & v88) >> (v50 + 1));
        unint64_t v65 = v53 - ((v63 & v53) >> (v50 + 1)) + ((v63 & v57) >> (v50 + 1));
        LODWORD(v63) = (v48 >> 28) & 3;
        unint64_t v66 = interpolate_cif10a[v63];
        char v67 = v63 + 1;
        unint64_t v68 = v64 - ((v64 & v66) >> v67);
        unint64_t v69 = v65 & v66;
LABEL_102:
        unint64_t v75 = v69 >> v67;
LABEL_103:
        unint64_t v44 = v68 + v75;
        break;
    }
LABEL_104:
    *(void *)(v11 + 8) = v44 | v13;
    *(unsigned char *)(v12 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v81 = 0;
    a2 += v10;
    uint64_t v82 = v90 - a2;
    a3 += v9;
    uint64_t v83 = v92 - a3;
    uint64_t v84 = -8;
    while (((v83 | v82 | (a3 - v93) | (a2 - v91)) & 0x8000000000000000) == 0)
    {
      unint64_t v41 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32);
      uint64_t v42 = *(unsigned int **)(result + 32);
      if (v17 >= v41) {
        v85 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32));
      }
      else {
        v85 = (unsigned int *)v17;
      }
      if (v85 < v42) {
        v85 = *(unsigned int **)(result + 32);
      }
      unint64_t v44 = *v85;
      if (v5)
      {
        unint64_t v45 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        v86 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v45) {
          unint64_t v87 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        }
        else {
          unint64_t v87 = (unint64_t)v16;
        }
        if (v87 >= (unint64_t)v86) {
          v86 = (unsigned __int8 *)v87;
        }
        v44 |= (unint64_t)*v86 << 32;
      }
      if (v8)
      {
        unsigned int v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v48 & 0xF) != 0)
        {
          v12 += v81 + 1;
          v11 -= v84;
          a4 += ~v81;
          unsigned int v27 = -1;
          goto LABEL_48;
        }
      }
      *(void *)(v11 + 8 * v81 + 16) = v44 | v13;
      *(unsigned char *)(v12 + v81++ + 2) = -1;
      v84 -= 8;
      a2 += v10;
      v82 -= v10;
      a3 += v9;
      v83 -= v9;
      if (a4 - 1 == v81) {
        return result;
      }
    }
    v12 += v81 + 1;
    v11 -= v84;
    a4 += ~v81;
  }
  while (a4);
  return result;
}

char *CIF10_pattern(uint64_t a1, char *a2, unsigned int a3, int a4, float *a5, float a6)
{
  uint64_t v9 = *(float **)(*(void *)a1 + 64);
  float v10 = *v9;
  float v11 = v9[1];
  float v12 = v9[4];
  if (a2 && a3 > 7 || (a2 = (char *)malloc_type_malloc(0x34uLL, 0x705560E0uLL)) != 0)
  {
    if (v10 > a6) {
      float v13 = v10;
    }
    else {
      float v13 = a6;
    }
    if (v11 < a6) {
      float v13 = v11;
    }
    if (a5) {
      int v14 = a4;
    }
    else {
      int v14 = 0;
    }
    if (v14 == 1)
    {
      if (*a5 <= v11)
      {
        float v11 = *a5;
        if (*a5 < v10) {
          float v11 = v10;
        }
      }
      int v15 = (int)(float)(v12 + (float)(v11 * v13));
      int v16 = v15;
      int v17 = v15;
      goto LABEL_62;
    }
    if (v14 == 4)
    {
      float v23 = a5[4];
      if (v23 < v10) {
        float v24 = v10;
      }
      else {
        float v24 = a5[4];
      }
      if (v23 <= v11) {
        float v25 = v24;
      }
      else {
        float v25 = v11;
      }
      float v26 = a5[1];
      if (*a5 < v10) {
        float v27 = v10;
      }
      else {
        float v27 = *a5;
      }
      if (*a5 <= v11) {
        float v28 = v27;
      }
      else {
        float v28 = v11;
      }
      float v29 = v11;
      if (v26 <= v11)
      {
        float v29 = a5[1];
        if (v26 < v10) {
          float v29 = v10;
        }
      }
      float v30 = a5[2];
      float v31 = v11;
      if (v30 <= v11)
      {
        float v31 = a5[2];
        if (v30 < v10) {
          float v31 = v10;
        }
      }
      float v32 = (float)(v11 - v28) - v25;
      float v33 = (float)(v11 - v29) - v25;
      float v34 = (float)(v11 - v31) - v25;
      if (v32 >= v10) {
        float v35 = v12 + (float)(v32 * v13);
      }
      else {
        float v35 = v10;
      }
      if (v33 >= v10) {
        float v36 = v12 + (float)(v33 * v13);
      }
      else {
        float v36 = v10;
      }
      if (v34 >= v10) {
        float v22 = v12 + (float)(v34 * v13);
      }
      else {
        float v22 = v10;
      }
      int v15 = (int)v35;
      int v16 = (int)v36;
    }
    else
    {
      int v15 = 0;
      int v16 = 0;
      int v17 = 0;
      if (v14 != 3)
      {
LABEL_62:
        *(_OWORD *)a2 = xmmword_1850CE060;
        *((_DWORD *)a2 + 6) = 0;
        *((void *)a2 + 2) = 1;
        uint64_t v37 = (unint64_t *)(a2 + 48);
        float v38 = v9[2];
        uint64_t v39 = (int)(float)(v12 + (float)(v13 * v9[3]));
        float v40 = v38 * (float)v15;
        if (v40 < 0.0) {
          float v41 = 0.0;
        }
        else {
          float v41 = v38 * (float)v15;
        }
        if (v40 <= 1023.0) {
          float v42 = v41;
        }
        else {
          float v42 = 1023.0;
        }
        uint64_t v43 = (int)v42;
        float v44 = v38 * (float)v16;
        if (v44 < 0.0) {
          float v45 = 0.0;
        }
        else {
          float v45 = v38 * (float)v16;
        }
        if (v44 <= 1023.0) {
          float v46 = v45;
        }
        else {
          float v46 = 1023.0;
        }
        int v47 = (int)v46;
        *((void *)a2 + 4) = v37;
        float v48 = v38 * (float)v17;
        if (v48 < 0.0) {
          float v49 = 0.0;
        }
        else {
          float v49 = v38 * (float)v17;
        }
        if (v48 <= 1023.0) {
          float v50 = v49;
        }
        else {
          float v50 = 1023.0;
        }
        *uint64_t v37 = (v43 << 52) | ((unint64_t)((int)v50 & 0x3FF | ((unsigned __int16)(v47 & 0x3FF) << 10)) << 32) | v39 | 0xC000000000000000;
        if (v39 == 255)
        {
          *((void *)a2 + 5) = 0;
        }
        else
        {
          *((_DWORD *)a2 + 14) = v39;
          *((void *)a2 + 5) = a2 + 56;
        }
        return a2;
      }
      float v18 = a5[1];
      if (*a5 < v10) {
        float v19 = v10;
      }
      else {
        float v19 = *a5;
      }
      if (*a5 > v11) {
        float v19 = v11;
      }
      if (v18 < v10) {
        float v20 = v10;
      }
      else {
        float v20 = a5[1];
      }
      if (v18 > v11) {
        float v20 = v11;
      }
      float v21 = a5[2];
      if (v21 <= v11)
      {
        float v11 = a5[2];
        if (v21 < v10) {
          float v11 = v10;
        }
      }
      int v15 = (int)(float)(v12 + (float)(v19 * v13));
      int v16 = (int)(float)(v12 + (float)(v20 * v13));
      float v22 = v12 + (float)(v11 * v13);
    }
    int v17 = (int)v22;
    goto LABEL_62;
  }
  return a2;
}

uint64_t CIF10_mark(uint64_t a1, __n128 a2)
{
  return CIF10_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

uint64_t CIF10_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v766 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(unsigned __int8 **)(v3 + 96);
  uint64_t v10 = *(void *)(v3 + 48);
  int v11 = *(_DWORD *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v9 == 0) + 4 * (v10 == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v13 = v3;
  unint64_t v14 = *(unsigned int *)(v3 + 4);
  unsigned int v15 = v14 - 1;
  if ((int)v14 < 1) {
    return 0;
  }
  int v16 = *(_DWORD *)(v3 + 8);
  uint64_t v17 = (v16 - 1);
  if (v16 < 1) {
    return 0;
  }
  float v18 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v18)
  {
    int v20 = *(_DWORD *)v3 & 0xFF00;
    int v730 = v11;
    if (v20 == 1024)
    {
      v765[0] = *(_DWORD *)(v3 + 4);
      v755[0] = v16;
      if (v9) {
        unsigned int v21 = *v9;
      }
      else {
        unsigned int v21 = 255;
      }
      uint64_t v34 = *(void *)(v3 + 40);
      unsigned __int32 v35 = *(_DWORD *)(*(void *)(v3 + 88) + 4);
      uint64_t v37 = *(int *)(v3 + 12);
      uint64_t v36 = *(int *)(v3 + 16);
      unint64_t v38 = (unint64_t)*(int *)(v3 + 28) >> 2;
      if (v10)
      {
        uint64_t v752 = *(int *)(v3 + 32);
        v750 = (char *)(v10 + v37 + (int)v752 * (uint64_t)(int)v36);
        unsigned int v747 = 1;
      }
      else
      {
        v750 = 0;
        uint64_t v752 = 0;
        unsigned int v747 = 0;
      }
      unsigned __int8 v743 = ~(_BYTE)v21;
      unint64_t v43 = v34 + 4 * (v37 + v36 * v38);
      unint64_t v745 = (unint64_t)*(int *)(v3 + 28) >> 2;
      unint64_t v749 = v43;
      if (!v18)
      {
        uint64_t v45 = 0;
        if (v10) {
          unint64_t v48 = v14;
        }
        else {
          unint64_t v48 = 0;
        }
        float v46 = v750;
        uint64_t v47 = v752 - v48;
        float v49 = (uint32x4_t *)(v34 + 4 * (v37 + v36 * v38));
        unint64_t v50 = v14;
        goto LABEL_924;
      }
      shape_enum_clip_alloc(v14, v3, (int *)v18, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v14, v16);
      uint64_t v45 = v44;
      float v46 = v750;
      uint64_t v47 = v752;
      if (!v44) {
        return 1;
      }
      while (shape_enum_clip_next(v45, (int *)&v754 + 1, &v754, v765, v755))
      {
        float v49 = (uint32x4_t *)(v43 + 4 * v38 * (int)v754 + 4 * SHIDWORD(v754));
        unint64_t v50 = v765[0];
        if (v10)
        {
          float v46 = &v750[(int)v752 * (uint64_t)(int)v754 + SHIDWORD(v754)];
          uint64_t v47 = v752 - v765[0];
        }
        LODWORD(v14) = v765[0];
LABEL_924:
        unint64_t v43 = v38 - v50;
        switch(v11)
        {
          case 0:
          case 1:
            uint64_t v541 = v43 + (int)v14;
            unsigned int v542 = v755[0];
            uint64_t v543 = v755[0] - 1;
            v544 = &v49->i8[4 * ((v541 * v543) & (v541 >> 63))];
            if (v541 < 0) {
              uint64_t v541 = -v541;
            }
            int v545 = v14;
            CGBlt_fillBytes(4 * v14, v755[0], v35, v544, 4 * v541);
            if (v10)
            {
              uint64_t v546 = v47 + v545;
              v46 += (v546 * v543) & (v546 >> 63);
              if (v546 >= 0) {
                v47 += v545;
              }
              else {
                uint64_t v47 = -v546;
              }
              CGBlt_fillBytes(v545, v542, v35, v46, v47);
            }
            int v11 = v730;
            goto LABEL_1179;
          case 2:
            if (v10)
            {
              v547.i64[0] = v21 | ((unint64_t)((v35 >> 20) & 0x3FF) << 32);
              v547.i64[1] = (v35 >> 10) & 0x3FF | ((unint64_t)(v35 & 0x3FF) << 32);
              int32x2_t v548 = vdup_n_s32(v743);
              do
              {
                int v549 = v765[0];
                if (v765[0] >= 4)
                {
                  unsigned int v550 = (v765[0] >> 2) + 1;
                  do
                  {
                    v551.i32[0] = (*v46 * v743 + ((*v46 * v743) >> 8) + 1) >> 8;
                    v551.i32[1] = ((((unsigned __int32)v49->i32[0] >> 20) & 0x3FF) * v743
                                 + (((((unsigned __int32)v49->i32[0] >> 20) & 0x3FF) * v743) >> 8)
                                 + 1) >> 8;
                    v551.i32[2] = ((((unsigned __int32)v49->i32[0] >> 10) & 0x3FF) * v743
                                 + (((((unsigned __int32)v49->i32[0] >> 10) & 0x3FF) * v743) >> 8)
                                 + 1) >> 8;
                    v551.i32[3] = ((v49->i32[0] & 0x3FF) * v743 + (((v49->i32[0] & 0x3FF) * v743) >> 8) + 1) >> 8;
                    int64x2_t v552 = vaddq_s64(v551, v547);
                    v49->i32[0] = ((unint64_t)v552.i64[0] >> 12) & 0x3FF00000 | v552.i16[6] & 0x3FF | ((v552.i16[4] & 0x3FF) << 10) | 0xC0000000;
                    *float v46 = v552.i8[0];
                    unsigned __int32 v553 = v49->u32[1];
                    v552.i64[0] = ((v46[1] * v743
                                  + ((v46[1] * v743) >> 8)
                                  + 1) >> 8) | ((unint64_t)((((v553 >> 20) & 0x3FF) * v743
                                                                  + ((((v553 >> 20) & 0x3FF) * v743) >> 8)
                                                                  + 1) >> 8) << 32);
                    v552.i64[1] = ((((v553 >> 10) & 0x3FF) * v743 + ((((v553 >> 10) & 0x3FF) * v743) >> 8) + 1) >> 8) | ((unint64_t)(((v553 & 0x3FF) * v743 + (((v553 & 0x3FF) * v743) >> 8) + 1) >> 8) << 32);
                    int64x2_t v554 = vaddq_s64(v552, v547);
                    v49->i32[1] = ((unint64_t)v554.i64[0] >> 12) & 0x3FF00000 | v554.i16[6] & 0x3FF | ((v554.i16[4] & 0x3FF) << 10) | 0xC0000000;
                    v46[1] = v554.i8[0];
                    unsigned __int32 v555 = v49->u32[2];
                    v554.i64[0] = ((v46[2] * v743
                                  + ((v46[2] * v743) >> 8)
                                  + 1) >> 8) | ((unint64_t)((((v555 >> 20) & 0x3FF) * v743
                                                                  + ((((v555 >> 20) & 0x3FF) * v743) >> 8)
                                                                  + 1) >> 8) << 32);
                    v554.i64[1] = ((((v555 >> 10) & 0x3FF) * v743 + ((((v555 >> 10) & 0x3FF) * v743) >> 8) + 1) >> 8) | ((unint64_t)(((v555 & 0x3FF) * v743 + (((v555 & 0x3FF) * v743) >> 8) + 1) >> 8) << 32);
                    int64x2_t v556 = vaddq_s64(v554, v547);
                    v49->i32[2] = ((unint64_t)v556.i64[0] >> 12) & 0x3FF00000 | v556.i16[6] & 0x3FF | ((v556.i16[4] & 0x3FF) << 10) | 0xC0000000;
                    v46[2] = v556.i8[0];
                    unsigned __int32 v557 = v49->u32[3];
                    v556.i64[0] = ((v46[3] * v743
                                  + ((v46[3] * v743) >> 8)
                                  + 1) >> 8) | ((unint64_t)((((v557 >> 20) & 0x3FF) * v743
                                                                  + ((((v557 >> 20) & 0x3FF) * v743) >> 8)
                                                                  + 1) >> 8) << 32);
                    v556.i64[1] = ((((v557 >> 10) & 0x3FF) * v743 + ((((v557 >> 10) & 0x3FF) * v743) >> 8) + 1) >> 8) | ((unint64_t)(((v557 & 0x3FF) * v743 + (((v557 & 0x3FF) * v743) >> 8) + 1) >> 8) << 32);
                    int64x2_t v558 = vaddq_s64(v556, v547);
                    v49->i32[3] = ((unint64_t)v558.i64[0] >> 12) & 0x3FF00000 | v558.i16[6] & 0x3FF | ((v558.i16[4] & 0x3FF) << 10) | 0xC0000000;
                    v46[3] = v558.i8[0];
                    ++v49;
                    v46 += 4 * v747;
                    --v550;
                  }
                  while (v550 > 1);
                  int v549 = v765[0] & 3;
                }
                if (v549 >= 1)
                {
                  unsigned int v559 = v549 + 1;
                  do
                  {
                    uint32x2_t v560 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v548);
                    *(uint32x2_t *)v561.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v560, v560, 8uLL), (int32x2_t)0x100000001), 8uLL);
                    unint64_t v562 = v561.u32[0] | ((unint64_t)(((v49->i32[0] & 0x3FF) * v743
                                                            + (((v49->i32[0] & 0x3FF) * v743) >> 8)
                                                            + 1) >> 8) << 32);
                    v561.i32[0] = (*v46 * v743 + ((*v46 * v743) >> 8) + 1) >> 8;
                    v561.i64[1] = v562;
                    int64x2_t v563 = vaddq_s64(v561, v547);
                    v49->i32[0] = ((unint64_t)v563.i64[0] >> 12) & 0x3FF00000 | v563.i16[6] & 0x3FF | ((v563.i16[4] & 0x3FF) << 10) | 0xC0000000;
                    float v49 = (uint32x4_t *)((char *)v49 + 4);
                    *float v46 = v563.i8[0];
                    v46 += v747;
                    --v559;
                  }
                  while (v559 > 1);
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47;
                --v755[0];
              }
              while (v755[0]);
            }
            else
            {
              int32x4_t v671 = vdupq_n_s32(v743);
              int32x4_t v672 = vdupq_n_s32(v35 - 0x40000000);
              v673.i64[0] = 0x300000003;
              v673.i64[1] = 0x300000003;
              v674.i64[0] = 0x100000001;
              v674.i64[1] = 0x100000001;
              v675.i64[0] = 0x400000004;
              v675.i64[1] = 0x400000004;
              v676.i64[0] = 0x100000001000;
              v676.i64[1] = 0x100000001000;
              __asm { FMOV            V6.4S, #1.875 }
              int8x16_t v682 = (int8x16_t)vdupq_n_s32(0xFFC00u);
              do
              {
                int v683 = v765[0];
                if (v765[0] >= 4)
                {
                  unsigned int v684 = (v765[0] >> 2) + 1;
                  do
                  {
                    uint32x4_t v685 = (uint32x4_t)vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v49, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)), v671);
                    uint32x4_t v686 = (uint32x4_t)vmulq_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(*v49, 0xAuLL), v673), v671);
                    uint32x4_t v687 = (uint32x4_t)vmulq_s32((int32x4_t)vandq_s8(*(int8x16_t *)v49, v673), v671);
                    *(int32x4_t *)v49++ = vaddq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vaddq_s32(vshlq_n_s32((int32x4_t)vsraq_n_u32(v685, v685, 8uLL), 0xCuLL), v676), _Q6), (int8x16_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v687, v687, 8uLL), v674), 8uLL)), vandq_s8((int8x16_t)vaddq_s32(
                                                                        vshlq_n_s32((int32x4_t)vsraq_n_u32(v686, v686, 8uLL), 2uLL), v675), v682)), v672);
                    v46 += 4 * v747;
                    --v684;
                  }
                  while (v684 > 1);
                  v683 &= 3u;
                }
                if (v683 >= 1)
                {
                  unsigned int v688 = v683 + 1;
                  do
                  {
                    uint32x2_t v689 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), *(int32x2_t *)v671.i8);
                    int8x8_t v690 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v689, v689, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                    v49->i32[0] = (v690.i32[0] | (((v49->i32[0] & 0x3FF) * v743
                                                 + (((v49->i32[0] & 0x3FF) * v743) >> 8)
                                                 + 1) >> 8) | v690.i32[1])
                                + v35
                                - 0x40000000;
                    float v49 = (uint32x4_t *)((char *)v49 + 4);
                    --v688;
                  }
                  while (v688 > 1);
                  v46 += v683 * v747;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47;
                --v755[0];
              }
              while (v755[0]);
            }
            goto LABEL_1179;
          case 3:
            int32x2_t v564 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v35), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
            do
            {
              int v565 = v765[0];
              do
              {
                unsigned int v566 = *v46;
                if (v566 == 255)
                {
                  v49->i32[0] = v35;
                  LOBYTE(v566) = v21;
                }
                else if (*v46)
                {
                  uint32x2_t v567 = (uint32x2_t)vmul_s32(v564, vdup_n_s32(v566));
                  int8x8_t v568 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v567, v567, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned __int32 v569 = v568.i32[0] | (((v35 & 0x3FF) * v566 + (((v35 & 0x3FF) * v566) >> 8) + 1) >> 8);
                  unsigned int v566 = (v566 * v21 + ((v566 * v21) >> 8) + 1) >> 8;
                  v49->i32[0] = v569 | v568.i32[1] | 0xC0000000;
                }
                else
                {
                  v49->i32[0] = 0;
                }
                *float v46 = v566;
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v565;
              }
              while (v565);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            goto LABEL_1179;
          case 4:
            int32x2_t v570 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v35), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
            do
            {
              int v571 = v765[0];
              do
              {
                if (~*v46 == 255)
                {
                  v49->i32[0] = v35;
                  LOBYTE(v572) = v21;
                }
                else if (*v46 == -1)
                {
                  LOBYTE(v572) = 0;
                  v49->i32[0] = 0;
                }
                else
                {
                  unsigned int v573 = ~*v46;
                  uint32x2_t v574 = (uint32x2_t)vmul_s32(v570, vdup_n_s32(v573));
                  int8x8_t v575 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v574, v574, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned __int32 v576 = v575.i32[0] | (((v35 & 0x3FF) * v573 + (((v35 & 0x3FF) * v573) >> 8) + 1) >> 8);
                  unsigned int v572 = (v573 * v21 + ((v573 * v21) >> 8) + 1) >> 8;
                  v49->i32[0] = v576 | v575.i32[1] | 0xC0000000;
                }
                *float v46 = v572;
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v571;
              }
              while (v571);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            goto LABEL_1179;
          case 5:
            int32x2_t v577 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v35), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
            int32x2_t v578 = vdup_n_s32(v743);
            do
            {
              int v579 = v765[0];
              do
              {
                unsigned int v580 = *v46;
                unsigned int v581 = ((v580 * v743 + ((v580 * v743) >> 8) + 1) >> 8) + ((v580 * v21 + ((v580 * v21) >> 8) + 1) >> 8);
                if (v581 >= 0xFF) {
                  LOBYTE(v581) = -1;
                }
                unsigned int v582 = (((v49->i32[0] & 0x3FF) * v743 + (((v49->i32[0] & 0x3FF) * v743) >> 8) + 1) >> 8)
                     + (((v35 & 0x3FF) * v580 + (((v35 & 0x3FF) * v580) >> 8) + 1) >> 8);
                if (v582 >= 0x3FF) {
                  unsigned int v582 = 1023;
                }
                uint32x2_t v583 = (uint32x2_t)vmul_s32(v577, vdup_n_s32(v580));
                uint32x2_t v584 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v578);
                int8x8_t v585 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v584, v584, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v583, v583, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                v49->i32[0] = vorr_s8(v585, (int8x8_t)vdup_lane_s32((int32x2_t)v585, 1)).u32[0] | v582 | 0xC0000000;
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                *float v46 = v581;
                v46 += v747;
                --v579;
              }
              while (v579);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            goto LABEL_1179;
          case 6:
            v586.i32[0] = v35;
            v586.i32[1] = v35 >> 20;
            int32x2_t v587 = (int32x2_t)vand_s8(v586, (int8x8_t)0x300000003);
            do
            {
              int v588 = v765[0];
              do
              {
                uint64_t v589 = *v46;
                if ((_BYTE)v589 != 0xFF)
                {
                  if (~(_BYTE)v589 == 255)
                  {
                    v49->i32[0] = v35;
                    __int8 v590 = v21;
                  }
                  else
                  {
                    unsigned int v591 = ~(_BYTE)v589;
                    uint32x2_t v592 = (uint32x2_t)vmul_s32(v587, vdup_n_s32(v591));
                    *(uint32x2_t *)v593.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v592, v592, 8uLL), (int32x2_t)0x100000001), 8uLL);
                    unint64_t v594 = ((((v35 >> 10) & 0x3FF) * v591 + ((((v35 >> 10) & 0x3FF) * v591) >> 8) + 1) >> 8) | ((unint64_t)v593.u32[0] << 32);
                    v593.i32[0] = (v591 * v21 + ((v591 * v21) >> 8) + 1) >> 8;
                    v593.i64[1] = v594;
                    int8x8_t v595 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                    unint64_t v596 = v595.u32[0] | ((unint64_t)(v49->i32[0] & 0x3FF) << 32);
                    v597.i64[0] = v589 | ((unint64_t)v595.u32[1] << 32);
                    v597.i64[1] = v596;
                    int64x2_t v598 = vaddq_s64(v597, v593);
                    __int8 v590 = v598.i8[0];
                    v49->i32[0] = ((unint64_t)v598.i64[0] >> 12) & 0x3FF00000 | v598.i16[6] & 0x3FF | ((v598.i16[4] & 0x3FF) << 10) | 0xC0000000;
                  }
                  *float v46 = v590;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v588;
              }
              while (v588);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            goto LABEL_1179;
          case 7:
            int32x2_t v599 = vdup_n_s32(v21);
            if (v10)
            {
              do
              {
                int v600 = v765[0];
                do
                {
                  uint32x2_t v601 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), v599);
                  int8x8_t v602 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v601, v601, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v603 = (*v46 * v21 + ((*v46 * v21) >> 8) + 1) >> 8;
                  v49->i32[0] = v602.i32[0] | (((v49->i32[0] & 0x3FF) * v21 + (((v49->i32[0] & 0x3FF) * v21) >> 8) + 1) >> 8) | v602.i32[1] | 0xC0000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  *float v46 = v603;
                  v46 += v747;
                  --v600;
                }
                while (v600);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47;
                --v755[0];
              }
              while (v755[0]);
            }
            else
            {
              do
              {
                int v691 = v765[0];
                unsigned int v692 = v765[0] - 1;
                do
                {
                  uint32x2_t v693 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), v599);
                  int8x8_t v694 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v693, v693, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  v49->i32[0] = v49->i32[0]
                              - (v694.i32[0] | (((v49->i32[0] & 0x3FF) * v21 + (((v49->i32[0] & 0x3FF) * v21) >> 8) + 1) >> 8) | v694.i32[1])
                              + 0x40000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  --v691;
                }
                while (v691);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47 + v747 + v747 * (unint64_t)v692;
                --v755[0];
              }
              while (v755[0]);
            }
            goto LABEL_1179;
          case 8:
            int32x2_t v604 = vdup_n_s32(v743);
            if (v10)
            {
              do
              {
                int v605 = v765[0];
                do
                {
                  uint32x2_t v606 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), v604);
                  int8x8_t v607 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v606, v606, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v608 = (*v46 * v743 + ((*v46 * v743) >> 8) + 1) >> 8;
                  v49->i32[0] = v607.i32[0] | (((v49->i32[0] & 0x3FF) * v743
                                              + (((v49->i32[0] & 0x3FF) * v743) >> 8)
                                              + 1) >> 8) | v607.i32[1] | 0xC0000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  *float v46 = v608;
                  v46 += v747;
                  --v605;
                }
                while (v605);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47;
                --v755[0];
              }
              while (v755[0]);
            }
            else
            {
              do
              {
                int v695 = v765[0];
                unsigned int v696 = v765[0] - 1;
                do
                {
                  uint32x2_t v697 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), v604);
                  int8x8_t v698 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v697, v697, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  v49->i32[0] = v49->i32[0]
                              - (v698.i32[0] | (((v49->i32[0] & 0x3FF) * v743
                                               + (((v49->i32[0] & 0x3FF) * v743) >> 8)
                                               + 1) >> 8) | v698.i32[1])
                              + 0x40000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  --v695;
                }
                while (v695);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47 + v747 + v747 * (unint64_t)v696;
                --v755[0];
              }
              while (v755[0]);
            }
            goto LABEL_1179;
          case 9:
            int32x2_t v609 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v35), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
            int32x2_t v610 = vdup_n_s32(v21);
            do
            {
              int v611 = v765[0];
              do
              {
                int v612 = *v46;
                unsigned int v613 = v612 ^ 0xFF;
                unsigned int v614 = ((v612 * v21 + ((v612 * v21) >> 8) + 1) >> 8) + ((v613 * v21 + ((v613 * v21) >> 8) + 1) >> 8);
                if (v614 >= 0xFF) {
                  LOBYTE(v614) = -1;
                }
                unsigned int v615 = (((v49->i32[0] & 0x3FF) * v21 + (((v49->i32[0] & 0x3FF) * v21) >> 8) + 1) >> 8)
                     + (((v35 & 0x3FF) * v613 + (((v35 & 0x3FF) * v613) >> 8) + 1) >> 8);
                if (v615 >= 0x3FF) {
                  unsigned int v615 = 1023;
                }
                uint32x2_t v616 = (uint32x2_t)vmul_s32(v609, vdup_n_s32(v613));
                uint32x2_t v617 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v610);
                int8x8_t v618 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v617, v617, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v616, v616, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                v49->i32[0] = vorr_s8(v618, (int8x8_t)vdup_lane_s32((int32x2_t)v618, 1)).u32[0] | v615 | 0xC0000000;
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                *float v46 = v614;
                v46 += v747;
                --v611;
              }
              while (v611);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            goto LABEL_1179;
          case 10:
            int32x2_t v619 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v35), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
            int32x2_t v620 = vdup_n_s32(v743);
            do
            {
              int v621 = v765[0];
              do
              {
                int v622 = *v46;
                unsigned int v623 = v622 ^ 0xFF;
                unsigned int v624 = ((v622 * v743 + ((v622 * v743) >> 8) + 1) >> 8)
                     + ((v623 * v21 + ((v623 * v21) >> 8) + 1) >> 8);
                if (v624 >= 0xFF) {
                  LOBYTE(v624) = -1;
                }
                unsigned int v625 = (((v49->i32[0] & 0x3FF) * v743 + (((v49->i32[0] & 0x3FF) * v743) >> 8) + 1) >> 8)
                     + (((v35 & 0x3FF) * v623 + (((v35 & 0x3FF) * v623) >> 8) + 1) >> 8);
                if (v625 >= 0x3FF) {
                  unsigned int v625 = 1023;
                }
                uint32x2_t v626 = (uint32x2_t)vmul_s32(v619, vdup_n_s32(v623));
                uint32x2_t v627 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v620);
                int8x8_t v628 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v627, v627, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v626, v626, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                v49->i32[0] = vorr_s8(v628, (int8x8_t)vdup_lane_s32((int32x2_t)v628, 1)).u32[0] | v625 | 0xC0000000;
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                *float v46 = v624;
                v46 += v747;
                --v621;
              }
              while (v621);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            goto LABEL_1179;
          case 11:
            int32x2_t v629 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v35), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
            int v630 = v35 & 0x3FF;
            if (v10)
            {
              do
              {
                int v631 = v765[0];
                do
                {
                  unsigned int v632 = *v46 + v21;
                  if (v632 >= 0xFF) {
                    LOBYTE(v632) = -1;
                  }
                  unsigned int v633 = (v49->i32[0] & 0x3FF) + v630;
                  if (v633 >= 0x3FF) {
                    unsigned int v633 = 1023;
                  }
                  int8x8_t v634 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v629), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  v49->i32[0] = vorr_s8(v634, (int8x8_t)vdup_lane_s32((int32x2_t)v634, 1)).u32[0] | v633 | 0xC0000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  *float v46 = v632;
                  v46 += v747;
                  --v631;
                }
                while (v631);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47;
                --v755[0];
              }
              while (v755[0]);
            }
            else
            {
              do
              {
                int v699 = v765[0];
                unsigned int v700 = v765[0] - 1;
                do
                {
                  unsigned int v701 = (v49->i32[0] & 0x3FF) + v630;
                  if (v701 >= 0x3FF) {
                    unsigned int v701 = 1023;
                  }
                  int8x8_t v702 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v629), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  v49->i32[0] = vorr_s8(v702, (int8x8_t)vdup_lane_s32((int32x2_t)v702, 1)).u32[0] | v701 | 0xC0000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  --v699;
                }
                while (v699);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47 + v747 + v747 * (unint64_t)v700;
                --v755[0];
              }
              while (v755[0]);
            }
            goto LABEL_1179;
          case 12:
            int32x2_t v635 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v35), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
            int v636 = v35 & 0x3FF;
            if (v10)
            {
              do
              {
                int v637 = v765[0];
                do
                {
                  unsigned int v638 = *v46 + v21;
                  if (v638 >= 0xFF) {
                    LOBYTE(v638) = -1;
                  }
                  unsigned int v639 = (v49->i32[0] & 0x3FF) + v636;
                  if (v639 >= 0x3FF) {
                    unsigned int v639 = 1023;
                  }
                  int8x8_t v640 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v635), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  v49->i32[0] = vorr_s8(v640, (int8x8_t)vdup_lane_s32((int32x2_t)v640, 1)).u32[0] | v639 | 0xC0000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  *float v46 = v638;
                  v46 += v747;
                  --v637;
                }
                while (v637);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47;
                --v755[0];
              }
              while (v755[0]);
            }
            else
            {
              do
              {
                int v703 = v765[0];
                unsigned int v704 = v765[0] - 1;
                do
                {
                  unsigned int v705 = (v49->i32[0] & 0x3FF) + v636;
                  if (v705 >= 0x3FF) {
                    unsigned int v705 = 1023;
                  }
                  int8x8_t v706 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v49->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v635), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  v49->i32[0] = vorr_s8(v706, (int8x8_t)vdup_lane_s32((int32x2_t)v706, 1)).u32[0] | v705 | 0xC0000000;
                  float v49 = (uint32x4_t *)((char *)v49 + 4);
                  --v703;
                }
                while (v703);
                float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
                v46 += v47 + v747 + v747 * (unint64_t)v704;
                --v755[0];
              }
              while (v755[0]);
            }
            goto LABEL_1179;
          case 13:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v641 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v642 = PDAmultiplyPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v642);
                    *float v46 = v642;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAmultiplyPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v641;
              }
              while (v641);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 14:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v643 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v644 = PDAscreenPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v644);
                    *float v46 = v644;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAscreenPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v643;
              }
              while (v643);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 15:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v645 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v646 = PDAoverlayPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v646);
                    *float v46 = v646;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAoverlayPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v645;
              }
              while (v645);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 16:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v647 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v648 = PDAdarkenPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v648);
                    *float v46 = v648;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAdarkenPDA(v49->i32[0], 0xFFu, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v647;
              }
              while (v647);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 17:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v649 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v650 = PDAlightenPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v650);
                    *float v46 = v650;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAlightenPDA(v49->i32[0], 0xFFu, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v649;
              }
              while (v649);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 18:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v651 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v652 = PDAcolordodgePDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v652);
                    *float v46 = v652;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAcolordodgePDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v651;
              }
              while (v651);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 19:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v653 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v654 = PDAcolorburnPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v654);
                    *float v46 = v654;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAcolorburnPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v653;
              }
              while (v653);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 20:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v655 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v656 = PDAsoftlightPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v656);
                    *float v46 = v656;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAsoftlightPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v655;
              }
              while (v655);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 21:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v657 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v658 = PDAhardlightPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v658);
                    *float v46 = v658;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAhardlightPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v657;
              }
              while (v657);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 22:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v659 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v660 = PDAdifferencePDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v660);
                    *float v46 = v660;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAdifferencePDA(v49->i32[0], 0xFFu, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v659;
              }
              while (v659);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 23:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v661 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v662 = PDAexclusionPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v662);
                    *float v46 = v662;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAexclusionPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v661;
              }
              while (v661);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 24:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v663 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v664 = PDAhuePDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v664);
                    *float v46 = v664;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAhuePDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v663;
              }
              while (v663);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 25:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v665 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v666 = PDAsaturationPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v666);
                    *float v46 = v666;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAsaturationPDA(v49->i32[0], 255, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v665;
              }
              while (v665);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 26:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v667 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v668 = PDAluminosityPDA(v35, v21, v49->i32[0], *v46);
                    v49->i32[0] = HIDWORD(v668);
                    *float v46 = v668;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAluminosityPDA(v35, v21, v49->i32[0], 0xFFu) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v667;
              }
              while (v667);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          case 27:
            if (!v21) {
              goto LABEL_1179;
            }
            do
            {
              int v669 = v765[0];
              do
              {
                if (v10)
                {
                  if (*v46)
                  {
                    unint64_t v670 = PDAluminosityPDA(v49->i32[0], *v46, v35, v21);
                    v49->i32[0] = HIDWORD(v670);
                    *float v46 = v670;
                  }
                  else
                  {
                    v49->i32[0] = v35;
                    *float v46 = v21;
                  }
                }
                else
                {
                  v49->i32[0] = PDAluminosityPDA(v49->i32[0], 0xFFu, v35, v21) >> 32;
                }
                float v49 = (uint32x4_t *)((char *)v49 + 4);
                v46 += v747;
                --v669;
              }
              while (v669);
              float v49 = (uint32x4_t *)((char *)v49 + 4 * v43);
              v46 += v47;
              --v755[0];
            }
            while (v755[0]);
            break;
          default:
            goto LABEL_1180;
        }
        int v11 = v730;
        unint64_t v38 = v745;
LABEL_1179:
        unint64_t v43 = v749;
LABEL_1180:
        if (!v45) {
          return 1;
        }
        uint64_t v754 = 0;
      }
      unint64_t v60 = (void *)v45;
LABEL_1187:
      free(v60);
      return 1;
    }
    v765[0] = *(_DWORD *)(v3 + 4);
    v755[0] = v16;
    float v22 = *(unsigned int **)(v3 + 88);
    uint64_t v24 = *(int *)(v3 + 12);
    uint64_t v23 = *(int *)(v3 + 16);
    unint64_t v25 = (unint64_t)*(int *)(v3 + 28) >> 2;
    if (v10)
    {
      uint64_t v26 = *(int *)(v3 + 32);
      v732 = (char *)(v10 + v24 + (int)v26 * (uint64_t)(int)v23);
      uint64_t v27 = 0xFFFFFFFFLL;
    }
    else
    {
      v732 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
    }
    unint64_t v731 = *(void *)(v3 + 40) + 4 * (v24 + v23 * v25);
    int v39 = *(_DWORD *)(v3 + 56);
    int v40 = *(_DWORD *)(v3 + 60);
    unint64_t v740 = (unint64_t)*(int *)(v3 + 76) >> 2;
    unint64_t v708 = v3;
    if (v20 == 256)
    {
      if (v9)
      {
        uint64_t v41 = *(int *)(v3 + 80);
        v9 += v39 + (int)v41 * (uint64_t)v40;
        int v42 = -1;
      }
      else
      {
        uint64_t v41 = 0;
        int v42 = 0;
      }
      v22 += v39 + v40 * v740;
      if (v740 == v25 && (uint64_t)(v731 - (void)v22) >= 1)
      {
        if (v14 >= (v731 - (unint64_t)v22) >> 2)
        {
          v731 += 4 * v15;
          v732 += v27 & v15;
          v9 += v42 & v15;
          int v63 = -1;
          unint64_t v740 = (unint64_t)*(int *)(v3 + 28) >> 2;
          v22 += v15;
          goto LABEL_49;
        }
        unint64_t v61 = v25 * v17;
        uint64_t v62 = &v22[v25 * v17];
        if (v731 <= (unint64_t)&v62[v15])
        {
          unint64_t v25 = -(uint64_t)v25;
          v732 += v26 * v17;
          uint64_t v26 = -v26;
          v27 &= 1u;
          v9 += v41 * v17;
          uint64_t v41 = -v41;
          v42 &= 1u;
          int v63 = 1;
          float v22 = v62;
          unint64_t v740 = v25;
          v731 += 4 * v61;
          goto LABEL_49;
        }
      }
      v27 &= 1u;
      v42 &= 1u;
      int v63 = 1;
LABEL_49:
      int v709 = *(_DWORD *)(v3 + 60);
      int v710 = *(_DWORD *)(v3 + 56);
      if (v18)
      {
        int v751 = v42;
        uint64_t v753 = v27;
        v744 = 0;
        v741 = 0;
        uint64_t v64 = -1;
        int v735 = v740;
        int v734 = v41;
        goto LABEL_54;
      }
      unint64_t v70 = v63 * (int)v14;
      uint64_t v748 = v26 - (int)v27 * (int)v14;
      unint64_t v71 = -1;
      int v733 = v63;
      int v734 = v41;
      unint64_t v72 = v740;
      int v735 = v740;
LABEL_62:
      uint64_t v736 = 0;
      uint64_t v737 = (uint64_t)v22;
      long long v76 = 0;
      unint64_t v740 = v72 - v70;
      v741 = 0;
      v41 -= v42 * (int)v14;
      v742 = v9;
      unint64_t v68 = v9;
      uint64_t v77 = (unsigned int *)v731;
      unint64_t v69 = v732;
      goto LABEL_66;
    }
    int v735 = *(_DWORD *)(v3 + 64);
    int v734 = *(_DWORD *)(v3 + 68);
    if (v9)
    {
      uint64_t v41 = *(int *)(v3 + 80);
      int v42 = 1;
    }
    else
    {
      uint64_t v41 = 0;
      int v42 = 0;
    }
    v741 = &v22[v740 * v734];
    v27 &= 1u;
    if (v18)
    {
      int v709 = *(_DWORD *)(v3 + 60);
      int v710 = *(_DWORD *)(v3 + 56);
      int v751 = v42;
      uint64_t v753 = v27;
      int v63 = 1;
      v744 = *(unsigned int **)(v3 + 88);
      uint64_t v64 = (uint64_t)v744;
LABEL_54:
      int v733 = v63;
      unint64_t v738 = v25;
      shape_enum_clip_alloc(v14, v3, (int *)v18, v63, v25, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v14, v16);
      uint64_t v66 = v65;
      char v67 = v9;
      unint64_t v68 = v9;
      unint64_t v69 = v732;
      uint64_t v748 = v26;
      if (!v65) {
        return 1;
      }
      goto LABEL_873;
    }
    uint64_t v748 = v26 - (v27 * v14);
    if (!v22)
    {
      int v709 = *(_DWORD *)(v3 + 60);
      int v710 = *(_DWORD *)(v3 + 56);
      unint64_t v71 = 0;
      int v733 = 1;
      unint64_t v70 = v14;
      unint64_t v72 = (unint64_t)*(int *)(v3 + 76) >> 2;
      goto LABEL_62;
    }
    uint64_t v73 = v40 % v734;
    int v709 = v40 % v734;
    uint64_t v737 = *(void *)(v3 + 88);
    char v74 = &v22[v740 * v73];
    int v75 = v39 % v735;
    long long v76 = &v74[v75];
    unint64_t v71 = (unint64_t)&v74[v735];
    int v710 = v75;
    uint64_t v736 = 0;
    if (v9)
    {
      unint64_t v68 = &v9[(int)v41 * (uint64_t)(int)v73 + v75];
      int v733 = 1;
      int v42 = 1;
      v742 = v68;
    }
    else
    {
      v742 = 0;
      unint64_t v68 = 0;
      int v733 = 1;
    }
    float v22 = &v74[v75];
    uint64_t v77 = (unsigned int *)v731;
    unint64_t v69 = v732;
    unint64_t v70 = v14;
LABEL_66:
    int v751 = v42;
    uint64_t v753 = v27;
    unint64_t v738 = v25;
    unint64_t v746 = v25 - v70;
    uint64_t v739 = v41;
    switch(v11)
    {
      case 0:
        v744 = v76;
        unint64_t v707 = v71;
        uint64_t v726 = v26;
        v728 = v9;
        uint64_t v78 = (int)v14;
        uint64_t v79 = v746 - (int)v14;
        int v80 = v14 - 1;
        uint64_t v81 = &v77[-(int)v14 + 1];
        if (v733 >= 0)
        {
          uint64_t v81 = v77;
          uint64_t v79 = v746 + (int)v14;
        }
        unsigned int v82 = v755[0];
        uint64_t v83 = v755[0] - 1;
        uint64_t v84 = (char *)&v81[(v79 * v83) & (v79 >> 63)];
        if (v79 < 0) {
          uint64_t v79 = -v79;
        }
        int v85 = v14;
        int v86 = v27;
        CGBlt_fillBytes(4 * v14, v755[0], 0, v84, 4 * v79);
        if (v86)
        {
          uint64_t v87 = v748 - v78;
          unint64_t v88 = &v69[-v80];
          if (v733 >= 0)
          {
            unint64_t v88 = v69;
            uint64_t v87 = v748 + v78;
          }
          uint64_t v89 = (v87 * v83) & (v87 >> 63);
          unint64_t v69 = &v88[v89];
          if (v87 >= 0) {
            uint64_t v90 = v87;
          }
          else {
            uint64_t v90 = -v87;
          }
          uint64_t v748 = v90;
          CGBlt_fillBytes(v85, v82, 0, &v88[v89], v90);
        }
        uint64_t v26 = v726;
        uint64_t v9 = v728;
        goto LABEL_79;
      case 1:
        int v91 = *(unsigned __int8 *)(v13 + 1);
        if (v91 == 2)
        {
          if ((int)v14 >= 8 && (4 * v735) <= 0x40)
          {
            LODWORD(v4) = 4 * v735;
            uint8x8_t v492 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v4);
            v492.i16[0] = vaddlv_u8(v492);
            if (v492.i32[0] <= 1u)
            {
              v744 = v76;
              unint64_t v707 = v71;
              unsigned int v493 = v14;
              int v494 = v755[0];
              float v22 = (unsigned int *)v737;
              CGSFillDRAM64((unint64_t)v77, 4 * (v14 + v746), 4 * v14, v755[0], v737, 4 * v740, 4 * v735, v734, 4 * v710, v709);
              if (v753)
              {
                uint64_t v66 = v736;
                if (v42) {
                  CGSFillDRAM64((unint64_t)v69, v493 + v748, v493, v494, (uint64_t)v9, v41, v735, v734, v710, v709);
                }
                else {
                  CGBlt_fillBytes(v493, v494, -1, v69, v493 + v748);
                }
                goto LABEL_81;
              }
LABEL_80:
              uint64_t v66 = v736;
              goto LABEL_81;
            }
          }
        }
        else if (v91 == 1)
        {
          v744 = v76;
          uint64_t v92 = (int)v14;
          unint64_t v707 = v71;
          uint64_t v93 = v26;
          if (v733 < 0)
          {
            uint64_t v94 = v740 - (int)v14;
            v22 += -(int)v14 + 1;
            uint64_t v95 = v746 - (int)v14;
            v77 += -(int)v14 + 1;
          }
          else
          {
            uint64_t v94 = v740 + (int)v14;
            uint64_t v95 = v746 + (int)v14;
          }
          uint64_t v523 = v755[0] - 1;
          v524 = (char *)&v22[(v94 * v523) & (v94 >> 63)];
          int v525 = v755[0];
          if (v94 >= 0) {
            unint64_t v526 = v94;
          }
          else {
            unint64_t v526 = -v94;
          }
          if (v95 >= 0) {
            LODWORD(v527) = v95;
          }
          else {
            uint64_t v527 = -v95;
          }
          int v528 = v14;
          unint64_t v740 = v526;
          CGBlt_copyBytes(4 * v14, v755[0], v524, (char *)&v77[(v95 * v523) & (v95 >> 63)], 4 * v526, 4 * v527);
          if (v753)
          {
            uint64_t v66 = v736;
            if (v42)
            {
              uint64_t v529 = v739 - v92;
              v530 = &v68[-v528 + 1];
              uint64_t v531 = v748 - v92;
              v532 = &v69[-v528 + 1];
              if (v733 >= 0)
              {
                v530 = v68;
                v532 = v69;
                uint64_t v529 = v739 + v92;
                uint64_t v531 = v748 + v92;
              }
              uint64_t v533 = (v529 * v523) & (v529 >> 63);
              unint64_t v68 = &v530[v533];
              if (v529 >= 0) {
                uint64_t v534 = v529;
              }
              else {
                uint64_t v534 = -v529;
              }
              uint64_t v535 = (v531 * v523) & (v531 >> 63);
              unint64_t v69 = &v532[v535];
              if (v531 >= 0) {
                uint64_t v536 = v531;
              }
              else {
                uint64_t v536 = -v531;
              }
              uint64_t v748 = v536;
              CGBlt_copyBytes(v528, v525, (char *)&v530[v533], &v532[v535], v534, v536);
              uint64_t v26 = v93;
              uint64_t v41 = v534;
              float v22 = (unsigned int *)v737;
            }
            else
            {
              uint64_t v537 = v748 - v92;
              v538 = &v69[-v528 + 1];
              if (v733 >= 0)
              {
                v538 = v69;
                uint64_t v537 = v748 + v92;
              }
              uint64_t v539 = (v537 * v523) & (v537 >> 63);
              unint64_t v69 = &v538[v539];
              if (v537 >= 0) {
                uint64_t v540 = v537;
              }
              else {
                uint64_t v540 = -v537;
              }
              uint64_t v748 = v540;
              CGBlt_fillBytes(v528, v525, -1, &v538[v539], v540);
              uint64_t v26 = v93;
              float v22 = (unsigned int *)v737;
              uint64_t v41 = v739;
            }
LABEL_81:
            unint64_t v71 = v707;
            char v67 = v742;
            int v11 = v730;
            if (!v66) {
              return 1;
            }
            goto LABEL_872;
          }
          uint64_t v26 = v93;
LABEL_79:
          float v22 = (unsigned int *)v737;
          uint64_t v41 = v739;
          goto LABEL_80;
        }
        if (v27)
        {
          uint64_t v495 = 4 * v733;
          if (v42)
          {
            uint64_t v496 = v42;
            char v67 = v742;
            do
            {
              int v497 = v765[0];
              do
              {
                unsigned int *v77 = *v22;
                *unint64_t v69 = *v68;
                v69 += (int)v27;
                v498 = &v22[v733];
                if ((unint64_t)v498 >= v71) {
                  uint64_t v499 = -(uint64_t)v735;
                }
                else {
                  uint64_t v499 = 0;
                }
                v68 += v496 + v499;
                float v22 = &v498[v499];
                uint64_t v77 = (unsigned int *)((char *)v77 + v495);
                --v497;
              }
              while (v497);
              if (v741)
              {
                v500 = &v76[v740];
                if (v500 >= v741) {
                  uint64_t v501 = -(v41 * v734);
                }
                else {
                  uint64_t v501 = 0;
                }
                v67 += v41 + v501;
                if (v500 >= v741) {
                  uint64_t v502 = -(uint64_t)(v740 * v734);
                }
                else {
                  uint64_t v502 = 0;
                }
                long long v76 = &v500[v502];
                v71 += 4 * v502 + 4 * v740;
                unint64_t v68 = v67;
                float v22 = v76;
              }
              else
              {
                v22 += v740;
                v68 += v41;
              }
              v77 += v746;
              v69 += v748;
              --v755[0];
            }
            while (v755[0]);
          }
          else
          {
            char v67 = v742;
            do
            {
              int v510 = v765[0];
              do
              {
                unsigned int *v77 = *v22;
                *unint64_t v69 = -1;
                v69 += (int)v27;
                v511 = &v22[v733];
                if ((unint64_t)v511 >= v71) {
                  uint64_t v512 = -(uint64_t)v735;
                }
                else {
                  uint64_t v512 = 0;
                }
                v68 += v512;
                float v22 = &v511[v512];
                uint64_t v77 = (unsigned int *)((char *)v77 + v495);
                --v510;
              }
              while (v510);
              if (v741)
              {
                v513 = &v76[v740];
                if (v513 >= v741) {
                  uint64_t v514 = -(v41 * v734);
                }
                else {
                  uint64_t v514 = 0;
                }
                v67 += v41 + v514;
                if (v513 >= v741) {
                  uint64_t v515 = -(uint64_t)(v740 * v734);
                }
                else {
                  uint64_t v515 = 0;
                }
                long long v76 = &v513[v515];
                v71 += 4 * v515 + 4 * v740;
                unint64_t v68 = v67;
                float v22 = v76;
              }
              else
              {
                v22 += v740;
                v68 += v41;
              }
              v77 += v746;
              v69 += v748;
              --v755[0];
            }
            while (v755[0]);
          }
        }
        else
        {
          uint64_t v503 = v42;
          char v67 = v742;
          do
          {
            int v504 = v765[0];
            do
            {
              unsigned int *v77 = *v22;
              v505 = &v22[v733];
              if ((unint64_t)v505 >= v71) {
                uint64_t v506 = -(uint64_t)v735;
              }
              else {
                uint64_t v506 = 0;
              }
              v68 += v503 + v506;
              float v22 = &v505[v506];
              v77 += v733;
              --v504;
            }
            while (v504);
            if (v741)
            {
              v507 = &v76[v740];
              if (v507 >= v741) {
                uint64_t v508 = -(v41 * v734);
              }
              else {
                uint64_t v508 = 0;
              }
              v67 += v41 + v508;
              if (v507 >= v741) {
                uint64_t v509 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v509 = 0;
              }
              long long v76 = &v507[v509];
              v71 += 4 * v509 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
        }
        goto LABEL_870;
      case 2:
        if (v27)
        {
          uint64_t v96 = v42;
          char v67 = v742;
          do
          {
            int v97 = v765[0];
            do
            {
              uint64_t v98 = *v68;
              if (*v68)
              {
                if (v98 == 255)
                {
                  unsigned int *v77 = *v22;
                  __int8 v99 = *v68;
                }
                else
                {
                  uint32x2_t v100 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v98 ^ 0xFF));
                  *(uint32x2_t *)v101.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v100, v100, 8uLL), (int32x2_t)0x100000001), 8uLL);
                  unint64_t v102 = v101.u32[0] | ((unint64_t)(((*v77 & 0x3FF) * (v98 ^ 0xFF)
                                                          + (((*v77 & 0x3FF) * (v98 ^ 0xFF)) >> 8)
                                                          + 1) >> 8) << 32);
                  v101.i32[0] = (*v69 * (v98 ^ 0xFF)
                               + ((*v69 * (v98 ^ 0xFF)) >> 8)
                               + 1) >> 8;
                  v101.i64[1] = v102;
                  int8x8_t v103 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                  unint64_t v104 = v103.u32[0] | ((unint64_t)(*v22 & 0x3FF) << 32);
                  v105.i64[0] = v98 | ((unint64_t)v103.u32[1] << 32);
                  v105.i64[1] = v104;
                  int64x2_t v106 = vaddq_s64(v101, v105);
                  __int8 v99 = v106.i8[0];
                  unsigned int *v77 = ((unint64_t)v106.i64[0] >> 12) & 0x3FF00000 | v106.i16[6] & 0x3FF | ((v106.i16[4] & 0x3FF) << 10) | 0xC0000000;
                }
                *unint64_t v69 = v99;
              }
              v69 += (int)v27;
              v107 = &v22[v733];
              if ((unint64_t)v107 >= v71) {
                uint64_t v108 = -(uint64_t)v735;
              }
              else {
                uint64_t v108 = 0;
              }
              v68 += v96 + v108;
              float v22 = &v107[v108];
              v77 += v733;
              --v97;
            }
            while (v97);
            if (v741)
            {
              v109 = &v76[v740];
              if (v109 >= v741) {
                uint64_t v110 = -(v41 * v734);
              }
              else {
                uint64_t v110 = 0;
              }
              v67 += v41 + v110;
              if (v109 >= v741) {
                uint64_t v111 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v111 = 0;
              }
              long long v76 = &v109[v111];
              v71 += 4 * v111 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
        }
        else
        {
          uint64_t v433 = v42;
          char v67 = v742;
          do
          {
            int v434 = v765[0];
            do
            {
              int v435 = *v68;
              if (*v68)
              {
                if (v435 == 255)
                {
                  unsigned int v436 = *v22;
                }
                else
                {
                  unsigned int v437 = v435 ^ 0xFF;
                  uint32x2_t v438 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v437));
                  int8x8_t v439 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v438, v438, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v436 = *v22
                       - 0x40000000
                       + (v439.i32[0] | (((*v77 & 0x3FF) * v437 + (((*v77 & 0x3FF) * v437) >> 8) + 1) >> 8) | v439.i32[1]);
                }
                unsigned int *v77 = v436;
              }
              v440 = &v22[v733];
              if ((unint64_t)v440 >= v71) {
                uint64_t v441 = -(uint64_t)v735;
              }
              else {
                uint64_t v441 = 0;
              }
              v68 += v433 + v441;
              float v22 = &v440[v441];
              v77 += v733;
              --v434;
            }
            while (v434);
            if (v741)
            {
              v442 = &v76[v740];
              if (v442 >= v741) {
                uint64_t v443 = -(v41 * v734);
              }
              else {
                uint64_t v443 = 0;
              }
              v67 += v41 + v443;
              if (v442 >= v741) {
                uint64_t v444 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v444 = 0;
              }
              long long v76 = &v442[v444];
              v71 += 4 * v444 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
        }
        goto LABEL_870;
      case 3:
        if (v42)
        {
          uint64_t v112 = v42;
          char v67 = v742;
          do
          {
            int v113 = v765[0];
            do
            {
              unsigned int v114 = *v69;
              if (v114 == 255)
              {
                unsigned int *v77 = *v22;
                LOBYTE(v115) = *v68;
              }
              else if (*v69)
              {
                unsigned int v115 = (*v68 * v114 + ((*v68 * v114) >> 8) + 1) >> 8;
                uint32x2_t v116 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v114));
                int8x8_t v117 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v116, v116, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int *v77 = v117.i32[0] | (((*v22 & 0x3FF) * v114 + (((*v22 & 0x3FF) * v114) >> 8) + 1) >> 8) | v117.i32[1] | 0xC0000000;
              }
              else
              {
                LOBYTE(v115) = 0;
                unsigned int *v77 = 0;
              }
              *unint64_t v69 = v115;
              v69 += (int)v27;
              v118 = &v22[v733];
              if ((unint64_t)v118 >= v71) {
                uint64_t v119 = -(uint64_t)v735;
              }
              else {
                uint64_t v119 = 0;
              }
              v68 += v112 + v119;
              float v22 = &v118[v119];
              v77 += v733;
              --v113;
            }
            while (v113);
            if (v741)
            {
              v120 = &v76[v740];
              if (v120 >= v741) {
                uint64_t v121 = -(v41 * v734);
              }
              else {
                uint64_t v121 = 0;
              }
              v67 += v41 + v121;
              if (v120 >= v741) {
                uint64_t v122 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v122 = 0;
              }
              long long v76 = &v120[v122];
              v71 += 4 * v122 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
        }
        else
        {
          char v67 = v742;
          do
          {
            int v445 = v765[0];
            do
            {
              unsigned int v446 = *v69;
              if (*v69)
              {
                if (v446 == 255)
                {
                  unsigned int v446 = *v22;
                }
                else
                {
                  uint32x2_t v447 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v446));
                  int8x8_t v448 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v447, v447, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v446 = *v22
                       - (v448.i32[0] | (((*v22 & 0x3FF) * v446 + (((*v22 & 0x3FF) * v446) >> 8) + 1) >> 8) | v448.i32[1])
                       + 0x40000000;
                }
              }
              unsigned int *v77 = v446;
              v69 += (int)v27;
              v449 = &v22[v733];
              if ((unint64_t)v449 >= v71) {
                uint64_t v450 = -(uint64_t)v735;
              }
              else {
                uint64_t v450 = 0;
              }
              v68 += v450;
              float v22 = &v449[v450];
              v77 += v733;
              --v445;
            }
            while (v445);
            if (v741)
            {
              v451 = &v76[v740];
              if (v451 >= v741) {
                uint64_t v452 = -(v41 * v734);
              }
              else {
                uint64_t v452 = 0;
              }
              v67 += v41 + v452;
              if (v451 >= v741) {
                uint64_t v453 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v453 = 0;
              }
              long long v76 = &v451[v453];
              v71 += 4 * v453 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
        }
        goto LABEL_870;
      case 4:
        do
        {
          int v123 = v765[0];
          do
          {
            if (~*v69 == 255)
            {
              if (v42) {
                LOBYTE(v124) = *v68;
              }
              else {
                LOBYTE(v124) = -1;
              }
            }
            else if (*v69 == -1)
            {
              LOBYTE(v124) = 0;
              unsigned int *v77 = 0;
            }
            else
            {
              if (v42) {
                int v125 = *v68;
              }
              else {
                int v125 = 255;
              }
              unsigned int v126 = ~*v69;
              uint32x2_t v127 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v126));
              int8x8_t v128 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v127, v127, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
              unsigned __int32 v129 = v128.i32[0] | (((*v22 & 0x3FF) * v126 + (((*v22 & 0x3FF) * v126) >> 8) + 1) >> 8);
              unsigned int v124 = (v125 * v126 + ((v125 * v126) >> 8) + 1) >> 8;
              unsigned int *v77 = v129 | v128.i32[1] | 0xC0000000;
            }
            *unint64_t v69 = v124;
            v69 += (int)v27;
            v130 = &v22[v733];
            if ((unint64_t)v130 >= v71) {
              uint64_t v131 = -(uint64_t)v735;
            }
            else {
              uint64_t v131 = 0;
            }
            v68 += v42 + v131;
            float v22 = &v130[v131];
            v77 += v733;
            --v123;
          }
          while (v123);
          if (v741)
          {
            v132 = &v76[v740];
            if (v132 >= v741) {
              uint64_t v133 = -(v41 * v734);
            }
            else {
              uint64_t v133 = 0;
            }
            unint64_t v68 = &v742[v41 + v133];
            if (v132 >= v741) {
              uint64_t v134 = -(uint64_t)(v740 * v734);
            }
            else {
              uint64_t v134 = 0;
            }
            long long v76 = &v132[v134];
            v71 += 4 * v134 + 4 * v740;
            v742 += v41 + v133;
            float v22 = v76;
          }
          else
          {
            v22 += v740;
            v68 += v41;
          }
          v77 += v746;
          v69 += v748;
          --v755[0];
        }
        while (v755[0]);
        goto LABEL_341;
      case 5:
        v744 = v76;
        uint64_t v135 = (int)v27;
        uint64_t v136 = v42;
        char v67 = v742;
        do
        {
          int v137 = v765[0];
          do
          {
            unsigned int v138 = *v69;
            int v139 = *v68;
            unsigned int v140 = v139 * v138 + ((v139 * v138) >> 8) + 1;
            unsigned int v141 = v139 ^ 0xFF;
            unsigned int v142 = ((v141 * v138 + ((v141 * v138) >> 8) + 1) >> 8) + (v140 >> 8);
            if (v142 >= 0xFF) {
              LOBYTE(v142) = -1;
            }
            unsigned int v143 = (((*v77 & 0x3FF) * v141 + (((*v77 & 0x3FF) * v141) >> 8) + 1) >> 8)
                 + (((*v22 & 0x3FF) * v138 + (((*v22 & 0x3FF) * v138) >> 8) + 1) >> 8);
            if (v143 >= 0x3FF) {
              unsigned int v143 = 1023;
            }
            uint32x2_t v144 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v138));
            uint32x2_t v145 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v141));
            int8x8_t v146 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v145, v145, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v144, v144, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            unsigned int *v77 = vorr_s8(v146, (int8x8_t)vdup_lane_s32((int32x2_t)v146, 1)).u32[0] | v143 | 0xC0000000;
            *unint64_t v69 = v142;
            v69 += v135;
            v147 = &v22[v733];
            if ((unint64_t)v147 >= v71) {
              uint64_t v148 = -(uint64_t)v735;
            }
            else {
              uint64_t v148 = 0;
            }
            v68 += v136 + v148;
            float v22 = &v147[v148];
            v77 += v733;
            --v137;
          }
          while (v137);
          if (v741)
          {
            v149 = &v744[v740];
            if (v149 >= v741) {
              uint64_t v150 = -(v41 * v734);
            }
            else {
              uint64_t v150 = 0;
            }
            v67 += v41 + v150;
            if (v149 >= v741) {
              uint64_t v151 = -(uint64_t)(v740 * v734);
            }
            else {
              uint64_t v151 = 0;
            }
            v152 = &v149[v151];
            v71 += 4 * v151 + 4 * v740;
            unint64_t v68 = v67;
            float v22 = v152;
          }
          else
          {
            v22 += v740;
            v68 += v41;
            v152 = v744;
          }
          v744 = v152;
          v77 += v746;
          v69 += v748;
          --v755[0];
        }
        while (v755[0]);
        goto LABEL_871;
      case 6:
        do
        {
          int v153 = v765[0];
          do
          {
            uint64_t v154 = *v69;
            if ((_BYTE)v154 != 0xFF)
            {
              if (~(_BYTE)v154 == 255)
              {
                unsigned int *v77 = *v22;
                if (v42) {
                  char v155 = *v68;
                }
                else {
                  char v155 = -1;
                }
              }
              else
              {
                if (v42) {
                  int v156 = *v68;
                }
                else {
                  int v156 = 255;
                }
                unsigned int v157 = ~(_BYTE)v154;
                uint32x2_t v158 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v157));
                *(uint32x2_t *)v159.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v158, v158, 8uLL), (int32x2_t)0x100000001), 8uLL);
                unint64_t v160 = v159.u32[0] | ((unint64_t)(((*v22 & 0x3FF) * v157 + (((*v22 & 0x3FF) * v157) >> 8) + 1) >> 8) << 32);
                v159.i32[0] = (v156 * v157 + ((v156 * v157) >> 8) + 1) >> 8;
                v159.i64[1] = v160;
                int8x8_t v161 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                unint64_t v162 = v161.u32[0] | ((unint64_t)(*v77 & 0x3FF) << 32);
                v163.i64[0] = v154 | ((unint64_t)v161.u32[1] << 32);
                v163.i64[1] = v162;
                int64x2_t v164 = vaddq_s64(v159, v163);
                char v155 = v164.i8[0];
                unsigned int *v77 = ((unint64_t)v164.i64[0] >> 12) & 0x3FF00000 | v164.i16[6] & 0x3FF | ((v164.i16[4] & 0x3FF) << 10) | 0xC0000000;
              }
              *unint64_t v69 = v155;
            }
            v69 += (int)v27;
            v165 = &v22[v733];
            if ((unint64_t)v165 >= v71) {
              uint64_t v166 = -(uint64_t)v735;
            }
            else {
              uint64_t v166 = 0;
            }
            v68 += v42 + v166;
            float v22 = &v165[v166];
            v77 += v733;
            --v153;
          }
          while (v153);
          if (v741)
          {
            v167 = &v76[v740];
            if (v167 >= v741) {
              uint64_t v168 = -(v41 * v734);
            }
            else {
              uint64_t v168 = 0;
            }
            unint64_t v68 = &v742[v41 + v168];
            if (v167 >= v741) {
              uint64_t v169 = -(uint64_t)(v740 * v734);
            }
            else {
              uint64_t v169 = 0;
            }
            long long v76 = &v167[v169];
            v71 += 4 * v169 + 4 * v740;
            v742 += v41 + v168;
            float v22 = v76;
          }
          else
          {
            v22 += v740;
            v68 += v41;
          }
          v77 += v746;
          v69 += v748;
          --v755[0];
        }
        while (v755[0]);
        goto LABEL_341;
      case 7:
        if (v27)
        {
          uint64_t v170 = v42;
          char v67 = v742;
          do
          {
            int v171 = v765[0];
            do
            {
              unsigned int v172 = *v68;
              if (v172 != 255)
              {
                if (*v68)
                {
                  unsigned int v173 = (*v69 * v172 + ((*v69 * v172) >> 8) + 1) >> 8;
                  uint32x2_t v174 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v172));
                  int8x8_t v175 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v174, v174, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int *v77 = v175.i32[0] | (((*v77 & 0x3FF) * v172 + (((*v77 & 0x3FF) * v172) >> 8) + 1) >> 8) | v175.i32[1] | 0xC0000000;
                }
                else
                {
                  LOBYTE(v173) = 0;
                  unsigned int *v77 = 0;
                }
                *unint64_t v69 = v173;
              }
              v69 += (int)v27;
              v176 = &v22[v733];
              if ((unint64_t)v176 >= v71) {
                uint64_t v177 = -(uint64_t)v735;
              }
              else {
                uint64_t v177 = 0;
              }
              v68 += v170 + v177;
              float v22 = &v176[v177];
              v77 += v733;
              --v171;
            }
            while (v171);
            if (v741)
            {
              v178 = &v76[v740];
              if (v178 >= v741) {
                uint64_t v179 = -(v41 * v734);
              }
              else {
                uint64_t v179 = 0;
              }
              v67 += v41 + v179;
              if (v178 >= v741) {
                uint64_t v180 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v180 = 0;
              }
              long long v76 = &v178[v180];
              v71 += 4 * v180 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
LABEL_870:
          v744 = v76;
LABEL_871:
          uint64_t v66 = v736;
          float v22 = (unsigned int *)v737;
          if (!v736) {
            return 1;
          }
          goto LABEL_872;
        }
        uint64_t v454 = v42;
        char v67 = v742;
LABEL_733:
        int v455 = v765[0];
        while (1)
        {
          unsigned int v456 = *v68;
          if (!*v68) {
            goto LABEL_737;
          }
          if (v456 != 255) {
            break;
          }
LABEL_738:
          v459 = &v22[v733];
          if ((unint64_t)v459 >= v71) {
            uint64_t v460 = -(uint64_t)v735;
          }
          else {
            uint64_t v460 = 0;
          }
          v68 += v454 + v460;
          float v22 = &v459[v460];
          v77 += v733;
          if (!--v455)
          {
            if (v741)
            {
              v461 = &v76[v740];
              if (v461 >= v741) {
                uint64_t v462 = -(v41 * v734);
              }
              else {
                uint64_t v462 = 0;
              }
              v67 += v41 + v462;
              if (v461 >= v741) {
                uint64_t v463 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v463 = 0;
              }
              long long v76 = &v461[v463];
              v71 += 4 * v463 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            if (!--v755[0]) {
              goto LABEL_870;
            }
            goto LABEL_733;
          }
        }
        uint32x2_t v457 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v456));
        int8x8_t v458 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v457, v457, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
        unsigned int v456 = *v77
             - (v458.i32[0] | (((*v77 & 0x3FF) * v456 + (((*v77 & 0x3FF) * v456) >> 8) + 1) >> 8) | v458.i32[1])
             + 0x40000000;
LABEL_737:
        unsigned int *v77 = v456;
        goto LABEL_738;
      case 8:
        if (v27)
        {
          uint64_t v181 = v42;
          char v67 = v742;
          do
          {
            int v182 = v765[0];
            do
            {
              if (~*v68 != 255)
              {
                if (*v68 == 0xFF)
                {
                  LOBYTE(v183) = 0;
                  unsigned int *v77 = 0;
                }
                else
                {
                  unsigned int v184 = ~*v68;
                  unsigned int v183 = (*v69 * v184 + ((*v69 * v184) >> 8) + 1) >> 8;
                  uint32x2_t v185 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v184));
                  int8x8_t v186 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v185, v185, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int *v77 = v186.i32[0] | (((*v77 & 0x3FF) * v184 + (((*v77 & 0x3FF) * v184) >> 8) + 1) >> 8) | v186.i32[1] | 0xC0000000;
                }
                *unint64_t v69 = v183;
              }
              v69 += (int)v27;
              v187 = &v22[v733];
              if ((unint64_t)v187 >= v71) {
                uint64_t v188 = -(uint64_t)v735;
              }
              else {
                uint64_t v188 = 0;
              }
              v68 += v181 + v188;
              float v22 = &v187[v188];
              v77 += v733;
              --v182;
            }
            while (v182);
            if (v741)
            {
              v189 = &v76[v740];
              if (v189 >= v741) {
                uint64_t v190 = -(v41 * v734);
              }
              else {
                uint64_t v190 = 0;
              }
              v67 += v41 + v190;
              if (v189 >= v741) {
                uint64_t v191 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v191 = 0;
              }
              long long v76 = &v189[v191];
              v71 += 4 * v191 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
          goto LABEL_870;
        }
        uint64_t v464 = v42;
        char v67 = v742;
LABEL_754:
        int v465 = v765[0];
        while (1)
        {
          unsigned int v466 = *v68 ^ 0xFF;
          if (!v466) {
            goto LABEL_758;
          }
          if (v466 != 255) {
            break;
          }
LABEL_759:
          v469 = &v22[v733];
          if ((unint64_t)v469 >= v71) {
            uint64_t v470 = -(uint64_t)v735;
          }
          else {
            uint64_t v470 = 0;
          }
          v68 += v464 + v470;
          float v22 = &v469[v470];
          v77 += v733;
          if (!--v465)
          {
            if (v741)
            {
              v471 = &v76[v740];
              if (v471 >= v741) {
                uint64_t v472 = -(v41 * v734);
              }
              else {
                uint64_t v472 = 0;
              }
              v67 += v41 + v472;
              if (v471 >= v741) {
                uint64_t v473 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v473 = 0;
              }
              long long v76 = &v471[v473];
              v71 += 4 * v473 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            if (!--v755[0]) {
              goto LABEL_870;
            }
            goto LABEL_754;
          }
        }
        uint32x2_t v467 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v466));
        int8x8_t v468 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v467, v467, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
        unsigned int v466 = *v77
             - (v468.i32[0] | (((*v77 & 0x3FF) * v466 + (((*v77 & 0x3FF) * v466) >> 8) + 1) >> 8) | v468.i32[1])
             + 0x40000000;
LABEL_758:
        unsigned int *v77 = v466;
        goto LABEL_759;
      case 9:
        v744 = v76;
        uint64_t v192 = (int)v27;
        uint64_t v193 = v42;
        char v67 = v742;
        do
        {
          int v194 = v765[0];
          do
          {
            int v195 = *v69;
            unsigned int v196 = *v68;
            unsigned int v197 = v195 ^ 0xFF;
            unsigned int v198 = ((v196 * v195 + ((v196 * v195) >> 8) + 1) >> 8) + ((v196 * v197 + ((v196 * v197) >> 8) + 1) >> 8);
            if (v198 >= 0xFF) {
              LOBYTE(v198) = -1;
            }
            unsigned int v199 = (((*v77 & 0x3FF) * v196 + (((*v77 & 0x3FF) * v196) >> 8) + 1) >> 8)
                 + (((*v22 & 0x3FF) * v197 + (((*v22 & 0x3FF) * v197) >> 8) + 1) >> 8);
            if (v199 >= 0x3FF) {
              unsigned int v199 = 1023;
            }
            uint32x2_t v200 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v197));
            uint32x2_t v201 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v196));
            int8x8_t v202 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v201, v201, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v200, v200, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            unsigned int *v77 = vorr_s8(v202, (int8x8_t)vdup_lane_s32((int32x2_t)v202, 1)).u32[0] | v199 | 0xC0000000;
            *unint64_t v69 = v198;
            v69 += v192;
            v203 = &v22[v733];
            if ((unint64_t)v203 >= v71) {
              uint64_t v204 = -(uint64_t)v735;
            }
            else {
              uint64_t v204 = 0;
            }
            v68 += v193 + v204;
            float v22 = &v203[v204];
            v77 += v733;
            --v194;
          }
          while (v194);
          if (v741)
          {
            v205 = &v744[v740];
            if (v205 >= v741) {
              uint64_t v206 = -(v41 * v734);
            }
            else {
              uint64_t v206 = 0;
            }
            v67 += v41 + v206;
            if (v205 >= v741) {
              uint64_t v207 = -(uint64_t)(v740 * v734);
            }
            else {
              uint64_t v207 = 0;
            }
            v208 = &v205[v207];
            v71 += 4 * v207 + 4 * v740;
            unint64_t v68 = v67;
            float v22 = v208;
          }
          else
          {
            v22 += v740;
            v68 += v41;
            v208 = v744;
          }
          v744 = v208;
          v77 += v746;
          v69 += v748;
          --v755[0];
        }
        while (v755[0]);
        goto LABEL_871;
      case 10:
        v744 = v76;
        uint64_t v209 = (int)v27;
        uint64_t v210 = v42;
        char v67 = v742;
        do
        {
          int v211 = v765[0];
          do
          {
            int v212 = *v69;
            int v213 = *v68;
            unsigned int v214 = v212 ^ 0xFF;
            unsigned int v215 = v213 * v214 + ((v213 * v214) >> 8) + 1;
            unsigned int v216 = v213 ^ 0xFF;
            unsigned int v217 = ((v216 * v212 + ((v216 * v212) >> 8) + 1) >> 8) + (v215 >> 8);
            if (v217 >= 0xFF) {
              LOBYTE(v217) = -1;
            }
            unsigned int v218 = (((*v77 & 0x3FF) * v216 + (((*v77 & 0x3FF) * v216) >> 8) + 1) >> 8)
                 + (((*v22 & 0x3FF) * v214 + (((*v22 & 0x3FF) * v214) >> 8) + 1) >> 8);
            if (v218 >= 0x3FF) {
              unsigned int v218 = 1023;
            }
            uint32x2_t v219 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v214));
            uint32x2_t v220 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v216));
            int8x8_t v221 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v220, v220, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v219, v219, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            unsigned int *v77 = vorr_s8(v221, (int8x8_t)vdup_lane_s32((int32x2_t)v221, 1)).u32[0] | v218 | 0xC0000000;
            *unint64_t v69 = v217;
            v69 += v209;
            v222 = &v22[v733];
            if ((unint64_t)v222 >= v71) {
              uint64_t v223 = -(uint64_t)v735;
            }
            else {
              uint64_t v223 = 0;
            }
            v68 += v210 + v223;
            float v22 = &v222[v223];
            v77 += v733;
            --v211;
          }
          while (v211);
          if (v741)
          {
            v224 = &v744[v740];
            if (v224 >= v741) {
              uint64_t v225 = -(v41 * v734);
            }
            else {
              uint64_t v225 = 0;
            }
            v67 += v41 + v225;
            if (v224 >= v741) {
              uint64_t v226 = -(uint64_t)(v740 * v734);
            }
            else {
              uint64_t v226 = 0;
            }
            v227 = &v224[v226];
            v71 += 4 * v226 + 4 * v740;
            unint64_t v68 = v67;
            float v22 = v227;
          }
          else
          {
            v22 += v740;
            v68 += v41;
            v227 = v744;
          }
          v744 = v227;
          v77 += v746;
          v69 += v748;
          --v755[0];
        }
        while (v755[0]);
        goto LABEL_871;
      case 11:
        if (v27)
        {
          do
          {
            int v228 = v765[0];
            do
            {
              if (v42) {
                int v229 = *v68;
              }
              else {
                int v229 = 255;
              }
              int8x8_t v230 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6);
              int8x8_t v231 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6);
              unsigned int v232 = v229 + *v69;
              if (v232 >= 0xFF) {
                LOBYTE(v232) = -1;
              }
              unsigned int v233 = (*v22 & 0x3FF) + (*v77 & 0x3FF);
              if (v233 >= 0x3FF) {
                unsigned int v233 = 1023;
              }
              int8x8_t v234 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8(v231, (int8x8_t)0x300000003), (int32x2_t)vand_s8(v230, (int8x8_t)0x300000003)), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              unsigned int *v77 = vorr_s8(v234, (int8x8_t)vdup_lane_s32((int32x2_t)v234, 1)).u32[0] | v233 | 0xC0000000;
              *unint64_t v69 = v232;
              v69 += (int)v27;
              v235 = &v22[v733];
              if ((unint64_t)v235 >= v71) {
                uint64_t v236 = -(uint64_t)v735;
              }
              else {
                uint64_t v236 = 0;
              }
              v68 += v42 + v236;
              float v22 = &v235[v236];
              v77 += v733;
              --v228;
            }
            while (v228);
            if (v741)
            {
              v237 = &v76[v740];
              if (v237 >= v741) {
                uint64_t v238 = -(v41 * v734);
              }
              else {
                uint64_t v238 = 0;
              }
              unint64_t v68 = &v742[v41 + v238];
              if (v237 >= v741) {
                uint64_t v239 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v239 = 0;
              }
              long long v76 = &v237[v239];
              v71 += 4 * v239 + 4 * v740;
              v742 += v41 + v238;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
LABEL_341:
          v744 = v76;
          goto LABEL_687;
        }
        uint64_t v474 = v42;
        char v67 = v742;
        do
        {
          int v475 = v765[0];
          do
          {
            unsigned int v476 = (*v22 & 0x3FF) + (*v77 & 0x3FF);
            if (v476 >= 0x3FF) {
              unsigned int v476 = 1023;
            }
            int8x8_t v477 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003)), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            unsigned int *v77 = vorr_s8(v477, (int8x8_t)vdup_lane_s32((int32x2_t)v477, 1)).u32[0] | v476 | 0xC0000000;
            v478 = &v22[v733];
            if ((unint64_t)v478 >= v71) {
              uint64_t v479 = -(uint64_t)v735;
            }
            else {
              uint64_t v479 = 0;
            }
            v68 += v474 + v479;
            float v22 = &v478[v479];
            v77 += v733;
            --v475;
          }
          while (v475);
          if (v741)
          {
            v480 = &v76[v740];
            if (v480 >= v741) {
              uint64_t v481 = -(v41 * v734);
            }
            else {
              uint64_t v481 = 0;
            }
            v67 += v41 + v481;
            if (v480 >= v741) {
              uint64_t v482 = -(uint64_t)(v740 * v734);
            }
            else {
              uint64_t v482 = 0;
            }
            long long v76 = &v480[v482];
            v71 += 4 * v482 + 4 * v740;
            unint64_t v68 = v67;
            float v22 = v76;
          }
          else
          {
            v22 += v740;
            v68 += v41;
          }
          v77 += v746;
          v69 += v748;
          --v755[0];
        }
        while (v755[0]);
        goto LABEL_870;
      case 12:
        if (!v27)
        {
          uint64_t v483 = v42;
          char v67 = v742;
          do
          {
            int v484 = v765[0];
            do
            {
              unsigned int v485 = (*v22 & 0x3FF) + (*v77 & 0x3FF);
              if (v485 >= 0x3FF) {
                unsigned int v485 = 1023;
              }
              int8x8_t v486 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003)), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              unsigned int *v77 = vorr_s8(v486, (int8x8_t)vdup_lane_s32((int32x2_t)v486, 1)).u32[0] | v485 | 0xC0000000;
              v487 = &v22[v733];
              if ((unint64_t)v487 >= v71) {
                uint64_t v488 = -(uint64_t)v735;
              }
              else {
                uint64_t v488 = 0;
              }
              v68 += v483 + v488;
              float v22 = &v487[v488];
              v77 += v733;
              --v484;
            }
            while (v484);
            if (v741)
            {
              v489 = &v76[v740];
              if (v489 >= v741) {
                uint64_t v490 = -(v41 * v734);
              }
              else {
                uint64_t v490 = 0;
              }
              v67 += v41 + v490;
              if (v489 >= v741) {
                uint64_t v491 = -(uint64_t)(v740 * v734);
              }
              else {
                uint64_t v491 = 0;
              }
              long long v76 = &v489[v491];
              v71 += 4 * v491 + 4 * v740;
              unint64_t v68 = v67;
              float v22 = v76;
            }
            else
            {
              v22 += v740;
              v68 += v41;
            }
            v77 += v746;
            v69 += v748;
            --v755[0];
          }
          while (v755[0]);
          goto LABEL_870;
        }
        do
        {
          int v240 = v765[0];
          do
          {
            if (v42) {
              int v241 = *v68;
            }
            else {
              int v241 = 255;
            }
            int8x8_t v242 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v77), (uint32x2_t)0xFFFFFFECFFFFFFF6);
            int8x8_t v243 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v22), (uint32x2_t)0xFFFFFFECFFFFFFF6);
            unsigned int v244 = v241 + *v69;
            if (v244 >= 0xFF) {
              LOBYTE(v244) = -1;
            }
            unsigned int v245 = (*v22 & 0x3FF) + (*v77 & 0x3FF);
            if (v245 >= 0x3FF) {
              unsigned int v245 = 1023;
            }
            int8x8_t v246 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8(v243, (int8x8_t)0x300000003), (int32x2_t)vand_s8(v242, (int8x8_t)0x300000003)), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            unsigned int *v77 = vorr_s8(v246, (int8x8_t)vdup_lane_s32((int32x2_t)v246, 1)).u32[0] | v245 | 0xC0000000;
            *unint64_t v69 = v244;
            v69 += (int)v27;
            v247 = &v22[v733];
            if ((unint64_t)v247 >= v71) {
              uint64_t v248 = -(uint64_t)v735;
            }
            else {
              uint64_t v248 = 0;
            }
            v68 += v42 + v248;
            float v22 = &v247[v248];
            v77 += v733;
            --v240;
          }
          while (v240);
          if (v741)
          {
            v249 = &v76[v740];
            if (v249 >= v741) {
              uint64_t v250 = -(v41 * v734);
            }
            else {
              uint64_t v250 = 0;
            }
            unint64_t v68 = &v742[v41 + v250];
            if (v249 >= v741) {
              uint64_t v251 = -(uint64_t)(v740 * v734);
            }
            else {
              uint64_t v251 = 0;
            }
            long long v76 = &v249[v251];
            v71 += 4 * v251 + 4 * v740;
            v742 += v41 + v250;
            float v22 = v76;
          }
          else
          {
            v22 += v740;
            v68 += v41;
          }
          v77 += v746;
          v69 += v748;
          --v755[0];
        }
        while (v755[0]);
        goto LABEL_341;
      case 13:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v252 = (int)v27;
        uint64_t v253 = v42;
        uint64_t v711 = -(v41 * v734);
        while (1)
        {
          int v254 = v765[0];
          unint64_t v255 = v71;
          do
          {
            if (v42)
            {
              int v256 = *v68;
              if (!*v68) {
                goto LABEL_352;
              }
              if (v27) {
                goto LABEL_347;
              }
            }
            else
            {
              int v256 = 255;
              if (v27)
              {
LABEL_347:
                if (*v69)
                {
                  unint64_t v257 = PDAmultiplyPDA(*v77, *v69, *v22, v256);
                  unint64_t v71 = v255;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v257);
                  *unint64_t v69 = v257;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v256;
                }
                goto LABEL_352;
              }
            }
            unint64_t v258 = PDAmultiplyPDA(*v77, 255, *v22, v256);
            unint64_t v71 = v255;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v258);
LABEL_352:
            v69 += v252;
            v259 = &v22[v733];
            if ((unint64_t)v259 >= v71) {
              uint64_t v260 = -(uint64_t)v735;
            }
            else {
              uint64_t v260 = 0;
            }
            v68 += v253 + v260;
            float v22 = &v259[v260];
            v77 += v733;
            --v254;
          }
          while (v254);
          if (v741)
          {
            uint64_t v41 = v739;
            v261 = &v744[v740];
            uint64_t v262 = v711;
            if (v261 < v741) {
              uint64_t v262 = 0;
            }
            unint64_t v68 = &v742[v739 + v262];
            uint64_t v263 = -(uint64_t)(v740 * v734);
            if (v261 < v741) {
              uint64_t v263 = 0;
            }
            float v22 = &v261[v263];
            v71 += 4 * v263 + 4 * v740;
            v742 += v739 + v262;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 14:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v264 = (int)v27;
        uint64_t v265 = v42;
        uint64_t v712 = -(v41 * v734);
        while (1)
        {
          int v266 = v765[0];
          unint64_t v267 = v71;
          do
          {
            if (v42)
            {
              int v268 = *v68;
              if (!*v68) {
                goto LABEL_375;
              }
              if (v27) {
                goto LABEL_370;
              }
            }
            else
            {
              int v268 = 255;
              if (v27)
              {
LABEL_370:
                if (*v69)
                {
                  unint64_t v269 = PDAscreenPDA(*v77, *v69, *v22, v268);
                  unint64_t v71 = v267;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v269);
                  *unint64_t v69 = v269;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v268;
                }
                goto LABEL_375;
              }
            }
            unint64_t v270 = PDAscreenPDA(*v77, 255, *v22, v268);
            unint64_t v71 = v267;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v270);
LABEL_375:
            v69 += v264;
            v271 = &v22[v733];
            if ((unint64_t)v271 >= v71) {
              uint64_t v272 = -(uint64_t)v735;
            }
            else {
              uint64_t v272 = 0;
            }
            v68 += v265 + v272;
            float v22 = &v271[v272];
            v77 += v733;
            --v266;
          }
          while (v266);
          if (v741)
          {
            uint64_t v41 = v739;
            v273 = &v744[v740];
            uint64_t v274 = v712;
            if (v273 < v741) {
              uint64_t v274 = 0;
            }
            unint64_t v68 = &v742[v739 + v274];
            uint64_t v275 = -(uint64_t)(v740 * v734);
            if (v273 < v741) {
              uint64_t v275 = 0;
            }
            float v22 = &v273[v275];
            v71 += 4 * v275 + 4 * v740;
            v742 += v739 + v274;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 15:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v276 = (int)v27;
        uint64_t v277 = v42;
        uint64_t v713 = -(v41 * v734);
        while (1)
        {
          int v278 = v765[0];
          unint64_t v279 = v71;
          do
          {
            if (v42)
            {
              int v280 = *v68;
              if (!*v68) {
                goto LABEL_398;
              }
              if (v27) {
                goto LABEL_393;
              }
            }
            else
            {
              int v280 = 255;
              if (v27)
              {
LABEL_393:
                if (*v69)
                {
                  unint64_t v281 = PDAoverlayPDA(*v77, *v69, *v22, v280);
                  unint64_t v71 = v279;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v281);
                  *unint64_t v69 = v281;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v280;
                }
                goto LABEL_398;
              }
            }
            unint64_t v282 = PDAoverlayPDA(*v77, 255, *v22, v280);
            unint64_t v71 = v279;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v282);
LABEL_398:
            v69 += v276;
            v283 = &v22[v733];
            if ((unint64_t)v283 >= v71) {
              uint64_t v284 = -(uint64_t)v735;
            }
            else {
              uint64_t v284 = 0;
            }
            v68 += v277 + v284;
            float v22 = &v283[v284];
            v77 += v733;
            --v278;
          }
          while (v278);
          if (v741)
          {
            uint64_t v41 = v739;
            v285 = &v744[v740];
            uint64_t v286 = v713;
            if (v285 < v741) {
              uint64_t v286 = 0;
            }
            unint64_t v68 = &v742[v739 + v286];
            uint64_t v287 = -(uint64_t)(v740 * v734);
            if (v285 < v741) {
              uint64_t v287 = 0;
            }
            float v22 = &v285[v287];
            v71 += 4 * v287 + 4 * v740;
            v742 += v739 + v286;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 16:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v288 = (int)v27;
        uint64_t v289 = v42;
        uint64_t v714 = -(v41 * v734);
        while (1)
        {
          int v290 = v765[0];
          unint64_t v291 = v71;
          do
          {
            if (v42)
            {
              unsigned int v292 = *v68;
              if (!*v68) {
                goto LABEL_421;
              }
              if (v27) {
                goto LABEL_416;
              }
            }
            else
            {
              unsigned int v292 = 255;
              if (v27)
              {
LABEL_416:
                if (*v69)
                {
                  unint64_t v293 = PDAdarkenPDA(*v77, *v69, *v22, v292);
                  unint64_t v71 = v291;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v293);
                  *unint64_t v69 = v293;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v292;
                }
                goto LABEL_421;
              }
            }
            unint64_t v294 = PDAdarkenPDA(*v77, 0xFFu, *v22, v292);
            unint64_t v71 = v291;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v294);
LABEL_421:
            v69 += v288;
            v295 = &v22[v733];
            if ((unint64_t)v295 >= v71) {
              uint64_t v296 = -(uint64_t)v735;
            }
            else {
              uint64_t v296 = 0;
            }
            v68 += v289 + v296;
            float v22 = &v295[v296];
            v77 += v733;
            --v290;
          }
          while (v290);
          if (v741)
          {
            uint64_t v41 = v739;
            v297 = &v744[v740];
            uint64_t v298 = v714;
            if (v297 < v741) {
              uint64_t v298 = 0;
            }
            unint64_t v68 = &v742[v739 + v298];
            uint64_t v299 = -(uint64_t)(v740 * v734);
            if (v297 < v741) {
              uint64_t v299 = 0;
            }
            float v22 = &v297[v299];
            v71 += 4 * v299 + 4 * v740;
            v742 += v739 + v298;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 17:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v300 = (int)v27;
        uint64_t v301 = v42;
        uint64_t v715 = -(v41 * v734);
        while (1)
        {
          int v302 = v765[0];
          unint64_t v303 = v71;
          do
          {
            if (v42)
            {
              unsigned int v304 = *v68;
              if (!*v68) {
                goto LABEL_444;
              }
              if (v27) {
                goto LABEL_439;
              }
            }
            else
            {
              unsigned int v304 = 255;
              if (v27)
              {
LABEL_439:
                if (*v69)
                {
                  unint64_t v305 = PDAlightenPDA(*v77, *v69, *v22, v304);
                  unint64_t v71 = v303;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v305);
                  *unint64_t v69 = v305;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v304;
                }
                goto LABEL_444;
              }
            }
            unint64_t v306 = PDAlightenPDA(*v77, 0xFFu, *v22, v304);
            unint64_t v71 = v303;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v306);
LABEL_444:
            v69 += v300;
            v307 = &v22[v733];
            if ((unint64_t)v307 >= v71) {
              uint64_t v308 = -(uint64_t)v735;
            }
            else {
              uint64_t v308 = 0;
            }
            v68 += v301 + v308;
            float v22 = &v307[v308];
            v77 += v733;
            --v302;
          }
          while (v302);
          if (v741)
          {
            uint64_t v41 = v739;
            v309 = &v744[v740];
            uint64_t v310 = v715;
            if (v309 < v741) {
              uint64_t v310 = 0;
            }
            unint64_t v68 = &v742[v739 + v310];
            uint64_t v311 = -(uint64_t)(v740 * v734);
            if (v309 < v741) {
              uint64_t v311 = 0;
            }
            float v22 = &v309[v311];
            v71 += 4 * v311 + 4 * v740;
            v742 += v739 + v310;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 18:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v312 = (int)v27;
        uint64_t v313 = v42;
        uint64_t v716 = -(v41 * v734);
        while (1)
        {
          int v314 = v765[0];
          unint64_t v315 = v71;
          do
          {
            if (v42)
            {
              int v316 = *v68;
              if (!*v68) {
                goto LABEL_467;
              }
              if (v27) {
                goto LABEL_462;
              }
            }
            else
            {
              int v316 = 255;
              if (v27)
              {
LABEL_462:
                if (*v69)
                {
                  unint64_t v317 = PDAcolordodgePDA(*v77, *v69, *v22, v316);
                  unint64_t v71 = v315;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v317);
                  *unint64_t v69 = v317;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v316;
                }
                goto LABEL_467;
              }
            }
            unint64_t v318 = PDAcolordodgePDA(*v77, 255, *v22, v316);
            unint64_t v71 = v315;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v318);
LABEL_467:
            v69 += v312;
            v319 = &v22[v733];
            if ((unint64_t)v319 >= v71) {
              uint64_t v320 = -(uint64_t)v735;
            }
            else {
              uint64_t v320 = 0;
            }
            v68 += v313 + v320;
            float v22 = &v319[v320];
            v77 += v733;
            --v314;
          }
          while (v314);
          if (v741)
          {
            uint64_t v41 = v739;
            v321 = &v744[v740];
            uint64_t v322 = v716;
            if (v321 < v741) {
              uint64_t v322 = 0;
            }
            unint64_t v68 = &v742[v739 + v322];
            uint64_t v323 = -(uint64_t)(v740 * v734);
            if (v321 < v741) {
              uint64_t v323 = 0;
            }
            float v22 = &v321[v323];
            v71 += 4 * v323 + 4 * v740;
            v742 += v739 + v322;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 19:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v324 = (int)v27;
        uint64_t v325 = v42;
        uint64_t v717 = -(v41 * v734);
        while (1)
        {
          int v326 = v765[0];
          unint64_t v327 = v71;
          do
          {
            if (v42)
            {
              int v328 = *v68;
              if (!*v68) {
                goto LABEL_490;
              }
              if (v27) {
                goto LABEL_485;
              }
            }
            else
            {
              int v328 = 255;
              if (v27)
              {
LABEL_485:
                if (*v69)
                {
                  unint64_t v329 = PDAcolorburnPDA(*v77, *v69, *v22, v328);
                  unint64_t v71 = v327;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v329);
                  *unint64_t v69 = v329;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v328;
                }
                goto LABEL_490;
              }
            }
            unint64_t v330 = PDAcolorburnPDA(*v77, 255, *v22, v328);
            unint64_t v71 = v327;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v330);
LABEL_490:
            v69 += v324;
            v331 = &v22[v733];
            if ((unint64_t)v331 >= v71) {
              uint64_t v332 = -(uint64_t)v735;
            }
            else {
              uint64_t v332 = 0;
            }
            v68 += v325 + v332;
            float v22 = &v331[v332];
            v77 += v733;
            --v326;
          }
          while (v326);
          if (v741)
          {
            uint64_t v41 = v739;
            v333 = &v744[v740];
            uint64_t v334 = v717;
            if (v333 < v741) {
              uint64_t v334 = 0;
            }
            unint64_t v68 = &v742[v739 + v334];
            uint64_t v335 = -(uint64_t)(v740 * v734);
            if (v333 < v741) {
              uint64_t v335 = 0;
            }
            float v22 = &v333[v335];
            v71 += 4 * v335 + 4 * v740;
            v742 += v739 + v334;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 20:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v336 = (int)v27;
        uint64_t v337 = v42;
        uint64_t v718 = -(v41 * v734);
        while (1)
        {
          int v338 = v765[0];
          unint64_t v339 = v71;
          do
          {
            if (v42)
            {
              int v340 = *v68;
              if (!*v68) {
                goto LABEL_513;
              }
              if (v27) {
                goto LABEL_508;
              }
            }
            else
            {
              int v340 = 255;
              if (v27)
              {
LABEL_508:
                if (*v69)
                {
                  unint64_t v341 = PDAsoftlightPDA(*v77, *v69, *v22, v340);
                  unint64_t v71 = v339;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v341);
                  *unint64_t v69 = v341;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v340;
                }
                goto LABEL_513;
              }
            }
            unint64_t v342 = PDAsoftlightPDA(*v77, 255, *v22, v340);
            unint64_t v71 = v339;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v342);
LABEL_513:
            v69 += v336;
            v343 = &v22[v733];
            if ((unint64_t)v343 >= v71) {
              uint64_t v344 = -(uint64_t)v735;
            }
            else {
              uint64_t v344 = 0;
            }
            v68 += v337 + v344;
            float v22 = &v343[v344];
            v77 += v733;
            --v338;
          }
          while (v338);
          if (v741)
          {
            uint64_t v41 = v739;
            v345 = &v744[v740];
            uint64_t v346 = v718;
            if (v345 < v741) {
              uint64_t v346 = 0;
            }
            unint64_t v68 = &v742[v739 + v346];
            uint64_t v347 = -(uint64_t)(v740 * v734);
            if (v345 < v741) {
              uint64_t v347 = 0;
            }
            float v22 = &v345[v347];
            v71 += 4 * v347 + 4 * v740;
            v742 += v739 + v346;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 21:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v348 = (int)v27;
        uint64_t v349 = v42;
        uint64_t v719 = -(v41 * v734);
        while (1)
        {
          int v350 = v765[0];
          unint64_t v351 = v71;
          do
          {
            if (v42)
            {
              int v352 = *v68;
              if (!*v68) {
                goto LABEL_536;
              }
              if (v27) {
                goto LABEL_531;
              }
            }
            else
            {
              int v352 = 255;
              if (v27)
              {
LABEL_531:
                if (*v69)
                {
                  unint64_t v353 = PDAhardlightPDA(*v77, *v69, *v22, v352);
                  unint64_t v71 = v351;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v353);
                  *unint64_t v69 = v353;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v352;
                }
                goto LABEL_536;
              }
            }
            unint64_t v354 = PDAhardlightPDA(*v77, 255, *v22, v352);
            unint64_t v71 = v351;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v354);
LABEL_536:
            v69 += v348;
            v355 = &v22[v733];
            if ((unint64_t)v355 >= v71) {
              uint64_t v356 = -(uint64_t)v735;
            }
            else {
              uint64_t v356 = 0;
            }
            v68 += v349 + v356;
            float v22 = &v355[v356];
            v77 += v733;
            --v350;
          }
          while (v350);
          if (v741)
          {
            uint64_t v41 = v739;
            v357 = &v744[v740];
            uint64_t v358 = v719;
            if (v357 < v741) {
              uint64_t v358 = 0;
            }
            unint64_t v68 = &v742[v739 + v358];
            uint64_t v359 = -(uint64_t)(v740 * v734);
            if (v357 < v741) {
              uint64_t v359 = 0;
            }
            float v22 = &v357[v359];
            v71 += 4 * v359 + 4 * v740;
            v742 += v739 + v358;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 22:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v360 = (int)v27;
        uint64_t v361 = v42;
        uint64_t v720 = -(v41 * v734);
        while (1)
        {
          int v362 = v765[0];
          unint64_t v363 = v71;
          do
          {
            if (v42)
            {
              unsigned int v364 = *v68;
              if (!*v68) {
                goto LABEL_559;
              }
              if (v27) {
                goto LABEL_554;
              }
            }
            else
            {
              unsigned int v364 = 255;
              if (v27)
              {
LABEL_554:
                if (*v69)
                {
                  unint64_t v365 = PDAdifferencePDA(*v77, *v69, *v22, v364);
                  unint64_t v71 = v363;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v365);
                  *unint64_t v69 = v365;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v364;
                }
                goto LABEL_559;
              }
            }
            unint64_t v366 = PDAdifferencePDA(*v77, 0xFFu, *v22, v364);
            unint64_t v71 = v363;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v366);
LABEL_559:
            v69 += v360;
            v367 = &v22[v733];
            if ((unint64_t)v367 >= v71) {
              uint64_t v368 = -(uint64_t)v735;
            }
            else {
              uint64_t v368 = 0;
            }
            v68 += v361 + v368;
            float v22 = &v367[v368];
            v77 += v733;
            --v362;
          }
          while (v362);
          if (v741)
          {
            uint64_t v41 = v739;
            v369 = &v744[v740];
            uint64_t v370 = v720;
            if (v369 < v741) {
              uint64_t v370 = 0;
            }
            unint64_t v68 = &v742[v739 + v370];
            uint64_t v371 = -(uint64_t)(v740 * v734);
            if (v369 < v741) {
              uint64_t v371 = 0;
            }
            float v22 = &v369[v371];
            v71 += 4 * v371 + 4 * v740;
            v742 += v739 + v370;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 23:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v372 = (int)v27;
        uint64_t v373 = v42;
        uint64_t v721 = -(v41 * v734);
        while (1)
        {
          int v374 = v765[0];
          unint64_t v375 = v71;
          do
          {
            if (v42)
            {
              int v376 = *v68;
              if (!*v68) {
                goto LABEL_582;
              }
              if (v27) {
                goto LABEL_577;
              }
            }
            else
            {
              int v376 = 255;
              if (v27)
              {
LABEL_577:
                if (*v69)
                {
                  unint64_t v377 = PDAexclusionPDA(*v77, *v69, *v22, v376);
                  unint64_t v71 = v375;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v377);
                  *unint64_t v69 = v377;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v376;
                }
                goto LABEL_582;
              }
            }
            unint64_t v378 = PDAexclusionPDA(*v77, 255, *v22, v376);
            unint64_t v71 = v375;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v378);
LABEL_582:
            v69 += v372;
            v379 = &v22[v733];
            if ((unint64_t)v379 >= v71) {
              uint64_t v380 = -(uint64_t)v735;
            }
            else {
              uint64_t v380 = 0;
            }
            v68 += v373 + v380;
            float v22 = &v379[v380];
            v77 += v733;
            --v374;
          }
          while (v374);
          if (v741)
          {
            uint64_t v41 = v739;
            v381 = &v744[v740];
            uint64_t v382 = v721;
            if (v381 < v741) {
              uint64_t v382 = 0;
            }
            unint64_t v68 = &v742[v739 + v382];
            uint64_t v383 = -(uint64_t)(v740 * v734);
            if (v381 < v741) {
              uint64_t v383 = 0;
            }
            float v22 = &v381[v383];
            v71 += 4 * v383 + 4 * v740;
            v742 += v739 + v382;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 24:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v384 = (int)v27;
        uint64_t v385 = v42;
        uint64_t v722 = -(v41 * v734);
        while (1)
        {
          int v386 = v765[0];
          unint64_t v387 = v71;
          do
          {
            if (v42)
            {
              int v388 = *v68;
              if (!*v68) {
                goto LABEL_605;
              }
              if (v27) {
                goto LABEL_600;
              }
            }
            else
            {
              int v388 = 255;
              if (v27)
              {
LABEL_600:
                if (*v69)
                {
                  unint64_t v389 = PDAhuePDA(*v77, *v69, *v22, v388);
                  unint64_t v71 = v387;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v389);
                  *unint64_t v69 = v389;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v388;
                }
                goto LABEL_605;
              }
            }
            unint64_t v390 = PDAhuePDA(*v77, 255, *v22, v388);
            unint64_t v71 = v387;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v390);
LABEL_605:
            v69 += v384;
            v391 = &v22[v733];
            if ((unint64_t)v391 >= v71) {
              uint64_t v392 = -(uint64_t)v735;
            }
            else {
              uint64_t v392 = 0;
            }
            v68 += v385 + v392;
            float v22 = &v391[v392];
            v77 += v733;
            --v386;
          }
          while (v386);
          if (v741)
          {
            uint64_t v41 = v739;
            v393 = &v744[v740];
            uint64_t v394 = v722;
            if (v393 < v741) {
              uint64_t v394 = 0;
            }
            unint64_t v68 = &v742[v739 + v394];
            uint64_t v395 = -(uint64_t)(v740 * v734);
            if (v393 < v741) {
              uint64_t v395 = 0;
            }
            float v22 = &v393[v395];
            v71 += 4 * v395 + 4 * v740;
            v742 += v739 + v394;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 25:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v396 = (int)v27;
        uint64_t v397 = v42;
        uint64_t v723 = -(v41 * v734);
        while (1)
        {
          int v398 = v765[0];
          unint64_t v399 = v71;
          do
          {
            if (v42)
            {
              int v400 = *v68;
              if (!*v68) {
                goto LABEL_628;
              }
              if (v27) {
                goto LABEL_623;
              }
            }
            else
            {
              int v400 = 255;
              if (v27)
              {
LABEL_623:
                if (*v69)
                {
                  unint64_t v401 = PDAsaturationPDA(*v77, *v69, *v22, v400);
                  unint64_t v71 = v399;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v401);
                  *unint64_t v69 = v401;
                }
                else
                {
                  unsigned int *v77 = *v22;
                  *unint64_t v69 = v400;
                }
                goto LABEL_628;
              }
            }
            unint64_t v402 = PDAsaturationPDA(*v77, 255, *v22, v400);
            unint64_t v71 = v399;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v402);
LABEL_628:
            v69 += v396;
            v403 = &v22[v733];
            if ((unint64_t)v403 >= v71) {
              uint64_t v404 = -(uint64_t)v735;
            }
            else {
              uint64_t v404 = 0;
            }
            v68 += v397 + v404;
            float v22 = &v403[v404];
            v77 += v733;
            --v398;
          }
          while (v398);
          if (v741)
          {
            uint64_t v41 = v739;
            v405 = &v744[v740];
            uint64_t v406 = v723;
            if (v405 < v741) {
              uint64_t v406 = 0;
            }
            unint64_t v68 = &v742[v739 + v406];
            uint64_t v407 = -(uint64_t)(v740 * v734);
            if (v405 < v741) {
              uint64_t v407 = 0;
            }
            float v22 = &v405[v407];
            v71 += 4 * v407 + 4 * v740;
            v742 += v739 + v406;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 26:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v408 = (int)v27;
        uint64_t v409 = v42;
        uint64_t v724 = -(v41 * v734);
        while (1)
        {
          int v410 = v765[0];
          unint64_t v411 = v71;
          do
          {
            if (v42)
            {
              unsigned int v412 = *v68;
              if (!*v68) {
                goto LABEL_651;
              }
              if (v27) {
                goto LABEL_646;
              }
            }
            else
            {
              unsigned int v412 = 255;
              if (v27)
              {
LABEL_646:
                unsigned int v413 = *v22;
                if (*v69)
                {
                  unint64_t v414 = PDAluminosityPDA(v413, v412, *v77, *v69);
                  unint64_t v71 = v411;
                  int v42 = v751;
                  LODWORD(v27) = v753;
                  unsigned int *v77 = HIDWORD(v414);
                  *unint64_t v69 = v414;
                }
                else
                {
                  unsigned int *v77 = v413;
                  *unint64_t v69 = v412;
                }
                goto LABEL_651;
              }
            }
            unint64_t v415 = PDAluminosityPDA(*v22, v412, *v77, 0xFFu);
            unint64_t v71 = v411;
            int v42 = v751;
            LODWORD(v27) = v753;
            unsigned int *v77 = HIDWORD(v415);
LABEL_651:
            v69 += v408;
            v416 = &v22[v733];
            if ((unint64_t)v416 >= v71) {
              uint64_t v417 = -(uint64_t)v735;
            }
            else {
              uint64_t v417 = 0;
            }
            v68 += v409 + v417;
            float v22 = &v416[v417];
            v77 += v733;
            --v410;
          }
          while (v410);
          if (v741)
          {
            uint64_t v41 = v739;
            v418 = &v744[v740];
            uint64_t v419 = v724;
            if (v418 < v741) {
              uint64_t v419 = 0;
            }
            unint64_t v68 = &v742[v739 + v419];
            uint64_t v420 = -(uint64_t)(v740 * v734);
            if (v418 < v741) {
              uint64_t v420 = 0;
            }
            float v22 = &v418[v420];
            v71 += 4 * v420 + 4 * v740;
            v742 += v739 + v419;
            v744 = v22;
          }
          else
          {
            uint64_t v41 = v739;
            v22 += v740;
            v68 += v739;
          }
          v77 += v746;
          v69 += v748;
          if (!--v755[0]) {
            goto LABEL_686;
          }
        }
      case 27:
        v744 = v76;
        uint64_t v727 = v26;
        v729 = v9;
        uint64_t v421 = (int)v27;
        uint64_t v422 = v42;
        uint64_t v725 = -(v41 * v734);
        break;
      default:
        goto LABEL_341;
    }
LABEL_665:
    int v423 = v765[0];
    unint64_t v424 = v71;
    while (1)
    {
      if (v42)
      {
        unsigned int v425 = *v68;
        if (!*v68) {
          goto LABEL_674;
        }
        if (!v27) {
          goto LABEL_672;
        }
      }
      else
      {
        unsigned int v425 = 255;
        if (!v27)
        {
LABEL_672:
          unint64_t v427 = PDAluminosityPDA(*v77, 0xFFu, *v22, v425);
          unint64_t v71 = v424;
          int v42 = v751;
          LODWORD(v27) = v753;
          unsigned int *v77 = HIDWORD(v427);
          goto LABEL_674;
        }
      }
      if (*v69)
      {
        unint64_t v426 = PDAluminosityPDA(*v77, *v69, *v22, v425);
        unint64_t v71 = v424;
        int v42 = v751;
        LODWORD(v27) = v753;
        unsigned int *v77 = HIDWORD(v426);
        *unint64_t v69 = v426;
      }
      else
      {
        unsigned int *v77 = *v22;
        *unint64_t v69 = v425;
      }
LABEL_674:
      v69 += v421;
      v428 = &v22[v733];
      if ((unint64_t)v428 >= v71) {
        uint64_t v429 = -(uint64_t)v735;
      }
      else {
        uint64_t v429 = 0;
      }
      v68 += v422 + v429;
      float v22 = &v428[v429];
      v77 += v733;
      if (!--v423)
      {
        if (v741)
        {
          uint64_t v41 = v739;
          v430 = &v744[v740];
          uint64_t v431 = v725;
          if (v430 < v741) {
            uint64_t v431 = 0;
          }
          unint64_t v68 = &v742[v739 + v431];
          uint64_t v432 = -(uint64_t)(v740 * v734);
          if (v430 < v741) {
            uint64_t v432 = 0;
          }
          float v22 = &v430[v432];
          v71 += 4 * v432 + 4 * v740;
          v742 += v739 + v431;
          v744 = v22;
        }
        else
        {
          uint64_t v41 = v739;
          v22 += v740;
          v68 += v739;
        }
        v77 += v746;
        v69 += v748;
        if (!--v755[0])
        {
LABEL_686:
          uint64_t v9 = v729;
          int v11 = v730;
          unint64_t v13 = v708;
          uint64_t v26 = v727;
LABEL_687:
          uint64_t v66 = v736;
          float v22 = (unsigned int *)v737;
          char v67 = v742;
          if (!v736) {
            return 1;
          }
LABEL_872:
          uint64_t v64 = v71;
          uint64_t v754 = 0;
LABEL_873:
          v742 = v67;
          if (!shape_enum_clip_next(v66, (int *)&v754 + 1, &v754, v765, v755))
          {
            unint64_t v60 = (void *)v66;
            goto LABEL_1187;
          }
          uint64_t v736 = v66;
          uint64_t v737 = (uint64_t)v22;
          if (v741)
          {
            unint64_t v25 = v738;
            uint64_t v77 = (unsigned int *)(v731 + 4 * v738 * (int)v754 + 4 * SHIDWORD(v754));
            int v516 = ((int)v754 + *(_DWORD *)(v13 + 60)) % v734;
            unint64_t v70 = v765[0];
            int v517 = (HIDWORD(v754) + *(_DWORD *)(v13 + 56)) % v735;
            v518 = &v22[v740 * v516];
            long long v76 = &v518[v517];
            unint64_t v71 = (unint64_t)&v518[v735];
            uint64_t v27 = v753;
            if (v753) {
              unint64_t v69 = &v732[v26 * (int)v754 + SHIDWORD(v754)];
            }
            uint64_t v519 = v748;
            if (v753) {
              uint64_t v519 = v26 - v765[0];
            }
            uint64_t v748 = v519;
            if (v751) {
              int v42 = v751;
            }
            else {
              int v42 = 0;
            }
            v520 = v742;
            if (v751) {
              v520 = &v9[v41 * v516 + v517];
            }
            v742 = v520;
            if (v751) {
              unint64_t v68 = &v9[v41 * v516 + v517];
            }
            LODWORD(v14) = v765[0];
            float v22 = &v518[v517];
            int v709 = ((int)v754 + *(_DWORD *)(v13 + 60)) % v734;
            int v710 = (HIDWORD(v754) + *(_DWORD *)(v13 + 56)) % v735;
          }
          else
          {
            uint64_t v521 = SHIDWORD(v754) * (uint64_t)v733;
            LODWORD(v14) = v765[0];
            unint64_t v25 = v738;
            uint64_t v77 = (unsigned int *)(v731 + 4 * v738 * (int)v754 + 4 * v521);
            unint64_t v70 = v765[0] * v733;
            v22 += (int)v754 * v735 + v521;
            unint64_t v740 = v735 - v765[0] * v733;
            uint64_t v27 = v753;
            if (v753) {
              unint64_t v69 = &v732[v26 * (int)v754 + SHIDWORD(v754) * (uint64_t)v733];
            }
            uint64_t v522 = v748;
            if (v753) {
              uint64_t v522 = v26 - v765[0] * v733;
            }
            uint64_t v748 = v522;
            if (v751) {
              int v42 = v751;
            }
            else {
              int v42 = 0;
            }
            v741 = 0;
            if (v751)
            {
              unint64_t v68 = &v9[(int)v754 * v734 + v521];
              uint64_t v41 = v734 - (int)v70;
            }
            unint64_t v71 = v64;
            long long v76 = v744;
          }
          goto LABEL_66;
        }
        goto LABEL_665;
      }
    }
  }
  int v19 = *(_DWORD *)(v3 + 128);
  if ((v19 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      CIF10_mark_constmask(v3, v11, v4, v5, v6, v7, v8);
    }
    else {
      CIF10_mark_pixelmask(v3, v11);
    }
    return 1;
  }
  int v28 = *(_DWORD *)(v3 + 112);
  int v29 = *(_DWORD *)(v3 + 116);
  unsigned int v30 = (v28 + 15) & 0xFFFFFFF0;
  size_t v31 = v30 * v29;
  if ((int)v31 <= 4096)
  {
    float v33 = v765;
  }
  else
  {
    float v32 = malloc_type_malloc(v31, 0x85316A6AuLL);
    if (!v32) {
      return 1;
    }
    float v33 = v32;
    float v18 = *(uint16x4_t **)(v13 + 136);
    int v19 = *(_DWORD *)(v13 + 128);
  }
  CGSConvertBitsToMask(v18, *(_DWORD *)(v13 + 124), v33, v30, v28, v29, v19);
  long long v54 = *(_OWORD *)(v13 + 112);
  long long v761 = *(_OWORD *)(v13 + 96);
  long long v762 = v54;
  long long v55 = *(_OWORD *)(v13 + 144);
  long long v763 = *(_OWORD *)(v13 + 128);
  long long v764 = v55;
  long long v56 = *(_OWORD *)(v13 + 48);
  long long v757 = *(_OWORD *)(v13 + 32);
  long long v758 = v56;
  long long v57 = *(_OWORD *)(v13 + 80);
  long long v759 = *(_OWORD *)(v13 + 64);
  long long v760 = v57;
  long long v58 = *(_OWORD *)v13;
  long long v59 = *(_OWORD *)(v13 + 16);
  *(_OWORD *)v755 = *(_OWORD *)v13;
  long long v756 = v59;
  HIDWORD(v762) = (v28 + 15) & 0xFFFFFFF0;
  *((void *)&v763 + 1) = v33;
  if (BYTE1(v755[0]) << 8 == 1024) {
    CIF10_mark_constmask((uint64_t)v755, v11, *(double *)&v58, *(double *)&v59, v51, v52, v53);
  }
  else {
    CIF10_mark_pixelmask((unint64_t)v755, v11);
  }
  if (v33 != (unsigned char *)v765)
  {
    unint64_t v60 = v33;
    goto LABEL_1187;
  }
  return 1;
}

unint64_t PDAmultiplyPDA(unsigned int a1, int a2, __int16 a3, int a4)
{
  int32x2_t v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  unsigned int v5 = ((a4 ^ 0xFF) + (a3 & 0x3FF)) * (a1 & 0x3FF);
  int32x2_t v6 = vmul_s32(vadd_s32(v4, vdup_n_s32(a4 ^ 0xFFu)), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003));
  double v7 = COERCE_DOUBLE(vmla_s32(v6, v4, vdup_n_s32(a2 ^ 0xFFu)));
  if (a2 != 255)
  {
    v5 += (a3 & 0x3FF) * (a2 ^ 0xFF);
    *(double *)&int32x2_t v6 = v7;
  }
  int32x2_t v8 = (int32x2_t)vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32((uint32x2_t)v6, (uint32x2_t)v6, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
  return ((255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)(vorr_s8((int8x8_t)v8, (int8x8_t)vdup_lane_s32(v8, 1)).u32[0] | ((v5 + (v5 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAscreenPDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4 = (a3 & 0x3FF) * (255 - (a1 & 0x3FF)) - (a1 & 0x3FF) + ((a1 & 0x3FF) << 8);
  int32x2_t v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int32x2_t v6 = vmla_s32(vmul_s32(v5, (int32x2_t)0xFF000000FFLL), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vsub_s32((int32x2_t)0xFF000000FFLL, v5));
  v5.i32[0] = vshr_n_u32((uint32x2_t)v6, 8uLL).u32[0];
  v5.i32[1] = vshr_n_s32(v6, 8uLL).i32[1];
  int8x8_t v7 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32((uint32x2_t)vadd_s32(v5, v6), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
  return ((255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)(((v4 + (v4 >> 8) + 1) >> 8) & 0x3FF | v7.i32[0] | v7.i32[1] | 0xC0000000) << 32);
}

unint64_t PDAoverlayPDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4 = (a1 >> 20) & 0x3FF;
  unsigned int v5 = (a1 >> 10) & 0x3FF;
  unsigned int v6 = a1 & 0x3FF;
  int v7 = (a3 >> 20) & 0x3FF;
  int v8 = (a3 >> 10) & 0x3FF;
  int v9 = a3 & 0x3FF;
  int v10 = 2 * v4 * v7;
  int v11 = 2 * v5 * v8;
  int v12 = 2 * v6;
  int v13 = a4 * a2;
  unsigned int v14 = (a2 + 1) >> 1;
  int v15 = a4 + 255;
  int v16 = a2 + 255;
  int v17 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  int v18 = a4 ^ 0xFF;
  int v19 = a2 ^ 0xFF;
  unsigned int v20 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  if (v4 < v14) {
    unsigned int v21 = v20;
  }
  else {
    unsigned int v21 = v17;
  }
  int v22 = v15 * v5 + v8 * v16 - (v13 + v11);
  unsigned int v23 = v8 * v19 + v18 * v5 + v11;
  if (v5 < v14) {
    unsigned int v24 = v23;
  }
  else {
    unsigned int v24 = v22;
  }
  if (v6 < v14) {
    unsigned int v25 = v18 * v6 + (v12 + v19) * v9;
  }
  else {
    unsigned int v25 = v9 * v16 - (v13 + v12 * (a3 & 0x3FF)) + v15 * v6;
  }
  return ((255 * (a4 + a2) - v13 + ((255 * (a4 + a2) - v13) >> 8) + 1) >> 8) | ((unint64_t)((((v21 + (v21 >> 8)) << 12) + 4096) & 0x3FF00000 | (4 * (v24 + (v24 >> 8)) + 4) & 0xFFC00 | ((v25 + (v25 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAlightenPDA(__int16 a1, unsigned int a2, __int16 a3, unsigned int a4)
{
  int32x2_t v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int32x2_t v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  double v6 = COERCE_DOUBLE(vmax_u32((uint32x2_t)vmul_s32(v5, vdup_n_s32(a2)), (uint32x2_t)vmul_s32(v4, vdup_n_s32(a4))));
  unsigned int v7 = (a1 & 0x3FF) * a4;
  if ((a3 & 0x3FF) * a2 > v7) {
    unsigned int v7 = (a3 & 0x3FF) * a2;
  }
  double v8 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v6, vdup_n_s32(a4 ^ 0xFF), v4));
  unsigned int v9 = v7 + (a4 ^ 0xFF) * (a1 & 0x3FF);
  if (a4 == 255)
  {
    unsigned int v9 = v7;
    *(double *)&int32x2_t v10 = v6;
  }
  else
  {
    *(double *)&int32x2_t v10 = v8;
  }
  double v11 = COERCE_DOUBLE(vmla_s32(v10, v5, vdup_n_s32(a2 ^ 0xFF)));
  if (a2 != 255)
  {
    v9 += (a3 & 0x3FF) * (a2 ^ 0xFF);
    *(double *)&int32x2_t v10 = v11;
  }
  int32x2_t v12 = (int32x2_t)vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32((uint32x2_t)v10, (uint32x2_t)v10, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
  return ((int)(255 * (a4 + a2) - a4 * a2 + ((int)(255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)(vorr_s8((int8x8_t)v12, (int8x8_t)vdup_lane_s32(v12, 1)).u32[0] | ((v9 + (v9 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAdarkenPDA(__int16 a1, unsigned int a2, __int16 a3, unsigned int a4)
{
  int32x2_t v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int32x2_t v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  double v6 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vmul_s32(v5, vdup_n_s32(a2)), (uint32x2_t)vmul_s32(v4, vdup_n_s32(a4))));
  unsigned int v7 = (a1 & 0x3FF) * a4;
  if ((a3 & 0x3FF) * a2 < v7) {
    unsigned int v7 = (a3 & 0x3FF) * a2;
  }
  double v8 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v6, vdup_n_s32(a4 ^ 0xFF), v4));
  unsigned int v9 = v7 + (a4 ^ 0xFF) * (a1 & 0x3FF);
  if (a4 == 255)
  {
    unsigned int v9 = v7;
    *(double *)&int32x2_t v10 = v6;
  }
  else
  {
    *(double *)&int32x2_t v10 = v8;
  }
  double v11 = COERCE_DOUBLE(vmla_s32(v10, v5, vdup_n_s32(a2 ^ 0xFF)));
  if (a2 != 255)
  {
    v9 += (a3 & 0x3FF) * (a2 ^ 0xFF);
    *(double *)&int32x2_t v10 = v11;
  }
  int32x2_t v12 = (int32x2_t)vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32((uint32x2_t)v10, (uint32x2_t)v10, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
  return ((int)(255 * (a4 + a2) - a4 * a2 + ((int)(255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)(vorr_s8((int8x8_t)v12, (int8x8_t)vdup_lane_s32(v12, 1)).u32[0] | ((v9 + (v9 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAcolordodgePDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = (a1 >> 20) & 0x3FF;
  int v5 = (a1 >> 10) & 0x3FF;
  int v6 = a1 & 0x3FF;
  int v7 = (a3 >> 20) & 0x3FF;
  int v8 = a4 * a4;
  if (v4)
  {
    if (a4 == v7) {
      int v9 = 65025;
    }
    else {
      int v9 = v8 * v4 / (a4 - v7);
    }
  }
  else
  {
    int v9 = 0;
  }
  int v10 = (a3 >> 10) & 0x3FF;
  if (v5)
  {
    if (a4 == v10) {
      int v11 = 65025;
    }
    else {
      int v11 = v8 * v5 / (a4 - v10);
    }
  }
  else
  {
    int v11 = 0;
  }
  int v12 = a3 & 0x3FF;
  if ((a1 & 0x3FF) != 0)
  {
    if (a4 == v12) {
      int v13 = 65025;
    }
    else {
      int v13 = v8 * v6 / (a4 - v12);
    }
  }
  else
  {
    int v13 = 0;
  }
  int v14 = v9 + (a4 ^ 0xFF) * v4;
  int v15 = v11 + (a4 ^ 0xFF) * v5;
  int v16 = v13 + (a4 ^ 0xFF) * v6;
  if (a4 == 255)
  {
    int v14 = v9;
    int v15 = v11;
    int v16 = v13;
  }
  int v17 = v14 + v7 * (a2 ^ 0xFF);
  int v18 = v15 + v10 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    int v17 = v14;
    int v19 = v16;
  }
  else
  {
    int v15 = v18;
    int v19 = v16 + v12 * (a2 ^ 0xFF);
  }
  int v20 = 255 * (a4 + a2) - a4 * a2;
  if (v17 >= v20) {
    int v17 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v15 >= v20) {
    int v15 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v19 >= v20) {
    int v19 = 255 * (a4 + a2) - a4 * a2;
  }
  return ((v20 + (v20 >> 8) + 1) >> 8) | ((unint64_t)((((v17 + (v17 >> 8)) << 12)
                                                                          + 4096) & 0x3FF00000 | (4
                                                                                                * (v15
                                                                                                 + (v15 >> 8))
                                                                                                + 4) & 0xFFC00 | ((v19 + (v19 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAcolorburnPDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = (a1 >> 20) & 0x3FF;
  int v5 = (a1 >> 10) & 0x3FF;
  int v6 = a1 & 0x3FF;
  int v7 = (a3 >> 20) & 0x3FF;
  int v8 = (a3 >> 10) & 0x3FF;
  int v9 = a3 & 0x3FF;
  int v10 = a4 * a2 + (a4 ^ 0xFF) * v4;
  int v11 = a4 * a2 + (a4 ^ 0xFF) * v5;
  if (a4 == 255)
  {
    int v10 = a4 * a2;
    int v11 = 255 * a2;
    int v12 = 255 * a2;
  }
  else
  {
    int v12 = a4 * a2 + (a4 ^ 0xFF) * (a1 & 0x3FF);
  }
  if (a2 == 255) {
    unsigned int v13 = v10;
  }
  else {
    unsigned int v13 = v10 + v7 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    unsigned int v14 = v11;
  }
  else {
    unsigned int v14 = v11 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    unsigned int v15 = v12;
  }
  else {
    unsigned int v15 = v12 + v9 * (a2 ^ 0xFF);
  }
  int v16 = a2 - v4;
  if (v16)
  {
    if (v7) {
      unsigned int v13 = (v13 - a4 * a4 * v16 / v7) & ~((int)(v13 - a4 * a4 * v16 / v7) >> 31);
    }
    else {
      unsigned int v13 = 0;
    }
  }
  int v17 = a2 - v5;
  if (v17)
  {
    if (v8) {
      unsigned int v14 = (v14 - a4 * a4 * v17 / v8) & ~((int)(v14 - a4 * a4 * v17 / v8) >> 31);
    }
    else {
      unsigned int v14 = 0;
    }
  }
  int v18 = a2 - v6;
  if (v18)
  {
    if ((a3 & 0x3FF) != 0) {
      unsigned int v15 = (v15 - a4 * a4 * v18 / v9) & ~((int)(v15 - a4 * a4 * v18 / v9) >> 31);
    }
    else {
      unsigned int v15 = 0;
    }
  }
  return ((255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)((((v13 + (v13 >> 8)) << 12) + 4096) & 0x3FF00000 | (4 * (v14 + (v14 >> 8)) + 4) & 0xFFC00 | ((v15 + (v15 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAhardlightPDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = (a1 >> 20) & 0x3FF;
  int v5 = (a1 >> 10) & 0x3FF;
  int v6 = a1 & 0x3FF;
  unsigned int v7 = (a3 >> 20) & 0x3FF;
  unsigned int v8 = (a3 >> 10) & 0x3FF;
  unsigned int v9 = a3 & 0x3FF;
  int v10 = 2 * v4 * v7;
  int v11 = 2 * v5 * v8;
  int v12 = 2 * v6;
  int v13 = a4 * a2;
  unsigned int v14 = (a4 + 1) >> 1;
  int v15 = a4 ^ 0xFF;
  int v16 = a2 ^ 0xFF;
  unsigned int v17 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  int v18 = a4 + 255;
  int v19 = a2 + 255;
  unsigned int v20 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  if (v7 <= v14) {
    unsigned int v20 = v17;
  }
  unsigned int v21 = v8 * v16 + v15 * v5 + v11;
  unsigned int v22 = v18 * v5 + v8 * v19 - (v13 + v11);
  if (v8 <= v14) {
    unsigned int v22 = v21;
  }
  int v23 = v15 * v6 + (v12 + v16) * v9;
  unsigned int v24 = v9 * v19 - (v13 + v12 * (a3 & 0x3FF)) + v18 * v6;
  if (v9 <= v14) {
    unsigned int v24 = v23;
  }
  return ((255 * (a4 + a2) - v13 + ((255 * (a4 + a2) - v13) >> 8) + 1) >> 8) | ((unint64_t)((((v20 + (v20 >> 8)) << 12) + 4096) & 0x3FF00000 | (4 * (v22 + (v22 >> 8)) + 4) & 0xFFC00 | ((v24 + (v24 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAsoftlightPDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4 = (a1 >> 20) & 0x3FF;
  int v5 = (a1 >> 10) & 0x3FF;
  int v6 = (a3 >> 20) & 0x3FF;
  int v7 = (a3 >> 10) & 0x3FF;
  int v8 = a3 & 0x3FF;
  int v9 = 2 * v4 * v6 - v4 * v4 * (2 * v6 - a4) / a2;
  int v10 = v9 & ~(v9 >> 31);
  int v11 = 2 * v5 * v7 - v5 * v5 * (2 * v7 - a4) / a2;
  int v12 = v11 & ~(v11 >> 31);
  unsigned int v13 = v10 + (a4 ^ 0xFF) * v4;
  unsigned int v14 = v12 + (a4 ^ 0xFF) * v5;
  unsigned int v15 = ((2 * (a1 & 0x3FF) * v8 - (int)((a1 & 0x3FF) * (a1 & 0x3FF) * (2 * v8 - a4)) / a2) & ~((int)(2 * (a1 & 0x3FF) * v8 - (int)((a1 & 0x3FF) * (a1 & 0x3FF) * (2 * v8 - a4)) / a2) >> 31))
      + (a4 ^ 0xFF) * (a1 & 0x3FF);
  if (a4 == 255)
  {
    unsigned int v13 = v10;
    unsigned int v14 = v12;
    unsigned int v15 = (2 * (a1 & 0x3FF) * v8 - (int)((a1 & 0x3FF) * (a1 & 0x3FF) * (2 * v8 - 255)) / a2) & ~((int)(2 * (a1 & 0x3FF) * v8 - (int)((a1 & 0x3FF) * (a1 & 0x3FF) * (2 * v8 - 255)) / a2) >> 31);
  }
  unsigned int v16 = v13 + v6 * (a2 ^ 0xFF);
  unsigned int v17 = v14 + v7 * (a2 ^ 0xFF);
  unsigned int v18 = v15 + v8 * (a2 ^ 0xFF);
  if (a2 != 255)
  {
    unsigned int v13 = v16;
    unsigned int v14 = v17;
    unsigned int v15 = v18;
  }
  return ((255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)((((v13 + (v13 >> 8)) << 12) + 4096) & 0x3FF00000 | (4 * (v14 + (v14 >> 8)) + 4) & 0xFFC00 | ((v15 + (v15 >> 8) + 1) >> 8) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAdifferencePDA(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int32x2_t v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int32x2_t v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int32x2_t v6 = vadd_s32(v5, v4);
  int32x2_t v7 = (int32x2_t)__PAIR64__(v4.u32[1], v5.u32[0]);
  int32x2_t v8 = vrev64_s32((int32x2_t)__PAIR64__(a2, a4));
  v4.i32[1] = v5.i32[1];
  int32x2_t v9 = vmul_s32(v4, (int32x2_t)__PAIR64__(a2, a4));
  int v10 = (a1 & 0x3FF) * a4;
  int v11 = (a3 & 0x3FF) * a2;
  int v13 = v10 - v11;
  BOOL v12 = v10 - v11 < 0;
  unsigned int v14 = 255 * ((a3 & 0x3FF) + (a1 & 0x3FF)) - v10 - v11;
  if (v12) {
    int v15 = -v13;
  }
  else {
    int v15 = v13;
  }
  int32x2_t v16 = vmul_s32(v7, v8);
  uint32x2_t v17 = (uint32x2_t)__PAIR64__(v9.u32[1], v16.u32[0]);
  int32x2_t v18 = vneg_s32(v9);
  v9.i32[1] = v16.i32[1];
  int32x2_t v19 = (int32x2_t)vaba_u32((uint32x2_t)vsub_s32(vmla_s32(v18, v6, (int32x2_t)0xFF000000FFLL), v16), v17, (uint32x2_t)v9);
  v20.i32[0] = vshr_n_u32((uint32x2_t)v19, 8uLL).u32[0];
  v20.i32[1] = vshr_n_s32(v19, 8uLL).i32[1];
  int8x8_t v21 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32((uint32x2_t)vadd_s32(v20, v19), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
  return ((int)(255 * (a4 + a2) - a4 * a2 + ((int)(255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)(((v14 + v15 + ((v14 + v15) >> 8) + 1) >> 8) & 0x3FF | v21.i32[0] | v21.i32[1] | 0xC0000000) << 32);
}

unint64_t PDAexclusionPDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4 = 255 * ((a3 & 0x3FF) + (a1 & 0x3FF)) - 2 * (a1 & 0x3FF) * (a3 & 0x3FF);
  int32x2_t v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int32x2_t v6 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int32x2_t v7 = vmul_s32(vadd_s32(v6, v5), (int32x2_t)0xFF000000FFLL);
  int32x2_t v8 = vmul_s32(v5, v6);
  int32x2_t v9 = vsub_s32(v7, vadd_s32(v8, v8));
  v6.i32[0] = vshr_n_u32((uint32x2_t)v9, 8uLL).u32[0];
  v6.i32[1] = vshr_n_s32(v9, 8uLL).i32[1];
  int8x8_t v10 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32((uint32x2_t)vadd_s32(v6, v9), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
  return ((255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) >> 8) | ((unint64_t)(((v4 + (v4 >> 8) + 1) >> 8) & 0x3FF | v10.i32[0] | v10.i32[1] | 0xC0000000) << 32);
}

unint64_t PDAhuePDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = (a1 >> 20) & 0x3FF;
  unsigned int v5 = (a1 >> 10) & 0x3FF;
  unsigned int v6 = a1 & 0x3FF;
  if (a4 == 255)
  {
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = 0;
  }
  else
  {
    unsigned int v7 = (a4 ^ 0xFF) * v4;
    unsigned int v4 = (v4 * a4 + ((v4 * a4) >> 8) + 1) >> 8;
    unsigned int v8 = (a4 ^ 0xFF) * v5;
    unsigned int v5 = (v5 * a4 + ((v5 * a4) >> 8) + 1) >> 8;
    unsigned int v9 = (a4 ^ 0xFF) * v6;
    unsigned int v6 = (v6 * a4 + ((v6 * a4) >> 8) + 1) >> 8;
  }
  unsigned int v10 = (a3 >> 20) & 0x3FF;
  unsigned int v11 = (a3 >> 10) & 0x3FF;
  signed int v12 = a3 & 0x3FF;
  if (a2 != 255)
  {
    v7 += v10 * (a2 ^ 0xFF);
    unsigned int v10 = (v10 * a2 + ((v10 * a2) >> 8) + 1) >> 8;
    v8 += v11 * (a2 ^ 0xFF);
    unsigned int v11 = (v11 * a2 + ((v11 * a2) >> 8) + 1) >> 8;
    v9 += v12 * (a2 ^ 0xFF);
    signed int v12 = (v12 * a2 + ((v12 * a2) >> 8) + 1) >> 8;
  }
  signed int v39 = v10;
  signed int v40 = v11;
  signed int v41 = v12;
  BOOL v13 = v10 >= v11;
  uint64_t v14 = v10 < v11;
  uint64_t v15 = v13;
  if (v12 >= *(&v39 + v15))
  {
    uint64_t v16 = v15;
    if (v12 > *(&v39 + v14))
    {
      uint64_t v15 = v14;
      uint64_t v14 = 2;
    }
  }
  else
  {
    uint64_t v16 = 2;
  }
  int v17 = *(&v39 + v14);
  int v18 = *(&v39 + v16);
  BOOL v19 = __OFSUB__(v17, v18);
  int v20 = v17 - v18;
  if ((v20 < 0) ^ v19 | (v20 == 0))
  {
    *(&v39 + v14) = 0;
    *(&v39 + v15) = 0;
  }
  else
  {
    if (v4 >= v5) {
      unsigned int v21 = v5;
    }
    else {
      unsigned int v21 = v4;
    }
    if (v4 <= v5) {
      unsigned int v22 = v5;
    }
    else {
      unsigned int v22 = v4;
    }
    if (v6 <= v22) {
      unsigned int v23 = v22;
    }
    else {
      unsigned int v23 = v6;
    }
    if (v6 >= v21) {
      unsigned int v22 = v23;
    }
    else {
      unsigned int v21 = v6;
    }
    unsigned int v24 = v22 - v21;
    *(&v39 + v14) = v24;
    *(&v39 + v15) = ((*(&v39 + v15) - *(&v39 + v16)) * ((int)(v24 << 16) / v20) + 0x8000) >> 16;
  }
  *(&v39 + v16) = 0;
  int v25 = 77 * (v4 - v39) + 151 * (v5 - v40) + 28 * (v6 - v41);
  int v26 = v39 + ((v25 + 128) >> 8);
  int v27 = v40 + ((v25 + 128) >> 8);
  signed int v28 = (a4 * a2 + ((a4 * a2) >> 8) + 1) >> 8;
  int v29 = v41 + ((v25 + 128) >> 8);
  if (v25 != (char)v25)
  {
    int v30 = v39 >= v40 ? v40 + ((v25 + 128) >> 8) : v39 + ((v25 + 128) >> 8);
    int v31 = v39 >= v40 ? v39 + ((v25 + 128) >> 8) : v40 + ((v25 + 128) >> 8);
    int v32 = v29 <= v31 ? v31 : v41 + ((v25 + 128) >> 8);
    int v33 = v29 >= v30 ? v30 : v41 + ((v25 + 128) >> 8);
    if (v29 >= v30) {
      int v31 = v32;
    }
    if (v31 > v28 || v33 < 0)
    {
      int v34 = (77 * v26 + 151 * v27 + 28 * v29 + 128) >> 8;
      if (v25 > -129)
      {
        int v35 = v31 - v34;
        if (v31 != v34)
        {
          int v36 = v28 - v34;
          goto LABEL_50;
        }
      }
      else
      {
        int v35 = v34 - v33;
        if (v34 != v33)
        {
          int v36 = (77 * v26 + 151 * v27 + 28 * v29 + 128) >> 8;
LABEL_50:
          int v37 = (v36 << 16) / v35;
          int v26 = v34 + ((v37 * (v26 - v34) + 0x8000) >> 16);
          int v27 = v34 + ((v37 * (v27 - v34) + 0x8000) >> 16);
          int v29 = v34 + ((v37 * (v29 - v34) + 0x8000) >> 16);
        }
      }
    }
  }
  return (a4 + a2 - v28) | ((unint64_t)(((((_WORD)v27
                                                              + (unsigned __int16)((v8 + (v8 >> 8) + 1) >> 8)) & 0x3FF) << 10) | ((v26 + ((v7 + (v7 >> 8) + 1) >> 8)) << 20) | (v29 + ((v9 + (v9 >> 8) + 1) >> 8)) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAsaturationPDA(unsigned int a1, int a2, unsigned int a3, int a4)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = (a1 >> 20) & 0x3FF;
  unsigned int v5 = (a1 >> 10) & 0x3FF;
  signed int v6 = a1 & 0x3FF;
  if (a4 == 255)
  {
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = 0;
  }
  else
  {
    unsigned int v7 = (a4 ^ 0xFF) * v4;
    unsigned int v4 = (v4 * a4 + ((v4 * a4) >> 8) + 1) >> 8;
    unsigned int v8 = (a4 ^ 0xFF) * v5;
    unsigned int v5 = (v5 * a4 + ((v5 * a4) >> 8) + 1) >> 8;
    unsigned int v9 = (a4 ^ 0xFF) * v6;
    signed int v6 = (v6 * a4 + ((v6 * a4) >> 8) + 1) >> 8;
  }
  unsigned int v10 = (a3 >> 20) & 0x3FF;
  unsigned int v11 = (a3 >> 10) & 0x3FF;
  unsigned int v12 = a3 & 0x3FF;
  if (a2 != 255)
  {
    v7 += v10 * (a2 ^ 0xFF);
    unsigned int v10 = (v10 * a2 + ((v10 * a2) >> 8) + 1) >> 8;
    v8 += v11 * (a2 ^ 0xFF);
    unsigned int v11 = (v11 * a2 + ((v11 * a2) >> 8) + 1) >> 8;
    v9 += v12 * (a2 ^ 0xFF);
    unsigned int v12 = (v12 * a2 + ((v12 * a2) >> 8) + 1) >> 8;
  }
  signed int v37 = v4;
  signed int v38 = v5;
  signed int v39 = v6;
  uint64_t v13 = v4 < v5;
  BOOL v14 = v4 >= v5;
  if (v6 >= *(&v37 + v14))
  {
    uint64_t v15 = v4 >= v5;
    if (v6 > *(&v37 + v13))
    {
      BOOL v14 = v4 < v5;
      uint64_t v13 = 2;
    }
  }
  else
  {
    uint64_t v15 = 2;
  }
  int v16 = *(&v37 + v13);
  int v17 = *(&v37 + v15);
  BOOL v18 = __OFSUB__(v16, v17);
  int v19 = v16 - v17;
  if ((v19 < 0) ^ v18 | (v19 == 0))
  {
    *(&v37 + v13) = 0;
    *(&v37 + v14) = 0;
  }
  else
  {
    if (v10 >= v11) {
      unsigned int v20 = v11;
    }
    else {
      unsigned int v20 = v10;
    }
    if (v10 <= v11) {
      unsigned int v10 = v11;
    }
    if (v12 <= v10) {
      unsigned int v21 = v10;
    }
    else {
      unsigned int v21 = v12;
    }
    if (v12 >= v20)
    {
      unsigned int v12 = v20;
      unsigned int v10 = v21;
    }
    unsigned int v22 = v10 - v12;
    *(&v37 + v13) = v22;
    *(&v37 + v14) = ((*(&v37 + v14) - *(&v37 + v15)) * ((int)(v22 << 16) / v19) + 0x8000) >> 16;
  }
  *(&v37 + v15) = 0;
  int v23 = 77 * (v4 - v37) + 151 * (v5 - v38) + 28 * (v6 - v39);
  int v24 = v37 + ((v23 + 128) >> 8);
  int v25 = v38 + ((v23 + 128) >> 8);
  signed int v26 = (a4 * a2 + ((a4 * a2) >> 8) + 1) >> 8;
  int v27 = v39 + ((v23 + 128) >> 8);
  if (v23 != (char)v23)
  {
    int v28 = v37 >= v38 ? v38 + ((v23 + 128) >> 8) : v37 + ((v23 + 128) >> 8);
    int v29 = v37 >= v38 ? v37 + ((v23 + 128) >> 8) : v38 + ((v23 + 128) >> 8);
    int v30 = v27 <= v29 ? v29 : v39 + ((v23 + 128) >> 8);
    int v31 = v27 >= v28 ? v28 : v39 + ((v23 + 128) >> 8);
    if (v27 >= v28) {
      int v29 = v30;
    }
    if (v29 > v26 || v31 < 0)
    {
      int v32 = (77 * v24 + 151 * v25 + 28 * v27 + 128) >> 8;
      if (v23 > -129)
      {
        int v33 = v29 - v32;
        if (v29 != v32)
        {
          int v34 = v26 - v32;
          goto LABEL_45;
        }
      }
      else
      {
        int v33 = v32 - v31;
        if (v32 != v31)
        {
          int v34 = (77 * v24 + 151 * v25 + 28 * v27 + 128) >> 8;
LABEL_45:
          int v35 = (v34 << 16) / v33;
          int v24 = v32 + ((v35 * (v24 - v32) + 0x8000) >> 16);
          int v25 = v32 + ((v35 * (v25 - v32) + 0x8000) >> 16);
          int v27 = v32 + ((v35 * (v27 - v32) + 0x8000) >> 16);
        }
      }
    }
  }
  return (a4 + a2 - v26) | ((unint64_t)(((((_WORD)v25
                                                              + (unsigned __int16)((v8 + (v8 >> 8) + 1) >> 8)) & 0x3FF) << 10) | ((v24 + ((v7 + (v7 >> 8) + 1) >> 8)) << 20) | (v27 + ((v9 + (v9 >> 8) + 1) >> 8)) & 0x3FF | 0xC0000000) << 32);
}

unint64_t PDAluminosityPDA(unsigned int a1, unsigned int a2, __int16 a3, unsigned int a4)
{
  unsigned int v4 = a1 & 0x3FF;
  int32x2_t v5 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003);
  int8x8_t v6 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF6FFFFFFECLL);
  if (a4 == 255)
  {
    unsigned int v9 = 0;
    int32x2_t v8 = 0;
  }
  else
  {
    uint32x2_t v7 = (uint32x2_t)vmul_s32(v5, vdup_n_s32(a4));
    int32x2_t v8 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v5);
    int32x2_t v5 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v7, v7, 8uLL), (int32x2_t)0x100000001), 8uLL);
    unsigned int v9 = (a4 ^ 0xFF) * v4;
    unsigned int v4 = (v4 * a4 + ((v4 * a4) >> 8) + 1) >> 8;
  }
  unsigned int v10 = a3 & 0x3FF;
  int32x2_t v11 = (int32x2_t)vand_s8(v6, (int8x8_t)0x300000003);
  if (a2 != 255)
  {
    int32x2_t v8 = vmla_s32(v8, v11, vdup_n_s32(a2 ^ 0xFF));
    uint32x2_t v12 = (uint32x2_t)vmul_s32(v11, vdup_n_s32(a2));
    int32x2_t v11 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v12, v12, 8uLL), (int32x2_t)0x100000001), 8uLL);
    v9 += v10 * (a2 ^ 0xFF);
    unsigned int v10 = (v10 * a2 + ((v10 * a2) >> 8) + 1) >> 8;
  }
  signed int v13 = (a4 * a2 + ((a4 * a2) >> 8) + 1) >> 8;
  int32x2_t v14 = vmul_s32(vsub_s32(v11, v5), (int32x2_t)0x970000004DLL);
  signed __int32 v15 = vadd_s32(vdup_lane_s32(v14, 1), v14).u32[0] + 28 * (v10 - v4);
  int32x2_t v16 = vadd_s32(vdup_n_s32((v15 + 128) >> 8), v5);
  signed __int32 v17 = v4 + ((v15 + 128) >> 8);
  if (v15 != (char)v15)
  {
    unsigned __int8 v18 = vcgt_u32((uint32x2_t)vdup_lane_s32(v5, 1), (uint32x2_t)v5).u8[0];
    __int32 v19 = (v18 & 1) != 0 ? v16.i32[0] : v16.i32[1];
    signed int v20 = (v18 & 1) != 0 ? v16.i32[1] : v16.i32[0];
    signed int v21 = v17 <= v20 ? v20 : v17;
    if (v17 >= v19) {
      signed int v20 = v21;
    }
    else {
      __int32 v19 = v17;
    }
    if (v20 > v13 || v19 < 0)
    {
      unsigned int v22 = (77 * v16.i32[0] + 151 * v16.i32[1] + 28 * v17 + 128) >> 8;
      if (v15 > -129)
      {
        signed __int32 v23 = v20 - v22;
        if (v20 != v22)
        {
          int v24 = v13 - v22;
          goto LABEL_26;
        }
      }
      else
      {
        signed __int32 v23 = v22 - v19;
        if (v22 != v19)
        {
          int v24 = (77 * v16.i32[0] + 151 * v16.i32[1] + 28 * v17 + 128) >> 8;
LABEL_26:
          int32x2_t v25 = vdup_n_s32(v22);
          unsigned int v26 = (v24 << 16) / v23;
          signed __int32 v17 = v22 + ((int)(v26 * (v17 - v22) + 0x8000) >> 16);
          int32x2_t v16 = vsra_n_s32(v25, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v26), vsub_s32(v16, v25)), 0x10uLL);
        }
      }
    }
  }
  uint32x2_t v27 = vshl_u32(vsra_n_u32((uint32x2_t)v16, (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)v8, (uint32x2_t)v8, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0xA00000014);
  return (a4 + a2 - v13) | ((unint64_t)(v27.i32[0] | ((_WORD)v17 + (unsigned __int16)((v9 + (v9 >> 8) + 1) >> 8)) & 0x3FF | v27.i32[1] & 0xFFC00 | 0xC0000000) << 32);
}

uint64_t CIF10_mark_constmask(uint64_t result, int a2, double a3, double a4, double a5, double a6, int64x2_t a7)
{
  uint64_t v7 = *(void *)(result + 48);
  uint64_t v8 = *(void *)(result + 136);
  unsigned int v9 = *(unsigned __int8 **)(result + 96);
  if (v9) {
    unsigned int v10 = *v9;
  }
  else {
    unsigned int v10 = 255;
  }
  uint64_t v12 = *(int *)(result + 12);
  uint64_t v11 = *(int *)(result + 16);
  if (v7)
  {
    uint64_t v13 = *(int *)(result + 32);
    int32x2_t v14 = (__int8 *)(v7 + v12 + (int)v13 * (uint64_t)(int)v11);
    uint64_t v15 = 1;
    if (!v8) {
      return result;
    }
  }
  else
  {
    int32x2_t v14 = 0;
    uint64_t v13 = 0;
    uint64_t v15 = 0;
    if (!v8) {
      return result;
    }
  }
  int v16 = *(_DWORD *)(result + 4);
  uint64_t v17 = v13 - v16;
  if (v7) {
    uint64_t v18 = v13 - v16;
  }
  else {
    uint64_t v18 = v13;
  }
  int v19 = *(_DWORD *)(result + 8);
  unsigned int v20 = **(_DWORD **)(result + 88);
  unint64_t v21 = (unint64_t)*(int *)(result + 28) >> 2;
  unsigned int v22 = (uint32x4_t *)(*(void *)(result + 40) + 4 * (v12 + v21 * v11));
  uint64_t v23 = *(int *)(result + 124);
  unint64_t v24 = v8 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v23;
  uint64_t v25 = v23 - v16;
  unint64_t v26 = v21 - v16;
  switch(a2)
  {
    case 0:
      if (v7)
      {
        do
        {
          int v27 = v16;
          do
          {
            int v28 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v28 == 255)
              {
                LOBYTE(v29) = 0;
                v22->i32[0] = 0;
              }
              else
              {
                unsigned int v30 = v28 ^ 0xFF;
                unsigned int v29 = (*v14 * v30 + ((*v14 * v30) >> 8) + 1) >> 8;
                uint32x2_t v31 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v30));
                int8x8_t v32 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v31, v31, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                CGColorSpaceRef result = v32.u32[0];
                v22->i32[0] = v32.i32[0] | (((v22->i32[0] & 0x3FF) * v30 + (((v22->i32[0] & 0x3FF) * v30) >> 8) + 1) >> 8) | v32.i32[1] | 0xC0000000;
              }
              *int32x2_t v14 = v29;
            }
            ++v24;
            unsigned int v22 = (uint32x4_t *)((char *)v22 + 4);
            v14 += v15;
            --v27;
          }
          while (v27);
          v24 += v25;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v26);
          v14 += v18;
          --v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          int v137 = v16;
          do
          {
            int v138 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v138 == 255)
              {
                __int32 v139 = 0;
              }
              else
              {
                unsigned int v140 = v138 ^ 0xFF;
                uint32x2_t v141 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v140));
                int8x8_t v142 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v141, v141, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                CGColorSpaceRef result = v142.i32[0] | (((v22->i32[0] & 0x3FF) * v140 + (((v22->i32[0] & 0x3FF) * v140) >> 8) + 1) >> 8);
                __int32 v139 = v22->i32[0] - (result | v142.i32[1]) + 0x40000000;
              }
              v22->i32[0] = v139;
            }
            ++v24;
            unsigned int v22 = (uint32x4_t *)((char *)v22 + 4);
            --v137;
          }
          while (v137);
          v24 += v25;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v26);
          --v19;
        }
        while (v19);
      }
      return result;
    case 1:
      unsigned int v33 = v24 & 3;
      if (!v7)
      {
        int v143 = v33 + v16;
        int v144 = -1 << (8 * v33);
        uint32x2_t v145 = (uint32x4_t *)((char *)v22 - 4 * (v24 & 3));
        if ((v24 & 3) != 0) {
          unsigned int v146 = v24 & 0xFFFFFFFC;
        }
        else {
          unsigned int v146 = v24;
        }
        if ((v24 & 3) != 0)
        {
          v24 &= 0xFFFFFFFFFFFFFFFCLL;
          unsigned int v22 = v145;
        }
        else
        {
          int v144 = -1;
          int v143 = v16;
        }
        unsigned int v147 = ((_BYTE)v143 + (_BYTE)v146) & 3;
        if ((((_BYTE)v143 + (_BYTE)v146) & 3) != 0)
        {
          unsigned int v148 = 4 - v147;
          v33 += v148;
          unsigned int v149 = 0xFFFFFFFF >> (8 * v148);
          if (v143 >= 4) {
            unsigned int v147 = 0xFFFFFFFF >> (8 * v148);
          }
          else {
            unsigned int v147 = 0;
          }
          if (v143 >= 4) {
            unsigned int v149 = -1;
          }
          v144 &= v149;
        }
        int v150 = v143 >> 2;
        int v151 = v20 & 0x3FF00000;
        int32x4_t v152 = vdupq_n_s32(v20);
        uint64_t v153 = v25 - v33;
        CGColorSpaceRef result = v20 & 0xFFC00;
        uint64_t v154 = &xmmword_1850CE000;
        unint64_t v155 = v26 - v33;
        while (1)
        {
          unsigned int v156 = *(_DWORD *)v24 & v144;
          int v157 = v150;
          unsigned int v158 = v147;
          if (!v156) {
            goto LABEL_172;
          }
LABEL_151:
          if (v156 == -1)
          {
            *unsigned int v22 = (uint32x4_t)v152;
            goto LABEL_172;
          }
          while (1)
          {
            if ((_BYTE)v156)
            {
              if (v156 == 255)
              {
                unsigned int v159 = v20;
              }
              else
              {
                LODWORD(v18) = v18 & 0xC0000000 | (v151 * v156) & 0x3FF00000 | (result
                                                                                               * v156) & 0xFFC00 | (v156 * (_WORD)v20) & 0x3FF;
                unsigned int v160 = v156 ^ 0xFF;
                uint32x2_t v161 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v160));
                int8x8_t v162 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v161, v161, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v159 = v18
                     - 0x40000000
                     + (v162.i32[0] | (((v22->i32[0] & 0x3FF) * v160 + (((v22->i32[0] & 0x3FF) * v160) >> 8) + 1) >> 8) | v162.i32[1]);
              }
              v22->i32[0] = v159;
            }
            if (BYTE1(v156))
            {
              if (BYTE1(v156) == 255)
              {
                unsigned int v163 = v20;
              }
              else
              {
                unsigned int v33 = v33 & 0xC0000000 | (v151 * BYTE1(v156)) & 0x3FF00000 | (result * BYTE1(v156)) & 0xFFC00 | (BYTE1(v156) * (_WORD)v20) & 0x3FF;
                unsigned int v164 = BYTE1(v156) ^ 0xFF;
                uint32x2_t v165 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->u32[1]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v164));
                int8x8_t v166 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v165, v165, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v163 = v33
                     - 0x40000000
                     + (v166.i32[0] | (((v22->i32[1] & 0x3FF) * v164 + (((v22->i32[1] & 0x3FF) * v164) >> 8) + 1) >> 8) | v166.i32[1]);
              }
              v22->i32[1] = v163;
            }
            if (BYTE2(v156))
            {
              if (BYTE2(v156) == 255)
              {
                unsigned int v167 = v20;
              }
              else
              {
                unsigned int v146 = v146 & 0xC0000000 | (v151 * BYTE2(v156)) & 0x3FF00000 | (result * BYTE2(v156)) & 0xFFC00 | (BYTE2(v156) * (_WORD)v20) & 0x3FF;
                unsigned int v168 = BYTE2(v156) ^ 0xFF;
                uint32x2_t v169 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->u32[2]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v168));
                int8x8_t v170 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v169, v169, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v167 = v146
                     - 0x40000000
                     + (v170.i32[0] | (((v22->i32[2] & 0x3FF) * v168 + (((v22->i32[2] & 0x3FF) * v168) >> 8) + 1) >> 8) | v170.i32[1]);
              }
              v22->i32[2] = v167;
            }
            unsigned int v171 = HIBYTE(v156);
            if (v171 == 255)
            {
              v22->i32[3] = v20;
            }
            else if (v171)
            {
              LODWORD(v154) = v154 & 0xC0000000 | (v151 * v171) & 0x3FF00000 | (result * v171) & 0xFFC00 | ((_WORD)v171 * (_WORD)v20) & 0x3FF;
              unsigned int v172 = v171 ^ 0xFF;
              uint32x2_t v173 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->u32[3]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v172));
              int8x8_t v174 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v173, v173, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
              v22->i32[3] = v154
                          - 0x40000000
                          + (v174.i32[0] | (((v22->i32[3] & 0x3FF) * v172 + (((v22->i32[3] & 0x3FF) * v172) >> 8) + 1) >> 8) | v174.i32[1]);
            }
LABEL_172:
            while (1)
            {
              int v175 = v157;
              ++v22;
              --v157;
              v24 += 4;
              if (v175 < 2) {
                break;
              }
              unsigned int v156 = *(_DWORD *)v24;
              if (*(_DWORD *)v24) {
                goto LABEL_151;
              }
            }
            if (!v158) {
              break;
            }
            unsigned int v158 = 0;
            unsigned int v156 = *(_DWORD *)v24 & v147;
          }
          v24 += v153;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v155);
          if (!--v19) {
            return result;
          }
        }
      }
      int v34 = v33 + v16;
      int v35 = -1 << (8 * v33);
      int v36 = (uint32x4_t *)((char *)v22 - 4 * (v24 & 3));
      signed int v37 = &v14[-(v24 & 3)];
      if ((v24 & 3) != 0) {
        char v38 = v24 & 0xFC;
      }
      else {
        char v38 = v24;
      }
      if ((v24 & 3) != 0)
      {
        v24 &= 0xFFFFFFFFFFFFFFFCLL;
      }
      else
      {
        int v35 = -1;
        signed int v37 = v14;
      }
      if (v33) {
        unsigned int v22 = v36;
      }
      else {
        int v34 = v16;
      }
      unsigned int v39 = ((_BYTE)v34 + v38) & 3;
      if ((((_BYTE)v34 + v38) & 3) != 0)
      {
        unsigned int v40 = 4 - v39;
        v33 += v40;
        unsigned int v41 = 0xFFFFFFFF >> (8 * v40);
        if (v34 >= 4) {
          unsigned int v39 = 0xFFFFFFFF >> (8 * v40);
        }
        else {
          unsigned int v39 = 0;
        }
        if (v34 >= 4) {
          unsigned int v41 = -1;
        }
        v35 &= v41;
      }
      uint64_t v42 = v25 - v33;
      unint64_t v43 = v26 - v33;
      CGColorSpaceRef result = (v34 >> 2);
      unsigned int v44 = v20 >> 20;
      unsigned int v45 = v20 >> 10;
      uint64_t v46 = v17 - v33;
      do
      {
        unsigned int v47 = *(_DWORD *)v24 & v35;
        int v48 = result;
        unsigned int v49 = v39;
        if (!v47) {
          goto LABEL_62;
        }
LABEL_41:
        if (v47 == -1)
        {
          v22->i32[0] = v20;
          *signed int v37 = v10;
          v22->i32[1] = v20;
          v37[1] = v10;
          v22->i32[2] = v20;
          v37[2] = v10;
LABEL_59:
          v22->i32[3] = v20;
          v37[3] = v10;
          goto LABEL_62;
        }
        while (1)
        {
          if ((_BYTE)v47)
          {
            if (v47 == 255)
            {
              v22->i32[0] = v20;
              __int8 v50 = v10;
            }
            else
            {
              unsigned int v51 = v47 ^ 0xFF;
              uint32x2_t v52 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v51));
              *(uint32x2_t *)v53.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v52, v52, 8uLL), (int32x2_t)0x100000001), 8uLL);
              unint64_t v54 = v53.u32[0] | ((unint64_t)(((v22->i32[0] & 0x3FF) * v51
                                                    + (((v22->i32[0] & 0x3FF) * v51) >> 8)
                                                    + 1) >> 8) << 32);
              v53.i32[0] = (v51 * *v37 + ((v51 * *v37) >> 8) + 1) >> 8;
              v53.i64[1] = v54;
              a7.i8[0] = v10 * v47;
              a7.i16[2] = (v47 * (_WORD)v44) & 0x3FF;
              a7.i16[4] = (v47 * (_WORD)v45) & 0x3FF;
              a7.i16[6] = (v47 * (_WORD)v20) & 0x3FF;
              int64x2_t v55 = vaddq_s64(v53, a7);
              __int8 v50 = v55.i8[0];
              v22->i32[0] = ((unint64_t)v55.i64[0] >> 12) & 0x3FF00000 | v55.i16[6] & 0x3FF | ((v55.i16[4] & 0x3FF) << 10) | 0xC0000000;
            }
            *signed int v37 = v50;
          }
          if (BYTE1(v47))
          {
            if (BYTE1(v47) == 255)
            {
              v22->i32[1] = v20;
              __int8 v56 = v10;
            }
            else
            {
              unsigned int v57 = BYTE1(v47) ^ 0xFF;
              uint32x2_t v58 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->u32[1]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v57));
              *(uint32x2_t *)v59.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v58, v58, 8uLL), (int32x2_t)0x100000001), 8uLL);
              unint64_t v60 = v59.u32[0] | ((unint64_t)(((v22->i32[1] & 0x3FF) * v57
                                                    + (((v22->i32[1] & 0x3FF) * v57) >> 8)
                                                    + 1) >> 8) << 32);
              v59.i32[0] = (v57 * v37[1] + ((v57 * v37[1]) >> 8) + 1) >> 8;
              v59.i64[1] = v60;
              a7.i8[0] = v10 * BYTE1(v47);
              a7.i16[2] = (BYTE1(v47) * (_WORD)v44) & 0x3FF;
              a7.i16[4] = (BYTE1(v47) * (_WORD)v45) & 0x3FF;
              a7.i16[6] = (BYTE1(v47) * (_WORD)v20) & 0x3FF;
              int64x2_t v61 = vaddq_s64(v59, a7);
              __int8 v56 = v61.i8[0];
              v22->i32[1] = ((unint64_t)v61.i64[0] >> 12) & 0x3FF00000 | v61.i16[6] & 0x3FF | ((v61.i16[4] & 0x3FF) << 10) | 0xC0000000;
            }
            v37[1] = v56;
          }
          if (BYTE2(v47))
          {
            if (BYTE2(v47) == 255)
            {
              v22->i32[2] = v20;
              __int8 v62 = v10;
            }
            else
            {
              unsigned int v63 = BYTE2(v47) ^ 0xFF;
              uint32x2_t v64 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->u32[2]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v63));
              *(uint32x2_t *)v65.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v64, v64, 8uLL), (int32x2_t)0x100000001), 8uLL);
              unint64_t v66 = v65.u32[0] | ((unint64_t)(((v22->i32[2] & 0x3FF) * v63
                                                    + (((v22->i32[2] & 0x3FF) * v63) >> 8)
                                                    + 1) >> 8) << 32);
              v65.i32[0] = (v63 * v37[2] + ((v63 * v37[2]) >> 8) + 1) >> 8;
              v65.i64[1] = v66;
              a7.i8[0] = v10 * BYTE2(v47);
              a7.i16[2] = (BYTE2(v47) * (_WORD)v44) & 0x3FF;
              a7.i16[4] = (BYTE2(v47) * (_WORD)v45) & 0x3FF;
              a7.i16[6] = (BYTE2(v47) * (_WORD)v20) & 0x3FF;
              int64x2_t v67 = vaddq_s64(v65, a7);
              __int8 v62 = v67.i8[0];
              v22->i32[2] = ((unint64_t)v67.i64[0] >> 12) & 0x3FF00000 | v67.i16[6] & 0x3FF | ((v67.i16[4] & 0x3FF) << 10) | 0xC0000000;
            }
            v37[2] = v62;
          }
          unsigned int v68 = HIBYTE(v47);
          if (v68 == 255) {
            goto LABEL_59;
          }
          if (v68)
          {
            __int16 v69 = v68 * v44;
            __int16 v70 = v68 * v45;
            int v71 = ((_WORD)v68 * (_WORD)v20) & 0x3FF;
            unsigned __int8 v72 = v10 * v68;
            unsigned int v73 = v68 ^ 0xFF;
            uint32x2_t v74 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->u32[3]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v73));
            *(uint32x2_t *)v75.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v74, v74, 8uLL), (int32x2_t)0x100000001), 8uLL);
            unint64_t v76 = v75.u32[0] | ((unint64_t)(((v22->i32[3] & 0x3FF) * v73
                                                  + (((v22->i32[3] & 0x3FF) * v73) >> 8)
                                                  + 1) >> 8) << 32);
            v75.i32[0] = (v73 * v37[3] + ((v73 * v37[3]) >> 8) + 1) >> 8;
            v75.i64[1] = v76;
            a7.i64[0] = v72 | ((unint64_t)(v69 & 0x3FF) << 32);
            a7.i32[2] = v70 & 0x3FF;
            a7.i8[12] = v71;
            a7.i8[13] = BYTE1(v71);
            a7.i8[14] = BYTE2(v71);
            a7.i8[15] = HIBYTE(v71);
            int64x2_t v77 = vaddq_s64(v75, a7);
            v22->i32[3] = ((unint64_t)v77.i64[0] >> 12) & 0x3FF00000 | v77.i16[6] & 0x3FF | ((v77.i16[4] & 0x3FF) << 10) | 0xC0000000;
            v37[3] = v77.i8[0];
          }
LABEL_62:
          while (1)
          {
            int v78 = v48;
            ++v22;
            v37 += 4;
            --v48;
            v24 += 4;
            if (v78 < 2) {
              break;
            }
            unsigned int v47 = *(_DWORD *)v24;
            if (*(_DWORD *)v24) {
              goto LABEL_41;
            }
          }
          if (!v49) {
            break;
          }
          unsigned int v49 = 0;
          unsigned int v47 = *(_DWORD *)v24 & v39;
        }
        v24 += v42;
        unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v43);
        v37 += v46;
        --v19;
      }
      while (v19);
      return result;
    case 2:
      unsigned __int8 v79 = ~(_BYTE)v10;
      unsigned int v80 = v24 & 3;
      if (v7)
      {
        int v81 = v80 + v16;
        int v82 = -1 << (8 * v80);
        uint64_t v83 = (uint32x4_t *)((char *)v22 - 4 * (v24 & 3));
        uint64_t v84 = (unsigned __int8 *)&v14[-(v24 & 3)];
        if ((v24 & 3) != 0) {
          char v85 = v24 & 0xFC;
        }
        else {
          char v85 = v24;
        }
        if ((v24 & 3) != 0)
        {
          v24 &= 0xFFFFFFFFFFFFFFFCLL;
        }
        else
        {
          int v82 = -1;
          uint64_t v84 = (unsigned __int8 *)v14;
        }
        if (v80) {
          unsigned int v22 = v83;
        }
        else {
          int v81 = v16;
        }
        uint64_t v86 = ((_BYTE)v81 + v85) & 3;
        if ((((_BYTE)v81 + v85) & 3) != 0)
        {
          int v87 = 4 - v86;
          v80 += v87;
          unsigned int v88 = 0xFFFFFFFF >> (8 * v87);
          if (v81 >= 4) {
            uint64_t v86 = v88;
          }
          else {
            uint64_t v86 = 0;
          }
          if (v81 >= 4) {
            unsigned int v88 = -1;
          }
          v82 &= v88;
        }
        uint64_t v89 = v25 - v80;
        unint64_t v90 = v26 - v80;
        CGColorSpaceRef result = (v81 >> 2);
        int v91 = ~(_BYTE)v10;
        v92.i64[0] = v10 | ((unint64_t)((v20 >> 20) & 0x3FF) << 32);
        v92.i64[1] = (v20 >> 10) & 0x3FF | ((unint64_t)(v20 & 0x3FF) << 32);
        uint64_t v93 = v17 - v80;
        while (1)
        {
          int v94 = *(_DWORD *)v24 & v82;
          int v95 = result;
          for (uint64_t i = v86; ; uint64_t i = v105)
          {
            if (v94 == -1)
            {
              v97.i32[0] = (*v84 * v91 + ((*v84 * v91) >> 8) + 1) >> 8;
              v97.i32[1] = ((((unsigned __int32)v22->i32[0] >> 20) & 0x3FF) * v91
                          + (((((unsigned __int32)v22->i32[0] >> 20) & 0x3FF) * v91) >> 8)
                          + 1) >> 8;
              v97.i32[2] = ((((unsigned __int32)v22->i32[0] >> 10) & 0x3FF) * v91
                          + (((((unsigned __int32)v22->i32[0] >> 10) & 0x3FF) * v91) >> 8)
                          + 1) >> 8;
              v97.i32[3] = ((v22->i32[0] & 0x3FF) * v91 + (((v22->i32[0] & 0x3FFu) * v91) >> 8) + 1) >> 8;
              int64x2_t v98 = vaddq_s64(v97, v92);
              v22->i32[0] = ((unint64_t)v98.i64[0] >> 12) & 0x3FF00000 | v98.i16[6] & 0x3FF | ((v98.i16[4] & 0x3FF) << 10) | 0xC0000000;
              *uint64_t v84 = v98.i8[0];
              unsigned __int32 v99 = v22->u32[1];
              v98.i64[0] = ((v84[1] * v91 + ((v84[1] * v91) >> 8) + 1) >> 8) | ((unint64_t)((((v99 >> 20) & 0x3FF) * v91 + ((((v99 >> 20) & 0x3FF) * v91) >> 8) + 1) >> 8) << 32);
              v98.i64[1] = ((((v99 >> 10) & 0x3FF) * v91 + ((((v99 >> 10) & 0x3FF) * v91) >> 8) + 1) >> 8) | ((unint64_t)(((v99 & 0x3FF) * v91 + (((v99 & 0x3FF) * v91) >> 8) + 1) >> 8) << 32);
              int64x2_t v100 = vaddq_s64(v98, v92);
              v22->i32[1] = ((unint64_t)v100.i64[0] >> 12) & 0x3FF00000 | v100.i16[6] & 0x3FF | ((v100.i16[4] & 0x3FF) << 10) | 0xC0000000;
              v84[1] = v100.i8[0];
              unsigned __int32 v101 = v22->u32[2];
              v100.i64[0] = ((v84[2] * v91 + ((v84[2] * v91) >> 8) + 1) >> 8) | ((unint64_t)((((v101 >> 20) & 0x3FF) * v91 + ((((v101 >> 20) & 0x3FF) * v91) >> 8) + 1) >> 8) << 32);
              v100.i64[1] = ((((v101 >> 10) & 0x3FF) * v91 + ((((v101 >> 10) & 0x3FF) * v91) >> 8) + 1) >> 8) | ((unint64_t)(((v101 & 0x3FF) * v91 + (((v101 & 0x3FF) * v91) >> 8) + 1) >> 8) << 32);
              int64x2_t v102 = vaddq_s64(v100, v92);
              v22->i32[2] = ((unint64_t)v102.i64[0] >> 12) & 0x3FF00000 | v102.i16[6] & 0x3FF | ((v102.i16[4] & 0x3FF) << 10) | 0xC0000000;
              v84[2] = v102.i8[0];
              unsigned __int32 v103 = v22->u32[3];
              v102.i64[0] = ((v84[3] * v91 + ((v84[3] * v91) >> 8) + 1) >> 8) | ((unint64_t)((((v103 >> 20) & 0x3FF) * v91 + ((((v103 >> 20) & 0x3FF) * v91) >> 8) + 1) >> 8) << 32);
              v102.i64[1] = ((((v103 >> 10) & 0x3FF) * v91 + ((((v103 >> 10) & 0x3FF) * v91) >> 8) + 1) >> 8) | ((unint64_t)(((v103 & 0x3FF) * v91 + (((v103 & 0x3FF) * v91) >> 8) + 1) >> 8) << 32);
              int64x2_t v104 = vaddq_s64(v102, v92);
              v22->i32[3] = ((unint64_t)v104.i64[0] >> 12) & 0x3FF00000 | v104.i16[6] & 0x3FF | ((v104.i16[4] & 0x3FF) << 10) | 0xC0000000;
              v84[3] = v104.i8[0];
            }
LABEL_90:
            uint64_t v105 = i;
            int v106 = v95;
            ++v22;
            v84 += 4;
            --v95;
            v24 += 4;
            if (v106 < 2) {
              break;
            }
            int v94 = *(_DWORD *)v24;
          }
          uint64_t i = 0;
          if (v105) {
            goto LABEL_90;
          }
          v24 += v89;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v90);
          v84 += v93;
          if (!--v19) {
            return result;
          }
        }
      }
      int v176 = v80 + v16;
      int v177 = -1 << (8 * v80);
      v178 = (uint32x4_t *)((char *)v22 - 4 * (v24 & 3));
      if ((v24 & 3) != 0) {
        char v179 = v24 & 0xFC;
      }
      else {
        char v179 = v24;
      }
      if ((v24 & 3) != 0)
      {
        v24 &= 0xFFFFFFFFFFFFFFFCLL;
        unsigned int v22 = v178;
      }
      else
      {
        int v177 = -1;
        int v176 = v16;
      }
      uint64_t v180 = ((_BYTE)v176 + v179) & 3;
      if ((((_BYTE)v176 + v179) & 3) != 0)
      {
        int v181 = 4 - v180;
        v80 += v181;
        unsigned int v182 = 0xFFFFFFFF >> (8 * v181);
        if (v176 >= 4) {
          uint64_t v180 = v182;
        }
        else {
          uint64_t v180 = 0;
        }
        if (v176 >= 4) {
          unsigned int v182 = -1;
        }
        v177 &= v182;
      }
      unsigned int v183 = v20 - 0x40000000;
      uint64_t v184 = v25 - v80;
      int v185 = v176 >> 2;
      unint64_t v186 = v26 - v80;
      int32x4_t v187 = vdupq_n_s32(v79);
      int32x4_t v188 = vdupq_n_s32(v183);
      v189.i64[0] = 0x300000003;
      v189.i64[1] = 0x300000003;
      v190.i64[0] = 0x100000001;
      v190.i64[1] = 0x100000001;
      v191.i64[0] = 0x400000004;
      v191.i64[1] = 0x400000004;
      v192.i64[0] = 0x100000001000;
      v192.i64[1] = 0x100000001000;
      __asm { FMOV            V6.4S, #1.875 }
      int8x16_t v198 = (int8x16_t)vdupq_n_s32(0xFFC00u);
      do
      {
        int v199 = *(_DWORD *)v24 & v177;
        int v200 = v185;
        uint64_t v201 = v180;
LABEL_194:
        if (v199 == -1)
        {
          uint32x4_t v202 = (uint32x4_t)vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v22, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)), v187);
          uint32x4_t v203 = (uint32x4_t)vmulq_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(*v22, 0xAuLL), v189), v187);
          uint32x4_t v204 = (uint32x4_t)vmulq_s32((int32x4_t)vandq_s8(*(int8x16_t *)v22, v189), v187);
          *(int32x4_t *)unsigned int v22 = vaddq_s32((int32x4_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vaddq_s32(vshlq_n_s32((int32x4_t)vsraq_n_u32(v202, v202, 8uLL), 0xCuLL), v192), _Q6), (int8x16_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v204, v204, 8uLL), v190), 8uLL)), vandq_s8((int8x16_t)vaddq_s32(vshlq_n_s32((int32x4_t)vsraq_n_u32(v203, v203, 8uLL), 2uLL), v191), v198)),
                                v188);
        }
        do
        {
          CGColorSpaceRef result = v201;
          int v205 = v200;
          ++v22;
          --v200;
          v24 += 4;
          if (v205 >= 2)
          {
            int v199 = *(_DWORD *)v24;
            uint64_t v201 = result;
            goto LABEL_194;
          }
          uint64_t v201 = 0;
        }
        while (result);
        v24 += v184;
        unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v186);
        --v19;
      }
      while (v19);
      return result;
    case 7:
      int32x2_t v107 = vdup_n_s32(v10);
      if (v7)
      {
        do
        {
          int v108 = v16;
          do
          {
            int v109 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v109 == 255)
              {
                unsigned int v110 = *v14 * v10 + ((*v14 * v10) >> 8) + 1;
                uint32x2_t v111 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), v107);
                uint32x2_t v112 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v111, v111, 8uLL), (int32x2_t)0x100000001);
                unsigned int v113 = (v22->i32[0] & 0x3FF) * v10;
              }
              else
              {
                unsigned int v114 = (~(_BYTE)v109 + ((unsigned __int16)(v109 * v10 + ((v109 * v10) >> 8) + 1) >> 8));
                unsigned int v110 = *v14 * v114 + ((*v14 * v114) >> 8) + 1;
                uint32x2_t v115 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v114));
                uint32x2_t v112 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v115, v115, 8uLL), (int32x2_t)0x100000001);
                unsigned int v113 = (v22->i32[0] & 0x3FF) * v114;
              }
              int8x8_t v116 = vand_s8((int8x8_t)vshl_u32(v112, (uint32x2_t)0x20000000CLL), (int8x8_t)0xFFC003FF00000);
              CGColorSpaceRef result = v116.u32[1];
              v22->i32[0] = v116.i32[0] | ((v113 + (v113 >> 8) + 1) >> 8) | v116.i32[1] | 0xC0000000;
              *int32x2_t v14 = BYTE1(v110);
            }
            ++v24;
            unsigned int v22 = (uint32x4_t *)((char *)v22 + 4);
            v14 += v15;
            --v108;
          }
          while (v108);
          v24 += v25;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v26);
          v14 += v18;
          --v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          int v206 = v16;
          do
          {
            CGColorSpaceRef result = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (result == 255)
              {
                uint32x2_t v207 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v107);
                uint32x2_t v208 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v207, v207, 8uLL), (int32x2_t)0x100000001);
                unsigned int v209 = (v22->i32[0] & 0x3FF) * v10;
              }
              else
              {
                unsigned int v210 = (~(_BYTE)result
                                       + ((unsigned __int16)(result * v10 + ((result * v10) >> 8) + 1) >> 8));
                uint32x2_t v211 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v210));
                uint32x2_t v208 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v211, v211, 8uLL), (int32x2_t)0x100000001);
                unsigned int v209 = (v22->i32[0] & 0x3FF) * v210;
              }
              int8x8_t v212 = vand_s8((int8x8_t)vshl_u32(v208, (uint32x2_t)0xC00000002), (int8x8_t)0x3FF00000000FFC00);
              CGColorSpaceRef result = v212.i32[1] | ((v209 + (v209 >> 8) + 1) >> 8) | v212.i32[0];
              v22->i32[0] = v22->i32[0] - result + 0x40000000;
            }
            ++v24;
            unsigned int v22 = (uint32x4_t *)((char *)v22 + 4);
            --v206;
          }
          while (v206);
          v24 += v25;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v26);
          --v19;
        }
        while (v19);
      }
      return result;
    case 8:
      int v117 = v10 ^ 0xFF;
      int32x2_t v118 = vdup_n_s32(v10 ^ 0xFF);
      if (v7)
      {
        do
        {
          int v119 = v16;
          do
          {
            CGColorSpaceRef result = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (result == 255)
              {
                unsigned int v120 = *v14 * v117 + ((*v14 * v117) >> 8) + 1;
                uint32x2_t v121 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), v118);
                uint32x2_t v122 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v121, v121, 8uLL), (int32x2_t)0x100000001);
                unsigned int v123 = (v22->i32[0] & 0x3FF) * v117;
              }
              else
              {
                unsigned int v124 = ~((result * v10 + ((result * v10) >> 8) + 1) >> 8);
                unsigned int v120 = v124 * *v14 + ((v124 * *v14) >> 8) + 1;
                uint32x2_t v125 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v124));
                uint32x2_t v122 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v125, v125, 8uLL), (int32x2_t)0x100000001);
                unsigned int v123 = (v22->i32[0] & 0x3FF) * v124;
              }
              CGColorSpaceRef result = v120 >> 8;
              int8x8_t v126 = vand_s8((int8x8_t)vshl_u32(v122, (uint32x2_t)0x20000000CLL), (int8x8_t)0xFFC003FF00000);
              v22->i32[0] = v126.i32[0] | ((v123 + (v123 >> 8) + 1) >> 8) | v126.i32[1] | 0xC0000000;
              *int32x2_t v14 = result;
            }
            ++v24;
            unsigned int v22 = (uint32x4_t *)((char *)v22 + 4);
            v14 += v15;
            --v119;
          }
          while (v119);
          v24 += v25;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v26);
          v14 += v18;
          --v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          LODWORD(result) = v16;
          do
          {
            int v213 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v213 == 255)
              {
                uint32x2_t v214 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), v118);
                uint32x2_t v215 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v214, v214, 8uLL), (int32x2_t)0x100000001);
                unsigned int v216 = (v22->i32[0] & 0x3FF) * v117;
              }
              else
              {
                unsigned int v217 = ~((v213 * v10 + ((v213 * v10) >> 8) + 1) >> 8);
                uint32x2_t v218 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v217));
                uint32x2_t v215 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v218, v218, 8uLL), (int32x2_t)0x100000001);
                unsigned int v216 = (v22->i32[0] & 0x3FF) * v217;
              }
              int8x8_t v219 = vand_s8((int8x8_t)vshl_u32(v215, (uint32x2_t)0xC00000002), (int8x8_t)0x3FF00000000FFC00);
              v22->i32[0] = v22->i32[0] - (v219.i32[1] | ((v216 + (v216 >> 8) + 1) >> 8) | v219.i32[0]) + 0x40000000;
            }
            ++v24;
            unsigned int v22 = (uint32x4_t *)((char *)v22 + 4);
            CGColorSpaceRef result = (result - 1);
          }
          while (result);
          v24 += v25;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v26);
          --v19;
        }
        while (v19);
      }
      return result;
    case 9:
      int32x2_t v127 = (int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(v20), (uint32x2_t)0xFFFFFFECFFFFFFF6);
      do
      {
        LODWORD(result) = v16;
        do
        {
          unsigned int v128 = *(unsigned __int8 *)v24;
          if (*(unsigned char *)v24)
          {
            int v129 = *v14;
            unsigned int v130 = v129 ^ 0xFF;
            unsigned int v131 = (v128 * v10 + ~(_BYTE)v128);
            unsigned int v132 = ((v129 * v131 + ((v129 * v131) >> 8) + 1) >> 8)
                 + ((v130 * (v128 * v10) + ((v130 * (v128 * v10)) >> 8) + 1) >> 8);
            if (v132 >= 0xFF) {
              LOBYTE(v132) = -1;
            }
            unsigned int v133 = (((v22->i32[0] & 0x3FF) * v131 + (((v22->i32[0] & 0x3FF) * v131) >> 8) + 1) >> 8)
                 + (((((_WORD)v20 * (_WORD)v128) & 0x3FF) * v130
                   + (((((_WORD)v20 * (_WORD)v128) & 0x3FF) * v130) >> 8)
                   + 1) >> 8);
            if (v133 >= 0x3FF) {
              unsigned int v133 = 1023;
            }
            uint32x2_t v134 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vmul_s32(v127, vdup_n_s32(v128)), (int8x8_t)0x300000003), vdup_n_s32(v130));
            uint32x2_t v135 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v22->i32[0]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v131));
            int32x2_t v136 = (int32x2_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v135, v135, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v134, v134, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            v22->i32[0] = vorr_s8((int8x8_t)v136, (int8x8_t)vdup_lane_s32(v136, 1)).u32[0] | v133 | 0xC0000000;
            *int32x2_t v14 = v132;
          }
          ++v24;
          unsigned int v22 = (uint32x4_t *)((char *)v22 + 4);
          v14 += v15;
          CGColorSpaceRef result = (result - 1);
        }
        while (result);
        v24 += v25;
        unsigned int v22 = (uint32x4_t *)((char *)v22 + 4 * v26);
        v14 += v18;
        --v19;
      }
      while (v19);
      return result;
    default:
      return result;
  }
}

unint64_t CIF10_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 136);
  uint64_t v5 = *(int *)(result + 12);
  uint64_t v4 = *(int *)(result + 16);
  if (v2)
  {
    uint64_t v6 = *(int *)(result + 32);
    uint64_t v7 = (char *)(v2 + v5 + (int)v6 * (uint64_t)(int)v4);
    int v8 = -1;
    if (!v3) {
      return result;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return result;
    }
  }
  int v9 = *(_DWORD *)(result + 4);
  int v10 = *(_DWORD *)(result + 8);
  unint64_t v12 = *(void *)(result + 88);
  uint64_t v11 = *(void *)(result + 96);
  unint64_t v13 = (unint64_t)*(int *)(result + 28) >> 2;
  int32x2_t v14 = (unsigned int *)(*(void *)(result + 40) + 4 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(result + 124);
  int v16 = (unsigned char *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(result + 56);
  uint64_t v18 = *(int *)(result + 60);
  unint64_t v19 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    int v21 = *(_DWORD *)(result + 64);
    int v22 = *(_DWORD *)(result + 68);
    unint64_t v842 = v19 >> 2;
    v843 = *(unsigned char **)(result + 96);
    if (v11)
    {
      uint64_t v840 = *(int *)(result + 80);
      int v20 = 1;
    }
    else
    {
      uint64_t v840 = 0;
      int v20 = 0;
    }
    CGColorSpaceRef result = v12 + 4 * v842 * v22;
    v8 &= 1u;
    int v27 = 1;
    unint64_t v844 = v12;
    uint64_t v23 = (unsigned int *)v12;
    goto LABEL_19;
  }
  unint64_t v842 = v19 >> 2;
  if (v11)
  {
    uint64_t v840 = *(int *)(result + 80);
    v843 = (unsigned char *)(v11 + v17 + (int)v840 * (uint64_t)(int)v18);
    int v20 = -1;
  }
  else
  {
    v843 = 0;
    uint64_t v840 = 0;
    int v20 = 0;
  }
  uint64_t v23 = (unsigned int *)(v12 + 4 * (v17 + v842 * v18));
  if (v842 == v13 && (char *)v14 - (char *)v23 >= 1)
  {
    if (v9 >= (uint64_t)((unint64_t)((char *)v14 - (char *)v23) >> 2))
    {
      v14 += v9 - 1;
      v23 += v9 - 1;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      int v27 = -1;
      unint64_t v842 = (unint64_t)*(int *)(result + 28) >> 2;
      v843 += v20 & (v9 - 1);
      goto LABEL_16;
    }
    uint64_t v24 = v10 - 1;
    unint64_t v25 = v13 * v24;
    unint64_t v26 = &v23[v13 * v24];
    if (v14 <= &v26[v9 - 1])
    {
      unint64_t v13 = -(uint64_t)v13;
      v16 += v15 * v24;
      uint64_t v15 = -v15;
      v7 += v6 * v24;
      uint64_t v6 = -v6;
      v8 &= 1u;
      unint64_t v842 = v13;
      v843 += v840 * v24;
      uint64_t v840 = -v840;
      v20 &= 1u;
      int v27 = 1;
      uint64_t v23 = v26;
      v14 += v25;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v20 &= 1u;
  int v27 = 1;
LABEL_16:
  CGColorSpaceRef result = 0;
  unint64_t v844 = 0;
  unint64_t v12 = -1;
  int v22 = v840;
  int v21 = v842;
LABEL_19:
  int v28 = v27 * v9;
  int v841 = v9;
  unint64_t v837 = result;
  int v845 = v10;
  if (result)
  {
    uint64_t v29 = (int)v18 % v22;
    unsigned int v30 = &v23[v842 * v29];
    CGColorSpaceRef result = (int)v17 % v21;
    uint64_t v23 = &v30[result];
    unint64_t v12 = (unint64_t)&v30[v21];
    unint64_t v31 = (unint64_t)v843;
    if (v20) {
      unint64_t v31 = (unint64_t)&v843[v840 * v29 + result];
    }
    v843 = (unsigned char *)v31;
    unint64_t v844 = (unint64_t)v23;
  }
  else
  {
    v842 -= v28;
    v840 -= v20 * v9;
  }
  uint64_t v839 = v15 - v28;
  unint64_t v838 = v13 - v28;
  unint64_t v836 = v6 - v8 * v9;
  int v862 = v20;
  int v846 = v8;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        do
        {
          int v32 = v9;
          int v33 = v845;
          do
          {
            int v34 = *v16;
            if (*v16)
            {
              if (v34 == 255)
              {
                LOBYTE(v35) = 0;
                *int32x2_t v14 = 0;
              }
              else
              {
                unsigned int v36 = v34 ^ 0xFF;
                unsigned int v35 = (*v7 * v36 + ((*v7 * v36) >> 8) + 1) >> 8;
                uint32x2_t v37 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v36));
                int8x8_t v38 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v37, v37, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                *int32x2_t v14 = v38.i32[0] | (((*v14 & 0x3FF) * v36 + (((*v14 & 0x3FF) * v36) >> 8) + 1) >> 8) | v38.i32[1] | 0xC0000000;
              }
              *uint64_t v7 = v35;
            }
            v16 += v27;
            v7 += v8;
            v14 += v27;
            --v32;
          }
          while (v32);
          v16 += v839;
          v14 += v838;
          v7 += v836;
          --v845;
        }
        while (v33 != 1);
      }
      else
      {
        do
        {
          int v640 = v9;
          int v641 = v845;
          do
          {
            int v642 = *v16;
            if (*v16)
            {
              if (v642 == 255)
              {
                unsigned int v643 = 0;
              }
              else
              {
                unsigned int v644 = v642 ^ 0xFF;
                uint32x2_t v645 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v644));
                int8x8_t v646 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v645, v645, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v643 = *v14
                     - (v646.i32[0] | (((*v14 & 0x3FF) * v644 + (((*v14 & 0x3FF) * v644) >> 8) + 1) >> 8) | v646.i32[1])
                     + 0x40000000;
              }
              *int32x2_t v14 = v643;
            }
            v16 += v27;
            v14 += v27;
            --v640;
          }
          while (v640);
          v16 += v839;
          v14 += v838;
          --v845;
        }
        while (v641 != 1);
      }
      return result;
    case 1:
      if (v8)
      {
        uint64_t v39 = v27;
        if (v20)
        {
          uint64_t v40 = v20;
          uint64_t v41 = v22;
          uint64_t v42 = -(uint64_t)(v842 * v22);
          uint64_t v43 = -(v840 * v41);
          uint64_t v44 = -(uint64_t)v21;
          unsigned int v45 = v843;
          do
          {
            int v46 = v841;
            int v47 = v845;
            do
            {
              unsigned int v48 = *v16;
              if (*v16)
              {
                if (v48 == 255)
                {
                  *int32x2_t v14 = *v23;
                  LOBYTE(v49) = *v45;
                }
                else
                {
                  unsigned int v51 = v48 ^ 0xFF;
                  unsigned int v49 = ((*v7 * v51 + ((*v7 * v51) >> 8) + 1) >> 8)
                      + ((*v45 * v48 + ((*v45 * v48) >> 8) + 1) >> 8);
                  if (v49 >= 0xFF) {
                    LOBYTE(v49) = -1;
                  }
                  unsigned int v50 = (*v23 & 0x3FF) * v48 + (((*v23 & 0x3FF) * v48) >> 8) + 1;
                  unsigned int v52 = ((*v14 & 0x3FF) * v51 + (((*v14 & 0x3FF) * v51) >> 8) + 1) >> 8;
                  uint32x2_t v53 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v48));
                  uint32x2_t v54 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v51));
                  int8x8_t v55 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v54, v54, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v53, v53, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  int8x8_t v56 = (int8x8_t)vdup_lane_s32((int32x2_t)v55, 1);
                  if (v52 + (v50 >> 8) >= 0x3FF) {
                    int v57 = 1023;
                  }
                  else {
                    int v57 = v52 + (v50 >> 8);
                  }
                  *int32x2_t v14 = vorr_s8(v55, v56).u32[0] | v57 | 0xC0000000;
                }
                *uint64_t v7 = v49;
              }
              v16 += v27;
              v7 += v8;
              uint32x2_t v58 = &v23[v27];
              int64x2_t v59 = &v45[v40];
              if ((unint64_t)v58 >= v12) {
                uint64_t v60 = v44;
              }
              else {
                uint64_t v60 = 0;
              }
              unsigned int v45 = &v59[v60];
              uint64_t v23 = &v58[v60];
              v14 += v27;
              --v46;
            }
            while (v46);
            if (v837)
            {
              unint64_t v61 = v844 + 4 * v842;
              if (v61 >= v837) {
                uint64_t v62 = v43;
              }
              else {
                uint64_t v62 = 0;
              }
              unsigned int v63 = &v843[v840 + v62];
              if (v61 >= v837) {
                uint64_t v64 = v42;
              }
              else {
                uint64_t v64 = 0;
              }
              uint64_t v23 = (unsigned int *)(v61 + 4 * v64);
              v12 += 4 * v64 + 4 * v842;
              v843 += v840 + v62;
              unint64_t v844 = (unint64_t)v23;
              unsigned int v45 = v63;
            }
            else
            {
              v23 += v842;
              v45 += v840;
            }
            v16 += v839;
            v14 += v838;
            CGColorSpaceRef result = v836;
            v7 += v836;
            --v845;
          }
          while (v47 != 1);
        }
        else
        {
          uint64_t v772 = -(uint64_t)v21;
          uint64_t v773 = -(uint64_t)(v842 * v22);
          do
          {
            int v774 = v841;
            int v775 = v845;
            do
            {
              unsigned int v776 = *v16;
              if (*v16)
              {
                if (v776 == 255)
                {
                  *int32x2_t v14 = *v23;
                  LOBYTE(v777) = -1;
                }
                else
                {
                  unsigned int v778 = v776 ^ 0xFF;
                  unsigned int v777 = ((*v7 * v778 + ((*v7 * v778) >> 8) + 1) >> 8)
                       + ((255 * v776 + ((255 * v776) >> 8) + 1) >> 8);
                  if (v777 >= 0xFF) {
                    LOBYTE(v777) = -1;
                  }
                  uint32x2_t v779 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v776));
                  uint32x2_t v780 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v778));
                  int8x8_t v781 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v780, v780, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v779, v779, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  int8x8_t v782 = (int8x8_t)vdup_lane_s32((int32x2_t)v781, 1);
                  if ((((*v14 & 0x3FF) * v778 + (((*v14 & 0x3FF) * v778) >> 8) + 1) >> 8)
                     + (((*v23 & 0x3FF) * v776 + (((*v23 & 0x3FF) * v776) >> 8) + 1) >> 8) >= 0x3FF)
                    unsigned int v783 = 1023;
                  else {
                    unsigned int v783 = (((*v14 & 0x3FF) * v778 + (((*v14 & 0x3FF) * v778) >> 8) + 1) >> 8)
                  }
                         + (((*v23 & 0x3FF) * v776 + (((*v23 & 0x3FF) * v776) >> 8) + 1) >> 8);
                  *int32x2_t v14 = vorr_s8(v781, v782).u32[0] | v783 | 0xC0000000;
                }
                *uint64_t v7 = v777;
              }
              v16 += v39;
              v7 += v8;
              v784 = &v23[v39];
              if ((unint64_t)v784 >= v12) {
                uint64_t v785 = v772;
              }
              else {
                uint64_t v785 = 0;
              }
              uint64_t v23 = &v784[v785];
              v14 += v39;
              --v774;
            }
            while (v774);
            v16 += v839;
            v14 += v838;
            v7 += v836;
            CGColorSpaceRef result = v842;
            unint64_t v786 = v844;
            unint64_t v787 = v844 + 4 * v842;
            if (v787 >= v837) {
              uint64_t v788 = v773;
            }
            else {
              uint64_t v788 = 0;
            }
            v789 = (unsigned int *)(v787 + 4 * v788);
            uint64_t v790 = v12 + 4 * v788 + 4 * v842;
            if (v837)
            {
              unint64_t v12 = v790;
              unint64_t v786 = (unint64_t)v789;
              uint64_t v23 = v789;
            }
            else
            {
              v23 += v842;
            }
            unint64_t v844 = v786;
            --v845;
          }
          while (v775 != 1);
        }
      }
      else
      {
        uint64_t v647 = v27;
        uint64_t v648 = -(uint64_t)v21;
        uint64_t v649 = -(uint64_t)(v842 * v22);
        uint64_t v650 = 4 * v27;
        do
        {
          int v651 = v841;
          int v652 = v845;
          do
          {
            unsigned int v653 = *v16;
            if (*v16)
            {
              if (v653 == 255)
              {
                unsigned int v654 = *v23;
              }
              else
              {
                unsigned int v655 = v653 ^ 0xFF;
                unsigned int v656 = (((*v14 & 0x3FF) * v655 + (((*v14 & 0x3FF) * v655) >> 8) + 1) >> 8)
                     + (((*v23 & 0x3FF) * v653 + (((*v23 & 0x3FF) * v653) >> 8) + 1) >> 8);
                if (v656 >= 0x3FF) {
                  unsigned int v656 = 1023;
                }
                uint32x2_t v657 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v653));
                uint32x2_t v658 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v655));
                int8x8_t v659 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v658, v658, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v657, v657, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                unsigned int v654 = vorr_s8(v659, (int8x8_t)vdup_lane_s32((int32x2_t)v659, 1)).u32[0] | v656 | 0xC0000000;
              }
              *int32x2_t v14 = v654;
            }
            v16 += v647;
            unint64_t v660 = &v23[v647];
            if ((unint64_t)v660 >= v12) {
              uint64_t v661 = v648;
            }
            else {
              uint64_t v661 = 0;
            }
            uint64_t v23 = &v660[v661];
            int32x2_t v14 = (unsigned int *)((char *)v14 + v650);
            --v651;
          }
          while (v651);
          v16 += v839;
          v14 += v838;
          CGColorSpaceRef result = v844;
          unint64_t v662 = v844 + 4 * v842;
          if (v662 >= v837) {
            uint64_t v663 = v649;
          }
          else {
            uint64_t v663 = 0;
          }
          unint64_t v664 = (unsigned int *)(v662 + 4 * v663);
          uint64_t v665 = v12 + 4 * v663 + 4 * v842;
          if (v837)
          {
            unint64_t v12 = v665;
            CGColorSpaceRef result = (unint64_t)v664;
            uint64_t v23 = v664;
          }
          else
          {
            v23 += v842;
          }
          unint64_t v844 = result;
          --v845;
        }
        while (v652 != 1);
      }
      return result;
    case 2:
      uint64_t v65 = v27;
      if (v8)
      {
        uint64_t v66 = v20;
        uint64_t v67 = v22;
        uint64_t v68 = -(uint64_t)(v842 * v22);
        uint64_t v69 = -(v840 * v67);
        uint64_t v70 = -(uint64_t)v21;
        int v71 = v843;
        while (1)
        {
          int v72 = v9;
          int v73 = v845;
          do
          {
            int v74 = *v16;
            if (!*v16) {
              goto LABEL_78;
            }
            if (v74 == 255)
            {
              uint64_t v75 = *v71;
              if (!*v71) {
                goto LABEL_78;
              }
              if (v75 == 255)
              {
                *int32x2_t v14 = *v23;
                char v76 = -1;
              }
              else
              {
                uint32x2_t v85 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v75 ^ 0xFF));
                *(uint32x2_t *)v86.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v85, v85, 8uLL), (int32x2_t)0x100000001), 8uLL);
                unint64_t v87 = v86.u32[0] | ((unint64_t)(((*v14 & 0x3FF) * (v75 ^ 0xFF)
                                                      + (((*v14 & 0x3FF) * (v75 ^ 0xFF)) >> 8)
                                                      + 1) >> 8) << 32);
                v86.i32[0] = (*v7 * (v75 ^ 0xFF)
                            + ((*v7 * (v75 ^ 0xFF)) >> 8)
                            + 1) >> 8;
                v86.i64[1] = v87;
                int8x8_t v88 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                unint64_t v89 = v88.u32[0] | ((unint64_t)(*v23 & 0x3FF) << 32);
                v90.i64[0] = v75 | ((unint64_t)v88.u32[1] << 32);
                v90.i64[1] = v89;
                int64x2_t v91 = vaddq_s64(v86, v90);
                char v76 = v91.i8[0];
                *int32x2_t v14 = ((unint64_t)v91.i64[0] >> 12) & 0x3FF00000 | v91.i16[6] & 0x3FF | ((v91.i16[4] & 0x3FF) << 10) | 0xC0000000;
              }
            }
            else
            {
              unsigned int v77 = *v71 * v74 + ((*v71 * v74) >> 8) + 1;
              if ((v77 & 0xFF00) == 0) {
                goto LABEL_78;
              }
              unsigned int v78 = (*v23 & 0x3FF) * v74 + (((*v23 & 0x3FF) * v74) >> 8) + 1;
              uint64_t v79 = v77 >> 8;
              uint32x2_t v80 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v79 ^ 0xFF));
              *(uint32x2_t *)v81.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v80, v80, 8uLL), (int32x2_t)0x100000001), 8uLL);
              unint64_t v82 = v81.u32[0] | ((unint64_t)(((*v14 & 0x3FF) * (v79 ^ 0xFF)
                                                    + (((*v14 & 0x3FF) * (v79 ^ 0xFF)) >> 8)
                                                    + 1) >> 8) << 32);
              v81.i32[0] = ((v79 ^ 0xFF) * *v7
                          + (((v79 ^ 0xFF) * *v7) >> 8)
                          + 1) >> 8;
              v81.i64[1] = v82;
              v83.i64[0] = v79 | ((unint64_t)(((((((*v23 >> 20) & 0x3FF) * v74
                                                       + ((((*v23 >> 20) & 0x3FF) * v74) >> 8)) << 12)
                                                     + 4096) & 0x3FF00000 | (v78 >> 8)) >> 20) << 32);
              v83.i32[2] = ((4 * (((*v23 >> 10) & 0x3FF) * v74 + ((((*v23 >> 10) & 0x3FF) * v74) >> 8)) + 4) | (v78 >> 8)) >> 10;
              v83.i32[3] = v78 >> 8;
              int64x2_t v84 = vaddq_s64(v81, v83);
              *int32x2_t v14 = ((unint64_t)v84.i64[0] >> 12) & 0x3FF00000 | v84.i16[6] & 0x3FF | ((v84.i16[4] & 0x3FF) << 10) | 0xC0000000;
              char v76 = v84.i8[0];
            }
            *uint64_t v7 = v76;
LABEL_78:
            v16 += v65;
            v7 += v8;
            int64x2_t v92 = &v23[v65];
            uint64_t v93 = &v71[v66];
            if ((unint64_t)v92 >= v12) {
              CGColorSpaceRef result = v70;
            }
            else {
              CGColorSpaceRef result = 0;
            }
            int v71 = &v93[result];
            uint64_t v23 = &v92[result];
            v14 += v65;
            --v72;
          }
          while (v72);
          if (v837)
          {
            CGColorSpaceRef result = v842;
            unint64_t v94 = v844 + 4 * v842;
            if (v94 >= v837) {
              uint64_t v95 = v69;
            }
            else {
              uint64_t v95 = 0;
            }
            uint64_t v96 = &v843[v840 + v95];
            if (v94 >= v837) {
              uint64_t v97 = v68;
            }
            else {
              uint64_t v97 = 0;
            }
            uint64_t v23 = (unsigned int *)(v94 + 4 * v97);
            v12 += 4 * v97 + 4 * v842;
            v843 += v840 + v95;
            unint64_t v844 = (unint64_t)v23;
            int v71 = v96;
          }
          else
          {
            v23 += v842;
            v71 += v840;
          }
          v16 += v839;
          v14 += v838;
          v7 += v836;
          --v845;
          if (v73 == 1) {
            return result;
          }
        }
      }
      uint64_t v666 = v22;
      uint64_t v667 = -(uint64_t)(v842 * v22);
      uint64_t v668 = -(v840 * v666);
      uint64_t v669 = -(uint64_t)v21;
      __asm { FMOV            V16.2S, #1.875 }
      int8x8_t v671 = (int8x8_t)vdup_n_s32(0xFFC00u);
      int32x4_t v672 = v843;
      break;
    case 3:
      uint64_t v98 = v20;
      uint64_t v99 = v22;
      uint64_t v100 = -(uint64_t)(v842 * v22);
      uint64_t v101 = -(v840 * v99);
      uint64_t v102 = -(uint64_t)v21;
      unsigned __int32 v103 = v843;
      do
      {
        int v104 = v841;
        int v105 = v845;
        do
        {
          int v106 = *v16;
          if (*v16)
          {
            if (v106 == 255)
            {
              if (v20) {
                int v107 = *v103;
              }
              else {
                int v107 = 255;
              }
              unsigned int v109 = *v7;
              uint32x2_t v110 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v109));
              int8x8_t v111 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v110, v110, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
              unsigned int v112 = (v109 * v107 + ((v109 * v107) >> 8) + 1) >> 8;
              unsigned __int32 v113 = v111.i32[0] | (((*v23 & 0x3FF) * v109 + (((*v23 & 0x3FF) * v109) >> 8) + 1) >> 8) | v111.i32[1];
            }
            else
            {
              if (v20) {
                int v108 = *v103;
              }
              else {
                int v108 = 255;
              }
              int v114 = *v7;
              unsigned int v115 = (v114 * v106 + ((v114 * v106) >> 8) + 1) >> 8;
              int8x8_t v116 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFECFFFFFFF6);
              unsigned int v117 = v106 ^ 0xFF;
              unsigned int v112 = ((v115 * v108 + ((v115 * v108) >> 8) + 1) >> 8) + ((v114 * v117 + ((v114 * v117) >> 8) + 1) >> 8);
              if (v112 >= 0xFF) {
                LOBYTE(v112) = -1;
              }
              unsigned int v118 = (((*v14 & 0x3FF) * v117 + (((*v14 & 0x3FF) * v117) >> 8) + 1) >> 8)
                   + ((v115 * (*v23 & 0x3FF) + ((v115 * (*v23 & 0x3FF)) >> 8) + 1) >> 8);
              if (v118 >= 0x3FF) {
                unsigned int v118 = 1023;
              }
              uint32x2_t v119 = (uint32x2_t)vmul_s32(vdup_n_s32(v115), (int32x2_t)vand_s8(v116, (int8x8_t)0x300000003));
              uint32x2_t v120 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v117));
              int8x8_t v121 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v120, v120, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v119, v119, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              unsigned __int32 v113 = vorr_s8(v121, (int8x8_t)vdup_lane_s32((int32x2_t)v121, 1)).u32[0] | v118;
              int v20 = v862;
            }
            *int32x2_t v14 = v113 | 0xC0000000;
            *uint64_t v7 = v112;
          }
          v16 += v27;
          v7 += v8;
          uint32x2_t v122 = &v23[v27];
          unsigned int v123 = &v103[v98];
          if ((unint64_t)v122 >= v12) {
            uint64_t v124 = v102;
          }
          else {
            uint64_t v124 = 0;
          }
          unsigned __int32 v103 = &v123[v124];
          uint64_t v23 = &v122[v124];
          v14 += v27;
          --v104;
        }
        while (v104);
        if (v837)
        {
          unint64_t v125 = v844 + 4 * v842;
          if (v125 >= v837) {
            uint64_t v126 = v101;
          }
          else {
            uint64_t v126 = 0;
          }
          int32x2_t v127 = &v843[v840 + v126];
          if (v125 >= v837) {
            uint64_t v128 = v100;
          }
          else {
            uint64_t v128 = 0;
          }
          uint64_t v23 = (unsigned int *)(v125 + 4 * v128);
          v12 += 4 * v128 + 4 * v842;
          v843 += v840 + v126;
          unint64_t v844 = (unint64_t)v23;
          unsigned __int32 v103 = v127;
        }
        else
        {
          v23 += v842;
          v103 += v840;
        }
        v16 += v839;
        v14 += v838;
        CGColorSpaceRef result = v836;
        v7 += v836;
        --v845;
      }
      while (v105 != 1);
      return result;
    case 4:
      uint64_t v129 = v20;
      uint64_t v130 = v22;
      uint64_t v131 = -(uint64_t)(v842 * v22);
      uint64_t v132 = -(v840 * v130);
      uint64_t v133 = -(uint64_t)v21;
      uint32x2_t v134 = v843;
      do
      {
        int v135 = v841;
        int v136 = v845;
        do
        {
          int v137 = *v16;
          if (*v16)
          {
            if (v137 == 255)
            {
              if (v20) {
                int v138 = *v134;
              }
              else {
                int v138 = 255;
              }
              unsigned int v140 = *v7 ^ 0xFF;
              uint32x2_t v141 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v140));
              int8x8_t v142 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v141, v141, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
              unsigned int v143 = (v140 * v138 + ((v140 * v138) >> 8) + 1) >> 8;
              unsigned __int32 v144 = v142.i32[0] | (((*v23 & 0x3FF) * v140 + (((*v23 & 0x3FF) * v140) >> 8) + 1) >> 8) | v142.i32[1];
            }
            else
            {
              if (v20) {
                int v139 = *v134;
              }
              else {
                int v139 = 255;
              }
              int v145 = *v7;
              unsigned int v146 = ((v145 ^ 0xFF) * v137 + (((v145 ^ 0xFFu) * v137) >> 8) + 1) >> 8;
              int8x8_t v147 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFECFFFFFFF6);
              unsigned int v148 = v137 ^ 0xFF;
              unsigned int v143 = ((v146 * v139 + ((v146 * v139) >> 8) + 1) >> 8) + ((v145 * v148 + ((v145 * v148) >> 8) + 1) >> 8);
              if (v143 >= 0xFF) {
                LOBYTE(v143) = -1;
              }
              unsigned int v149 = (((*v14 & 0x3FF) * v148 + (((*v14 & 0x3FF) * v148) >> 8) + 1) >> 8)
                   + ((v146 * (*v23 & 0x3FF) + ((v146 * (*v23 & 0x3FF)) >> 8) + 1) >> 8);
              if (v149 >= 0x3FF) {
                unsigned int v149 = 1023;
              }
              uint32x2_t v150 = (uint32x2_t)vmul_s32(vdup_n_s32(v146), (int32x2_t)vand_s8(v147, (int8x8_t)0x300000003));
              uint32x2_t v151 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v148));
              int8x8_t v152 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v151, v151, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v150, v150, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              unsigned __int32 v144 = vorr_s8(v152, (int8x8_t)vdup_lane_s32((int32x2_t)v152, 1)).u32[0] | v149;
              int v20 = v862;
            }
            *int32x2_t v14 = v144 | 0xC0000000;
            *uint64_t v7 = v143;
          }
          v16 += v27;
          v7 += v8;
          uint64_t v153 = &v23[v27];
          uint64_t v154 = &v134[v129];
          if ((unint64_t)v153 >= v12) {
            uint64_t v155 = v133;
          }
          else {
            uint64_t v155 = 0;
          }
          uint32x2_t v134 = &v154[v155];
          uint64_t v23 = &v153[v155];
          v14 += v27;
          --v135;
        }
        while (v135);
        if (v837)
        {
          unint64_t v156 = v844 + 4 * v842;
          if (v156 >= v837) {
            uint64_t v157 = v132;
          }
          else {
            uint64_t v157 = 0;
          }
          unsigned int v158 = &v843[v840 + v157];
          if (v156 >= v837) {
            uint64_t v159 = v131;
          }
          else {
            uint64_t v159 = 0;
          }
          uint64_t v23 = (unsigned int *)(v156 + 4 * v159);
          v12 += 4 * v159 + 4 * v842;
          v843 += v840 + v157;
          unint64_t v844 = (unint64_t)v23;
          uint32x2_t v134 = v158;
        }
        else
        {
          v23 += v842;
          v134 += v840;
        }
        v16 += v839;
        v14 += v838;
        CGColorSpaceRef result = v836;
        v7 += v836;
        --v845;
      }
      while (v136 != 1);
      return result;
    case 5:
      uint64_t v160 = v8;
      uint64_t v161 = v20;
      uint64_t v162 = v22;
      uint64_t v163 = -(uint64_t)(v842 * v22);
      uint64_t v164 = -(v840 * v162);
      __asm { FMOV            V1.2S, #1.875 }
      uint64_t v170 = -(uint64_t)v21;
      unsigned int v171 = v843;
      do
      {
        int v172 = v841;
        int v173 = v845;
        do
        {
          int v174 = *v16;
          if (*v16)
          {
            unsigned int v175 = *v7;
            unsigned int v176 = (*v171 * v174 + ((*v171 * v174) >> 8) + 1) >> 8;
            unsigned int v177 = ((*v23 >> 20) & 0x3FF) * v174;
            __int32 v178 = v177 >> 8;
            unsigned int v179 = v177 + 1;
            unsigned int v180 = ((*v23 >> 10) & 0x3FF) * v174;
            unsigned int v181 = ((*v23 & 0x3FF) * v174 + (((*v23 & 0x3FF) * v174) >> 8) + 1) >> 8;
            unsigned int v182 = v176 * v175 + ((v176 * v175) >> 8) + 1;
            unsigned int v183 = v176 ^ 0xFF;
            unsigned int v184 = ((v183 * v175 + ((v183 * v175) >> 8) + 1) >> 8) + (v182 >> 8);
            if (v184 >= 0xFF) {
              LOBYTE(v184) = -1;
            }
            unsigned int v185 = ((v183 * (*v14 & 0x3FF) + ((v183 * (*v14 & 0x3FF)) >> 8) + 1) >> 8)
                 + ((v181 * v175 + ((v181 * v175) >> 8) + 1) >> 8);
            if (v185 >= 0x3FF) {
              unsigned int v185 = 1023;
            }
            v186.i32[0] = 1;
            v186.i32[1] = v178;
            int32x2_t v187 = vadd_s32((int32x2_t)__PAIR64__(v179, v180), v186);
            v186.i32[0] = vshl_n_s32(vadd_s32(v187, (int32x2_t)((v180 >> 8) | 0xC00000000)), 2uLL).u32[0];
            v186.i32[1] = vand_s8((int8x8_t)vshl_n_s32(v187, 0xCuLL), _D1).i32[1];
            uint32x2_t v188 = (uint32x2_t)vmul_s32((int32x2_t)vshl_u32((uint32x2_t)vorr_s8((int8x8_t)vdup_n_s32(v181), (int8x8_t)v186), (uint32x2_t)0xFFFFFFECFFFFFFF6), vdup_n_s32(v175));
            uint32x2_t v189 = (uint32x2_t)vmul_s32(vdup_n_s32(v183), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
            int8x8_t v190 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v188, v188, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v189, v189, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            *int32x2_t v14 = vorr_s8(v190, (int8x8_t)vdup_lane_s32((int32x2_t)v190, 1)).u32[0] | v185 | 0xC0000000;
            *uint64_t v7 = v184;
          }
          v16 += v27;
          v7 += v160;
          int32x4_t v191 = &v23[v27];
          int32x4_t v192 = &v171[v161];
          if ((unint64_t)v191 >= v12) {
            uint64_t v193 = v170;
          }
          else {
            uint64_t v193 = 0;
          }
          unsigned int v171 = &v192[v193];
          uint64_t v23 = &v191[v193];
          v14 += v27;
          --v172;
        }
        while (v172);
        if (v837)
        {
          unint64_t v194 = v844 + 4 * v842;
          if (v194 >= v837) {
            uint64_t v195 = v164;
          }
          else {
            uint64_t v195 = 0;
          }
          unsigned int v196 = &v843[v840 + v195];
          if (v194 >= v837) {
            uint64_t v197 = v163;
          }
          else {
            uint64_t v197 = 0;
          }
          uint64_t v23 = (unsigned int *)(v194 + 4 * v197);
          v12 += 4 * v197 + 4 * v842;
          v843 += v840 + v195;
          unint64_t v844 = (unint64_t)v23;
          unsigned int v171 = v196;
        }
        else
        {
          v23 += v842;
          v171 += v840;
        }
        v16 += v839;
        v14 += v838;
        CGColorSpaceRef result = v836;
        v7 += v836;
        --v845;
      }
      while (v173 != 1);
      return result;
    case 6:
      uint64_t v198 = v22;
      uint64_t v199 = -(uint64_t)(v842 * v22);
      uint64_t v200 = -(v840 * v198);
      uint64_t v201 = -(uint64_t)v21;
      uint32x4_t v202 = v843;
      do
      {
        int v203 = v841;
        int v204 = v845;
        do
        {
          unsigned int v205 = *v16;
          if (*v16)
          {
            uint64_t v206 = *v7;
            if ((_BYTE)v206 != 0xFF)
            {
              if (~(_BYTE)v206 == 255)
              {
                if (v20) {
                  int v207 = *v202;
                }
                else {
                  int v207 = 255;
                }
                uint32x2_t v209 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v205));
                int8x8_t v210 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v209, v209, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                LODWORD(v206) = (v207 * v205 + ((v207 * v205) >> 8) + 1) >> 8;
                unsigned int v211 = v210.i32[0] | (((*v23 & 0x3FF) * v205 + (((*v23 & 0x3FF) * v205) >> 8) + 1) >> 8) | v210.i32[1] | 0xC0000000;
              }
              else
              {
                if (v20) {
                  int v208 = *v202;
                }
                else {
                  int v208 = 255;
                }
                unsigned int v212 = (~(_BYTE)v206 * v205 + ((~(_BYTE)v206 * v205) >> 8) + 1) >> 8;
                uint32x2_t v213 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v212));
                *(uint32x2_t *)v214.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v213, v213, 8uLL), (int32x2_t)0x100000001), 8uLL);
                unint64_t v215 = v214.u32[0] | ((unint64_t)(((*v23 & 0x3FF) * v212 + (((*v23 & 0x3FF) * v212) >> 8) + 1) >> 8) << 32);
                v214.i32[0] = (v212 * v208 + ((v212 * v208) >> 8) + 1) >> 8;
                v214.i64[1] = v215;
                int8x8_t v216 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                unint64_t v217 = v216.u32[0] | ((unint64_t)(*v14 & 0x3FF) << 32);
                v218.i64[0] = v206 | ((unint64_t)v216.u32[1] << 32);
                v218.i64[1] = v217;
                int64x2_t v219 = vaddq_s64(v214, v218);
                LOBYTE(v206) = v219.i8[0];
                unsigned int v211 = ((unint64_t)v219.i64[0] >> 12) & 0x3FF00000 | v219.i16[6] & 0x3FF | ((v219.i16[4] & 0x3FF) << 10) | 0xC0000000;
              }
              *int32x2_t v14 = v211;
              *uint64_t v7 = v206;
            }
          }
          v16 += v27;
          v7 += v8;
          uint32x2_t v220 = &v23[v27];
          int8x8_t v221 = &v202[v20];
          if ((unint64_t)v220 >= v12) {
            uint64_t v222 = v201;
          }
          else {
            uint64_t v222 = 0;
          }
          uint32x4_t v202 = &v221[v222];
          uint64_t v23 = &v220[v222];
          v14 += v27;
          --v203;
        }
        while (v203);
        CGColorSpaceRef result = v837;
        if (v837)
        {
          unint64_t v223 = v844 + 4 * v842;
          if (v223 >= v837) {
            uint64_t v224 = v200;
          }
          else {
            uint64_t v224 = 0;
          }
          uint64_t v225 = &v843[v840 + v224];
          if (v223 >= v837) {
            uint64_t v226 = v199;
          }
          else {
            uint64_t v226 = 0;
          }
          CGColorSpaceRef result = v12 + 4 * v226;
          uint64_t v23 = (unsigned int *)(v223 + 4 * v226);
          unint64_t v12 = result + 4 * v842;
          v843 = v225;
          unint64_t v844 = (unint64_t)v23;
          uint32x4_t v202 = v225;
        }
        else
        {
          v23 += v842;
          v202 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v204 != 1);
      return result;
    case 7:
      if (v8)
      {
        uint64_t v227 = v8;
        uint64_t v228 = v22;
        uint64_t v229 = -(uint64_t)(v842 * v22);
        uint64_t v230 = -(v840 * v228);
        uint64_t v231 = -(uint64_t)v21;
        unsigned int v232 = v843;
        do
        {
          int v233 = v841;
          int v234 = v845;
          do
          {
            int v235 = *v16;
            if (*v16)
            {
              if (v235 == 255)
              {
                unsigned int v236 = *v232;
                unsigned int v237 = (v236 * *v7 + ((v236 * *v7) >> 8) + 1) >> 8;
                uint32x2_t v238 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v236));
                int8x8_t v239 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v238, v238, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v240 = v239.u32[1];
                unsigned __int32 v241 = v239.i32[0] | (((*v14 & 0x3FF) * v236 + (((*v14 & 0x3FF) * v236) >> 8) + 1) >> 8);
              }
              else
              {
                unsigned int v242 = (*v232 * v235 + ((*v232 * v235) >> 8) + 1) >> 8;
                unsigned int v243 = v235 ^ 0xFF;
                unsigned int v237 = ((v242 * *v7 + ((v242 * *v7) >> 8) + 1) >> 8)
                     + ((*v7 * v243 + ((*v7 * v243) >> 8) + 1) >> 8);
                if (v237 >= 0xFF) {
                  LOBYTE(v237) = -1;
                }
                unsigned int v240 = ((v242 * (*v14 & 0x3FF) + ((v242 * (*v14 & 0x3FF)) >> 8) + 1) >> 8)
                     + (((*v14 & 0x3FF) * v243 + (((*v14 & 0x3FF) * v243) >> 8) + 1) >> 8);
                if (v240 >= 0x3FF) {
                  unsigned int v240 = 1023;
                }
                int32x2_t v244 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                uint32x2_t v245 = (uint32x2_t)vmul_s32(vdup_n_s32(v242), v244);
                uint32x2_t v246 = (uint32x2_t)vmul_s32(v244, vdup_n_s32(v243));
                int8x8_t v247 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v245, v245, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v246, v246, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                unsigned __int32 v241 = vorr_s8(v247, (int8x8_t)vdup_lane_s32((int32x2_t)v247, 1)).u32[0];
              }
              *int32x2_t v14 = v241 | v240 | 0xC0000000;
              *uint64_t v7 = v237;
            }
            v16 += v27;
            v7 += v227;
            uint64_t v248 = &v23[v27];
            v249 = &v232[v20];
            if ((unint64_t)v248 >= v12) {
              uint64_t v250 = v231;
            }
            else {
              uint64_t v250 = 0;
            }
            unsigned int v232 = &v249[v250];
            uint64_t v23 = &v248[v250];
            v14 += v27;
            --v233;
          }
          while (v233);
          if (v837)
          {
            unint64_t v251 = v844 + 4 * v842;
            if (v251 >= v837) {
              uint64_t v252 = v230;
            }
            else {
              uint64_t v252 = 0;
            }
            uint64_t v253 = &v843[v840 + v252];
            if (v251 >= v837) {
              uint64_t v254 = v229;
            }
            else {
              uint64_t v254 = 0;
            }
            uint64_t v23 = (unsigned int *)(v251 + 4 * v254);
            v12 += 4 * v254 + 4 * v842;
            v843 += v840 + v252;
            unint64_t v844 = (unint64_t)v23;
            unsigned int v232 = v253;
          }
          else
          {
            v23 += v842;
            v232 += v840;
          }
          v16 += v839;
          v14 += v838;
          CGColorSpaceRef result = v836;
          v7 += v836;
          --v845;
        }
        while (v234 != 1);
      }
      else
      {
        uint64_t v694 = v22;
        uint64_t v695 = -(uint64_t)(v842 * v22);
        uint64_t v696 = -(v840 * v694);
        uint64_t v697 = -(uint64_t)v21;
        int8x8_t v698 = v843;
        do
        {
          int v699 = v841;
          int v700 = v845;
          do
          {
            int v701 = *v16;
            if (*v16)
            {
              if (v701 == 255)
              {
                unsigned int v702 = *v698;
                uint32x2_t v703 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v702));
                int8x8_t v704 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v703, v703, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned __int32 v705 = *v14
                     - (v704.i32[0] | (((*v14 & 0x3FF) * v702 + (((*v14 & 0x3FF) * v702) >> 8) + 1) >> 8) | v704.i32[1])
                     + 0x40000000;
              }
              else
              {
                unsigned int v706 = (*v698 * v701 + ((*v698 * v701) >> 8) + 1) >> 8;
                unsigned int v707 = v701 ^ 0xFF;
                unsigned int v708 = ((v706 * (*v14 & 0x3FF) + ((v706 * (*v14 & 0x3FF)) >> 8) + 1) >> 8)
                     + (((*v14 & 0x3FF) * v707 + (((*v14 & 0x3FF) * v707) >> 8) + 1) >> 8);
                if (v708 >= 0x3FF) {
                  unsigned int v708 = 1023;
                }
                int32x2_t v709 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                uint32x2_t v710 = (uint32x2_t)vmul_s32(vdup_n_s32(v706), v709);
                uint32x2_t v711 = (uint32x2_t)vmul_s32(v709, vdup_n_s32(v707));
                int8x8_t v712 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v710, v710, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v711, v711, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                unsigned __int32 v705 = vorr_s8(v712, (int8x8_t)vdup_lane_s32((int32x2_t)v712, 1)).u32[0] | v708 | 0xC0000000;
              }
              *int32x2_t v14 = v705;
            }
            v16 += v27;
            uint64_t v713 = &v23[v27];
            uint64_t v714 = &v698[v20];
            if ((unint64_t)v713 >= v12) {
              uint64_t v715 = v697;
            }
            else {
              uint64_t v715 = 0;
            }
            int8x8_t v698 = &v714[v715];
            uint64_t v23 = &v713[v715];
            v14 += v27;
            --v699;
          }
          while (v699);
          CGColorSpaceRef result = v837;
          if (v837)
          {
            unint64_t v716 = v844 + 4 * v842;
            if (v716 >= v837) {
              uint64_t v717 = v696;
            }
            else {
              uint64_t v717 = 0;
            }
            uint64_t v718 = &v843[v840 + v717];
            if (v716 >= v837) {
              uint64_t v719 = v695;
            }
            else {
              uint64_t v719 = 0;
            }
            CGColorSpaceRef result = v12 + 4 * v719;
            uint64_t v23 = (unsigned int *)(v716 + 4 * v719);
            unint64_t v12 = result + 4 * v842;
            v843 = v718;
            unint64_t v844 = (unint64_t)v23;
            int8x8_t v698 = v718;
          }
          else
          {
            v23 += v842;
            v698 += v840;
          }
          v16 += v839;
          v14 += v838;
          --v845;
        }
        while (v700 != 1);
      }
      return result;
    case 8:
      uint64_t v255 = v27;
      if (v8)
      {
        uint64_t v256 = v8;
        uint64_t v257 = v22;
        uint64_t v258 = -(uint64_t)(v842 * v22);
        uint64_t v259 = -(v840 * v257);
        uint64_t v260 = -(uint64_t)v21;
        v261 = v843;
        do
        {
          int v262 = v9;
          int v263 = v845;
          do
          {
            int v264 = *v16;
            if (*v16)
            {
              if (v264 == 255)
              {
                unsigned int v265 = *v261 ^ 0xFF;
                unsigned int v266 = v265 * *v7 + ((v265 * *v7) >> 8) + 1;
                uint32x2_t v267 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v265));
                uint32x2_t v268 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v267, v267, 8uLL), (int32x2_t)0x100000001);
                unsigned int v269 = (*v14 & 0x3FF) * v265;
              }
              else
              {
                unsigned int v270 = ((*v261 * v264 + ((*v261 * v264) >> 8) + 1) >> 8) ^ 0xFF;
                unsigned int v266 = v270 * *v7 + ((v270 * *v7) >> 8) + 1;
                uint32x2_t v271 = (uint32x2_t)vmul_s32(vdup_n_s32(v270), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003));
                uint32x2_t v268 = (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v271, v271, 8uLL), (int32x2_t)0x100000001);
                unsigned int v269 = v270 * (*v14 & 0x3FF);
              }
              int8x8_t v272 = vand_s8((int8x8_t)vshl_u32(v268, (uint32x2_t)0x20000000CLL), (int8x8_t)0xFFC003FF00000);
              *int32x2_t v14 = v272.i32[0] | ((v269 + (v269 >> 8) + 1) >> 8) | v272.i32[1] | 0xC0000000;
              *uint64_t v7 = BYTE1(v266);
            }
            v16 += v255;
            v7 += v256;
            v273 = &v23[v255];
            uint64_t v274 = &v261[v20];
            if ((unint64_t)v273 >= v12) {
              CGColorSpaceRef result = v260;
            }
            else {
              CGColorSpaceRef result = 0;
            }
            v261 = &v274[result];
            uint64_t v23 = &v273[result];
            v14 += v255;
            --v262;
          }
          while (v262);
          if (v837)
          {
            CGColorSpaceRef result = v842;
            unint64_t v275 = v844 + 4 * v842;
            if (v275 >= v837) {
              uint64_t v276 = v259;
            }
            else {
              uint64_t v276 = 0;
            }
            uint64_t v277 = &v843[v840 + v276];
            if (v275 >= v837) {
              uint64_t v278 = v258;
            }
            else {
              uint64_t v278 = 0;
            }
            uint64_t v23 = (unsigned int *)(v275 + 4 * v278);
            v12 += 4 * v278 + 4 * v842;
            v843 += v840 + v276;
            unint64_t v844 = (unint64_t)v23;
            v261 = v277;
          }
          else
          {
            v23 += v842;
            v261 += v840;
          }
          v16 += v839;
          v14 += v838;
          v7 += v836;
          --v845;
        }
        while (v263 != 1);
      }
      else
      {
        uint64_t v720 = -(uint64_t)v21;
        uint64_t v721 = v22;
        uint64_t v722 = v843;
        uint64_t v723 = -(uint64_t)(v842 * v22);
        uint64_t v724 = -(v840 * v721);
        do
        {
          int v725 = v841;
          int v726 = v845;
          do
          {
            int v727 = *v16;
            if (*v16)
            {
              if (v727 == 255)
              {
                unsigned int v728 = *v722 ^ 0xFF;
                uint32x2_t v729 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v728));
              }
              else
              {
                unsigned int v728 = ((*v722 * v727 + ((*v722 * v727) >> 8) + 1) >> 8) ^ 0xFF;
                uint32x2_t v729 = (uint32x2_t)vmul_s32(vdup_n_s32(v728), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
              }
              int8x8_t v730 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v729, v729, 8uLL), (int32x2_t)0x100000001), (uint32x2_t)0xC00000002), (int8x8_t)0x3FF00000000FFC00);
              *int32x2_t v14 = *v14
                   - (v730.i32[1] | (((*v14 & 0x3FF) * v728 + (((*v14 & 0x3FF) * v728) >> 8) + 1) >> 8) | v730.i32[0])
                   + 0x40000000;
            }
            v16 += v255;
            unint64_t v731 = &v23[v255];
            v732 = &v722[v20];
            if ((unint64_t)v731 >= v12) {
              CGColorSpaceRef result = v720;
            }
            else {
              CGColorSpaceRef result = 0;
            }
            uint64_t v722 = &v732[result];
            uint64_t v23 = &v731[result];
            v14 += v255;
            --v725;
          }
          while (v725);
          if (v837)
          {
            CGColorSpaceRef result = v842;
            unint64_t v733 = v844 + 4 * v842;
            if (v733 >= v837) {
              uint64_t v734 = v724;
            }
            else {
              uint64_t v734 = 0;
            }
            int v735 = &v843[v840 + v734];
            if (v733 >= v837) {
              uint64_t v736 = v723;
            }
            else {
              uint64_t v736 = 0;
            }
            uint64_t v23 = (unsigned int *)(v733 + 4 * v736);
            v12 += 4 * v736 + 4 * v842;
            v843 += v840 + v734;
            unint64_t v844 = (unint64_t)v23;
            uint64_t v722 = v735;
          }
          else
          {
            v23 += v842;
            v722 += v840;
          }
          v16 += v839;
          v14 += v838;
          --v845;
        }
        while (v726 != 1);
      }
      return result;
    case 9:
      uint64_t v279 = v8;
      uint64_t v280 = v20;
      uint64_t v281 = v22;
      uint64_t v282 = -(uint64_t)v21;
      v283 = v843;
      uint64_t v284 = -(uint64_t)(v842 * v22);
      do
      {
        int v285 = v841;
        int v286 = v845;
        do
        {
          int v287 = *v16;
          if (*v16)
          {
            int v288 = *v7;
            unsigned int v289 = *v283 * v287 + ((*v283 * v287) >> 8) + 1;
            unsigned int v290 = ((*v23 & 0x3FF) * v287 + (((*v23 & 0x3FF) * v287) >> 8) + 1) >> 8;
            unsigned int v291 = (((((*v23 >> 20) & 0x3FF) * v287 + ((((*v23 >> 20) & 0x3FF) * v287) >> 8)) << 12) + 4096) & 0x3FF00000 | v290;
            unsigned int v292 = (4 * (((*v23 >> 10) & 0x3FF) * v287 + ((((*v23 >> 10) & 0x3FF) * v287) >> 8)) + 4) | v290;
            LOBYTE(v293) = ~(_BYTE)v287 + BYTE1(v289);
            unsigned int v294 = (v289 >> 8) * (v288 ^ 0xFF) + (((v289 >> 8) * (v288 ^ 0xFF)) >> 8) + 1;
            unsigned int v295 = (v291 >> 20) * (v288 ^ 0xFF) + (((v291 >> 20) * (v288 ^ 0xFF)) >> 8) + 1;
            unsigned int v296 = ((v292 >> 10) * (v288 ^ 0xFF) + (((v292 >> 10) * (v288 ^ 0xFF)) >> 8) + 1) >> 8;
            unsigned int v297 = v290 * (v288 ^ 0xFF) + ((v290 * (v288 ^ 0xFF)) >> 8) + 1;
            int v293 = v293;
            unsigned int v298 = (v293 * v288 + ((v293 * v288) >> 8) + 1) >> 8;
            unsigned int v299 = (((*v14 >> 20) & 0x3FF) * v293 + ((((*v14 >> 20) & 0x3FF) * v293) >> 8) + 1) >> 8;
            unsigned int v300 = ((*v14 >> 10) & 0x3FF) * v293 + ((((*v14 >> 10) & 0x3FF) * v293) >> 8) + 1;
            unsigned int v301 = ((*v14 & 0x3FF) * v293 + (((*v14 & 0x3FF) * v293) >> 8) + 1) >> 8;
            unsigned int v302 = v298 + (v294 >> 8);
            if (v302 >= 0xFF) {
              LOBYTE(v302) = -1;
            }
            unsigned int v303 = v299 + (v295 >> 8);
            if (v303 >= 0x3FF) {
              unsigned int v303 = 1023;
            }
            unsigned int v304 = v296 + (v300 >> 8);
            if (v304 >= 0x3FF) {
              unsigned int v304 = 1023;
            }
            unsigned int v305 = v301 + (v297 >> 8);
            if (v305 >= 0x3FF) {
              unsigned int v305 = 1023;
            }
            *int32x2_t v14 = (v304 << 10) | (v303 << 20) | v305 | 0xC0000000;
            *uint64_t v7 = v302;
          }
          v16 += v27;
          v7 += v279;
          unint64_t v306 = &v23[v27];
          v307 = &v283[v280];
          if ((unint64_t)v306 >= v12) {
            uint64_t v308 = v282;
          }
          else {
            uint64_t v308 = 0;
          }
          v283 = &v307[v308];
          uint64_t v23 = &v306[v308];
          v14 += v27;
          --v285;
        }
        while (v285);
        if (v837)
        {
          unint64_t v309 = v844 + 4 * v842;
          if (v309 >= v837) {
            uint64_t v310 = -(v840 * v281);
          }
          else {
            uint64_t v310 = 0;
          }
          uint64_t v311 = &v843[v840 + v310];
          if (v309 >= v837) {
            uint64_t v312 = v284;
          }
          else {
            uint64_t v312 = 0;
          }
          uint64_t v23 = (unsigned int *)(v309 + 4 * v312);
          v12 += 4 * v312 + 4 * v842;
          v843 += v840 + v310;
          unint64_t v844 = (unint64_t)v23;
          v283 = v311;
        }
        else
        {
          v23 += v842;
          v283 += v840;
        }
        v16 += v839;
        v14 += v838;
        CGColorSpaceRef result = v836;
        v7 += v836;
        --v845;
      }
      while (v286 != 1);
      return result;
    case 10:
      uint64_t v313 = v8;
      uint64_t v314 = v20;
      uint64_t v315 = v22;
      uint64_t v316 = -(uint64_t)(v842 * v22);
      uint64_t v317 = -(v840 * v315);
      __asm { FMOV            V1.2S, #1.875 }
      uint64_t v319 = -(uint64_t)v21;
      uint64_t v320 = v843;
      do
      {
        int v321 = v841;
        int v322 = v845;
        do
        {
          int v323 = *v16;
          if (*v16)
          {
            int v324 = *v7;
            unsigned int v325 = (*v320 * v323 + ((*v320 * v323) >> 8) + 1) >> 8;
            unsigned int v326 = ((*v23 >> 20) & 0x3FF) * v323;
            __int32 v327 = v326 >> 8;
            unsigned int v328 = v326 + 1;
            unsigned int v329 = ((*v23 >> 10) & 0x3FF) * v323;
            unsigned int v330 = ((*v23 & 0x3FF) * v323 + (((*v23 & 0x3FF) * v323) >> 8) + 1) >> 8;
            unsigned int v331 = v324 ^ 0xFF;
            unsigned int v332 = v325 * v331 + ((v325 * v331) >> 8) + 1;
            unsigned int v333 = v325 ^ 0xFF;
            unsigned int v334 = ((v333 * v324 + ((v333 * v324) >> 8) + 1) >> 8) + (v332 >> 8);
            if (v334 >= 0xFF) {
              LOBYTE(v334) = -1;
            }
            unsigned int v335 = ((v333 * (*v14 & 0x3FF) + ((v333 * (*v14 & 0x3FF)) >> 8) + 1) >> 8)
                 + ((v330 * v331 + ((v330 * v331) >> 8) + 1) >> 8);
            if (v335 >= 0x3FF) {
              unsigned int v335 = 1023;
            }
            v336.i32[0] = 1;
            v336.i32[1] = v327;
            int32x2_t v337 = vadd_s32((int32x2_t)__PAIR64__(v328, v329), v336);
            v336.i32[0] = vshl_n_s32(vadd_s32(v337, (int32x2_t)((v329 >> 8) | 0xC00000000)), 2uLL).u32[0];
            v336.i32[1] = vand_s8((int8x8_t)vshl_n_s32(v337, 0xCuLL), _D1).i32[1];
            uint32x2_t v338 = (uint32x2_t)vmul_s32((int32x2_t)vshl_u32((uint32x2_t)vorr_s8((int8x8_t)vdup_n_s32(v330), (int8x8_t)v336), (uint32x2_t)0xFFFFFFECFFFFFFF6), vdup_n_s32(v331));
            uint32x2_t v339 = (uint32x2_t)vmul_s32(vdup_n_s32(v333), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
            int8x8_t v340 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v338, v338, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v339, v339, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
            *int32x2_t v14 = vorr_s8(v340, (int8x8_t)vdup_lane_s32((int32x2_t)v340, 1)).u32[0] | v335 | 0xC0000000;
            *uint64_t v7 = v334;
          }
          v16 += v27;
          v7 += v313;
          unint64_t v341 = &v23[v27];
          unint64_t v342 = &v320[v314];
          if ((unint64_t)v341 >= v12) {
            uint64_t v343 = v319;
          }
          else {
            uint64_t v343 = 0;
          }
          uint64_t v320 = &v342[v343];
          uint64_t v23 = &v341[v343];
          v14 += v27;
          --v321;
        }
        while (v321);
        if (v837)
        {
          unint64_t v344 = v844 + 4 * v842;
          if (v344 >= v837) {
            uint64_t v345 = v317;
          }
          else {
            uint64_t v345 = 0;
          }
          uint64_t v346 = &v843[v840 + v345];
          if (v344 >= v837) {
            uint64_t v347 = v316;
          }
          else {
            uint64_t v347 = 0;
          }
          uint64_t v23 = (unsigned int *)(v344 + 4 * v347);
          v12 += 4 * v347 + 4 * v842;
          v843 += v840 + v345;
          unint64_t v844 = (unint64_t)v23;
          uint64_t v320 = v346;
        }
        else
        {
          v23 += v842;
          v320 += v840;
        }
        v16 += v839;
        v14 += v838;
        CGColorSpaceRef result = v836;
        v7 += v836;
        --v845;
      }
      while (v322 != 1);
      return result;
    case 11:
      uint64_t v348 = v27;
      if (v8)
      {
        uint64_t v349 = v8;
        uint64_t v350 = v20;
        uint64_t v351 = v22;
        int v352 = v843;
        uint64_t v353 = -(uint64_t)(v842 * v22);
        uint64_t v354 = -(v840 * v351);
        uint64_t v355 = -(uint64_t)v21;
        do
        {
          int v356 = v841;
          int v357 = v845;
          do
          {
            int v358 = *v16;
            if (*v16)
            {
              if (v20) {
                int v359 = *v352;
              }
              else {
                int v359 = 255;
              }
              unsigned int v360 = v359 * v358 + ((v359 * v358) >> 8) + 1;
              unsigned int v361 = (((*v23 >> 20) & 0x3FF) * v358 + ((((*v23 >> 20) & 0x3FF) * v358) >> 8)) << 12;
              unsigned int v362 = 4 * (((*v23 >> 10) & 0x3FF) * v358 + ((((*v23 >> 10) & 0x3FF) * v358) >> 8));
              unsigned int v363 = (*v23 & 0x3FF) * v358 + (((*v23 & 0x3FF) * v358) >> 8) + 1;
              unsigned int v364 = (v361 + 4096) & 0x3FF00000 | (v363 >> 8);
              unsigned int v365 = *v7 + (v360 >> 8);
              if (v365 >= 0xFF) {
                LOBYTE(v365) = -1;
              }
              unsigned int v366 = ((*v14 >> 20) & 0x3FF) + (v364 >> 20);
              if (v366 >= 0x3FF) {
                unsigned int v366 = 1023;
              }
              unsigned int v367 = ((*v14 >> 10) & 0x3FF) + (((v362 + 4) | (v363 >> 8)) >> 10);
              if (v367 >= 0x3FF) {
                unsigned int v367 = 1023;
              }
              unsigned int v368 = (*v14 & 0x3FF) + (v363 >> 8);
              if (v368 >= 0x3FF) {
                unsigned int v368 = 1023;
              }
              *int32x2_t v14 = (v367 << 10) | (v366 << 20) | v368 | 0xC0000000;
              *uint64_t v7 = v365;
              int v20 = v862;
            }
            v16 += v27;
            v7 += v349;
            v369 = &v23[v27];
            uint64_t v370 = &v352[v350];
            if ((unint64_t)v369 >= v12) {
              uint64_t v371 = v355;
            }
            else {
              uint64_t v371 = 0;
            }
            int v352 = &v370[v371];
            uint64_t v23 = &v369[v371];
            v14 += v27;
            --v356;
          }
          while (v356);
          if (v837)
          {
            unint64_t v372 = v844 + 4 * v842;
            if (v372 >= v837) {
              uint64_t v373 = v354;
            }
            else {
              uint64_t v373 = 0;
            }
            int v374 = &v843[v840 + v373];
            if (v372 >= v837) {
              uint64_t v375 = v353;
            }
            else {
              uint64_t v375 = 0;
            }
            uint64_t v23 = (unsigned int *)(v372 + 4 * v375);
            v12 += 4 * v375 + 4 * v842;
            v843 += v840 + v373;
            unint64_t v844 = (unint64_t)v23;
            int v352 = v374;
          }
          else
          {
            v23 += v842;
            v352 += v840;
          }
          v16 += v839;
          v14 += v838;
          CGColorSpaceRef result = v836;
          v7 += v836;
          --v845;
        }
        while (v357 != 1);
      }
      else
      {
        uint64_t v737 = -(uint64_t)v21;
        uint64_t v738 = -(uint64_t)(v842 * v22);
        do
        {
          int v739 = v841;
          int v740 = v845;
          do
          {
            int v741 = *v16;
            if (*v16)
            {
              unsigned int v742 = (((*v23 >> 20) & 0x3FF) * v741 + ((((*v23 >> 20) & 0x3FF) * v741) >> 8)) << 12;
              unsigned int v743 = 4 * (((*v23 >> 10) & 0x3FF) * v741 + ((((*v23 >> 10) & 0x3FF) * v741) >> 8));
              unsigned int v744 = (*v23 & 0x3FF) * v741 + (((*v23 & 0x3FF) * v741) >> 8) + 1;
              unsigned int v745 = ((*v14 >> 20) & 0x3FF) + (((v742 + 4096) & 0x3FF00000 | (v744 >> 8)) >> 20);
              if (v745 >= 0x3FF) {
                unsigned int v745 = 1023;
              }
              unsigned int v746 = ((*v14 >> 10) & 0x3FF) + (((v743 + 4) | (v744 >> 8)) >> 10);
              if (v746 >= 0x3FF) {
                unsigned int v746 = 1023;
              }
              unsigned int v747 = (*v14 & 0x3FF) + (v744 >> 8);
              if (v747 >= 0x3FF) {
                unsigned int v747 = 1023;
              }
              *int32x2_t v14 = (v746 << 10) | (v745 << 20) | v747 | 0xC0000000;
            }
            v16 += v348;
            uint64_t v748 = &v23[v348];
            if ((unint64_t)v748 >= v12) {
              uint64_t v749 = v737;
            }
            else {
              uint64_t v749 = 0;
            }
            uint64_t v23 = &v748[v749];
            v14 += v348;
            --v739;
          }
          while (v739);
          v16 += v839;
          v14 += v838;
          CGColorSpaceRef result = v844;
          unint64_t v750 = v844 + 4 * v842;
          if (v750 >= v837) {
            uint64_t v751 = v738;
          }
          else {
            uint64_t v751 = 0;
          }
          uint64_t v752 = (unsigned int *)(v750 + 4 * v751);
          uint64_t v753 = v12 + 4 * v751 + 4 * v842;
          if (v837)
          {
            unint64_t v12 = v753;
            CGColorSpaceRef result = (unint64_t)v752;
            uint64_t v23 = v752;
          }
          else
          {
            v23 += v842;
          }
          unint64_t v844 = result;
          --v845;
        }
        while (v740 != 1);
      }
      return result;
    case 12:
      uint64_t v376 = v27;
      if (v8)
      {
        uint64_t v377 = v8;
        uint64_t v378 = v20;
        uint64_t v379 = v22;
        uint64_t v380 = v843;
        uint64_t v381 = -(uint64_t)(v842 * v22);
        uint64_t v382 = -(v840 * v379);
        uint64_t v383 = -(uint64_t)v21;
        do
        {
          int v384 = v841;
          int v385 = v845;
          do
          {
            int v386 = *v16;
            if (*v16)
            {
              if (v20) {
                int v387 = *v380;
              }
              else {
                int v387 = 255;
              }
              unsigned int v388 = v387 * v386 + ((v387 * v386) >> 8) + 1;
              unsigned int v389 = (((*v23 >> 20) & 0x3FF) * v386 + ((((*v23 >> 20) & 0x3FF) * v386) >> 8)) << 12;
              unsigned int v390 = 4 * (((*v23 >> 10) & 0x3FF) * v386 + ((((*v23 >> 10) & 0x3FF) * v386) >> 8));
              unsigned int v391 = (*v23 & 0x3FF) * v386 + (((*v23 & 0x3FF) * v386) >> 8) + 1;
              unsigned int v392 = (v389 + 4096) & 0x3FF00000 | (v391 >> 8);
              unsigned int v393 = *v7 + (v388 >> 8);
              if (v393 >= 0xFF) {
                LOBYTE(v393) = -1;
              }
              unsigned int v394 = ((*v14 >> 20) & 0x3FF) + (v392 >> 20);
              if (v394 >= 0x3FF) {
                unsigned int v394 = 1023;
              }
              unsigned int v395 = ((*v14 >> 10) & 0x3FF) + (((v390 + 4) | (v391 >> 8)) >> 10);
              if (v395 >= 0x3FF) {
                unsigned int v395 = 1023;
              }
              unsigned int v396 = (*v14 & 0x3FF) + (v391 >> 8);
              if (v396 >= 0x3FF) {
                unsigned int v396 = 1023;
              }
              *int32x2_t v14 = (v395 << 10) | (v394 << 20) | v396 | 0xC0000000;
              *uint64_t v7 = v393;
              int v20 = v862;
            }
            v16 += v27;
            v7 += v377;
            uint64_t v397 = &v23[v27];
            int v398 = &v380[v378];
            if ((unint64_t)v397 >= v12) {
              uint64_t v399 = v383;
            }
            else {
              uint64_t v399 = 0;
            }
            uint64_t v380 = &v398[v399];
            uint64_t v23 = &v397[v399];
            v14 += v27;
            --v384;
          }
          while (v384);
          if (v837)
          {
            unint64_t v400 = v844 + 4 * v842;
            if (v400 >= v837) {
              uint64_t v401 = v382;
            }
            else {
              uint64_t v401 = 0;
            }
            unint64_t v402 = &v843[v840 + v401];
            if (v400 >= v837) {
              uint64_t v403 = v381;
            }
            else {
              uint64_t v403 = 0;
            }
            uint64_t v23 = (unsigned int *)(v400 + 4 * v403);
            v12 += 4 * v403 + 4 * v842;
            v843 += v840 + v401;
            unint64_t v844 = (unint64_t)v23;
            uint64_t v380 = v402;
          }
          else
          {
            v23 += v842;
            v380 += v840;
          }
          v16 += v839;
          v14 += v838;
          CGColorSpaceRef result = v836;
          v7 += v836;
          --v845;
        }
        while (v385 != 1);
      }
      else
      {
        uint64_t v754 = -(uint64_t)(v842 * v22);
        uint64_t v755 = -(uint64_t)v21;
        do
        {
          int v756 = v841;
          int v757 = v845;
          do
          {
            unsigned int v758 = *v16;
            if (*v16)
            {
              uint32x2_t v759 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v23), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v758));
              int8x8_t v760 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v759, v759, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
              unsigned int v761 = *v23
                   - (v760.i32[0] | (((*v23 & 0x3FF) * v758 + (((*v23 & 0x3FF) * v758) >> 8) + 1) >> 8) | v760.i32[1])
                   + 0x40000000;
              int8x8_t v762 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v761), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003)), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              int8x8_t v763 = (int8x8_t)vdup_lane_s32((int32x2_t)v762, 1);
              if ((v761 & 0x3FF) + (*v14 & 0x3FF) >= 0x3FF) {
                int v764 = 1023;
              }
              else {
                int v764 = (v761 & 0x3FF) + (*v14 & 0x3FF);
              }
              *int32x2_t v14 = vorr_s8(v762, v763).u32[0] | v764 | 0xC0000000;
            }
            v16 += v376;
            v765 = &v23[v376];
            if ((unint64_t)v765 >= v12) {
              uint64_t v766 = v755;
            }
            else {
              uint64_t v766 = 0;
            }
            uint64_t v23 = &v765[v766];
            v14 += v376;
            --v756;
          }
          while (v756);
          v16 += v839;
          CGColorSpaceRef result = v837;
          v14 += v838;
          unint64_t v767 = v844;
          unint64_t v768 = v844 + 4 * v842;
          if (v768 >= v837) {
            uint64_t v769 = v754;
          }
          else {
            uint64_t v769 = 0;
          }
          v770 = (unsigned int *)(v768 + 4 * v769);
          uint64_t v771 = v12 + 4 * v769 + 4 * v842;
          if (v837)
          {
            unint64_t v12 = v771;
            unint64_t v767 = (unint64_t)v770;
            uint64_t v23 = v770;
          }
          else
          {
            v23 += v842;
          }
          unint64_t v844 = v767;
          --v845;
        }
        while (v757 != 1);
      }
      return result;
    case 13:
      uint64_t v404 = v27;
      uint64_t v405 = v8;
      uint64_t v406 = v20;
      uint64_t v407 = v843;
      uint64_t v806 = -(uint64_t)(v842 * v22);
      uint64_t v821 = v8;
      uint64_t v791 = -(v840 * v22);
      uint64_t v408 = 4 * v27;
      uint64_t v409 = -(uint64_t)v21;
      do
      {
        int v410 = v841;
        unint64_t v847 = v12;
        do
        {
          int v411 = *v16;
          if (*v16)
          {
            int v412 = v20 ? *v407 : 255;
            unsigned int v413 = v412 * v411 + ((v412 * v411) >> 8) + 1;
            if (BYTE1(v413))
            {
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAmultiplyPDA(*v14, *v7, (((*v23 & 0x3FF) * v411 + (((*v23 & 0x3FF) * v411) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v411 + ((((*v23 >> 10) & 0x3FF) * v411) >> 8))+ 4) & 0xFC00, BYTE1(v413));
                  uint64_t v405 = v821;
                  int v8 = v846;
                  unint64_t v12 = v847;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v413 >> 8) | ((unint64_t)((((((*v23 >> 20) & 0x3FF) * v411
                                                              + ((((*v23 >> 20) & 0x3FF) * v411) >> 8)) << 12)
                                                            + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v411
                                                                                   + (((*v23 & 0x3FF) * v411) >> 8)
                                                                                   + 1) >> 8) | (4
                                                                                               * (((*v23 >> 10) & 0x3FF)
                                                                                                * v411
                                                                                                + ((((*v23 >> 10) & 0x3FF)
                                                                                                  * v411) >> 8))
                                                                                               + 4) & 0xFFC00 | 0xC0000000) << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAmultiplyPDA(*v14, 255, (((*v23 & 0x3FF) * v411 + (((*v23 & 0x3FF) * v411) >> 8) + 1) >> 8) | (4* (((*v23 >> 10) & 0x3FF)* v411+ ((((*v23 >> 10) & 0x3FF) * v411) >> 8))+ 4) & 0xFC00, BYTE1(v413));
                uint64_t v405 = v821;
                int v8 = v846;
                unint64_t v12 = v847;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v404;
          v7 += v405;
          unint64_t v414 = &v23[v404];
          if ((unint64_t)v414 >= v12) {
            uint64_t v415 = v409;
          }
          else {
            uint64_t v415 = 0;
          }
          v407 += v406 + v415;
          uint64_t v23 = &v414[v415];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v408);
          --v410;
        }
        while (v410);
        if (v837)
        {
          unint64_t v416 = v844 + 4 * v842;
          uint64_t v417 = v791;
          if (v416 < v837) {
            uint64_t v417 = 0;
          }
          uint64_t v407 = &v843[v840 + v417];
          uint64_t v418 = v806;
          if (v416 < v837) {
            uint64_t v418 = 0;
          }
          uint64_t v23 = (unsigned int *)(v416 + 4 * v418);
          v12 += 4 * v418 + 4 * v842;
          v843 += v840 + v417;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v407 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 14:
      uint64_t v419 = v27;
      uint64_t v420 = v8;
      uint64_t v421 = v20;
      uint64_t v422 = v843;
      uint64_t v807 = -(uint64_t)(v842 * v22);
      uint64_t v822 = v8;
      uint64_t v792 = -(v840 * v22);
      uint64_t v423 = 4 * v27;
      uint64_t v424 = -(uint64_t)v21;
      do
      {
        int v425 = v841;
        unint64_t v848 = v12;
        do
        {
          int v426 = *v16;
          if (*v16)
          {
            int v427 = v20 ? *v422 : 255;
            unsigned int v428 = v427 * v426 + ((v427 * v426) >> 8) + 1;
            if (BYTE1(v428))
            {
              uint64_t v429 = (((((*v23 >> 20) & 0x3FF) * v426 + ((((*v23 >> 20) & 0x3FF) * v426) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v426 + (((*v23 & 0x3FF) * v426) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v426 + ((((*v23 >> 10) & 0x3FF) * v426) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAscreenPDA(*v14, *v7, v429, BYTE1(v428));
                  uint64_t v420 = v822;
                  int v8 = v846;
                  unint64_t v12 = v848;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v428 >> 8) | (unint64_t)(v429 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAscreenPDA(*v14, 255, v429, BYTE1(v428));
                uint64_t v420 = v822;
                int v8 = v846;
                unint64_t v12 = v848;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v419;
          v7 += v420;
          v430 = &v23[v419];
          if ((unint64_t)v430 >= v12) {
            uint64_t v431 = v424;
          }
          else {
            uint64_t v431 = 0;
          }
          v422 += v421 + v431;
          uint64_t v23 = &v430[v431];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v423);
          --v425;
        }
        while (v425);
        if (v837)
        {
          unint64_t v432 = v844 + 4 * v842;
          uint64_t v433 = v792;
          if (v432 < v837) {
            uint64_t v433 = 0;
          }
          uint64_t v422 = &v843[v840 + v433];
          uint64_t v434 = v807;
          if (v432 < v837) {
            uint64_t v434 = 0;
          }
          uint64_t v23 = (unsigned int *)(v432 + 4 * v434);
          v12 += 4 * v434 + 4 * v842;
          v843 += v840 + v433;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v422 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 15:
      uint64_t v435 = v27;
      uint64_t v436 = v8;
      uint64_t v437 = v20;
      uint32x2_t v438 = v843;
      uint64_t v808 = -(uint64_t)(v842 * v22);
      uint64_t v823 = v8;
      uint64_t v793 = -(v840 * v22);
      uint64_t v439 = 4 * v27;
      uint64_t v440 = -(uint64_t)v21;
      do
      {
        int v441 = v841;
        unint64_t v849 = v12;
        do
        {
          int v442 = *v16;
          if (*v16)
          {
            int v443 = v20 ? *v438 : 255;
            unsigned int v444 = v443 * v442 + ((v443 * v442) >> 8) + 1;
            if (BYTE1(v444))
            {
              uint64_t v445 = (((((*v23 >> 20) & 0x3FF) * v442 + ((((*v23 >> 20) & 0x3FF) * v442) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v442 + (((*v23 & 0x3FF) * v442) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v442 + ((((*v23 >> 10) & 0x3FF) * v442) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAoverlayPDA(*v14, *v7, v445, BYTE1(v444));
                  uint64_t v436 = v823;
                  int v8 = v846;
                  unint64_t v12 = v849;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v444 >> 8) | (unint64_t)(v445 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAoverlayPDA(*v14, 255, v445, BYTE1(v444));
                uint64_t v436 = v823;
                int v8 = v846;
                unint64_t v12 = v849;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v435;
          v7 += v436;
          unsigned int v446 = &v23[v435];
          if ((unint64_t)v446 >= v12) {
            uint64_t v447 = v440;
          }
          else {
            uint64_t v447 = 0;
          }
          v438 += v437 + v447;
          uint64_t v23 = &v446[v447];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v439);
          --v441;
        }
        while (v441);
        if (v837)
        {
          unint64_t v448 = v844 + 4 * v842;
          uint64_t v449 = v793;
          if (v448 < v837) {
            uint64_t v449 = 0;
          }
          uint32x2_t v438 = &v843[v840 + v449];
          uint64_t v450 = v808;
          if (v448 < v837) {
            uint64_t v450 = 0;
          }
          uint64_t v23 = (unsigned int *)(v448 + 4 * v450);
          v12 += 4 * v450 + 4 * v842;
          v843 += v840 + v449;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v438 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 16:
      uint64_t v451 = v27;
      uint64_t v452 = v8;
      uint64_t v453 = v20;
      uint64_t v454 = v843;
      uint64_t v809 = -(uint64_t)(v842 * v22);
      uint64_t v824 = v8;
      uint64_t v794 = -(v840 * v22);
      uint64_t v455 = 4 * v27;
      uint64_t v456 = -(uint64_t)v21;
      do
      {
        int v457 = v841;
        unint64_t v850 = v12;
        do
        {
          int v458 = *v16;
          if (*v16)
          {
            int v459 = v20 ? *v454 : 255;
            unsigned int v460 = v459 * v458 + ((v459 * v458) >> 8) + 1;
            if (BYTE1(v460))
            {
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAdarkenPDA(*v14, *v7, (((*v23 & 0x3FF) * v458 + (((*v23 & 0x3FF) * v458) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v458 + ((((*v23 >> 10) & 0x3FF) * v458) >> 8))+ 4) & 0xFC00, BYTE1(v460));
                  uint64_t v452 = v824;
                  int v8 = v846;
                  unint64_t v12 = v850;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v460 >> 8) | ((unint64_t)((((((*v23 >> 20) & 0x3FF) * v458
                                                              + ((((*v23 >> 20) & 0x3FF) * v458) >> 8)) << 12)
                                                            + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v458
                                                                                   + (((*v23 & 0x3FF) * v458) >> 8)
                                                                                   + 1) >> 8) | (4
                                                                                               * (((*v23 >> 10) & 0x3FF)
                                                                                                * v458
                                                                                                + ((((*v23 >> 10) & 0x3FF)
                                                                                                  * v458) >> 8))
                                                                                               + 4) & 0xFFC00 | 0xC0000000) << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAdarkenPDA(*v14, 0xFFu, (((*v23 & 0x3FF) * v458 + (((*v23 & 0x3FF) * v458) >> 8) + 1) >> 8) | (4* (((*v23 >> 10) & 0x3FF)* v458+ ((((*v23 >> 10) & 0x3FF) * v458) >> 8))+ 4) & 0xFC00, BYTE1(v460));
                uint64_t v452 = v824;
                int v8 = v846;
                unint64_t v12 = v850;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v451;
          v7 += v452;
          v461 = &v23[v451];
          if ((unint64_t)v461 >= v12) {
            uint64_t v462 = v456;
          }
          else {
            uint64_t v462 = 0;
          }
          v454 += v453 + v462;
          uint64_t v23 = &v461[v462];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v455);
          --v457;
        }
        while (v457);
        if (v837)
        {
          unint64_t v463 = v844 + 4 * v842;
          uint64_t v464 = v794;
          if (v463 < v837) {
            uint64_t v464 = 0;
          }
          uint64_t v454 = &v843[v840 + v464];
          uint64_t v465 = v809;
          if (v463 < v837) {
            uint64_t v465 = 0;
          }
          uint64_t v23 = (unsigned int *)(v463 + 4 * v465);
          v12 += 4 * v465 + 4 * v842;
          v843 += v840 + v464;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v454 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 17:
      uint64_t v466 = v27;
      uint64_t v467 = v8;
      uint64_t v468 = v20;
      v469 = v843;
      uint64_t v810 = -(uint64_t)(v842 * v22);
      uint64_t v825 = v8;
      uint64_t v795 = -(v840 * v22);
      uint64_t v470 = 4 * v27;
      uint64_t v471 = -(uint64_t)v21;
      do
      {
        int v472 = v841;
        unint64_t v851 = v12;
        do
        {
          int v473 = *v16;
          if (*v16)
          {
            int v474 = v20 ? *v469 : 255;
            unsigned int v475 = v474 * v473 + ((v474 * v473) >> 8) + 1;
            if (BYTE1(v475))
            {
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAlightenPDA(*v14, *v7, (((*v23 & 0x3FF) * v473 + (((*v23 & 0x3FF) * v473) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v473 + ((((*v23 >> 10) & 0x3FF) * v473) >> 8))+ 4) & 0xFC00, BYTE1(v475));
                  uint64_t v467 = v825;
                  int v8 = v846;
                  unint64_t v12 = v851;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v475 >> 8) | ((unint64_t)((((((*v23 >> 20) & 0x3FF) * v473
                                                              + ((((*v23 >> 20) & 0x3FF) * v473) >> 8)) << 12)
                                                            + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v473
                                                                                   + (((*v23 & 0x3FF) * v473) >> 8)
                                                                                   + 1) >> 8) | (4
                                                                                               * (((*v23 >> 10) & 0x3FF)
                                                                                                * v473
                                                                                                + ((((*v23 >> 10) & 0x3FF)
                                                                                                  * v473) >> 8))
                                                                                               + 4) & 0xFFC00 | 0xC0000000) << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAlightenPDA(*v14, 0xFFu, (((*v23 & 0x3FF) * v473 + (((*v23 & 0x3FF) * v473) >> 8) + 1) >> 8) | (4* (((*v23 >> 10) & 0x3FF)* v473+ ((((*v23 >> 10) & 0x3FF) * v473) >> 8))+ 4) & 0xFC00, BYTE1(v475));
                uint64_t v467 = v825;
                int v8 = v846;
                unint64_t v12 = v851;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v466;
          v7 += v467;
          unsigned int v476 = &v23[v466];
          if ((unint64_t)v476 >= v12) {
            uint64_t v477 = v471;
          }
          else {
            uint64_t v477 = 0;
          }
          v469 += v468 + v477;
          uint64_t v23 = &v476[v477];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v470);
          --v472;
        }
        while (v472);
        if (v837)
        {
          unint64_t v478 = v844 + 4 * v842;
          uint64_t v479 = v795;
          if (v478 < v837) {
            uint64_t v479 = 0;
          }
          v469 = &v843[v840 + v479];
          uint64_t v480 = v810;
          if (v478 < v837) {
            uint64_t v480 = 0;
          }
          uint64_t v23 = (unsigned int *)(v478 + 4 * v480);
          v12 += 4 * v480 + 4 * v842;
          v843 += v840 + v479;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v469 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 18:
      uint64_t v481 = v27;
      uint64_t v482 = v8;
      uint64_t v483 = v20;
      int v484 = v843;
      uint64_t v811 = -(uint64_t)(v842 * v22);
      uint64_t v826 = v8;
      uint64_t v796 = -(v840 * v22);
      uint64_t v485 = 4 * v27;
      uint64_t v486 = -(uint64_t)v21;
      do
      {
        int v487 = v841;
        unint64_t v852 = v12;
        do
        {
          int v488 = *v16;
          if (*v16)
          {
            int v489 = v20 ? *v484 : 255;
            unsigned int v490 = v489 * v488 + ((v489 * v488) >> 8) + 1;
            if (BYTE1(v490))
            {
              uint64_t v491 = (((((*v23 >> 20) & 0x3FF) * v488 + ((((*v23 >> 20) & 0x3FF) * v488) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v488 + (((*v23 & 0x3FF) * v488) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v488 + ((((*v23 >> 10) & 0x3FF) * v488) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAcolordodgePDA(*v14, *v7, v491, BYTE1(v490));
                  uint64_t v482 = v826;
                  int v8 = v846;
                  unint64_t v12 = v852;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v490 >> 8) | (unint64_t)(v491 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAcolordodgePDA(*v14, 255, v491, BYTE1(v490));
                uint64_t v482 = v826;
                int v8 = v846;
                unint64_t v12 = v852;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v481;
          v7 += v482;
          uint8x8_t v492 = &v23[v481];
          if ((unint64_t)v492 >= v12) {
            uint64_t v493 = v486;
          }
          else {
            uint64_t v493 = 0;
          }
          v484 += v483 + v493;
          uint64_t v23 = &v492[v493];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v485);
          --v487;
        }
        while (v487);
        if (v837)
        {
          unint64_t v494 = v844 + 4 * v842;
          uint64_t v495 = v796;
          if (v494 < v837) {
            uint64_t v495 = 0;
          }
          int v484 = &v843[v840 + v495];
          uint64_t v496 = v811;
          if (v494 < v837) {
            uint64_t v496 = 0;
          }
          uint64_t v23 = (unsigned int *)(v494 + 4 * v496);
          v12 += 4 * v496 + 4 * v842;
          v843 += v840 + v495;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v484 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 19:
      uint64_t v497 = v27;
      uint64_t v498 = v8;
      uint64_t v499 = v20;
      v500 = v843;
      uint64_t v812 = -(uint64_t)(v842 * v22);
      uint64_t v827 = v8;
      uint64_t v797 = -(v840 * v22);
      uint64_t v501 = 4 * v27;
      uint64_t v502 = -(uint64_t)v21;
      do
      {
        int v503 = v841;
        unint64_t v853 = v12;
        do
        {
          int v504 = *v16;
          if (*v16)
          {
            int v505 = v20 ? *v500 : 255;
            unsigned int v506 = v505 * v504 + ((v505 * v504) >> 8) + 1;
            if (BYTE1(v506))
            {
              uint64_t v507 = (((((*v23 >> 20) & 0x3FF) * v504 + ((((*v23 >> 20) & 0x3FF) * v504) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v504 + (((*v23 & 0x3FF) * v504) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v504 + ((((*v23 >> 10) & 0x3FF) * v504) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAcolorburnPDA(*v14, *v7, v507, BYTE1(v506));
                  uint64_t v498 = v827;
                  int v8 = v846;
                  unint64_t v12 = v853;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v506 >> 8) | (unint64_t)(v507 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAcolorburnPDA(*v14, 255, v507, BYTE1(v506));
                uint64_t v498 = v827;
                int v8 = v846;
                unint64_t v12 = v853;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v497;
          v7 += v498;
          uint64_t v508 = &v23[v497];
          if ((unint64_t)v508 >= v12) {
            uint64_t v509 = v502;
          }
          else {
            uint64_t v509 = 0;
          }
          v500 += v499 + v509;
          uint64_t v23 = &v508[v509];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v501);
          --v503;
        }
        while (v503);
        if (v837)
        {
          unint64_t v510 = v844 + 4 * v842;
          uint64_t v511 = v797;
          if (v510 < v837) {
            uint64_t v511 = 0;
          }
          v500 = &v843[v840 + v511];
          uint64_t v512 = v812;
          if (v510 < v837) {
            uint64_t v512 = 0;
          }
          uint64_t v23 = (unsigned int *)(v510 + 4 * v512);
          v12 += 4 * v512 + 4 * v842;
          v843 += v840 + v511;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v500 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 20:
      uint64_t v513 = v27;
      uint64_t v514 = v8;
      uint64_t v515 = v20;
      int v516 = v843;
      uint64_t v813 = -(uint64_t)(v842 * v22);
      uint64_t v828 = v8;
      uint64_t v798 = -(v840 * v22);
      uint64_t v517 = 4 * v27;
      uint64_t v518 = -(uint64_t)v21;
      do
      {
        int v519 = v841;
        unint64_t v854 = v12;
        do
        {
          int v520 = *v16;
          if (*v16)
          {
            int v521 = v20 ? *v516 : 255;
            unsigned int v522 = v521 * v520 + ((v521 * v520) >> 8) + 1;
            if (BYTE1(v522))
            {
              uint64_t v523 = (((((*v23 >> 20) & 0x3FF) * v520 + ((((*v23 >> 20) & 0x3FF) * v520) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v520 + (((*v23 & 0x3FF) * v520) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v520 + ((((*v23 >> 10) & 0x3FF) * v520) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAsoftlightPDA(*v14, *v7, v523, BYTE1(v522));
                  uint64_t v514 = v828;
                  int v8 = v846;
                  unint64_t v12 = v854;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v522 >> 8) | (unint64_t)(v523 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAsoftlightPDA(*v14, 255, v523, BYTE1(v522));
                uint64_t v514 = v828;
                int v8 = v846;
                unint64_t v12 = v854;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v513;
          v7 += v514;
          v524 = &v23[v513];
          if ((unint64_t)v524 >= v12) {
            uint64_t v525 = v518;
          }
          else {
            uint64_t v525 = 0;
          }
          v516 += v515 + v525;
          uint64_t v23 = &v524[v525];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v517);
          --v519;
        }
        while (v519);
        if (v837)
        {
          unint64_t v526 = v844 + 4 * v842;
          uint64_t v527 = v798;
          if (v526 < v837) {
            uint64_t v527 = 0;
          }
          int v516 = &v843[v840 + v527];
          uint64_t v528 = v813;
          if (v526 < v837) {
            uint64_t v528 = 0;
          }
          uint64_t v23 = (unsigned int *)(v526 + 4 * v528);
          v12 += 4 * v528 + 4 * v842;
          v843 += v840 + v527;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v516 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 21:
      uint64_t v529 = v27;
      uint64_t v530 = v8;
      uint64_t v531 = v20;
      v532 = v843;
      uint64_t v814 = -(uint64_t)(v842 * v22);
      uint64_t v829 = v8;
      uint64_t v799 = -(v840 * v22);
      uint64_t v533 = 4 * v27;
      uint64_t v534 = -(uint64_t)v21;
      do
      {
        int v535 = v841;
        unint64_t v855 = v12;
        do
        {
          int v536 = *v16;
          if (*v16)
          {
            int v537 = v20 ? *v532 : 255;
            unsigned int v538 = v537 * v536 + ((v537 * v536) >> 8) + 1;
            if (BYTE1(v538))
            {
              uint64_t v539 = (((((*v23 >> 20) & 0x3FF) * v536 + ((((*v23 >> 20) & 0x3FF) * v536) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v536 + (((*v23 & 0x3FF) * v536) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v536 + ((((*v23 >> 10) & 0x3FF) * v536) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAhardlightPDA(*v14, *v7, v539, BYTE1(v538));
                  uint64_t v530 = v829;
                  int v8 = v846;
                  unint64_t v12 = v855;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v538 >> 8) | (unint64_t)(v539 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAhardlightPDA(*v14, 255, v539, BYTE1(v538));
                uint64_t v530 = v829;
                int v8 = v846;
                unint64_t v12 = v855;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v529;
          v7 += v530;
          uint64_t v540 = &v23[v529];
          if ((unint64_t)v540 >= v12) {
            uint64_t v541 = v534;
          }
          else {
            uint64_t v541 = 0;
          }
          v532 += v531 + v541;
          uint64_t v23 = &v540[v541];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v533);
          --v535;
        }
        while (v535);
        if (v837)
        {
          unint64_t v542 = v844 + 4 * v842;
          uint64_t v543 = v799;
          if (v542 < v837) {
            uint64_t v543 = 0;
          }
          v532 = &v843[v840 + v543];
          uint64_t v544 = v814;
          if (v542 < v837) {
            uint64_t v544 = 0;
          }
          uint64_t v23 = (unsigned int *)(v542 + 4 * v544);
          v12 += 4 * v544 + 4 * v842;
          v843 += v840 + v543;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v532 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 22:
      uint64_t v545 = v27;
      uint64_t v546 = v8;
      uint64_t v547 = v20;
      int32x2_t v548 = v843;
      uint64_t v815 = -(uint64_t)(v842 * v22);
      uint64_t v830 = v8;
      uint64_t v800 = -(v840 * v22);
      uint64_t v549 = 4 * v27;
      uint64_t v550 = -(uint64_t)v21;
      do
      {
        int v551 = v841;
        unint64_t v856 = v12;
        do
        {
          int v552 = *v16;
          if (*v16)
          {
            int v553 = v20 ? *v548 : 255;
            unsigned int v554 = v553 * v552 + ((v553 * v552) >> 8) + 1;
            if (BYTE1(v554))
            {
              uint64_t v555 = (((((*v23 >> 20) & 0x3FF) * v552 + ((((*v23 >> 20) & 0x3FF) * v552) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v552 + (((*v23 & 0x3FF) * v552) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v552 + ((((*v23 >> 10) & 0x3FF) * v552) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAdifferencePDA(*v14, *v7, v555, BYTE1(v554));
                  uint64_t v546 = v830;
                  int v8 = v846;
                  unint64_t v12 = v856;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v554 >> 8) | (unint64_t)(v555 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAdifferencePDA(*v14, 0xFFu, v555, BYTE1(v554));
                uint64_t v546 = v830;
                int v8 = v846;
                unint64_t v12 = v856;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v545;
          v7 += v546;
          int64x2_t v556 = &v23[v545];
          if ((unint64_t)v556 >= v12) {
            uint64_t v557 = v550;
          }
          else {
            uint64_t v557 = 0;
          }
          v548 += v547 + v557;
          uint64_t v23 = &v556[v557];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v549);
          --v551;
        }
        while (v551);
        if (v837)
        {
          unint64_t v558 = v844 + 4 * v842;
          uint64_t v559 = v800;
          if (v558 < v837) {
            uint64_t v559 = 0;
          }
          int32x2_t v548 = &v843[v840 + v559];
          uint64_t v560 = v815;
          if (v558 < v837) {
            uint64_t v560 = 0;
          }
          uint64_t v23 = (unsigned int *)(v558 + 4 * v560);
          v12 += 4 * v560 + 4 * v842;
          v843 += v840 + v559;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v548 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 23:
      uint64_t v561 = v27;
      uint64_t v562 = v8;
      uint64_t v563 = v20;
      int32x2_t v564 = v843;
      uint64_t v816 = -(uint64_t)(v842 * v22);
      uint64_t v831 = v8;
      uint64_t v801 = -(v840 * v22);
      uint64_t v565 = 4 * v27;
      uint64_t v566 = -(uint64_t)v21;
      do
      {
        int v567 = v841;
        unint64_t v857 = v12;
        do
        {
          int v568 = *v16;
          if (*v16)
          {
            int v569 = v20 ? *v564 : 255;
            unsigned int v570 = v569 * v568 + ((v569 * v568) >> 8) + 1;
            if (BYTE1(v570))
            {
              uint64_t v571 = (((((*v23 >> 20) & 0x3FF) * v568 + ((((*v23 >> 20) & 0x3FF) * v568) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v568 + (((*v23 & 0x3FF) * v568) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v568 + ((((*v23 >> 10) & 0x3FF) * v568) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAexclusionPDA(*v14, *v7, v571, BYTE1(v570));
                  uint64_t v562 = v831;
                  int v8 = v846;
                  unint64_t v12 = v857;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v570 >> 8) | (unint64_t)(v571 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAexclusionPDA(*v14, 255, v571, BYTE1(v570));
                uint64_t v562 = v831;
                int v8 = v846;
                unint64_t v12 = v857;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v561;
          v7 += v562;
          unsigned int v572 = &v23[v561];
          if ((unint64_t)v572 >= v12) {
            uint64_t v573 = v566;
          }
          else {
            uint64_t v573 = 0;
          }
          v564 += v563 + v573;
          uint64_t v23 = &v572[v573];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v565);
          --v567;
        }
        while (v567);
        if (v837)
        {
          unint64_t v574 = v844 + 4 * v842;
          uint64_t v575 = v801;
          if (v574 < v837) {
            uint64_t v575 = 0;
          }
          int32x2_t v564 = &v843[v840 + v575];
          uint64_t v576 = v816;
          if (v574 < v837) {
            uint64_t v576 = 0;
          }
          uint64_t v23 = (unsigned int *)(v574 + 4 * v576);
          v12 += 4 * v576 + 4 * v842;
          v843 += v840 + v575;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v564 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 24:
      uint64_t v577 = v27;
      uint64_t v578 = v8;
      uint64_t v579 = v20;
      unsigned int v580 = v843;
      uint64_t v817 = -(uint64_t)(v842 * v22);
      uint64_t v832 = v8;
      uint64_t v802 = -(v840 * v22);
      uint64_t v581 = 4 * v27;
      uint64_t v582 = -(uint64_t)v21;
      do
      {
        int v583 = v841;
        unint64_t v858 = v12;
        do
        {
          int v584 = *v16;
          if (*v16)
          {
            int v585 = v20 ? *v580 : 255;
            unsigned int v586 = v585 * v584 + ((v585 * v584) >> 8) + 1;
            if (BYTE1(v586))
            {
              uint64_t v587 = (((((*v23 >> 20) & 0x3FF) * v584 + ((((*v23 >> 20) & 0x3FF) * v584) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v584 + (((*v23 & 0x3FF) * v584) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v584 + ((((*v23 >> 10) & 0x3FF) * v584) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAhuePDA(*v14, *v7, v587, BYTE1(v586));
                  uint64_t v578 = v832;
                  int v8 = v846;
                  unint64_t v12 = v858;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v586 >> 8) | (unint64_t)(v587 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAhuePDA(*v14, 255, v587, BYTE1(v586));
                uint64_t v578 = v832;
                int v8 = v846;
                unint64_t v12 = v858;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v577;
          v7 += v578;
          int v588 = &v23[v577];
          if ((unint64_t)v588 >= v12) {
            uint64_t v589 = v582;
          }
          else {
            uint64_t v589 = 0;
          }
          v580 += v579 + v589;
          uint64_t v23 = &v588[v589];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v581);
          --v583;
        }
        while (v583);
        if (v837)
        {
          unint64_t v590 = v844 + 4 * v842;
          uint64_t v591 = v802;
          if (v590 < v837) {
            uint64_t v591 = 0;
          }
          unsigned int v580 = &v843[v840 + v591];
          uint64_t v592 = v817;
          if (v590 < v837) {
            uint64_t v592 = 0;
          }
          uint64_t v23 = (unsigned int *)(v590 + 4 * v592);
          v12 += 4 * v592 + 4 * v842;
          v843 += v840 + v591;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v580 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 25:
      uint64_t v593 = v27;
      uint64_t v594 = v8;
      uint64_t v595 = v20;
      unint64_t v596 = v843;
      uint64_t v818 = -(uint64_t)(v842 * v22);
      uint64_t v833 = v8;
      uint64_t v803 = -(v840 * v22);
      uint64_t v597 = 4 * v27;
      uint64_t v598 = -(uint64_t)v21;
      do
      {
        int v599 = v841;
        unint64_t v859 = v12;
        do
        {
          int v600 = *v16;
          if (*v16)
          {
            int v601 = v20 ? *v596 : 255;
            unsigned int v602 = v601 * v600 + ((v601 * v600) >> 8) + 1;
            if (BYTE1(v602))
            {
              uint64_t v603 = (((((*v23 >> 20) & 0x3FF) * v600 + ((((*v23 >> 20) & 0x3FF) * v600) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v600 + (((*v23 & 0x3FF) * v600) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v600 + ((((*v23 >> 10) & 0x3FF) * v600) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAsaturationPDA(*v14, *v7, v603, BYTE1(v602));
                  uint64_t v594 = v833;
                  int v8 = v846;
                  unint64_t v12 = v859;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v602 >> 8) | (unint64_t)(v603 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAsaturationPDA(*v14, 255, v603, BYTE1(v602));
                uint64_t v594 = v833;
                int v8 = v846;
                unint64_t v12 = v859;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v593;
          v7 += v594;
          int32x2_t v604 = &v23[v593];
          if ((unint64_t)v604 >= v12) {
            uint64_t v605 = v598;
          }
          else {
            uint64_t v605 = 0;
          }
          v596 += v595 + v605;
          uint64_t v23 = &v604[v605];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v597);
          --v599;
        }
        while (v599);
        if (v837)
        {
          unint64_t v606 = v844 + 4 * v842;
          uint64_t v607 = v803;
          if (v606 < v837) {
            uint64_t v607 = 0;
          }
          unint64_t v596 = &v843[v840 + v607];
          uint64_t v608 = v818;
          if (v606 < v837) {
            uint64_t v608 = 0;
          }
          uint64_t v23 = (unsigned int *)(v606 + 4 * v608);
          v12 += 4 * v608 + 4 * v842;
          v843 += v840 + v607;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v596 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 26:
      uint64_t v609 = v27;
      uint64_t v610 = v8;
      uint64_t v611 = v20;
      int v612 = v843;
      uint64_t v819 = -(uint64_t)(v842 * v22);
      uint64_t v834 = v8;
      uint64_t v804 = -(v840 * v22);
      uint64_t v613 = 4 * v27;
      uint64_t v614 = -(uint64_t)v21;
      do
      {
        int v615 = v841;
        unint64_t v860 = v12;
        do
        {
          int v616 = *v16;
          if (*v16)
          {
            int v617 = v20 ? *v612 : 255;
            unsigned int v618 = v617 * v616 + ((v617 * v616) >> 8) + 1;
            if (BYTE1(v618))
            {
              uint64_t v619 = (((((*v23 >> 20) & 0x3FF) * v616 + ((((*v23 >> 20) & 0x3FF) * v616) >> 8)) << 12) + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v616 + (((*v23 & 0x3FF) * v616) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v616 + ((((*v23 >> 10) & 0x3FF) * v616) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAluminosityPDA(v619, BYTE1(v618), *v14, *v7);
                  uint64_t v610 = v834;
                  int v8 = v846;
                  unint64_t v12 = v860;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v618 >> 8) | (unint64_t)(v619 << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAluminosityPDA(v619, BYTE1(v618), *v14, 0xFFu);
                uint64_t v610 = v834;
                int v8 = v846;
                unint64_t v12 = v860;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v609;
          v7 += v610;
          int32x2_t v620 = &v23[v609];
          if ((unint64_t)v620 >= v12) {
            uint64_t v621 = v614;
          }
          else {
            uint64_t v621 = 0;
          }
          v612 += v611 + v621;
          uint64_t v23 = &v620[v621];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v613);
          --v615;
        }
        while (v615);
        if (v837)
        {
          unint64_t v622 = v844 + 4 * v842;
          uint64_t v623 = v804;
          if (v622 < v837) {
            uint64_t v623 = 0;
          }
          int v612 = &v843[v840 + v623];
          uint64_t v624 = v819;
          if (v622 < v837) {
            uint64_t v624 = 0;
          }
          uint64_t v23 = (unsigned int *)(v622 + 4 * v624);
          v12 += 4 * v624 + 4 * v842;
          v843 += v840 + v623;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v612 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    case 27:
      uint64_t v625 = v27;
      uint64_t v626 = v8;
      uint64_t v627 = v20;
      int8x8_t v628 = v843;
      uint64_t v820 = -(uint64_t)(v842 * v22);
      uint64_t v835 = v8;
      uint64_t v805 = -(v840 * v22);
      uint64_t v629 = 4 * v27;
      uint64_t v630 = -(uint64_t)v21;
      do
      {
        int v631 = v841;
        unint64_t v861 = v12;
        do
        {
          int v632 = *v16;
          if (*v16)
          {
            int v633 = v20 ? *v628 : 255;
            unsigned int v634 = v633 * v632 + ((v633 * v632) >> 8) + 1;
            if (BYTE1(v634))
            {
              if (v8)
              {
                if (*v7)
                {
                  CGColorSpaceRef result = PDAluminosityPDA(*v14, *v7, (((*v23 & 0x3FF) * v632 + (((*v23 & 0x3FF) * v632) >> 8) + 1) >> 8) | (4 * (((*v23 >> 10) & 0x3FF) * v632 + ((((*v23 >> 10) & 0x3FF) * v632) >> 8))+ 4) & 0xFC00, BYTE1(v634));
                  uint64_t v626 = v835;
                  int v8 = v846;
                  unint64_t v12 = v861;
                  int v20 = v862;
                }
                else
                {
                  CGColorSpaceRef result = (v634 >> 8) | ((unint64_t)((((((*v23 >> 20) & 0x3FF) * v632
                                                              + ((((*v23 >> 20) & 0x3FF) * v632) >> 8)) << 12)
                                                            + 4096) & 0x3FF00000 | (((*v23 & 0x3FF) * v632
                                                                                   + (((*v23 & 0x3FF) * v632) >> 8)
                                                                                   + 1) >> 8) | (4
                                                                                               * (((*v23 >> 10) & 0x3FF)
                                                                                                * v632
                                                                                                + ((((*v23 >> 10) & 0x3FF)
                                                                                                  * v632) >> 8))
                                                                                               + 4) & 0xFFC00 | 0xC0000000) << 32);
                }
                *int32x2_t v14 = HIDWORD(result);
                *uint64_t v7 = result;
              }
              else
              {
                CGColorSpaceRef result = PDAluminosityPDA(*v14, 0xFFu, (((*v23 & 0x3FF) * v632 + (((*v23 & 0x3FF) * v632) >> 8) + 1) >> 8) | (4* (((*v23 >> 10) & 0x3FF)* v632+ ((((*v23 >> 10) & 0x3FF) * v632) >> 8))+ 4) & 0xFC00, BYTE1(v634));
                uint64_t v626 = v835;
                int v8 = v846;
                unint64_t v12 = v861;
                int v20 = v862;
                *int32x2_t v14 = HIDWORD(result);
              }
            }
          }
          v16 += v625;
          v7 += v626;
          int32x2_t v635 = &v23[v625];
          if ((unint64_t)v635 >= v12) {
            uint64_t v636 = v630;
          }
          else {
            uint64_t v636 = 0;
          }
          v628 += v627 + v636;
          uint64_t v23 = &v635[v636];
          int32x2_t v14 = (unsigned int *)((char *)v14 + v629);
          --v631;
        }
        while (v631);
        if (v837)
        {
          unint64_t v637 = v844 + 4 * v842;
          uint64_t v638 = v805;
          if (v637 < v837) {
            uint64_t v638 = 0;
          }
          int8x8_t v628 = &v843[v840 + v638];
          uint64_t v639 = v820;
          if (v637 < v837) {
            uint64_t v639 = 0;
          }
          uint64_t v23 = (unsigned int *)(v637 + 4 * v639);
          v12 += 4 * v639 + 4 * v842;
          v843 += v840 + v638;
          unint64_t v844 = (unint64_t)v23;
        }
        else
        {
          v23 += v842;
          v628 += v840;
        }
        v16 += v839;
        v14 += v838;
        v7 += v836;
        --v845;
      }
      while (v845);
      return result;
    default:
      return result;
  }
  do
  {
    int v673 = v9;
    int v674 = v845;
    do
    {
      int v675 = *v16;
      if (!*v16) {
        goto LABEL_802;
      }
      if (v675 == 255)
      {
        int v676 = *v672;
        if (!*v672) {
          goto LABEL_802;
        }
        if (v676 == 255)
        {
          unsigned int v677 = *v23;
        }
        else
        {
          unsigned int v685 = v676 ^ 0xFF;
          uint32x2_t v686 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v14), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v685));
          int8x8_t v687 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v686, v686, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
          unsigned int v677 = *v23
               - 0x40000000
               + (v687.i32[0] | (((*v14 & 0x3FF) * v685 + (((*v14 & 0x3FF) * v685) >> 8) + 1) >> 8) | v687.i32[1]);
        }
      }
      else
      {
        unsigned int v678 = *v672 * v675 + ((*v672 * v675) >> 8) + 1;
        if ((v678 & 0xFF00) == 0) {
          goto LABEL_802;
        }
        v679.i32[0] = *v23;
        v679.i32[1] = *v14;
        v680.i32[0] = *v16;
        v680.i32[1] = (v678 >> 8) ^ 0xFF;
        uint32x2_t v681 = (uint32x2_t)vmul_s32((int32x2_t)(*(void *)&vshr_n_u32(v679, 0x14uLL) & 0xFFFFF3FFFFFFF3FFLL), v680);
        uint32x2_t v682 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshr_n_u32(v679, 0xAuLL), (int8x8_t)0x300000003), v680);
        uint32x2_t v683 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)v679, (int8x8_t)0x300000003), v680);
        int8x8_t v684 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vadd_s32(vshl_n_s32((int32x2_t)vsra_n_u32(v681, v681, 8uLL), 0xCuLL), (int32x2_t)0x100000001000), _D16), (int8x8_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v683, v683, 8uLL), (int32x2_t)0x100000001), 8uLL)), vand_s8((int8x8_t)vadd_s32(vshl_n_s32((int32x2_t)vsra_n_u32(v682, v682, 8uLL), 2uLL), (int32x2_t)0x400000004), v671));
        unsigned int v677 = (v684.i32[1] + v684.i32[0]) | 0x80000000;
      }
      *int32x2_t v14 = v677;
LABEL_802:
      v16 += v65;
      unsigned int v688 = &v23[v65];
      uint32x2_t v689 = &v672[v20];
      if ((unint64_t)v688 >= v12) {
        CGColorSpaceRef result = v669;
      }
      else {
        CGColorSpaceRef result = 0;
      }
      int32x4_t v672 = &v689[result];
      uint64_t v23 = &v688[result];
      v14 += v65;
      --v673;
    }
    while (v673);
    if (v837)
    {
      CGColorSpaceRef result = v842;
      unint64_t v690 = v844 + 4 * v842;
      if (v690 >= v837) {
        uint64_t v691 = v668;
      }
      else {
        uint64_t v691 = 0;
      }
      unsigned int v692 = &v843[v840 + v691];
      if (v690 >= v837) {
        uint64_t v693 = v667;
      }
      else {
        uint64_t v693 = 0;
      }
      uint64_t v23 = (unsigned int *)(v690 + 4 * v693);
      v12 += 4 * v693 + 4 * v842;
      v843 += v840 + v691;
      unint64_t v844 = (unint64_t)v23;
      int32x4_t v672 = v692;
    }
    else
    {
      v23 += v842;
      v672 += v840;
    }
    v16 += v839;
    v14 += v838;
    --v845;
  }
  while (v674 != 1);
  return result;
}

uint64_t CIF10_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (int *)*a1;
  memset(v26, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v21, (uint64_t)v26) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  unsigned int v19 = *(_DWORD *)a3;
  int v22 = v19;
  int v23 = v18;
  if (v19 != 134886228)
  {
    int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      int v21 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&CIF10_image_sample[8 * v20 + 8];
      if (v21)
      {
        int v22 = 134886228;
        goto LABEL_19;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v25 && (~v24 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v24 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      CIF10_mark_inner(*(void *)(*a1 + 56), v17);
      return 1;
    }
  }
  int v21 = CIF10_sample_CIF10_inner;
LABEL_19:
  CIF10_image_mark((uint64_t)a2, (float32x2_t *)&v21, v8, v17);
  return 1;
}

void CIF10_image_mark(uint64_t a1, float32x2_t *a2, int a3, __n128 a4)
{
  uint64_t v605 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  uint64_t v589 = (int)v4;
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  unint64_t v9 = *(int *)(a1 + 28);
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v601 = *(void *)(a1 + 48);
  uint64_t v602 = v4;
  float v11 = a2[23].f32[0];
  int32x2_t v604 = *(int **)(a1 + 136);
  float32x2_t v597 = a2[12];
  float32x2_t v600 = a2[13];
  uint64_t v13 = *(int *)(a1 + 12);
  uint64_t v12 = *(int *)(a1 + 16);
  int v596 = *(_DWORD *)(a1 + 8);
  uint64_t v14 = a2[2].i32[0];
  uint64_t v15 = (v14 + 10) * v5;
  if (v15 > 65439)
  {
    int v18 = (char *)malloc_type_calloc(1uLL, v15 + 96, 0x48537F98uLL);
    __n128 v17 = v18;
    int v20 = v18;
    int v21 = v602;
    if (!v18) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    __n128 v17 = (char *)&v585 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v17, v16);
    int v20 = 0;
    int v21 = v602;
  }
  uint64_t v22 = v10;
  unsigned int v586 = v20;
  int v590 = a3;
  unint64_t v24 = (unint64_t)(v17 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v25 = v24 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  a2[20] = (float32x2_t)v25;
  if (v14) {
    uint64_t v26 = 8 * v5;
  }
  else {
    uint64_t v26 = 0;
  }
  unint64_t v27 = v25 + v26;
  float v23 = (float)(v11 * 255.0) + 0.5;
  unsigned int v28 = (int)v23;
  unint64_t v29 = v9 >> 2;
  a2[18] = (float32x2_t)v24;
  a2[19] = (float32x2_t)(v25 + v26);
  uint64_t v591 = a2;
  if (v601)
  {
    uint64_t v30 = *(int *)(a1 + 32);
    unint64_t v31 = (unsigned char *)(v601 + v13 + (int)v30 * (uint64_t)(int)v12);
    uint64_t v32 = v589;
    uint64_t v594 = v30 - v589;
    uint64_t v603 = 1;
  }
  else
  {
    unint64_t v31 = 0;
    uint64_t v594 = 0;
    uint64_t v603 = 0;
    uint64_t v32 = v589;
  }
  int v33 = (unsigned int *)(v22 + 4 * (v13 + v29 * v12));
  uint64_t v593 = v29 - v32;
  uint64_t v34 = *(int *)(a1 + 104);
  int v35 = *(_DWORD *)(a1 + 108);
  int v36 = *(unsigned __int8 *)(a1 + 2);
  uint64_t v595 = (int)v23;
  if (v36 == 6 || v36 == 1)
  {
    int v37 = v590;
    int8x8_t v38 = v591;
    float32x2_t v39 = v597;
    float32x2_t v40 = v600;
    if (v604)
    {
      unint64_t v585 = v29;
      uint64_t v41 = 0;
      int v42 = 0;
      uint64_t v43 = *(int *)(a1 + 124);
      uint64_t v44 = (int *)((char *)v604 + v34 + (int)v43 * (uint64_t)v35);
      uint64_t v32 = v589;
      uint64_t v592 = v43 - v589;
      goto LABEL_32;
    }
    goto LABEL_20;
  }
  unint64_t v585 = v29;
  if (v604)
  {
    shape_enum_clip_alloc((uint64_t)v18, v19, v604, 1, 1, 1, v34, v35, v21, v596);
    if (v45)
    {
      uint64_t v41 = v45;
      int v42 = 0;
      uint64_t v46 = (int)((v14 * v5 + 15) & 0xFFFFFFF0);
      if (!v14) {
        uint64_t v46 = 8 * v5;
      }
      uint64_t v47 = v589;
      uint64_t v592 = -v589;
      uint64_t v44 = (int *)(v27 + v46 + 16);
      int v37 = v590;
      float32x2_t v39 = v597;
      float32x2_t v40 = v600;
      goto LABEL_22;
    }
LABEL_20:
    unsigned int v48 = v586;
    goto LABEL_602;
  }
  uint64_t v44 = 0;
  uint64_t v41 = 0;
  uint64_t v592 = 0;
  int v42 = 0;
  int v37 = v590;
  int8x8_t v38 = v591;
  float32x2_t v39 = v597;
  float32x2_t v40 = v600;
LABEL_32:
  while (2)
  {
    uint64_t v588 = (v21 - 1) + 1;
    int32x2_t v56 = vdup_n_s32(v28);
    uint64_t v587 = -v32;
    float32x2_t v600 = (float32x2_t)vdup_n_s32(0x43FF8000u);
    float32x2_t v57 = (float32x2_t)vdup_n_s32(0x43C00000u);
    __asm { FMOV            V0.2D, #0.5 }
    float64x2_t v599 = _Q0;
    uint32x2_t v598 = (uint32x2_t)0xA00000014;
    unsigned int v63 = v41;
LABEL_33:
    int32x2_t v604 = v44;
    uint64_t v41 = v63;
    uint64_t v64 = (void (*)(float32x2_t *, void, void))*v38;
    float32x2_t v597 = v39;
    v64(v38, *(void *)&v39, *(void *)&v40);
    uint64_t v70 = (unsigned __int8 *)v38[20];
    int v71 = (unsigned char *)v38[18];
    unsigned int v72 = v38[1].u32[0];
    if (v72 == v38[1].i32[1])
    {
      int v73 = v595;
      if (v595 == 255)
      {
        int v74 = v602;
        uint64_t v75 = v603;
        uint64_t v44 = v604;
      }
      else
      {
        int v74 = v602;
        uint64_t v75 = v603;
        int v76 = v602;
        unsigned int v77 = (unsigned char *)v38[18];
        uint64_t v44 = v604;
        do
        {
          if (*v77)
          {
            uint32x2_t v78 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), v56);
            int8x8_t v79 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v78, v78, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
            *(void *)uint64_t v70 = ((*v70 * v73 + ((*v70 * v73) >> 8) + 1) >> 8) | ((unint64_t)(v79.i32[0] | (((*((_DWORD *)v70 + 1) & 0x3FF) * v73 + (((*((_DWORD *)v70 + 1) & 0x3FFu) * v73) >> 8) + 1) >> 8) | v79.i32[1] | 0xC0000000) << 32);
          }
          ++v77;
          v70 += 8;
          --v76;
        }
        while (v76);
        v70 += 8 * v587;
        v71 += v588 + v587;
      }
      goto LABEL_79;
    }
    int v80 = v42;
    int64x2_t v81 = v41;
    float32x2_t v82 = v40;
    float32x2_t v83 = v38[19];
    int v84 = HIWORD(v72) & 0x3F;
    unsigned int v85 = v595;
    if (v84 != 16)
    {
      int v74 = v602;
      uint64_t v75 = v603;
      uint64_t v44 = v604;
      if (v84 != 32) {
        _CGHandleAssert("CIF10_image_pixel", 11844, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/CIF10/blt_cif10.cc", "0", "unhandled bit depth (%u)", v65, v603, (uint64_t)v604, v84);
      }
      if (v595 == 255)
      {
        uint64_t v103 = 0;
        do
        {
          if (v71[v103]) {
            *(void *)&v70[8 * v103] = *(void *)(*(void *)&v83 + 8 * v103);
          }
          ++v103;
        }
        while (v74 != v103);
      }
      else
      {
        uint64_t v86 = 0;
        do
        {
          if (v71[v86])
          {
            unint64_t v87 = *(void *)(*(void *)&v83 + 8 * v86);
            LODWORD(v++*(_DWORD *)(result + 88) = (((v87 * (unint64_t)v85) >> 8) + v87 * v85 + 1) >> 8;
            if (v88 >= 0xFF) {
              uint64_t v88 = 255;
            }
            else {
              uint64_t v88 = v88;
            }
            *(void *)&v70[8 * v86] = v88 | (((((((WORD2(v87) & 0x3FF) * (unint64_t)v85) >> 8)
                                                             + (WORD2(v87) & 0x3FF) * (unint64_t)v85
                                                             + 1) >> 8) | HIDWORD(v87) & 0xC0000000 | (4 * (((((v87 >> 42) & 0x3FF) * v85) >> 8) + ((v87 >> 42) & 0x3FF) * v85) + 4) & 0x7FFFFC00 | (((((v87 >> 52) & 0x3FF) * v85 + ((((v87 >> 52) & 0x3FF) * v85) >> 8)) << 12) + 4096) & 0xFFF00000) << 32);
          }
          ++v86;
        }
        while (v74 != v86);
      }
LABEL_78:
      float32x2_t v40 = v82;
      uint64_t v41 = v81;
      int v42 = v80;
      goto LABEL_79;
    }
    int v74 = v602;
    uint64_t v75 = v603;
    uint64_t v44 = v604;
    if (v595 == 255)
    {
      uint64_t v104 = 0;
      uint64_t v105 = 0;
      do
      {
        if (v71[v104])
        {
          v66.i16[0] = *(_WORD *)(*(void *)&v83 + v105);
          v67.n128_u16[0] = *(_WORD *)(*(void *)&v83 + v105 + 2);
          v68.n128_u16[0] = *(_WORD *)(*(void *)&v83 + v105 + 4);
          v69.n128_u16[0] = *(_WORD *)(*(void *)&v83 + v105 + 6);
          RGBAf16((unint64_t *)&v70[v105], v66, v67, v68, v69);
          uint64_t v75 = v603;
          uint64_t v44 = v604;
          int v74 = v602;
        }
        v105 += 8;
        ++v104;
      }
      while (v74 != v104);
      int v37 = v590;
      int8x8_t v38 = v591;
      goto LABEL_78;
    }
    uint64_t v89 = 0;
    float v90 = v38[23].f32[0];
    int64x2_t v91 = (__int16 *)(*(void *)&v83 + 6);
    float32x2_t v40 = v82;
    uint64_t v41 = v81;
    int v42 = v80;
    do
    {
      if (v71[v89])
      {
        _H2 = *(v91 - 1);
        _H3 = *v91;
        __asm { FCVT            S3, H3 }
        float v95 = (float)(v90 * (float)(_S3 * 255.0)) + 0.5;
        float v96 = 0.0;
        if (v95 >= 0.0) {
          float v96 = v95;
        }
        if (v95 <= 255.0) {
          float v97 = v96;
        }
        else {
          float v97 = 255.0;
        }
        LODWORD(v98) = v97;
        v67.n128_u32[0] = *(_DWORD *)(v91 - 3);
        v67.n128_u64[0] = (unint64_t)vshl_u32(vmin_u32((uint32x2_t)vmovn_s64((int64x2_t)vcvtq_u64_f64(vaddq_f64(vcvtq_f64_f32(vmla_f32(v57, v600, vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16((float16x4_t)v67.n128_u64[0]), v90))), v599))), (uint32x2_t)0x300000003), v598);
        int8x8_t v99 = (int8x8_t)vdup_lane_s32((int32x2_t)v67.n128_u64[0], 1);
        if (v98 >= 0xFF) {
          uint64_t v98 = 255;
        }
        else {
          uint64_t v98 = v98;
        }
        unsigned __int32 v100 = vorr_s8(v99, (int8x8_t)v67.n128_u64[0]).u32[0];
        __asm { FCVT            S1, H2 }
        v67.n128_f64[0] = (float)((float)((float)(v90 * _S1) * 511.0) + 384.0) + 0.5;
        unsigned int v102 = v67.n128_f64[0];
        if (v67.n128_f64[0] >= 0x3FF) {
          unsigned int v102 = 1023;
        }
        *(void *)&v70[8 * v89] = v98 | ((unint64_t)(v100 | v102) << 32) | 0xC000000000000000;
      }
      v91 += 4;
      ++v89;
    }
    while (v74 != v89);
LABEL_79:
    __asm { FMOV            V0.2S, #1.875 }
    switch(v37)
    {
      case 0:
        BOOL v107 = v44 != 0;
        if (v601)
        {
          int v108 = v74;
          unsigned int v109 = v44;
          int v110 = v596;
          do
          {
            int v111 = *v71;
            if (*v71)
            {
              if (v44) {
                int v111 = ((unsigned __int16)(*(unsigned __int8 *)v109 * (_WORD)v111
              }
                                                          + ((*(unsigned __int8 *)v109 * v111) >> 8)
                                                          + 1) >> 8);
              if (v111)
              {
                if (v111 == 255)
                {
                  LOBYTE(v112) = 0;
                  unsigned int *v33 = 0;
                }
                else
                {
                  unsigned int v113 = v111 ^ 0xFF;
                  unsigned int v112 = (*v31 * (v111 ^ 0xFF) + ((*v31 * (v111 ^ 0xFFu)) >> 8) + 1) >> 8;
                  uint32x2_t v114 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v113));
                  int8x8_t v115 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v114, v114, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int *v33 = v115.i32[0] | (((*v33 & 0x3FF) * v113 + (((*v33 & 0x3FF) * v113) >> 8) + 1) >> 8) | v115.i32[1] | 0xC0000000;
                }
                *unint64_t v31 = v112;
              }
            }
            ++v71;
            unsigned int v109 = (int *)((char *)v109 + v107);
            ++v33;
            ++v31;
            --v108;
          }
          while (v108);
        }
        else
        {
          int v442 = v74;
          unsigned int v109 = v44;
          int v110 = v596;
          do
          {
            int v443 = *v71;
            if (*v71)
            {
              if (v44) {
                int v443 = ((unsigned __int16)(*(unsigned __int8 *)v109 * (_WORD)v443
              }
                                                          + ((*(unsigned __int8 *)v109 * v443) >> 8)
                                                          + 1) >> 8);
              if (v443)
              {
                if (v443 == 255)
                {
                  unsigned int v444 = 0;
                }
                else
                {
                  unsigned int v445 = v443 ^ 0xFF;
                  uint32x2_t v446 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v445));
                  int8x8_t v447 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v446, v446, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v444 = *v33
                       - (v447.i32[0] | (((*v33 & 0x3FF) * v445 + (((*v33 & 0x3FF) * v445) >> 8) + 1) >> 8) | v447.i32[1])
                       + 0x40000000;
                }
                unsigned int *v33 = v444;
              }
            }
            ++v71;
            unsigned int v109 = (int *)((char *)v109 + v107);
            ++v33;
            --v442;
          }
          while (v442);
        }
        uint64_t v44 = (int *)((char *)v109 + v592);
        v33 += v593;
        v31 += v594;
        float32x2_t v120 = v597;
        goto LABEL_546;
      case 1:
        unsigned int v116 = *v71;
        if (v601)
        {
          if (v44)
          {
            uint64_t v117 = 0;
            unsigned int v118 = v71 + 1;
            uint32x2_t v119 = v33 - 1;
            float32x2_t v120 = v597;
            do
            {
              if (v116)
              {
                unsigned int v121 = *((unsigned __int8 *)v44 + v117) * v116 + ((*((unsigned __int8 *)v44 + v117) * v116) >> 8) + 1;
                if (BYTE1(v121))
                {
                  if (BYTE1(v121) == 255)
                  {
                    uint32x2_t v122 = &v70[8 * v117];
                    v33[v117] = *((_DWORD *)v122 + 1);
                    LOBYTE(v122) = *v122;
                  }
                  else
                  {
                    unsigned int v123 = v121 >> 8;
                    uint32x2_t v122 = &v70[8 * v117];
                    unsigned int v124 = *((_DWORD *)v122 + 1);
                    unsigned int v125 = v123 ^ 0xFF;
                    LODWORD(v122) = ((v125 * v31[v117] + ((v125 * v31[v117]) >> 8) + 1) >> 8)
                                  + ((*v122 * v123 + ((*v122 * v123) >> 8) + 1) >> 8);
                    if (v122 >= 0xFF) {
                      LOBYTE(v122) = -1;
                    }
                    unsigned int v126 = (((v124 & 0x3FF) * v123 + (((v124 & 0x3FF) * v123) >> 8) + 1) >> 8)
                         + (((v33[v117] & 0x3FF) * v125 + (((v33[v117] & 0x3FF) * v125) >> 8) + 1) >> 8);
                    if (v126 >= 0x3FF) {
                      unsigned int v126 = 1023;
                    }
                    uint32x2_t v127 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v124), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v123));
                    uint32x2_t v128 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v33[v117]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v125));
                    int8x8_t v129 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v127, v127, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v128, v128, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                    v33[v117] = vorr_s8(v129, (int8x8_t)vdup_lane_s32((int32x2_t)v129, 1)).u32[0] | v126 | 0xC0000000;
                  }
                  v31[v117] = (_BYTE)v122;
                }
              }
              unsigned int v116 = v118[v117++];
              ++v119;
            }
            while (v74 != v117);
            uint64_t v130 = (uint64_t)&v31[v117 - 1];
            uint64_t v44 = (int *)((char *)v44 + v117 + v592);
          }
          else
          {
            unsigned int v522 = v71 + 1;
            uint64_t v130 = (uint64_t)(v31 - 1);
            uint32x2_t v119 = v33 - 1;
            int v523 = v74;
            float32x2_t v120 = v597;
            do
            {
              if (v116)
              {
                if (v116 == 255)
                {
                  v119[1] = *((_DWORD *)v70 + 1);
                  LOBYTE(v524) = *v70;
                }
                else
                {
                  unsigned int v525 = v116 ^ 0xFF;
                  unsigned int v524 = ((*(unsigned __int8 *)(v130 + 1) * v525 + ((*(unsigned __int8 *)(v130 + 1) * v525) >> 8) + 1) >> 8)
                       + ((*v70 * v116 + ((*v70 * v116) >> 8) + 1) >> 8);
                  if (v524 >= 0xFF) {
                    LOBYTE(v524) = -1;
                  }
                  unsigned int v526 = ((*((_DWORD *)v70 + 1) & 0x3FF) * v116 + (((*((_DWORD *)v70 + 1) & 0x3FF) * v116) >> 8) + 1) >> 8;
                  unsigned int v527 = (v119[1] & 0x3FF) * v525 + (((v119[1] & 0x3FF) * v525) >> 8) + 1;
                  uint32x2_t v528 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v116));
                  uint32x2_t v529 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v119[1]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v525));
                  int8x8_t v530 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v528, v528, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v529, v529, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  int8x8_t v531 = (int8x8_t)vdup_lane_s32((int32x2_t)v530, 1);
                  if (v526 + (v527 >> 8) >= 0x3FF) {
                    int v532 = 1023;
                  }
                  else {
                    int v532 = v526 + (v527 >> 8);
                  }
                  v119[1] = vorr_s8(v530, v531).u32[0] | v532 | 0xC0000000;
                }
                *(unsigned char *)(v130 + 1) = v524;
              }
              unsigned int v533 = *v522++;
              unsigned int v116 = v533;
              v70 += 8;
              ++v130;
              ++v119;
              --v523;
            }
            while (v523);
            uint64_t v44 = 0;
          }
          uint64_t v534 = &v119[v593];
          uint64_t v535 = v130 + v594;
          goto LABEL_576;
        }
        unint64_t v448 = v71 + 1;
        uint64_t v449 = v33 - 1;
        int v450 = v74;
        if (v44)
        {
          float32x2_t v120 = v597;
          do
          {
            if (v116)
            {
              unsigned int v451 = ((unsigned __int16)(*(unsigned __int8 *)v44 * (_WORD)v116
                                                        + ((*(unsigned __int8 *)v44 * v116) >> 8)
                                                        + 1) >> 8);
              if (v451)
              {
                if (v451 == 255)
                {
                  unsigned __int32 v452 = *((_DWORD *)v70 + 1);
                }
                else
                {
                  unsigned int v453 = v451 ^ 0xFF;
                  unsigned int v454 = (((v449[1] & 0x3FF) * v453 + (((v449[1] & 0x3FF) * v453) >> 8) + 1) >> 8)
                       + (((*((_DWORD *)v70 + 1) & 0x3FF) * v451 + (((*((_DWORD *)v70 + 1) & 0x3FF) * v451) >> 8) + 1) >> 8);
                  if (v454 >= 0x3FF) {
                    unsigned int v454 = 1023;
                  }
                  uint32x2_t v455 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v451));
                  uint32x2_t v456 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v449[1]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v453));
                  int8x8_t v457 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v456, v456, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v455, v455, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  unsigned __int32 v452 = vorr_s8(v457, (int8x8_t)vdup_lane_s32((int32x2_t)v457, 1)).u32[0] | v454 | 0xC0000000;
                }
                v449[1] = v452;
              }
            }
            unsigned int v458 = *v448++;
            unsigned int v116 = v458;
            v70 += 8;
            uint64_t v44 = (int *)((char *)v44 + 1);
            ++v449;
            --v450;
          }
          while (v450);
          goto LABEL_494;
        }
        float32x2_t v120 = v597;
        do
        {
          if (v116)
          {
            if (v116 == 255)
            {
              unsigned __int32 v562 = *((_DWORD *)v70 + 1);
            }
            else
            {
              unsigned int v563 = v116 ^ 0xFF;
              unsigned int v564 = (((*((_DWORD *)v70 + 1) & 0x3FF) * v116 + (((*((_DWORD *)v70 + 1) & 0x3FF) * v116) >> 8) + 1) >> 8)
                   + (((v449[1] & 0x3FF) * v563 + (((v449[1] & 0x3FF) * v563) >> 8) + 1) >> 8);
              if (v564 >= 0x3FF) {
                unsigned int v564 = 1023;
              }
              uint32x2_t v565 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v116));
              uint32x2_t v566 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v449[1]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v563));
              int8x8_t v567 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v565, v565, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v566, v566, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              unsigned __int32 v562 = vorr_s8(v567, (int8x8_t)vdup_lane_s32((int32x2_t)v567, 1)).u32[0] | v564 | 0xC0000000;
            }
            v449[1] = v562;
          }
          unsigned int v568 = *v448++;
          unsigned int v116 = v568;
          v70 += 8;
          ++v449;
          --v450;
        }
        while (v450);
        goto LABEL_598;
      case 2:
        unsigned int v131 = *v71;
        if (!v601)
        {
          int v459 = v71 + 1;
          uint64_t v449 = v33 - 1;
          int v460 = v74;
          if (v44)
          {
            float32x2_t v120 = v597;
            while (1)
            {
              if (!v131) {
                goto LABEL_493;
              }
              unsigned int v461 = ((unsigned __int16)(*(unsigned __int8 *)v44 * (_WORD)v131
                                                        + ((*(unsigned __int8 *)v44 * v131) >> 8)
                                                        + 1) >> 8);
              if (!((unsigned __int16)(*(unsigned __int8 *)v44 * (_WORD)v131
                                      + ((*(unsigned __int8 *)v44 * v131) >> 8)
                                      + 1) >> 8))
                goto LABEL_493;
              if (v461 == 255)
              {
                if (*(void *)v70)
                {
                  uint64_t v462 = HIDWORD(*(void *)v70);
                  if (*(void *)v70 != 255)
                  {
                    unsigned int v463 = ~*v70;
                    uint32x2_t v464 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v449[1]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v463));
                    int8x8_t v465 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v464, v464, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                    unsigned __int32 v466 = v465.i32[0] | (((v449[1] & 0x3FF) * v463 + (((v449[1] & 0x3FF) * v463) >> 8) + 1) >> 8) | v465.i32[1];
                    __int32 v467 = v462 - 0x40000000;
                    goto LABEL_491;
                  }
                  goto LABEL_492;
                }
              }
              else
              {
                unsigned int v468 = v461 * *(void *)v70 + ((v461 * *(void *)v70) >> 8) + 1;
                if ((v468 & 0xFF00) != 0)
                {
                  v469.i32[0] = HIDWORD(*(void *)v70);
                  v470.i32[0] = v461;
                  uint32x2_t v471 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v469.u32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v461));
                  int32x2_t v472 = (int32x2_t)vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v471, v471, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v473 = ~(v468 >> 8);
                  uint32x2_t v474 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v449[1]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v473));
                  v469.i32[1] = v449[1];
                  int32x2_t v475 = (int32x2_t)vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v474, v474, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  v470.i32[1] = v473;
                  uint32x2_t v476 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v469, (int8x8_t)0x300000003), v470);
                  int8x8_t v477 = vorr_s8(vorr_s8((int8x8_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v476, v476, 8uLL), (int32x2_t)0x100000001), 8uLL), (int8x8_t)vzip1_s32(v472, v475)), (int8x8_t)vzip2_s32(v472, v475));
                  __int32 v467 = v477.i32[1];
                  unsigned __int32 v466 = v477.i32[0] + 0x80000000;
LABEL_491:
                  LODWORD(v462) = v467 + v466;
LABEL_492:
                  v449[1] = v462;
                }
              }
LABEL_493:
              unsigned int v478 = *v459++;
              unsigned int v131 = v478;
              v70 += 8;
              uint64_t v44 = (int *)((char *)v44 + 1);
              ++v449;
              if (!--v460)
              {
LABEL_494:
                uint64_t v44 = (int *)((char *)v44 + v592);
LABEL_599:
                int v33 = &v449[v593 + 1];
                v31 += v594;
                goto LABEL_545;
              }
            }
          }
          float32x2_t v120 = v597;
          while (1)
          {
            if (v131)
            {
              if (v131 == 255)
              {
                unint64_t v569 = *(void *)v70;
                if (*(void *)v70)
                {
                  if (*(void *)v70 == 255)
                  {
                    v569 >>= 32;
                  }
                  else
                  {
                    unint64_t v580 = HIDWORD(v569);
                    unsigned int v581 = ~*v70;
                    uint32x2_t v582 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v449[1]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v581));
                    int8x8_t v583 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v582, v582, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                    LODWORD(v569) = v580
                                  - 0x40000000
                                  + (v583.i32[0] | (((v449[1] & 0x3FF) * v581 + (((v449[1] & 0x3FF) * v581) >> 8) + 1) >> 8) | v583.i32[1]);
                  }
                  goto LABEL_596;
                }
              }
              else
              {
                unsigned int v570 = *(void *)v70 * v131 + ((*(void *)v70 * v131) >> 8) + 1;
                if ((v570 & 0xFF00) != 0)
                {
                  v571.i32[0] = HIDWORD(*(void *)v70);
                  v572.i32[0] = v131;
                  uint32x2_t v573 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v571.u32[0]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v131));
                  int32x2_t v574 = (int32x2_t)vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v573, v573, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v575 = ~(v570 >> 8);
                  uint32x2_t v576 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v449[1]), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v575));
                  v571.i32[1] = v449[1];
                  int32x2_t v577 = (int32x2_t)vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v576, v576, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  v572.i32[1] = v575;
                  uint32x2_t v578 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v571, (int8x8_t)0x300000003), v572);
                  int8x8_t v579 = vorr_s8(vorr_s8((int8x8_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v578, v578, 8uLL), (int32x2_t)0x100000001), 8uLL), (int8x8_t)vzip1_s32(v574, v577)), (int8x8_t)vzip2_s32(v574, v577));
                  LODWORD(v569) = v579.i32[1] + v579.i32[0] + 0x80000000;
LABEL_596:
                  v449[1] = v569;
                }
              }
            }
            unsigned int v584 = *v459++;
            unsigned int v131 = v584;
            v70 += 8;
            ++v449;
            if (!--v460)
            {
LABEL_598:
              uint64_t v44 = 0;
              goto LABEL_599;
            }
          }
        }
        if (!v44)
        {
          int v536 = v71 + 1;
          uint64_t v163 = (uint64_t)(v31 - 1);
          uint32x2_t v134 = v33 - 1;
          int v537 = v74;
          float32x2_t v120 = v597;
          while (1)
          {
            if (v131)
            {
              if (v131 == 255)
              {
                unint64_t v538 = *(void *)v70;
                if (*(void *)v70)
                {
                  if (*(void *)v70 == 255)
                  {
                    v134[1] = HIDWORD(v538);
                    char v539 = -1;
                  }
                  else
                  {
                    unsigned __int32 v552 = v134[1];
                    unsigned int v553 = ~*v70;
                    v554.i32[0] = v552;
                    v554.i32[1] = v552 >> 20;
                    uint32x2_t v555 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v554, (int8x8_t)0x300000003), vdup_n_s32(v553));
                    *(uint32x2_t *)v556.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v555, v555, 8uLL), (int32x2_t)0x100000001), 8uLL);
                    unint64_t v557 = ((((v552 >> 10) & 0x3FF) * v553 + ((((v552 >> 10) & 0x3FF) * v553) >> 8) + 1) >> 8) | ((unint64_t)v556.u32[0] << 32);
                    v556.i32[0] = (v553 * *(unsigned __int8 *)(v163 + 1)
                                 + ((v553 * *(unsigned __int8 *)(v163 + 1)) >> 8)
                                 + 1) >> 8;
                    v556.i64[1] = v557;
                    *(int8x8_t *)v558.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(HIDWORD(v538)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                    uint64_t v559 = v558.u32[0] | ((HIDWORD(v538) & 0x3FF) << 32);
                    v558.i8[0] = *(void *)v70;
                    v558.i64[1] = v559;
                    int64x2_t v560 = vaddq_s64(v556, v558);
                    char v539 = v560.i8[0];
                    v134[1] = ((unint64_t)v560.i64[0] >> 12) & 0x3FF00000 | v560.i16[6] & 0x3FF | ((v560.i16[4] & 0x3FF) << 10) | 0xC0000000;
                  }
                  goto LABEL_572;
                }
              }
              else
              {
                unint64_t v540 = *(void *)v70;
                unsigned int v541 = *(void *)v70 * v131 + ((*(void *)v70 * v131) >> 8) + 1;
                if ((v541 & 0xFF00) != 0)
                {
                  int v542 = ((HIDWORD(*(void *)v70) & 0x3FF) * v131
                        + (((HIDWORD(*(void *)v70) & 0x3FF) * v131) >> 8)
                        + 1) >> 8;
                  unsigned int v543 = (((((v540 >> 52) & 0x3FF) * v131 + ((((v540 >> 52) & 0x3FF) * v131) >> 8)) << 12) + 4096) & 0x3FF00000 | v542;
                  unsigned int v544 = (4 * (((v540 >> 42) & 0x3FF) * v131 + ((((v540 >> 42) & 0x3FF) * v131) >> 8)) + 4) | v542;
                  uint64_t v545 = v541 >> 8;
                  unsigned int v546 = (v545 ^ 0xFF) * *(unsigned __int8 *)(v163 + 1);
                  uint32x2_t v547 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v134[1]), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v545 ^ 0xFF));
                  *(uint32x2_t *)v548.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v547, v547, 8uLL), (int32x2_t)0x100000001), 8uLL);
                  unint64_t v549 = v548.u32[0] | ((unint64_t)(((v134[1] & 0x3FF) * (v545 ^ 0xFF)
                                                          + (((v134[1] & 0x3FF) * (v545 ^ 0xFF)) >> 8)
                                                          + 1) >> 8) << 32);
                  v548.i32[0] = (v546 + (v546 >> 8) + 1) >> 8;
                  v548.i64[1] = v549;
                  v550.i64[0] = v545 | ((unint64_t)(v543 >> 20) << 32);
                  v550.i32[2] = v544 >> 10;
                  v550.i8[12] = v542;
                  v550.i8[13] = BYTE1(v542);
                  v550.i8[14] = BYTE2(v542);
                  v550.i8[15] = HIBYTE(v542);
                  int64x2_t v551 = vaddq_s64(v548, v550);
                  v134[1] = ((unint64_t)v551.i64[0] >> 12) & 0x3FF00000 | v551.i16[6] & 0x3FF | ((v551.i16[4] & 0x3FF) << 10) | 0xC0000000;
                  char v539 = v551.i8[0];
LABEL_572:
                  *(unsigned char *)(v163 + 1) = v539;
                }
              }
            }
            unsigned int v561 = *v536++;
            unsigned int v131 = v561;
            v70 += 8;
            ++v163;
            ++v134;
            if (!--v537)
            {
              uint64_t v44 = 0;
              goto LABEL_575;
            }
          }
        }
        uint64_t v132 = 0;
        uint64_t v133 = v71 + 1;
        uint32x2_t v134 = v33 - 1;
        float32x2_t v120 = v597;
        do
        {
          if (v131)
          {
            unsigned int v135 = *((unsigned __int8 *)v44 + v132) * v131 + ((*((unsigned __int8 *)v44 + v132) * v131) >> 8) + 1;
            if (BYTE1(v135))
            {
              if (BYTE1(v135) == 255)
              {
                unint64_t v136 = *(void *)&v70[8 * v132];
                if (!(_BYTE)v136) {
                  goto LABEL_120;
                }
                if (*(void *)&v70[8 * v132] == 255)
                {
                  v33[v132] = HIDWORD(v136);
                  char v137 = -1;
                }
                else
                {
                  unsigned __int32 v154 = v33[v132];
                  unsigned int v155 = ~(_BYTE)v136;
                  v156.i32[0] = v154;
                  v156.i32[1] = v154 >> 20;
                  uint32x2_t v157 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v156, (int8x8_t)0x300000003), vdup_n_s32(v155));
                  *(uint32x2_t *)v158.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v157, v157, 8uLL), (int32x2_t)0x100000001), 8uLL);
                  unint64_t v159 = ((((v154 >> 10) & 0x3FF) * v155 + ((((v154 >> 10) & 0x3FF) * v155) >> 8) + 1) >> 8) | ((unint64_t)v158.u32[0] << 32);
                  v158.i32[0] = (v155 * v31[v132] + ((v155 * v31[v132]) >> 8) + 1) >> 8;
                  v158.i64[1] = v159;
                  *(int8x8_t *)v160.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(HIDWORD(v136)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                  uint64_t v161 = v160.u32[0] | ((HIDWORD(v136) & 0x3FF) << 32);
                  v160.i8[0] = v136;
                  v160.i64[1] = v161;
                  int64x2_t v162 = vaddq_s64(v158, v160);
                  char v137 = v162.i8[0];
                  v33[v132] = ((unint64_t)v162.i64[0] >> 12) & 0x3FF00000 | v162.i16[6] & 0x3FF | ((v162.i16[4] & 0x3FF) << 10) | 0xC0000000;
                }
              }
              else
              {
                uint64_t v138 = *(void *)&v70[8 * v132];
                unsigned int v139 = v135 >> 8;
                unsigned int v140 = v138 * (v135 >> 8) + ((v138 * (v135 >> 8)) >> 8) + 1;
                if ((v140 & 0xFF00) == 0) {
                  goto LABEL_120;
                }
                LODWORD(v138) = (WORD2(v138) & 0x3FF) * v139 + (((WORD2(v138) & 0x3FF) * v139) >> 8) + 1;
                uint32x2_t v141 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(HIDWORD(v138)), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v139));
                int8x8_t v142 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v141, v141, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v143 = vorr_s8(v142, (int8x8_t)vdup_lane_s32((int32x2_t)v142, 1)).u32[0] | (v138 >> 8) | 0xC0000000;
                unsigned __int32 v144 = v33[v132];
                uint64_t v145 = BYTE1(v140);
                int v146 = v145 ^ 0xFF;
                v142.i32[0] = v144;
                v142.i32[1] = v144 >> 20;
                uint32x2_t v147 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v142, (int8x8_t)0x300000003), vdup_n_s32(v145 ^ 0xFF));
                *(uint32x2_t *)v148.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v147, v147, 8uLL), (int32x2_t)0x100000001), 8uLL);
                unint64_t v149 = ((((v144 >> 10) & 0x3FF) * v146 + ((((v144 >> 10) & 0x3FF) * v146) >> 8) + 1) >> 8) | ((unint64_t)v148.u32[0] << 32);
                v148.i32[0] = (v146 * v31[v132]
                             + ((v146 * v31[v132]) >> 8)
                             + 1) >> 8;
                v148.i64[1] = v149;
                int8x8_t v150 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v143), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                unint64_t v151 = v150.u32[0] | ((unint64_t)((v138 >> 8) & 0x3FF) << 32);
                v152.i64[0] = v145 | ((unint64_t)v150.u32[1] << 32);
                v152.i64[1] = v151;
                int64x2_t v153 = vaddq_s64(v148, v152);
                v33[v132] = ((unint64_t)v153.i64[0] >> 12) & 0x3FF00000 | v153.i16[6] & 0x3FF | ((v153.i16[4] & 0x3FF) << 10) | 0xC0000000;
                char v137 = v153.i8[0];
              }
              v31[v132] = v137;
            }
          }
LABEL_120:
          unsigned int v131 = v133[v132++];
          ++v134;
        }
        while (v74 != v132);
        uint64_t v163 = (uint64_t)&v31[v132 - 1];
        uint64_t v44 = (int *)((char *)v44 + v132 + v592);
LABEL_575:
        uint64_t v534 = &v134[v593];
        uint64_t v535 = v163 + v594;
LABEL_576:
        int v33 = v534 + 1;
        unint64_t v31 = (unsigned char *)(v535 + 1);
LABEL_545:
        int v110 = v596;
LABEL_546:
        int v521 = v110 - 1;
        if (v521)
        {
          int v596 = v521;
          unsigned int v63 = 0;
          ++v42;
          float32x2_t v39 = (float32x2_t)(*(void *)&v38[16] + *(void *)&v120);
          *(void *)&v40 += *(void *)&v38[17];
          if (v41)
          {
            uint64_t v47 = v589;
LABEL_22:
            unsigned int v49 = v44 - 4;
            uint64_t v50 = v594 + v47;
            while (1)
            {
              while (1)
              {
                int v51 = *v49;
                int v52 = *v49 - v42;
                if (*v49 <= v42) {
                  break;
                }
                v596 -= v52;
                if (v596 < 1) {
                  goto LABEL_600;
                }
                *(void *)&v39 += *(void *)&v591[16] * v52;
                *(void *)&v40 += *(void *)&v591[17] * v52;
                v33 += v585 * v52;
                uint64_t v55 = v50 * v52;
                if (!v601) {
                  uint64_t v55 = 0;
                }
                v31 += v55;
                int v42 = v51;
              }
              if (v42 < *(v44 - 3) + v51) {
                break;
              }
              uint32x2_t v53 = v44;
              int v54 = shape_enum_clip_scan((uint64_t)v41, v49);
              uint64_t v44 = v53;
              if (!v54) {
                goto LABEL_600;
              }
            }
            int8x8_t v38 = v591;
            int v21 = v602;
            uint64_t v32 = v589;
            unsigned int v28 = v595;
            continue;
          }
          goto LABEL_33;
        }
LABEL_600:
        unsigned int v48 = v586;
        if (v41) {
          free(v41);
        }
LABEL_602:
        if (v48) {
          free(v48);
        }
        return;
      case 3:
        int v164 = v74;
        uint32x2_t v165 = v44;
        do
        {
          int v166 = *v71;
          if (*v71)
          {
            if (v44) {
              int v166 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v166
            }
                                                        + ((*(unsigned __int8 *)v165 * v166) >> 8)
                                                        + 1) >> 8);
            if (v166)
            {
              if (v166 == 255)
              {
                unsigned int v167 = *v31;
                unsigned int v168 = (*v70 * v167 + ((*v70 * v167) >> 8) + 1) >> 8;
                uint32x2_t v169 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v167));
                int8x8_t v170 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v169, v169, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v171 = v170.u32[1];
                unsigned __int32 v172 = v170.i32[0] | (((*((_DWORD *)v70 + 1) & 0x3FF) * v167
                                     + (((*((_DWORD *)v70 + 1) & 0x3FF) * v167) >> 8)
                                     + 1) >> 8);
              }
              else
              {
                int v173 = *v31;
                unsigned int v174 = (v173 * v166 + ((v173 * v166) >> 8) + 1) >> 8;
                unsigned int v175 = v166 ^ 0xFF;
                unsigned int v168 = ((v174 * *v70 + ((v174 * *v70) >> 8) + 1) >> 8) + ((v173 * v175 + ((v173 * v175) >> 8) + 1) >> 8);
                if (v168 >= 0xFF) {
                  LOBYTE(v168) = -1;
                }
                unsigned int v171 = ((v174 * (*((_DWORD *)v70 + 1) & 0x3FF) + ((v174 * (*((_DWORD *)v70 + 1) & 0x3FF)) >> 8) + 1) >> 8)
                     + (((*v33 & 0x3FF) * v175 + (((*v33 & 0x3FF) * v175) >> 8) + 1) >> 8);
                if (v171 >= 0x3FF) {
                  unsigned int v171 = 1023;
                }
                uint32x2_t v176 = (uint32x2_t)vmul_s32(vdup_n_s32(v174), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
                uint32x2_t v177 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v175));
                int8x8_t v178 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v176, v176, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v177, v177, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                unsigned __int32 v172 = vorr_s8(v178, (int8x8_t)vdup_lane_s32((int32x2_t)v178, 1)).u32[0];
              }
              unsigned int *v33 = v172 | v171 | 0xC0000000;
              *unint64_t v31 = v168;
            }
          }
          ++v71;
          v70 += 8;
          uint32x2_t v165 = (int *)((char *)v165 + (v44 != 0));
          ++v33;
          v31 += v75;
          --v164;
        }
        while (v164);
        goto LABEL_543;
      case 4:
        int v179 = v74;
        uint32x2_t v165 = v44;
        do
        {
          int v180 = *v71;
          if (*v71)
          {
            if (v44) {
              int v180 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v180
            }
                                                        + ((*(unsigned __int8 *)v165 * v180) >> 8)
                                                        + 1) >> 8);
            if (v180)
            {
              if (v180 == 255)
              {
                unsigned int v181 = *v31 ^ 0xFF;
                unsigned int v182 = (*v70 * v181 + ((*v70 * v181) >> 8) + 1) >> 8;
                uint32x2_t v183 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v181));
                int8x8_t v184 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v183, v183, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v185 = v184.u32[1];
                unsigned __int32 v186 = v184.i32[0] | (((*((_DWORD *)v70 + 1) & 0x3FF) * v181
                                     + (((*((_DWORD *)v70 + 1) & 0x3FF) * v181) >> 8)
                                     + 1) >> 8);
              }
              else
              {
                int v187 = *v31;
                unsigned int v188 = ((v187 ^ 0xFF) * v180 + (((v187 ^ 0xFFu) * v180) >> 8) + 1) >> 8;
                unsigned int v189 = v180 ^ 0xFF;
                unsigned int v182 = ((v188 * *v70 + ((v188 * *v70) >> 8) + 1) >> 8) + ((v187 * v189 + ((v187 * v189) >> 8) + 1) >> 8);
                if (v182 >= 0xFF) {
                  LOBYTE(v182) = -1;
                }
                unsigned int v185 = ((v188 * (*((_DWORD *)v70 + 1) & 0x3FF) + ((v188 * (*((_DWORD *)v70 + 1) & 0x3FF)) >> 8) + 1) >> 8)
                     + (((*v33 & 0x3FF) * v189 + (((*v33 & 0x3FF) * v189) >> 8) + 1) >> 8);
                if (v185 >= 0x3FF) {
                  unsigned int v185 = 1023;
                }
                uint32x2_t v190 = (uint32x2_t)vmul_s32(vdup_n_s32(v188), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
                uint32x2_t v191 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v189));
                int8x8_t v192 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v190, v190, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v191, v191, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                unsigned __int32 v186 = vorr_s8(v192, (int8x8_t)vdup_lane_s32((int32x2_t)v192, 1)).u32[0];
              }
              unsigned int *v33 = v186 | v185 | 0xC0000000;
              *unint64_t v31 = v182;
            }
          }
          ++v71;
          v70 += 8;
          uint32x2_t v165 = (int *)((char *)v165 + (v44 != 0));
          ++v33;
          v31 += v75;
          --v179;
        }
        while (v179);
        goto LABEL_543;
      case 5:
        int v193 = v74;
        uint32x2_t v165 = v44;
        do
        {
          int v194 = *v71;
          if (*v71)
          {
            if (!v44
              || (unsigned int v195 = *(unsigned __int8 *)v165 * v194 + ((*(unsigned __int8 *)v165 * v194) >> 8) + 1,
                  int v194 = BYTE1(v195),
                  BYTE1(v195)))
            {
              unsigned int v196 = *v31;
              unsigned int v197 = (*(void *)v70 * v194
                    + ((*(void *)v70 * v194) >> 8)
                    + 1) >> 8;
              unsigned int v198 = ((*(void *)v70 >> 52) & 0x3FF) * v194;
              unsigned int v199 = ((*(void *)v70 >> 42) & 0x3FF) * v194;
              unsigned int v200 = ((HIDWORD(*(void *)v70) & 0x3FF) * v194
                    + (((HIDWORD(*(void *)v70) & 0x3FF) * v194) >> 8)
                    + 1) >> 8;
              unsigned int v201 = v197 ^ 0xFF;
              unsigned int v202 = ((v201 * v196 + ((v201 * v196) >> 8) + 1) >> 8) + ((v197 * v196 + ((v197 * v196) >> 8) + 1) >> 8);
              if (v202 >= 0xFF) {
                LOBYTE(v202) = -1;
              }
              unsigned int v203 = ((v201 * (*v33 & 0x3FF) + ((v201 * (*v33 & 0x3FF)) >> 8) + 1) >> 8)
                   + ((v200 * v196 + ((v200 * v196) >> 8) + 1) >> 8);
              if (v203 >= 0x3FF) {
                unsigned int v203 = 1023;
              }
              v204.i32[0] = 1;
              v204.i32[1] = v198 >> 8;
              int32x2_t v205 = vadd_s32((int32x2_t)__PAIR64__(v198 + 1, v199), v204);
              v204.i32[0] = vshl_n_s32(vadd_s32(v205, (int32x2_t)((v199 >> 8) | 0xC00000000)), 2uLL).u32[0];
              v204.i32[1] = vand_s8((int8x8_t)vshl_n_s32(v205, 0xCuLL), _D0).i32[1];
              uint32x2_t v206 = (uint32x2_t)vmul_s32((int32x2_t)vshl_u32((uint32x2_t)vorr_s8((int8x8_t)vdup_n_s32(v200), (int8x8_t)v204), (uint32x2_t)0xFFFFFFECFFFFFFF6), vdup_n_s32(v196));
              uint32x2_t v207 = (uint32x2_t)vmul_s32(vdup_n_s32(v201), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
              int8x8_t v208 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v206, v206, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v207, v207, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              unsigned int *v33 = vorr_s8(v208, (int8x8_t)vdup_lane_s32((int32x2_t)v208, 1)).u32[0] | v203 | 0xC0000000;
              *unint64_t v31 = v202;
            }
          }
          ++v71;
          v70 += 8;
          uint32x2_t v165 = (int *)((char *)v165 + (v44 != 0));
          ++v33;
          v31 += v75;
          --v193;
        }
        while (v193);
        goto LABEL_543;
      case 6:
        int v209 = v74;
        uint32x2_t v165 = v44;
        do
        {
          unsigned int v210 = *v71;
          if (*v71)
          {
            if (!v44
              || (unsigned int v211 = *(unsigned __int8 *)v165 * v210 + ((*(unsigned __int8 *)v165 * v210) >> 8) + 1,
                  unsigned int v210 = BYTE1(v211),
                  BYTE1(v211)))
            {
              uint64_t v212 = *v31;
              if ((_BYTE)v212 != 0xFF)
              {
                if (~(_BYTE)v212 == 255)
                {
                  LODWORD(v212) = (*v70 * v210 + ((*v70 * v210) >> 8) + 1) >> 8;
                  uint32x2_t v213 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v210));
                  int8x8_t v214 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v213, v213, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v215 = v214.i32[0] | (((*((_DWORD *)v70 + 1) & 0x3FF) * v210
                                       + (((*((_DWORD *)v70 + 1) & 0x3FF) * v210) >> 8)
                                       + 1) >> 8) | v214.i32[1] | 0xC0000000;
                }
                else
                {
                  unsigned int v216 = (~(_BYTE)v212 * v210 + ((~(_BYTE)v212 * v210) >> 8) + 1) >> 8;
                  uint32x2_t v217 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v216));
                  *(uint32x2_t *)v218.i8 = vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v217, v217, 8uLL), (int32x2_t)0x100000001), 8uLL);
                  unint64_t v219 = v218.u32[0] | ((unint64_t)(((*((_DWORD *)v70 + 1) & 0x3FF) * v216
                                                          + (((*((_DWORD *)v70 + 1) & 0x3FF) * v216) >> 8)
                                                          + 1) >> 8) << 32);
                  v218.i32[0] = (*v70 * v216 + ((*v70 * v216) >> 8) + 1) >> 8;
                  v218.i64[1] = v219;
                  int8x8_t v220 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                  unint64_t v221 = v220.u32[0] | ((unint64_t)(*v33 & 0x3FF) << 32);
                  v222.i64[0] = v212 | ((unint64_t)v220.u32[1] << 32);
                  v222.i64[1] = v221;
                  int64x2_t v223 = vaddq_s64(v218, v222);
                  LOBYTE(v212) = v223.i8[0];
                  unsigned int v215 = ((unint64_t)v223.i64[0] >> 12) & 0x3FF00000 | v223.i16[6] & 0x3FF | ((v223.i16[4] & 0x3FF) << 10) | 0xC0000000;
                }
                unsigned int *v33 = v215;
                *unint64_t v31 = v212;
              }
            }
          }
          ++v71;
          v70 += 8;
          uint32x2_t v165 = (int *)((char *)v165 + (v44 != 0));
          ++v33;
          v31 += v75;
          --v209;
        }
        while (v209);
        goto LABEL_543;
      case 7:
        BOOL v224 = v44 != 0;
        if (v601)
        {
          int v225 = v74;
          uint32x2_t v165 = v44;
          do
          {
            int v226 = *v71;
            if (*v71)
            {
              if (v44) {
                int v226 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v226
              }
                                                          + ((*(unsigned __int8 *)v165 * v226) >> 8)
                                                          + 1) >> 8);
              if (v226)
              {
                if (v226 == 255)
                {
                  unsigned int v227 = *v70;
                  unsigned int v228 = (v227 * *v31 + ((v227 * *v31) >> 8) + 1) >> 8;
                  uint32x2_t v229 = (uint32x2_t)vmul_s32(vdup_n_s32(v227), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003));
                  int8x8_t v230 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v229, v229, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v231 = v230.u32[1];
                  unsigned __int32 v232 = v230.i32[0] | ((v227 * (*v33 & 0x3FF) + ((v227 * (*v33 & 0x3FF)) >> 8) + 1) >> 8);
                }
                else
                {
                  unsigned int v233 = (*v70 * v226 + ((*v70 * v226) >> 8) + 1) >> 8;
                  unsigned int v234 = v226 ^ 0xFF;
                  unsigned int v228 = ((v233 * *v31 + ((v233 * *v31) >> 8) + 1) >> 8)
                       + ((*v31 * v234 + ((*v31 * v234) >> 8) + 1) >> 8);
                  if (v228 >= 0xFF) {
                    LOBYTE(v228) = -1;
                  }
                  unsigned int v231 = ((v233 * (*v33 & 0x3FF) + ((v233 * (*v33 & 0x3FF)) >> 8) + 1) >> 8)
                       + (((*v33 & 0x3FF) * v234 + (((*v33 & 0x3FF) * v234) >> 8) + 1) >> 8);
                  if (v231 >= 0x3FF) {
                    unsigned int v231 = 1023;
                  }
                  int32x2_t v235 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                  uint32x2_t v236 = (uint32x2_t)vmul_s32(vdup_n_s32(v233), v235);
                  uint32x2_t v237 = (uint32x2_t)vmul_s32(v235, vdup_n_s32(v234));
                  int8x8_t v238 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v236, v236, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v237, v237, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  unsigned __int32 v232 = vorr_s8(v238, (int8x8_t)vdup_lane_s32((int32x2_t)v238, 1)).u32[0];
                }
                unsigned int *v33 = v232 | v231 | 0xC0000000;
                *unint64_t v31 = v228;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v224);
            ++v33;
            ++v31;
            --v225;
          }
          while (v225);
        }
        else
        {
          int v479 = v74;
          uint32x2_t v165 = v44;
          do
          {
            int v480 = *v71;
            if (*v71)
            {
              if (v44) {
                int v480 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v480
              }
                                                          + ((*(unsigned __int8 *)v165 * v480) >> 8)
                                                          + 1) >> 8);
              if (v480)
              {
                if (v480 == 255)
                {
                  unsigned int v481 = *v70;
                  uint32x2_t v482 = (uint32x2_t)vmul_s32(vdup_n_s32(v481), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003));
                  int8x8_t v483 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v482, v482, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned __int32 v484 = *v33
                       - (v483.i32[0] | ((v481 * (*v33 & 0x3FF) + ((v481 * (*v33 & 0x3FF)) >> 8) + 1) >> 8) | v483.i32[1])
                       + 0x40000000;
                }
                else
                {
                  unsigned int v485 = (*v70 * v480 + ((*v70 * v480) >> 8) + 1) >> 8;
                  unsigned int v486 = v480 ^ 0xFF;
                  unsigned int v487 = ((v485 * (*v33 & 0x3FF) + ((v485 * (*v33 & 0x3FF)) >> 8) + 1) >> 8)
                       + (((*v33 & 0x3FF) * v486 + (((*v33 & 0x3FF) * v486) >> 8) + 1) >> 8);
                  if (v487 >= 0x3FF) {
                    unsigned int v487 = 1023;
                  }
                  int32x2_t v488 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                  uint32x2_t v489 = (uint32x2_t)vmul_s32(vdup_n_s32(v485), v488);
                  uint32x2_t v490 = (uint32x2_t)vmul_s32(v488, vdup_n_s32(v486));
                  int8x8_t v491 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v489, v489, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v490, v490, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  unsigned __int32 v484 = vorr_s8(v491, (int8x8_t)vdup_lane_s32((int32x2_t)v491, 1)).u32[0] | v487 | 0xC0000000;
                }
                unsigned int *v33 = v484;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v224);
            ++v33;
            --v479;
          }
          while (v479);
        }
        goto LABEL_543;
      case 8:
        BOOL v239 = v44 != 0;
        if (v601)
        {
          int v240 = v74;
          uint32x2_t v165 = v44;
          do
          {
            int v241 = *v71;
            if (*v71)
            {
              if (v44) {
                int v241 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v241
              }
                                                          + ((*(unsigned __int8 *)v165 * v241) >> 8)
                                                          + 1) >> 8);
              if (v241)
              {
                if (v241 == 255)
                {
                  unsigned int v242 = *v70 ^ 0xFF;
                  unsigned int v243 = (v242 * *v31 + ((v242 * *v31) >> 8) + 1) >> 8;
                  uint32x2_t v244 = (uint32x2_t)vmul_s32(vdup_n_s32(v242), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003));
                  int8x8_t v245 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v244, v244, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned int v246 = v245.u32[1];
                  unsigned __int32 v247 = v245.i32[0] | ((v242 * (*v33 & 0x3FF) + ((v242 * (*v33 & 0x3FF)) >> 8) + 1) >> 8);
                }
                else
                {
                  unsigned int v248 = ((*v70 ^ 0xFF) * v241 + (((*v70 ^ 0xFFu) * v241) >> 8) + 1) >> 8;
                  unsigned int v249 = v241 ^ 0xFF;
                  unsigned int v243 = ((v248 * *v31 + ((v248 * *v31) >> 8) + 1) >> 8)
                       + ((*v31 * v249 + ((*v31 * v249) >> 8) + 1) >> 8);
                  if (v243 >= 0xFF) {
                    LOBYTE(v243) = -1;
                  }
                  unsigned int v246 = ((v248 * (*v33 & 0x3FF) + ((v248 * (*v33 & 0x3FF)) >> 8) + 1) >> 8)
                       + (((*v33 & 0x3FF) * v249 + (((*v33 & 0x3FF) * v249) >> 8) + 1) >> 8);
                  if (v246 >= 0x3FF) {
                    unsigned int v246 = 1023;
                  }
                  int32x2_t v250 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                  uint32x2_t v251 = (uint32x2_t)vmul_s32(vdup_n_s32(v248), v250);
                  uint32x2_t v252 = (uint32x2_t)vmul_s32(v250, vdup_n_s32(v249));
                  int8x8_t v253 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v251, v251, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v252, v252, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  unsigned __int32 v247 = vorr_s8(v253, (int8x8_t)vdup_lane_s32((int32x2_t)v253, 1)).u32[0];
                }
                unsigned int *v33 = v247 | v246 | 0xC0000000;
                *unint64_t v31 = v243;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v239);
            ++v33;
            ++v31;
            --v240;
          }
          while (v240);
        }
        else
        {
          int v492 = v74;
          uint32x2_t v165 = v44;
          do
          {
            int v493 = *v71;
            if (*v71)
            {
              if (v44) {
                int v493 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v493
              }
                                                          + ((*(unsigned __int8 *)v165 * v493) >> 8)
                                                          + 1) >> 8);
              if (v493)
              {
                if (v493 == 255)
                {
                  unsigned int v494 = *v70 ^ 0xFF;
                  uint32x2_t v495 = (uint32x2_t)vmul_s32(vdup_n_s32(v494), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003));
                  int8x8_t v496 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v495, v495, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                  unsigned __int32 v497 = *v33
                       - (v496.i32[0] | ((v494 * (*v33 & 0x3FF) + ((v494 * (*v33 & 0x3FF)) >> 8) + 1) >> 8) | v496.i32[1])
                       + 0x40000000;
                }
                else
                {
                  unsigned int v498 = ((*v70 ^ 0xFF) * v493 + (((*v70 ^ 0xFFu) * v493) >> 8) + 1) >> 8;
                  unsigned int v499 = v493 ^ 0xFF;
                  unsigned int v500 = ((v498 * (*v33 & 0x3FF) + ((v498 * (*v33 & 0x3FF)) >> 8) + 1) >> 8)
                       + (((*v33 & 0x3FF) * v499 + (((*v33 & 0x3FF) * v499) >> 8) + 1) >> 8);
                  if (v500 >= 0x3FF) {
                    unsigned int v500 = 1023;
                  }
                  int32x2_t v501 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
                  uint32x2_t v502 = (uint32x2_t)vmul_s32(vdup_n_s32(v498), v501);
                  uint32x2_t v503 = (uint32x2_t)vmul_s32(v501, vdup_n_s32(v499));
                  int8x8_t v504 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v502, v502, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v503, v503, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                  unsigned __int32 v497 = vorr_s8(v504, (int8x8_t)vdup_lane_s32((int32x2_t)v504, 1)).u32[0] | v500 | 0xC0000000;
                }
                unsigned int *v33 = v497;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v239);
            ++v33;
            --v492;
          }
          while (v492);
        }
        goto LABEL_543;
      case 9:
        int v254 = v74;
        uint32x2_t v165 = v44;
        break;
      case 10:
        int v275 = v74;
        uint32x2_t v165 = v44;
        do
        {
          int v276 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v276 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v276
                                                            + ((*(unsigned __int8 *)v165 * v276) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v277 = *v31;
              unsigned int v278 = (*(void *)v70 * v276
                    + ((*(void *)v70 * v276) >> 8)
                    + 1) >> 8;
              unsigned int v279 = ((*(void *)v70 >> 52) & 0x3FF) * v276;
              __int32 v280 = v279 >> 8;
              unsigned int v281 = v279 + 1;
              unsigned int v282 = ((*(void *)v70 >> 42) & 0x3FF) * v276;
              unsigned int v283 = ((HIDWORD(*(void *)v70) & 0x3FF) * v276
                    + (((HIDWORD(*(void *)v70) & 0x3FF) * v276) >> 8)
                    + 1) >> 8;
              unsigned int v284 = v277 ^ 0xFF;
              unsigned int v285 = v278 * v284 + ((v278 * v284) >> 8) + 1;
              unsigned int v286 = v278 ^ 0xFF;
              unsigned int v287 = ((v286 * v277 + ((v286 * v277) >> 8) + 1) >> 8) + (v285 >> 8);
              if (v287 >= 0xFF) {
                LOBYTE(v287) = -1;
              }
              unsigned int v288 = ((v286 * (*v33 & 0x3FF) + ((v286 * (*v33 & 0x3FF)) >> 8) + 1) >> 8)
                   + ((v283 * v284 + ((v283 * v284) >> 8) + 1) >> 8);
              if (v288 >= 0x3FF) {
                unsigned int v288 = 1023;
              }
              v289.i32[0] = 1;
              v289.i32[1] = v280;
              int32x2_t v290 = vadd_s32((int32x2_t)__PAIR64__(v281, v282), v289);
              v289.i32[0] = vshl_n_s32(vadd_s32(v290, (int32x2_t)((v282 >> 8) | 0xC00000000)), 2uLL).u32[0];
              v289.i32[1] = vand_s8((int8x8_t)vshl_n_s32(v290, 0xCuLL), _D0).i32[1];
              uint32x2_t v291 = (uint32x2_t)vmul_s32((int32x2_t)vshl_u32((uint32x2_t)vorr_s8((int8x8_t)vdup_n_s32(v283), (int8x8_t)v289), (uint32x2_t)0xFFFFFFECFFFFFFF6), vdup_n_s32(v284));
              uint32x2_t v292 = (uint32x2_t)vmul_s32(vdup_n_s32(v286), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003));
              int8x8_t v293 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v291, v291, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v292, v292, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
              unsigned int *v33 = vorr_s8(v293, (int8x8_t)vdup_lane_s32((int32x2_t)v293, 1)).u32[0] | v288 | 0xC0000000;
              *unint64_t v31 = v287;
            }
          }
          ++v71;
          v70 += 8;
          uint32x2_t v165 = (int *)((char *)v165 + (v44 != 0));
          ++v33;
          v31 += v75;
          --v275;
        }
        while (v275);
        goto LABEL_543;
      case 11:
        BOOL v294 = v44 != 0;
        if (v601)
        {
          int v295 = v74;
          uint32x2_t v165 = v44;
          do
          {
            int v296 = *v71;
            if (*v71)
            {
              if (!v44
                || (int v296 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v296
                                                              + ((*(unsigned __int8 *)v165 * v296) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                unsigned int v297 = *(void *)v70 * v296
                     + ((*(void *)v70 * v296) >> 8)
                     + 1;
                unsigned int v298 = ((*(void *)v70 >> 52) & 0x3FF) * v296;
                unsigned int v299 = ((*(void *)v70 >> 42) & 0x3FF) * v296;
                unsigned int v300 = (HIDWORD(*(void *)v70) & 0x3FF) * v296
                     + (((HIDWORD(*(void *)v70) & 0x3FF) * v296) >> 8)
                     + 1;
                unsigned int v301 = (((v298 + (v298 >> 8)) << 12) + 4096) & 0x3FF00000 | (v300 >> 8);
                unsigned int v302 = (4 * (v299 + (v299 >> 8)) + 4) | (v300 >> 8);
                unsigned int v303 = *v31 + (v297 >> 8);
                if (v303 >= 0xFF) {
                  LOBYTE(v303) = -1;
                }
                unsigned int v304 = ((*v33 >> 20) & 0x3FF) + (v301 >> 20);
                if (v304 >= 0x3FF) {
                  unsigned int v304 = 1023;
                }
                unsigned int v305 = ((*v33 >> 10) & 0x3FF) + (v302 >> 10);
                if (v305 >= 0x3FF) {
                  unsigned int v305 = 1023;
                }
                unsigned int v306 = (*v33 & 0x3FF) + (v300 >> 8);
                if (v306 >= 0x3FF) {
                  unsigned int v306 = 1023;
                }
                unsigned int *v33 = (v305 << 10) | (v304 << 20) | v306 | 0xC0000000;
                *unint64_t v31 = v303;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v294);
            ++v33;
            ++v31;
            --v295;
          }
          while (v295);
        }
        else
        {
          int v505 = v74;
          uint32x2_t v165 = v44;
          do
          {
            int v506 = *v71;
            if (*v71)
            {
              if (!v44
                || (int v506 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v506
                                                              + ((*(unsigned __int8 *)v165 * v506) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                unsigned int v507 = ((*(void *)v70 >> 52) & 0x3FF) * v506;
                unsigned int v508 = ((*(void *)v70 >> 42) & 0x3FF) * v506;
                unsigned int v509 = (HIDWORD(*(void *)v70) & 0x3FF) * v506
                     + (((HIDWORD(*(void *)v70) & 0x3FF) * v506) >> 8)
                     + 1;
                unsigned int v510 = ((*v33 >> 20) & 0x3FF)
                     + (((((v507 + (v507 >> 8)) << 12) + 4096) & 0x3FF00000 | (v509 >> 8)) >> 20);
                if (v510 >= 0x3FF) {
                  unsigned int v510 = 1023;
                }
                unsigned int v511 = ((*v33 >> 10) & 0x3FF) + (((4 * (v508 + (v508 >> 8)) + 4) | (v509 >> 8)) >> 10);
                if (v511 >= 0x3FF) {
                  unsigned int v511 = 1023;
                }
                unsigned int v512 = (*v33 & 0x3FF) + (v509 >> 8);
                if (v512 >= 0x3FF) {
                  unsigned int v512 = 1023;
                }
                unsigned int *v33 = (v511 << 10) | (v510 << 20) | v512 | 0xC0000000;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v294);
            ++v33;
            --v505;
          }
          while (v505);
        }
        goto LABEL_543;
      case 12:
        BOOL v307 = v44 != 0;
        if (v601)
        {
          int v308 = v74;
          uint32x2_t v165 = v44;
          do
          {
            int v309 = *v71;
            if (*v71)
            {
              if (!v44
                || (int v309 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v309
                                                              + ((*(unsigned __int8 *)v165 * v309) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                unsigned int v310 = *(void *)v70 * v309
                     + ((*(void *)v70 * v309) >> 8)
                     + 1;
                unsigned int v311 = ((*(void *)v70 >> 52) & 0x3FF) * v309;
                unsigned int v312 = ((*(void *)v70 >> 42) & 0x3FF) * v309;
                unsigned int v313 = (HIDWORD(*(void *)v70) & 0x3FF) * v309
                     + (((HIDWORD(*(void *)v70) & 0x3FF) * v309) >> 8)
                     + 1;
                unsigned int v314 = (((v311 + (v311 >> 8)) << 12) + 4096) & 0x3FF00000 | (v313 >> 8);
                unsigned int v315 = (4 * (v312 + (v312 >> 8)) + 4) | (v313 >> 8);
                unsigned int v316 = *v31 + (v310 >> 8);
                if (v316 >= 0xFF) {
                  LOBYTE(v316) = -1;
                }
                unsigned int v317 = ((*v33 >> 20) & 0x3FF) + (v314 >> 20);
                if (v317 >= 0x3FF) {
                  unsigned int v317 = 1023;
                }
                unsigned int v318 = ((*v33 >> 10) & 0x3FF) + (v315 >> 10);
                if (v318 >= 0x3FF) {
                  unsigned int v318 = 1023;
                }
                unsigned int v319 = (*v33 & 0x3FF) + (v313 >> 8);
                if (v319 >= 0x3FF) {
                  unsigned int v319 = 1023;
                }
                unsigned int *v33 = (v318 << 10) | (v317 << 20) | v319 | 0xC0000000;
                *unint64_t v31 = v316;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v307);
            ++v33;
            ++v31;
            --v308;
          }
          while (v308);
        }
        else
        {
          int v513 = v74;
          uint32x2_t v165 = v44;
          do
          {
            unsigned int v514 = *v71;
            if (*v71)
            {
              if (!v44
                || (unsigned int v514 = ((unsigned __int16)(*(unsigned __int8 *)v165 * (_WORD)v514
                                                              + ((*(unsigned __int8 *)v165 * v514) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                uint32x2_t v515 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)v70 + 1)), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003), vdup_n_s32(v514));
                int8x8_t v516 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vshl_u32(vsra_n_u32(v515, v515, 8uLL), (uint32x2_t)0x20000000CLL), (int32x2_t)0x400001000), (int8x8_t)0xFFC003FF00000);
                unsigned int v517 = *((_DWORD *)v70 + 1)
                     - (v516.i32[0] | (((*((_DWORD *)v70 + 1) & 0x3FF) * v514
                                      + (((*((_DWORD *)v70 + 1) & 0x3FF) * v514) >> 8)
                                      + 1) >> 8) | v516.i32[1])
                     + 0x40000000;
                int8x8_t v518 = (int8x8_t)vshl_u32(vmin_u32((uint32x2_t)vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v517), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003)), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
                int8x8_t v519 = (int8x8_t)vdup_lane_s32((int32x2_t)v518, 1);
                if ((v517 & 0x3FF) + (*v33 & 0x3FF) >= 0x3FF) {
                  int v520 = 1023;
                }
                else {
                  int v520 = (v517 & 0x3FF) + (*v33 & 0x3FF);
                }
                unsigned int *v33 = vorr_s8(v518, v519).u32[0] | v520 | 0xC0000000;
              }
            }
            ++v71;
            v70 += 8;
            uint32x2_t v165 = (int *)((char *)v165 + v307);
            ++v33;
            --v513;
          }
          while (v513);
        }
        goto LABEL_543;
      case 13:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v323 = v44 != 0;
        int v324 = v74;
        unsigned int v325 = v44;
        do
        {
          int v326 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v326 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v326
                                                            + ((*(unsigned __int8 *)v325 * v326) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v328 = *(void *)v70 * v326
                   + ((*(void *)v70 * v326) >> 8)
                   + 1;
              if (BYTE1(v328))
              {
                unint64_t v327 = *(void *)v70;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v329 = PDAmultiplyPDA(*v33, *v31, (((WORD2(v327) & 0x3FF) * v326 + (((WORD2(v327) & 0x3FFu) * v326) >> 8) + 1) >> 8) | (4 * (((v327 >> 42) & 0x3FF) * v326 + ((((v327 >> 42) & 0x3FF) * v326) >> 8)) + 4) & 0xFC00, BYTE1(v328));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v329 = (v328 >> 8) | (((((((v327 >> 52) & 0x3FF) * v326 + ((((v327 >> 52) & 0x3FF) * v326) >> 8)) << 12)
                                          + 4096) & 0x3FF00000 | (((WORD2(v327) & 0x3FF) * v326
                                                                 + (((WORD2(v327) & 0x3FFu) * v326) >> 8)
                                                                 + 1) >> 8) | (4
                                                                             * (((v327 >> 42) & 0x3FF) * v326
                                                                              + ((((v327 >> 42) & 0x3FF) * v326) >> 8))
                                                                             + 4) & 0xFFC00 | 0xC0000000) << 32);
                  }
                  unsigned int *v33 = HIDWORD(v329);
                  *unint64_t v31 = v329;
                }
                else
                {
                  unint64_t v330 = PDAmultiplyPDA(*v33, 255, (((WORD2(v327) & 0x3FF) * v326 + (((WORD2(v327) & 0x3FFu) * v326) >> 8) + 1) >> 8) | (4 * (((v327 >> 42) & 0x3FF) * v326 + ((((v327 >> 42) & 0x3FF) * v326) >> 8)) + 4) & 0xFC00, BYTE1(v328));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v330);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v323);
          ++v33;
          v31 += v75;
          --v324;
        }
        while (v324);
        goto LABEL_429;
      case 14:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v331 = v44 != 0;
        int v332 = v74;
        unsigned int v325 = v44;
        do
        {
          int v333 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v333 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v333
                                                            + ((*(unsigned __int8 *)v325 * v333) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v335 = *(void *)v70 * v333
                   + ((*(void *)v70 * v333) >> 8)
                   + 1;
              if (BYTE1(v335))
              {
                unint64_t v334 = *(void *)v70;
                unint64_t v336 = (((((v334 >> 52) & 0x3FF) * v333 + ((((v334 >> 52) & 0x3FF) * v333) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v334) & 0x3FF) * v333 + (((WORD2(v334) & 0x3FFu) * v333) >> 8) + 1) >> 8) | (4 * (((v334 >> 42) & 0x3FF) * v333 + ((((v334 >> 42) & 0x3FF) * v333) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v337 = PDAscreenPDA(*v33, *v31, v336, BYTE1(v335));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v337 = (v335 >> 8) | (v336 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v337);
                  *unint64_t v31 = v337;
                }
                else
                {
                  unint64_t v338 = PDAscreenPDA(*v33, 255, v336, BYTE1(v335));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v338);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v331);
          ++v33;
          v31 += v75;
          --v332;
        }
        while (v332);
        goto LABEL_429;
      case 15:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v339 = v44 != 0;
        int v340 = v74;
        unsigned int v325 = v44;
        do
        {
          int v341 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v341 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v341
                                                            + ((*(unsigned __int8 *)v325 * v341) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v343 = *(void *)v70 * v341
                   + ((*(void *)v70 * v341) >> 8)
                   + 1;
              if (BYTE1(v343))
              {
                unint64_t v342 = *(void *)v70;
                unint64_t v344 = (((((v342 >> 52) & 0x3FF) * v341 + ((((v342 >> 52) & 0x3FF) * v341) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v342) & 0x3FF) * v341 + (((WORD2(v342) & 0x3FFu) * v341) >> 8) + 1) >> 8) | (4 * (((v342 >> 42) & 0x3FF) * v341 + ((((v342 >> 42) & 0x3FF) * v341) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v345 = PDAoverlayPDA(*v33, *v31, v344, BYTE1(v343));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v345 = (v343 >> 8) | (v344 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v345);
                  *unint64_t v31 = v345;
                }
                else
                {
                  unint64_t v346 = PDAoverlayPDA(*v33, 255, v344, BYTE1(v343));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v346);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v339);
          ++v33;
          v31 += v75;
          --v340;
        }
        while (v340);
        goto LABEL_429;
      case 16:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v347 = v44 != 0;
        int v348 = v74;
        unsigned int v325 = v44;
        do
        {
          int v349 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v349 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v349
                                                            + ((*(unsigned __int8 *)v325 * v349) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v351 = *(void *)v70 * v349
                   + ((*(void *)v70 * v349) >> 8)
                   + 1;
              if (BYTE1(v351))
              {
                unint64_t v350 = *(void *)v70;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v352 = PDAdarkenPDA(*v33, *v31, (((WORD2(v350) & 0x3FF) * v349 + (((WORD2(v350) & 0x3FFu) * v349) >> 8) + 1) >> 8) | (4 * (((v350 >> 42) & 0x3FF) * v349 + ((((v350 >> 42) & 0x3FF) * v349) >> 8)) + 4) & 0xFC00, BYTE1(v351));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v352 = (v351 >> 8) | (((((((v350 >> 52) & 0x3FF) * v349 + ((((v350 >> 52) & 0x3FF) * v349) >> 8)) << 12)
                                          + 4096) & 0x3FF00000 | (((WORD2(v350) & 0x3FF) * v349
                                                                 + (((WORD2(v350) & 0x3FFu) * v349) >> 8)
                                                                 + 1) >> 8) | (4
                                                                             * (((v350 >> 42) & 0x3FF) * v349
                                                                              + ((((v350 >> 42) & 0x3FF) * v349) >> 8))
                                                                             + 4) & 0xFFC00 | 0xC0000000) << 32);
                  }
                  unsigned int *v33 = HIDWORD(v352);
                  *unint64_t v31 = v352;
                }
                else
                {
                  unint64_t v353 = PDAdarkenPDA(*v33, 0xFFu, (((WORD2(v350) & 0x3FF) * v349 + (((WORD2(v350) & 0x3FFu) * v349) >> 8) + 1) >> 8) | (4 * (((v350 >> 42) & 0x3FF) * v349 + ((((v350 >> 42) & 0x3FF) * v349) >> 8)) + 4) & 0xFC00, BYTE1(v351));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v353);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v347);
          ++v33;
          v31 += v75;
          --v348;
        }
        while (v348);
        goto LABEL_429;
      case 17:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v354 = v44 != 0;
        int v355 = v74;
        unsigned int v325 = v44;
        do
        {
          int v356 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v356 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v356
                                                            + ((*(unsigned __int8 *)v325 * v356) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v358 = *(void *)v70 * v356
                   + ((*(void *)v70 * v356) >> 8)
                   + 1;
              if (BYTE1(v358))
              {
                unint64_t v357 = *(void *)v70;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v359 = PDAlightenPDA(*v33, *v31, (((WORD2(v357) & 0x3FF) * v356 + (((WORD2(v357) & 0x3FFu) * v356) >> 8) + 1) >> 8) | (4 * (((v357 >> 42) & 0x3FF) * v356 + ((((v357 >> 42) & 0x3FF) * v356) >> 8)) + 4) & 0xFC00, BYTE1(v358));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v359 = (v358 >> 8) | (((((((v357 >> 52) & 0x3FF) * v356 + ((((v357 >> 52) & 0x3FF) * v356) >> 8)) << 12)
                                          + 4096) & 0x3FF00000 | (((WORD2(v357) & 0x3FF) * v356
                                                                 + (((WORD2(v357) & 0x3FFu) * v356) >> 8)
                                                                 + 1) >> 8) | (4
                                                                             * (((v357 >> 42) & 0x3FF) * v356
                                                                              + ((((v357 >> 42) & 0x3FF) * v356) >> 8))
                                                                             + 4) & 0xFFC00 | 0xC0000000) << 32);
                  }
                  unsigned int *v33 = HIDWORD(v359);
                  *unint64_t v31 = v359;
                }
                else
                {
                  unint64_t v360 = PDAlightenPDA(*v33, 0xFFu, (((WORD2(v357) & 0x3FF) * v356 + (((WORD2(v357) & 0x3FFu) * v356) >> 8) + 1) >> 8) | (4 * (((v357 >> 42) & 0x3FF) * v356 + ((((v357 >> 42) & 0x3FF) * v356) >> 8)) + 4) & 0xFC00, BYTE1(v358));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v360);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v354);
          ++v33;
          v31 += v75;
          --v355;
        }
        while (v355);
        goto LABEL_429;
      case 18:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v361 = v44 != 0;
        int v362 = v74;
        unsigned int v325 = v44;
        do
        {
          int v363 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v363 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v363
                                                            + ((*(unsigned __int8 *)v325 * v363) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v365 = *(void *)v70 * v363
                   + ((*(void *)v70 * v363) >> 8)
                   + 1;
              if (BYTE1(v365))
              {
                unint64_t v364 = *(void *)v70;
                unint64_t v366 = (((((v364 >> 52) & 0x3FF) * v363 + ((((v364 >> 52) & 0x3FF) * v363) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v364) & 0x3FF) * v363 + (((WORD2(v364) & 0x3FFu) * v363) >> 8) + 1) >> 8) | (4 * (((v364 >> 42) & 0x3FF) * v363 + ((((v364 >> 42) & 0x3FF) * v363) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v367 = PDAcolordodgePDA(*v33, *v31, v366, BYTE1(v365));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v367 = (v365 >> 8) | (v366 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v367);
                  *unint64_t v31 = v367;
                }
                else
                {
                  unint64_t v368 = PDAcolordodgePDA(*v33, 255, v366, BYTE1(v365));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v368);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v361);
          ++v33;
          v31 += v75;
          --v362;
        }
        while (v362);
        goto LABEL_429;
      case 19:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v369 = v44 != 0;
        int v370 = v74;
        unsigned int v325 = v44;
        do
        {
          int v371 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v371 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v371
                                                            + ((*(unsigned __int8 *)v325 * v371) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v373 = *(void *)v70 * v371
                   + ((*(void *)v70 * v371) >> 8)
                   + 1;
              if (BYTE1(v373))
              {
                unint64_t v372 = *(void *)v70;
                unint64_t v374 = (((((v372 >> 52) & 0x3FF) * v371 + ((((v372 >> 52) & 0x3FF) * v371) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v372) & 0x3FF) * v371 + (((WORD2(v372) & 0x3FFu) * v371) >> 8) + 1) >> 8) | (4 * (((v372 >> 42) & 0x3FF) * v371 + ((((v372 >> 42) & 0x3FF) * v371) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v375 = PDAcolorburnPDA(*v33, *v31, v374, BYTE1(v373));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v375 = (v373 >> 8) | (v374 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v375);
                  *unint64_t v31 = v375;
                }
                else
                {
                  unint64_t v376 = PDAcolorburnPDA(*v33, 255, v374, BYTE1(v373));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v376);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v369);
          ++v33;
          v31 += v75;
          --v370;
        }
        while (v370);
        goto LABEL_429;
      case 20:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v377 = v44 != 0;
        int v378 = v74;
        unsigned int v325 = v44;
        do
        {
          int v379 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v379 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v379
                                                            + ((*(unsigned __int8 *)v325 * v379) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v381 = *(void *)v70 * v379
                   + ((*(void *)v70 * v379) >> 8)
                   + 1;
              if (BYTE1(v381))
              {
                unint64_t v380 = *(void *)v70;
                unint64_t v382 = (((((v380 >> 52) & 0x3FF) * v379 + ((((v380 >> 52) & 0x3FF) * v379) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v380) & 0x3FF) * v379 + (((WORD2(v380) & 0x3FFu) * v379) >> 8) + 1) >> 8) | (4 * (((v380 >> 42) & 0x3FF) * v379 + ((((v380 >> 42) & 0x3FF) * v379) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v383 = PDAsoftlightPDA(*v33, *v31, v382, BYTE1(v381));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v383 = (v381 >> 8) | (v382 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v383);
                  *unint64_t v31 = v383;
                }
                else
                {
                  unint64_t v384 = PDAsoftlightPDA(*v33, 255, v382, BYTE1(v381));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v384);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v377);
          ++v33;
          v31 += v75;
          --v378;
        }
        while (v378);
        goto LABEL_429;
      case 21:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v385 = v44 != 0;
        int v386 = v74;
        unsigned int v325 = v44;
        do
        {
          int v387 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v387 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v387
                                                            + ((*(unsigned __int8 *)v325 * v387) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v389 = *(void *)v70 * v387
                   + ((*(void *)v70 * v387) >> 8)
                   + 1;
              if (BYTE1(v389))
              {
                unint64_t v388 = *(void *)v70;
                unint64_t v390 = (((((v388 >> 52) & 0x3FF) * v387 + ((((v388 >> 52) & 0x3FF) * v387) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v388) & 0x3FF) * v387 + (((WORD2(v388) & 0x3FFu) * v387) >> 8) + 1) >> 8) | (4 * (((v388 >> 42) & 0x3FF) * v387 + ((((v388 >> 42) & 0x3FF) * v387) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v391 = PDAhardlightPDA(*v33, *v31, v390, BYTE1(v389));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v391 = (v389 >> 8) | (v390 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v391);
                  *unint64_t v31 = v391;
                }
                else
                {
                  unint64_t v392 = PDAhardlightPDA(*v33, 255, v390, BYTE1(v389));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v392);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v385);
          ++v33;
          v31 += v75;
          --v386;
        }
        while (v386);
        goto LABEL_429;
      case 22:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v393 = v44 != 0;
        int v394 = v74;
        unsigned int v325 = v44;
        do
        {
          int v395 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v395 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v395
                                                            + ((*(unsigned __int8 *)v325 * v395) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v397 = *(void *)v70 * v395
                   + ((*(void *)v70 * v395) >> 8)
                   + 1;
              if (BYTE1(v397))
              {
                unint64_t v396 = *(void *)v70;
                unint64_t v398 = (((((v396 >> 52) & 0x3FF) * v395 + ((((v396 >> 52) & 0x3FF) * v395) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v396) & 0x3FF) * v395 + (((WORD2(v396) & 0x3FFu) * v395) >> 8) + 1) >> 8) | (4 * (((v396 >> 42) & 0x3FF) * v395 + ((((v396 >> 42) & 0x3FF) * v395) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v399 = PDAdifferencePDA(*v33, *v31, v398, BYTE1(v397));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v399 = (v397 >> 8) | (v398 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v399);
                  *unint64_t v31 = v399;
                }
                else
                {
                  unint64_t v400 = PDAdifferencePDA(*v33, 0xFFu, v398, BYTE1(v397));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v400);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v393);
          ++v33;
          v31 += v75;
          --v394;
        }
        while (v394);
        goto LABEL_429;
      case 23:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v401 = v44 != 0;
        int v402 = v74;
        unsigned int v325 = v44;
        do
        {
          int v403 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v403 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v403
                                                            + ((*(unsigned __int8 *)v325 * v403) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v405 = *(void *)v70 * v403
                   + ((*(void *)v70 * v403) >> 8)
                   + 1;
              if (BYTE1(v405))
              {
                unint64_t v404 = *(void *)v70;
                unint64_t v406 = (((((v404 >> 52) & 0x3FF) * v403 + ((((v404 >> 52) & 0x3FF) * v403) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v404) & 0x3FF) * v403 + (((WORD2(v404) & 0x3FFu) * v403) >> 8) + 1) >> 8) | (4 * (((v404 >> 42) & 0x3FF) * v403 + ((((v404 >> 42) & 0x3FF) * v403) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v407 = PDAexclusionPDA(*v33, *v31, v406, BYTE1(v405));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v407 = (v405 >> 8) | (v406 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v407);
                  *unint64_t v31 = v407;
                }
                else
                {
                  unint64_t v408 = PDAexclusionPDA(*v33, 255, v406, BYTE1(v405));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v408);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v401);
          ++v33;
          v31 += v75;
          --v402;
        }
        while (v402);
        goto LABEL_429;
      case 24:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v409 = v44 != 0;
        int v410 = v74;
        unsigned int v325 = v44;
        do
        {
          int v411 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v411 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v411
                                                            + ((*(unsigned __int8 *)v325 * v411) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v413 = *(void *)v70 * v411
                   + ((*(void *)v70 * v411) >> 8)
                   + 1;
              if (BYTE1(v413))
              {
                unint64_t v412 = *(void *)v70;
                unint64_t v414 = (((((v412 >> 52) & 0x3FF) * v411 + ((((v412 >> 52) & 0x3FF) * v411) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v412) & 0x3FF) * v411 + (((WORD2(v412) & 0x3FFu) * v411) >> 8) + 1) >> 8) | (4 * (((v412 >> 42) & 0x3FF) * v411 + ((((v412 >> 42) & 0x3FF) * v411) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v415 = PDAhuePDA(*v33, *v31, v414, BYTE1(v413));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v415 = (v413 >> 8) | (v414 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v415);
                  *unint64_t v31 = v415;
                }
                else
                {
                  unint64_t v416 = PDAhuePDA(*v33, 255, v414, BYTE1(v413));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v416);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v409);
          ++v33;
          v31 += v75;
          --v410;
        }
        while (v410);
        goto LABEL_429;
      case 25:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v417 = v44 != 0;
        int v418 = v74;
        unsigned int v325 = v44;
        do
        {
          int v419 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v419 = ((unsigned __int16)(*(unsigned __int8 *)v325 * (_WORD)v419
                                                            + ((*(unsigned __int8 *)v325 * v419) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v421 = *(void *)v70 * v419
                   + ((*(void *)v70 * v419) >> 8)
                   + 1;
              if (BYTE1(v421))
              {
                unint64_t v420 = *(void *)v70;
                unint64_t v422 = (((((v420 >> 52) & 0x3FF) * v419 + ((((v420 >> 52) & 0x3FF) * v419) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v420) & 0x3FF) * v419 + (((WORD2(v420) & 0x3FFu) * v419) >> 8) + 1) >> 8) | (4 * (((v420 >> 42) & 0x3FF) * v419 + ((((v420 >> 42) & 0x3FF) * v419) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v423 = PDAsaturationPDA(*v33, *v31, v422, BYTE1(v421));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v423 = (v421 >> 8) | (v422 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v423);
                  *unint64_t v31 = v423;
                }
                else
                {
                  unint64_t v424 = PDAsaturationPDA(*v33, 255, v422, BYTE1(v421));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v424);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          unsigned int v325 = (int *)((char *)v325 + v417);
          ++v33;
          v31 += v75;
          --v418;
        }
        while (v418);
LABEL_429:
        uint64_t v44 = (int *)((char *)v325 + v592);
        goto LABEL_430;
      case 26:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v425 = v44 != 0;
        int v426 = v74;
        int v427 = v44;
        do
        {
          int v428 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v428 = ((unsigned __int16)(*(unsigned __int8 *)v427 * (_WORD)v428
                                                            + ((*(unsigned __int8 *)v427 * v428) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v430 = *(void *)v70 * v428
                   + ((*(void *)v70 * v428) >> 8)
                   + 1;
              if (BYTE1(v430))
              {
                unint64_t v429 = *(void *)v70;
                unint64_t v431 = (((((v429 >> 52) & 0x3FF) * v428 + ((((v429 >> 52) & 0x3FF) * v428) >> 8)) << 12) + 4096) & 0x3FF00000 | (((WORD2(v429) & 0x3FF) * v428 + (((WORD2(v429) & 0x3FFu) * v428) >> 8) + 1) >> 8) | (4 * (((v429 >> 42) & 0x3FF) * v428 + ((((v429 >> 42) & 0x3FF) * v428) >> 8)) + 4) & 0xFFC00 | 0xC0000000;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v432 = PDAluminosityPDA(v431, BYTE1(v430), *v33, *v31);
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v432 = (v430 >> 8) | (v431 << 32);
                  }
                  unsigned int *v33 = HIDWORD(v432);
                  *unint64_t v31 = v432;
                }
                else
                {
                  unint64_t v433 = PDAluminosityPDA(v431, BYTE1(v430), *v33, 0xFFu);
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v433);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          int v427 = (int *)((char *)v427 + v425);
          ++v33;
          v31 += v75;
          --v426;
        }
        while (v426);
        uint64_t v44 = (int *)((char *)v427 + v592);
        v33 += v593;
        v31 += v594;
        int v37 = v590;
        int8x8_t v38 = v591;
        goto LABEL_431;
      case 27:
        int v320 = v42;
        int v321 = v41;
        float32x2_t v322 = v40;
        BOOL v434 = v44 != 0;
        uint64_t v435 = v44;
        int v436 = v74;
        do
        {
          int v437 = *v71;
          if (*v71)
          {
            if (!v44
              || (int v437 = ((unsigned __int16)(*(unsigned __int8 *)v435 * (_WORD)v437
                                                            + ((*(unsigned __int8 *)v435 * v437) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v439 = *(void *)v70 * v437
                   + ((*(void *)v70 * v437) >> 8)
                   + 1;
              if (BYTE1(v439))
              {
                unint64_t v438 = *(void *)v70;
                if (v601)
                {
                  if (*v31)
                  {
                    unint64_t v440 = PDAluminosityPDA(*v33, *v31, (((WORD2(v438) & 0x3FF) * v437 + (((WORD2(v438) & 0x3FFu) * v437) >> 8) + 1) >> 8) | (4 * (((v438 >> 42) & 0x3FF) * v437 + ((((v438 >> 42) & 0x3FF) * v437) >> 8)) + 4) & 0xFC00, BYTE1(v439));
                    uint64_t v75 = v603;
                    uint64_t v44 = v604;
                  }
                  else
                  {
                    unint64_t v440 = (v439 >> 8) | (((((((v438 >> 52) & 0x3FF) * v437 + ((((v438 >> 52) & 0x3FF) * v437) >> 8)) << 12)
                                          + 4096) & 0x3FF00000 | (((WORD2(v438) & 0x3FF) * v437
                                                                 + (((WORD2(v438) & 0x3FFu) * v437) >> 8)
                                                                 + 1) >> 8) | (4
                                                                             * (((v438 >> 42) & 0x3FF) * v437
                                                                              + ((((v438 >> 42) & 0x3FF) * v437) >> 8))
                                                                             + 4) & 0xFFC00 | 0xC0000000) << 32);
                  }
                  unsigned int *v33 = HIDWORD(v440);
                  *unint64_t v31 = v440;
                }
                else
                {
                  unint64_t v441 = PDAluminosityPDA(*v33, 0xFFu, (((WORD2(v438) & 0x3FF) * v437 + (((WORD2(v438) & 0x3FFu) * v437) >> 8) + 1) >> 8) | (4 * (((v438 >> 42) & 0x3FF) * v437 + ((((v438 >> 42) & 0x3FF) * v437) >> 8)) + 4) & 0xFC00, BYTE1(v439));
                  uint64_t v75 = v603;
                  uint64_t v44 = v604;
                  unsigned int *v33 = HIDWORD(v441);
                }
              }
            }
          }
          ++v71;
          v70 += 8;
          uint64_t v435 = (int *)((char *)v435 + v434);
          ++v33;
          v31 += v75;
          --v436;
        }
        while (v436);
        uint64_t v44 = (int *)((char *)v435 + v592);
LABEL_430:
        v33 += v593;
        v31 += v594;
        int v37 = v590;
        int8x8_t v38 = v591;
LABEL_431:
        float32x2_t v120 = v597;
        float32x2_t v40 = v322;
        int v110 = v596;
        uint64_t v41 = v321;
        int v42 = v320;
        goto LABEL_546;
      default:
        goto LABEL_544;
    }
    break;
  }
  while (1)
  {
    unsigned int v255 = *v71;
    if (*v71)
    {
      if (!v44) {
        goto LABEL_211;
      }
      unsigned int v256 = *(unsigned __int8 *)v165 * v255 + ((*(unsigned __int8 *)v165 * v255) >> 8) + 1;
      if (BYTE1(v256)) {
        break;
      }
    }
LABEL_216:
    ++v71;
    v70 += 8;
    uint32x2_t v165 = (int *)((char *)v165 + (v44 != 0));
    ++v33;
    v31 += v75;
    if (!--v254)
    {
LABEL_543:
      uint64_t v44 = (int *)((char *)v165 + v592);
      v33 += v593;
      v31 += v594;
LABEL_544:
      float32x2_t v120 = v597;
      goto LABEL_545;
    }
  }
  unsigned int v255 = v256 >> 8;
LABEL_211:
  int v257 = *v31;
  unsigned int v258 = *(void *)v70 * v255;
  unsigned int v259 = v258 + (v258 >> 8) + 1;
  unsigned int v260 = ((*(void *)v70 >> 52) & 0x3FF) * v255;
  __int32 v261 = v260 >> 8;
  unsigned int v262 = v260 + 1;
  unsigned int v263 = ((*(void *)v70 >> 42) & 0x3FF) * v255;
  unsigned int v264 = (HIDWORD(*(void *)v70) & 0x3FF) * v255;
  unsigned int v265 = (v264 + (v264 >> 8) + 1) >> 8;
  unsigned int v266 = v257 ^ 0xFF;
  unsigned int v267 = (~(_BYTE)v255 + BYTE1(v259));
  unsigned int v268 = ((v267 * v257 + ((v267 * v257) >> 8) + 1) >> 8) + (((v259 >> 8) * v266 + (((v259 >> 8) * v266) >> 8) + 1) >> 8);
  if (v268 >= 0xFF) {
    LOBYTE(v268) = -1;
  }
  unsigned int v269 = (((*v33 & 0x3FF) * v267 + (((*v33 & 0x3FF) * v267) >> 8) + 1) >> 8)
       + ((v265 * v266 + ((v265 * v266) >> 8) + 1) >> 8);
  if (v269 >= 0x3FF) {
    unsigned int v269 = 1023;
  }
  v270.i32[0] = 1;
  v270.i32[1] = v261;
  int32x2_t v271 = vadd_s32((int32x2_t)__PAIR64__(v262, v263), v270);
  v270.i32[0] = vshl_n_s32(vadd_s32(v271, (int32x2_t)((v263 >> 8) | 0xC00000000)), 2uLL).u32[0];
  v270.i32[1] = vand_s8((int8x8_t)vshl_n_s32(v271, 0xCuLL), _D0).i32[1];
  uint32x2_t v272 = (uint32x2_t)vmul_s32((int32x2_t)vshl_u32((uint32x2_t)vorr_s8((int8x8_t)vdup_n_s32(v265), (int8x8_t)v270), (uint32x2_t)0xFFFFFFECFFFFFFF6), vdup_n_s32(v266));
  uint32x2_t v273 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v33), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003), vdup_n_s32(v267));
  int8x8_t v274 = (int8x8_t)vshl_u32(vmin_u32(vsra_n_u32(vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v272, v272, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v273, v273, 8uLL), (int32x2_t)0x100000001), 8uLL), (uint32x2_t)0x300000003), (uint32x2_t)0x140000000ALL);
  unsigned int *v33 = vorr_s8(v274, (int8x8_t)vdup_lane_s32((int32x2_t)v274, 1)).u32[0] | v269 | 0xC0000000;
  *unint64_t v31 = v268;
  goto LABEL_216;
}

unint64_t *RGBAf16(unint64_t *result, float16x4_t a2, __n128 a3, __n128 _Q2, __n128 _Q3)
{
  __asm { FCVT            S3, H3 }
  float v10 = (float)(_S3 * 255.0) + 0.5;
  float v11 = 0.0;
  if (v10 >= 0.0) {
    float v11 = v10;
  }
  if (v10 <= 255.0) {
    float v12 = v11;
  }
  else {
    float v12 = 255.0;
  }
  LODWORD(v13) = v12;
  if (v12 >= 0xFF) {
    uint64_t v13 = 255;
  }
  else {
    uint64_t v13 = v13;
  }
  a2.i16[1] = a3.n128_u16[0];
  __asm { FMOV            V1.2D, #0.5 }
  _D0 = (int32x2_t)vshl_u32(vmin_u32((uint32x2_t)vmovn_s64((int64x2_t)vcvtq_u64_f64(vaddq_f64(vcvtq_f64_f32(vmla_f32((float32x2_t)vdup_n_s32(0x43C00000u), (float32x2_t)vdup_n_s32(0x43FF8000u), (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a2))), _Q1))), (uint32x2_t)0x300000003), (uint32x2_t)0xA00000014);
  unsigned __int32 v16 = vorr_s8((int8x8_t)_D0, (int8x8_t)vdup_lane_s32(_D0, 1)).u32[0];
  __asm { FCVT            S0, H2 }
  unsigned int v17 = ((float)((float)(*(float *)_D0.i32 * 511.0) + 384.0) + 0.5);
  if (v17 >= 0x3FF) {
    unsigned int v17 = 1023;
  }
  *CGColorSpaceRef result = v13 | ((unint64_t)(v16 | v17) << 32) | 0xC000000000000000;
  return result;
}

uint64_t CIF10_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  BOOL v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v15, (uint64_t)v27) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x3000000)
  {
    if (*(void *)(v5 + 16))
    {
      float v12 = CIF10_shade_radial_RGB;
    }
    else if (*(void *)(v5 + 24))
    {
      float v12 = CIF10_shade_conic_RGB;
    }
    else if (v21 < 2)
    {
      float v12 = CIF10_shade_axial_RGB;
    }
    else
    {
      float v12 = CIF10_shade_custom_RGB;
    }
    float32x2_t v15 = (float32x2_t)v12;
    if (v25)
    {
      unint64_t v24 = v30;
      _blt_shade_samples_16((uint64_t)v30, 2, 3, v25, v26, 1uLL);
    }
    unint64_t v13 = v21 * v20;
    if (v21 * v20 <= 480)
    {
      uint64_t v14 = v28;
      uint64_t v22 = v28;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v14, 2, 3, v18, v19, v13);
      if (*(unsigned char *)(v5 + 1)) {
        float v23 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    uint64_t v14 = malloc_type_malloc(8 * v13 + 32, 0xA5C3E662uLL);
    if (v14)
    {
      uint64_t v22 = v14;
      unint64_t v13 = v21 * v20;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v15) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  int v16 = *v7;
  int v17 = v16;
  CIF10_image_mark(v6, &v15, v9, v11);
  if (v22 && (v22 < v28 || &v29 < v22)) {
    free(v22);
  }
  return 1;
}

void CIF10_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  float v6 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
             + (float)(v5 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  uint64_t v7 = a1 + 368;
  uint64_t v8 = *(void *)(a1 + 368);
  uint64_t v9 = ((unint64_t)a3 >> 4) & 0xF0;
  uint64_t v10 = v8 + v9;
  if (v8) {
    uint64_t v11 = v8 + v9;
  }
  else {
    uint64_t v11 = a1 + 368;
  }
  if (v8) {
    char v12 = 15;
  }
  else {
    char v12 = 0;
  }
  float v14 = *(float *)(a1 + 336);
  float v15 = *(float *)(a1 + 344);
  float v16 = *(float *)(a1 + 304);
  float v17 = *(float *)(a1 + 308);
  int v18 = *(_DWORD *)(a1 + 320);
  int v19 = *(_DWORD *)(a1 + 324);
  uint64_t v22 = a1 + 144;
  uint64_t v20 = *(_DWORD **)(a1 + 144);
  uint64_t v21 = *(int8x16_t **)(v22 + 8);
  float v23 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v24 = *(void *)(a1 + 360);
  if (v5 != 0.0)
  {
    if (v8) {
      unsigned int v30 = (a2 >> 8) & 0xF;
    }
    else {
      LOBYTE(v30) = 0;
    }
    while (1)
    {
      int v31 = v18;
      if (v6 >= v16)
      {
        int v31 = v19;
        if (v6 <= v17) {
          int v31 = (int)(float)(v15 * (float)(v6 - v14));
        }
      }
      if (v31 < 0)
      {
        if (!v23)
        {
          char v40 = 0;
          goto LABEL_40;
        }
        int v39 = *(unsigned __int8 *)(v11 + v30);
        int v36 = v39 + *v23;
        int v37 = v39 + v23[1];
        unsigned __int16 v38 = v39 + v23[2];
        LOWORD(v39) = v39 + v23[3];
      }
      else
      {
        uint64_t v32 = (unsigned __int16 *)(v24 + 8 * v31);
        int v33 = v32[1];
        int v39 = *(unsigned __int8 *)(v11 + v30);
        unsigned __int16 v34 = v32[2];
        unsigned __int16 v35 = v32[3];
        int v36 = v39 + *v32;
        int v37 = v39 + v33;
        unsigned __int16 v38 = v39 + v34;
        LOBYTE(v39) = v39 + v35;
      }
      v21->i64[0] = v39 | ((unint64_t)((v36 << 14) & 0x3FF00000 | (16 * v37) & 0xFFC00 | (v38 >> 6)) << 32);
      char v40 = -1;
LABEL_40:
      LOBYTE(v30) = (v30 + 1) & v12;
      float v6 = v5 + v6;
      uint64_t v21 = (int8x16_t *)((char *)v21 + 8);
      *(unsigned char *)uint64_t v20 = v40;
      uint64_t v20 = (_DWORD *)((char *)v20 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v8) {
    uint64_t v25 = v10;
  }
  else {
    uint64_t v25 = v7;
  }
  if (v8) {
    LODWORD(v26) = ((a2 >> 8) + 1) & 0xF;
  }
  else {
    LODWORD(v26) = 0;
  }
  if (v8) {
    LODWORD(v27) = (a2 >> 8) & 0xF;
  }
  else {
    LODWORD(v27) = 0;
  }
  if (v8) {
    int v28 = 15;
  }
  else {
    int v28 = 0;
  }
  if (v6 >= v16)
  {
    int v18 = v19;
    if (v6 <= v17) {
      int v18 = (int)(float)(v15 * (float)(v6 - v14));
    }
  }
  if ((v18 & 0x80000000) == 0 || v23)
  {
    uint64_t v41 = (unsigned __int16 *)(v24 + 8 * v18);
    if (v18 >= 0) {
      float v23 = v41;
    }
    unsigned int v42 = v23[3];
    unsigned int v43 = v23[2];
    v45.i32[0] = *v23;
    __int32 v44 = v23[1];
    v45.i32[1] = v44;
    if (v8)
    {
      int32x2_t v46 = vdup_n_s32(v43);
      int32x2_t v47 = vdup_n_s32(v42);
      int32x2_t v48 = vrev64_s32(v45);
      int v49 = a4 + 4;
      do
      {
        v4.i8[0] = *(unsigned char *)(v25 + v27);
        uint64_t v27 = (v27 + 1) & v28;
        v4.i8[4] = *(unsigned char *)(v25 + v26);
        int32x2_t v50 = (int32x2_t)vand_s8(*(int8x8_t *)v4.i8, (int8x8_t)0xFF000000FFLL);
        int8x8_t v51 = vand_s8((int8x8_t)vadd_s32(v47, *(int32x2_t *)v4.i8), (int8x8_t)0xFF000000FFLL);
        v52.i64[0] = v51.u32[0];
        v52.i64[1] = v51.u32[1];
        int8x16_t v53 = vorrq_s8((int8x16_t)vshll_n_s32((int32x2_t)vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v50, v45), (uint32x2_t)0x40000000ELL), (int8x8_t)0xFFC003FF00000), vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v48, v50), (uint32x2_t)0xE00000004), (int8x8_t)0x3FF00000000FFC00)), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v46, v50), 6uLL) & 0xFFFFFBFFFFFFFBFFLL)), 0x20uLL), v52);
        int8x16_t *v21 = v53;
        uint64_t v26 = (v26 + 1) & v28;
        v53.i8[0] = *(unsigned char *)(v25 + v27);
        v53.i8[4] = *(unsigned char *)(v25 + v26);
        int32x2_t v54 = (int32x2_t)vand_s8(*(int8x8_t *)v53.i8, (int8x8_t)0xFF000000FFLL);
        *(int8x8_t *)v53.i8 = vand_s8((int8x8_t)vadd_s32(v47, *(int32x2_t *)v53.i8), (int8x8_t)0xFF000000FFLL);
        v52.i64[0] = v53.u32[0];
        v52.i64[1] = v53.u32[1];
        *v20++ = -1;
        v49 -= 4;
        int8x16_t v4 = vorrq_s8((int8x16_t)vshll_n_s32((int32x2_t)vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v54, v45), (uint32x2_t)0x40000000ELL), (int8x8_t)0xFFC003FF00000), vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v48, v54), (uint32x2_t)0xE00000004), (int8x8_t)0x3FF00000000FFC00)), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v46, v54), 6uLL) & 0xFFFFFBFFFFFFFBFFLL)), 0x20uLL), v52);
        v21[1] = v4;
        v21 += 2;
      }
      while (v49 > 4);
    }
    else
    {
      unint64_t v55 = v42 | ((unint64_t)((v43 >> 6) & 0xC00003FF | ((unsigned __int16)v45.i16[0] >> 6 << 20) | ((unsigned __int16)v44 >> 6 << 10)) << 32);
      int v56 = a4 + 4;
      do
      {
        v21->i64[0] = v55;
        v21->i64[1] = v55;
        v21[1].i64[0] = v55;
        v21[1].i64[1] = v55;
        v56 -= 4;
        v21 += 2;
        *v20++ = -1;
      }
      while (v56 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v29 = 4;
    }
    else {
      int v29 = a4;
    }
    bzero(v20, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t CIF10_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(result + 280);
  float v5 = *(float *)(*(void *)(result + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = result + 368;
  uint64_t v10 = *(void *)(result + 368);
  int v11 = 15;
  if (v10) {
    uint64_t v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(result + 284);
  float v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  float v14 = *(float *)(result + 304);
  float v15 = *(float *)(result + 308);
  float v16 = *(float *)(result + 312);
  float v17 = *(float *)(result + 316);
  float v18 = *(float *)(result + 336);
  float v19 = *(float *)(result + 348);
  float v20 = *(float *)(result + 344);
  float v21 = *(float *)(result + 356);
  uint64_t v22 = *(unsigned __int16 **)(result + 376);
  uint64_t v23 = *(void *)(result + 360);
  int v24 = 4 * *(_DWORD *)(result + 48);
  if (v10) {
    uint64_t v25 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v25 = 0;
  }
  uint64_t v27 = *(char **)(result + 144);
  uint64_t v26 = *(unint64_t **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      unsigned __int16 v34 = (unsigned __int16 *)(v23
                               + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19))
                               + 8 * (int)(float)(v20 * (float)(v8 - v18)));
      int v35 = v34[1];
      int v33 = *(unsigned __int8 *)(v9 + v25);
      int v36 = v34[2];
      unsigned __int16 v37 = v34[3];
      int v31 = v33 + *v34;
      int v32 = v33 + v35;
      CGColorSpaceRef result = (v33 + v36);
      LOBYTE(v33) = v33 + v37;
      goto LABEL_21;
    }
    if (v22)
    {
      int v33 = *(unsigned __int8 *)(v9 + v25);
      int v31 = v33 + *v22;
      int v32 = v33 + v22[1];
      CGColorSpaceRef result = v33 + v22[2];
      LOWORD(v33) = v33 + v22[3];
LABEL_21:
      unint64_t *v26 = v33 | ((unint64_t)((v31 << 14) & 0x3FF00000 | (16 * v32) & 0xFFC00 | ((unsigned __int16)result >> 6)) << 32);
      char v38 = -1;
      goto LABEL_22;
    }
    char v38 = 0;
LABEL_22:
    uint64_t v25 = (v25 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    ++v26;
    *v27++ = v38;
    --a4;
  }
  while (a4);
  return result;
}

void CIF10_shade_conic_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = *(void *)(a1 + 368);
  if (v9) {
    uint64_t v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v10 = a1 + 368;
  }
  if (v9) {
    int v11 = 15;
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(a1 + 284);
  float v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  float v36 = *(float *)(a1 + 336);
  float v37 = *(float *)(a1 + 304);
  float v15 = *(float *)(a1 + 344);
  uint64_t v16 = *(void *)(a1 + 360);
  float v18 = *(unsigned char **)(a1 + 144);
  float v17 = *(unint64_t **)(a1 + 152);
  if (v9) {
    uint64_t v19 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v19 = 0;
  }
  float v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    float v21 = v15 * (float)((float)(v37 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v36);
    unsigned int v22 = vcvtms_s32_f32(v21);
    float v23 = ceilf(v21);
    unsigned int v24 = vcvtms_s32_f32(v15 + v21);
    float v25 = v21 - (float)(int)floorf(v21);
    if (v21 < 0.0) {
      unsigned int v22 = v24;
    }
    BOOL v26 = v21 <= v15;
    float v27 = ceilf(v21 - v15);
    float v28 = (float)(v25 * 255.0) + 0.5;
    if (v26) {
      float v27 = v23;
    }
    int v29 = (unsigned __int16 *)(v16 + 2 * (int)(4 * v22));
    int v30 = v29[1];
    int v31 = (unsigned __int16 *)(v16 + 8 * (int)v27);
    int v32 = v31[1];
    int v33 = 255 - (int)v28;
    unsigned int v34 = (int)v28 * *v31 + v33 * *v29;
    unsigned int v35 = (int)v28 * v31[2] + v33 * v29[2];
    LODWORD(v29) = (int)v28 * v31[3] + v33 * v29[3];
    LODWORD(v31) = *(unsigned __int8 *)(v10 + v19);
    *v17++ = ((_BYTE)v31 + BYTE1(v29)) | ((unint64_t)(((v31 + (v34 >> 8)) << 14) & 0x3FF00000 | (16 * (v31 + (((int)v28 * v32 + v33 * v30) >> 8))) & 0xFFC00 | ((unsigned __int16)((_WORD)v31 + (v35 >> 8)) >> 6)) << 32);
    uint64_t v19 = (v19 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
}

void CIF10_shade_radial_RGB(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  float v6 = *(float *)(a1 + 280);
  float v7 = *(float *)(a1 + 284);
  float v8 = *(float *)(*(void *)(a1 + 272) + 4);
  float v9 = v8 * (float)a2;
  float v10 = v8 * (float)(uint64_t)a3;
  float v11 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v10) + (float)(v6 * v9));
  float v12 = *(float *)(a1 + 300) + (float)((float)(v10 * *(float *)(a1 + 292)) + (float)(v7 * v9));
  uint64_t v14 = *(void *)(a1 + 400);
  float v15 = *(float *)(a1 + 336);
  float v16 = *(float *)(a1 + 344);
  float v17 = *(float *)(a1 + 304);
  float v18 = *(float *)(a1 + 308);
  int v19 = *(_DWORD *)(a1 + 324);
  float v20 = *(float *)(v14 + 8);
  float v21 = *(float *)(v14 + 16);
  float v22 = *(float *)(v14 + 20);
  v5.i32[0] = *(_DWORD *)(v14 + 28);
  uint64_t v25 = a1 + 144;
  float v23 = *(char **)(a1 + 144);
  unsigned int v24 = *(int8x16_t **)(v25 + 8);
  BOOL v26 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v27 = *(void *)(a1 + 360);
  uint64_t v28 = ((unint64_t)a2 >> 8) & 0xF;
  if (v20 != 0.0 || *(float *)v5.i32 != 0.0 || v7 != 0.0)
  {
    int v40 = *(_DWORD *)(a1 + 320);
    float v41 = *(float *)(v14 + 12);
    float v42 = *(float *)(v14 + 24);
    float v43 = *(float *)(v14 + 32);
    uint64_t v44 = a1 + 368;
    uint64_t v45 = *(void *)(a1 + 368);
    uint64_t v46 = v45 + ((a3 >> 4) & 0xF0);
    BOOL v32 = v45 == 0;
    int v47 = 15;
    if (v32)
    {
      int v47 = 0;
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v44 = v46;
    }
    float v48 = -v42;
    float v49 = v18 - v17;
    while (1)
    {
      float v50 = v48 + (float)((float)(v11 + v11) * v20);
      float v51 = (float)((float)(v12 * v12) + (float)(v11 * v11)) - *(float *)v5.i32;
      if (v22 == 0.0)
      {
        float v58 = v51 / v50;
      }
      else
      {
        float v52 = (float)((float)(v22 * -4.0) * v51) + (float)(v50 * v50);
        if (v52 < 0.0) {
          goto LABEL_56;
        }
        float v53 = sqrtf(v52);
        float v54 = v43 * (float)(v50 - v53);
        float v55 = v50 + v53;
        float v56 = v43 * v55;
        BOOL v57 = (float)(v43 * v55) <= v54;
        if ((float)(v43 * v55) <= v54) {
          float v58 = v43 * v55;
        }
        else {
          float v58 = v54;
        }
        if (v57) {
          float v56 = v54;
        }
        if (v56 < 0.0)
        {
          BOOL v59 = v56 < v41;
LABEL_42:
          int v60 = v40;
          if (v59) {
            goto LABEL_56;
          }
LABEL_43:
          if ((v60 & 0x80000000) == 0) {
            goto LABEL_55;
          }
          goto LABEL_56;
        }
        if (v56 <= 1.0)
        {
          float v61 = v17 + (float)(v56 * v49);
          goto LABEL_54;
        }
        if ((v19 & 0x80000000) == 0)
        {
          int v60 = v19;
          if (v56 <= v21)
          {
LABEL_55:
            uint64_t v62 = (unsigned __int16 *)(v27 + 8 * v60);
            int v63 = v62[1];
            int v69 = *(unsigned __int8 *)(v44 + v28);
            unsigned __int16 v64 = v62[2];
            unsigned __int16 v65 = v62[3];
            int v66 = v69 + *v62;
            int v67 = v69 + v63;
            unsigned __int16 v68 = v69 + v64;
            LOBYTE(v69) = v69 + v65;
            goto LABEL_58;
          }
        }
      }
      if (v58 < 0.0)
      {
        BOOL v59 = v58 < v41;
        goto LABEL_42;
      }
      if (v58 > 1.0)
      {
        int v60 = v19;
        if (v58 > v21) {
          goto LABEL_56;
        }
        goto LABEL_43;
      }
      float v61 = v17 + (float)(v58 * v49);
LABEL_54:
      int v60 = (int)(float)(v16 * (float)(v61 - v15));
      if ((v60 & 0x80000000) == 0) {
        goto LABEL_55;
      }
LABEL_56:
      if (!v26)
      {
        char v70 = 0;
        goto LABEL_60;
      }
      int v69 = *(unsigned __int8 *)(v44 + v28);
      int v66 = v69 + *v26;
      int v67 = v69 + v26[1];
      unsigned __int16 v68 = v69 + v26[2];
      LOWORD(v69) = v69 + v26[3];
LABEL_58:
      v24->i64[0] = v69 | ((unint64_t)((v66 << 14) & 0x3FF00000 | (16 * v67) & 0xFFC00 | (v68 >> 6)) << 32);
      char v70 = -1;
LABEL_60:
      uint64_t v28 = (v28 + 1) & v47;
      float v11 = v6 + v11;
      float v12 = v7 + v12;
      unsigned int v24 = (int8x16_t *)((char *)v24 + 8);
      *v23++ = v70;
      if (!--a4) {
        return;
      }
    }
  }
  uint64_t v29 = a1 + 368;
  uint64_t v30 = *(void *)(a1 + 368);
  int v31 = (BYTE1(a2) + 1) & 0xF;
  BOOL v32 = v30 == 0;
  if (v30) {
    uint64_t v33 = v30 + ((a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v33 = v29;
  }
  if (v32) {
    LODWORD(v34) = 0;
  }
  else {
    LODWORD(v34) = v31;
  }
  if (v32) {
    LODWORD(v35) = 0;
  }
  else {
    LODWORD(v35) = v28;
  }
  if (v32) {
    int v36 = 0;
  }
  else {
    int v36 = 15;
  }
  float v37 = v12 * v12;
  float v38 = -v22;
  if (v37 <= (float)-v22)
  {
    float v71 = fabsf(*(float *)(v14 + 32));
    float v72 = v22 * -4.0;
    float v73 = v18 - v17;
    int v74 = (unsigned __int16 *)(v27 + 8 * v19);
    int v75 = a4 + 2;
    while (1)
    {
      float v76 = v37 + (float)(v11 * v11);
      float v77 = v6 + v11;
      float v78 = v37 + (float)(v77 * v77);
      if (v76 > v38 && v78 > v38)
      {
        if (v19 < 0)
        {
          if (!v26)
          {
            char v112 = 0;
            char v111 = 0;
            goto LABEL_84;
          }
          int v87 = *v26;
          int v88 = v26[1];
          unsigned __int16 v89 = v26[2];
          LOWORD(v90) = v26[3];
        }
        else
        {
          int v87 = *v74;
          int v88 = v74[1];
          unsigned __int16 v89 = v74[2];
          LOWORD(v90) = v74[3];
        }
        int v105 = *(unsigned __int8 *)(v33 + v35);
        int v106 = v105 + v87;
        int v107 = v105 + v88;
        unsigned __int16 v108 = v105 + v89;
        unsigned __int8 v109 = v105 + v90;
        int v110 = *(unsigned __int8 *)(v33 + v34);
        int v100 = v110 + v87;
        int v101 = v110 + v88;
        unsigned __int16 v102 = v110 + v89;
        LOBYTE(v90) = v110 + v90;
        uint64_t v103 = v109;
        uint64_t v104 = (v106 << 14) & 0x3FF00000 | (16 * v107) & 0xFFC00 | (v108 >> 6);
        goto LABEL_82;
      }
      float v80 = sqrtf(v72 * v78);
      float v81 = v71 * sqrtf(v72 * v76);
      float v82 = v71 * v80;
      int v83 = (int)(float)(v16 * (float)((float)(v17 + (float)(v81 * v73)) - v15));
      int v84 = (int)(float)(v16 * (float)((float)(v17 + (float)((float)(v71 * v80) * v73)) - v15));
      if (v81 <= 1.0 && v82 <= 1.0)
      {
        int64x2_t v91 = (unsigned __int16 *)(v27 + 8 * v83);
        int64x2_t v92 = (unsigned __int16 *)(v27 + 8 * v84);
        int v93 = *v92;
        int v94 = v92[1];
        unsigned __int16 v95 = v92[2];
        unsigned __int16 v96 = v92[3];
        LODWORD(v92) = *(unsigned __int8 *)(v33 + v35);
        int v97 = v92 + *v91;
        int v98 = v92 + v91[1];
        unsigned __int16 v99 = (_WORD)v92 + v91[2];
        LOBYTE(v103) = (_BYTE)v92 + v91[3];
        int v90 = *(unsigned __int8 *)(v33 + v34);
        int v100 = v90 + v93;
        int v101 = v90 + v94;
        unsigned __int16 v102 = v90 + v95;
        LOBYTE(v90) = v90 + v96;
        uint64_t v103 = v103;
        uint64_t v104 = (v97 << 14) & 0x3FF00000 | (16 * v98) & 0xFFC00 | (v99 >> 6);
LABEL_82:
        v24->i64[0] = v103 | (v104 << 32);
        char v111 = -1;
        goto LABEL_83;
      }
      if (v81 <= 1.0)
      {
        if ((v83 & 0x80000000) == 0)
        {
          uint64_t v86 = 4 * v83;
LABEL_88:
          unsigned int v113 = (unsigned __int16 *)(v27 + 2 * v86);
          int v114 = v113[1];
          int v120 = *(unsigned __int8 *)(v33 + v35);
          unsigned __int16 v115 = v113[2];
          unsigned __int16 v116 = v113[3];
          int v117 = v120 + *v113;
          int v118 = v120 + v114;
          unsigned __int16 v119 = v120 + v115;
          LOBYTE(v120) = v120 + v116;
          goto LABEL_91;
        }
      }
      else if (v81 <= v21)
      {
        uint64_t v86 = 4 * v19;
        if ((v19 & 0x80000000) == 0) {
          goto LABEL_88;
        }
      }
      if (!v26)
      {
        char v111 = 0;
        goto LABEL_92;
      }
      int v120 = *(unsigned __int8 *)(v33 + v35);
      int v117 = v120 + *v26;
      int v118 = v120 + v26[1];
      unsigned __int16 v119 = v120 + v26[2];
      LOWORD(v120) = v120 + v26[3];
LABEL_91:
      v24->i64[0] = v120 | ((unint64_t)((v117 << 14) & 0x3FF00000 | (16 * v118) & 0xFFC00 | (v119 >> 6)) << 32);
      char v111 = -1;
LABEL_92:
      if (v82 <= 1.0)
      {
        if (v84 < 0) {
          goto LABEL_99;
        }
        uint64_t v121 = 4 * v84;
      }
      else if (v82 > v21 || (uint64_t v121 = 4 * v19, v19 < 0))
      {
LABEL_99:
        if (!v26)
        {
          char v112 = 0;
          goto LABEL_84;
        }
        int v90 = *(unsigned __int8 *)(v33 + v34);
        int v100 = v90 + *v26;
        int v101 = v90 + v26[1];
        unsigned __int16 v102 = v90 + v26[2];
        LOWORD(v90) = v90 + v26[3];
        goto LABEL_83;
      }
      uint32x2_t v122 = (unsigned __int16 *)(v27 + 2 * v121);
      int v123 = v122[1];
      int v90 = *(unsigned __int8 *)(v33 + v34);
      unsigned __int16 v124 = v122[2];
      unsigned __int16 v125 = v122[3];
      int v100 = v90 + *v122;
      int v101 = v90 + v123;
      unsigned __int16 v102 = v90 + v124;
      LOBYTE(v90) = v90 + v125;
LABEL_83:
      v24->i64[1] = v90 | ((unint64_t)((v100 << 14) & 0x3FF00000 | (16 * v101) & 0xFFC00 | (v102 >> 6)) << 32);
      char v112 = -1;
LABEL_84:
      float v11 = v6 + v77;
      LOBYTE(v35) = (v35 + 1) & v36;
      LOBYTE(v34) = (v34 + 1) & v36;
      ++v24;
      *float v23 = v111;
      v23[1] = v112;
      v23 += 2;
      v75 -= 2;
      if (v75 <= 2) {
        return;
      }
    }
  }
  if (v26 || (v19 & 0x80000000) == 0)
  {
    unsigned int v126 = (unsigned __int16 *)(v27 + 8 * v19);
    if (v19 >= 0) {
      uint32x2_t v127 = v126;
    }
    else {
      uint32x2_t v127 = v26;
    }
    v128.i32[0] = *v127;
    v128.i32[1] = v127[1];
    int32x2_t v129 = vdup_n_s32(v127[2]);
    int32x2_t v130 = vdup_n_s32(v127[3]);
    int32x2_t v131 = vrev64_s32(v128);
    int v132 = a4 + 4;
    do
    {
      v5.i8[0] = *(unsigned char *)(v33 + v35);
      uint64_t v35 = (v35 + 1) & v36;
      v5.i8[4] = *(unsigned char *)(v33 + v34);
      int32x2_t v133 = (int32x2_t)vand_s8(*(int8x8_t *)v5.i8, (int8x8_t)0xFF000000FFLL);
      int8x8_t v134 = vand_s8((int8x8_t)vadd_s32(v130, *(int32x2_t *)v5.i8), (int8x8_t)0xFF000000FFLL);
      v135.i64[0] = v134.u32[0];
      v135.i64[1] = v134.u32[1];
      int8x16_t v136 = vorrq_s8((int8x16_t)vshll_n_s32((int32x2_t)vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v133, v128), (uint32x2_t)0x40000000ELL), (int8x8_t)0xFFC003FF00000), vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v131, v133), (uint32x2_t)0xE00000004), (int8x8_t)0x3FF00000000FFC00)), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v129, v133), 6uLL) & 0xFFFFFBFFFFFFFBFFLL)), 0x20uLL), v135);
      *unsigned int v24 = v136;
      uint64_t v34 = (v34 + 1) & v36;
      v136.i8[0] = *(unsigned char *)(v33 + v35);
      v136.i8[4] = *(unsigned char *)(v33 + v34);
      int32x2_t v137 = (int32x2_t)vand_s8(*(int8x8_t *)v136.i8, (int8x8_t)0xFF000000FFLL);
      *(int8x8_t *)v136.i8 = vand_s8((int8x8_t)vadd_s32(v130, *(int32x2_t *)v136.i8), (int8x8_t)0xFF000000FFLL);
      v135.i64[0] = v136.u32[0];
      v135.i64[1] = v136.u32[1];
      *(_DWORD *)float v23 = -1;
      v23 += 4;
      v132 -= 4;
      int8x16_t v5 = vorrq_s8((int8x16_t)vshll_n_s32((int32x2_t)vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v137, v128), (uint32x2_t)0x40000000ELL), (int8x8_t)0xFFC003FF00000), vand_s8((int8x8_t)vshl_u32((uint32x2_t)vadd_s32(v131, v137), (uint32x2_t)0xE00000004), (int8x8_t)0x3FF00000000FFC00)), (int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v129, v137), 6uLL) & 0xFFFFFBFFFFFFFBFFLL)), 0x20uLL), v135);
      v24[1] = v5;
      v24 += 2;
    }
    while (v132 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v39 = 4;
    }
    else {
      int v39 = a4;
    }
    bzero(v23, ((a4 - v39 + 3) & 0xFFFFFFFC) + 4);
  }
}

unint64_t *CIF10_sample_RGBAf16(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float32x4_t a5, float32x4_t a6, __n128 a7, float32x4_t a8, double a9, double _D5)
{
  uint64_t v14 = *(void *)(a1 + 176);
  uint64_t v70 = *(void *)(a1 + 80);
  float v73 = *(unint64_t **)(a1 + 88);
  uint64_t v80 = *(void *)(a1 + 112);
  uint64_t v79 = *(void *)(a1 + 120);
  int v69 = *(_DWORD *)(a1 + 188);
  float v15 = (unint64_t *)(*(void *)(a1 + 152) - 8);
  uint64_t v74 = *(void *)(a1 + 144) - 1;
  uint64_t v78 = *(void *)(a1 + 40);
  uint64_t v75 = *(void *)(a1 + 32);
  int v76 = *(_DWORD *)(a1 + 24);
  unint64_t v77 = v75 + ((*(_DWORD *)(a1 + 260) - 1) * v76) + 2 * (4 * *(_DWORD *)(a1 + 256)) - 8;
  uint64_t v71 = *(void *)(a1 + 72);
  uint64_t v72 = *(void *)(a1 + 64);
  while (1)
  {
    if (a3 >= v71)
    {
      CGColorSpaceRef result = v73;
      if (a3 <= (uint64_t)v73)
      {
        uint64_t v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v28 = 0x3FFFFFFF;
        HIDWORD(v29) = HIDWORD(a3);
        int v19 = a4;
        uint64_t v21 = v72;
      }
      else
      {
        uint64_t v23 = *(void *)(a1 + 216);
        unsigned int v24 = (char *)v73 + *(void *)(a1 + 224);
        uint64_t v25 = (uint64_t)&v24[(v23 >> 1) - a3];
        int v19 = a4;
        uint64_t v21 = v72;
        if (v25 < 1) {
          goto LABEL_33;
        }
        if (v25 >= v23) {
          LODWORD(v26) = 0x3FFFFFFF;
        }
        else {
          unint64_t v26 = (unint64_t)(*(void *)(a1 + 232) * v25) >> 32;
        }
        unsigned int v28 = v26 | v69;
        uint64_t v29 = v24 - 0x1000000;
        uint64_t v27 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(a1 + 216);
      uint64_t v17 = v71 - *(void *)(a1 + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      int v19 = a4;
      uint64_t v21 = v72;
      CGColorSpaceRef result = v73;
      if (v18 < 1) {
        goto LABEL_33;
      }
      if (v18 >= v16) {
        LODWORD(v22) = 0x3FFFFFFF;
      }
      else {
        unint64_t v22 = (unint64_t)(*(void *)(a1 + 232) * v18) >> 32;
      }
      unsigned int v28 = v22 | v69;
      uint64_t v29 = (char *)(v17 + 0x1000000);
      uint64_t v27 = 512;
    }
    if (a2 >= v21)
    {
      if (a2 <= v70)
      {
        uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v33 = a2;
      }
      else
      {
        uint64_t v35 = *(void *)(a1 + 192);
        uint64_t v36 = *(void *)(a1 + 200) + v70;
        uint64_t v37 = v36 - a2 + (v35 >> 1);
        if (v37 < 1) {
          goto LABEL_33;
        }
        if (v37 < v35) {
          unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v37) >> 32) >> 15)) | v69;
        }
        uint64_t v33 = v36 - 0x1000000;
        uint64_t v34 = 28;
      }
    }
    else
    {
      uint64_t v30 = *(void *)(a1 + 192);
      uint64_t v31 = v21 - *(void *)(a1 + 200);
      uint64_t v32 = a2 - v31 + (v30 >> 1);
      if (v32 < 1) {
        goto LABEL_33;
      }
      if (v32 < v30) {
        unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v32) >> 32) >> 15)) | v69;
      }
      uint64_t v33 = v31 + 0x1000000;
      uint64_t v34 = 32;
    }
    if (v28 >= 0x400000) {
      break;
    }
LABEL_33:
    int v41 = v19 - 1;
    a2 += v80;
    a3 += v79;
    ++v15;
    *(unsigned char *)++uint64_t v74 = 0;
LABEL_34:
    a4 = v41;
    if (!v41) {
      return result;
    }
  }
  unint64_t v38 = v75 + SHIDWORD(v29) * (uint64_t)v76 + 8 * (v33 >> 32);
  int v39 = *(unsigned __int16 **)(a1 + 32);
  int v40 = (unsigned __int16 *)v77;
  if (v77 >= v38) {
    int v40 = (unsigned __int16 *)v38;
  }
  if (v40 < v39) {
    int v40 = *(unsigned __int16 **)(a1 + 32);
  }
  if (v78) {
    a8.i16[0] = v40[3];
  }
  else {
    a8.i16[0] = COERCE_UNSIGNED_INT(1.0);
  }
  a8.i16[1] = v40[1];
  a8.i16[2] = *v40;
  a8.i16[3] = v40[2];
  if (!v14) {
    goto LABEL_72;
  }
  unsigned int v42 = *(_DWORD *)(v14 + (v34 | v27));
LABEL_40:
  int v43 = v42 & 0xF;
  int v44 = HIBYTE(v42) & 3;
  switch(v43)
  {
    case 1:
      float v56 = (unsigned __int16 *)(v38 + SBYTE1(v42) * (uint64_t)v76);
      if (v77 < (unint64_t)v56) {
        float v56 = (unsigned __int16 *)v77;
      }
      if (v56 >= v39) {
        int v39 = v56;
      }
      unsigned __int16 v57 = *v39;
      unsigned __int16 v58 = v39[1];
      unsigned __int16 v59 = v39[2];
      a6.i16[0] = COERCE_UNSIGNED_INT(1.0);
      if (v78) {
        a6.i16[0] = v39[3];
      }
      int v60 = &interpolate_rgbaf16[4 * v44];
      goto LABEL_70;
    case 2:
      float v61 = (unsigned __int16 *)(v38 + ((uint64_t)((unint64_t)HIWORD(v42) << 56) >> 53));
      if (v77 < (unint64_t)v61) {
        float v61 = (unsigned __int16 *)v77;
      }
      if (v61 >= v39) {
        int v39 = v61;
      }
      unsigned __int16 v57 = *v39;
      unsigned __int16 v58 = v39[1];
      unsigned __int16 v59 = v39[2];
      a6.i16[0] = COERCE_UNSIGNED_INT(1.0);
      if (v78) {
        a6.i16[0] = v39[3];
      }
      int v60 = &interpolate_rgbaf16[4 * ((v42 >> 28) & 3)];
LABEL_70:
      LOWORD(_D5) = v60[3];
      __asm { FCVT            S5, H5 }
      float32x4_t v62 = vcvtq_f32_f16(*(float16x4_t *)a8.f32);
      a6.i16[1] = v58;
      a6.i16[2] = v57;
      a6.i16[3] = v59;
      a5 = vcvtq_f32_f16(*(float16x4_t *)a6.f32);
      a8 = vmlaq_n_f32(vmlsq_lane_f32(v62, v62, *(float32x2_t *)&_D5, 0), a5, *(float *)&_D5);
      goto LABEL_71;
    case 3:
      uint64_t v45 = (__int16 *)(v38 + ((uint64_t)((unint64_t)HIWORD(v42) << 56) >> 53));
      if (v77 < (unint64_t)v45) {
        uint64_t v45 = (__int16 *)v77;
      }
      if (v45 < (__int16 *)v39) {
        uint64_t v45 = (__int16 *)v39;
      }
      v46.i16[0] = COERCE_UNSIGNED_INT(1.0);
      v47.i16[0] = COERCE_UNSIGNED_INT(1.0);
      if (v78) {
        v47.i16[0] = v45[3];
      }
      unint64_t v48 = v38 + SBYTE1(v42) * (uint64_t)v76 + 8 * SBYTE2(v42);
      if (v77 < v48) {
        unint64_t v48 = v77;
      }
      if (v48 >= (unint64_t)v39) {
        int v39 = (unsigned __int16 *)v48;
      }
      if (v78) {
        v46.i16[0] = v39[3];
      }
      _D17.i16[0] = interpolate_rgbaf16[4 * v44 + 3];
      __asm { FCVT            S17, H17 }
      _D18.i16[0] = interpolate_rgbaf16[4 * ((v42 >> 28) & 3) + 3];
      __asm { FCVT            S18, H18 }
      v47.i16[1] = v45[1];
      v47.i16[2] = *v45;
      float32x4_t v53 = vcvtq_f32_f16(*(float16x4_t *)a8.f32);
      v47.i16[3] = v45[2];
      float32x4_t v54 = vcvtq_f32_f16(v47);
      v46.i16[1] = v39[1];
      v46.i16[2] = *v39;
      v46.i16[3] = v39[2];
      a5 = vcvtq_f32_f16(v46);
      float32x4_t v55 = vmlaq_n_f32(vmlsq_lane_f32(v53, v53, _D17, 0), v54, _D17.f32[0]);
      a6 = vmlaq_n_f32(vmlsq_lane_f32(v54, v54, _D17, 0), a5, _D17.f32[0]);
      a8 = vmlaq_n_f32(vmlsq_lane_f32(v55, v55, _D18, 0), a6, _D18.f32[0]);
LABEL_71:
      *(float16x4_t *)a8.f32 = vcvt_f16_f32(a8);
      break;
  }
LABEL_72:
  uint64_t v63 = 0;
  ++v15;
  int v68 = v19;
  int v64 = v19 - 1;
  a3 += v79;
  unint64_t v65 = (unint64_t)result - a3;
  a2 += v80;
  uint64_t v66 = v70 - a2;
  while (1)
  {
    a5.i16[0] = a8.i16[2];
    a6.i16[0] = a8.i16[1];
    a7.n128_u16[0] = a8.u16[3];
    CGColorSpaceRef result = RGBAf16(v15, *(float16x4_t *)a5.f32, (__n128)a6, a7, (__n128)a8);
    *(unsigned char *)(v74 + 1 + v63) = v28 >> 22;
    if (v64 == v63) {
      return result;
    }
    if (((v65 | v66 | (a3 - v71) | (a2 - v72)) & 0x8000000000000000) != 0)
    {
      v74 += v63 + 1;
      int v41 = ~v63 + v68;
      goto LABEL_34;
    }
    unint64_t v38 = v75 + SHIDWORD(a3) * (uint64_t)v76 + 8 * (a2 >> 32);
    int v39 = *(unsigned __int16 **)(a1 + 32);
    int v67 = (unsigned __int16 *)v77;
    if (v77 >= v38) {
      int v67 = (unsigned __int16 *)(v75 + SHIDWORD(a3) * (uint64_t)v76 + 8 * (a2 >> 32));
    }
    if (v67 < v39) {
      int v67 = *(unsigned __int16 **)(a1 + 32);
    }
    if (v78) {
      a8.i16[0] = v67[3];
    }
    else {
      a8.i16[0] = COERCE_UNSIGNED_INT(1.0);
    }
    a8.i16[1] = v67[1];
    a8.i16[2] = *v67;
    a8.i16[3] = v67[2];
    if (v14)
    {
      unsigned int v42 = *(_DWORD *)(v14 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v42 & 0xF) != 0)
      {
        CGColorSpaceRef result = v73;
        v74 += v63 + 1;
        int v19 = ~v63 + v68;
        unsigned int v28 = -1;
        goto LABEL_40;
      }
    }
    ++v63;
    ++v15;
    a3 += v79;
    v65 -= v79;
    a2 += v80;
    v66 -= v80;
    unsigned int v28 = -1;
  }
}

uint64_t __init_appl_data_block_invoke(uint64_t a1)
{
  uint64_t result = PDFXRefTableAddObject(*(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 464));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 64)
            + 8 * (int)(*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))++) = result;
  return result;
}

void __emit_application_data_block_invoke(uint64_t a1, CFStringRef theString)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFStringGetCString(theString, buffer, 127, 0x600u);
  snprintf(__str, 0x86uLL, "%s%s", "AAPL:", buffer);
  PDFDocumentPrintNameReferencePair(*(void *)(*(void *)(a1 + 40) + 8), (uint64_t)"/%N %R", (uint64_t)__str, *(void *)(*(void *)(*(void *)(a1 + 40) + 64) + 8* *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)), v3, v4, v5, v6);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t __emit_application_data_streams_block_invoke(uint64_t a1, int a2, CFTypeRef cf)
{
  CFTypeID v5 = CFGetTypeID(cf);
  uint64_t result = CFDataGetTypeID();
  if (v5 == result)
  {
    float v7 = PDFStreamCreateWithObjectNumber(*(void *)(*(void *)(a1 + 40) + 8), *(void *)(*(void *)(*(void *)(a1 + 40) + 64)+ 8 * *(int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)));
    PDFDocumentBeginObject(*v7, v7[1], v8, v9, v10, v11, v12, v13);
    PDFDocumentPrintf(*v7, (uint64_t)"<<", v14, v15, v16, v17, v18, v19, v22);
    PDFStreamBeginData((CGDataConsumerRef)v7);
    BytePtr = CFDataGetBytePtr((CFDataRef)cf);
    CFIndex Length = CFDataGetLength((CFDataRef)cf);
    CGDataConsumerPutBytes(v7[3], (uint64_t)BytePtr, Length);
    PDFStreamEndData(v7);
    uint64_t result = (uint64_t)PDFStreamEnd((CFDataRef *)v7);
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t (*__emit_thumbnail_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8))(void)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageDestinationFinalize");
  }
  uint64_t result = (uint64_t (*)(void))dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageDestinationFinalize");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageDestinationFinalize");
  }
  emit_thumbnail_f_31 = result;
  return result;
}

void *__emit_thumbnail_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageDestinationAddImage");
  }
  uint64_t result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageDestinationAddImage");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageDestinationAddImage");
  }
  emit_thumbnail_f_25 = (uint64_t (*)(void, void, void))result;
  return result;
}

void *__emit_thumbnail_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageDestinationCreateWithData");
  }
  uint64_t result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageDestinationCreateWithData");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageDestinationCreateWithData");
  }
  emit_thumbnail_f = (uint64_t (*)(void, void, void, void))result;
  return result;
}

uint64_t CGPDFNodeIsInlineContainer(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 52)) {
    return 1;
  }
  if (*(_DWORD *)a1 != 1 || *(uint64_t *)(a1 + 24) < 1) {
    return 0;
  }
  uint64_t v2 = a1;
  while (*(_DWORD *)v2 != 517)
  {
    uint64_t v2 = *(void *)(v2 + 8);
    if (!v2) {
      return 0;
    }
  }
  uint64_t v3 = *(void *)(v2 + 104);
  if (v3
    && (uint64_t v4 = *(void *)(a1 + 16), (v4 & 0x8000000000000000) == 0)
    && *(void *)(v3 + 48) > v4
    && (uint64_t v5 = *(void *)(v3 + 24)) != 0
    && (uint64_t v6 = *(void *)(v5 + 24 * v4)) != 0
    && *(__int16 *)(v6 + 8) == -4)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t CGPDFNodeGetChildCount(uint64_t result)
{
  if (result)
  {
    if ((*(unsigned char *)(result + 1) & 2) != 0) {
      return *(unsigned int *)(result + 44);
    }
    else {
      return 0;
    }
  }
  return result;
}

CGFloat CGPDFNodeInitInPage(int a1)
{
  if (a1 <= 512)
  {
    if (a1 > 257)
    {
      if (a1 == 258)
      {
        size_t v2 = 200;
      }
      else
      {
        if (a1 != 259) {
          return result;
        }
LABEL_13:
        size_t v2 = 120;
      }
    }
    else if (a1 == 1)
    {
      size_t v2 = 72;
    }
    else
    {
      if (a1 != 257) {
        return result;
      }
      size_t v2 = 208;
    }
  }
  else
  {
    switch(a1)
    {
      case 513:
      case 515:
        size_t v2 = 112;
        break;
      case 514:
      case 516:
        goto LABEL_13;
      case 517:
        size_t v2 = 152;
        break;
      default:
        if (a1 == 1537)
        {
          size_t v2 = 144;
        }
        else
        {
          if (a1 != 1538) {
            return result;
          }
          size_t v2 = 128;
        }
        break;
    }
  }
  uint64_t v3 = (char *)malloc_type_calloc(v2, 1uLL, 0x2C7ACE11uLL);
  *(_DWORD *)uint64_t v3 = a1;
  *((_DWORD *)v3 + 10) = 1;
  CGFloat result = *(double *)&CPRangeNull;
  *((_OWORD *)v3 + 1) = CPRangeNull;
  *((void *)v3 + 4) = 0;
  *((void *)v3 + 7) = 0;
  *(void *)(v3 + 44) = 0;
  v3[52] = 0;
  if ((a1 & 0x300) != 0)
  {
    CGFloat result = CGRectNull.origin.x;
    *((CGRect *)v3 + 2) = CGRectNull;
  }
  return result;
}

uint64_t CGPDFNodeRetain(uint64_t result)
{
  return result;
}

void CGPDFNodeRelease(_DWORD *a1)
{
  if (!a1) {
    return;
  }
  int v2 = a1[10];
  if (!v2) {
    return;
  }
  int v3 = v2 - 1;
  a1[10] = v3;
  if (v3) {
    return;
  }
  if (a1[11])
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *((void *)a1 + 7);
      *(void *)(*(void *)(v5 + 8 * v4) + 8) = 0;
      CGPDFNodeRelease(*(void *)(v5 + 8 * v4++));
    }
    while (v4 < a1[11]);
  }
  uint64_t v6 = (void *)*((void *)a1 + 7);
  if (v6) {
    free(v6);
  }
  if (CGPDFNodeIsInlineContainer((uint64_t)a1))
  {
    uint64_t v7 = *((void *)a1 + 8);
    if (v7)
    {
      *(void *)(v7 + 8) = 0;
      CGPDFNodeRelease(v7);
    }
    *((void *)a1 + 8) = 0;
    *((unsigned char *)a1 + 52) = 0;
  }
  CGPDFNodeRemoveSubType((uint64_t)a1);
  int v8 = *a1;
  if ((int)*a1 > 516)
  {
    if (v8 == 1538)
    {
      uint64_t v9 = (const void *)*((void *)a1 + 14);
      if (!v9) {
        goto LABEL_43;
      }
LABEL_42:
      CFRelease(v9);
      goto LABEL_43;
    }
    if (v8 == 1537)
    {
      uint64_t v9 = (const void *)*((void *)a1 + 15);
      if (!v9) {
        goto LABEL_43;
      }
      goto LABEL_42;
    }
    if (v8 != 517) {
      goto LABEL_43;
    }
    *((void *)a1 + 13) = 0;
    unint64_t v10 = a1[28];
    if (v10)
    {
      unint64_t v11 = 0;
      uint64_t v12 = 8;
      do
      {
        uint64_t v13 = *(const void **)(*((void *)a1 + 15) + v12);
        if (v13)
        {
          CFRelease(v13);
          unint64_t v10 = a1[28];
        }
        ++v11;
        v12 += 32;
      }
      while (v11 < v10);
    }
    uint64_t v14 = (void *)*((void *)a1 + 15);
LABEL_40:
    free(v14);
    goto LABEL_43;
  }
  switch(v8)
  {
    case 257:
      uint64_t v15 = (const void *)*((void *)a1 + 16);
      if (v15) {
        CFRelease(v15);
      }
      uint64_t v9 = (const void *)*((void *)a1 + 24);
      if (!v9) {
        break;
      }
      goto LABEL_42;
    case 258:
      uint64_t v16 = (const void *)*((void *)a1 + 16);
      if (v16) {
        CFRelease(v16);
      }
      uint64_t v17 = (const void *)*((void *)a1 + 21);
      if (v17) {
        CFRelease(v17);
      }
      uint64_t v18 = (const void *)*((void *)a1 + 22);
      if (v18) {
        CFRelease(v18);
      }
      uint64_t v14 = (void *)*((void *)a1 + 23);
      goto LABEL_40;
    case 259:
      uint64_t v9 = (const void *)*((void *)a1 + 13);
      if (v9) {
        goto LABEL_42;
      }
      break;
  }
LABEL_43:

  free(a1);
}

void CGPDFNodeRemoveSubType(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 1) & 4) == 0) {
    return;
  }
  int v2 = *(void ***)(a1 + 104);
  if (!v2) {
    return;
  }
  int v3 = *(_DWORD *)v2;
  if (*(_DWORD *)v2 == 3)
  {
    free(v2[1]);
    free(v2[3]);
    uint64_t v6 = v2[5];
    goto LABEL_16;
  }
  if (v3 == 2)
  {
    uint64_t v7 = (char *)v2[5];
    if (!v7) {
      goto LABEL_17;
    }
    for (uint64_t i = 32; i != 192; i += 40)
    {
      uint64_t v9 = *(const void **)&v7[i];
      if (v9) {
        CFRelease(v9);
      }
    }
    uint64_t v6 = v7;
LABEL_16:
    free(v6);
LABEL_17:
    unint64_t v10 = v2[6];
    if (v10) {
      CFRelease(v10);
    }
    goto LABEL_19;
  }
  if (v3 != 1)
  {
LABEL_19:
    free(v2);
    *(void *)(a1 + 104) = 0;
    return;
  }
  int v4 = *((_DWORD *)v2 + 5);
  if (!v4 || (int v5 = v4 - 1, (*((_DWORD *)v2 + 5) = v5) == 0))
  {
    free(v2[3]);
    goto LABEL_19;
  }
}

uint64_t CGPDFNodeGetID(uint64_t result)
{
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t CGPDFNodeGetFromID(uint64_t a1, uint64_t a2)
{
  return a2;
}

void CGPDFNodeAddChild(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a1 && (*(unsigned char *)(a1 + 1) & 2) != 0)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 48);
    if (v6 <= a3)
    {
      if (v6) {
        unsigned int v8 = 2 * v6;
      }
      else {
        unsigned int v8 = 4;
      }
      unsigned int v7 = a3 + 1;
      if (v8 <= a3 + 1) {
        size_t v9 = a3 + 1;
      }
      else {
        size_t v9 = v8;
      }
      unint64_t v10 = malloc_type_calloc(v9, 8uLL, 0x2004093837F09uLL);
      unint64_t v11 = v10;
      uint64_t v12 = *(const void **)(a1 + 56);
      if (v12)
      {
        memcpy(v10, v12, 8 * *(unsigned int *)(a1 + 44));
        free(*(void **)(a1 + 56));
      }
      *(void *)(a1 + 56) = v11;
      *(_DWORD *)(a1 + 48) = v9;
    }
    else
    {
      unsigned int v7 = a3 + 1;
    }
    unsigned int v13 = *(_DWORD *)(a1 + 44);
    if (v13 <= a3) {
      unsigned int v13 = v7;
    }
    *(_DWORD *)(a1 + 44) = v13;
    ++*(_DWORD *)(a2 + 40);
    uint64_t v14 = *(void *)(a2 + 8);
    if (v14)
    {
      uint64_t v15 = *(unsigned int *)(v14 + 44);
      if (v15)
      {
        unint64_t v16 = 0;
        int v17 = -1;
        uint64_t v18 = *(unsigned int *)(v14 + 44);
        do
        {
          uint64_t v19 = *(void *)(v14 + 56);
          uint64_t v20 = *(void *)(v19 + 8 * v16);
          if (v20 == a2)
          {
            if ((*(unsigned char *)(v14 + 1) & 2) == 0) {
              goto LABEL_28;
            }
            uint64_t v21 = v15;
            if (v18 > v16)
            {
              if (v20)
              {
                *(void *)(v19 + 8 * v16) = 0;
                *(void *)(v20 + 8) = 0;
                CGPDFNodeRelease((_DWORD *)v20);
                LODWORD(v18) = *(_DWORD *)(v14 + 44);
              }
              if (v18 + v17)
              {
                memmove((void *)(*(void *)(v14 + 56) + 8 * v16), (const void *)(*(void *)(v14 + 56) + 8 * v16 + 8), 8 * (v18 + v17));
                LODWORD(v18) = *(_DWORD *)(v14 + 44);
              }
              uint64_t v15 = (v18 - 1);
              *(_DWORD *)(v14 + 44) = v15;
LABEL_28:
              uint64_t v21 = v15;
            }
          }
          else
          {
            uint64_t v21 = v18;
          }
          ++v16;
          --v17;
          uint64_t v18 = v21;
        }
        while (v16 < v21);
      }
    }
    *(void *)(*(void *)(a1 + 56) + 8 * a3) = a2;
    *(void *)(a2 + 8) = a1;
  }
}

uint64_t CGPDFNodeGetAncestorOfType(uint64_t result, int a2)
{
  for (; result; CGFloat result = *(void *)(result + 8))
  {
    if (*(_DWORD *)result == a2) {
      break;
    }
  }
  return result;
}

void CGPDFNodeMakeSubType(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 0x400) == 0) {
    return;
  }
  if (v2 == 1538)
  {
    if ((a2 & 0xFFFFFFFE) != 2) {
      return;
    }
    if (a2 == 2)
    {
      size_t v6 = 56;
    }
    else
    {
      if (a2 != 3) {
        return;
      }
      size_t v6 = 64;
    }
    goto LABEL_14;
  }
  if (v2 == 1537 && a2 == 1)
  {
    size_t v6 = 48;
LABEL_14:
    unsigned int v7 = malloc_type_calloc(1uLL, v6, 0x39832BCBuLL);
    if (v7)
    {
      unsigned int v8 = v7;
      *unsigned int v7 = a2;
      CGPDFNodeRemoveSubType(a1);
      *(void *)(a1 + 104) = v8;
    }
  }
}

unsigned int *CGPDFNodeGetType(unsigned int *result)
{
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

uint64_t CGPDFNodeGetSubType(uint64_t result)
{
  if (result)
  {
    if ((*(unsigned char *)(result + 1) & 4) != 0 && (int v1 = *(unsigned int **)(result + 104)) != 0) {
      return *v1;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetParent(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t CGPDFNodeGetChild(uint64_t result, unsigned int a2)
{
  if (result)
  {
    if ((*(unsigned char *)(result + 1) & 2) != 0 && *(_DWORD *)(result + 44) > a2) {
      return *(void *)(*(void *)(result + 56) + 8 * a2);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetChildIndex(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0;
  }
  if ((*(unsigned char *)(v1 + 1) & 2) == 0) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(v1 + 44);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(v1 + 56);
  while (*(void *)(v4 + 8 * v3) != a1)
  {
    if (v2 == ++v3) {
      return 0;
    }
  }
  return v3;
}

uint64_t CGPDFNodeGetLayout(uint64_t result)
{
  if (result)
  {
    while (*(_DWORD *)result != 517)
    {
      CGFloat result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(void *)(result + 104);
  }
  return result;
}

double CGPDFNodeGetPageRotation(uint64_t a1)
{
  double v1 = 0.0;
  if (a1)
  {
    while (*(_DWORD *)a1 != 517)
    {
      a1 = *(void *)(a1 + 8);
      if (!a1) {
        return v1;
      }
    }
    uint64_t v2 = *(void *)(a1 + 104);
    if (v2)
    {
      int RotationAngle = CGPDFPageGetRotationAngle(*(CGPDFPageRef *)(v2 + 16));
      if (RotationAngle) {
        return (double)RotationAngle * -3.14159265 / 180.0;
      }
    }
  }
  return v1;
}

double CGPDFNodeGetRotation(uint64_t a1)
{
  double result = 0.0;
  if (a1)
  {
    if (*(_DWORD *)a1 == 1)
    {
      uint64_t v2 = a1;
      while (1)
      {
        uint64_t v2 = *(void *)(v2 + 8);
        if (!v2) {
          break;
        }
        if (*(_DWORD *)v2 == 517)
        {
          uint64_t v3 = *(void *)(v2 + 104);
          if (v3)
          {
            uint64_t TextRange = CGPDFNodeGetTextRange(a1);
            uint64_t v6 = v5;
            if (v5 < 1)
            {
              double v11 = 0.0;
              double v9 = 0.0;
            }
            else
            {
              uint64_t v7 = TextRange;
              uint64_t v8 = 24 * TextRange + 8;
              double v9 = 0.0;
              uint64_t v10 = v5;
              double v11 = 0.0;
              do
              {
                double v12 = 0.0;
                if ((v7 & 0x8000000000000000) == 0 && *(void *)(v3 + 48) > v7)
                {
                  uint64_t v13 = *(void *)(v3 + 24);
                  if (v13)
                  {
                    uint64_t v14 = *(void *)(v13 + v8);
                    if (v14) {
                      double v12 = *(double *)(v14 + 40);
                    }
                  }
                }
                __double2 v15 = __sincos_stret(v12);
                double v11 = v11 + v15.__cosval;
                double v9 = v9 + v15.__sinval;
                v8 += 24;
                ++v7;
                --v10;
              }
              while (v10);
            }
            return atan2(v9 / (double)v6, v11 / (double)v6);
          }
          return result;
        }
      }
    }
    else
    {
      return *(double *)(a1 + 32);
    }
  }
  return result;
}

uint64_t CGPDFNodeGetTextRange(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == 0x7FFFFFFFFFFFFFFFLL && *(void *)(a1 + 24) == 0)
  {
    if ((*(unsigned char *)(a1 + 1) & 2) != 0 && (uint64_t v4 = *(unsigned int *)(a1 + 44), v4))
    {
      uint64_t v5 = 0;
      uint64_t v2 = 0;
      uint64_t v6 = 0;
      uint64_t v7 = 8 * v4;
      do
      {
        uint64_t TextRange = CGPDFNodeGetTextRange(*(void *)(*(void *)(a1 + 56) + v5));
        uint64_t v2 = CPRangeUnion(v2, v6, TextRange, v9);
        uint64_t v6 = v10;
        v5 += 8;
      }
      while (v7 != v5);
    }
    else
    {
      uint64_t v2 = 0;
      uint64_t v6 = 0;
    }
    *(void *)(a1 + 16) = v2;
    *(void *)(a1 + 24) = v6;
  }
  return v2;
}

__n64 CGPDFNodeGetBounds(__n64 *a1)
{
  if (!a1) {
    return (__n64)0x7FF0000000000000;
  }
  if (a1->n64_u32[0] == 1)
  {
    double v1 = a1;
    while (1)
    {
      double v1 = (__n64 *)v1[1].n64_u64[0];
      if (!v1) {
        break;
      }
      if (v1->n64_u32[0] == 517)
      {
        uint64_t v2 = v1[13].n64_i64[0];
        if (!v2) {
          return (__n64)0x7FF0000000000000;
        }
        uint64_t TextRange = CGPDFNodeGetTextRange((uint64_t)a1);
        return CGPDFLayoutGetRectForTextRange(v2, TextRange, v4);
      }
    }
  }
  else if ((a1->n64_u32[0] & 0x300) != 0)
  {
    return a1[8];
  }
  return (__n64)0x7FF0000000000000;
}

double CGPDFNodeGetBaseline(uint64_t a1)
{
  double result = 0.0;
  if (a1)
  {
    uint64_t v2 = a1;
    while (*(_DWORD *)v2 != 517)
    {
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        return result;
      }
    }
    uint64_t v3 = *(void *)(v2 + 104);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      double v5 = 0.0;
      if (v4 < 0)
      {
        double v6 = 0.0;
      }
      else
      {
        double v6 = 0.0;
        if (*(void *)(v3 + 48) > v4)
        {
          uint64_t v7 = *(void *)(v3 + 24);
          if (v7)
          {
            uint64_t v8 = *(void *)(v7 + 24 * v4);
            if (v8) {
              double v5 = *(double *)(v8 + 88);
            }
          }
          uint64_t v9 = *(void *)(v3 + 24);
          if (v9)
          {
            uint64_t v10 = *(void *)(v9 + 24 * v4 + 8);
            if (v10) {
              double v6 = *(double *)(v10 + 48);
            }
          }
        }
      }
      return v5 - v6;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetZ(uint64_t result)
{
  if (result)
  {
    while ((*(unsigned char *)(result + 1) & 3) == 0)
    {
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(void *)(result + 96);
  }
  return result;
}

uint64_t CGPDFNodeIsLineBreakAfter(uint64_t result)
{
  if (result)
  {
    while (*(_DWORD *)result != 514)
    {
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(unsigned char *)(result + 104) != 0;
  }
  return result;
}

__CFArray *CGPDFNodeGetParagraphLinks(__n64 *a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (!a1 || a1->n64_u32[0] != 1537) {
    return 0;
  }
  CFMutableArrayRef Mutable = (__CFArray *)a1[15].n64_u64[0];
  if (!Mutable)
  {
    uint64_t v3 = a1;
    while (v3->n64_u32[0] != 517)
    {
      uint64_t v3 = (__n64 *)v3[1].n64_u64[0];
      if (!v3) {
        return 0;
      }
    }
    unint64_t v4 = v3[13].n64_u64[0];
    if (!v4) {
      return 0;
    }
    uint64_t v5 = *(void *)(v4 + 16);
    if (!v5) {
      return 0;
    }
    double v6 = *(CGPDFDictionary **)(*(void *)(v5 + 40) + 16);
    if (!v6) {
      return 0;
    }
    CGPDFArrayRef value = 0;
    CFMutableArrayRef Mutable = 0;
    if (CGPDFDictionaryGetArray(v6, "Annots", &value))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      v7.n64_u64[0] = CGPDFNodeGetBounds(a1).n64_u64[0];
      if (value)
      {
        uint64_t v11 = *((void *)value + 2);
        if (v11)
        {
          CGFloat v12 = v7.n64_f64[0];
          CGFloat v13 = v8.n64_f64[0];
          CGFloat v14 = v9.n64_f64[0];
          CGFloat v15 = v10.n64_f64[0];
          for (size_t i = 0; i != v11; ++i)
          {
            CGPDFDictionaryRef dict = 0;
            if (CGPDFArrayGetDictionary(value, i, &dict))
            {
              __s1 = 0;
              if (CGPDFDictionaryGetName(dict, "Subtype", (const char **)&__s1) && !strcmp(__s1, "Link"))
              {
                CGPDFArrayRef array = 0;
                if (CGPDFDictionaryGetArray(dict, "Rect", &array))
                {
                  int v17 = array;
                  if (array)
                  {
                    if (*((void *)array + 2) == 4)
                    {
                      BOOL v18 = 0;
                      size_t v19 = 0;
                      uint64_t v20 = v51;
                      while (CGPDFArrayGetNumber(v17, v19, v20))
                      {
                        BOOL v18 = v19 > 2;
                        ++v20;
                        if (++v19 == 4)
                        {
                          double v22 = v51[0];
                          double v21 = v51[1];
                          double v23 = *(double *)&v52 - v51[0];
                          double v24 = *((double *)&v52 + 1) - v51[1];
                          goto LABEL_27;
                        }
                      }
                      if (!v18) {
                        continue;
                      }
                      double v24 = 0.0;
                      double v21 = INFINITY;
                      double v23 = 0.0;
                      double v22 = INFINITY;
LABEL_27:
                      CGFloat v39 = v23;
                      double v40 = v24;
                      double v25 = v22 + v23 * 0.5;
                      double v26 = v21 + v24 * 0.5;
                      v55.origin.x = v12;
                      v55.origin.y = v13;
                      v55.size.width = v14;
                      v55.size.height = v15;
                      v54.x = v25;
                      v54.y = v26;
                      if (CGRectContainsPoint(v55, v54))
                      {
                        int v44 = 0;
                        CGPDFDictionaryRef v45 = 0;
                        CGPDFStringRef v43 = 0;
                        if (CGPDFDictionaryGetDictionary(dict, "A", &v45)
                          && CGPDFDictionaryGetName(v45, "S", (const char **)&v44)
                          && !strcmp(v44, "URI")
                          && CGPDFDictionaryGetString(v45, "URI", &v43))
                        {
                          CGPDFStringRef v27 = v43;
                          if (v43)
                          {
                            if (*((void *)v43 + 3)) {
                              decrypt_string((uint64_t)v43);
                            }
                            if (*((void *)v27 + 9))
                            {
                              unsigned int v28 = CGPDFSelectionCreateAtPointWithOptions(v5, 1, v25, v26);
                              long long valuePtr = 0uLL;
                              if (v28)
                              {
                                uint64_t v29 = v28[23];
                                long long v30 = xmmword_1850CD8B0;
                                if (v28[24] != v29) {
                                  long long v30 = *(_OWORD *)(v29 + 8);
                                }
                                long long valuePtr = v30;
                                CFRelease(v28);
                                uint64_t v31 = valuePtr;
                              }
                              else
                              {
                                uint64_t v31 = -1;
                                *(void *)&long long valuePtr = -1;
                              }
                              *(void *)&long long valuePtr = v31 - CGPDFNodeGetTextRange((uint64_t)a1);
                              CFNumberRef v32 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
                              CFNumberRef v33 = CFNumberCreate(0, kCFNumberCFIndexType, (char *)&valuePtr + 8);
                              v56.origin.x = v22;
                              v56.origin.y = v21;
                              v56.size.width = v39;
                              v56.size.height = v40;
                              CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v56);
                              CGPDFStringRef v35 = v43;
                              if (v43)
                              {
                                if (*((void *)v43 + 3)) {
                                  decrypt_string((uint64_t)v43);
                                }
                                uint64_t v36 = (char *)v35 + 80;
                              }
                              else
                              {
                                uint64_t v36 = 0;
                              }
                              CFStringRef v37 = CFStringCreateWithCString(0, v36, 0x8000100u);
                              *(_OWORD *)float v51 = xmmword_1E52CE960;
                              long long v52 = *(_OWORD *)off_1E52CE970;
                              values[0] = DictionaryRepresentation;
                              values[1] = (void *)v37;
                              values[2] = v32;
                              values[3] = v33;
                              CFDictionaryRef v41 = CFDictionaryCreate(0, (const void **)v51, (const void **)values, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                              CFRelease(DictionaryRepresentation);
                              CFRelease(v37);
                              CFRelease(v32);
                              CFRelease(v33);
                              CFArrayAppendValue(Mutable, v41);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (CFArrayGetCount(Mutable))
      {
        a1[15].n64_u64[0] = (unint64_t)Mutable;
        return Mutable;
      }
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

uint64_t CGPDFNodeIsHeading(uint64_t result)
{
  if (result)
  {
    while (*(_DWORD *)result != 1537)
    {
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(unsigned char *)(result + 128) != 0;
  }
  return result;
}

uint64_t CGPDFNodeIsPreformatted(uint64_t result)
{
  if (result)
  {
    while (*(_DWORD *)result != 1537)
    {
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(double *)(result + 112) != 0.0;
  }
  return result;
}

double CGPDFNodeGetPreformattedWidthUnit(uint64_t a1)
{
  double result = 0.0;
  if (a1)
  {
    while (*(_DWORD *)a1 != 1537)
    {
      a1 = *(void *)(a1 + 8);
      if (!a1) {
        return result;
      }
    }
    return *(double *)(a1 + 112);
  }
  return result;
}

uint64_t CGPDFNodeGetUserNode(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 1)) {
      return *(void *)(result + 112);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeIsGraphic(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 513) {
      return 1;
    }
    else {
      return (*(_DWORD *)result >> 8) & 1;
    }
  }
  return result;
}

uint64_t CGPDFNodeIsUsedGraphic(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = *(_DWORD *)result;
    BOOL v3 = *(_DWORD *)result != 513 && (*(_DWORD *)result & 0x100) == 0;
    if (v3) {
      return 0;
    }
    if ((v2 & 0x100) != 0 && *(void *)(result + 112)) {
      return 1;
    }
    if ((v2 & 0x200) != 0 && (unint64_t v4 = *(unsigned int *)(result + 44), v4))
    {
      unint64_t v5 = 0;
      do
      {
        if (v5 >= v4) {
          uint64_t v6 = 0;
        }
        else {
          uint64_t v6 = *(void *)(*(void *)(v1 + 56) + 8 * v5);
        }
        double result = CGPDFNodeIsUsedGraphic(v6);
        if (!result) {
          break;
        }
        BOOL v3 = v4 - 1 == v5++;
      }
      while (!v3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void CGPDFNodeDrawInContext(uint64_t a1, CGContext *a2)
{
  if (a1)
  {
    int v4 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 == 257)
    {
      CGPDFNodeDrawImageInContext(a1, a2);
    }
    else if (v4 == 513)
    {
      uint64_t v5 = *(unsigned int *)(a1 + 44);
      if (v5)
      {
        uint64_t v6 = 0;
        uint64_t v7 = 8 * v5;
        do
        {
          CGPDFNodeDrawInContext(*(void *)(*(void *)(a1 + 56) + v6), a2);
          v6 += 8;
        }
        while (v7 != v6);
      }
    }
    else if (v4 == 258)
    {
      CGPDFNodeDrawShapeInContext(a1, a2);
    }
  }
}

void CGPDFNodeDrawShapeInContext(uint64_t a1, CGContext *a2)
{
  if (CGPDFNodeDrawPatternInContext(a1, a2, 0)) {
    int v4 = 0;
  }
  else {
    int v4 = *(CGColor **)(a1 + 168);
  }
  uint64_t v5 = *(void *)(a1 + 184);
  if (v5 && *(void *)(v5 + 8))
  {
    uint64_t v6 = 0;
    int v7 = 1;
  }
  else
  {
    int v7 = 0;
    uint64_t v6 = *(CGColor **)(a1 + 176);
  }
  if ((unint64_t)v4 | (unint64_t)v6)
  {
    CGContextSaveGState(a2);
    CGPDFNodeApplyClipToContext(a1, a2);
    if (v6)
    {
      CGContextSetLineWidth(a2, *(CGFloat *)(a1 + 144));
      CGContextSetLineCap(a2, *(CGLineCap *)(a1 + 160));
      CGContextSetLineJoin(a2, *(CGLineJoin *)(a1 + 164));
      CGContextSetMiterLimit(a2, *(CGFloat *)(a1 + 152));
      CGContextSetStrokeColorWithColor(a2, v6);
    }
    if (v4)
    {
      CGContextSetFillColorWithColor(a2, v4);
      if (*(unsigned char *)(a1 + 136))
      {
        if (v6) {
          CGPathDrawingMode v8 = kCGPathEOFillStroke;
        }
        else {
          CGPathDrawingMode v8 = kCGPathEOFill;
        }
      }
      else if (v6)
      {
        CGPathDrawingMode v8 = kCGPathFillStroke;
      }
      else
      {
        CGPathDrawingMode v8 = kCGPathFill;
      }
    }
    else
    {
      CGPathDrawingMode v8 = kCGPathStroke;
    }
    ShapePath = (const CGPath *)CGPDFNodeCreateShapePath(a1);
    if (ShapePath)
    {
      __n64 v10 = ShapePath;
      CGContextAddPath(a2, ShapePath);
      CGContextDrawPath(a2, v8);
      CFRelease(v10);
    }
    CGContextRestoreGState(a2);
  }
  if (v7 && (CGPDFNodeDrawPatternInContext(a1, a2, 1) & 1) == 0)
  {
    if (*(void *)(a1 + 176))
    {
      long long v11 = *(_OWORD *)(a1 + 144);
      v17[8] = *(_OWORD *)(a1 + 128);
      v17[9] = v11;
      long long v18 = *(_OWORD *)(a1 + 160);
      uint64_t v12 = *(void *)(a1 + 176);
      long long v13 = *(_OWORD *)(a1 + 80);
      v17[4] = *(_OWORD *)(a1 + 64);
      v17[5] = v13;
      long long v14 = *(_OWORD *)(a1 + 112);
      v17[6] = *(_OWORD *)(a1 + 96);
      v17[7] = v14;
      long long v15 = *(_OWORD *)(a1 + 16);
      v17[0] = *(_OWORD *)a1;
      v17[1] = v15;
      long long v16 = *(_OWORD *)(a1 + 48);
      v17[2] = *(_OWORD *)(a1 + 32);
      v17[3] = v16;
      uint64_t v19 = v12;
      uint64_t v20 = 0;
      *((void *)&v18 + 1) = 0;
      CGPDFNodeDrawShapeInContext(v17, a2);
    }
  }
}

void CGPDFNodeDrawImageInContext(uint64_t a1, CGContext *a2)
{
  uint64_t Image = CGPDFNodeCreateImage();
  if (Image)
  {
    uint64_t v5 = (CGImage *)Image;
    uint64_t v6 = CPPDFCreateMaskingImageFromStream(*(CGPDFStream **)(a1 + 120));
    uint64_t v23 = 0;
    if (v6)
    {
      int v7 = v6;
      CGImageRef v8 = CPImageCreateWithMask(v5, (uint64_t)v6);
      CFRelease(v5);
      CFRelease(v7);
      uint64_t v5 = v8;
    }
    else
    {
      __n64 v9 = (CGFloat *)CPPDFCreateMaskingColorsFromStream(*(void *)(a1 + 120), &v23);
      if (v9)
      {
        __n64 v10 = v9;
        CGColorSpaceRef ColorSpace = CGImageGetColorSpace(v5);
        if (ColorSpace) {
          uint64_t v12 = *(void *)(*((void *)ColorSpace + 3) + 48);
        }
        else {
          uint64_t v12 = 0;
        }
        if (v12 == v23)
        {
          CGImageRef v13 = CGImageCreateWithMaskingColors(v5, v10);
          CFRelease(v5);
          uint64_t v5 = v13;
        }
        free(v10);
      }
    }
    CGContextSaveGState(a2);
    CGPDFNodeApplyClipToContext(a1, a2);
    double v14 = *(double *)(a1 + 64);
    double v15 = *(double *)(a1 + 72);
    long long v18 = *(_DWORD **)(a1 + 8);
    if (!v18 || *v18 != 513 || v14 != INFINITY && v15 != INFINITY)
    {
      uint64_t v16 = *(void *)(a1 + 80);
      uint64_t v17 = *(void *)(a1 + 88);
      CGContextClipToRect(a2, *(CGRect *)&v14);
    }
    long long v19 = *(_OWORD *)(a1 + 152);
    *(_OWORD *)&v22.a = *(_OWORD *)(a1 + 136);
    *(_OWORD *)&v22.c = v19;
    *(_OWORD *)&v22.tx = *(_OWORD *)(a1 + 168);
    CGContextConcatCTM(a2, &v22);
    double v20 = *(double *)(a1 + 184);
    if (v20 != 1.0) {
      CGContextSetAlpha(a2, v20);
    }
    double v21 = *(CGColor **)(a1 + 192);
    if (v21) {
      CGContextSetFillColorWithColor(a2, v21);
    }
    v24.origin.x = 0.0;
    v24.origin.y = 0.0;
    v24.size.width = 1.0;
    v24.size.height = 1.0;
    CGContextDrawImage(a2, v24, v5);
    if (v5) {
      CFRelease(v5);
    }
    CGContextRestoreGState(a2);
  }
}

CGPDFStream *CGPDFNodeCreateImage(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == 513 || v2 == 258)
  {
    double x = *(double *)(a1 + 64);
    double width = *(double *)(a1 + 80);
    double y = *(double *)(a1 + 72);
    double height = *(double *)(a1 + 88);
    double PageRotation = CGPDFNodeGetPageRotation(a1);
    CGFloat v7 = PageRotation;
    if (PageRotation != 0.0)
    {
      __double2 v8 = __sincos_stret(PageRotation);
      v24.a = v8.__cosval;
      v24.b = v8.__sinval;
      v24.c = -v8.__sinval;
      v24.d = v8.__cosval;
      v24.tdouble x = 0.0;
      v24.tdouble y = 0.0;
      v26.origin.double x = x;
      v26.origin.double y = y;
      v26.size.double width = width;
      v26.size.double height = height;
      CGRect v27 = CGRectApplyAffineTransform(v26, &v24);
      double x = v27.origin.x;
      double y = v27.origin.y;
      double width = v27.size.width;
      double height = v27.size.height;
    }
    size_t v9 = vcvtpd_u64_f64(width);
    size_t v10 = vcvtpd_u64_f64(height);
    CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
    uint64_t v12 = CGBitmapContextCreateWithData(0, v9, v10, 8uLL, 4 * v9, DeviceRGB, 1u, 0, 0);
    if (v12)
    {
      uint64_t v13 = (uint64_t)v12;
      v28.size.double width = (double)v9;
      v28.size.double height = (double)v10;
      v28.origin.double x = 0.0;
      v28.origin.double y = 0.0;
      CGContextClearRect(v12, v28);
      if (*(_DWORD *)(v13 + 16) == 1129601108) {
        *(float64x2_t *)(*(void *)(v13 + 96) + 56) = vmlsq_lane_f64(vmlsq_lane_f64(*(float64x2_t *)(*(void *)(v13 + 96) + 56), *(float64x2_t *)(*(void *)(v13 + 96) + 24), x, 0), *(float64x2_t *)(*(void *)(v13 + 96) + 40), y, 0);
      }
      else {
        handle_invalid_context((char)"CGContextTranslateCTM", v13, v14, v15, v16, v17, v18, v19);
      }
      if (v7 != 0.0) {
        CGContextRotateCTM((CGContextRef)v13, v7);
      }
      CGPDFNodeDrawInContext(a1, (CGContext *)v13);
      CGImageRef Image = CGBitmapContextCreateImage((CGContextRef)v13);
      CFRelease((CFTypeRef)v13);
    }
    else
    {
      CGImageRef Image = 0;
    }
    CGColorSpaceRelease(DeviceRGB);
    return Image;
  }
  if (v2 != 257) {
    return 0;
  }
  CGImageRef Image = *(CGImageRef *)(a1 + 128);
  if (Image)
  {
    CFRetain(*(CFTypeRef *)(a1 + 128));
    return Image;
  }
  double v21 = *(CGPDFStream **)(a1 + 120);

  return CPPDFCreateImageFromStream(v21, 0, 0);
}

CGImageRef CPImageCreateWithMask(CGImage *cf, uint64_t a2)
{
  CGImageRef Image = cf;
  if (!cf)
  {
    size_t v4 = 0;
    size_t v5 = 0;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    size_t v6 = 0;
    size_t v7 = 0;
    goto LABEL_6;
  }
  CFRetain(cf);
  size_t v4 = *((void *)Image + 5);
  size_t v5 = *((void *)Image + 6);
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  size_t v6 = *(void *)(a2 + 40);
  size_t v7 = *(void *)(a2 + 48);
LABEL_6:
  if (v6 > v4 || v7 > v5)
  {
    if (v6 <= v4) {
      size_t v8 = v4;
    }
    else {
      size_t v8 = v6;
    }
    if (v7 <= v5) {
      size_t v9 = v5;
    }
    else {
      size_t v9 = v7;
    }
    CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
    long long v11 = CGBitmapContextCreateWithData(0, v8, v9, 8uLL, 4 * v8, DeviceRGB, 1u, 0, 0);
    if (v11)
    {
      uint64_t v12 = v11;
      v15.origin.double x = 0.0;
      v15.origin.double y = 0.0;
      v15.size.double width = (double)v8;
      v15.size.double height = (double)v9;
      CGContextClearRect(v11, v15);
      v16.origin.double x = 0.0;
      v16.origin.double y = 0.0;
      v16.size.double width = (double)v8;
      v16.size.double height = (double)v9;
      CGContextDrawImage(v12, v16, Image);
      if (Image) {
        CFRelease(Image);
      }
      CGImageRef Image = CGBitmapContextCreateImage(v12);
      CFRelease(v12);
    }
    CGColorSpaceRelease(DeviceRGB);
  }
  CGImageRef v13 = CGImageCreateWithMaskAndMatte((uint64_t)Image, a2, 0);
  if (Image) {
    CFRelease(Image);
  }
  return v13;
}

void CGPDFNodeApplyClipToContext(uint64_t a1, CGContextRef c)
{
  CGContextBeginPath(c);
  if (a1)
  {
    if (*(unsigned char *)(a1 + 1))
    {
      for (uint64_t i = *(void *)(a1 + 104); i; uint64_t i = *(void *)(i + 24))
      {
        size_t v5 = *(const CGPath **)(i + 8);
        if (v5)
        {
          CFRetain(*(CFTypeRef *)(i + 8));
          CGContextAddPath(c, v5);
          clip((uint64_t)c, *(unsigned __int8 *)(i + 16), v6, v7, v8, v9, v10, v11);
          CFRelease(v5);
        }
      }
    }
  }
}

CGPDFContentStreamRef CGPDFNodeDrawPatternInContext(uint64_t a1, CGContext *a2, int a3)
{
  v90[4] = *(CGPDFReal *)MEMORY[0x1E4F143B8];
  BOOL v3 = *(float64x2_t **)(a1 + 184);
  if (!v3) {
    return 0;
  }
  uint64_t v6 = 1;
  if (!a3) {
    uint64_t v6 = 0;
  }
  CGPDFContentStreamRef result = *(CGPDFContentStreamRef *)&v3->f64[v6];
  if (!result) {
    return result;
  }
  CGPDFDictionaryRef dict = 0;
  uint64_t v79 = 0;
  CGPDFNodeExtractPDFObject((uint64_t)result, &v79, &dict);
  uint64_t v9 = dict;
  if (!dict) {
    return 0;
  }
  CGPDFInteger value = 0;
  if (CGPDFDictionaryGetInteger(dict, "ShadingType", &value))
  {
    CGPDFInteger v10 = value;
    float64x2_t v11 = v3[2];
    *(float64x2_t *)&v89.a = v3[1];
    *(float64x2_t *)&v89.c = v11;
    float64x2_t v12 = v3[3];
LABEL_8:
    *(float64x2_t *)&v89.tdouble x = v12;
    return (CGPDFContentStreamRef)CGPDFNodeDrawShadingInContext(a1, a2, v9, v10, (uint64_t)&v89, a3);
  }
  CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetInteger(v9, "PatternType", &value);
  if (!result) {
    return result;
  }
  CGPDFArrayRef array = 0;
  if (CGPDFDictionaryGetArray(v9, "Matrix", &array))
  {
    size_t v13 = 0;
    uint64_t v14 = &v89;
    while (CGPDFArrayGetNumber(array, v13, &v14->a))
    {
      ++v13;
      uint64_t v14 = (CGAffineTransform *)((char *)v14 + 8);
      if (v13 == 6)
      {
        float64x2_t v15 = *(float64x2_t *)&v89.a;
        float64x2_t v16 = *(float64x2_t *)&v89.c;
        float64x2_t v17 = *(float64x2_t *)&v89.tx;
        goto LABEL_17;
      }
    }
    float64x2_t v17 = 0uLL;
    float64x2_t v15 = (float64x2_t)xmmword_1850CD830;
    float64x2_t v16 = (float64x2_t)xmmword_1850CD8C0;
  }
  else
  {
    float64x2_t v16 = (float64x2_t)xmmword_1850CD8C0;
    float64x2_t v15 = (float64x2_t)xmmword_1850CD830;
    float64x2_t v17 = 0uLL;
  }
LABEL_17:
  float64x2_t v18 = v3[1];
  float64x2_t v19 = v3[2];
  float64x2_t v20 = vmlaq_n_f64(vmulq_laneq_f64(v19, v15, 1), v18, v15.f64[0]);
  float64x2_t v21 = vmlaq_n_f64(vmulq_laneq_f64(v19, v16, 1), v18, v16.f64[0]);
  float64x2_t v22 = vaddq_f64(v3[3], vmlaq_n_f64(vmulq_laneq_f64(v19, v17, 1), v18, v17.f64[0]));
  if (value == 2)
  {
    float64x2_t v68 = v22;
    float64x2_t v71 = v20;
    float64x2_t v74 = v21;
    v80.a = 0.0;
    CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetObject(v9, "Shading", (CGPDFObjectRef *)&v80);
    if (!result) {
      return result;
    }
    v90[0] = 0.0;
    *(void *)&v81.version = 0;
    CGPDFNodeExtractPDFObject(*(uint64_t *)&v80.a, v90, &v81);
    uint64_t v9 = *(CGPDFDictionary **)&v81.version;
    if (*(void *)&v81.version)
    {
      CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetInteger(*(CGPDFDictionaryRef *)&v81.version, "ShadingType", &value);
      if (result)
      {
        CGPDFInteger v10 = value;
        *(float64x2_t *)&v89.a = v71;
        *(float64x2_t *)&v89.c = v74;
        float64x2_t v12 = v68;
        goto LABEL_8;
      }
      return result;
    }
    return 0;
  }
  if (value != 1) {
    return 0;
  }
  uint64_t v23 = v79;
  if (!v79) {
    return 0;
  }
  float64x2_t v67 = v22;
  float64x2_t v70 = v20;
  float64x2_t v73 = v21;
  CGPDFInteger v88 = 0;
  CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetInteger(v9, "PaintType", &v88);
  if (!result) {
    return result;
  }
  if (v88 != 1)
  {
    if (v88 == 2)
    {
      BOOL v24 = 0;
      goto LABEL_31;
    }
    return 0;
  }
  BOOL v24 = 1;
LABEL_31:
  CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetInteger(v9, "TilingType", &v88);
  if (result)
  {
    int v25 = v88 == 3 ? 2 : 1;
    CGPatternTiling v26 = v88 == 2 ? kCGPatternTilingNoDistortion : v25;
    CGPDFReal v86 = 0.0;
    CGPDFReal v87 = 0.0;
    BOOL Number = CGPDFDictionaryGetNumber(v9, "XStep", &v87);
    CGPDFContentStreamRef result = 0;
    if (Number)
    {
      CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetNumber(v9, "YStep", &v86);
      if (result)
      {
        CGPDFArrayRef v85 = 0;
        CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetArray(v9, "BBox", &v85);
        if (result)
        {
          size_t v28 = 0;
          uint64_t v29 = v90;
          do
          {
            CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFArrayGetNumber(v85, v28, v29);
            if (!result) {
              return result;
            }
            ++v28;
            ++v29;
          }
          while (v28 != 4);
          double v30 = v90[0];
          double v31 = v90[1];
          double v32 = v90[2];
          double v33 = v90[3];
          CGPDFDictionaryRef streamResources = 0;
          CGPDFContentStreamRef result = (CGPDFContentStreamRef)CGPDFDictionaryGetDictionary(v9, "Resources", &streamResources);
          if (result)
          {
            CGPDFContentStreamRef result = CGPDFContentStreamCreateWithStream(v23, streamResources, 0);
            if (result)
            {
              uint64_t v34 = result;
              double v35 = v32 - v30;
              double v36 = v33 - v31;
              CGContextGetCTM(&v89, a2);
              float64x2_t v72 = vmlaq_n_f64(vmulq_laneq_f64(*(float64x2_t *)&v89.c, v70, 1), *(float64x2_t *)&v89.a, v70.f64[0]);
              float64x2_t v75 = vmlaq_n_f64(vmulq_laneq_f64(*(float64x2_t *)&v89.c, v73, 1), *(float64x2_t *)&v89.a, v73.f64[0]);
              float64x2_t v69 = vaddq_f64(*(float64x2_t *)&v89.tx, vmlaq_n_f64(vmulq_laneq_f64(*(float64x2_t *)&v89.c, v67, 1), *(float64x2_t *)&v89.a, v67.f64[0]));
              uint64_t v37 = 168;
              if (a3) {
                uint64_t v37 = 176;
              }
              unint64_t v38 = *(void *)(a1 + v37);
              if (v38) {
                BOOL v39 = v24;
              }
              else {
                BOOL v39 = 0;
              }
              if (v39) {
                CGColorRef CopyWithAlpha = CGColorCreateCopyWithAlpha((CGColorRef)v38, 1.0);
              }
              else {
                CGColorRef CopyWithAlpha = 0;
              }
              CFTypeRef info = v34;
              CFTypeRef cf = CopyWithAlpha;
              CGPatternCallbacks v81 = *(CGPatternCallbacks *)byte_1ED09DB40;
              *(float64x2_t *)&v80.a = v72;
              *(float64x2_t *)&v80.c = v75;
              *(float64x2_t *)&v80.tdouble x = v69;
              v91.origin.double x = v30;
              v91.origin.double y = v31;
              v91.size.double width = v35;
              v91.size.double height = v36;
              CGPatternRef v41 = CGPatternCreate(&info, v91, &v80, v87, v86, v26, v24, &v81);
              if (!v41)
              {
                if (info) {
                  CFRelease(info);
                }
                if (cf) {
                  CFRelease(cf);
                }
                return 0;
              }
              float v49 = v41;
              v80.a = 1.0;
              if (v38)
              {
                if (v24)
                {
                  if ((v38 & 0x8000000000000000) != 0) {
                    double Alpha = CGTaggedColorGetAlpha(v38, v42, v43, v44, v45, v46, v47, v48);
                  }
                  else {
                    double Alpha = *(double *)(v38 + 8 * *(void *)(v38 + 56) + 56);
                  }
                  CGColorSpaceRef ColorSpace = 0;
                  v80.a = Alpha;
                }
                else
                {
                  if ((v38 & 0x8000000000000000) != 0)
                  {
                    CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v38, v42, v43, v44, v45, v46, v47, v48);
                    double v60 = CGTaggedColorGetAlpha(v38, v53, v54, v55, v56, v57, v58, v59);
                  }
                  else
                  {
                    CGColorSpaceRef ColorSpace = *(CGColorSpace **)(v38 + 24);
                    double v60 = *(double *)(v38 + 8 * *(void *)(v38 + 56) + 56);
                  }
                  v80.a = v60;
                  if (ColorSpace)
                  {
                    Components = (CGAffineTransform *)CGColorGetComponents((CGColorRef)v38);
LABEL_73:
                    CGColorSpaceRef Pattern = CGColorSpaceCreatePattern(ColorSpace);
                    if (Pattern)
                    {
                      uint64_t v63 = Pattern;
                      uint64_t ShapePath = CGPDFNodeCreateShapePath(a1);
                      BOOL v51 = ShapePath != 0;
                      if (ShapePath)
                      {
                        unint64_t v65 = (const CGPath *)ShapePath;
                        CGContextSaveGState(a2);
                        CGPDFNodeApplyClipToContext(a1, a2);
                        CGContextAddPath(a2, v65);
                        if (a3)
                        {
                          CGContextSetLineWidth(a2, *(CGFloat *)(a1 + 144));
                          CGContextSetLineCap(a2, *(CGLineCap *)(a1 + 160));
                          CGContextSetLineJoin(a2, *(CGLineJoin *)(a1 + 164));
                          CGContextSetMiterLimit(a2, *(CGFloat *)(a1 + 152));
                          CGContextSetStrokeColorSpace(a2, v63);
                          CGContextSetStrokePattern(a2, v49, &Components->a);
                          CGPathDrawingMode v66 = kCGPathStroke;
                        }
                        else
                        {
                          CGContextSetFillColorSpace(a2, v63);
                          CGContextSetFillPattern(a2, v49, &Components->a);
                          CGPathDrawingMode v66 = *(unsigned __int8 *)(a1 + 136);
                        }
                        CGContextDrawPath(a2, v66);
                        CGContextRestoreGState(a2);
                        CFRelease(v65);
                      }
                      CGColorSpaceRelease(v63);
                    }
                    else
                    {
                      BOOL v51 = 0;
                    }
                    CFRelease(v49);
                    return (CGPDFContentStreamRef)v51;
                  }
                }
              }
              else
              {
                CGColorSpaceRef ColorSpace = 0;
              }
              Components = &v80;
              goto LABEL_73;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t CGPDFNodeCreateShapePath(uint64_t a1)
{
  size_t v4 = (_DWORD *)a1;
  if (!a1 || *(_DWORD *)a1 != 258) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2)
  {
    CFRetain(*(CFTypeRef *)(a1 + 128));
  }
  else
  {
    CGPDFNodeLoadPaths(&v4, 1u);
    uint64_t v2 = *(void *)(a1 + 128);
    if (v2) {
      CFRetain(*(CFTypeRef *)(a1 + 128));
    }
    CGPDFNodePurgePaths((uint64_t *)&v4, 1u);
  }
  return v2;
}

void CGPDFNodeLoadPaths(_DWORD **a1, unsigned int a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  CGPDFNodeCollectShapesWithoutPaths(a1, a2, Mutable);
  uint64_t Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    int64_t v6 = Count;
    v32.location = 0;
    v32.length = Count;
    CFArraySortValues(Mutable, v32, (CFComparatorFunction)comparePDFObjectID, 0);
    uint64_t v7 = malloc_type_calloc(v6, 4uLL, 0x100004052888210uLL);
    uint64_t v8 = malloc_type_calloc(v6, 8uLL, 0x6004044C4A2DFuLL);
    CFIndex v9 = 0;
    unsigned int v10 = 0;
    int v11 = 0;
    unsigned int v12 = 1;
    do
    {
      int v13 = *((_DWORD *)CFArrayGetValueAtIndex(Mutable, v9) + 30);
      if (v12 == 1 || v13 != v11)
      {
        v7[v10++] = v13;
        int v11 = v13;
      }
      CFIndex v9 = v12;
      BOOL v14 = v6 <= v12++;
    }
    while (!v14);
    ValueAtIndedouble x = CFArrayGetValueAtIndex(Mutable, 0);
    if (ValueAtIndex)
    {
      while (*(_DWORD *)ValueAtIndex != 517)
      {
        ValueAtIndedouble x = (void *)ValueAtIndex[1];
        if (!ValueAtIndex) {
          goto LABEL_24;
        }
      }
      uint64_t v16 = ValueAtIndex[13];
      if (v16)
      {
        uint64_t v17 = *(void *)(v16 + 16);
        if (v17)
        {
          float64x2_t v18 = CPPDFContextCreate();
          if (v18)
          {
            uint64_t v19 = (uint64_t)v18;
            *(CGRect *)v18->i8 = CGPDFPageGetBoxRect((CGPDFPageRef)v17, kCGPDFCropBox);
            pthread_mutex_lock((pthread_mutex_t *)(v17 + 216));
            int v20 = *(_DWORD *)(v17 + 48);
            pthread_mutex_unlock((pthread_mutex_t *)(v17 + 216));
            *(_DWORD *)(v19 + 2284) = v20;
            *(void *)(v19 + 22++*(_DWORD *)(result + 88) = v17;
            *(void *)(v19 + 2344) = 0;
            *(void *)(v19 + 2304) = v10;
            *(void *)(v19 + 2320) = v7;
            *(void *)(v19 + 2328) = v8;
            *(void *)(v19 + 2312) = 0;
            *(unsigned char *)(v19 + 2336) = 0;
            float64x2_t v21 = CGPDFOperatorTableCreate();
            AddLazyPdfOperators(v21);
            float64x2_t v22 = (CGPDFContentStream *)CGPDFContentStreamCreate(*(void *)(v17 + 40));
            uint64_t v23 = *(unsigned int *)(v19 + 2056);
            *(_DWORD *)(v19 + 2056) = v23 + 1;
            *(void *)(v19 + 8 * v23 + 56) = v22;
            BOOL v24 = CGPDFScannerCreate(v22, v21, (void *)v19);
            *(unsigned char *)(*(void *)(v19 + 40) + 8) = 1;
            CPPDFContextSaveGState(v19);
            *(unsigned char *)(*(void *)(v19 + 40) + 8) = 0;
            CGPDFScannerScan(v24);
            CPPDFContextRestoreGState(v19);
            uint64_t v25 = *(void *)(v19 + 40);
            if (v25) {
              *(unsigned char *)(v25 + 8) = 0;
            }
            if (v22) {
              CFRelease(v22);
            }
            if (v24) {
              CFRelease(v24);
            }
            if (v21) {
              CFRelease(v21);
            }
            CPPDFContextRelease(v19);
          }
        }
      }
    }
LABEL_24:
    CFIndex v26 = 0;
    int v27 = 0;
    unsigned int v28 = 1;
    do
    {
      uint64_t v29 = CFArrayGetValueAtIndex(Mutable, v26);
      if (*((_DWORD *)v29 + 30) == v7[v27])
      {
        double v30 = (const void *)v8[v27];
        v29[16] = v30;
        if (v28 != 1 && v30) {
          CFRetain(v30);
        }
      }
      else
      {
        v29[16] = v8[++v27];
      }
      CFIndex v26 = v28;
      BOOL v14 = v6 <= v28++;
    }
    while (!v14);
    free(v8);
    free(v7);
  }

  CFRelease(Mutable);
}

void CGPDFNodePurgePaths(uint64_t *a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    do
    {
      uint64_t v4 = *a1;
      if (*a1)
      {
        if (*(_DWORD *)v4 == 258)
        {
          size_t v5 = *(const void **)(v4 + 128);
          if (v5) {
            CFRelease(v5);
          }
          *(void *)(v4 + 128) = 0;
        }
        else if ((*(_DWORD *)v4 & 0x200) != 0)
        {
          CGPDFNodePurgePaths(*(void *)(v4 + 56), *(unsigned int *)(v4 + 44));
        }
      }
      ++a1;
      --v3;
    }
    while (v3);
  }
}

void CGPDFNodeCollectShapesWithoutPaths(_DWORD **a1, unsigned int a2, __CFArray *a3)
{
  if (a2)
  {
    uint64_t v5 = a2;
    do
    {
      int64_t v6 = *a1;
      if (*a1)
      {
        if (*v6 == 258)
        {
          if (!*((void *)v6 + 16)) {
            CFArrayAppendValue(a3, v6);
          }
        }
        else if ((*v6 & 0x200) != 0)
        {
          CGPDFNodeCollectShapesWithoutPaths(*((void *)v6 + 7), v6[11], a3);
        }
      }
      ++a1;
      --v5;
    }
    while (v5);
  }
}

uint64_t comparePDFObjectID(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 120);
  unsigned int v3 = *(_DWORD *)(a2 + 120);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return -1;
  }
}

uint64_t CGPDFNodeExtractPDFObject(uint64_t result, void *a2, void *a3)
{
  if (!result || (int v3 = *(_DWORD *)(result + 8), v3 == 12))
  {
    uint64_t v4 = 0;
    *a2 = 0;
LABEL_4:
    *a3 = v4;
    return result;
  }
  *a2 = 0;
  *a3 = 0;
  if (v3 == 8)
  {
    uint64_t v4 = *(void *)(result + 32);
    goto LABEL_4;
  }
  if (v3 == 9)
  {
    uint64_t v4 = *(void *)(result + 32);
    *a2 = v4;
    if (v4) {
      uint64_t v4 = *(void *)(v4 + 48);
    }
    goto LABEL_4;
  }
  return result;
}

BOOL CGPDFNodeDrawShadingInContext(uint64_t a1, CGContext *a2, CGPDFDictionaryRef dict, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if ((a4 & 0xFFFFFFFFFFFFFFFELL) == 2)
  {
    CGPDFObjectRef value = 0;
    CGColorSpaceRef v58 = 0;
    if (CGPDFDictionaryGetObject(dict, "ColorSpace", &value))
    {
      CreateColorSpaceFromObject(value, &v58);
      CGColorSpaceRef v12 = v58;
      if (v58)
      {
        CGPDFArrayRef array = 0;
        if (CGPDFDictionaryGetArray(dict, "BBox", &array))
        {
          size_t v13 = 0;
          BOOL v14 = &v59;
          while (CGPDFArrayGetNumber(array, v13, &v14->a))
          {
            ++v13;
            BOOL v14 = (CGAffineTransform *)((char *)v14 + 8);
            if (v13 == 4)
            {
              double a = v59.a;
              double b = v59.b;
              double v17 = v59.c - v59.a;
              double v18 = v59.d - v59.b;
              goto LABEL_12;
            }
          }
        }
        double v17 = 0.0;
        double a = INFINITY;
        double b = INFINITY;
        double v18 = 0.0;
LABEL_12:
        CGPDFObjectRef v55 = 0;
        if (CGPDFDictionaryGetObject(dict, "Function", &v55))
        {
          Function = CGPDFFunctionCreateFunction((char *)v55);
          if (Function)
          {
            float64x2_t v22 = Function;
            CGPDFArrayRef v54 = 0;
            if (CGPDFDictionaryGetArray(dict, "Coords", &v54))
            {
              CFTypeRef cf = (double **)v22;
              size_t v23 = 0;
              if (a4 == 2) {
                uint64_t v24 = 4;
              }
              else {
                uint64_t v24 = 6;
              }
              uint64_t v25 = &v59;
              while (CGPDFArrayGetNumber(v54, v23, &v25->a))
              {
                ++v23;
                uint64_t v25 = (CGAffineTransform *)((char *)v25 + 8);
                if (v24 == v23) {
                  goto LABEL_24;
                }
              }
              if (v24 != v23)
              {
                CFIndex v26 = cf;
                goto LABEL_44;
              }
LABEL_24:
              CGPDFArrayRef v53 = 0;
              if (CGPDFDictionaryGetArray(dict, "Extend", &v53))
              {
                CGPDFBoolean v52 = 0;
                BOOL Boolean = CGPDFArrayGetBoolean(v53, 0, &v52);
                if (v52) {
                  uint64_t v29 = Boolean;
                }
                else {
                  uint64_t v29 = 0;
                }
                BOOL v30 = CGPDFArrayGetBoolean(v53, 1uLL, &v52);
                if (v52) {
                  uint64_t v31 = v30;
                }
                else {
                  uint64_t v31 = 0;
                }
              }
              else
              {
                uint64_t v29 = 0;
                uint64_t v31 = 0;
              }
              if (a4 == 2) {
                uint64_t AxialInternal = CGShadingCreateAxialInternal(v12, 0, 0, cf[5], cf, v29, v31, v27, v59.a, v59.b, v59.c, v59.d);
              }
              else {
                uint64_t AxialInternal = CGShadingCreateRadialInternal(v12, 0, 0, cf[5], cf, v29, v31, v27, v59.a, v59.b, v59.c, v59.d, v59.tx, v59.ty);
              }
              double v33 = (CGShading *)AxialInternal;
              CFRelease(cf);
              if (v33)
              {
                uint64_t ShapePath = CGPDFNodeCreateShapePath(a1);
                BOOL v19 = ShapePath != 0;
                if (ShapePath)
                {
                  double v35 = (const CGPath *)ShapePath;
                  CGContextSaveGState(a2);
                  CGPDFNodeApplyClipToContext(a1, a2);
                  if (a != INFINITY && b != INFINITY)
                  {
                    CFMutableArrayRef Mutable = CGPathCreateMutable();
                    v61.origin.double x = a;
                    v61.origin.double y = b;
                    v61.size.double width = v17;
                    v61.size.double height = v18;
                    CGPathAddRect(Mutable, (const CGAffineTransform *)a5, v61);
                    CGContextAddPath(a2, Mutable);
                    clip((uint64_t)a2, 0, v37, v38, v39, v40, v41, v42);
                    if (Mutable) {
                      CFRelease(Mutable);
                    }
                  }
                  CGContextAddPath(a2, v35);
                  if (a6)
                  {
                    CGContextSetLineWidth(a2, *(CGFloat *)(a1 + 144));
                    CGContextSetLineCap(a2, *(CGLineCap *)(a1 + 160));
                    CGContextSetLineJoin(a2, *(CGLineJoin *)(a1 + 164));
                    CGContextSetMiterLimit(a2, *(CGFloat *)(a1 + 152));
                    CGContextReplacePathWithStrokedPath(a2);
                    uint64_t v49 = 0;
                  }
                  else
                  {
                    uint64_t v49 = *(unsigned __int8 *)(a1 + 136);
                  }
                  clip((uint64_t)a2, v49, v43, v44, v45, v46, v47, v48);
                  long long v50 = *(_OWORD *)(a5 + 16);
                  *(_OWORD *)&v59.double a = *(_OWORD *)a5;
                  *(_OWORD *)&v59.c = v50;
                  *(_OWORD *)&v59.tdouble x = *(_OWORD *)(a5 + 32);
                  CGContextConcatCTM(a2, &v59);
                  CGContextDrawShading(a2, v33);
                  CGContextRestoreGState(a2);
                  CFRelease(v35);
                }
                CFRelease(v33);
                goto LABEL_46;
              }
            }
            else
            {
              CFIndex v26 = v22;
LABEL_44:
              CFRelease(v26);
            }
          }
        }
        BOOL v19 = 0;
LABEL_46:
        CGColorSpaceRelease(v12);
        return v19;
      }
    }
  }
  return 0;
}

void CGPDFNodeReleaseTile(uint64_t a1)
{
  unsigned int v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  int v3 = *(const void **)(a1 + 8);
  if (v3)
  {
    CFRelease(v3);
  }
}

void CGPDFNodeDrawTile(CGPDFContentStreamRef *a1, CGContextRef c)
{
  uint64_t v4 = a1[1];
  if (v4) {
    CGContextSetFillColorWithColor(c, v4);
  }
  CGContextBeginPath(c);
  BOOL v5 = CGPDFOperatorTableCreate();
  CGPDFNodeInitOperatorTable(v5);
  int64_t v6 = CGPDFScannerCreate(*a1, v5, c);
  if (v6)
  {
    uint64_t v7 = v6;
    CGPDFScannerScan(v6);
    CFRelease(v7);
  }
  if (v5)
  {
    CFRelease(v5);
  }
}

void CGPDFNodeInitOperatorTable(CGPDFOperatorTable *a1)
{
  CGPDFOperatorTableSetCallback(a1, "b", (CGPDFOperatorCallback)op_b_22541);
  CGPDFOperatorTableSetCallback(a1, "b*", (CGPDFOperatorCallback)op_bstar_22540);
  CGPDFOperatorTableSetCallback(a1, "B", (CGPDFOperatorCallback)op_B_22539);
  CGPDFOperatorTableSetCallback(a1, "B*", (CGPDFOperatorCallback)op_Bstar_22538);
  CGPDFOperatorTableSetCallback(a1, "c", (CGPDFOperatorCallback)op_c_22537);
  CGPDFOperatorTableSetCallback(a1, "cm", (CGPDFOperatorCallback)op_cm_22536);
  CGPDFOperatorTableSetCallback(a1, "cs", (CGPDFOperatorCallback)op_cs_22535);
  CGPDFOperatorTableSetCallback(a1, "CS", (CGPDFOperatorCallback)op_CS_22533);
  CGPDFOperatorTableSetCallback(a1, "d", (CGPDFOperatorCallback)op_d_22532);
  CGPDFOperatorTableSetCallback(a1, "Do", (CGPDFOperatorCallback)op_Do_22528);
  CGPDFOperatorTableSetCallback(a1, "EI", (CGPDFOperatorCallback)op_EI_22527);
  CGPDFOperatorTableSetCallback(a1, "f", (CGPDFOperatorCallback)op_f_22526);
  CGPDFOperatorTableSetCallback(a1, "f*", (CGPDFOperatorCallback)op_fstar_22525);
  CGPDFOperatorTableSetCallback(a1, "F", (CGPDFOperatorCallback)op_f_22526);
  CGPDFOperatorTableSetCallback(a1, "g", (CGPDFOperatorCallback)op_g_22524);
  CGPDFOperatorTableSetCallback(a1, "G", (CGPDFOperatorCallback)op_G_22523);
  CGPDFOperatorTableSetCallback(a1, "gs", (CGPDFOperatorCallback)op_gs_22514);
  CGPDFOperatorTableSetCallback(a1, "h", (CGPDFOperatorCallback)op_h_22513);
  CGPDFOperatorTableSetCallback(a1, "j", (CGPDFOperatorCallback)op_j_22512);
  CGPDFOperatorTableSetCallback(a1, "J", (CGPDFOperatorCallback)op_J_22511);
  CGPDFOperatorTableSetCallback(a1, "k", (CGPDFOperatorCallback)op_k_22510);
  CGPDFOperatorTableSetCallback(a1, "K", (CGPDFOperatorCallback)op_K_22509);
  CGPDFOperatorTableSetCallback(a1, "l", (CGPDFOperatorCallback)op_l_22508);
  CGPDFOperatorTableSetCallback(a1, "m", (CGPDFOperatorCallback)op_m_22507);
  CGPDFOperatorTableSetCallback(a1, "M", (CGPDFOperatorCallback)op_M_22506);
  CGPDFOperatorTableSetCallback(a1, "n", (CGPDFOperatorCallback)op_n_22505);
  CGPDFOperatorTableSetCallback(a1, "q", (CGPDFOperatorCallback)op_q_22504);
  CGPDFOperatorTableSetCallback(a1, "Q", (CGPDFOperatorCallback)op_Q_22503);
  CGPDFOperatorTableSetCallback(a1, "re", (CGPDFOperatorCallback)op_re_22502);
  CGPDFOperatorTableSetCallback(a1, "rg", (CGPDFOperatorCallback)op_rg_22501);
  CGPDFOperatorTableSetCallback(a1, "RG", (CGPDFOperatorCallback)op_RG_22500);
  CGPDFOperatorTableSetCallback(a1, "s", (CGPDFOperatorCallback)op_s_22499);
  CGPDFOperatorTableSetCallback(a1, "S", (CGPDFOperatorCallback)op_S_22498);
  CGPDFOperatorTableSetCallback(a1, "sc", (CGPDFOperatorCallback)op_scn_22497);
  CGPDFOperatorTableSetCallback(a1, "scn", (CGPDFOperatorCallback)op_scn_22497);
  CGPDFOperatorTableSetCallback(a1, "SC", (CGPDFOperatorCallback)op_SCN_22495);
  CGPDFOperatorTableSetCallback(a1, "SCN", (CGPDFOperatorCallback)op_SCN_22495);
  CGPDFOperatorTableSetCallback(a1, "v", (CGPDFOperatorCallback)op_v_22494);
  CGPDFOperatorTableSetCallback(a1, "w", (CGPDFOperatorCallback)op_w_22493);
  CGPDFOperatorTableSetCallback(a1, "W", (CGPDFOperatorCallback)op_W_22492);
  CGPDFOperatorTableSetCallback(a1, "W*", (CGPDFOperatorCallback)op_Wstar_22491);

  CGPDFOperatorTableSetCallback(a1, "y", (CGPDFOperatorCallback)op_y_22490);
}

void op_y_22490(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFReal v6 = 0.0;
  CGPDFReal v7 = 0.0;
  CGFloat v4 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v6)
    && CGPDFScannerPopNumber(a1, &v7)
    && !CGContextIsPathEmpty(a2))
  {
    CGContextAddCurveToPoint(a2, v7, v6, value, v4, value, v4);
  }
}

void op_Wstar_22491(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void op_W_22492(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void op_w_22493(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)) {
    CGContextSetLineWidth(a2, value);
  }
}

void op_v_22494(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFReal v7 = 0.0;
  CGPDFReal v8 = 0.0;
  CGFloat v5 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v5)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v7)
    && CGPDFScannerPopNumber(a1, &v8)
    && !CGContextIsPathEmpty(a2))
  {
    CGPoint PathCurrentPoint = CGContextGetPathCurrentPoint(a2);
    CGContextAddCurveToPoint(a2, PathCurrentPoint.x, PathCurrentPoint.y, v8, v7, value, v5);
  }
}

void op_SCN_22495(uint64_t a1, CGContext *a2)
{
}

void CGPDFNodeDrawColor(uint64_t a1, CGContext *a2, int a3)
{
  CGPDFReal value = 0.0;
  int v3 = *(_DWORD *)(a1 + 72);
  if (v3 <= 0)
  {
    pdf_error("stack underflow.");
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 80);
    unsigned int v6 = v3 - 1;
    *(_DWORD *)(a1 + 72) = v6;
    if (v5)
    {
      switch(*(_DWORD *)(v5 + 40 * v6 + 8))
      {
        case 3:
        case 0xC:
          double v9 = (double)*(uint64_t *)(v5 + 40 * v6 + 32);
          goto LABEL_9;
        case 4:
          double v9 = *(double *)(v5 + 40 * v6 + 32);
LABEL_9:
          CGPDFReal value = v9;
          unsigned int v10 = (double *)malloc_type_malloc(0x28uLL, 0x100004000313F17uLL);
          CGPDFObjectRef Resource = 0;
          v10[1] = 1.0;
          *unsigned int v10 = v9;
          int v12 = 1;
          goto LABEL_17;
        case 5:
          size_t v13 = *(CGPDFContentStream **)(a1 + 56);
          if (v13) {
            CGPDFObjectRef Resource = CGPDFContentStreamGetResource(v13, "Pattern", *(const char **)(v5 + 40 * v6 + 32));
          }
          else {
            CGPDFObjectRef Resource = 0;
          }
          unsigned int v10 = (double *)malloc_type_malloc(0x28uLL, 0x100004000313F17uLL);
          int v12 = 0;
          *unsigned int v10 = 1.0;
LABEL_17:
          while (CGPDFScannerPopNumber((CGPDFScannerRef)a1, &value))
          {
            if ((v12 + 1) >= 5) {
              unsigned int v10 = (double *)malloc_type_realloc(v10, 8 * (v12 + 2), 0x100004000313F17uLL);
            }
            memmove(v10 + 1, v10, 8 * (v12 + 1));
            *unsigned int v10 = value;
            ++v12;
          }
          if (Resource)
          {
            CGPatternCallbacks v16 = *(CGPatternCallbacks *)byte_1ED09DB58;
            v19.origin.double x = 0.0;
            v19.origin.double y = 0.0;
            v19.size.double width = 1.0;
            v19.size.double height = 1.0;
            BOOL v14 = CGPatternCreate(0, v19, (CGAffineTransform *)&CGAffineTransformIdentity, 1.0, 1.0, kCGPatternTilingConstantSpacingMinimalDistortion, v12 == 0, &v16);
            if (v14)
            {
              float64x2_t v15 = v14;
              if (a3) {
                CGContextSetStrokePattern(a2, v14, v10);
              }
              else {
                CGContextSetFillPattern(a2, v14, v10);
              }
              CFRelease(v15);
            }
          }
          else if (a3)
          {
            CGContextSetStrokeColor(a2, v10);
          }
          else
          {
            CGContextSetFillColor(a2, v10);
          }
          free(v10);
          break;
        default:
          return;
      }
    }
  }
}

void op_scn_22497(uint64_t a1, CGContext *a2)
{
}

void op_S_22498(int a1, CGContextRef c)
{
}

void op_s_22499(int a1, CGContextRef c)
{
  if (!CGContextIsPathEmpty(c)) {
    CGContextClosePath(c);
  }

  CGContextDrawPath(c, kCGPathStroke);
}

void op_RG_22500(CGPDFScanner *a1, CGContext *a2)
{
  components[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  double v11 = 0.0;
  components[3] = 1.0;
  BOOL v4 = CGPDFScannerPopNumber(a1, &v11);
  double v5 = v11;
  if (!v4) {
    double v5 = 0.0;
  }
  components[2] = v5;
  BOOL v6 = CGPDFScannerPopNumber(a1, &v11);
  double v7 = v11;
  if (!v6) {
    double v7 = 0.0;
  }
  components[1] = v7;
  BOOL v8 = CGPDFScannerPopNumber(a1, &v11);
  double v9 = v11;
  if (!v8) {
    double v9 = 0.0;
  }
  components[0] = v9;
  CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CGContextSetStrokeColorSpace(a2, DeviceRGB);
  CGContextSetStrokeColor(a2, components);
  CGColorSpaceRelease(DeviceRGB);
}

void op_rg_22501(CGPDFScanner *a1, CGContext *a2)
{
  components[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  double v11 = 0.0;
  components[3] = 1.0;
  BOOL v4 = CGPDFScannerPopNumber(a1, &v11);
  double v5 = v11;
  if (!v4) {
    double v5 = 0.0;
  }
  components[2] = v5;
  BOOL v6 = CGPDFScannerPopNumber(a1, &v11);
  double v7 = v11;
  if (!v6) {
    double v7 = 0.0;
  }
  components[1] = v7;
  BOOL v8 = CGPDFScannerPopNumber(a1, &v11);
  double v9 = v11;
  if (!v8) {
    double v9 = 0.0;
  }
  components[0] = v9;
  CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CGContextSetFillColorSpace(a2, DeviceRGB);
  CGContextSetFillColor(a2, components);
  CGColorSpaceRelease(DeviceRGB);
}

void op_re_22502(CGPDFScanner *a1, CGContext *a2)
{
  memset(&v3, 0, sizeof(v3));
  if (common_ReadCGRect(a1, &v3.origin.x)) {
    CGContextAddRect(a2, v3);
  }
}

void op_Q_22503(int a1, CGContextRef c)
{
}

void op_q_22504(int a1, CGContextRef c)
{
}

void op_n_22505(int a1, CGContextRef c)
{
}

void op_M_22506(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)) {
    CGContextSetMiterLimit(a2, value);
  }
}

void op_m_22507(CGPDFScanner *a1, CGContext *a2)
{
  CGFloat y = 0.0;
  CGPDFReal value = 0.0;
  if (!CGPDFScannerPopNumber(a1, &y)) {
    CGFloat y = 0.0;
  }
  if (CGPDFScannerPopNumber(a1, &value))
  {
    CGFloat v4 = value;
  }
  else
  {
    CGPDFReal value = 0.0;
    CGFloat v4 = 0.0;
  }
  CGContextMoveToPoint(a2, v4, y);
}

void op_l_22508(CGPDFScanner *a1, CGContext *a2)
{
  CGFloat v4 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4) && CGPDFScannerPopNumber(a1, &value) && !CGContextIsPathEmpty(a2)) {
    CGContextAddLineToPoint(a2, value, v4);
  }
}

void op_K_22509(CGPDFScanner *a1, CGContext *a2)
{
  CGFloat components[5] = *(CGFloat *)MEMORY[0x1E4F143B8];
  CGPDFReal value = 0.0;
  components[4] = 1.0;
  BOOL v4 = CGPDFScannerPopNumber(a1, &value);
  double v5 = value;
  if (!v4) {
    double v5 = 1.0;
  }
  components[3] = v5;
  BOOL v6 = CGPDFScannerPopNumber(a1, &value);
  double v7 = value;
  if (!v6) {
    double v7 = 0.0;
  }
  components[2] = v7;
  BOOL v8 = CGPDFScannerPopNumber(a1, &value);
  double v9 = value;
  if (!v8) {
    double v9 = 0.0;
  }
  components[1] = v9;
  BOOL v10 = CGPDFScannerPopNumber(a1, &value);
  double v11 = value;
  if (!v10) {
    double v11 = 0.0;
  }
  components[0] = v11;
  CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  CGContextSetStrokeColorSpace(a2, DeviceCMYK);
  CGContextSetStrokeColor(a2, components);
  CGColorSpaceRelease(DeviceCMYK);
}

void op_k_22510(CGPDFScanner *a1, CGContext *a2)
{
  CGFloat components[5] = *(CGFloat *)MEMORY[0x1E4F143B8];
  CGPDFReal value = 0.0;
  components[4] = 1.0;
  BOOL v4 = CGPDFScannerPopNumber(a1, &value);
  double v5 = value;
  if (!v4) {
    double v5 = 1.0;
  }
  components[3] = v5;
  BOOL v6 = CGPDFScannerPopNumber(a1, &value);
  double v7 = value;
  if (!v6) {
    double v7 = 0.0;
  }
  components[2] = v7;
  BOOL v8 = CGPDFScannerPopNumber(a1, &value);
  double v9 = value;
  if (!v8) {
    double v9 = 0.0;
  }
  components[1] = v9;
  BOOL v10 = CGPDFScannerPopNumber(a1, &value);
  double v11 = value;
  if (!v10) {
    double v11 = 0.0;
  }
  components[0] = v11;
  CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  CGContextSetFillColorSpace(a2, DeviceCMYK);
  CGContextSetFillColor(a2, components);
  CGColorSpaceRelease(DeviceCMYK);
}

void op_J_22511(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFInteger value = 0;
  if (CGPDFScannerPopInteger(a1, &value) && (unint64_t)value <= 2) {
    CGContextSetLineCap(a2, (CGLineCap)value);
  }
}

void op_j_22512(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFInteger value = 0;
  if (CGPDFScannerPopInteger(a1, &value) && (unint64_t)value <= 2) {
    CGContextSetLineJoin(a2, (CGLineJoin)value);
  }
}

void op_h_22513(int a1, CGContextRef c)
{
  if (!CGContextIsPathEmpty(c))
  {
    CGContextClosePath(c);
  }
}

void op_gs_22514(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFInteger value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    BOOL v4 = (CGPDFContentStream *)*((void *)a1 + 7);
    if (v4)
    {
      CGPDFObjectRef Resource = CGPDFContentStreamGetResource(v4, "ExtGState", value);
      if (Resource)
      {
        if (*((_DWORD *)Resource + 2) == 8)
        {
          BOOL v6 = (CGPDFDictionary *)*((void *)Resource + 4);
          alphdouble a = 0.0;
          if (CGPDFDictionaryGetNumber(v6, "ca", &alpha)) {
            CGContextSetAlpha(a2, alpha);
          }
          if (CGPDFDictionaryGetNumber(v6, "CA", &alpha)) {
            CGContextSetAlpha(a2, alpha);
          }
          if (CGPDFDictionaryGetNumber(v6, "LW", &alpha)) {
            CGContextSetLineWidth(a2, alpha);
          }
          if (CGPDFDictionaryGetNumber(v6, "ML", &alpha)) {
            CGContextSetMiterLimit(a2, alpha);
          }
          CGPDFInteger v20 = 0;
          if (CGPDFDictionaryGetInteger(v6, "LC", &v20) && (unint64_t)v20 <= 2) {
            CGContextSetLineCap(a2, (CGLineCap)v20);
          }
          if (CGPDFDictionaryGetInteger(v6, "LJ", &v20) && (unint64_t)v20 <= 2) {
            CGContextSetLineJoin(a2, (CGLineJoin)v20);
          }
          CGPDFArrayRef array = 0;
          if (CGPDFDictionaryGetArray(v6, "D", &array))
          {
            CGPDFReal phase = 0.0;
            CGPDFArrayRef v18 = 0;
            if (CGPDFArrayGetArray(array, 0, &v18) && CGPDFArrayGetNumber(array, 1uLL, &phase))
            {
              if (v18)
              {
                unint64_t v7 = *((void *)v18 + 2);
                BOOL v8 = (CGPDFReal *)malloc_type_malloc(8 * v7, 0x100004000313F17uLL);
                if (v7)
                {
                  size_t v9 = 0;
                  unsigned int v10 = 1;
                  do
                  {
                    CGPDFReal v16 = 0.0;
                    if (!CGPDFArrayGetNumber(v18, v9, &v16)) {
                      break;
                    }
                    v8[v9] = v16;
                    size_t v9 = v10;
                  }
                  while (v7 > v10++);
                  if (v7 != v9) {
                    goto LABEL_32;
                  }
                  CGFloat v12 = phase;
                  size_t v13 = a2;
                  BOOL v14 = v8;
                  size_t v15 = v7;
LABEL_31:
                  CGContextSetLineDash(v13, v12, v14, v15);
LABEL_32:
                  free(v8);
                  return;
                }
              }
              else
              {
                BOOL v8 = (CGPDFReal *)malloc_type_malloc(0, 0x100004000313F17uLL);
              }
              CGFloat v12 = phase;
              size_t v13 = a2;
              BOOL v14 = v8;
              size_t v15 = 0;
              goto LABEL_31;
            }
          }
        }
      }
    }
  }
}

void op_G_22523(CGPDFScanner *a1, CGContext *a2)
{
  components[2] = *(CGFloat *)MEMORY[0x1E4F143B8];
  double v6 = 0.0;
  components[1] = 1.0;
  BOOL v3 = CGPDFScannerPopNumber(a1, &v6);
  double v4 = v6;
  if (!v3) {
    double v4 = 0.0;
  }
  components[0] = v4;
  DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
  CGContextSetStrokeColorSpace(a2, DeviceGray);
  CGContextSetStrokeColor(a2, components);
  CGColorSpaceRelease(DeviceGray);
}

void op_g_22524(CGPDFScanner *a1, CGContext *a2)
{
  components[2] = *(CGFloat *)MEMORY[0x1E4F143B8];
  double v6 = 0.0;
  components[1] = 1.0;
  BOOL v3 = CGPDFScannerPopNumber(a1, &v6);
  double v4 = v6;
  if (!v3) {
    double v4 = 0.0;
  }
  components[0] = v4;
  DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
  CGContextSetFillColorSpace(a2, DeviceGray);
  CGContextSetFillColor(a2, components);
  CGColorSpaceRelease(DeviceGray);
}

void op_fstar_22525(int a1, CGContextRef c)
{
}

void op_f_22526(int a1, CGContextRef c)
{
}

__n128 op_EI_22527(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFStreamRef value = 0;
  if (CGPDFScannerPopStream(a1, &value))
  {
    memset(&v9[2], 0, 32);
    v9[0] = 0u;
    v9[1] = CPRangeNull;
    LODWORD(v9[0]) = 257;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    __asm { FMOV            V0.2D, #1.0 }
    long long v12 = _Q0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    CGPDFStreamRef v16 = value;
    CGAffineTransform v18 = CGAffineTransformIdentity;
    uint64_t v17 = 0;
    uint64_t v19 = 0x3FF0000000000000;
    uint64_t v20 = 0;
    CGPDFNodeDrawImageInContext((uint64_t)v9, a2);
  }
  return result;
}

__n128 op_Do_22528(CGPDFScanner *a1, CGContext *a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  CGPDFStreamRef value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    double v5 = (CGPDFContentStream *)*((void *)a1 + 7);
    CGPDFObjectRef Resource = CGPDFContentStreamGetResource(v5, "XObject", value);
    if (Resource)
    {
      if (*((_DWORD *)Resource + 2) == 9)
      {
        unint64_t v7 = (CGPDFStream *)*((void *)Resource + 4);
        if (v7)
        {
          BOOL v8 = (CGPDFDictionary *)*((void *)v7 + 6);
          if (v8)
          {
            __s1 = 0;
            if (CGPDFDictionaryGetName(v8, "Subtype", (const char **)&__s1))
            {
              size_t v9 = __s1;
              if (!strcmp(__s1, "Image"))
              {
                *(_OWORD *)&v29.tdouble x = 0u;
                long long v30 = 0u;
                *(_OWORD *)&v29.double a = 0u;
                *(_OWORD *)&v29.c = CPRangeNull;
                __asm { FMOV            V0.2D, #1.0 }
                long long v33 = _Q0;
                CGAffineTransform v39 = CGAffineTransformIdentity;
                LODWORD(v29.a) = 257;
                uint64_t v31 = 0;
                uint64_t v32 = 0;
                uint64_t v34 = 0;
                uint64_t v35 = 0;
                uint64_t v36 = 0;
                uint64_t v37 = v7;
                uint64_t v38 = 0;
                uint64_t v40 = 0x3FF0000000000000;
                uint64_t v41 = 0;
                CGPDFNodeDrawImageInContext((uint64_t)&v29, a2);
              }
              else if (!strcmp(v9, "Form"))
              {
                CGPDFDictionaryRef streamResources = 0;
                if (CGPDFDictionaryGetDictionary(v8, "Resources", &streamResources))
                {
                  CGPDFContentStreamRef v10 = CGPDFContentStreamCreateWithStream(v7, streamResources, v5);
                  if (v10)
                  {
                    uint64_t v11 = v10;
                    long long v12 = CGPDFOperatorTableCreate();
                    CGPDFNodeInitOperatorTable();
                    CGPDFScannerRef v13 = CGPDFScannerCreate(v11, v12, a2);
                    if (v13)
                    {
                      uint64_t v14 = v13;
                      CGContextSaveGState(a2);
                      CGPDFArrayRef array = 0;
                      if (CGPDFDictionaryGetArray(v8, "Matrix", &array))
                      {
                        size_t v15 = 0;
                        CGPDFStreamRef v16 = &v29;
                        while (CGPDFArrayGetNumber(array, v15, &v16->a))
                        {
                          ++v15;
                          CGPDFStreamRef v16 = (CGAffineTransform *)((char *)v16 + 8);
                          if (v15 == 6)
                          {
                            CGAffineTransform v24 = v29;
                            CGContextConcatCTM(a2, &v24);
                            break;
                          }
                        }
                      }
                      if (CGPDFDictionaryGetArray(v8, "BBox", &array))
                      {
                        size_t v17 = 0;
                        CGAffineTransform v18 = &v29;
                        while (CGPDFArrayGetNumber(array, v17, &v18->a))
                        {
                          ++v17;
                          CGAffineTransform v18 = (CGAffineTransform *)((char *)v18 + 8);
                          if (v17 == 4)
                          {
                            v43.origin.double x = v29.a;
                            v43.origin.CGFloat y = v29.b;
                            v43.size.double width = v29.c - v29.a;
                            v43.size.double height = v29.d - v29.b;
                            CGContextClipToRect(a2, v43);
                            break;
                          }
                        }
                      }
                      CGPDFScannerScan(v14);
                      CGContextRestoreGState(a2);
                      CFRelease(v14);
                    }
                    if (v12) {
                      CFRelease(v12);
                    }
                    CFRelease(v11);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void op_d_22532(CGPDFScanner *a1, CGContext *a2)
{
  CGPDFReal value = 0.0;
  CGPDFArrayRef array = 0;
  if (CGPDFScannerPopNumber(a1, &value) && CGPDFScannerPopArray(a1, &array))
  {
    if (array)
    {
      unint64_t v4 = *((void *)array + 2);
      double v5 = (CGPDFReal *)malloc_type_malloc(8 * v4, 0x100004000313F17uLL);
      if (v4)
      {
        size_t v6 = 0;
        unsigned int v7 = 1;
        do
        {
          CGPDFReal v13 = 0.0;
          if (!CGPDFArrayGetNumber(array, v6, &v13)) {
            break;
          }
          v5[v6] = v13;
          size_t v6 = v7;
        }
        while (v4 > v7++);
        if (v4 != v6) {
          goto LABEL_13;
        }
        CGFloat v9 = value;
        CGPDFContentStreamRef v10 = a2;
        uint64_t v11 = v5;
        size_t v12 = v4;
LABEL_12:
        CGContextSetLineDash(v10, v9, v11, v12);
LABEL_13:
        free(v5);
        return;
      }
    }
    else
    {
      double v5 = (CGPDFReal *)malloc_type_malloc(0, 0x100004000313F17uLL);
    }
    CGFloat v9 = value;
    CGPDFContentStreamRef v10 = a2;
    uint64_t v11 = v5;
    size_t v12 = 0;
    goto LABEL_12;
  }
}

void op_CS_22533(CGPDFScanner *a1, CGContext *a2)
{
  CGColorSpaceRef ColorSpace = CGPDFNodeCreateColorSpace(a1);
  if (ColorSpace)
  {
    unint64_t v4 = ColorSpace;
    CGContextSetStrokeColorSpace(a2, ColorSpace);
    CGColorSpaceRelease(v4);
  }
}

CGPDFContentStream *CGPDFNodeCreateColorSpace(CGPDFScanner *a1)
{
  CGPDFReal value = 0;
  BOOL v2 = CGPDFScannerPopName(a1, (const char **)&value);
  __n128 result = 0;
  if (v2)
  {
    if (value)
    {
      CGColorSpaceRef v4 = 0;
      CreateColorSpaceFromName(value, &v4);
      __n128 result = v4;
      if (!v4)
      {
        __n128 result = (CGPDFContentStream *)*((void *)a1 + 7);
        if (result)
        {
          __n128 result = CGPDFContentStreamGetResource(result, "ColorSpace", value);
          if (result)
          {
            CreateColorSpaceFromObject(result, &v4);
            return v4;
          }
        }
      }
    }
  }
  return result;
}

void op_cs_22535(CGPDFScanner *a1, CGContext *a2)
{
  CGColorSpaceRef ColorSpace = CGPDFNodeCreateColorSpace(a1);
  if (ColorSpace)
  {
    CGColorSpaceRef v4 = ColorSpace;
    CGContextSetFillColorSpace(a2, ColorSpace);
    CGColorSpaceRelease(v4);
  }
}

void op_cm_22536(CGPDFScanner *a1, CGContext *a2)
{
  memset(&v4, 0, sizeof(v4));
  if (common_ReadCGAffineTransform(a1, &v4.a))
  {
    CGAffineTransform v3 = v4;
    CGContextConcatCTM(a2, &v3);
  }
}

void op_c_22537(CGPDFScanner *a1, CGContext *a2)
{
  CGFloat v8 = 0.0;
  CGFloat v6 = 0.0;
  CGFloat v7 = 0.0;
  CGFloat v4 = 0.0;
  CGFloat v5 = 0.0;
  CGFloat y = 0.0;
  if (common_ReadCGPathCurve(a1, &v8, &v7, &v6, &v5, &v4, &y) && !CGContextIsPathEmpty(a2)) {
    CGContextAddCurveToPoint(a2, v8, v7, v6, v5, v4, y);
  }
}

void op_Bstar_22538(int a1, CGContextRef c)
{
}

void op_B_22539(int a1, CGContextRef c)
{
}

void op_bstar_22540(int a1, CGContextRef c)
{
  if (!CGContextIsPathEmpty(c)) {
    CGContextClosePath(c);
  }

  CGContextDrawPath(c, kCGPathEOFillStroke);
}

void op_b_22541(int a1, CGContextRef c)
{
  if (!CGContextIsPathEmpty(c)) {
    CGContextClosePath(c);
  }

  CGContextDrawPath(c, kCGPathFillStroke);
}

CFStringRef CGPDFNodeCreateImageName(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = a1;
  while (*(_DWORD *)v1 != 517)
  {
    uint64_t v1 = *(void *)(v1 + 8);
    if (!v1) {
      return 0;
    }
  }
  uint64_t v2 = *(void *)(v1 + 104);
  if (v2 && (uint64_t v3 = *(void *)(v2 + 16)) != 0) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"page%uimage%u", *(void *)(*(void *)(v3 + 40) + 8), a1);
  }
  else {
    return 0;
  }
}

uint64_t CGPDFNodeHasRectClips(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 1) & 1) == 0) {
    return 1;
  }
  uint64_t v1 = *(void *)(a1 + 104);
  if (!v1) {
    return 1;
  }
  do
  {
    uint64_t v2 = *(const CGPath **)(v1 + 8);
    if (v2)
    {
      CFRetain(*(CFTypeRef *)(v1 + 8));
      uint64_t v3 = (uint64_t)CGPathIsCongruentToARect(v2);
      CFRelease(v2);
    }
    else
    {
      uint64_t v3 = 1;
    }
    uint64_t v1 = *(void *)(v1 + 24);
  }
  while (v1 && (v3 & 1) != 0);
  return v3;
}

void *__CGPDFNodeCreateImageData_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageDestinationAddImage");
  }
  __n128 result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageDestinationAddImage");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageDestinationAddImage");
  }
  CGPDFNodeCreateImageData_f_37 = (uint64_t (*)(void, void, void))result;
  return result;
}

void *__CGPDFNodeCreateImageData_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageDestinationCreateWithData");
  }
  __n128 result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageDestinationCreateWithData");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageDestinationCreateWithData");
  }
  CGPDFNodeCreateImageData_f = (uint64_t (*)(void, void, void, void))result;
  return result;
}

BOOL CGPDFNodeIsEvenOddShape(BOOL result)
{
  if (result) {
    return *(_DWORD *)result == 258 && *(unsigned char *)(result + 136) != 0;
  }
  return result;
}

double CGPDFNodeGetShapeLineWidth(uint64_t a1)
{
  double result = 0.0;
  if (a1)
  {
    if (*(_DWORD *)a1 == 258) {
      return *(double *)(a1 + 144);
    }
  }
  return result;
}

double CGPDFNodeGetShapeMiterLimit(uint64_t a1)
{
  double result = 0.0;
  if (a1)
  {
    if (*(_DWORD *)a1 == 258) {
      return *(double *)(a1 + 152);
    }
  }
  return result;
}

_DWORD *CGPDFNodeGetShapeLineCap(_DWORD *result)
{
  if (result)
  {
    if (*result == 258) {
      return (_DWORD *)result[40];
    }
    else {
      return 0;
    }
  }
  return result;
}

_DWORD *CGPDFNodeGetShapeLineJoin(_DWORD *result)
{
  if (result)
  {
    if (*result == 258) {
      return (_DWORD *)result[41];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetShapeFillColor(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 258) {
      return *(void *)(result + 168);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetShapeStrokeColor(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 258) {
      return *(void *)(result + 176);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetClip(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 1)) {
      return *(void *)(result + 104);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeClipGetNextClip(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t CGPDFNodeClipCreatePath(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    CFRetain(*(CFTypeRef *)(a1 + 8));
  }
  return v1;
}

BOOL CGPDFNodeClipIsEvenOdd(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 16) != 0;
  }
  return result;
}

uint64_t CGPDFNodeGetListStyle(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1537)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 1) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return v1[1];
  }
  return result;
}

uint64_t CGPDFNodeGetAncestorOfTypeAndSubType(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = 0;
  if (a1 && (a2 & 0x400) != 0)
  {
    while (1)
    {
      if (*(_DWORD *)a1 == a2)
      {
        CGFloat v4 = *(_DWORD **)(a1 + 104);
        if (v4)
        {
          if (*v4 == a3) {
            break;
          }
        }
      }
      a1 = *(void *)(a1 + 8);
      if (!a1) {
        return 0;
      }
    }
    return a1;
  }
  return v3;
}

uint64_t CGPDFNodeGetListFirstItemNumber(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1537)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 1) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return v1[4];
  }
  return result;
}

uint64_t CGPDFNodeGetListFirstParagraph(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1537)
      {
        uint64_t v1 = *(void *)(result + 104);
        if (v1)
        {
          if (*(_DWORD *)v1 == 1) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(void *)(v1 + 8);
  }
  return result;
}

uint64_t CGPDFNodeGetListItemCount(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1537)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 1) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return v1[5];
  }
  return result;
}

uint64_t CGPDFNodeGetItemParagraphCount(uint64_t result, unsigned int a2)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1537)
      {
        uint64_t v2 = *(void *)(result + 104);
        if (v2)
        {
          if (*(_DWORD *)v2 == 1) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    if (*(_DWORD *)(v2 + 20) <= a2)
    {
      return 0;
    }
    else
    {
      uint64_t v3 = *(void *)(v2 + 24);
      int v4 = *(_DWORD *)(v3 + 4 * a2);
      if (a2) {
        return (v4 - *(_DWORD *)(v3 + 4 * (a2 - 1)));
      }
      else {
        return (v4 + 1);
      }
    }
  }
  return result;
}

uint64_t CGPDFNodeGetItemMarkerRange(uint64_t a1)
{
  if (!a1) {
    return CGPDFNodeGetTextRange(a1);
  }
  while (1)
  {
    if (*(_DWORD *)a1 == 1537)
    {
      uint64_t v1 = *(_DWORD **)(a1 + 104);
      if (v1)
      {
        if (*v1 == 1) {
          break;
        }
      }
    }
    a1 = *(void *)(a1 + 8);
    if (!a1) {
      return CGPDFNodeGetTextRange(a1);
    }
  }
  if (*(_DWORD *)(a1 + 44)
    && (uint64_t v3 = **(void **)(a1 + 56)) != 0
    && (*(unsigned char *)(v3 + 1) & 2) != 0
    && *(_DWORD *)(v3 + 44))
  {
    return CGPDFNodeGetTextRange(**(void **)(v3 + 56));
  }
  else
  {
    return CGPDFNodeGetTextRange(0);
  }
}

uint64_t CGPDFNodeGetItemMarkerPrefixRange(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1537)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 1) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    if (*(_DWORD *)(result + 44)
      && (uint64_t v2 = **(void **)(result + 56)) != 0
      && (*(unsigned char *)(v2 + 1) & 2) != 0
      && *(_DWORD *)(v2 + 44))
    {
      uint64_t v3 = **(void **)(v2 + 56);
    }
    else
    {
      uint64_t v3 = 0;
    }
    return CGPDFNodeGetTextRange(v3);
  }
  return result;
}

uint64_t CGPDFNodeGetItemMarkerSuffixRange(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1537)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 1) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    if (*(_DWORD *)(result + 44)
      && (uint64_t v2 = **(void **)(result + 56)) != 0
      && (*(unsigned char *)(v2 + 1) & 2) != 0
      && *(_DWORD *)(v2 + 44))
    {
      uint64_t v3 = **(void **)(v2 + 56);
    }
    else
    {
      uint64_t v3 = 0;
    }
    double result = CGPDFNodeGetTextRange(v3);
    uint64_t v5 = v4;
    uint64_t v6 = v1[9];
    if (v5 > v6) {
      return result + v5 - v6;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetTableRowCount(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return v1[1];
  }
  return result;
}

uint64_t CGPDFNodeGetTableRowDividerPositions(uint64_t result, void *__dst)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v2 = *(void *)(result + 104);
        if (v2)
        {
          if (*(_DWORD *)v2 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    int v3 = *(_DWORD *)(v2 + 4);
    if (v3)
    {
      memcpy(__dst, *(const void **)(v2 + 8), 8 * (v3 + 1));
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetTableColumnCount(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return v1[4];
  }
  return result;
}

uint64_t CGPDFNodeGetTableColumnDividerPositions(uint64_t result, void *__dst)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v2 = *(void *)(result + 104);
        if (v2)
        {
          if (*(_DWORD *)v2 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    int v3 = *(_DWORD *)(v2 + 16);
    if (v3)
    {
      memcpy(__dst, *(const void **)(v2 + 24), 8 * (v3 + 1));
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetTableGraphicNodeCount(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v1 = *(_DWORD **)(result + 104);
        if (v1)
        {
          if (*v1 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return v1[8];
  }
  return result;
}

uint64_t CGPDFNodeGetTableGraphicNodes(uint64_t result, void *__dst)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v2 = *(void *)(result + 104);
        if (v2)
        {
          if (*(_DWORD *)v2 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    uint64_t v3 = *(unsigned int *)(v2 + 32);
    if (v3)
    {
      memcpy(__dst, *(const void **)(v2 + 40), 8 * v3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetTableBackgroundColor(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v1 = *(void *)(result + 104);
        if (v1)
        {
          if (*(_DWORD *)v1 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(void *)(v1 + 48);
  }
  return result;
}

uint64_t CGPDFNodeGetTableHasHeaderRow(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v1 = *(void *)(result + 104);
        if (v1)
        {
          if (*(_DWORD *)v1 == 3) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(unsigned __int8 *)(v1 + 56) != 0;
  }
  return result;
}

uint64_t CGPDFNodeGetTableCellRowSpan(uint64_t a1)
{
  uint64_t v1 = &CPRangeNull;
  if (a1)
  {
    while (1)
    {
      if (*(_DWORD *)a1 == 1538)
      {
        uint64_t v2 = *(_DWORD **)(a1 + 104);
        if (v2)
        {
          if (*v2 == 2) {
            break;
          }
        }
      }
      a1 = *(void *)(a1 + 8);
      if (!a1) {
        return *(void *)v1;
      }
    }
    uint64_t v1 = (long long *)(v2 + 2);
  }
  return *(void *)v1;
}

uint64_t CGPDFNodeGetTableCellColumnSpan(uint64_t a1)
{
  uint64_t v1 = &CPRangeNull;
  if (a1)
  {
    while (1)
    {
      if (*(_DWORD *)a1 == 1538)
      {
        uint64_t v2 = *(_DWORD **)(a1 + 104);
        if (v2)
        {
          if (*v2 == 2) {
            break;
          }
        }
      }
      a1 = *(void *)(a1 + 8);
      if (!a1) {
        return *(void *)v1;
      }
    }
    uint64_t v1 = (long long *)(v2 + 6);
  }
  return *(void *)v1;
}

CGFloat CGPDFNodeGetTableCellBorderBounds(uint64_t a1, int a2)
{
  if (!a1) {
    goto LABEL_10;
  }
  uint64_t v2 = &CGRectNull;
  do
  {
    if (*(_DWORD *)a1 == 1538)
    {
      uint64_t v3 = *(void *)(a1 + 104);
      if (v3)
      {
        if (*(_DWORD *)v3 == 2) {
          break;
        }
      }
    }
    a1 = *(void *)(a1 + 8);
  }
  while (a1);
  uint64_t v4 = *(void *)(v3 + 40);
  if (v4) {
    uint64_t v2 = (const CGRect *)(v4 + 40 * a2);
  }
  else {
LABEL_10:
  }
    uint64_t v2 = &CGRectNull;
  return v2->origin.x;
}

uint64_t CGPDFNodeGetTableCellBorderColor(uint64_t result, int a2)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v2 = *(void *)(result + 104);
        if (v2)
        {
          if (*(_DWORD *)v2 == 2) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    uint64_t v3 = *(void *)(v2 + 40);
    if (v3) {
      return *(void *)(v3 + 40 * a2 + 32);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeGetTableCellBackgroundColor(uint64_t result)
{
  if (result)
  {
    while (1)
    {
      if (*(_DWORD *)result == 1538)
      {
        uint64_t v1 = *(void *)(result + 104);
        if (v1)
        {
          if (*(_DWORD *)v1 == 2) {
            break;
          }
        }
      }
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(void *)(v1 + 48);
  }
  return result;
}

uint64_t CGPDFNodeGetSectionBackgroundColor(uint64_t result)
{
  if (result)
  {
    while (*(_DWORD *)result != 1538)
    {
      double result = *(void *)(result + 8);
      if (!result) {
        return result;
      }
    }
    return *(void *)(result + 112);
  }
  return result;
}

uint64_t CGPDFNodeGetBackgroundColor(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  while (1)
  {
    if (*(_DWORD *)a1 == 1538)
    {
      uint64_t v1 = *(_DWORD **)(a1 + 104);
      if (v1 && (*v1 == 2 || *v1 == 3)) {
        uint64_t v2 = (uint64_t *)(v1 + 12);
      }
      else {
        uint64_t v2 = (uint64_t *)(a1 + 112);
      }
      uint64_t v3 = *v2;
      if (v3) {
        break;
      }
    }
    a1 = *(void *)(a1 + 8);
    if (!a1) {
      return 0;
    }
  }
  return v3;
}

uint64_t CGPDFNodeGetNodeContainingTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  if (!a1 || !a3) {
    return result;
  }
  uint64_t TextRange = CGPDFNodeGetTextRange(a1);
  if (!v8)
  {
    int v13 = *(_DWORD *)a1;
LABEL_30:
    if (v13 != 517 || a2 < 0) {
      return 0;
    }
    uint64_t v17 = *(void *)(a1 + 104);
    if (v17) {
      uint64_t v17 = *(void *)(v17 + 48);
    }
    uint64_t result = a1;
    if (a2 + a3 > v17) {
      return 0;
    }
    return result;
  }
  if (v8 <= 0) {
    uint64_t v9 = TextRange + v8;
  }
  else {
    uint64_t v9 = TextRange;
  }
  if (v8 <= 0) {
    uint64_t v10 = TextRange;
  }
  else {
    uint64_t v10 = TextRange + v8;
  }
  if (a3 <= 0) {
    uint64_t v11 = a2 + a3;
  }
  else {
    uint64_t v11 = a2;
  }
  if (a3 <= 0) {
    uint64_t v12 = a2;
  }
  else {
    uint64_t v12 = a2 + a3;
  }
  int v13 = *(_DWORD *)a1;
  if (v9 > v11 || v10 < v12) {
    goto LABEL_30;
  }
  if (v13 == 513) {
    return a1;
  }
  if ((v13 & 0x200) == 0) {
    return a1;
  }
  uint64_t v14 = *(unsigned int *)(a1 + 44);
  if (!v14) {
    return a1;
  }
  unint64_t v15 = 0;
  while (1)
  {
    uint64_t v16 = (*(unsigned char *)(a1 + 1) & 2) != 0 && v15 < *(unsigned int *)(a1 + 44)
        ? *(void *)(*(void *)(a1 + 56) + 8 * v15)
        : 0;
    uint64_t result = CGPDFNodeGetNodeContainingTextRange(v16, a2, a3);
    if (result) {
      break;
    }
    if (v14 == ++v15) {
      return a1;
    }
  }
  return result;
}

_DWORD *CGPDFNodeGetNodeFollowingTextIndex(_DWORD *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t TextRange = CGPDFNodeGetTextRange((uint64_t)result);
    uint64_t v7 = TextRange + v6;
    if (TextRange + v6 > a2)
    {
      while (1)
      {
        uint64_t result = (_DWORD *)CGPDFNodeGetNodeContainingTextRange(v4, a2, 1);
        if (!result) {
          break;
        }
        int v8 = *result;
        BOOL v9 = (*result - 257) < 2 || v8 == 1;
        if (!v9 && v8 != 513) {
          goto LABEL_11;
        }
LABEL_12:
        BOOL v10 = (v8 - 257) < 2 || v8 == 1;
        if (v10 || v8 == 513) {
          return result;
        }
        ++a2;
        uint64_t v2 = result;
        if (v7 == a2) {
          return 0;
        }
      }
      int v8 = 0;
LABEL_11:
      uint64_t result = v2;
      goto LABEL_12;
    }
    return 0;
  }
  return result;
}

_DWORD *CGPDFNodeGetNodePrecedingTextIndex(_DWORD *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t TextRange = CGPDFNodeGetTextRange((uint64_t)result);
    if (TextRange > a2) {
      return 0;
    }
    uint64_t v6 = TextRange;
    while (1)
    {
      uint64_t result = (_DWORD *)CGPDFNodeGetNodeContainingTextRange(v4, a2, 1);
      if (!result) {
        break;
      }
      int v7 = *result;
      BOOL v8 = (*result - 257) < 2 || v7 == 1;
      if (!v8 && v7 != 513) {
        goto LABEL_14;
      }
LABEL_15:
      BOOL v9 = (v7 - 257) < 2 || v7 == 1;
      if (v9 || v7 == 513) {
        return result;
      }
      uint64_t v2 = result;
      if (a2-- <= v6) {
        return 0;
      }
    }
    int v7 = 0;
LABEL_14:
    uint64_t result = v2;
    goto LABEL_15;
  }
  return result;
}

uint64_t CGPDFNodeGetInlineNode(uint64_t a1)
{
  if (CGPDFNodeIsInlineContainer(a1)) {
    return *(void *)(a1 + 64);
  }
  else {
    return 0;
  }
}

BOOL CGPDFNodeIsAncestorOfNode(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a2 != 0;
  if (a2 != a1 && a2)
  {
    do
    {
      a2 = *(void *)(a2 + 8);
      BOOL v2 = a2 != 0;
    }
    while (a2 != a1 && a2 != 0);
  }
  return v2;
}

uint64_t CGPDFNodeGetFirstDescendantOfType(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  if (a1)
  {
    int v6 = *a1;
    if ((a3 & 1) != 0 || v6 != a2)
    {
      if ((v6 & 0x200) != 0 && (uint64_t v7 = a1[11], v7))
      {
        BOOL v8 = (void *)*((void *)a1 + 7);
        while (1)
        {
          uint64_t FirstDescendantOfType = CGPDFNodeGetFirstDescendantOfType(*v8, a2, a3);
          if (FirstDescendantOfType) {
            return FirstDescendantOfType;
          }
          ++v8;
          if (!--v7) {
            goto LABEL_9;
          }
        }
      }
      else
      {
LABEL_9:
        if ((a3 & (v6 == a2)) == 0) {
          return 0;
        }
      }
    }
  }
  return (uint64_t)v3;
}

uint64_t CGPDFNodeGetLastDescendantOfType(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  if (a1)
  {
    int v6 = *a1;
    if ((a3 & 1) != 0 || v6 != a2)
    {
      if ((v6 & 0x200) != 0) {
        uint64_t v7 = a1[11];
      }
      else {
        uint64_t v7 = 0;
      }
      for (uint64_t i = 8 * v7 - 8; i != -8; i -= 8)
      {
        uint64_t LastDescendantOfType = CGPDFNodeGetLastDescendantOfType(*(void *)(*((void *)v3 + 7) + i), a2, a3);
        if (LastDescendantOfType) {
          return LastDescendantOfType;
        }
      }
      if ((a3 & (v6 == a2)) == 0) {
        return 0;
      }
    }
  }
  return (uint64_t)v3;
}

uint64_t CGPDFNodeGetCGPDFAnnotation(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 259) {
      return *(void *)(result + 104);
    }
    else {
      return 0;
    }
  }
  return result;
}

void CGPDFNodeSetCGPDFAnnotation(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == 259)
    {
      CFTypeRef v4 = *(CFTypeRef *)(a1 + 104);
      if (v4 != cf)
      {
        if (v4) {
          CFRelease(v4);
        }
        *(void *)(a1 + 104) = cf;
        if (cf)
        {
          CFRetain(cf);
        }
      }
    }
  }
}

BOOL CGPDFNodeMap(uint64_t a1, uint64_t (*a2)(uint64_t, void, uint64_t), uint64_t a3)
{
  if (!a1) {
    return 1;
  }
  if ((*(unsigned char *)(a1 + 1) & 2) == 0) {
    return 1;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 44);
  if (!v4) {
    return 1;
  }
  int v7 = ((uint64_t (*)(void, void))a2)(0, **(void **)(a1 + 56));
  BOOL result = 0;
  if (v7)
  {
    uint64_t v9 = 1;
    while (v4 != v9)
    {
      char v10 = a2(v9, *(void *)(*(void *)(a1 + 56) + 8 * v9), a3);
      ++v9;
      if ((v10 & 1) == 0)
      {
        unint64_t v11 = v9 - 1;
        return v11 >= v4;
      }
    }
    unint64_t v11 = v4;
    return v11 >= v4;
  }
  return result;
}

BOOL CGPDFNodeMapByType(uint64_t a1, uint64_t a2)
{
  if (a1 && (*(unsigned char *)(a1 + 1) & 2) != 0 && (unint64_t v3 = *(unsigned int *)(a1 + 44), v3))
  {
    uint64_t v5 = 0;
    BOOL v6 = 0;
    do
    {
      int v7 = *(_DWORD **)(*(void *)(a1 + 56) + 8 * v5);
      if (v7)
      {
        uint64_t v8 = 1;
        while (kCGPDFNodeTypeOrder[v8] != *v7)
        {
          if (++v8 == 12) {
            goto LABEL_9;
          }
        }
        if (v8 >= 0xC) {
          __assert_rtn("CGPDFNodeMapByType", "CGPDFNode.c", 4050, "typeIndex < 12");
        }
      }
      else
      {
LABEL_9:
        LODWORD(v8) = 0;
      }
      if (((*(uint64_t (**)(uint64_t))(a2 + 8 * v8))(v5) & 1) == 0) {
        break;
      }
      BOOL v6 = ++v5 >= v3;
    }
    while (v5 != v3);
  }
  else
  {
    return 1;
  }
  return v6;
}

uint64_t CGPDFNodeTypeGetIndex(int a1)
{
  uint64_t result = 1;
  while (kCGPDFNodeTypeOrder[result] != a1)
  {
    if (++result == 12) {
      return 0;
    }
  }
  return result;
}

__n64 *CGPDFNodePrint(__n64 *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result) {
    return (__n64 *)CGPDFNodePrintTabbed(result, 0, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t CGPDFNodePrintTabbed(__n64 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v10 = a1->n64_u32[0];
  if ((v10 & 0x200) == 0)
  {
    uint64_t v11 = 0;
    if (!a2) {
      goto LABEL_8;
    }
LABEL_5:
    uint64_t v12 = a2;
    do
    {
      printf("    ");
      --v12;
    }
    while (v12);
    int v10 = a1->n64_u32[0];
    goto LABEL_8;
  }
  uint64_t v11 = a1[5].n64_u32[1];
  if (a2) {
    goto LABEL_5;
  }
LABEL_8:
  Name = CGPDFNodeTypeGetName(v10, a2, a3, a4, a5, a6, a7, a8);
  int TextRange = CGPDFNodeGetTextRange((uint64_t)a1);
  int v16 = v15;
  v17.n64_u64[0] = CGPDFNodeGetBounds(a1).n64_u64[0];
  float64x2_t v21 = a1;
  while (v21->n64_u32[0] != 517)
  {
    float64x2_t v21 = (__n64 *)v21[1].n64_u64[0];
    if (!v21) {
      goto LABEL_15;
    }
  }
  unint64_t v22 = v21[13].n64_u64[0];
  if (v22)
  {
    uint64_t v23 = *(void *)(v22 + 16);
    if (v23)
    {
      int v24 = *(_DWORD *)(*(void *)(v23 + 40) + 8);
      goto LABEL_16;
    }
  }
LABEL_15:
  int v24 = -1;
LABEL_16:
  uint64_t result = printf("CGPDFNodeRef: %p, type: <%s>, page %d, child count: %zu, text range: [%d, %d], bounds: (%.2f, %.2f), [%.2f, %.2f]\n", a1, Name, v24, v11, TextRange, v16, v17.n64_f64[0], v18.n64_f64[0], v19.n64_f64[0], v20.n64_f64[0]);
  if (v11)
  {
    uint64_t v33 = 0;
    while (1)
    {
      if ((a1->n64_u8[1] & 2) == 0 || a1[5].n64_u32[1] <= v33)
      {
        int v35 = 0;
        uint64_t v34 = 0;
        goto LABEL_27;
      }
      uint64_t v34 = *(__n64 **)(a1[7].n64_u64[0] + 8 * v33);
      if (!v34) {
        break;
      }
      int v35 = v34->n64_u32[0];
      if ((v34->n64_u32[0] & 0x200) == 0) {
        goto LABEL_27;
      }
      if (a2)
      {
        uint64_t v36 = a2;
        do
        {
          printf("    ");
          --v36;
        }
        while (v36);
      }
      uint64_t v37 = CGPDFNodeTypeGetName(v35, v26, v27, v28, v29, v30, v31, v32);
      printf("Tagged node type: %s.\n", v37);
      uint64_t result = CGPDFNodePrintTabbed(v34, a2 + 1);
LABEL_46:
      if (++v33 == v11) {
        return result;
      }
    }
    int v35 = 0;
LABEL_27:
    if (a2 != -1)
    {
      uint64_t v38 = a2 + 1;
      do
      {
        printf("    ");
        --v38;
      }
      while (v38);
    }
    if (v35 == 1)
    {
      CGAffineTransform v39 = v34;
      if (v34->n64_u32[0] == 1)
      {
        while (1)
        {
          CGAffineTransform v39 = (__n64 *)v39[1].n64_u64[0];
          if (!v39) {
            break;
          }
          if (v39->n64_u32[0] == 517)
          {
            uint64_t v40 = v39[13].n64_i64[0];
            if (!v40) {
              break;
            }
            StringForRanges = CGPDFLayoutCreateStringForRanges(v40, (uint64_t)&v34[2], 1);
            if (!StringForRanges) {
              break;
            }
            uint64_t v42 = StringForRanges;
            if (CFStringGetCString(StringForRanges, buffer, 1023, 0x8000100u)) {
              CGRect v43 = buffer;
            }
            else {
              CGRect v43 = 0;
            }
            CFRelease(v42);
            goto LABEL_43;
          }
        }
      }
    }
    else if ((v35 & 0x300) != 0)
    {
      v44.n64_u64[0] = CGPDFNodeGetBounds(v34).n64_u64[0];
      CGRect v43 = buffer;
      __sprintf_chk(buffer, 0, 0x400uLL, "bounds: (%.2f, %.2f), [%.2f, %.2f]", v44.n64_f64[0], v45, v46, v47);
LABEL_43:
      uint64_t v48 = CGPDFNodeTypeGetName(v35, v26, v27, v28, v29, v30, v31, v32);
      uint64_t v49 = "(null)";
      if (v43) {
        uint64_t v49 = v43;
      }
      uint64_t result = printf("Leaf-node type: %s, %s\n", v48, v49);
      goto LABEL_46;
    }
    CGRect v43 = 0;
    goto LABEL_43;
  }
  return result;
}

const char *CGPDFNodeTypeGetName(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 <= 512)
  {
    if (a1 <= 256)
    {
      if (!a1) {
        return "None";
      }
      if (a1 == 1) {
        return "Word";
      }
    }
    else
    {
      switch(a1)
      {
        case 257:
          return "Image";
        case 258:
          return "Shape";
        case 259:
          return "Annotation";
      }
    }
LABEL_23:
    CGLog(2, (uint64_t)"%s: Unexpected node type (%d)", a3, a4, a5, a6, a7, a8, (char)"CGPDFNodeTypeGetName");
    return 0;
  }
  else
  {
    switch(a1)
    {
      case 513:
        uint64_t result = "Group";
        break;
      case 514:
        uint64_t result = "Text Line";
        break;
      case 515:
        uint64_t result = "Column";
        break;
      case 516:
        uint64_t result = "Layout Area";
        break;
      case 517:
        uint64_t result = "Page";
        break;
      default:
        if (a1 == 1537)
        {
          uint64_t result = "Paragraph";
        }
        else
        {
          if (a1 != 1538) {
            goto LABEL_23;
          }
          uint64_t result = "Section";
        }
        break;
    }
  }
  return result;
}

void ascii85_filter_finalize(const void **a1)
{
  if (a1)
  {
    BOOL v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

uint64_t ascii85_filter_refill(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 8)) {
    return 0;
  }
  uint64_t v11 = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a2;
LABEL_4:
  if (v11 + 4 >= a3 || *(unsigned char *)(a1 + 8)) {
    return *(void *)(a1 + 16);
  }
  int v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 8;
  uint64_t v15 = 5;
  while (1)
  {
    do
    {
      int v16 = CGPDFSourceGetc(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
      if ((v16 + 1) > 0x21) {
        goto LABEL_10;
      }
    }
    while (((1 << (v16 + 1)) & 0x200006C02) != 0);
    if (v16 == -1) {
      goto LABEL_32;
    }
LABEL_10:
    if (v16 == 122)
    {
      if (!v13)
      {
        uint64_t v20 = 4;
        do
        {
          uint64_t v22 = *(void *)(a1 + 16);
          uint64_t v21 = *(void *)(a1 + 24);
          *(void *)(a1 + 16) = v22 + 1;
          *(unsigned char *)(v21 + v22) = 0;
          --v20;
        }
        while (v20);
        goto LABEL_28;
      }
      int v35 = 122;
      goto LABEL_31;
    }
    if (v16 == 126) {
      break;
    }
    if ((v16 - 118) <= 0xFFFFFFAA)
    {
      int v35 = v16;
LABEL_31:
      pdf_error("ASCII85Decode: invalid character 0x%02x encountered in stream.", v35);
LABEL_32:
      *(unsigned char *)(a1 + 8) = 1;
      return *(void *)(a1 + 16);
    }
    int v12 = v16 + 85 * v12 - 33;
    ++v13;
    --v15;
    --v14;
    if (v13 == 5)
    {
      uint64_t v17 = 4;
      do
      {
        uint64_t v19 = *(void *)(a1 + 16);
        uint64_t v18 = *(void *)(a1 + 24);
        *(void *)(a1 + 16) = v19 + 1;
        *(unsigned char *)(v18 + v19) = HIBYTE(v12);
        v12 <<= 8;
        --v17;
      }
      while (v17);
LABEL_28:
      uint64_t v11 = *(void *)(a1 + 16);
      goto LABEL_4;
    }
  }
  *(unsigned char *)(a1 + 8) = 1;
  int v23 = CGPDFSourceGetc(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (v13 != 1 && v23 == 62)
  {
    v24.i64[0] = 0x5500000055;
    v24.i64[1] = 0x5500000055;
    if (!v13) {
      return *(void *)(a1 + 16);
    }
    v25.i32[1] = 1;
    v25.i64[1] = 0x100000001;
    v25.i32[0] = v12 + 1;
    unint64_t v26 = v14 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      int8x16_t v27 = (int8x16_t)v25;
      int32x4_t v25 = vmulq_s32(v25, v24);
      v26 -= 4;
    }
    while (v26);
    uint64_t v28 = v13 - 1;
    uint64x2_t v29 = (uint64x2_t)vdupq_lane_s64(v15 - 1, 0);
    int8x16_t v30 = (int8x16_t)vdupq_n_s64((v14 & 0xFFFFFFFFFFFFFFFCLL) - 4);
    int8x16_t v31 = vbslq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_u64((uint64x2_t)vorrq_s8(v30, (int8x16_t)xmmword_1850CD8A0), v29), (int32x4_t)vcgtq_u64((uint64x2_t)vorrq_s8(v30, (int8x16_t)xmmword_1850CE070), v29)), v27, (int8x16_t)v25);
    *(int32x2_t *)v31.i8 = vmul_s32(*(int32x2_t *)v31.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
    __int32 v32 = v31.i32[0] * v31.i32[1];
    do
    {
      uint64_t v34 = *(void *)(a1 + 16);
      uint64_t v33 = *(void *)(a1 + 24);
      *(void *)(a1 + 16) = v34 + 1;
      *(unsigned char *)(v33 + v34) = HIBYTE(v32);
      v32 <<= 8;
      --v28;
    }
    while (v28);
    goto LABEL_28;
  }
  pdf_error("ASCII85Decode: encountered unexpected EOF.");
  return *(void *)(a1 + 16);
}

uint64_t ascii85_filter_rewind(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  return CGPDFSourceRewind(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
}

CGFloat CGClipStackCreateMutable()
{
  v0 = (char *)malloc_type_malloc(0x98uLL, 0x2062DE7BuLL);
  *(_DWORD *)v0 = 1;
  *((_DWORD *)v0 + 1) = 0;
  *((_DWORD *)v0 + 2) = 0;
  CGFloat result = CGRectInfinite.origin.x;
  *(CGRect *)(v0 + 48) = CGRectInfinite;
  *(CGRect *)(v0 + 80) = CGRectInfinite;
  *(CGRect *)(v0 + 16) = CGRectInfinite;
  *((void *)v0 + 14) = 3;
  *((void *)v0 + 15) = 0;
  *((void *)v0 + 16) = 0;
  return result;
}

atomic_uint *CGClipStackRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

BOOL CGClipStackEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (a1)
  {
    if (a2) {
      return *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4);
    }
  }
  return result;
}

uint64_t CGClipStackEquivalent(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  uint64_t result = CGRectEqualToRect(*(CGRect *)(a1 + 16), *(CGRect *)(a2 + 16));
  if (!result) {
    return result;
  }
  uint64_t result = CGRectEqualToRect(*(CGRect *)(a1 + 48), *(CGRect *)(a2 + 48));
  if (!result) {
    return result;
  }
  uint64_t result = CGRectEqualToRect(*(CGRect *)(a1 + 80), *(CGRect *)(a2 + 80));
  if (!result) {
    return result;
  }
  uint64_t v5 = *(void *)(a1 + 120);
  if (v5 != *(void *)(a2 + 120)) {
    return 0;
  }
  if (!v5) {
    return 1;
  }
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  uint64_t v8 = (void *)(a1 + 128);
  uint64_t v9 = (void *)(a2 + 128);
  do
  {
    if (*(void *)(a1 + 112) == 3) {
      int v10 = &v8[v7];
    }
    else {
      int v10 = (uint64_t *)(*v8 + v6 * 8);
    }
    if (*(void *)(a2 + 120) <= v7)
    {
      uint64_t v12 = 0;
    }
    else
    {
      if (*(void *)(a2 + 112) == 3) {
        uint64_t v11 = &v9[v6];
      }
      else {
        uint64_t v11 = (uint64_t *)(*v9 + 8 * v7);
      }
      uint64_t v12 = *v11;
    }
    uint64_t result = CGClipEqualToClip(*v10, v12);
    if ((result & 1) == 0) {
      break;
    }
    ++v7;
    ++v6;
  }
  while (v7 < *(void *)(a1 + 120));
  return result;
}

void *CGClipStackGetClipAtIndex(void *result, unint64_t a2)
{
  if (result)
  {
    if (result[15] <= a2)
    {
      return 0;
    }
    else
    {
      BOOL v2 = result + 16;
      if (result[14] != 3) {
        BOOL v2 = (void *)*v2;
      }
      return (void *)v2[a2];
    }
  }
  return result;
}

uint64_t CGClipStackContainsMask(uint64_t result)
{
  if (result) {
    return *(unsigned char *)(result + 8) & 1;
  }
  return result;
}

void CGClipStackPrint(uint64_t a1, FILE *a2)
{
  if (a1)
  {
    fprintf(a2, "ClipStack: (%f, %f %f, %f)\n", *(double *)(a1 + 16), *(double *)(a1 + 24), *(double *)(a1 + 32), *(double *)(a1 + 40));
    uint64_t v4 = *(void *)(a1 + 120);
    if (v4)
    {
      unint64_t v5 = 0;
      uint64_t v6 = (uint64_t *)(a1 + 128);
      do
      {
        if (*(void *)(a1 + 120) <= v5)
        {
          uint64_t v8 = 0;
        }
        else
        {
          unint64_t v7 = v6;
          if (*(void *)(a1 + 112) != 3) {
            unint64_t v7 = (uint64_t *)(*(void *)(a1 + 128) + 8 * v5);
          }
          uint64_t v8 = *v7;
        }
        int v9 = *(unsigned __int8 *)(v8 + 8);
        switch((char)v9)
        {
          case 0:
            fprintf(a2, "Clip %zu (Rect): (%g %g %g %g)\n");
            break;
          case 2:
            if (v9 == 2) {
              int v10 = *(const CGPath **)(v8 + 24);
            }
            else {
              int v10 = 0;
            }
            BoundingBodouble x = CGPathGetBoundingBox(v10);
            fprintf(a2, "Clip %zu (Path): bbox (%g %g %g %g)\n", v5, BoundingBox.origin.x, BoundingBox.origin.y, BoundingBox.size.width, BoundingBox.size.height);
            CGPathPrint(v10, a2);
            break;
          case 3:
            fprintf(a2, "Clip %zu (Mask)\n");
            break;
          case 4:
            fprintf(a2, "Clip %zu (Text clipping)\n");
            break;
          default:
            break;
        }
        ++v5;
        ++v6;
      }
      while (v4 != v5);
    }
  }
  else
  {
    fprintf(a2, "ClipStack: (%f, %f %f, %f)\n", -8.98846567e307, -8.98846567e307, 1.79769313e308, 1.79769313e308);
  }
}

uint64_t anonymous namespace'::apply_element(_anonymous_namespace_ *this, void *a2, CGPathElementType a3, const CGPoint *a4, path_iterator *a5)
{
  if (a2 >= 5)
  {
    if (a2 != -3) {
      abort();
    }
    (*(void (**)(void))(*(void *)this + 16))();
    (*(void (**)(void))(*(void *)this + 16))();
    (*(void (**)(void))(*(void *)this + 16))();
    (*(void (**)(void))(*(void *)this + 16))();
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)this + 16);
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)this + 16);
  }
  return v6();
}

CGPDFObjectRef common_op_sh(CGPDFScanner *a1, double *a2, void *a3, CGPath **a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CGPDFReal value = 0;
  CGPDFObjectRef result = (CGPDFObjectRef)CGPDFScannerPopName(a1, (const char **)&value);
  if (!result) {
    return result;
  }
  CGPDFObjectRef result = (CGPDFObjectRef)*((void *)a1 + 7);
  if (!result) {
    return result;
  }
  CGPDFObjectRef result = CGPDFContentStreamGetResource(result, "Shading", value);
  *a3 = result;
  if (!result) {
    return result;
  }
  int v9 = *((_DWORD *)result + 2);
  if (v9 == 9)
  {
    uint64_t v10 = *((void *)result + 4);
    if (v10)
    {
      CGPDFObjectRef result = *(CGPDFObjectRef *)(v10 + 48);
      if (!result) {
        return result;
      }
      goto LABEL_9;
    }
    return 0;
  }
  if (v9 != 8) {
    return 0;
  }
  CGPDFObjectRef result = (CGPDFObjectRef)*((void *)result + 4);
LABEL_9:
  CGPDFArrayRef array = 0;
  if (CGPDFDictionaryGetArray(result, "BBox", &array))
  {
    size_t v11 = 0;
    uint64_t v12 = &v26;
    while (CGPDFArrayGetNumber(array, v11, v12))
    {
      ++v11;
      ++v12;
      if (v11 == 4)
      {
        double v13 = v26;
        double v14 = v27;
        double v15 = v28 - v26;
        double v16 = v29 - v27;
        goto LABEL_16;
      }
    }
  }
  double v15 = 0.0;
  double v13 = INFINITY;
  double v14 = INFINITY;
  double v16 = 0.0;
LABEL_16:
  CFMutableArrayRef Mutable = CGPathCreateMutable();
  *a4 = Mutable;
  if (v13 == INFINITY || v14 == INFINITY)
  {
    double v20 = *a2;
    double v21 = a2[1];
    double v22 = a2[2];
    double v23 = a2[3];
    uint64_t v19 = 0;
  }
  else
  {
    uint64_t v19 = (const CGAffineTransform *)(*((void *)a2 + 5) + 16);
    double v20 = v13;
    double v21 = v14;
    double v22 = v15;
    double v23 = v16;
  }
  CGPathAddRect(Mutable, v19, *(CGRect *)&v20);
  return (CGPDFObjectRef)1;
}

BOOL common_op_gs(uint64_t a1, CGPDFDictionaryRef dict)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFDictionaryGetNumber(dict, "CA", &value);
  if (result)
  {
    *(CGPDFReal *)(*(void *)(a1 + 40) + 344) = value;
    BOOL result = CGPDFDictionaryGetNumber(dict, "ca", &value);
    if (result)
    {
      *(CGPDFReal *)(*(void *)(a1 + 40) + 336) = value;
      BOOL result = CGPDFDictionaryGetNumber(dict, "LW", &value);
      if (result)
      {
        *(CGPDFReal *)(*(void *)(a1 + 40) + 296) = value;
        BOOL result = CGPDFDictionaryGetNumber(dict, "ML", &value);
        if (result)
        {
          *(CGPDFReal *)(*(void *)(a1 + 40) + 2++*(_DWORD *)(result + 88) = value;
          BOOL result = CGPDFDictionaryGetNumber(dict, "FL", &value);
          if (result)
          {
            *(CGPDFReal *)(*(void *)(a1 + 40) + 312) = value;
            BOOL result = CGPDFDictionaryGetNumber(dict, "SM", &value);
            if (result)
            {
              *(CGPDFReal *)(*(void *)(a1 + 40) + 320) = value;
              CGPDFInteger v5 = 0;
              BOOL result = CGPDFDictionaryGetInteger(dict, "LC", &v5);
              if (result)
              {
                *(unsigned char *)(*(void *)(a1 + 40) + 304) = v5;
                BOOL result = CGPDFDictionaryGetInteger(dict, "LJ", &v5);
                if (result)
                {
                  *(unsigned char *)(*(void *)(a1 + 40) + 305) = v5;
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CGPDFObjectRef common_op_Do(CGPDFScanner *a1, const char **a2, void *a3, uint64_t a4)
{
  CGPDFReal value = 0;
  CGPDFObjectRef result = (CGPDFObjectRef)CGPDFScannerPopName(a1, (const char **)&value);
  if (result)
  {
    CGPDFObjectRef result = (CGPDFObjectRef)*((void *)a1 + 7);
    if (result)
    {
      CGPDFObjectRef result = CGPDFContentStreamGetResource(result, "XObject", value);
      if (result)
      {
        *(void *)a4 = 0;
        if (*((_DWORD *)result + 2) == 9
          && (uint64_t v9 = *((void *)result + 4), (*(void *)a4 = v9) != 0)
          && (*a3 = 0, *(void *)a4))
        {
          CGPDFObjectRef result = *(CGPDFObjectRef *)(*(void *)a4 + 48);
          *a3 = result;
          if (result) {
            return (CGPDFObjectRef)CGPDFDictionaryGetName(result, "Subtype", a2);
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t common_op_ri(CGPDFScanner *a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(a2 + 40) + 308) = 0;
  CGPDFReal value = 0;
  uint64_t result = CGPDFScannerPopName(a1, (const char **)&value);
  if (result)
  {
    uint64_t v4 = value;
    uint64_t result = strcmp(value, "AbsoluteColorimetric");
    if (result)
    {
      int v5 = 1;
    }
    else
    {
      uint64_t result = strcmp(v4, "RelativeColorimetric");
      if (result)
      {
        int v5 = 2;
      }
      else
      {
        uint64_t result = strcmp(v4, "Perceptual");
        if (result)
        {
          int v5 = 3;
        }
        else
        {
          uint64_t result = strcmp(v4, "Saturation");
          if (!result) {
            return result;
          }
          int v5 = 4;
        }
      }
    }
    *(_DWORD *)(*(void *)(a2 + 40) + 308) = v5;
  }
  return result;
}

CGColorRef common_PopRGBAlphaCGColorCreate(CGPDFScanner *a1, CGColorSpace *a2)
{
  v7[2] = *(CGPDFReal *)MEMORY[0x1E4F143B8];
  if (!CGPDFScannerPopNumber(a1, v7)) {
    v7[0] = 0.0;
  }
  if (!CGPDFScannerPopNumber(a1, (CGPDFReal *)&v6)) {
    uint64_t v6 = 0;
  }
  if (!CGPDFScannerPopNumber(a1, &value)) {
    CGPDFReal value = 0.0;
  }
  v7[1] = 1.0;
  return CGColorCreate(a2, &value);
}

CGColorRef common_PopCMYKAlphaCGColorCreate(CGPDFScanner *a1, CGColorSpace *a2)
{
  v8[2] = *(CGPDFReal *)MEMORY[0x1E4F143B8];
  if (!CGPDFScannerPopNumber(a1, v8)) {
    v8[0] = 1.0;
  }
  if (!CGPDFScannerPopNumber(a1, (CGPDFReal *)&v7)) {
    uint64_t v7 = 0;
  }
  if (!CGPDFScannerPopNumber(a1, (CGPDFReal *)&v6)) {
    uint64_t v6 = 0;
  }
  if (!CGPDFScannerPopNumber(a1, (CGPDFReal *)&v5)) {
    uint64_t v5 = 0;
  }
  v8[1] = 1.0;
  return CGColorCreate(a2, (const CGFloat *)&v5);
}

BOOL common_ReadCGPathCurve(CGPDFScanner *a1, CGPDFReal *a2, CGPDFReal *a3, CGPDFReal *a4, CGPDFReal *a5, CGPDFReal *a6, CGPDFReal *value)
{
  if (!CGPDFScannerPopNumber(a1, value)
    || !CGPDFScannerPopNumber(a1, a6)
    || !CGPDFScannerPopNumber(a1, a5)
    || !CGPDFScannerPopNumber(a1, a4)
    || !CGPDFScannerPopNumber(a1, a3))
  {
    return 0;
  }

  return CGPDFScannerPopNumber(a1, a2);
}

BOOL common_ReadCGAffineTransform(CGPDFScanner *a1, CGPDFReal *a2)
{
  if (!CGPDFScannerPopNumber(a1, a2 + 5)
    || !CGPDFScannerPopNumber(a1, a2 + 4)
    || !CGPDFScannerPopNumber(a1, a2 + 3)
    || !CGPDFScannerPopNumber(a1, a2 + 2)
    || !CGPDFScannerPopNumber(a1, a2 + 1))
  {
    return 0;
  }

  return CGPDFScannerPopNumber(a1, a2);
}

BOOL common_ReadCGRect(CGPDFScanner *a1, CGPDFReal *a2)
{
  if (!CGPDFScannerPopNumber(a1, a2 + 3) || !CGPDFScannerPopNumber(a1, a2 + 2) || !CGPDFScannerPopNumber(a1, a2 + 1)) {
    return 0;
  }

  return CGPDFScannerPopNumber(a1, a2);
}

CGPDFObjectRef common_GetResourceDictionary(CGPDFObjectRef result, const char *a2, const char *a3)
{
  if (result)
  {
    uint64_t result = CGPDFContentStreamGetResource(result, a2, a3);
    if (result)
    {
      if (*((_DWORD *)result + 2) == 8) {
        return (CGPDFObjectRef)*((void *)result + 4);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

CFLocaleRef CGFontNameTableCopyNameForLocale(os_unfair_lock_s *a1, uint64_t a2, unsigned int a3)
{
  CFLocaleRef v3 = 0;
  if (a1 && a2)
  {
    CFStringRef v6 = CGCreateCanonicalLanguageLocale();
    while (1)
    {
      CFLocaleRef v7 = (const __CFLocale *)copy_localized_value(a1, v6, a3);
      if (v7)
      {
        CFLocaleRef v3 = v7;
        goto LABEL_10;
      }
      CFLocaleRef v3 = (const __CFLocale *)CGCreateContainingLocaleForLocale(v6);
      if (!v3) {
        goto LABEL_10;
      }
      if (v3 == CFLocaleGetSystem()) {
        break;
      }
      CFRelease(v6);
      CFStringRef v6 = CGCreateCanonicalLanguageLocale();
      CFRelease(v3);
    }
    CFRelease(v3);
    CFLocaleRef v3 = 0;
LABEL_10:
    CFRelease(v6);
  }
  return v3;
}

uint64_t CGFontNameTableGetPostScriptName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

void CGFontNameTablePrint(uint64_t a1, FILE *a2)
{
  if (!a1) {
    return;
  }
  if (a2) {
    CFLocaleRef v3 = a2;
  }
  else {
    CFLocaleRef v3 = (FILE *)*MEMORY[0x1E4F143D8];
  }
  if (*(void *)a1)
  {
    CFDataRef v4 = (const __CFData *)(*(uint64_t (**)(void, uint64_t))(*(void *)(*(void *)a1 + 16) + 424))(*(void *)(*(void *)a1 + 112), 1851878757);
    if (v4)
    {
      CFDataRef v5 = v4;
      BytePtr = CFDataGetBytePtr(v4);
      CFDataRef cf = v5;
      unint64_t Length = CFDataGetLength(v5);
      uint64_t v8 = 2 * (Length > 1);
      unint64_t v9 = (v8 + 2);
      if (Length >= v9)
      {
        int v10 = BytePtr[v8 | 1] | (BytePtr[v8] << 8);
        unint64_t v9 = v8 | 4;
        int v11 = v8 | 4;
        LODWORD(v8) = v8 + 2;
      }
      else
      {
        int v10 = 0;
        int v11 = v8 + 2;
      }
      if (Length >= v9)
      {
        unsigned int v12 = bswap32(*(unsigned __int16 *)&BytePtr[v8]) >> 16;
        for (LODWORD(v8) = v11; v10; --v10)
        {
LABEL_16:
          unint64_t v13 = (v8 + 2);
          if (Length >= v13)
          {
            int v14 = BytePtr[(v8 + 1)] | (BytePtr[v8] << 8);
            unint64_t v13 = (v8 + 4);
            int v15 = v8 + 4;
            LODWORD(v8) = v8 + 2;
          }
          else
          {
            int v14 = 0;
            int v15 = v8 + 2;
          }
          if (Length >= v13)
          {
            int v16 = BytePtr[(v8 + 1)] | (BytePtr[v8] << 8);
            unint64_t v13 = (v15 + 2);
            int v17 = v15 + 2;
            LODWORD(v8) = v15;
          }
          else
          {
            int v16 = 0;
            int v17 = v15;
          }
          if (Length >= v13)
          {
            int v18 = BytePtr[(v8 + 1)] | (BytePtr[v8] << 8);
            unint64_t v13 = (v17 + 2);
            int v19 = v17 + 2;
            LODWORD(v8) = v17;
          }
          else
          {
            int v18 = 0;
            int v19 = v17;
          }
          if (Length >= v13)
          {
            int v20 = BytePtr[(v8 + 1)] | (BytePtr[v8] << 8);
            unint64_t v13 = (v19 + 2);
            int v21 = v19 + 2;
            LODWORD(v8) = v19;
          }
          else
          {
            int v20 = 0;
            int v21 = v19;
          }
          if (Length >= v13)
          {
            unsigned __int16 v22 = BytePtr[(v8 + 1)] | (BytePtr[v8] << 8);
            unint64_t v13 = (v21 + 2);
            int v23 = v21 + 2;
            LODWORD(v8) = v21;
          }
          else
          {
            unsigned __int16 v22 = 0;
            int v23 = v21;
          }
          if (Length >= v13)
          {
            __int16 v24 = BytePtr[(v8 + 1)] | (BytePtr[v8] << 8);
            LODWORD(v8) = v23;
          }
          else
          {
            __int16 v24 = 0;
          }
          unsigned __int16 v25 = v24 + v12;
          if (Length > v25)
          {
            if (Length >= v25 + (unint64_t)v22) {
              unsigned __int16 v26 = v22;
            }
            else {
              unsigned __int16 v26 = Length - v25;
            }
            double v27 = &BytePtr[v25];
            fprintf(v3, "  (%u; %u; %u; %u): ", v14, v16, v18, v20);
            if (v14 == 1) {
              CFStringEncoding v28 = v16;
            }
            else {
              CFStringEncoding v28 = 268435712;
            }
            CFStringRef v29 = CFStringCreateWithBytes(0, v27, v26, v28, 0);
            CFStringRef v30 = v29;
            if (v29)
            {
              CFIndex v31 = CFStringGetLength(v29);
              CFIndex v32 = CFStringGetMaximumSizeForEncoding(v31, 0x8000100u) + 1;
              uint64_t v33 = (char *)malloc_type_malloc(v32, 0x7B96445DuLL);
              if (CFStringGetCString(v30, v33, v32, 0x8000100u)) {
                fputs(v33, v3);
              }
              else {
                fwrite("<<invalid>>", 0xBuLL, 1uLL, v3);
              }
              free(v33);
            }
            else
            {
              fwrite("<<null>>", 8uLL, 1uLL, v3);
            }
            CFRelease(v30);
            fputc(10, v3);
          }
        }
      }
      else
      {
        LOWORD(v12) = 0;
        if (v10) {
          goto LABEL_16;
        }
      }
      CFRelease(cf);
      return;
    }
  }

  fwrite("  <<unavailable>>\n", 0x12uLL, 1uLL, v3);
}

CFStringRef copy_debug_description_22775(const void *a1)
{
  return copy_description(a1, 0);
}

CFStringRef copy_description(const void *a1, const __CFDictionary *a2)
{
  if (!a1) {
    return 0;
  }
  CFGetTypeID(a1);
  uint64_t ClassWithTypeID = _CFRuntimeGetClassWithTypeID();
  if (!ClassWithTypeID) {
    return 0;
  }
  uint64_t v5 = ClassWithTypeID;
  CFAllocatorRef v6 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v6, a2, @"<%s %p>", *(void *)(v5 + 8), a1);
}

uint64_t __CGTypeRegister(uint64_t a1)
{
  BOOL v2 = (char *)malloc_type_malloc(0x60uLL, 0x10D00408820D60FuLL);
  *(void *)BOOL v2 = 0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + ++*(_DWORD *)(result + 40) = *(_OWORD *)(a1 + 40);
  v3.i64[0] = (uint64_t)copy_description;
  v3.i64[1] = (uint64_t)copy_debug_description_22775;
  *(int8x16_t *)(v2 + 56) = vbslq_s8((int8x16_t)vceqzq_s64(*(int64x2_t *)(a1 + 56)), v3, *(int8x16_t *)(a1 + 56));
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4) {
    *(void *)BOOL v2 = 4;
  }
  *((void *)v2 + 9) = v4;
  *((void *)v2 + 10) = 0;

  return _CFRuntimeRegisterClass();
}

__CFString *cs_copy_format_description(void *a1)
{
  unsigned int Type = CGColorSpaceGetType(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v3, 0);
  uint64_t v5 = Mutable;
  if (Type > 0xB) {
    CFAllocatorRef v6 = "Unknown";
  }
  else {
    CFAllocatorRef v6 = off_1E52CEBC8[Type];
  }
  CFStringAppendFormat(Mutable, 0, @"<CGColorSpace %p> (%s"), a1, v6;
  if (CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(a1[3] + 18))
  {
    char v7 = 0;
    uint64_t v8 = @"HLG scene referred derivative";
  }
  else if (CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(a1[3] + 19))
  {
    char v7 = 0;
    uint64_t v8 = @"PQ display referred derivative";
  }
  else
  {
    uint64_t v8 = 0;
    char v7 = 1;
  }
  switch(Type)
  {
    case 5u:
      if (a1)
      {
        unsigned int v12 = *(uint64_t (**)(void *))(*(void *)(a1[3] + 112) + 48);
        if (v12)
        {
          uint64_t v13 = v12(a1);
          if (v13)
          {
            CFStringRef v14 = (CFStringRef)v13;
            CFStringAppendFormat(v5, 0, @"; %@", v13);
            goto LABEL_61;
          }
        }
      }
      goto LABEL_62;
    case 6u:
    case 0xAu:
    case 0xBu:
      if (!a1)
      {
        CFStringAppendFormat(v5, 0, @"; %s; ", "Unknown model");
        CFStringRef v11 = @"-- no description tag -- ";
        goto LABEL_47;
      }
      uint64_t v9 = *(unsigned int *)(a1[3] + 32);
      if (v9 > 7) {
        int v10 = "Unknown model";
      }
      else {
        int v10 = off_1E52CEC28[v9];
      }
      CFStringAppendFormat(v5, 0, @"; %s; ", v10);
      CFStringRef v29 = *(void **)(a1[3] + 112);
      CFStringRef v30 = (uint64_t (*)(void *))v29[6];
      if (!v30) {
        goto LABEL_36;
      }
      CFStringRef v31 = (const __CFString *)v30(a1);
      if (v31) {
        goto LABEL_41;
      }
      CFStringRef v29 = *(void **)(a1[3] + 112);
LABEL_36:
      CFIndex v32 = (uint64_t (*)(void *))v29[3];
      if (!v32) {
        goto LABEL_39;
      }
      CFStringRef v31 = (const __CFString *)v32(a1);
      if (v31) {
        goto LABEL_41;
      }
      CFStringRef v29 = *(void **)(a1[3] + 112);
LABEL_39:
      uint64_t v33 = (uint64_t (*)(void *))v29[5];
      if (v33 && (CFStringRef v31 = (const __CFString *)v33(a1)) != 0)
      {
LABEL_41:
        CFStringAppend(v5, v31);
        CFRelease(v31);
      }
      else
      {
        CFStringAppend(v5, @"-- no description tag -- ");
      }
      if (!*(unsigned char *)(a1[3] + 13)) {
        goto LABEL_48;
      }
      CFStringRef v11 = @"; extended range";
LABEL_47:
      CFStringAppend(v5, v11);
LABEL_48:
      if ((v7 & 1) == 0) {
        CFStringAppendFormat(v5, 0, @"; %@", v8);
      }
      goto LABEL_62;
    case 7u:
      if (a1 && (uint64_t v15 = a1[3], (*(_DWORD *)(v15 + 28) - 5) <= 1)) {
        int v16 = **(const void ***)(v15 + 96);
      }
      else {
        int v16 = 0;
      }
      CFStringRef v14 = CFCopyDescription(v16);
      CFStringAppendFormat(v5, 0, @"; base %@", v14);
      goto LABEL_61;
    case 8u:
      if (CGColorSpaceGetType(a1) != 8)
      {
        char v39 = CGColorSpaceGetType(a1);
        _CGHandleAssert("deviceN_copy_names", 1463, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace.c", "CGColorSpaceGetType(s) == kCGColorSpaceDeviceN", "colorspace must be DeviceN. unsigned int Type = %d", v40, v41, v42, v39);
      }
      CFAllocatorRef v17 = CFGetAllocator(a1);
      unsigned __int16 v25 = CFStringCreateMutable(v17, 0);
      if (a1)
      {
        uint64_t v26 = *(void *)(a1[3] + 48);
        uint64_t Names = CGColorSpaceGetNames((uint64_t)a1, v18, v19, v20, v21, v22, v23, v24);
        CFStringAppendFormat(v25, 0, @"\n\tnames: [");
        if (v26)
        {
          for (unint64_t i = 0; i != v26; ++i)
          {
            CFStringAppendFormat(v25, 0, @"%s", *(void *)(Names + 8 * i));
            if (i >= v26 - 1) {
              CFStringAppendFormat(v25, 0, @"]\n");
            }
            else {
              CFStringAppendFormat(v25, 0, @", ");
            }
          }
        }
      }
      else
      {
        CGColorSpaceGetNames(0, v18, v19, v20, v21, v22, v23, v24);
        CFStringAppendFormat(v25, 0, @"\n\tnames: [");
      }
      CFStringAppendFormat(v5, 0, @"%@", v25);
      CFRelease(v25);
      if (!a1) {
        goto LABEL_56;
      }
      uint64_t v34 = a1[3];
      int v35 = *(_DWORD *)(v34 + 24);
      switch(v35)
      {
        case 6:
          uint64_t v36 = (const void **)(*(void *)(v34 + 96) + 56);
          break;
        case 10:
          uint64_t v36 = (const void **)(*(void *)(v34 + 96) + 48);
          break;
        case 8:
          uint64_t v36 = (const void **)(*(void *)(v34 + 96) + 8);
          break;
        default:
LABEL_56:
          uint64_t v37 = 0;
          goto LABEL_60;
      }
      uint64_t v37 = *v36;
LABEL_60:
      CFStringRef v14 = CFCopyDescription(v37);
      CFStringAppendFormat(v5, 0, @"\talternate: %@", v14);
LABEL_61:
      CFRelease(v14);
LABEL_62:
      CFStringAppend(v5, @""));
      return v5;
    default:
      goto LABEL_62;
  }
}

uint64_t cs_finalize(uint64_t a1)
{
  color_space_state_unregister(*(void *)(a1 + 24));

  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
}

CGColorSpaceRef CGColorSpaceCreateExtended(CGColorSpaceRef space)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  BOOL v2 = colorspace_from_properties((uint64_t)space, @"kCGColorSpaceExtendedDerivative");
  if (!v2)
  {
    if (!space) {
      return 0;
    }
    CFAllocatorRef v3 = (unsigned char *)*((void *)space + 3);
    if (!v3[15] || v3[16] || v3[17]) {
      return 0;
    }
    CFRetain(space);
    if (*(unsigned char *)(*((void *)space + 3) + 13))
    {
      CFRetain(space);
      BOOL v2 = space;
LABEL_27:
      CGColorSpaceRelease(space);
      return v2;
    }
    CFDataRef v5 = CGColorSpaceCopyICCData(space);
    if (!v5)
    {
      BOOL v2 = 0;
      goto LABEL_27;
    }
    CFDataRef v6 = v5;
    if (CGColorSpaceGetType(space) == 6)
    {
      char v7 = *(const void **)(*(void *)(*((void *)space + 3) + 96) + 16);
      if (!v7) {
        goto LABEL_25;
      }
      CFTypeRef Extended_f = CFRetain(v7);
    }
    else
    {
      if (CGColorSpaceCreateExtended_cglibrarypredicate != -1) {
        dispatch_once(&CGColorSpaceCreateExtended_cglibrarypredicate, &__block_literal_global_67_22894);
      }
      CFTypeRef Extended_f = (CFTypeRef)CGColorSpaceCreateExtended_f(v6, 0);
    }
    uint64_t v9 = (void *)Extended_f;
    if (Extended_f)
    {
      memcpy(__dst, &CGICCProfileInfoInitializer, sizeof(__dst));
      CGCMSUtilsGetICCProfileInfo(v9, (uint64_t)__dst, 1, v10, v11, v12, v13, v14);
      memcpy(v23, __dst, sizeof(v23));
      icc = (atomic_uint *)color_space_state_create_icc(v9, v6, v23);
      BOOL v2 = (CGColorSpace *)CGColorSpaceCreateWithState(icc, v16, v17, v18, v19, v20, v21, v22);
      if (icc && atomic_fetch_add_explicit(icc, 0xFFFFFFFF, memory_order_relaxed) == 1) {
        color_space_state_dealloc((uint64_t)icc);
      }
      if (v2)
      {
        *((void *)v2 + 3) = color_space_state_register(*((unsigned char **)v2 + 3));
        CGColorSpaceSetProperty((uint64_t)v2, @"kCGColorSpaceExtendedDerivative", v2);
      }
      CFRelease(v9);
      goto LABEL_26;
    }
LABEL_25:
    BOOL v2 = 0;
LABEL_26:
    CFRelease(v6);
    goto LABEL_27;
  }
  return v2;
}

CGColorSpaceRef colorspace_from_properties(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  uint64_t v5 = *(void *)(*(void *)(a1 + 24) + 88);
  if (!v5)
  {
    pthread_mutex_unlock(v4);
    return 0;
  }
  CFStringRef v6 = (const __CFString *)CGPropertiesCopyProperty(v5, a2);
  pthread_mutex_unlock(v4);
  if (!v6) {
    return 0;
  }
  CFTypeID v7 = CFGetTypeID(v6);
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  if (v7 == CGColorSpaceGetTypeID_type_id)
  {
    CFRetain(v6);
    CGColorSpaceRef v8 = (CGColorSpaceRef)v6;
  }
  else
  {
    CFTypeID v9 = CFGetTypeID(v6);
    if (v9 == CFStringGetTypeID()) {
      CGColorSpaceRef v8 = CGColorSpaceCreateWithName(v6);
    }
    else {
      CGColorSpaceRef v8 = 0;
    }
  }
  CFRelease(v6);
  return v8;
}

uint64_t colorsync_smart_null_22901()
{
  return 0;
}

BOOL CGColorSpaceIsDisplayReferredDerivative(void *a1)
{
  return CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(a1[3] + 19) != 0;
}

BOOL CGColorSpaceIsSceneReferredDerivative(void *a1)
{
  return CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(a1[3] + 18) != 0;
}

uint64_t CGColorSpaceGetMD5Digest(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return v1 + 64;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGColorSpaceGetIdentifier(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(int8x8_t **)(a1 + 24);
  if (!v1) {
    return 0;
  }
  int8x8_t v2 = veor_s8(v1[8], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v1[8].i8, *(int8x16_t *)v1[8].i8, 8uLL));
  return (v2.i32[0] ^ v2.i32[1]);
}

uint64_t CGColorSpaceIsICCCompatible(uint64_t result)
{
  if (result)
  {
    unsigned int v1 = *(_DWORD *)(*(void *)(result + 24) + 24);
    if (v1 > 0xB) {
      return 0;
    }
    else {
      return (0xC78u >> v1) & 1;
    }
  }
  return result;
}

uint64_t CGColorSpaceGetDescriptor(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (*(_DWORD *)(v1 + 24) >= 3u) {
      return *(void *)(v1 + 96);
    }
    else {
      return 0;
    }
  }
  return result;
}

BOOL CGColorSpaceIgnoresIntent(uint64_t a1)
{
  return !a1 || *(unsigned char *)(*(void *)(a1 + 24) + 12) != 0;
}

CGColorSpaceRef CGColorSpaceCopyBaseColorSpace(uint64_t a1)
{
  if (a1
    && (uint64_t v2 = *(void *)(a1 + 24), (*(_DWORD *)(v2 + 28) - 5) <= 1)
    && (CFAllocatorRef v3 = *(CFTypeRef **)(v2 + 96), (v4 = *v3) != 0))
  {
    CFRetain(*v3);
  }
  else if (CGColorSpaceContainsFlexGTCInfo(a1) && (int v6 = 0, CGColorSpaceGetCICPInfo(a1, &v6)))
  {
    return CGColorSpaceCreateFromCICP(v6);
  }
  else
  {
    return 0;
  }
  return (CGColorSpaceRef)v4;
}

CGColorSpaceRef CGColorSpaceCreatePQBasedCopy(CGColorSpaceRef result)
{
  if (result)
  {
    BOOL v1 = (BOOL)result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
    }
    if (v2 == CGColorSpaceGetTypeID_type_id && (int v3 = 0, CGColorSpaceGetCICPInfo(v1, &v3)))
    {
      BYTE1(v3) = 16;
      return CGColorSpaceCreateFromCICP(v3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CGColorSpaceRef CGColorSpaceCreateHLGBasedCopy(CGColorSpaceRef result)
{
  if (result)
  {
    BOOL v1 = (BOOL)result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
    }
    if (v2 == CGColorSpaceGetTypeID_type_id && (int v3 = 0, CGColorSpaceGetCICPInfo(v1, &v3)))
    {
      BYTE1(v3) = 18;
      return CGColorSpaceCreateFromCICP(v3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *CGColorSpaceCreateSceneReferredLinearDerivative(void *a1)
{
  BOOL v1 = a1;
  if (CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(v1[3] + 18))
  {
    CFRetain(v1);
    return v1;
  }
  if (CGColorSpaceGetType(v1) == 6)
  {
    uint64_t v2 = v1[3];
    if (*(unsigned char *)(v2 + 19)) {
      return 0;
    }
  }
  else
  {
    if (!v1) {
      return v1;
    }
    uint64_t v2 = v1[3];
  }
  if (!*(unsigned char *)(v2 + 17)) {
    return 0;
  }
  ExtendedLinearized = (uint64_t *)CGColorSpaceCreateExtendedLinearized((CGColorSpaceRef)v1);
  icc_derivative_with_state = color_space_state_create_icc_derivative_with_state(ExtendedLinearized[3], 1, 0, v4, v5, v6, v7, v8);
  BOOL v1 = (void *)CGColorSpaceCreateWithState((atomic_uint *)icc_derivative_with_state, v10, v11, v12, v13, v14, v15, v16);
  if (icc_derivative_with_state
    && atomic_fetch_add_explicit((atomic_uint *volatile)icc_derivative_with_state, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    color_space_state_dealloc((uint64_t)icc_derivative_with_state);
  }
  if (v1) {
    v1[3] = color_space_state_register((unsigned char *)v1[3]);
  }
  CGColorSpaceRelease((CGColorSpaceRef)ExtendedLinearized);
  return v1;
}

CGColorSpaceRef CGColorSpaceCreateExtendedLinearized(CGColorSpaceRef space)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = colorspace_from_properties((uint64_t)space, @"kCGColorSpaceExtendedLinearDerivative");
  if (v2) {
    return v2;
  }
  if (!space) {
    return 0;
  }
  if (!*(unsigned char *)(*((void *)space + 3) + 15)) {
    return 0;
  }
  CFDataRef v3 = CGColorSpaceCopyICCData(space);
  if (!v3) {
    return 0;
  }
  CFDataRef v4 = v3;
  LinearizedProfile = (void *)CGCMSUtilsCreateLinearizedProfile((uint64_t)v3);
  if (CGColorSpaceCreateExtendedLinearized_cglibrarypredicate != -1) {
    dispatch_once(&CGColorSpaceCreateExtendedLinearized_cglibrarypredicate, &__block_literal_global_64_22959);
  }
  uint64_t ExtendedLinearized_f = CGColorSpaceCreateExtendedLinearized_f(LinearizedProfile, 0);
  CFDataRef v7 = (const __CFData *)ExtendedLinearized_f;
  if (LinearizedProfile && ExtendedLinearized_f)
  {
    memcpy(__dst, &CGICCProfileInfoInitializer, sizeof(__dst));
    CGCMSUtilsGetICCProfileInfo(LinearizedProfile, (uint64_t)__dst, 1, v8, v9, v10, v11, v12);
    memcpy(v23, __dst, sizeof(v23));
    icc = (atomic_uint *)color_space_state_create_icc(LinearizedProfile, v7, v23);
    uint64_t v21 = (void *)CGColorSpaceCreateWithState(icc, v14, v15, v16, v17, v18, v19, v20);
    if (icc && atomic_fetch_add_explicit(icc, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      color_space_state_dealloc((uint64_t)icc);
    }
    if (v21)
    {
      v21[3] = color_space_state_register((unsigned char *)v21[3]);
      CGColorSpaceSetProperty((uint64_t)v21, @"kCGColorSpaceExtendedLinearDerivative", v21);
    }
    goto LABEL_16;
  }
  uint64_t v21 = 0;
  uint64_t v2 = 0;
  if (LinearizedProfile)
  {
LABEL_16:
    CFRelease(LinearizedProfile);
    uint64_t v2 = (CGColorSpace *)v21;
  }
  if (v7) {
    CFRelease(v7);
  }
  CFRelease(v4);
  return v2;
}

void *CGColorSpaceCreateDisplayReferredLinearDerivative(void *a1)
{
  BOOL v1 = a1;
  if (CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(v1[3] + 19))
  {
    CFRetain(v1);
    return v1;
  }
  if (CGColorSpaceGetType(v1) == 6)
  {
    uint64_t v2 = v1[3];
    if (*(unsigned char *)(v2 + 18)) {
      return 0;
    }
  }
  else
  {
    if (!v1) {
      return v1;
    }
    uint64_t v2 = v1[3];
  }
  if (!*(unsigned char *)(v2 + 16)) {
    return 0;
  }
  ExtendedLinearized = (uint64_t *)CGColorSpaceCreateExtendedLinearized((CGColorSpaceRef)v1);
  icc_derivative_with_state = color_space_state_create_icc_derivative_with_state(ExtendedLinearized[3], 0, 1, v4, v5, v6, v7, v8);
  BOOL v1 = (void *)CGColorSpaceCreateWithState((atomic_uint *)icc_derivative_with_state, v10, v11, v12, v13, v14, v15, v16);
  if (icc_derivative_with_state
    && atomic_fetch_add_explicit((atomic_uint *volatile)icc_derivative_with_state, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    color_space_state_dealloc((uint64_t)icc_derivative_with_state);
  }
  if (v1) {
    v1[3] = color_space_state_register((unsigned char *)v1[3]);
  }
  CGColorSpaceRelease((CGColorSpaceRef)ExtendedLinearized);
  return v1;
}

CGColorSpaceRef CGColorSpaceCreateLinearized(CGColorSpaceRef space)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = colorspace_from_properties((uint64_t)space, @"kCGColorSpaceLinearDerivative");
  if (v2) {
    return v2;
  }
  if (!space) {
    return 0;
  }
  if (!*(unsigned char *)(*((void *)space + 3) + 15)) {
    return 0;
  }
  CFDataRef v3 = CGColorSpaceCopyICCData(space);
  if (!v3) {
    return 0;
  }
  CFDataRef v4 = v3;
  LinearizedProfile = (void *)CGCMSUtilsCreateLinearizedProfile((uint64_t)v3);
  if (CGColorSpaceCreateLinearized_cglibrarypredicate != -1) {
    dispatch_once(&CGColorSpaceCreateLinearized_cglibrarypredicate, &__block_literal_global_60_22975);
  }
  uint64_t Linearized_f = CGColorSpaceCreateLinearized_f(LinearizedProfile, 0);
  CFDataRef v7 = (const __CFData *)Linearized_f;
  if (LinearizedProfile && Linearized_f)
  {
    memcpy(__dst, &CGICCProfileInfoInitializer, sizeof(__dst));
    CGCMSUtilsGetICCProfileInfo(LinearizedProfile, (uint64_t)__dst, 0, v8, v9, v10, v11, v12);
    memcpy(v23, __dst, sizeof(v23));
    icc = (atomic_uint *)color_space_state_create_icc(LinearizedProfile, v7, v23);
    uint64_t v21 = (void *)CGColorSpaceCreateWithState(icc, v14, v15, v16, v17, v18, v19, v20);
    if (icc && atomic_fetch_add_explicit(icc, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      color_space_state_dealloc((uint64_t)icc);
    }
    if (v21)
    {
      v21[3] = color_space_state_register((unsigned char *)v21[3]);
      CGColorSpaceSetProperty((uint64_t)v21, @"kCGColorSpaceLinearDerivative", v21);
    }
    goto LABEL_16;
  }
  uint64_t v21 = 0;
  uint64_t v2 = 0;
  if (LinearizedProfile)
  {
LABEL_16:
    CFRelease(LinearizedProfile);
    uint64_t v2 = (CGColorSpace *)v21;
  }
  if (v7) {
    CFRelease(v7);
  }
  CFRelease(v4);
  return v2;
}

BOOL __CGColorSpaceIsLinear_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 28);
  if (!v2) {
    return 1;
  }
  if (v2 != 1) {
    return 0;
  }
  uint64_t v3 = **(void **)(a2 + 52);
  if (CGColorTRCGetGammaID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorTRCGetGammaID_cglibrarypredicate, &__block_literal_global_8);
  }
  return CGColorTRCGetGammaID_f(v3) == 7;
}

uint64_t CGColorSpaceGetAlternateColorSpace(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    int v2 = *(_DWORD *)(v1 + 24);
    switch(v2)
    {
      case 6:
        uint64_t v3 = *(void *)(v1 + 96) + 56;
        break;
      case 10:
        uint64_t v3 = *(void *)(v1 + 96) + 48;
        break;
      case 8:
        uint64_t v3 = *(void *)(v1 + 96) + 8;
        break;
      default:
        return 0;
    }
    return *(void *)v3;
  }
  return result;
}

uint64_t CGColorSpaceCreateCopyWithNativeGamma(CGColorSpace *a1)
{
  v28[3] = *(void **)MEMORY[0x1E4F143B8];
  CFDataRef v1 = CGColorSpaceCopyICCData(a1);
  if (!v1) {
    return 0;
  }
  CFDataRef v2 = v1;
  if (CGCMSUtilsCreateProfileWithNativeGamma_cglibrarypredicate != -1) {
    dispatch_once(&CGCMSUtilsCreateProfileWithNativeGamma_cglibrarypredicate, &__block_literal_global_453);
  }
  ProfileWithNativeGamma_f = (void *)CGCMSUtilsCreateProfileWithNativeGamma_f(v2, 0);
  if (ProfileWithNativeGamma_f)
  {
    values[0] = CFNumberCreate(0, kCFNumberSInt16Type, &CGCMSUtilsCreateProfileWithNativeGamma_iccDate);
    values[1] = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F59E);
    values[2] = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F5A0);
    values[3] = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F5A2);
    values[4] = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F5A4);
    values[5] = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F5A6);
    CFArrayRef v4 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 6, MEMORY[0x1E4F1D510]);
    for (uint64_t i = 0; i != 6; ++i)
    {
      uint64_t v6 = values[i];
      if (v6) {
        CFRelease(v6);
      }
    }
    *(_OWORD *)uint64_t v26 = xmmword_1E52A0F48;
    *(void *)&v26[16] = @"Date";
    v28[0] = @"copyWithNativeGamma";
    v28[1] = ProfileWithNativeGamma_f;
    v28[2] = v4;
    CFDictionaryRef v7 = CFDictionaryCreate(0, (const void **)v26, (const void **)v28, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (CGCMSUtilsCreateProfileWithNativeGamma_cglibrarypredicate_461 != -1) {
      dispatch_once(&CGCMSUtilsCreateProfileWithNativeGamma_cglibrarypredicate_461, &__block_literal_global_464);
    }
    ProfileWithNativeGamma_f = (void *)CGCMSUtilsCreateProfileWithNativeGamma_f_460(v7);
    CFRelease(v7);
  }
  if (CGColorSpaceCreateCopyWithNativeGamma_cglibrarypredicate != -1) {
    dispatch_once(&CGColorSpaceCreateCopyWithNativeGamma_cglibrarypredicate, &__block_literal_global_70_23017);
  }
  uint64_t CopyWithNativeGamma_f = CGColorSpaceCreateCopyWithNativeGamma_f(ProfileWithNativeGamma_f, 0);
  CFDataRef v9 = (const __CFData *)CopyWithNativeGamma_f;
  if (ProfileWithNativeGamma_f && CopyWithNativeGamma_f)
  {
    memcpy(values, &CGICCProfileInfoInitializer, sizeof(values));
    CGCMSUtilsGetICCProfileInfo(ProfileWithNativeGamma_f, (uint64_t)values, 1, v10, v11, v12, v13, v14);
    memcpy(v26, values, sizeof(v26));
    icc = (atomic_uint *)color_space_state_create_icc(ProfileWithNativeGamma_f, v9, (int *)v26);
    uint64_t v23 = CGColorSpaceCreateWithState(icc, v16, v17, v18, v19, v20, v21, v22);
    if (icc && atomic_fetch_add_explicit(icc, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      color_space_state_dealloc((uint64_t)icc);
    }
    if (v23) {
      *(void *)(v23 + 24) = color_space_state_register(*(unsigned char **)(v23 + 24));
    }
    goto LABEL_23;
  }
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  if (ProfileWithNativeGamma_f)
  {
LABEL_23:
    CFRelease(ProfileWithNativeGamma_f);
    uint64_t v24 = v23;
  }
  if (v9) {
    CFRelease(v9);
  }
  CFRelease(v2);
  return v24;
}

CGColorSpaceRef CGColorSpaceCreateCopyWithStandardRange(CGColorSpaceRef s)
{
  CGColorSpaceRef colorspace_with_ColorSync_profile = colorspace_from_properties((uint64_t)s, @"kCGColorSpaceStandardRangeOriginal");
  if (!colorspace_with_ColorSync_profile)
  {
    if (!s) {
      return 0;
    }
    if (!*(unsigned char *)(*((void *)s + 3) + 13))
    {
      CFRetain(s);
      return s;
    }
    CFDataRef v3 = CGColorSpaceCopyICCData(s);
    if (v3)
    {
      CFDataRef v4 = v3;
      if (CGColorSpaceCreateCopyWithStandardRange_cglibrarypredicate != -1) {
        dispatch_once(&CGColorSpaceCreateCopyWithStandardRange_cglibrarypredicate, &__block_literal_global_73_23022);
      }
      CopyWithStandardRange_f = (const void *)CGColorSpaceCreateCopyWithStandardRange_f(v4, 0);
      if (CopyWithStandardRange_f)
      {
        uint64_t v6 = CopyWithStandardRange_f;
        CGColorSpaceRef colorspace_with_ColorSync_profile = create_colorspace_with_ColorSync_profile(CopyWithStandardRange_f, 0);
        CGColorSpaceSetProperty((uint64_t)colorspace_with_ColorSync_profile, @"kCGColorSpaceStandardRangeOriginal", colorspace_with_ColorSync_profile);
        CFRelease(v6);
      }
      else
      {
        CGColorSpaceRef colorspace_with_ColorSync_profile = 0;
      }
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return colorspace_with_ColorSync_profile;
}

uint64_t CGColorSpaceCreateCopyWithPQTransferFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGPostError((uint64_t)"CGColorSpaceCreateCopyWithPQTransferFunctions is decomissioned. Please use CGColorSpaceCreateFromCICP", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t CGColorSpaceCopyICCProfileASCIIDescriptionString(uint64_t a1)
{
  if (a1 && (CFDataRef v1 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 112) + 40)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

BOOL CGColorSpaceDumpPropertyList(CGColorSpace *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFPropertyListRef v2 = CGColorSpaceCopyPropertyList(a1);
  if (!v2) {
    return 0;
  }
  CFDataRef v3 = v2;
  Datdouble a = CFPropertyListCreateData(0, v2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (Data)
  {
    CFDataRef v5 = Data;
    bzero(v21, 0x400uLL);
    *(void *)__filename = MEMORY[0x1E4F143A8];
    uint64_t v16 = 0x40000000;
    uint64_t v17 = __initialize_path_block_invoke;
    uint64_t v18 = &__block_descriptor_tmp_104_23040;
    uint64_t v19 = v21;
    if (initialize_path_predicate != -1) {
      dispatch_once(&initialize_path_predicate, __filename);
    }
    if (v21[0] && (CFStringRef v6 = CFCopyDescription(a1)) != 0)
    {
      CFStringRef v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x600u);
      if (!CStringPtr)
      {
        CStringPtr = buffer;
        CFStringGetCString(v7, buffer, 256, 0x600u);
      }
      bzero(__filename, 0x400uLL);
      __sprintf_chk(__filename, 0, 0x400uLL, "%s/%s.plist", v21, CStringPtr);
      CFDataRef v9 = fopen(__filename, "w");
      if (v9)
      {
        uint64_t v10 = v9;
        size_t Length = CFDataGetLength(v5);
        BytePtr = CFDataGetBytePtr(v5);
        BOOL v13 = 0;
        if (BytePtr && Length) {
          BOOL v13 = fwrite(BytePtr, 1uLL, Length, v10) == Length;
        }
        fclose(v10);
      }
      else
      {
        BOOL v13 = 0;
      }
      CFRelease(v7);
    }
    else
    {
      BOOL v13 = 0;
    }
    CFRelease(v5);
  }
  else
  {
    BOOL v13 = 0;
  }
  CFRelease(v3);
  return v13;
}

size_t __initialize_path_block_invoke(uint64_t a1)
{
  size_t result = confstr(65537, *(char **)(a1 + 32), 0x400uLL);
  if (!result) {
    **(unsigned char **)(a1 + 32) = 0;
  }
  return result;
}

CGColorSpaceRef CGColorSpaceCreateWithURL(CFURLRef fileURL)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!fileURL) {
    return 0;
  }
  CFDataRef v1 = CFReadStreamCreateWithFile(0, fileURL);
  CGColorSpaceRef v2 = v1;
  if (!v1) {
    return v2;
  }
  if (!CFReadStreamOpen(v1))
  {
    CFRelease(v2);
    return 0;
  }
  for (uint64_t i = CFDataCreateMutable(0, 0); ; CFDataAppendBytes(i, buffer, v4))
  {
    CFIndex v4 = CFReadStreamRead(v2, buffer, 1024);
    if (!v4) {
      break;
    }
  }
  CFReadStreamClose(v2);
  CFRelease(v2);
  if (!i) {
    return 0;
  }
  *(void *)buffer = 0;
  CFPropertyListRef v5 = CFPropertyListCreateWithData(0, i, 0, (CFPropertyListFormat *)buffer, 0);
  if (v5)
  {
    CFStringRef v6 = v5;
    CGColorSpaceRef v2 = CGColorSpaceCreateWithPropertyList(v5);
    CFRelease(v6);
  }
  else
  {
    CGColorSpaceRef v2 = 0;
  }
  CFRelease(i);
  return v2;
}

void TrueTypeSubset::emit_definition(TrueTypeSubset *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((void *)this + 13))
  {
    uint64_t v9 = *((void *)this + 1);
    uint64_t v10 = **(void **)(v9 + 8);
    PDFDocumentBeginObject(v10, *((void *)this + 6), a3, a4, a5, a6, a7, a8);
    PDFDocumentPrintf(v10, (uint64_t)"<<", v11, v12, v13, v14, v15, v16, v104);
    PDFDocumentPrintf(v10, (uint64_t)"/Type /Font", v17, v18, v19, v20, v21, v22, v105);
    PDFDocumentPrintf(v10, (uint64_t)"/Subtype /TrueType", v23, v24, v25, v26, v27, v28, v106);
    int v35 = (char *)*((void *)this + 8);
    if (*((char *)this + 87) >= 0) {
      int v35 = (char *)this + 64;
    }
    PDFDocumentPrintf(v10, (uint64_t)"/BaseFont /%N", v29, v30, v31, v32, v33, v34, (uint64_t)v35);
    FontDescriptor::FontDescriptor((FontDescriptor *)v110, (const PDFFont *)v9, *((_DWORD *)this + 10) == 1);
    PDFDocumentPrintReference(v10, (uint64_t)"/FontDescriptor %R", v111, v36, v37, v38, v39, v40);
    if (*((_DWORD *)this + 10) == 1)
    {
      PDFDocumentPrintf(v10, (uint64_t)"/Encoding /MacRomanEncoding", v41, v42, v43, v44, v45, v46, v107);
      uint64_t v47 = 0;
    }
    else
    {
      uint64_t v47 = PDFXRefTableAddObject(*(void **)(v10 + 464));
      PDFDocumentPrintReference(v10, (uint64_t)"/ToUnicode %R", v47, v48, v49, v50, v51, v52);
    }
    FontSubset::emit_widths(this);
    PDFDocumentPrintf(v10, (uint64_t)">>", v53, v54, v55, v56, v57, v58, v107);
    PDFDocumentEndObject(v10, v59, v60, v61, v62, v63, v64, v65);
    if (v47)
    {
      uint64_t v109 = v9;
      FontSubset::get_encoding_vector((FontSubset *)__p, (uint64_t)this);
      ToUnicode::write<std::vector<unsigned short>>((uint64_t)&v109, v47, __p);
      if (__p[0]) {
        operator delete(__p[0]);
      }
    }
    if (*(unsigned char *)(v9 + 56))
    {
      FontDescriptor::emit_definition((uint64_t)v110, (uint64_t)this + 64, 0, v66, v67, v68, v69, v70);
      return;
    }
    uint64_t v71 = PDFXRefTableAddObject(*(void **)(v10 + 464));
    FontDescriptor::emit_definition((uint64_t)v110, (uint64_t)this + 64, v71, v72, v73, v74, v75, v76);
    unint64_t v77 = (void *)*((void *)this + 1);
    glyph_index_set = FontSubset::create_glyph_index_set(this);
    if (*((_DWORD *)this + 10) == 1)
    {
      CFDataRef embedded_font = (const __CFData *)PDFFont::create_embedded_font(v77, (uint64_t *)this + 8, (uint64_t)glyph_index_set, 0, 0);
    }
    else
    {
      FontSubset::get_encoding_vector((FontSubset *)__p, (uint64_t)this);
      CGAffineTransform v80 = __p[0];
      if (__p[1] == __p[0])
      {
        __break(1u);
        return;
      }
      CFDataRef embedded_font = (const __CFData *)PDFFont::create_embedded_font(v77, (uint64_t *)this + 8, (uint64_t)glyph_index_set, (uint64_t)__p[0], 0);
      if (v80) {
        operator delete(v80);
      }
    }
    CGFontIndexSetRelease((void **)glyph_index_set);
    if (embedded_font)
    {
      if ((unint64_t)(CFDataGetLength(embedded_font) - 0x80000000) > 0xFFFFFFFF80000000)
      {
        uint64_t v81 = **(void **)(*((void *)this + 1) + 8);
        float v82 = PDFStreamCreateWithObjectNumber(v81, v71);
        PDFDocumentBeginObject(*v82, v82[1], v83, v84, v85, v86, v87, v88);
        PDFDocumentPrintf(*v82, (uint64_t)"<<", v89, v90, v91, v92, v93, v94, v108);
        CFIndex Length = CFDataGetLength(embedded_font);
        int v96 = Length;
        PDFDocumentPrintf(v81, (uint64_t)"/Length1 %d", v97, v98, v99, v100, v101, v102, Length);
        PDFStreamBeginData((CGDataConsumerRef)v82);
        BytePtr = CFDataGetBytePtr(embedded_font);
        CGDataConsumerPutBytes(v82[3], (uint64_t)BytePtr, v96);
        PDFStreamEndData(v82);
        PDFStreamEnd((CFDataRef *)v82);
        PDFStreamRelease((uint64_t)v82);
      }
      CFRelease(embedded_font);
    }
  }
}

void sub_1850BAB9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (v14) {
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

void TrueTypeSubset::~TrueTypeSubset(TrueTypeSubset *this)
{
  FontSubset::~FontSubset(this);

  JUMPOUT(0x18532A2A0);
}

void PDFFormRelease(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if ((*(_DWORD *)a1)-- == 1)
    {
      if (*((_DWORD *)a1 + 6) <= 1u)
      {
        uint64_t v10 = (const void *)a1[4];
        if (v10) {
          CFRelease(v10);
        }
      }
      uint64_t v11 = a1[2];
      if (v11) {
        PDFContentStreamRelease(v11, a2, a3, a4, a5, a6, a7, a8);
      }
      free(a1);
    }
  }
}

CGColorRef pattern_create_default_color(CGColorSpace *a1)
{
  if (**(void **)(*((void *)a1 + 3) + 96)) {
    UncoloredEmptCGFloat y = (CGPattern *)CGPatternCreateUncoloredEmpty();
  }
  else {
    UncoloredEmptCGFloat y = (CGPattern *)CGPatternCreateColoredEmpty();
  }
  CFDataRef v3 = UncoloredEmpty;
  uint64_t v4 = *((void *)a1 + 3);
  if (v4) {
    CFPropertyListRef v5 = *(const CGFloat **)(v4 + 40);
  }
  else {
    CFPropertyListRef v5 = 0;
  }
  CGColorRef v6 = CGColorCreateWithPattern(a1, UncoloredEmpty, v5);
  if (v3) {
    CFRelease(v3);
  }
  return v6;
}

uint64_t pattern_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

void pattern_finalize_23107(uint64_t a1)
{
  CFDataRef v1 = *(CGColorSpaceRef **)(a1 + 96);
  if (v1) {
    CGColorSpaceRelease(*v1);
  }
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)23,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  uint64_t v17 = *result;
  unint64_t v18 = *a3;
  uint64_t v19 = *a2;
  uint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0xFFFFFFFFFFFFLL;
  a13.i64[1] = 0xFFFFFFFFFFFFLL;
  v29.i64[0] = 0x800000008000;
  v29.i64[1] = 0x800000008000;
  v30.i64[0] = -1;
  v30.i64[1] = -1;
  while (1)
  {
    __int32 v31 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      uint64_t v55 = (int8x16_t *)&v20[v16];
      uint64_t v56 = (int8x16_t *)v20;
      do
        uint64_t v57 = v56++;
      while (v56 <= v55 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v57)) & 0x80) != 0);
      do
      {
        uint64_t v58 = v57;
        uint64_t v57 = (int8x16_t *)((char *)v57 + 4);
      }
      while (v57 <= v55 && !v58->i32[0]);
      if (v58 < v55)
      {
        while (!v58->i8[0])
        {
          uint64_t v58 = (int8x16_t *)((char *)v58 + 1);
          if (v58 >= v55)
          {
            uint64_t v58 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v59 = (char *)v58 - v20;
      int64_t v60 = ((char *)v58 - v20) * a6;
      v17 += v60;
      v19 += v60;
      v20 += v60;
      v16 -= v59;
      goto LABEL_37;
    }
    if (v31 != 0xFFFF) {
      break;
    }
    uint64_t v32 = (int8x16_t *)&v20[v16];
    uint64_t v33 = (int8x16_t *)v20;
    do
      uint64_t v34 = v33++;
    while (v33 <= v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, v30)) & 0x80) != 0);
    do
    {
      int v35 = v34;
      uint64_t v34 = (int8x16_t *)((char *)v34 + 4);
    }
    while (v34 <= v32 && v35->i32[0] == -1);
    if (v35 < v32)
    {
      while (v35->u8[0] == 255)
      {
        int v35 = (int8x16_t *)((char *)v35 + 1);
        if (v35 >= v32)
        {
          int v35 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v36 = 0;
    int64_t v37 = (char *)v35 - v20;
    unint64_t v38 = (char *)v35 - v20;
    do
    {
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v17->i8[v36], v23);
      int8x16_t v40 = vorrq_s8(*(int8x16_t *)&v19->i8[v36], v25);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880);
      int16x8_t v42 = (int16x8_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v43 = vminq_u16((uint16x8_t)v39, (uint16x8_t)v41);
      int8x16_t v44 = (int8x16_t)vminq_u16((uint16x8_t)v40, (uint16x8_t)v42);
      uint16x8_t v45 = (uint16x8_t)vmvnq_s8(v44);
      uint16x8_t v46 = (uint16x8_t)vandq_s8(v44, (int8x16_t)a13);
      int8x16_t v47 = (int8x16_t)vcgtq_u16(v46, v45);
      uint16x8_t v48 = vabdq_u16(v45, v46);
      uint32x4_t v49 = vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v48.i8);
      uint32x4_t v50 = vmull_high_u16(v43, v48);
      uint32x4_t v51 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v49, v28), v29);
      uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v50, v28), v29);
      uint16x8_t v53 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v51, v51, 0x10uLL), 0x10uLL), vsraq_n_u32(v52, v52, 0x10uLL), 0x10uLL);
      int8x16_t v54 = vbslq_s8(v47, (int8x16_t)vqsubq_u16((uint16x8_t)v44, v53), (int8x16_t)vqaddq_u16((uint16x8_t)v44, v53));
      int8x16_t v15 = (int8x16_t)vceqzq_s16(v41);
      *(int8x16_t *)&v19->i8[v36] = vbslq_s8(v15, v40, vbslq_s8((int8x16_t)vceqzq_s16(v42), v39, (int8x16_t)vminq_u16((uint16x8_t)v54, (uint16x8_t)vqtbl1q_s8(v54, (int8x16_t)xmmword_1850CD880))));
      v20 += v26;
      v38 -= 2;
      v36 += v27;
    }
    while (v38 > 1);
    uint64_t v19 = (int8x8_t *)((char *)v19 + v36);
    uint64_t v17 = (int8x8_t *)((char *)v17 + v36);
    unint64_t v16 = v16 - v37 + v38;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v61 = 0;
  while (1)
  {
    v15.i32[0] = v31;
    int16x8_t v62 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v63 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v61], v23);
    int8x16_t v64 = vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v62)), *(int8x16_t *)&v19->i8[v61]);
    uint32x4_t v65 = vmull_u16(*(uint16x4_t *)v63.i8, *(uint16x4_t *)v62.i8);
    uint32x4_t v66 = vmull_high_u16(v63, (uint16x8_t)v62);
    uint32x4_t v67 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v65, v28), v29);
    *(uint16x4_t *)v67.i8 = vqshrn_n_u32(vsraq_n_u32(v67, v67, 0x10uLL), 0x10uLL);
    uint32x4_t v68 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v66, v28), v29);
    uint32x4_t v69 = vsraq_n_u32(v68, v68, 0x10uLL);
    *(uint16x4_t *)v65.i8 = vqshrn_n_u32(v69, 0x10uLL);
    *(int16x4_t *)v70.i8 = vdup_lane_s16(*(int16x4_t *)v67.i8, 3);
    uint16x4_t v71 = vmin_u16(*(uint16x4_t *)v67.i8, *(uint16x4_t *)v70.i8);
    int8x16_t v72 = (int8x16_t)vqshrn_high_n_u32(*(uint16x4_t *)v67.i8, v69, 0x10uLL);
    v70.u64[1] = (unint64_t)vdup_lane_s16(*(int16x4_t *)v65.i8, 3);
    int16x8_t v73 = (int16x8_t)vqtbl1q_s8(v64, (int8x16_t)xmmword_1850CD880);
    int8x16_t v74 = (int8x16_t)vminq_u16((uint16x8_t)v64, (uint16x8_t)v73);
    uint16x8_t v75 = (uint16x8_t)vmvnq_s8(v74);
    uint16x8_t v76 = (uint16x8_t)vandq_s8(v74, (int8x16_t)a13);
    int8x16_t v77 = (int8x16_t)vcgtq_u16(v76, v75);
    int8x16_t v78 = (int8x16_t)vabdq_u16(v75, v76);
    uint32x4_t v79 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(v71, *(uint16x4_t *)v78.i8), v28), v29);
    uint32x4_t v80 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(vmin_u16(*(uint16x4_t *)v65.i8, (uint16x4_t)v70.u64[1]), (uint16x4_t)*(_OWORD *)&vextq_s8(v78, v78, 8uLL)), v28), v29);
    uint16x8_t v81 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v79, v79, 0x10uLL), 0x10uLL), vsraq_n_u32(v80, v80, 0x10uLL), 0x10uLL);
    int8x16_t v82 = vbslq_s8(v77, (int8x16_t)vqsubq_u16((uint16x8_t)v74, v81), (int8x16_t)vqaddq_u16((uint16x8_t)v74, v81));
    int8x16_t v83 = vbslq_s8((int8x16_t)vceqzq_s16(v73), v72, (int8x16_t)vminq_u16((uint16x8_t)v82, (uint16x8_t)vqtbl1q_s8(v82, (int8x16_t)xmmword_1850CD880)));
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v70);
    *(int8x16_t *)&v19->i8[v61] = vbslq_s8(v15, v64, v83);
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v31 = *(unsigned __int16 *)v20;
    v61 += v27;
    if ((unsigned __int16)(v31 - 1) >= 0xFFFEu)
    {
      uint64_t v17 = (int8x8_t *)((char *)v17 + v61);
      uint64_t v19 = (int8x8_t *)((char *)v19 + v61);
      goto LABEL_37;
    }
  }
  uint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v61);
  uint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v61);
LABEL_40:
  uint64_t v84 = v16 + a14;
  if (v84)
  {
    if (a7) {
      __int16 v85 = 0;
    }
    else {
      __int16 v85 = -1;
    }
    int8x8_t v86 = 0;
    v86.i16[3] = v85;
    int8x8_t v87 = 0;
    if (a8) {
      __int16 v88 = 0;
    }
    else {
      __int16 v88 = -1;
    }
    v87.i16[3] = v88;
    uint32x4_t v89 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v90.i64[0] = 0x800000008000;
    v90.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v91 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int16x4_t v92 = (int16x4_t)vorr_s8(*v19, vbic_s8(v87, (int8x8_t)vceqz_s16(v91)));
        a13 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v86), (uint16x4_t)v91), v89), v90);
        *(uint16x4_t *)a13.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a13, (uint32x4_t)a13, 0x10uLL), 0x10uLL);
        int16x4_t v93 = vdup_lane_s16(*(int16x4_t *)a13.i8, 3);
        int16x4_t v94 = vdup_lane_s16(v92, 3);
        int8x8_t v95 = (int8x8_t)vmin_u16((uint16x4_t)v92, (uint16x4_t)v94);
        uint16x4_t v96 = (uint16x4_t)vmvn_s8(v95);
        uint16x4_t v97 = (uint16x4_t)v95;
        v97.i16[3] = 0;
        uint32x4_t v98 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(vmin_u16(*(uint16x4_t *)a13.i8, (uint16x4_t)v93), vabd_u16(v96, v97)), v89), v90);
        *(uint16x4_t *)v98.i8 = vqshrn_n_u32(vsraq_n_u32(v98, v98, 0x10uLL), 0x10uLL);
        *(int8x8_t *)v98.i8 = vbsl_s8((int8x8_t)vcgt_u16(v97, v96), (int8x8_t)vqsub_u16((uint16x4_t)v95, *(uint16x4_t *)v98.i8), (int8x8_t)vqadd_u16((uint16x4_t)v95, *(uint16x4_t *)v98.i8));
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vceqz_s16(v93), (int8x8_t)v92, vbsl_s8((int8x8_t)vceqz_s16(v94), *(int8x8_t *)a13.i8, (int8x8_t)vmin_u16(*(uint16x4_t *)v98.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v98.i8, 3))));
        *uint64_t v19 = *(int8x8_t *)a13.i8;
      }
      uint64_t v99 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v99 >= v18) {
        uint64_t v100 = -(uint64_t)a5;
      }
      else {
        uint64_t v100 = 0;
      }
      uint64_t v17 = &v99[v100];
      v19 += a6;
      --v84;
    }
    while (v84);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)22,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  uint64_t v17 = *result;
  unint64_t v18 = *a3;
  uint64_t v19 = *a2;
  uint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0x800000008000;
  a13.i64[1] = 0x800000008000;
  v29.i64[0] = -1;
  v29.i64[1] = -1;
  while (1)
  {
    __int32 v30 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      uint64_t v57 = (int8x16_t *)&v20[v16];
      uint64_t v58 = (int8x16_t *)v20;
      do
        int64_t v59 = v58++;
      while (v58 <= v57 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v59)) & 0x80) != 0);
      do
      {
        int64_t v60 = v59;
        int64_t v59 = (int8x16_t *)((char *)v59 + 4);
      }
      while (v59 <= v57 && !v60->i32[0]);
      if (v60 < v57)
      {
        while (!v60->i8[0])
        {
          int64_t v60 = (int8x16_t *)((char *)v60 + 1);
          if (v60 >= v57)
          {
            int64_t v60 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v61 = (char *)v60 - v20;
      int64_t v62 = ((char *)v60 - v20) * a6;
      v17 += v62;
      v19 += v62;
      v20 += v62;
      v16 -= v61;
      goto LABEL_37;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    __int32 v31 = (int8x16_t *)&v20[v16];
    uint64_t v32 = (int8x16_t *)v20;
    do
      uint64_t v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v29)) & 0x80) != 0);
    do
    {
      uint64_t v34 = v33;
      uint64_t v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint64_t v34 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v20;
    unint64_t v37 = (char *)v34 - v20;
    do
    {
      int8x16_t v38 = vorrq_s8(*(int8x16_t *)&v17->i8[v35], v23);
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      int16x8_t v40 = (int16x8_t)vqtbl1q_s8(v38, (int8x16_t)xmmword_1850CD880);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v42 = vminq_u16((uint16x8_t)v38, (uint16x8_t)v40);
      uint16x8_t v43 = vminq_u16((uint16x8_t)v39, (uint16x8_t)v41);
      uint32x4_t v44 = vmull_lane_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v38.i8, 3);
      v44.i32[3] = 0;
      uint32x4_t v45 = vmull_high_laneq_u16(v43, (uint16x8_t)v38, 7);
      uint16x8_t v46 = (uint16x8_t)vabdq_u32(vmull_lane_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v39.i8, 3), v44);
      v45.i32[3] = 0;
      uint32x4_t v47 = vabdq_u32(vmull_high_laneq_u16(v42, (uint16x8_t)v39, 7), v45);
      uint16x8_t v48 = (uint16x8_t)vmvnq_s8((int8x16_t)v40);
      uint32x4_t v49 = vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v48.i8);
      uint32x4_t v50 = vqaddq_u32(v47, vmull_high_u16(v43, v48));
      uint16x8_t v51 = (uint16x8_t)vmvnq_s8((int8x16_t)v41);
      uint32x4_t v52 = vmull_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v51.i8);
      uint32x4_t v53 = vqaddq_u32(v50, vmull_high_u16(v42, v51));
      uint32x4_t v54 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)v46, v49), v52), v28), a13);
      *(uint16x4_t *)v54.i8 = vqshrn_n_u32(vsraq_n_u32(v54, v54, 0x10uLL), 0x10uLL);
      uint32x4_t v55 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v53, v28), a13);
      uint32x4_t v56 = vsraq_n_u32(v55, v55, 0x10uLL);
      *(int16x4_t *)v46.i8 = vdup_lane_s16(*(int16x4_t *)v54.i8, 3);
      v46.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v56, 0x10uLL), 3);
      int8x16_t v15 = vbslq_s8((int8x16_t)vceqzq_s16(v41), v38, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v54.i8, v56, 0x10uLL), v46));
      *(int8x16_t *)&v19->i8[v35] = vbslq_s8((int8x16_t)vceqzq_s16(v40), v39, v15);
      v20 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    uint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    uint64_t v17 = (int8x8_t *)((char *)v17 + v35);
    unint64_t v16 = v16 - v36 + v37;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v63 = 0;
  while (1)
  {
    v15.i32[0] = v30;
    int16x8_t v64 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v65 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v63], v23);
    int16x8_t v66 = (int16x8_t)vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v64)), *(int8x16_t *)&v19->i8[v63]);
    uint32x4_t v67 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v65.i8, *(uint16x4_t *)v64.i8), v28), a13);
    int16x4_t v68 = (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v67, v67, 0x10uLL), 0x10uLL);
    uint32x4_t v69 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v65, (uint16x8_t)v64), v28), a13);
    uint32x4_t v70 = vsraq_n_u32(v69, v69, 0x10uLL);
    int16x4_t v71 = (int16x4_t)vqshrn_n_u32(v70, 0x10uLL);
    *(int16x4_t *)v64.i8 = vdup_lane_s16(v68, 3);
    int16x8_t v72 = (int16x8_t)vqtbl1q_s8((int8x16_t)v66, (int8x16_t)xmmword_1850CD880);
    int8x16_t v73 = (int8x16_t)vminq_u16((uint16x8_t)v66, (uint16x8_t)v72);
    uint16x4_t v74 = vmin_u16((uint16x4_t)v68, *(uint16x4_t *)v64.i8);
    uint32x4_t v75 = vmull_lane_u16(*(uint16x4_t *)v73.i8, (uint16x4_t)v68, 3);
    int8x16_t v76 = (int8x16_t)vqshrn_high_n_u32((uint16x4_t)v68, v70, 0x10uLL);
    v64.i64[1] = vdupq_lane_s16(v71, 3).u64[0];
    int8x16_t v77 = (int8x16_t)vdupq_laneq_s16(v66, 7);
    uint16x4_t v78 = vmin_u16((uint16x4_t)v71, (uint16x4_t)v64.u64[1]);
    uint16x4_t v79 = (uint16x4_t)vextq_s8(v73, v73, 8uLL).u64[0];
    v75.i32[3] = 0;
    uint32x4_t v80 = vmull_high_lane_u16((uint16x8_t)v73, (uint16x4_t)v71, 3);
    v80.i32[3] = 0;
    uint32x4_t v81 = vqaddq_u32(vabdq_u32(vmull_lane_u16(v74, *(uint16x4_t *)v66.i8, 3), v75), vmull_u16(*(uint16x4_t *)v73.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v64.i8)));
    int8x16_t v82 = vmvnq_s8((int8x16_t)v72);
    uint32x4_t v83 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v81, vmull_u16(v74, *(uint16x4_t *)v82.i8)), v28), a13);
    *(uint16x4_t *)v83.i8 = vqshrn_n_u32(vsraq_n_u32(v83, v83, 0x10uLL), 0x10uLL);
    uint32x4_t v84 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vabdq_u32(vmull_u16(v78, (uint16x4_t)*(_OWORD *)&vextq_s8(v77, v77, 8uLL)), v80), vmull_u16(v79, (uint16x4_t)vmvn_s8((int8x8_t)v64.u64[1]))), vmull_u16(v78, (uint16x4_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL))), v28), a13);
    uint32x4_t v85 = vsraq_n_u32(v84, v84, 0x10uLL);
    *(int16x4_t *)v82.i8 = vdup_lane_s16(*(int16x4_t *)v83.i8, 3);
    v82.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v85, 0x10uLL), 3);
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v64);
    *(int8x16_t *)&v19->i8[v63] = vbslq_s8(v15, (int8x16_t)v66, vbslq_s8((int8x16_t)vceqzq_s16(v72), v76, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v83.i8, v85, 0x10uLL), (uint16x8_t)v82)));
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v30 = *(unsigned __int16 *)v20;
    v63 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      uint64_t v17 = (int8x8_t *)((char *)v17 + v63);
      uint64_t v19 = (int8x8_t *)((char *)v19 + v63);
      goto LABEL_37;
    }
  }
  uint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v63);
  uint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v63);
LABEL_40:
  uint64_t v86 = v16 + a14;
  if (v86)
  {
    if (a7) {
      __int16 v87 = 0;
    }
    else {
      __int16 v87 = -1;
    }
    int8x8_t v88 = 0;
    v88.i16[3] = v87;
    int8x8_t v89 = 0;
    if (a8) {
      __int16 v90 = 0;
    }
    else {
      __int16 v90 = -1;
    }
    v89.i16[3] = v90;
    uint32x4_t v91 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v92.i64[0] = 0x800000008000;
    v92.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v93 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int16x4_t v94 = (int16x4_t)vorr_s8(*v19, vbic_s8(v89, (int8x8_t)vceqz_s16(v93)));
        uint32x4_t v95 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v88), (uint16x4_t)v93), v91), v92);
        *(uint16x4_t *)v95.i8 = vqshrn_n_u32(vsraq_n_u32(v95, v95, 0x10uLL), 0x10uLL);
        int16x4_t v96 = vdup_lane_s16(*(int16x4_t *)v95.i8, 3);
        int16x4_t v97 = vdup_lane_s16(v94, 3);
        uint16x4_t v98 = vmin_u16(*(uint16x4_t *)v95.i8, (uint16x4_t)v96);
        uint16x4_t v99 = vmin_u16((uint16x4_t)v94, (uint16x4_t)v97);
        uint32x4_t v100 = vmull_lane_u16(v99, *(uint16x4_t *)v95.i8, 3);
        v100.i32[3] = 0;
        uint32x4_t v101 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vabdq_u32(vmull_lane_u16(v98, (uint16x4_t)v94, 3), v100), vmull_u16(v99, (uint16x4_t)vmvn_s8((int8x8_t)v96))), vmull_u16(v98, (uint16x4_t)vmvn_s8((int8x8_t)v97))), v91), v92);
        *(uint16x4_t *)v101.i8 = vqshrn_n_u32(vsraq_n_u32(v101, v101, 0x10uLL), 0x10uLL);
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vceqz_s16(v96), (int8x8_t)v94, vbsl_s8((int8x8_t)vceqz_s16(v97), *(int8x8_t *)v95.i8, (int8x8_t)vmin_u16(*(uint16x4_t *)v101.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v101.i8, 3))));
        *uint64_t v19 = *(int8x8_t *)a13.i8;
      }
      uint64_t v102 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v102 >= v18) {
        uint64_t v103 = -(uint64_t)a5;
      }
      else {
        uint64_t v103 = 0;
      }
      uint64_t v17 = &v102[v103];
      v19 += a6;
      --v86;
    }
    while (v86);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)21,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, int32x4_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v18 = a16;
  uint64_t v19 = *result;
  unint64_t v20 = *a3;
  unsigned int v21 = *a2;
  int8x16_t v22 = *a4;
  if (a16 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFFFF000000000000;
  v24.i64[1] = 0xFFFF000000000000;
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v23), v24);
  if (a8) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = -1;
  }
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s16(v26), v24);
  uint64_t v28 = 2 * a6;
  uint64_t v29 = 16 * a6;
  uint32x4_t v30 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a14.i64[0] = 0x800000008000;
  a14.i64[1] = 0x800000008000;
  v31.i64[0] = -1;
  v31.i64[1] = -1;
  while (1)
  {
    __int32 v32 = *(unsigned __int16 *)v22;
    if (!*(_WORD *)v22)
    {
      uint16x8_t v65 = (int8x16_t *)&v22[v18];
      int16x8_t v66 = (int8x16_t *)v22;
      do
        uint32x4_t v67 = v66++;
      while (v66 <= v65 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v67)) & 0x80) != 0);
      do
      {
        int16x4_t v68 = v67;
        uint32x4_t v67 = (int8x16_t *)((char *)v67 + 4);
      }
      while (v67 <= v65 && !v68->i32[0]);
      if (v68 < v65)
      {
        while (!v68->i8[0])
        {
          int16x4_t v68 = (int8x16_t *)((char *)v68 + 1);
          if (v68 >= v65)
          {
            int16x4_t v68 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      int64_t v69 = (char *)v68 - v22;
      int64_t v70 = ((char *)v68 - v22) * a6;
      v19 += v70;
      v21 += v70;
      v22 += v70;
      v18 -= v69;
      goto LABEL_37;
    }
    if (v32 != 0xFFFF) {
      break;
    }
    uint64_t v33 = (int8x16_t *)&v22[v18];
    uint64_t v34 = (int8x16_t *)v22;
    do
      uint64_t v35 = v34++;
    while (v34 <= v33 && (vminvq_u8((uint8x16_t)vceqq_s8(*v35, v31)) & 0x80) != 0);
    do
    {
      int64_t v36 = v35;
      uint64_t v35 = (int8x16_t *)((char *)v35 + 4);
    }
    while (v35 <= v33 && v36->i32[0] == -1);
    if (v36 < v33)
    {
      while (v36->u8[0] == 255)
      {
        int64_t v36 = (int8x16_t *)((char *)v36 + 1);
        if (v36 >= v33)
        {
          int64_t v36 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    uint64_t v37 = 0;
    int64_t v38 = (char *)v36 - v22;
    unint64_t v39 = (char *)v36 - v22;
    do
    {
      int8x16_t v40 = vorrq_s8(*(int8x16_t *)&v19->i8[v37], v25);
      int16x8_t v41 = (int16x8_t)vorrq_s8(*(int8x16_t *)&v21->i8[v37], v27);
      int16x8_t v42 = (int16x8_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_1850CD880);
      int16x8_t v43 = (int16x8_t)vqtbl1q_s8((int8x16_t)v41, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v44 = vminq_u16((uint16x8_t)v40, (uint16x8_t)v42);
      uint16x8_t v45 = vminq_u16((uint16x8_t)v41, (uint16x8_t)v43);
      int16x8_t v46 = (int16x8_t)vcgeq_u16(vrhaddq_u16((uint16x8_t)v42, (uint16x8_t)0), v44);
      int8x16_t v47 = (int8x16_t)vzip1q_s16(v46, v46);
      uint32x4_t v48 = vmull_u16(*(uint16x4_t *)v44.i8, *(uint16x4_t *)v45.i8);
      uint32x4_t v49 = vmull_high_u16(v44, v45);
      uint16x8_t v50 = vqsubq_u16((uint16x8_t)v43, v45);
      uint16x8_t v51 = vqsubq_u16((uint16x8_t)v42, v44);
      uint32x4_t v52 = vmull_u16(*(uint16x4_t *)v50.i8, *(uint16x4_t *)v51.i8);
      uint32x4_t v53 = vmull_high_u16(v50, v51);
      uint32x4_t v54 = (uint32x4_t)vbslq_s8((int8x16_t)vzip2q_s16(v46, v46), (int8x16_t)vqaddq_u32(v49, v49), (int8x16_t)vqsubq_u32(vmull_laneq_u16((uint16x4_t)vdup_laneq_s16(v41, 7), (uint16x8_t)v40, 7), vqaddq_u32(v53, v53)));
      uint32x4_t v55 = (uint32x4_t)vbslq_s8(v47, (int8x16_t)vqaddq_u32(v48, v48), (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v41.i8, 3), *(uint16x4_t *)v40.i8, 3), vqaddq_u32(v52, v52)));
      uint16x8_t v56 = (uint16x8_t)vmvnq_s8((int8x16_t)v42);
      uint32x4_t v57 = vmull_u16(*(uint16x4_t *)v45.i8, *(uint16x4_t *)v56.i8);
      uint32x4_t v58 = vqaddq_u32(v54, vmull_high_u16(v45, v56));
      uint16x8_t v59 = (uint16x8_t)vmvnq_s8((int8x16_t)v43);
      uint32x4_t v60 = vmull_u16(*(uint16x4_t *)v44.i8, *(uint16x4_t *)v59.i8);
      uint32x4_t v61 = vqaddq_u32(v58, vmull_high_u16(v44, v59));
      uint32x4_t v62 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(v55, v57), v60), v30), a14);
      *(uint16x4_t *)v62.i8 = vqshrn_n_u32(vsraq_n_u32(v62, v62, 0x10uLL), 0x10uLL);
      uint32x4_t v63 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v61, v30), a14);
      uint32x4_t v64 = vsraq_n_u32(v63, v63, 0x10uLL);
      *(int16x4_t *)v59.i8 = vdup_lane_s16(*(int16x4_t *)v62.i8, 3);
      v59.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v64, 0x10uLL), 3);
      int16x8_t v17 = (int16x8_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v62.i8, v64, 0x10uLL), v59);
      int8x16_t v16 = vbslq_s8((int8x16_t)vceqzq_s16(v43), v40, (int8x16_t)v17);
      *(int8x16_t *)&v21->i8[v37] = vbslq_s8((int8x16_t)vceqzq_s16(v42), (int8x16_t)v41, v16);
      v22 += v28;
      v39 -= 2;
      v37 += v29;
    }
    while (v39 > 1);
    unsigned int v21 = (int8x8_t *)((char *)v21 + v37);
    uint64_t v19 = (int8x8_t *)((char *)v19 + v37);
    unint64_t v18 = v18 - v38 + v39;
LABEL_37:
    if (v18 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v71 = 0;
  while (1)
  {
    v16.i32[0] = v32;
    int16x8_t v72 = (int16x8_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v73 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v19->i8[v71], v25);
    int16x8_t v74 = (int16x8_t)vorrq_s8(vbicq_s8(v27, (int8x16_t)vceqzq_s16(v72)), *(int8x16_t *)&v21->i8[v71]);
    uint32x4_t v75 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v73.i8, *(uint16x4_t *)v72.i8), v30), a14);
    int16x4_t v76 = (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v75, v75, 0x10uLL), 0x10uLL);
    uint32x4_t v77 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v73, (uint16x8_t)v72), v30), a14);
    uint32x4_t v78 = vsraq_n_u32(v77, v77, 0x10uLL);
    int16x4_t v79 = (int16x4_t)vqshrn_n_u32(v78, 0x10uLL);
    *(int16x4_t *)v72.i8 = vdup_lane_s16(v76, 3);
    *(uint16x4_t *)v73.i8 = vmin_u16((uint16x4_t)v76, *(uint16x4_t *)v72.i8);
    uint32x4_t v80 = vmull_lane_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v74.i8, 3), (uint16x4_t)v76, 3);
    int8x16_t v81 = (int8x16_t)vqshrn_high_n_u32((uint16x4_t)v76, v78, 0x10uLL);
    v72.u64[1] = (unint64_t)vdup_lane_s16(v79, 3);
    int16x8_t v82 = (int16x8_t)vqtbl1q_s8((int8x16_t)v74, (int8x16_t)xmmword_1850CD880);
    uint16x8_t v83 = vminq_u16((uint16x8_t)v81, (uint16x8_t)v72);
    int8x16_t v84 = (int8x16_t)vminq_u16((uint16x8_t)v74, (uint16x8_t)v82);
    int16x8_t v85 = (int16x8_t)vcgeq_u16(vrhaddq_u16((uint16x8_t)v72, (uint16x8_t)0), v83);
    uint32x4_t v86 = vmull_u16(*(uint16x4_t *)v73.i8, *(uint16x4_t *)v84.i8);
    uint16x4_t v87 = vmin_u16((uint16x4_t)v79, (uint16x4_t)v72.u64[1]);
    uint16x4_t v88 = (uint16x4_t)vextq_s8(v84, v84, 8uLL).u64[0];
    uint32x4_t v89 = vmull_u16(v87, v88);
    uint16x8_t v90 = vqsubq_u16((uint16x8_t)v82, (uint16x8_t)v84);
    uint16x8_t v91 = vqsubq_u16((uint16x8_t)v72, v83);
    uint32x4_t v92 = vmull_u16(*(uint16x4_t *)v90.i8, *(uint16x4_t *)v91.i8);
    uint32x4_t v93 = vmull_high_u16(v90, v91);
    int8x16_t v94 = vmvnq_s8((int8x16_t)v82);
    uint32x4_t v95 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)vbslq_s8((int8x16_t)vzip1q_s16(v85, v85), (int8x16_t)vqaddq_u32(v86, v86), (int8x16_t)vqsubq_u32(v80, vqaddq_u32(v92, v92))), vmull_u16(*(uint16x4_t *)v84.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v72.i8))), vmull_u16(*(uint16x4_t *)v73.i8, *(uint16x4_t *)v94.i8)), v30), a14);
    *(uint16x4_t *)v95.i8 = vqshrn_n_u32(vsraq_n_u32(v95, v95, 0x10uLL), 0x10uLL);
    uint32x4_t v96 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)vbslq_s8((int8x16_t)vzip2q_s16(v85, v85), (int8x16_t)vqaddq_u32(v89, v89), (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)vdup_laneq_s16(v74, 7), (uint16x4_t)v79, 3), vqaddq_u32(v93, v93))), vmull_u16(v88, (uint16x4_t)vmvn_s8((int8x8_t)v72.u64[1]))), vmull_u16(v87, (uint16x4_t)*(_OWORD *)&vextq_s8(v94, v94, 8uLL))), v30), a14);
    uint32x4_t v97 = vsraq_n_u32(v96, v96, 0x10uLL);
    *(int16x4_t *)v94.i8 = vdup_lane_s16(*(int16x4_t *)v95.i8, 3);
    v94.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v97, 0x10uLL), 3);
    int8x16_t v98 = (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v95.i8, v97, 0x10uLL), (uint16x8_t)v94);
    int16x8_t v17 = vceqzq_s16(v82);
    int8x16_t v16 = (int8x16_t)vceqzq_s16(v72);
    *(int8x16_t *)&v21->i8[v71] = vbslq_s8(v16, (int8x16_t)v74, vbslq_s8((int8x16_t)v17, v81, v98));
    v22 += v28;
    v18 -= 2;
    if (v18 < 2) {
      break;
    }
    __int32 v32 = *(unsigned __int16 *)v22;
    v71 += v29;
    if ((unsigned __int16)(v32 - 1) >= 0xFFFEu)
    {
      uint64_t v19 = (int8x8_t *)((char *)v19 + v71);
      unsigned int v21 = (int8x8_t *)((char *)v21 + v71);
      goto LABEL_37;
    }
  }
  uint64_t v19 = (int8x8_t *)((char *)v19 + v29 + v71);
  unsigned int v21 = (int8x8_t *)((char *)v21 + v29 + v71);
LABEL_40:
  uint64_t v99 = v18 + a15;
  if (v99)
  {
    if (a7) {
      __int16 v100 = 0;
    }
    else {
      __int16 v100 = -1;
    }
    int8x8_t v101 = 0;
    v101.i16[3] = v100;
    if (a8) {
      __int16 v102 = 0;
    }
    else {
      __int16 v102 = -1;
    }
    int8x8_t v103 = 0;
    v103.i16[3] = v102;
    uint32x4_t v104 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v105.i64[0] = 0x800000008000;
    v105.i64[1] = 0x800000008000;
    do
    {
      if (*v22)
      {
        a14.i32[0] = *v22;
        int16x4_t v106 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a14.i8, 0);
        int16x4_t v107 = (int16x4_t)vorr_s8(*v21, vbic_s8(v103, (int8x8_t)vceqz_s16(v106)));
        a14 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v19, v101), (uint16x4_t)v106), v104), v105);
        *(uint16x4_t *)a14.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a14, (uint32x4_t)a14, 0x10uLL), 0x10uLL);
        int16x4_t v108 = vdup_lane_s16(*(int16x4_t *)a14.i8, 3);
        int16x4_t v109 = vdup_lane_s16(v107, 3);
        uint16x4_t v110 = vmin_u16(*(uint16x4_t *)a14.i8, (uint16x4_t)v108);
        uint16x4_t v111 = vmin_u16((uint16x4_t)v107, (uint16x4_t)v109);
        *(uint16x4_t *)v17.i8 = vcge_u16(vrhadd_u16((uint16x4_t)v108, 0), v110);
        uint32x4_t v112 = vmull_u16(v110, v111);
        uint32x4_t v113 = vmull_u16(vqsub_u16((uint16x4_t)v109, v111), vqsub_u16((uint16x4_t)v108, v110));
        int16x8_t v17 = (int16x8_t)vbslq_s8((int8x16_t)vzip1q_s16(v17, v17), (int8x16_t)vqaddq_u32(v112, v112), (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)v109, *(uint16x4_t *)a14.i8, 3), vqaddq_u32(v113, v113)));
        uint32x4_t v114 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)v17, vmull_u16(v111, (uint16x4_t)vmvn_s8((int8x8_t)v108))), vmull_u16(v110, (uint16x4_t)vmvn_s8((int8x8_t)v109))), v104), v105);
        *(uint16x4_t *)v114.i8 = vqshrn_n_u32(vsraq_n_u32(v114, v114, 0x10uLL), 0x10uLL);
        *(int8x8_t *)a14.i8 = vbsl_s8((int8x8_t)vceqz_s16(v108), (int8x8_t)v107, vbsl_s8((int8x8_t)vceqz_s16(v109), *(int8x8_t *)a14.i8, (int8x8_t)vmin_u16(*(uint16x4_t *)v114.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v114.i8, 3))));
        int8x8_t *v21 = *(int8x8_t *)a14.i8;
      }
      unsigned __int16 v115 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v115 >= v20) {
        uint64_t v116 = -(uint64_t)a5;
      }
      else {
        uint64_t v116 = 0;
      }
      uint64_t v19 = &v115[v116];
      v21 += a6;
      --v99;
    }
    while (v99);
  }
  *size_t result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)20,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  int16x8_t v17 = *result;
  unint64_t v18 = *a3;
  uint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0x800000008000;
  a13.i64[1] = 0x800000008000;
  v29.i64[0] = -1;
  v29.i64[1] = -1;
  while (1)
  {
    __int32 v30 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      uint32x4_t v63 = (int8x16_t *)&v20[v16];
      uint32x4_t v64 = (int8x16_t *)v20;
      do
        uint16x8_t v65 = v64++;
      while (v64 <= v63 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v65)) & 0x80) != 0);
      do
      {
        int16x8_t v66 = v65;
        uint16x8_t v65 = (int8x16_t *)((char *)v65 + 4);
      }
      while (v65 <= v63 && !v66->i32[0]);
      if (v66 < v63)
      {
        while (!v66->i8[0])
        {
          int16x8_t v66 = (int8x16_t *)((char *)v66 + 1);
          if (v66 >= v63)
          {
            int16x8_t v66 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v67 = (char *)v66 - v20;
      int64_t v68 = ((char *)v66 - v20) * a6;
      v17 += v68;
      v19 += v68;
      v20 += v68;
      v16 -= v67;
      goto LABEL_37;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    int8x16_t v31 = (int8x16_t *)&v20[v16];
    __int32 v32 = (int8x16_t *)v20;
    do
      uint64_t v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v29)) & 0x80) != 0);
    do
    {
      uint64_t v34 = v33;
      uint64_t v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint64_t v34 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v20;
    unint64_t v37 = (char *)v34 - v20;
    do
    {
      int8x16_t v38 = vorrq_s8(*(int8x16_t *)&v17->i8[v35], v23);
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      int16x8_t v40 = (int16x8_t)vqtbl1q_s8(v38, (int8x16_t)xmmword_1850CD880);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v42 = vminq_u16((uint16x8_t)v38, (uint16x8_t)v40);
      uint16x8_t v43 = vminq_u16((uint16x8_t)v39, (uint16x8_t)v41);
      int16x4_t v44 = vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v43.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v41.i8)))));
      int32x4_t v45 = vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_high_u16(v43, v43)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v41, (int8x16_t)v41, 8uLL)))));
      uint32x4_t v46 = vmull_lane_u16((uint16x4_t)v44, *(uint16x4_t *)v38.i8, 3);
      uint16x8_t v47 = vqsubq_u16(v43, (uint16x8_t)vqmovun_high_s32(v44, v45));
      uint32x4_t v48 = vmull_u16(*(uint16x4_t *)v47.i8, *(uint16x4_t *)v42.i8);
      uint32x4_t v49 = vmull_high_u16(v47, v42);
      uint32x4_t v50 = vqaddq_u32(v46, vqaddq_u32(v48, v48));
      uint32x4_t v51 = vqaddq_u32(vmull_laneq_u16((uint16x4_t)vqmovun_s32(v45), (uint16x8_t)v38, 7), vqaddq_u32(v49, v49));
      uint16x8_t v52 = (uint16x8_t)vmvnq_s8((int8x16_t)v40);
      uint32x4_t v53 = vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v52.i8);
      uint32x4_t v54 = vmull_high_u16(v43, v52);
      uint32x4_t v55 = vqaddq_u32(v50, v53);
      uint32x4_t v56 = vqaddq_u32(v51, v54);
      uint16x8_t v57 = (uint16x8_t)vmvnq_s8((int8x16_t)v41);
      uint32x4_t v58 = vmull_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v57.i8);
      uint32x4_t v59 = vqaddq_u32(v56, vmull_high_u16(v42, v57));
      uint32x4_t v60 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v55, v58), v28), a13);
      *(uint16x4_t *)v60.i8 = vqshrn_n_u32(vsraq_n_u32(v60, v60, 0x10uLL), 0x10uLL);
      uint32x4_t v61 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v59, v28), a13);
      uint32x4_t v62 = vsraq_n_u32(v61, v61, 0x10uLL);
      *(int16x4_t *)v57.i8 = vdup_lane_s16(*(int16x4_t *)v60.i8, 3);
      v57.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v62, 0x10uLL), 3);
      int8x16_t v15 = vbslq_s8((int8x16_t)vceqzq_s16(v41), v38, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v60.i8, v62, 0x10uLL), v57));
      *(int8x16_t *)&v19->i8[v35] = vbslq_s8((int8x16_t)vceqzq_s16(v40), v39, v15);
      v20 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    uint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    int16x8_t v17 = (int8x8_t *)((char *)v17 + v35);
    unint64_t v16 = v16 - v36 + v37;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v69 = 0;
  while (1)
  {
    v15.i32[0] = v30;
    int16x8_t v70 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    int16x8_t v71 = (int16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v69], v23);
    int8x16_t v72 = vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v70)), *(int8x16_t *)&v19->i8[v69]);
    uint32x4_t v73 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v71.i8, *(uint16x4_t *)v70.i8), v28), a13);
    int16x4_t v74 = (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v73, v73, 0x10uLL), 0x10uLL);
    uint32x4_t v75 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16((uint16x8_t)v71, (uint16x8_t)v70), v28), a13);
    uint32x4_t v76 = vsraq_n_u32(v75, v75, 0x10uLL);
    *(int16x4_t *)v71.i8 = vdup_lane_s16(v74, 3);
    int16x4_t v77 = (int16x4_t)vqshrn_n_u32(v76, 0x10uLL);
    int16x8_t v78 = (int16x8_t)vqtbl1q_s8(v72, (int8x16_t)xmmword_1850CD880);
    int8x16_t v79 = (int8x16_t)vminq_u16((uint16x8_t)v72, (uint16x8_t)v78);
    int16x4_t v80 = vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_u16(*(uint16x4_t *)v79.i8, *(uint16x4_t *)v79.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v78.i8)))));
    uint16x8_t v81 = (uint16x8_t)vmull_lane_u16((uint16x4_t)v80, (uint16x4_t)v74, 3);
    uint16x4_t v82 = vmin_u16((uint16x4_t)v74, *(uint16x4_t *)v71.i8);
    int8x16_t v83 = (int8x16_t)vqshrn_high_n_u32((uint16x4_t)v74, v76, 0x10uLL);
    v71.u64[1] = (unint64_t)vdup_lane_s16(v77, 3);
    int32x4_t v84 = vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_high_u16((uint16x8_t)v79, (uint16x8_t)v79)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v78, (int8x16_t)v78, 8uLL)))));
    int8x16_t v85 = (int8x16_t)vqsubq_u16((uint16x8_t)v79, (uint16x8_t)vqmovun_high_s32(v80, v84));
    uint32x4_t v86 = vmull_u16(*(uint16x4_t *)v85.i8, v82);
    uint16x4_t v87 = vmin_u16((uint16x4_t)v77, (uint16x4_t)v71.u64[1]);
    uint32x4_t v88 = vmull_u16((uint16x4_t)*(_OWORD *)&vextq_s8(v85, v85, 8uLL), v87);
    uint32x4_t v89 = vqaddq_u32(vqaddq_u32(vmull_lane_u16((uint16x4_t)vqmovun_s32(v84), (uint16x4_t)v77, 3), vqaddq_u32(v88, v88)), vmull_u16((uint16x4_t)*(_OWORD *)&vextq_s8(v79, v79, 8uLL), (uint16x4_t)vmvn_s8((int8x8_t)v71.u64[1])));
    int8x16_t v90 = vmvnq_s8((int8x16_t)v78);
    uint32x4_t v91 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)v81, vqaddq_u32(v86, v86)), vmull_u16(*(uint16x4_t *)v79.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v71.i8))), vmull_u16(v82, *(uint16x4_t *)v90.i8)), v28), a13);
    *(uint16x4_t *)v91.i8 = vqshrn_n_u32(vsraq_n_u32(v91, v91, 0x10uLL), 0x10uLL);
    uint32x4_t v92 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v89, vmull_u16(v87, (uint16x4_t)*(_OWORD *)&vextq_s8(v90, v90, 8uLL))), v28), a13);
    uint32x4_t v93 = vsraq_n_u32(v92, v92, 0x10uLL);
    *(int16x4_t *)v81.i8 = vdup_lane_s16(*(int16x4_t *)v91.i8, 3);
    v81.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v93, 0x10uLL), 3);
    int8x16_t v94 = vbslq_s8((int8x16_t)vceqzq_s16(v78), v83, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v91.i8, v93, 0x10uLL), v81));
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v71);
    *(int8x16_t *)&v19->i8[v69] = vbslq_s8(v15, v72, v94);
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v30 = *(unsigned __int16 *)v20;
    v69 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      int16x8_t v17 = (int8x8_t *)((char *)v17 + v69);
      uint64_t v19 = (int8x8_t *)((char *)v19 + v69);
      goto LABEL_37;
    }
  }
  int16x8_t v17 = (int8x8_t *)((char *)v17 + v27 + v69);
  uint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v69);
LABEL_40:
  uint64_t v95 = v16 + a14;
  if (v95)
  {
    if (a7) {
      __int16 v96 = 0;
    }
    else {
      __int16 v96 = -1;
    }
    int8x8_t v97 = 0;
    v97.i16[3] = v96;
    int8x8_t v98 = 0;
    if (a8) {
      __int16 v99 = 0;
    }
    else {
      __int16 v99 = -1;
    }
    v98.i16[3] = v99;
    uint32x4_t v100 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v101.i64[0] = 0x800000008000;
    v101.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v102 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int16x4_t v103 = (int16x4_t)vorr_s8(*v19, vbic_s8(v98, (int8x8_t)vceqz_s16(v102)));
        a13 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v97), (uint16x4_t)v102), v100), v101);
        *(uint16x4_t *)a13.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a13, (uint32x4_t)a13, 0x10uLL), 0x10uLL);
        int16x4_t v104 = vdup_lane_s16(*(int16x4_t *)a13.i8, 3);
        int16x4_t v105 = vdup_lane_s16(v103, 3);
        uint16x4_t v106 = vmin_u16(*(uint16x4_t *)a13.i8, (uint16x4_t)v104);
        uint16x4_t v107 = vmin_u16((uint16x4_t)v103, (uint16x4_t)v105);
        uint16x4_t v108 = (uint16x4_t)vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_u16(v107, v107)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v105)))));
        uint32x4_t v109 = vmull_lane_u16(v108, *(uint16x4_t *)a13.i8, 3);
        uint32x4_t v110 = vmull_u16(vqsub_u16(v107, v108), v106);
        uint32x4_t v111 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vqaddq_u32(v109, vqaddq_u32(v110, v110)), vmull_u16(v107, (uint16x4_t)vmvn_s8((int8x8_t)v104))), vmull_u16(v106, (uint16x4_t)vmvn_s8((int8x8_t)v105))), v100), v101);
        *(uint16x4_t *)v111.i8 = vqshrn_n_u32(vsraq_n_u32(v111, v111, 0x10uLL), 0x10uLL);
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vceqz_s16(v104), (int8x8_t)v103, vbsl_s8((int8x8_t)vceqz_s16(v105), *(int8x8_t *)a13.i8, (int8x8_t)vmin_u16(*(uint16x4_t *)v111.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v111.i8, 3))));
        *uint64_t v19 = *(int8x8_t *)a13.i8;
      }
      uint32x4_t v112 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v112 >= v18) {
        uint64_t v113 = -(uint64_t)a5;
      }
      else {
        uint64_t v113 = 0;
      }
      int16x8_t v17 = &v112[v113];
      v19 += a6;
      --v95;
    }
    while (v95);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)19,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, int8x8_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v17 = a16;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a16 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v22 = 0;
  }
  else {
    unsigned int v22 = -1;
  }
  v23.i64[0] = 0xFFFF000000000000;
  v23.i64[1] = 0xFFFF000000000000;
  int8x16_t v24 = vandq_s8((int8x16_t)vdupq_n_s16(v22), v23);
  if (a8) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = vandq_s8((int8x16_t)vdupq_n_s16(v25), v23);
  uint64_t v27 = 2 * a6;
  uint64_t v28 = 16 * a6;
  float32x4_t v29 = (float32x4_t)vdupq_n_s32(0x37800080u);
  v30.i64[0] = -1;
  v30.i64[1] = -1;
  a14.i32[1] = 0;
  uint32x4_t v31 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v32.i64[0] = 0x800000008000;
  v32.i64[1] = 0x800000008000;
  while (1)
  {
    __int32 v33 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      uint32x4_t v61 = (int8x16_t *)&v21[v17];
      uint32x4_t v62 = (int8x16_t *)v21;
      do
        uint32x4_t v63 = v62++;
      while (v62 <= v61 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v63)) & 0x80) != 0);
      do
      {
        uint32x4_t v64 = v63;
        uint32x4_t v63 = (int8x16_t *)((char *)v63 + 4);
      }
      while (v63 <= v61 && !v64->i32[0]);
      if (v64 < v61)
      {
        while (!v64->i8[0])
        {
          uint32x4_t v64 = (int8x16_t *)((char *)v64 + 1);
          if (v64 >= v61)
          {
            uint32x4_t v64 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v65 = (char *)v64 - v21;
      int64_t v66 = ((char *)v64 - v21) * a6;
      v18 += v66;
      v20 += v66;
      v21 += v66;
      v17 -= v65;
      goto LABEL_37;
    }
    if (v33 != 0xFFFF) {
      break;
    }
    uint64_t v34 = (int8x16_t *)&v21[v17];
    uint64_t v35 = (int8x16_t *)v21;
    do
      int64_t v36 = v35++;
    while (v35 <= v34 && (vminvq_u8((uint8x16_t)vceqq_s8(*v36, v30)) & 0x80) != 0);
    do
    {
      unint64_t v37 = v36;
      int64_t v36 = (int8x16_t *)((char *)v36 + 4);
    }
    while (v36 <= v34 && v37->i32[0] == -1);
    if (v37 < v34)
    {
      while (v37->u8[0] == 255)
      {
        unint64_t v37 = (int8x16_t *)((char *)v37 + 1);
        if (v37 >= v34)
        {
          unint64_t v37 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v38 = 0;
    int64_t v39 = (char *)v37 - v21;
    unint64_t v40 = (char *)v37 - v21;
    do
    {
      int16x8_t v41 = (int16x8_t)vorrq_s8(*(int8x16_t *)&v18->i8[v38], v24);
      int8x16_t v42 = vorrq_s8(*(int8x16_t *)&v20->i8[v38], v26);
      int16x8_t v43 = (int16x8_t)vqtbl1q_s8((int8x16_t)v41, (int8x16_t)xmmword_1850CD880);
      int16x8_t v44 = (int16x8_t)vqtbl1q_s8(v42, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v45 = vminq_u16((uint16x8_t)v41, (uint16x8_t)v43);
      uint16x8_t v46 = vminq_u16((uint16x8_t)v42, (uint16x8_t)v44);
      uint16x8_t v47 = vqsubq_u16((uint16x8_t)v44, v46);
      float32x4_t v48 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v47.i8));
      float32x4_t v49 = vcvtq_f32_u32(vmovl_high_u16(v47));
      uint16x4_t v50 = (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v41.i8, 3);
      uint16x4_t v51 = (uint16x4_t)vdup_laneq_s16(v41, 7);
      float32x4_t v52 = vcvtq_f32_u32(vmovl_high_u16(v45));
      float32x4_t v53 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v45.i8));
      uint16x8_t v54 = (uint16x8_t)vmvnq_s8((int8x16_t)v43);
      uint32x4_t v55 = vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v54.i8);
      uint32x4_t v56 = vmull_high_u16(v46, v54);
      uint16x8_t v57 = (uint16x8_t)vmvnq_s8((int8x16_t)v44);
      uint32x4_t v58 = vmull_u16(*(uint16x4_t *)v45.i8, *(uint16x4_t *)v57.i8);
      float32x4_t v59 = vaddq_f32(vcvtq_f32_u32(v56), vcvtq_f32_u32(vmull_high_u16(v45, v57)));
      *(int16x4_t *)v56.i8 = vqmovun_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(v55), vcvtq_f32_u32(v58)), vcvtq_f32_u32(vmull_lane_u16(v50, *(uint16x4_t *)v42.i8, 3))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v48, vcvtq_f32_u32(vmull_lane_u16(v50, *(uint16x4_t *)v41.i8, 3))), v53), (int8x16_t)vceqzq_f32(v48))), v29)));
      int32x4_t v60 = vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(v59, vcvtq_f32_u32(vmull_laneq_u16(v51, (uint16x8_t)v42, 7))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v49, vcvtq_f32_u32(vmull_laneq_u16(v51, (uint16x8_t)v41, 7))), v52), (int8x16_t)vceqzq_f32(v49))), v29));
      *(int16x4_t *)v49.f32 = vdup_lane_s16(*(int16x4_t *)v56.i8, 3);
      *(int16x4_t *)&v49.u32[2] = vdup_lane_s16(vqmovun_s32(v60), 3);
      int8x16_t v16 = (int8x16_t)vminq_u16((uint16x8_t)vqmovun_high_s32(*(int16x4_t *)v56.i8, v60), (uint16x8_t)v49);
      *(int8x16_t *)&v20->i8[v38] = vbslq_s8((int8x16_t)vceqzq_s16(v43), v42, vbslq_s8((int8x16_t)vceqzq_s16(v44), (int8x16_t)v41, v16));
      v21 += v27;
      v40 -= 2;
      v38 += v28;
    }
    while (v40 > 1);
    unint64_t v20 = (int8x8_t *)((char *)v20 + v38);
    unint64_t v18 = (int8x8_t *)((char *)v18 + v38);
    unint64_t v17 = v17 - v39 + v40;
LABEL_37:
    if (v17 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v67 = 0;
  while (1)
  {
    v16.i32[0] = v33;
    int16x8_t v68 = (int16x8_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v69 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v18->i8[v67], v24);
    int8x16_t v70 = vorrq_s8(vbicq_s8(v26, (int8x16_t)vceqzq_s16(v68)), *(int8x16_t *)&v20->i8[v67]);
    int16x8_t v71 = (int16x8_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v69.i8, *(uint16x4_t *)v68.i8), v31), v32);
    int16x4_t v72 = (int16x4_t)vqshrn_n_u32(vsraq_n_u32((uint32x4_t)v71, (uint32x4_t)v71, 0x10uLL), 0x10uLL);
    uint32x4_t v73 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v69, (uint16x8_t)v68), v31), v32);
    uint32x4_t v74 = vsraq_n_u32(v73, v73, 0x10uLL);
    int16x4_t v75 = (int16x4_t)vqshrn_n_u32(v74, 0x10uLL);
    *(int16x4_t *)v71.i8 = vdup_lane_s16(v72, 3);
    uint32x4_t v76 = vmull_lane_u16(*(uint16x4_t *)v71.i8, (uint16x4_t)v72, 3);
    uint16x4_t v77 = vmin_u16((uint16x4_t)v72, *(uint16x4_t *)v71.i8);
    int8x16_t v78 = (int8x16_t)vqshrn_high_n_u32((uint16x4_t)v72, v74, 0x10uLL);
    v71.u64[1] = (unint64_t)vdup_lane_s16(v75, 3);
    int16x8_t v79 = (int16x8_t)vqtbl1q_s8(v70, (int8x16_t)xmmword_1850CD880);
    int8x16_t v80 = (int8x16_t)vminq_u16((uint16x8_t)v70, (uint16x8_t)v79);
    uint16x8_t v81 = vqsubq_u16((uint16x8_t)v79, (uint16x8_t)v80);
    float32x4_t v82 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v81.i8));
    float32x4_t v83 = vcvtq_f32_u32(vmovl_high_u16(v81));
    uint16x4_t v84 = vmin_u16((uint16x4_t)v75, (uint16x4_t)v71.u64[1]);
    uint32x4_t v85 = vmull_u16(*(uint16x4_t *)v80.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v71.i8));
    uint32x4_t v86 = vmull_u16((uint16x4_t)*(_OWORD *)&vextq_s8(v80, v80, 8uLL), (uint16x4_t)vmvn_s8((int8x8_t)v71.u64[1]));
    int8x16_t v87 = vmvnq_s8((int8x16_t)v79);
    *(int16x4_t *)v76.i8 = vqmovun_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(v85), vcvtq_f32_u32(vmull_u16(v77, *(uint16x4_t *)v87.i8))), vcvtq_f32_u32(vmull_lane_u16(*(uint16x4_t *)v71.i8, *(uint16x4_t *)v70.i8, 3))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v82, vcvtq_f32_u32(v76)), vcvtq_f32_u32(vmovl_u16(v77))), (int8x16_t)vceqzq_f32(v82))), v29)));
    int32x4_t v88 = vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(v86), vcvtq_f32_u32(vmull_u16(v84, (uint16x4_t)*(_OWORD *)&vextq_s8(v87, v87, 8uLL)))), vcvtq_f32_u32(vmull_laneq_u16((uint16x4_t)v71.u64[1], (uint16x8_t)v70, 7))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v83, vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v71.u64[1], (uint16x4_t)v75, 3))), vcvtq_f32_u32(vmovl_u16(v84))), (int8x16_t)vceqzq_f32(v83))), v29));
    *(int16x4_t *)v89.i8 = vdup_lane_s16(*(int16x4_t *)v76.i8, 3);
    v89.u64[1] = (unint64_t)vdup_lane_s16(vqmovun_s32(v88), 3);
    int8x16_t v90 = (int8x16_t)vminq_u16((uint16x8_t)vqmovun_high_s32(*(int16x4_t *)v76.i8, v88), v89);
    int8x16_t v16 = (int8x16_t)vceqzq_s16(v79);
    *(int8x16_t *)&v20->i8[v67] = vbslq_s8((int8x16_t)vceqzq_s16(v71), v70, vbslq_s8(v16, v78, v90));
    v21 += v27;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    __int32 v33 = *(unsigned __int16 *)v21;
    v67 += v28;
    if ((unsigned __int16)(v33 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (int8x8_t *)((char *)v18 + v67);
      unint64_t v20 = (int8x8_t *)((char *)v20 + v67);
      goto LABEL_37;
    }
  }
  unint64_t v18 = (int8x8_t *)((char *)v18 + v28 + v67);
  unint64_t v20 = (int8x8_t *)((char *)v20 + v28 + v67);
LABEL_40:
  uint64_t v91 = v17 + a15;
  if (v91)
  {
    if (a7) {
      __int16 v92 = 0;
    }
    else {
      __int16 v92 = -1;
    }
    int8x8_t v93 = 0;
    v93.i16[3] = v92;
    int8x8_t v94 = 0;
    if (a8) {
      __int16 v95 = 0;
    }
    else {
      __int16 v95 = -1;
    }
    v94.i16[3] = v95;
    uint32x4_t v96 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v97.i64[0] = 0x800000008000;
    v97.i64[1] = 0x800000008000;
    float32x4_t v98 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      if (*v21)
      {
        a14.i32[0] = *v21;
        int16x4_t v99 = (int16x4_t)vdup_lane_s8(a14, 0);
        int16x4_t v100 = (int16x4_t)vorr_s8(*v20, vbic_s8(v94, (int8x8_t)vceqz_s16(v99)));
        uint32x4_t v101 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v18, v93), (uint16x4_t)v99), v96), v97);
        *(uint16x4_t *)v101.i8 = vqshrn_n_u32(vsraq_n_u32(v101, v101, 0x10uLL), 0x10uLL);
        int16x4_t v102 = vdup_lane_s16(*(int16x4_t *)v101.i8, 3);
        int16x4_t v103 = vdup_lane_s16(v100, 3);
        uint16x4_t v104 = vmin_u16(*(uint16x4_t *)v101.i8, (uint16x4_t)v102);
        uint16x4_t v105 = vmin_u16((uint16x4_t)v100, (uint16x4_t)v103);
        float32x4_t v106 = vcvtq_f32_u32(vmovl_u16(vqsub_u16((uint16x4_t)v103, v105)));
        int16x4_t v107 = vqmovun_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmull_u16(v105, (uint16x4_t)vmvn_s8((int8x8_t)v102))), vcvtq_f32_u32(vmull_u16(v104, (uint16x4_t)vmvn_s8((int8x8_t)v103)))), vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v102, (uint16x4_t)v100, 3))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v106, vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v102, *(uint16x4_t *)v101.i8, 3))), vcvtq_f32_u32(vmovl_u16(v104))), (int8x16_t)vceqzq_f32(v106))), v98)));
        a14 = vbsl_s8((int8x8_t)vceqz_s16(v102), (int8x8_t)v100, vbsl_s8((int8x8_t)vceqz_s16(v103), *(int8x8_t *)v101.i8, (int8x8_t)vmin_u16((uint16x4_t)v107, (uint16x4_t)vdup_lane_s16(v107, 3))));
        int8x8_t *v20 = a14;
      }
      uint16x4_t v108 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v108 >= v19) {
        uint64_t v109 = -(uint64_t)a5;
      }
      else {
        uint64_t v109 = 0;
      }
      unint64_t v18 = &v108[v109];
      v20 += a6;
      --v91;
    }
    while (v91);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)18,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0xFFFFFFFFFFFFLL;
  a13.i64[1] = 0xFFFFFFFFFFFFLL;
  v29.i64[0] = 0x800000008000;
  v29.i64[1] = 0x800000008000;
  v30.i64[0] = -1;
  v30.i64[1] = -1;
  while (1)
  {
    __int32 v31 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      uint32x4_t v58 = (int8x16_t *)&v20[v16];
      float32x4_t v59 = (int8x16_t *)v20;
      do
        int32x4_t v60 = v59++;
      while (v59 <= v58 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v60)) & 0x80) != 0);
      do
      {
        uint32x4_t v61 = v60;
        int32x4_t v60 = (int8x16_t *)((char *)v60 + 4);
      }
      while (v60 <= v58 && !v61->i32[0]);
      if (v61 < v58)
      {
        while (!v61->i8[0])
        {
          uint32x4_t v61 = (int8x16_t *)((char *)v61 + 1);
          if (v61 >= v58)
          {
            uint32x4_t v61 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v62 = (char *)v61 - v20;
      int64_t v63 = ((char *)v61 - v20) * a6;
      v17 += v63;
      v19 += v63;
      v20 += v63;
      v16 -= v62;
      goto LABEL_37;
    }
    if (v31 != 0xFFFF) {
      break;
    }
    int32x4_t v32 = (int8x16_t *)&v20[v16];
    __int32 v33 = (int8x16_t *)v20;
    do
      uint64_t v34 = v33++;
    while (v33 <= v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, v30)) & 0x80) != 0);
    do
    {
      uint64_t v35 = v34;
      uint64_t v34 = (int8x16_t *)((char *)v34 + 4);
    }
    while (v34 <= v32 && v35->i32[0] == -1);
    if (v35 < v32)
    {
      while (v35->u8[0] == 255)
      {
        uint64_t v35 = (int8x16_t *)((char *)v35 + 1);
        if (v35 >= v32)
        {
          uint64_t v35 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v36 = 0;
    int64_t v37 = (char *)v35 - v20;
    unint64_t v38 = (char *)v35 - v20;
    do
    {
      int16x8_t v39 = (int16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v36], v23);
      int8x16_t v40 = vorrq_s8(*(int8x16_t *)&v19->i8[v36], v25);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8((int8x16_t)v39, (int8x16_t)xmmword_1850CD880);
      int16x8_t v42 = (int16x8_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_1850CD880);
      int8x16_t v43 = (int8x16_t)vminq_u16((uint16x8_t)v39, (uint16x8_t)v41);
      int16x8_t v44 = (int16x8_t)vminq_u16((uint16x8_t)v40, (uint16x8_t)v42);
      uint16x8_t v45 = (uint16x8_t)vandq_s8(v43, (int8x16_t)a13);
      int16x8_t v46 = (int16x8_t)vbicq_s8((int8x16_t)vtstq_s16(v44, v44), (int8x16_t)vcgtq_u16((uint16x8_t)v41, v45));
      int8x16_t v47 = (int8x16_t)vmovl_high_s16(v46);
      uint16x8_t v48 = (uint16x8_t)vorrq_s8((int8x16_t)vqsubq_u16((uint16x8_t)v41, v45), (int8x16_t)vceqzq_s16(v44));
      uint16x8_t v49 = (uint16x8_t)vmvnq_s8((int8x16_t)v41);
      uint32x4_t v50 = vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v44.i8)), vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v39.i8, 3), *(uint16x4_t *)v39.i8, 3))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v48.i8)))), (int8x16_t)vmovl_s16(*(int16x4_t *)v46.i8)), vmull_u16(*(uint16x4_t *)v44.i8, *(uint16x4_t *)v49.i8));
      uint32x4_t v51 = vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_high_u16((uint16x8_t)v44)), vcvtq_f32_u32(vmull_laneq_u16((uint16x4_t)vdup_laneq_s16(v39, 7), (uint16x8_t)v39, 7))), vcvtq_f32_u32(vmovl_high_u16(v48)))), v47), vmull_high_u16((uint16x8_t)v44, v49));
      uint16x8_t v52 = (uint16x8_t)vmvnq_s8((int8x16_t)v42);
      uint32x4_t v53 = vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v52.i8);
      uint32x4_t v54 = vqaddq_u32(v51, vmull_high_u16((uint16x8_t)v43, v52));
      uint32x4_t v55 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v50, v53), v28), v29);
      *(uint16x4_t *)v55.i8 = vqshrn_n_u32(vsraq_n_u32(v55, v55, 0x10uLL), 0x10uLL);
      uint32x4_t v56 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v54, v28), v29);
      uint32x4_t v57 = vsraq_n_u32(v56, v56, 0x10uLL);
      *(int16x4_t *)v52.i8 = vdup_lane_s16(*(int16x4_t *)v55.i8, 3);
      v52.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v57, 0x10uLL), 3);
      int8x16_t v15 = vbslq_s8((int8x16_t)vceqzq_s16(v42), (int8x16_t)v39, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v55.i8, v57, 0x10uLL), v52));
      *(int8x16_t *)&v19->i8[v36] = vbslq_s8((int8x16_t)vceqzq_s16(v41), v40, v15);
      v20 += v26;
      v38 -= 2;
      v36 += v27;
    }
    while (v38 > 1);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v36);
    unint64_t v17 = (int8x8_t *)((char *)v17 + v36);
    unint64_t v16 = v16 - v37 + v38;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v64 = 0;
  while (1)
  {
    v15.i32[0] = v31;
    int16x8_t v65 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v66 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v64], v23);
    int8x16_t v67 = vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v65)), *(int8x16_t *)&v19->i8[v64]);
    uint32x4_t v68 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v66.i8, *(uint16x4_t *)v65.i8), v28), v29);
    int16x4_t v69 = (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v68, v68, 0x10uLL), 0x10uLL);
    uint32x4_t v70 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v66, (uint16x8_t)v65), v28), v29);
    uint32x4_t v71 = vsraq_n_u32(v70, v70, 0x10uLL);
    int16x4_t v72 = (int16x4_t)vqshrn_n_u32(v71, 0x10uLL);
    *(int16x4_t *)v65.i8 = vdup_lane_s16(v69, 3);
    uint32x4_t v73 = vmull_lane_u16(*(uint16x4_t *)v65.i8, (uint16x4_t)v69, 3);
    uint16x4_t v74 = vmin_u16((uint16x4_t)v69, *(uint16x4_t *)v65.i8);
    int8x16_t v75 = (int8x16_t)vqshrn_high_n_u32((uint16x4_t)v69, v71, 0x10uLL);
    v65.u64[1] = (unint64_t)vdup_lane_s16(v72, 3);
    int16x8_t v76 = (int16x8_t)vqtbl1q_s8(v67, (int8x16_t)xmmword_1850CD880);
    int16x8_t v77 = (int16x8_t)vminq_u16((uint16x8_t)v67, (uint16x8_t)v76);
    uint16x8_t v78 = (uint16x8_t)vandq_s8((int8x16_t)vminq_u16((uint16x8_t)v75, (uint16x8_t)v65), (int8x16_t)a13);
    int16x8_t v79 = (int16x8_t)vbicq_s8((int8x16_t)vtstq_s16(v77, v77), (int8x16_t)vcgtq_u16((uint16x8_t)v65, v78));
    uint16x8_t v80 = (uint16x8_t)vorrq_s8((int8x16_t)vqsubq_u16((uint16x8_t)v65, v78), (int8x16_t)vceqzq_s16(v77));
    uint32x4_t v81 = vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v77.i8)), vcvtq_f32_u32(v73)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v80.i8)))), (int8x16_t)vmovl_s16(*(int16x4_t *)v79.i8)), vmull_u16(*(uint16x4_t *)v77.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v65.i8)));
    uint16x8_t v82 = (uint16x8_t)vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_high_u16((uint16x8_t)v77)), vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v65.u64[1], (uint16x4_t)v72, 3))), vcvtq_f32_u32(vmovl_high_u16(v80)))), (int8x16_t)vmovl_high_s16(v79)), vmull_u16((uint16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v77, (int8x16_t)v77, 8uLL), (uint16x4_t)vmvn_s8((int8x8_t)v65.u64[1])));
    int8x16_t v83 = vmvnq_s8((int8x16_t)v76);
    uint32x4_t v84 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v81, vmull_u16(v74, *(uint16x4_t *)v83.i8)), v28), v29);
    *(uint16x4_t *)v84.i8 = vqshrn_n_u32(vsraq_n_u32(v84, v84, 0x10uLL), 0x10uLL);
    uint32x4_t v85 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32((uint32x4_t)v82, vmull_u16(vmin_u16((uint16x4_t)v72, (uint16x4_t)v65.u64[1]), (uint16x4_t)*(_OWORD *)&vextq_s8(v83, v83, 8uLL))), v28), v29);
    uint32x4_t v86 = vsraq_n_u32(v85, v85, 0x10uLL);
    *(int16x4_t *)v82.i8 = vdup_lane_s16(*(int16x4_t *)v84.i8, 3);
    v82.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v86, 0x10uLL), 3);
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v65);
    *(int8x16_t *)&v19->i8[v64] = vbslq_s8(v15, v67, vbslq_s8((int8x16_t)vceqzq_s16(v76), v75, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v84.i8, v86, 0x10uLL), v82)));
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v31 = *(unsigned __int16 *)v20;
    v64 += v27;
    if ((unsigned __int16)(v31 - 1) >= 0xFFFEu)
    {
      unint64_t v17 = (int8x8_t *)((char *)v17 + v64);
      unint64_t v19 = (int8x8_t *)((char *)v19 + v64);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v64);
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v64);
LABEL_40:
  uint64_t v87 = v16 + a14;
  if (v87)
  {
    if (a7) {
      __int16 v88 = 0;
    }
    else {
      __int16 v88 = -1;
    }
    int8x8_t v89 = 0;
    v89.i16[3] = v88;
    int8x8_t v90 = 0;
    if (a8) {
      __int16 v91 = 0;
    }
    else {
      __int16 v91 = -1;
    }
    v90.i16[3] = v91;
    uint32x4_t v92 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v93.i64[0] = 0x800000008000;
    v93.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v94 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int16x4_t v95 = (int16x4_t)vorr_s8(*v19, vbic_s8(v90, (int8x8_t)vceqz_s16(v94)));
        a13 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v89), (uint16x4_t)v94), v92), v93);
        *(uint16x4_t *)a13.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a13, (uint32x4_t)a13, 0x10uLL), 0x10uLL);
        int16x4_t v96 = vdup_lane_s16(*(int16x4_t *)a13.i8, 3);
        int16x4_t v97 = vdup_lane_s16(v95, 3);
        uint16x4_t v98 = vmin_u16(*(uint16x4_t *)a13.i8, (uint16x4_t)v96);
        int16x4_t v99 = (int16x4_t)vmin_u16((uint16x4_t)v95, (uint16x4_t)v97);
        uint32x4_t v100 = vmull_u16(v98, (uint16x4_t)vmvn_s8((int8x8_t)v97));
        v98.i16[3] = 0;
        uint32x4_t v101 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v99)), vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v96, *(uint16x4_t *)a13.i8, 3))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)vorr_s8((int8x8_t)vqsub_u16((uint16x4_t)v96, v98), (int8x8_t)vceqz_s16(v99)))))), (int8x16_t)vmovl_s16((int16x4_t)vbic_s8((int8x8_t)vtst_s16(v99, v99), (int8x8_t)vcgt_u16((uint16x4_t)v96, v98)))), vmull_u16((uint16x4_t)v99, (uint16x4_t)vmvn_s8((int8x8_t)v96))), v100),
                                          v92),
                             v93);
        *(uint16x4_t *)v101.i8 = vqshrn_n_u32(vsraq_n_u32(v101, v101, 0x10uLL), 0x10uLL);
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vceqz_s16(v96), (int8x8_t)v95, vbsl_s8((int8x8_t)vceqz_s16(v97), *(int8x8_t *)a13.i8, (int8x8_t)vmin_u16(*(uint16x4_t *)v101.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v101.i8, 3))));
        *unint64_t v19 = *(int8x8_t *)a13.i8;
      }
      int16x4_t v102 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v102 >= v18) {
        uint64_t v103 = -(uint64_t)a5;
      }
      else {
        uint64_t v103 = 0;
      }
      unint64_t v17 = &v102[v103];
      v19 += a6;
      --v87;
    }
    while (v87);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)17,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0x800000008000;
  a13.i64[1] = 0x800000008000;
  v29.i64[0] = -1;
  v29.i64[1] = -1;
  while (1)
  {
    __int32 v30 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      uint32x4_t v51 = (int8x16_t *)&v20[v16];
      uint16x8_t v52 = (int8x16_t *)v20;
      do
        uint32x4_t v53 = v52++;
      while (v52 <= v51 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v53)) & 0x80) != 0);
      do
      {
        uint32x4_t v54 = v53;
        uint32x4_t v53 = (int8x16_t *)((char *)v53 + 4);
      }
      while (v53 <= v51 && !v54->i32[0]);
      if (v54 < v51)
      {
        while (!v54->i8[0])
        {
          uint32x4_t v54 = (int8x16_t *)((char *)v54 + 1);
          if (v54 >= v51)
          {
            uint32x4_t v54 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v55 = (char *)v54 - v20;
      int64_t v56 = ((char *)v54 - v20) * a6;
      v17 += v56;
      v19 += v56;
      v20 += v56;
      v16 -= v55;
      goto LABEL_37;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    __int32 v31 = (int8x16_t *)&v20[v16];
    int32x4_t v32 = (int8x16_t *)v20;
    do
      __int32 v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v29)) & 0x80) != 0);
    do
    {
      uint64_t v34 = v33;
      __int32 v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint64_t v34 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v20;
    unint64_t v37 = (char *)v34 - v20;
    do
    {
      int8x16_t v38 = vorrq_s8(*(int8x16_t *)&v17->i8[v35], v23);
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      int16x8_t v40 = (int16x8_t)vqtbl1q_s8(v38, (int8x16_t)xmmword_1850CD880);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v42 = vminq_u16((uint16x8_t)v38, (uint16x8_t)v40);
      uint16x8_t v43 = vminq_u16((uint16x8_t)v39, (uint16x8_t)v41);
      uint32x4_t v44 = vmull_lane_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v39.i8, 3);
      uint16x8_t v45 = (uint16x8_t)vmvnq_s8((int8x16_t)v41);
      uint32x4_t v46 = vmull_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v45.i8);
      uint16x8_t v47 = (uint16x8_t)vmvnq_s8((int8x16_t)v40);
      uint32x4_t v48 = vqaddq_u32(vqaddq_u32(vmaxq_u32(vmull_high_laneq_u16(v42, (uint16x8_t)v39, 7), vmull_high_laneq_u16(v43, (uint16x8_t)v38, 7)), vmull_high_u16(v42, v45)), vmull_high_u16(v43, v47));
      uint32x4_t v49 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vmaxq_u32(v44, vmull_lane_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v38.i8, 3)), v46), vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v47.i8)), v28), a13);
      uint32x4_t v50 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v48, v28), a13);
      int8x16_t v15 = vbslq_s8((int8x16_t)vceqzq_s16(v41), v38, (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v49, v49, 0x10uLL), 0x10uLL), vsraq_n_u32(v50, v50, 0x10uLL), 0x10uLL));
      *(int8x16_t *)&v19->i8[v35] = vbslq_s8((int8x16_t)vceqzq_s16(v40), v39, v15);
      v20 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    unint64_t v17 = (int8x8_t *)((char *)v17 + v35);
    unint64_t v16 = v16 - v36 + v37;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v57 = 0;
  while (1)
  {
    v15.i32[0] = v30;
    int16x8_t v58 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v59 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v57], v23);
    int16x8_t v60 = (int16x8_t)vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v58)), *(int8x16_t *)&v19->i8[v57]);
    uint32x4_t v61 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v59.i8, *(uint16x4_t *)v58.i8), v28), a13);
    int16x4_t v62 = (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v61, v61, 0x10uLL), 0x10uLL);
    uint32x4_t v63 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v59, (uint16x8_t)v58), v28), a13);
    uint32x4_t v64 = vsraq_n_u32(v63, v63, 0x10uLL);
    int16x4_t v65 = (int16x4_t)vqshrn_n_u32(v64, 0x10uLL);
    *(int16x4_t *)v58.i8 = vdup_lane_s16(v62, 3);
    int16x8_t v66 = (int16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
    int8x16_t v67 = (int8x16_t)vminq_u16((uint16x8_t)v60, (uint16x8_t)v66);
    uint16x4_t v68 = vmin_u16((uint16x4_t)v62, *(uint16x4_t *)v58.i8);
    uint32x4_t v69 = vmull_lane_u16(*(uint16x4_t *)v67.i8, (uint16x4_t)v62, 3);
    int8x16_t v70 = (int8x16_t)vqshrn_high_n_u32((uint16x4_t)v62, v64, 0x10uLL);
    v58.i64[1] = vdupq_lane_s16(v65, 3).u64[0];
    uint16x4_t v71 = vmin_u16((uint16x4_t)v65, (uint16x4_t)v58.u64[1]);
    int8x16_t v72 = (int8x16_t)vdupq_laneq_s16(v60, 7);
    uint16x4_t v73 = (uint16x4_t)vextq_s8(v67, v67, 8uLL).u64[0];
    int8x16_t v74 = vmvnq_s8((int8x16_t)v66);
    uint32x4_t v75 = vqaddq_u32(vmaxq_u32(vmull_lane_u16(v68, *(uint16x4_t *)v60.i8, 3), v69), vmull_u16(v68, *(uint16x4_t *)v74.i8));
    uint32x4_t v76 = vqaddq_u32(vmaxq_u32(vmull_u16(v71, (uint16x4_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL)), vmull_high_lane_u16((uint16x8_t)v67, (uint16x4_t)v65, 3)), vmull_u16(v71, (uint16x4_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL)));
    uint32x4_t v77 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v75, vmull_u16(*(uint16x4_t *)v67.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v58.i8))), v28), a13);
    uint32x4_t v78 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v76, vmull_u16(v73, (uint16x4_t)vmvn_s8((int8x8_t)v58.u64[1]))), v28), a13);
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v58);
    *(int8x16_t *)&v19->i8[v57] = vbslq_s8(v15, (int8x16_t)v60, vbslq_s8((int8x16_t)vceqzq_s16(v66), v70, (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v77, v77, 0x10uLL), 0x10uLL), vsraq_n_u32(v78, v78, 0x10uLL), 0x10uLL)));
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v30 = *(unsigned __int16 *)v20;
    v57 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      unint64_t v17 = (int8x8_t *)((char *)v17 + v57);
      unint64_t v19 = (int8x8_t *)((char *)v19 + v57);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v57);
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v57);
LABEL_40:
  uint64_t v79 = v16 + a14;
  if (v79)
  {
    if (a7) {
      __int16 v80 = 0;
    }
    else {
      __int16 v80 = -1;
    }
    int8x8_t v81 = 0;
    v81.i16[3] = v80;
    int8x8_t v82 = 0;
    if (a8) {
      __int16 v83 = 0;
    }
    else {
      __int16 v83 = -1;
    }
    v82.i16[3] = v83;
    uint32x4_t v84 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v85.i64[0] = 0x800000008000;
    v85.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v86 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int16x4_t v87 = (int16x4_t)vorr_s8(*v19, vbic_s8(v82, (int8x8_t)vceqz_s16(v86)));
        a13 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v81), (uint16x4_t)v86), v84), v85);
        *(uint16x4_t *)a13.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a13, (uint32x4_t)a13, 0x10uLL), 0x10uLL);
        int16x4_t v88 = vdup_lane_s16(*(int16x4_t *)a13.i8, 3);
        int16x4_t v89 = vdup_lane_s16(v87, 3);
        uint16x4_t v90 = vmin_u16(*(uint16x4_t *)a13.i8, (uint16x4_t)v88);
        uint16x4_t v91 = vmin_u16((uint16x4_t)v87, (uint16x4_t)v89);
        uint32x4_t v92 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vmaxq_u32(vmull_lane_u16(v90, (uint16x4_t)v87, 3), vmull_lane_u16(v91, *(uint16x4_t *)a13.i8, 3)), vmull_u16(v90, (uint16x4_t)vmvn_s8((int8x8_t)v89))), vmull_u16(v91, (uint16x4_t)vmvn_s8((int8x8_t)v88))), v84), v85);
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vceqz_s16(v88), (int8x8_t)v87, vbsl_s8((int8x8_t)vceqz_s16(v89), *(int8x8_t *)a13.i8, (int8x8_t)vqshrn_n_u32(vsraq_n_u32(v92, v92, 0x10uLL), 0x10uLL)));
        *unint64_t v19 = *(int8x8_t *)a13.i8;
      }
      int32x4_t v93 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v93 >= v18) {
        uint64_t v94 = -(uint64_t)a5;
      }
      else {
        uint64_t v94 = 0;
      }
      unint64_t v17 = &v93[v94];
      v19 += a6;
      --v79;
    }
    while (v79);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)16,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0x800000008000;
  a13.i64[1] = 0x800000008000;
  v29.i64[0] = -1;
  v29.i64[1] = -1;
  while (1)
  {
    __int32 v30 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      uint32x4_t v51 = (int8x16_t *)&v20[v16];
      uint16x8_t v52 = (int8x16_t *)v20;
      do
        uint32x4_t v53 = v52++;
      while (v52 <= v51 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v53)) & 0x80) != 0);
      do
      {
        uint32x4_t v54 = v53;
        uint32x4_t v53 = (int8x16_t *)((char *)v53 + 4);
      }
      while (v53 <= v51 && !v54->i32[0]);
      if (v54 < v51)
      {
        while (!v54->i8[0])
        {
          uint32x4_t v54 = (int8x16_t *)((char *)v54 + 1);
          if (v54 >= v51)
          {
            uint32x4_t v54 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v55 = (char *)v54 - v20;
      int64_t v56 = ((char *)v54 - v20) * a6;
      v17 += v56;
      v19 += v56;
      v20 += v56;
      v16 -= v55;
      goto LABEL_37;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    __int32 v31 = (int8x16_t *)&v20[v16];
    int32x4_t v32 = (int8x16_t *)v20;
    do
      __int32 v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v29)) & 0x80) != 0);
    do
    {
      uint64_t v34 = v33;
      __int32 v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint64_t v34 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v20;
    unint64_t v37 = (char *)v34 - v20;
    do
    {
      int8x16_t v38 = vorrq_s8(*(int8x16_t *)&v17->i8[v35], v23);
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      int16x8_t v40 = (int16x8_t)vqtbl1q_s8(v38, (int8x16_t)xmmword_1850CD880);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v42 = vminq_u16((uint16x8_t)v38, (uint16x8_t)v40);
      uint16x8_t v43 = vminq_u16((uint16x8_t)v39, (uint16x8_t)v41);
      uint32x4_t v44 = vmull_lane_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v39.i8, 3);
      uint16x8_t v45 = (uint16x8_t)vmvnq_s8((int8x16_t)v41);
      uint32x4_t v46 = vmull_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v45.i8);
      uint16x8_t v47 = (uint16x8_t)vmvnq_s8((int8x16_t)v40);
      uint32x4_t v48 = vqaddq_u32(vqaddq_u32(vminq_u32(vmull_high_laneq_u16(v43, (uint16x8_t)v38, 7), vmull_high_laneq_u16(v42, (uint16x8_t)v39, 7)), vmull_high_u16(v42, v45)), vmull_high_u16(v43, v47));
      uint32x4_t v49 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vminq_u32(vmull_lane_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v38.i8, 3), v44), v46), vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v47.i8)), v28), a13);
      uint32x4_t v50 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v48, v28), a13);
      int8x16_t v15 = vbslq_s8((int8x16_t)vceqzq_s16(v41), v38, (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v49, v49, 0x10uLL), 0x10uLL), vsraq_n_u32(v50, v50, 0x10uLL), 0x10uLL));
      *(int8x16_t *)&v19->i8[v35] = vbslq_s8((int8x16_t)vceqzq_s16(v40), v39, v15);
      v20 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    unint64_t v17 = (int8x8_t *)((char *)v17 + v35);
    unint64_t v16 = v16 - v36 + v37;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v57 = 0;
  while (1)
  {
    v15.i32[0] = v30;
    int16x8_t v58 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v59 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v57], v23);
    int16x8_t v60 = (int16x8_t)vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v58)), *(int8x16_t *)&v19->i8[v57]);
    uint32x4_t v61 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v59.i8, *(uint16x4_t *)v58.i8), v28), a13);
    int16x4_t v62 = (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v61, v61, 0x10uLL), 0x10uLL);
    uint32x4_t v63 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v59, (uint16x8_t)v58), v28), a13);
    uint32x4_t v64 = vsraq_n_u32(v63, v63, 0x10uLL);
    int16x4_t v65 = (int16x4_t)vqshrn_n_u32(v64, 0x10uLL);
    *(int16x4_t *)v58.i8 = vdup_lane_s16(v62, 3);
    int16x8_t v66 = (int16x8_t)vqtbl1q_s8((int8x16_t)v60, (int8x16_t)xmmword_1850CD880);
    int8x16_t v67 = (int8x16_t)vminq_u16((uint16x8_t)v60, (uint16x8_t)v66);
    uint16x4_t v68 = vmin_u16((uint16x4_t)v62, *(uint16x4_t *)v58.i8);
    uint32x4_t v69 = vmull_lane_u16(*(uint16x4_t *)v67.i8, (uint16x4_t)v62, 3);
    int8x16_t v70 = (int8x16_t)vqshrn_high_n_u32((uint16x4_t)v62, v64, 0x10uLL);
    v58.i64[1] = vdupq_lane_s16(v65, 3).u64[0];
    uint16x4_t v71 = vmin_u16((uint16x4_t)v65, (uint16x4_t)v58.u64[1]);
    int8x16_t v72 = (int8x16_t)vdupq_laneq_s16(v60, 7);
    uint16x4_t v73 = (uint16x4_t)vextq_s8(v67, v67, 8uLL).u64[0];
    int8x16_t v74 = vmvnq_s8((int8x16_t)v66);
    uint32x4_t v75 = vqaddq_u32(vminq_u32(v69, vmull_lane_u16(v68, *(uint16x4_t *)v60.i8, 3)), vmull_u16(v68, *(uint16x4_t *)v74.i8));
    uint32x4_t v76 = vqaddq_u32(vminq_u32(vmull_high_lane_u16((uint16x8_t)v67, (uint16x4_t)v65, 3), vmull_u16(v71, (uint16x4_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL))), vmull_u16(v71, (uint16x4_t)*(_OWORD *)&vextq_s8(v74, v74, 8uLL)));
    uint32x4_t v77 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v75, vmull_u16(*(uint16x4_t *)v67.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v58.i8))), v28), a13);
    uint32x4_t v78 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v76, vmull_u16(v73, (uint16x4_t)vmvn_s8((int8x8_t)v58.u64[1]))), v28), a13);
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v58);
    *(int8x16_t *)&v19->i8[v57] = vbslq_s8(v15, (int8x16_t)v60, vbslq_s8((int8x16_t)vceqzq_s16(v66), v70, (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v77, v77, 0x10uLL), 0x10uLL), vsraq_n_u32(v78, v78, 0x10uLL), 0x10uLL)));
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v30 = *(unsigned __int16 *)v20;
    v57 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      unint64_t v17 = (int8x8_t *)((char *)v17 + v57);
      unint64_t v19 = (int8x8_t *)((char *)v19 + v57);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v57);
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v57);
LABEL_40:
  uint64_t v79 = v16 + a14;
  if (v79)
  {
    if (a7) {
      __int16 v80 = 0;
    }
    else {
      __int16 v80 = -1;
    }
    int8x8_t v81 = 0;
    v81.i16[3] = v80;
    int8x8_t v82 = 0;
    if (a8) {
      __int16 v83 = 0;
    }
    else {
      __int16 v83 = -1;
    }
    v82.i16[3] = v83;
    uint32x4_t v84 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v85.i64[0] = 0x800000008000;
    v85.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v86 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int16x4_t v87 = (int16x4_t)vorr_s8(*v19, vbic_s8(v82, (int8x8_t)vceqz_s16(v86)));
        a13 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v81), (uint16x4_t)v86), v84), v85);
        *(uint16x4_t *)a13.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a13, (uint32x4_t)a13, 0x10uLL), 0x10uLL);
        int16x4_t v88 = vdup_lane_s16(*(int16x4_t *)a13.i8, 3);
        int16x4_t v89 = vdup_lane_s16(v87, 3);
        uint16x4_t v90 = vmin_u16(*(uint16x4_t *)a13.i8, (uint16x4_t)v88);
        uint16x4_t v91 = vmin_u16((uint16x4_t)v87, (uint16x4_t)v89);
        uint32x4_t v92 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vminq_u32(vmull_lane_u16(v90, (uint16x4_t)v87, 3), vmull_lane_u16(v91, *(uint16x4_t *)a13.i8, 3)), vmull_u16(v90, (uint16x4_t)vmvn_s8((int8x8_t)v89))), vmull_u16(v91, (uint16x4_t)vmvn_s8((int8x8_t)v88))), v84), v85);
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vceqz_s16(v88), (int8x8_t)v87, vbsl_s8((int8x8_t)vceqz_s16(v89), *(int8x8_t *)a13.i8, (int8x8_t)vqshrn_n_u32(vsraq_n_u32(v92, v92, 0x10uLL), 0x10uLL)));
        *unint64_t v19 = *(int8x8_t *)a13.i8;
      }
      int32x4_t v93 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v93 >= v18) {
        uint64_t v94 = -(uint64_t)a5;
      }
      else {
        uint64_t v94 = 0;
      }
      unint64_t v17 = &v93[v94];
      v19 += a6;
      --v79;
    }
    while (v79);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)15,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, int32x4_t a14, uint64_t a15, unint64_t a16)
{
  unint64_t v17 = a16;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a16 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v22 = 0;
  }
  else {
    unsigned int v22 = -1;
  }
  v23.i64[0] = 0xFFFF000000000000;
  v23.i64[1] = 0xFFFF000000000000;
  int8x16_t v24 = vandq_s8((int8x16_t)vdupq_n_s16(v22), v23);
  if (a8) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = -1;
  }
  int8x16_t v26 = vandq_s8((int8x16_t)vdupq_n_s16(v25), v23);
  uint64_t v27 = 2 * a6;
  uint64_t v28 = 16 * a6;
  uint32x4_t v29 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a14.i64[0] = 0x800000008000;
  a14.i64[1] = 0x800000008000;
  v30.i64[0] = -1;
  v30.i64[1] = -1;
  while (1)
  {
    __int32 v31 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      uint16x8_t v52 = (int8x16_t *)&v21[v17];
      uint32x4_t v53 = (int8x16_t *)v21;
      do
        uint32x4_t v54 = v53++;
      while (v53 <= v52 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v54)) & 0x80) != 0);
      do
      {
        int64_t v55 = v54;
        uint32x4_t v54 = (int8x16_t *)((char *)v54 + 4);
      }
      while (v54 <= v52 && !v55->i32[0]);
      if (v55 < v52)
      {
        while (!v55->i8[0])
        {
          int64_t v55 = (int8x16_t *)((char *)v55 + 1);
          if (v55 >= v52)
          {
            int64_t v55 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v56 = (char *)v55 - v21;
      int64_t v57 = ((char *)v55 - v21) * a6;
      v18 += v57;
      v20 += v57;
      v21 += v57;
      v17 -= v56;
      goto LABEL_37;
    }
    if (v31 != 0xFFFF) {
      break;
    }
    int32x4_t v32 = (int8x16_t *)&v21[v17];
    __int32 v33 = (int8x16_t *)v21;
    do
      uint64_t v34 = v33++;
    while (v33 <= v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, v30)) & 0x80) != 0);
    do
    {
      uint64_t v35 = v34;
      uint64_t v34 = (int8x16_t *)((char *)v34 + 4);
    }
    while (v34 <= v32 && v35->i32[0] == -1);
    if (v35 < v32)
    {
      while (v35->u8[0] == 255)
      {
        uint64_t v35 = (int8x16_t *)((char *)v35 + 1);
        if (v35 >= v32)
        {
          uint64_t v35 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v36 = 0;
    int64_t v37 = (char *)v35 - v21;
    unint64_t v38 = (char *)v35 - v21;
    do
    {
      int16x8_t v39 = (int16x8_t)vorrq_s8(*(int8x16_t *)&v18->i8[v36], v24);
      int8x16_t v40 = vorrq_s8(*(int8x16_t *)&v20->i8[v36], v26);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8((int8x16_t)v39, (int8x16_t)xmmword_1850CD880);
      int16x8_t v42 = (int16x8_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_1850CD880);
      int16x8_t v43 = (int16x8_t)vminq_u16((uint16x8_t)v39, (uint16x8_t)v41);
      int16x8_t v44 = (int16x8_t)vminq_u16((uint16x8_t)v40, (uint16x8_t)v42);
      uint16x8_t v45 = (uint16x8_t)vsubq_s16(v41, v43);
      uint16x8_t v46 = (uint16x8_t)vsubq_s16(v42, v44);
      int16x8_t v47 = (int16x8_t)vcgtq_u16(vrhaddq_u16((uint16x8_t)v42, (uint16x8_t)0), (uint16x8_t)v44);
      int8x16_t v48 = (int8x16_t)vqaddq_u32(vmull_u16(*(uint16x4_t *)v45.i8, *(uint16x4_t *)v44.i8), vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v43.i8));
      int8x16_t v49 = (int8x16_t)vqaddq_u32(vmull_high_u16(v45, (uint16x8_t)v44), vmull_high_u16(v46, (uint16x8_t)v43));
      uint32x4_t v50 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v47.i8), v48, (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v39.i8, 3), *(uint16x4_t *)v40.i8, 3), (uint32x4_t)v48)), v29), a14);
      uint32x4_t v51 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v47), v49, (int8x16_t)vqsubq_u32(vmull_laneq_u16((uint16x4_t)vdup_laneq_s16(v39, 7), (uint16x8_t)v40, 7), (uint32x4_t)v49)), v29), a14);
      int8x16_t v16 = (int8x16_t)vceqzq_s16(v42);
      *(int8x16_t *)&v20->i8[v36] = vbslq_s8((int8x16_t)vceqzq_s16(v41), v40, vbslq_s8(v16, (int8x16_t)v39, (int8x16_t)vsubq_s16(vaddq_s16(v44, v43), (int16x8_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v50, v50, 0x10uLL), 0x10uLL), vsraq_n_u32(v51, v51, 0x10uLL), 0x10uLL))));
      v21 += v27;
      v38 -= 2;
      v36 += v28;
    }
    while (v38 > 1);
    unint64_t v20 = (int8x8_t *)((char *)v20 + v36);
    unint64_t v18 = (int8x8_t *)((char *)v18 + v36);
    unint64_t v17 = v17 - v37 + v38;
LABEL_37:
    if (v17 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v58 = 0;
  while (1)
  {
    v16.i32[0] = v31;
    int16x8_t v59 = (int16x8_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v60 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v18->i8[v58], v24);
    int8x16_t v61 = vorrq_s8(vbicq_s8(v26, (int8x16_t)vceqzq_s16(v59)), *(int8x16_t *)&v20->i8[v58]);
    uint32x4_t v62 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v60.i8, *(uint16x4_t *)v59.i8), v29), a14);
    *(uint16x4_t *)v62.i8 = vqshrn_n_u32(vsraq_n_u32(v62, v62, 0x10uLL), 0x10uLL);
    uint32x4_t v63 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v60, (uint16x8_t)v59), v29), a14);
    uint32x4_t v64 = vsraq_n_u32(v63, v63, 0x10uLL);
    *(uint16x4_t *)v59.i8 = vqshrn_n_u32(v64, 0x10uLL);
    *(int16x4_t *)v65.i8 = vdup_lane_s16(*(int16x4_t *)v62.i8, 3);
    uint16x4_t v66 = vmin_u16(*(uint16x4_t *)v62.i8, *(uint16x4_t *)v65.i8);
    v65.u64[1] = (unint64_t)vdup_lane_s16(*(int16x4_t *)v59.i8, 3);
    int8x16_t v67 = (int8x16_t)vqshrn_high_n_u32(*(uint16x4_t *)v62.i8, v64, 0x10uLL);
    int16x8_t v68 = (int16x8_t)vqtbl1q_s8(v61, (int8x16_t)xmmword_1850CD880);
    int16x8_t v69 = (int16x8_t)vminq_u16((uint16x8_t)v67, v65);
    int16x8_t v70 = (int16x8_t)vminq_u16((uint16x8_t)v61, (uint16x8_t)v68);
    uint16x8_t v71 = (uint16x8_t)vsubq_s16((int16x8_t)v65, v69);
    int8x16_t v72 = (int8x16_t)vsubq_s16(v68, v70);
    uint32x4_t v73 = vmull_u16(*(uint16x4_t *)v72.i8, v66);
    uint32x4_t v74 = vmull_u16((uint16x4_t)*(_OWORD *)&vextq_s8(v72, v72, 8uLL), vmin_u16(*(uint16x4_t *)v59.i8, (uint16x4_t)v65.u64[1]));
    int16x8_t v75 = (int16x8_t)vcgtq_u16(vrhaddq_u16((uint16x8_t)v68, (uint16x8_t)0), (uint16x8_t)v70);
    int8x16_t v76 = (int8x16_t)vqaddq_u32(vmull_u16(*(uint16x4_t *)v71.i8, *(uint16x4_t *)v70.i8), v73);
    int8x16_t v77 = (int8x16_t)vqaddq_u32(vmull_high_u16(v71, (uint16x8_t)v70), v74);
    uint32x4_t v78 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v75.i8), v76, (int8x16_t)vqsubq_u32(vmull_lane_u16(*(uint16x4_t *)v65.i8, *(uint16x4_t *)v61.i8, 3), (uint32x4_t)v76)), v29), a14);
    uint32x4_t v79 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v75), v77, (int8x16_t)vqsubq_u32(vmull_laneq_u16((uint16x4_t)v65.u64[1], (uint16x8_t)v61, 7), (uint32x4_t)v77)), v29), a14);
    int8x16_t v16 = (int8x16_t)vsubq_s16(vaddq_s16(v70, v69), (int16x8_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v78, v78, 0x10uLL), 0x10uLL), vsraq_n_u32(v79, v79, 0x10uLL), 0x10uLL));
    *(int8x16_t *)&v20->i8[v58] = vbslq_s8((int8x16_t)vceqzq_s16((int16x8_t)v65), v61, vbslq_s8((int8x16_t)vceqzq_s16(v68), v67, v16));
    v21 += v27;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    __int32 v31 = *(unsigned __int16 *)v21;
    v58 += v28;
    if ((unsigned __int16)(v31 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (int8x8_t *)((char *)v18 + v58);
      unint64_t v20 = (int8x8_t *)((char *)v20 + v58);
      goto LABEL_37;
    }
  }
  unint64_t v18 = (int8x8_t *)((char *)v18 + v28 + v58);
  unint64_t v20 = (int8x8_t *)((char *)v20 + v28 + v58);
LABEL_40:
  uint64_t v80 = v17 + a15;
  if (v80)
  {
    if (a7) {
      __int16 v81 = 0;
    }
    else {
      __int16 v81 = -1;
    }
    int8x8_t v82 = 0;
    v82.i16[3] = v81;
    if (a8) {
      __int16 v83 = 0;
    }
    else {
      __int16 v83 = -1;
    }
    int8x8_t v84 = 0;
    v84.i16[3] = v83;
    uint32x4_t v85 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v86.i64[0] = 0x800000008000;
    v86.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a14.i32[0] = *v21;
        int16x4_t v87 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a14.i8, 0);
        int16x4_t v88 = (int16x4_t)vorr_s8(*v20, vbic_s8(v84, (int8x8_t)vceqz_s16(v87)));
        uint32x4_t v89 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v18, v82), (uint16x4_t)v87), v85), v86);
        *(uint16x4_t *)v89.i8 = vqshrn_n_u32(vsraq_n_u32(v89, v89, 0x10uLL), 0x10uLL);
        int16x4_t v90 = vdup_lane_s16(*(int16x4_t *)v89.i8, 3);
        int16x4_t v91 = vdup_lane_s16(v88, 3);
        int16x4_t v92 = (int16x4_t)vmin_u16(*(uint16x4_t *)v89.i8, (uint16x4_t)v90);
        int16x4_t v93 = (int16x4_t)vmin_u16((uint16x4_t)v88, (uint16x4_t)v91);
        int8x16_t v94 = (int8x16_t)vqaddq_u32(vmull_u16((uint16x4_t)vsub_s16(v90, v92), (uint16x4_t)v93), vmull_u16((uint16x4_t)vsub_s16(v91, v93), (uint16x4_t)v92));
        uint32x4_t v95 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_s16((int16x4_t)vcgt_u16(vrhadd_u16((uint16x4_t)v91, 0), (uint16x4_t)v93)), v94, (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)v90, (uint16x4_t)v88, 3), (uint32x4_t)v94)), v85), v86);
        *(int8x8_t *)a14.i8 = vbsl_s8((int8x8_t)vceqz_s16(v90), (int8x8_t)v88, vbsl_s8((int8x8_t)vceqz_s16(v91), *(int8x8_t *)v89.i8, (int8x8_t)vsub_s16(vadd_s16(v93, v92), (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v95, v95, 0x10uLL), 0x10uLL))));
        int8x8_t *v20 = *(int8x8_t *)a14.i8;
      }
      int16x4_t v96 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v96 >= v19) {
        uint64_t v97 = -(uint64_t)a5;
      }
      else {
        uint64_t v97 = 0;
      }
      unint64_t v18 = &v96[v97];
      v20 += a6;
      --v80;
    }
    while (v80);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)14,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0x800000008000;
  a13.i64[1] = 0x800000008000;
  v29.i64[0] = -1;
  v29.i64[1] = -1;
  while (1)
  {
    __int32 v30 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      int16x8_t v43 = (int8x16_t *)&v20[v16];
      int16x8_t v44 = (int8x16_t *)v20;
      do
        uint16x8_t v45 = v44++;
      while (v44 <= v43 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v45)) & 0x80) != 0);
      do
      {
        uint16x8_t v46 = v45;
        uint16x8_t v45 = (int8x16_t *)((char *)v45 + 4);
      }
      while (v45 <= v43 && !v46->i32[0]);
      if (v46 < v43)
      {
        while (!v46->i8[0])
        {
          uint16x8_t v46 = (int8x16_t *)((char *)v46 + 1);
          if (v46 >= v43)
          {
            uint16x8_t v46 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v47 = (char *)v46 - v20;
      int64_t v48 = ((char *)v46 - v20) * a6;
      v17 += v48;
      v19 += v48;
      v20 += v48;
      v16 -= v47;
      goto LABEL_37;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    __int32 v31 = (int8x16_t *)&v20[v16];
    int32x4_t v32 = (int8x16_t *)v20;
    do
      __int32 v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v29)) & 0x80) != 0);
    do
    {
      uint64_t v34 = v33;
      __int32 v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint64_t v34 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v20;
    unint64_t v37 = (char *)v34 - v20;
    do
    {
      int8x16_t v38 = vorrq_s8(*(int8x16_t *)&v17->i8[v35], v23);
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      uint16x8_t v40 = (uint16x8_t)vbicq_s8(v39, (int8x16_t)vceqzq_s16((int16x8_t)vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880)));
      uint32x4_t v41 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v38.i8, *(uint16x4_t *)v40.i8), v28), a13);
      uint32x4_t v42 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16((uint16x8_t)v38, v40), v28), a13);
      int8x16_t v15 = (int8x16_t)vceqzq_s16((int16x8_t)vqtbl1q_s8(v38, (int8x16_t)xmmword_1850CD880));
      *(int8x16_t *)&v19->i8[v35] = vbslq_s8(v15, v39, (int8x16_t)vqaddq_u16(vqsubq_u16((uint16x8_t)v38, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v41, v41, 0x10uLL), 0x10uLL), vsraq_n_u32(v42, v42, 0x10uLL), 0x10uLL)), v40));
      v20 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    unint64_t v17 = (int8x8_t *)((char *)v17 + v35);
    unint64_t v16 = v16 - v36 + v37;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v49 = 0;
  while (1)
  {
    v15.i32[0] = v30;
    int16x8_t v50 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v51 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v49], v23);
    int8x16_t v52 = vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v50)), *(int8x16_t *)&v19->i8[v49]);
    int16x8_t v53 = (int16x8_t)vmull_u16(*(uint16x4_t *)v51.i8, *(uint16x4_t *)v50.i8);
    uint32x4_t v54 = vmull_high_u16(v51, (uint16x8_t)v50);
    uint32x4_t v55 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)v53, v28), a13);
    *(uint16x4_t *)v55.i8 = vqshrn_n_u32(vsraq_n_u32(v55, v55, 0x10uLL), 0x10uLL);
    uint32x4_t v56 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v54, v28), a13);
    uint32x4_t v57 = vsraq_n_u32(v56, v56, 0x10uLL);
    *(int16x4_t *)v53.i8 = vdup_lane_s16(*(int16x4_t *)v55.i8, 3);
    int16x4_t v58 = (int16x4_t)vqshrn_n_u32(v57, 0x10uLL);
    int8x16_t v59 = vbicq_s8(v52, (int8x16_t)vceqzq_s16((int16x8_t)vqtbl1q_s8(v52, (int8x16_t)xmmword_1850CD880)));
    uint32x4_t v60 = vmull_u16(*(uint16x4_t *)v55.i8, *(uint16x4_t *)v59.i8);
    uint16x8_t v61 = vqshrn_high_n_u32(*(uint16x4_t *)v55.i8, v57, 0x10uLL);
    v53.u64[1] = (unint64_t)vdup_lane_s16(v58, 3);
    uint32x4_t v62 = vmull_u16((uint16x4_t)v58, (uint16x4_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL));
    uint32x4_t v63 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v60, v28), a13);
    uint32x4_t v64 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v62, v28), a13);
    int8x16_t v65 = (int8x16_t)vqaddq_u16(vqsubq_u16(v61, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v63, v63, 0x10uLL), 0x10uLL), vsraq_n_u32(v64, v64, 0x10uLL), 0x10uLL)), (uint16x8_t)v59);
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v53);
    *(int8x16_t *)&v19->i8[v49] = vbslq_s8(v15, v52, v65);
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v30 = *(unsigned __int16 *)v20;
    v49 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      unint64_t v17 = (int8x8_t *)((char *)v17 + v49);
      unint64_t v19 = (int8x8_t *)((char *)v19 + v49);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v49);
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v49);
LABEL_40:
  uint64_t v66 = v16 + a14;
  if (v66)
  {
    if (a7) {
      __int16 v67 = 0;
    }
    else {
      __int16 v67 = -1;
    }
    int8x8_t v68 = 0;
    v68.i16[3] = v67;
    int8x8_t v69 = 0;
    if (a8) {
      __int16 v70 = 0;
    }
    else {
      __int16 v70 = -1;
    }
    v69.i16[3] = v70;
    uint32x4_t v71 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v72.i64[0] = 0x800000008000;
    v72.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v73 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int16x4_t v74 = (int16x4_t)vorr_s8(*v19, vbic_s8(v69, (int8x8_t)vceqz_s16(v73)));
        a13 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v68), (uint16x4_t)v73), v71), v72);
        *(uint16x4_t *)a13.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a13, (uint32x4_t)a13, 0x10uLL), 0x10uLL);
        uint16x4_t v75 = (uint16x4_t)vbic_s8((int8x8_t)v74, (int8x8_t)vdup_lane_s16(vceqz_s16(v74), 3));
        uint32x4_t v76 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)a13.i8, v75), v71), v72);
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vdup_lane_s16(vceqz_s16(*(int16x4_t *)a13.i8), 3), (int8x8_t)v74, (int8x8_t)vqadd_u16(vqsub_u16(*(uint16x4_t *)a13.i8, vqshrn_n_u32(vsraq_n_u32(v76, v76, 0x10uLL), 0x10uLL)), v75));
        *unint64_t v19 = *(int8x8_t *)a13.i8;
      }
      int8x16_t v77 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v77 >= v18) {
        uint64_t v78 = -(uint64_t)a5;
      }
      else {
        uint64_t v78 = 0;
      }
      unint64_t v17 = &v77[v78];
      v19 += a6;
      --v66;
    }
    while (v66);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)13,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int32x4_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a13.i64[0] = 0x800000008000;
  a13.i64[1] = 0x800000008000;
  v29.i64[0] = -1;
  v29.i64[1] = -1;
  while (1)
  {
    __int32 v30 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      int16x8_t v53 = (int8x16_t *)&v20[v16];
      uint32x4_t v54 = (int8x16_t *)v20;
      do
        uint32x4_t v55 = v54++;
      while (v54 <= v53 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v55)) & 0x80) != 0);
      do
      {
        uint32x4_t v56 = v55;
        uint32x4_t v55 = (int8x16_t *)((char *)v55 + 4);
      }
      while (v55 <= v53 && !v56->i32[0]);
      if (v56 < v53)
      {
        while (!v56->i8[0])
        {
          uint32x4_t v56 = (int8x16_t *)((char *)v56 + 1);
          if (v56 >= v53)
          {
            uint32x4_t v56 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v57 = (char *)v56 - v20;
      int64_t v58 = ((char *)v56 - v20) * a6;
      v17 += v58;
      v19 += v58;
      v20 += v58;
      v16 -= v57;
      goto LABEL_37;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    __int32 v31 = (int8x16_t *)&v20[v16];
    int32x4_t v32 = (int8x16_t *)v20;
    do
      __int32 v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v29)) & 0x80) != 0);
    do
    {
      uint64_t v34 = v33;
      __int32 v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint64_t v34 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v20;
    unint64_t v37 = (char *)v34 - v20;
    do
    {
      int8x16_t v38 = vorrq_s8(*(int8x16_t *)&v17->i8[v35], v23);
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      int16x8_t v40 = (int16x8_t)vqtbl1q_s8(v38, (int8x16_t)xmmword_1850CD880);
      int16x8_t v41 = (int16x8_t)vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880);
      int8x16_t v42 = (int8x16_t)vceqzq_s16(v41);
      uint16x8_t v43 = (uint16x8_t)vbicq_s8(v39, v42);
      uint32x4_t v44 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v38.i8, *(uint16x4_t *)v43.i8), v28), a13);
      uint32x4_t v45 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16((uint16x8_t)v38, v43), v28), a13);
      uint16x8_t v46 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v44, v44, 0x10uLL), 0x10uLL), vsraq_n_u32(v45, v45, 0x10uLL), 0x10uLL);
      uint16x8_t v47 = (uint16x8_t)vmvnq_s8((int8x16_t)v41);
      uint16x8_t v48 = (uint16x8_t)vmvnq_s8((int8x16_t)v40);
      uint32x4_t v49 = vqaddq_u32(vmull_u16(*(uint16x4_t *)v38.i8, *(uint16x4_t *)v47.i8), vmull_u16(*(uint16x4_t *)v43.i8, *(uint16x4_t *)v48.i8));
      uint32x4_t v50 = vqaddq_u32(vmull_high_u16((uint16x8_t)v38, v47), vmull_high_u16(v43, v48));
      uint32x4_t v51 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v49, v28), a13);
      uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v50, v28), a13);
      int8x16_t v15 = (int8x16_t)vceqzq_s16(v40);
      *(int8x16_t *)&v19->i8[v35] = vbslq_s8(v15, v39, vbslq_s8(v42, v38, (int8x16_t)vqaddq_u16(v46, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v51, v51, 0x10uLL), 0x10uLL), vsraq_n_u32(v52, v52, 0x10uLL), 0x10uLL))));
      v20 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    unint64_t v17 = (int8x8_t *)((char *)v17 + v35);
    unint64_t v16 = v16 - v36 + v37;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v59 = 0;
  while (1)
  {
    v15.i32[0] = v30;
    int16x8_t v60 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v61 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v59], v23);
    int8x16_t v62 = vorrq_s8(vbicq_s8(v25, (int8x16_t)vceqzq_s16(v60)), *(int8x16_t *)&v19->i8[v59]);
    uint32x4_t v63 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v61.i8, *(uint16x4_t *)v60.i8), v28), a13);
    *(uint16x4_t *)v63.i8 = vqshrn_n_u32(vsraq_n_u32(v63, v63, 0x10uLL), 0x10uLL);
    uint32x4_t v64 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v61, (uint16x8_t)v60), v28), a13);
    uint32x4_t v65 = vsraq_n_u32(v64, v64, 0x10uLL);
    *(uint16x4_t *)v61.i8 = vqshrn_n_u32(v65, 0x10uLL);
    *(int16x4_t *)v66.i8 = vdup_lane_s16(*(int16x4_t *)v63.i8, 3);
    int16x8_t v67 = (int16x8_t)vqtbl1q_s8(v62, (int8x16_t)xmmword_1850CD880);
    int8x16_t v68 = (int8x16_t)vceqzq_s16(v67);
    int8x16_t v69 = vbicq_s8(v62, v68);
    uint32x4_t v70 = vmull_u16(*(uint16x4_t *)v63.i8, *(uint16x4_t *)v69.i8);
    int8x16_t v71 = vmvnq_s8((int8x16_t)v67);
    uint32x4_t v72 = vmull_u16(*(uint16x4_t *)v63.i8, *(uint16x4_t *)v71.i8);
    int8x16_t v73 = (int8x16_t)vqshrn_high_n_u32(*(uint16x4_t *)v63.i8, v65, 0x10uLL);
    v66.u64[1] = (unint64_t)vdup_lane_s16(*(int16x4_t *)v61.i8, 3);
    uint16x4_t v74 = (uint16x4_t)vextq_s8(v69, v69, 8uLL).u64[0];
    uint32x4_t v75 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v70, v28), a13);
    uint32x4_t v76 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v61.i8, v74), v28), a13);
    uint32x4_t v77 = vqaddq_u32(vmull_u16(*(uint16x4_t *)v61.i8, (uint16x4_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL)), vmull_u16(v74, (uint16x4_t)vmvn_s8((int8x8_t)v66.u64[1])));
    uint32x4_t v78 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(v72, vmull_u16(*(uint16x4_t *)v69.i8, (uint16x4_t)vmvn_s8(*(int8x8_t *)v66.i8))), v28), a13);
    uint32x4_t v79 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v77, v28), a13);
    int8x16_t v80 = vbslq_s8(v68, v73, (int8x16_t)vqaddq_u16(vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v75, v75, 0x10uLL), 0x10uLL), vsraq_n_u32(v76, v76, 0x10uLL), 0x10uLL), vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v78, v78, 0x10uLL), 0x10uLL), vsraq_n_u32(v79, v79, 0x10uLL), 0x10uLL)));
    int8x16_t v15 = (int8x16_t)vceqzq_s16(v66);
    *(int8x16_t *)&v19->i8[v59] = vbslq_s8(v15, v62, v80);
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v30 = *(unsigned __int16 *)v20;
    v59 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      unint64_t v17 = (int8x8_t *)((char *)v17 + v59);
      unint64_t v19 = (int8x8_t *)((char *)v19 + v59);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v59);
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v59);
LABEL_40:
  uint64_t v81 = v16 + a14;
  if (v81)
  {
    if (a7) {
      __int16 v82 = 0;
    }
    else {
      __int16 v82 = -1;
    }
    int8x8_t v83 = 0;
    v83.i16[3] = v82;
    int8x8_t v84 = 0;
    if (a8) {
      __int16 v85 = 0;
    }
    else {
      __int16 v85 = -1;
    }
    v84.i16[3] = v85;
    uint32x4_t v86 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v87.i64[0] = 0x800000008000;
    v87.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v88 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a13.i8, 0);
        int8x8_t v89 = vbic_s8(v84, (int8x8_t)vceqz_s16(v88));
        a13 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v83), (uint16x4_t)v88), v86), v87);
        *(uint16x4_t *)a13.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a13, (uint32x4_t)a13, 0x10uLL), 0x10uLL);
        int16x4_t v90 = vdup_lane_s16(*(int16x4_t *)a13.i8, 3);
        int16x4_t v91 = (int16x4_t)vorr_s8(*v19, v89);
        int16x4_t v92 = vdup_lane_s16(v91, 3);
        int8x8_t v93 = (int8x8_t)vceqz_s16(v92);
        uint16x4_t v94 = (uint16x4_t)vbic_s8((int8x8_t)v91, v93);
        uint32x4_t v95 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)a13.i8, v94), v86), v87);
        uint32x4_t v96 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_u16(*(uint16x4_t *)a13.i8, (uint16x4_t)vmvn_s8((int8x8_t)v92)), vmull_u16(v94, (uint16x4_t)vmvn_s8((int8x8_t)v90))), v86), v87);
        *(int8x8_t *)a13.i8 = vbsl_s8((int8x8_t)vceqz_s16(v90), (int8x8_t)v91, vbsl_s8(v93, *(int8x8_t *)a13.i8, (int8x8_t)vqadd_u16(vqshrn_n_u32(vsraq_n_u32(v95, v95, 0x10uLL), 0x10uLL), vqshrn_n_u32(vsraq_n_u32(v96, v96, 0x10uLL), 0x10uLL))));
        *unint64_t v19 = *(int8x8_t *)a13.i8;
      }
      uint64_t v97 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v97 >= v18) {
        uint64_t v98 = -(uint64_t)a5;
      }
      else {
        uint64_t v98 = 0;
      }
      unint64_t v17 = &v97[v98];
      v19 += a6;
      --v81;
    }
    while (v81);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)12,_rgba16_t>(int8x8_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, double a8, double a9, double a10, uint32x4_t a11, double a12, double a13, double a14, uint16x8_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v18 = a18;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  unsigned int v21 = *a2;
  int8x16_t v22 = *a4;
  if (a18 < 2) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFFFF000000000000;
  v24.i64[1] = 0xFFFF000000000000;
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v23), v24);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  v28.i64[0] = -1;
  v28.i64[1] = -1;
  a11 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v29.i64[0] = 0x800000008000;
  v29.i64[1] = 0x800000008000;
  while (1)
  {
    unsigned __int32 v30 = *(unsigned __int16 *)v22;
    if (!*(_WORD *)v22)
    {
      int8x16_t v38 = (int8x16_t *)&v22[v18];
      int8x16_t v39 = (int8x16_t *)v22;
      do
        int16x8_t v40 = v39++;
      while (v39 <= v38 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v40)) & 0x80) != 0);
      do
      {
        int16x8_t v41 = v40;
        int16x8_t v40 = (int8x16_t *)((char *)v40 + 4);
      }
      while (v40 <= v38 && !v41->i32[0]);
      if (v41 < v38)
      {
        while (!v41->i8[0])
        {
          int16x8_t v41 = (int8x16_t *)((char *)v41 + 1);
          if (v41 >= v38)
          {
            int16x8_t v41 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      int64_t v42 = (char *)v41 - v22;
      int64_t v43 = ((char *)v41 - v22) * a6;
      v19 += v43;
      v21 += v43;
      v22 += v43;
      v18 -= v42;
      goto LABEL_34;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    __int32 v31 = (int8x16_t *)&v22[v18];
    int32x4_t v32 = (int8x16_t *)v22;
    do
      __int32 v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v28)) & 0x80) != 0);
    do
    {
      uint64_t v34 = v33;
      __int32 v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint64_t v34 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v22;
    unint64_t v37 = (char *)v34 - v22;
    do
    {
      *(uint16x8_t *)&v21->i8[v35] = vqaddq_u16(*(uint16x8_t *)&v21->i8[v35], (uint16x8_t)vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25));
      v22 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    unsigned int v21 = (uint16x4_t *)((char *)v21 + v35);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    unint64_t v18 = v18 - v36 + v37;
LABEL_34:
    if (v18 <= 1) {
      goto LABEL_37;
    }
  }
  uint64_t v44 = 0;
  while (1)
  {
    a15.i32[0] = v30;
    uint16x8_t v45 = (uint16x8_t)vqtbl1q_s8((int8x16_t)a15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v46 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v19->i8[v44], v25);
    uint32x4_t v47 = vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v45.i8);
    uint32x4_t v48 = vmull_high_u16(v46, v45);
    uint32x4_t v49 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v47, a11), v29);
    uint32x4_t v50 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v48, a11), v29);
    a15 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v49, v49, 0x10uLL), 0x10uLL), vsraq_n_u32(v50, v50, 0x10uLL), 0x10uLL);
    *(uint16x8_t *)&v21->i8[v44] = vqaddq_u16(*(uint16x8_t *)&v21->i8[v44], a15);
    v22 += v26;
    v18 -= 2;
    if (v18 < 2) {
      break;
    }
    unsigned __int32 v30 = *(unsigned __int16 *)v22;
    v44 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      unint64_t v19 = (int8x8_t *)((char *)v19 + v44);
      unsigned int v21 = (uint16x4_t *)((char *)v21 + v44);
      goto LABEL_34;
    }
  }
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v44);
  unsigned int v21 = (uint16x4_t *)((char *)v21 + v27 + v44);
LABEL_37:
  uint64_t v51 = v18 + a17;
  if (v51)
  {
    int8x8_t v52 = 0;
    if (a7) {
      __int16 v53 = 0;
    }
    else {
      __int16 v53 = -1;
    }
    v52.i16[3] = v53;
    uint32x4_t v54 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v55.i64[0] = 0x800000008000;
    v55.i64[1] = 0x800000008000;
    do
    {
      if (*v22)
      {
        a11.i32[0] = *v22;
        a11 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v19, v52), (uint16x4_t)vdup_lane_s8(*(int8x8_t *)a11.i8, 0)), v54), v55);
        *(uint16x4_t *)a11.i8 = vqadd_u16(*v21, vqshrn_n_u32(vsraq_n_u32(a11, a11, 0x10uLL), 0x10uLL));
        uint16x4_t *v21 = *(uint16x4_t *)a11.i8;
      }
      uint32x4_t v56 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v56 >= v20) {
        uint64_t v57 = -(uint64_t)a5;
      }
      else {
        uint64_t v57 = 0;
      }
      unint64_t v19 = &v56[v57];
      v21 += a6;
      --v51;
    }
    while (v51);
  }
  *size_t result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)11,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, int8x8_t a13, uint64_t a14, unint64_t a15)
{
  unint64_t v16 = a15;
  unint64_t v17 = *result;
  unint64_t v18 = *a3;
  unint64_t v19 = *a2;
  unint64_t v20 = *a4;
  if (a15 < 2) {
    goto LABEL_40;
  }
  if (a7) {
    unsigned int v21 = 0;
  }
  else {
    unsigned int v21 = -1;
  }
  v22.i64[0] = 0xFFFF000000000000;
  v22.i64[1] = 0xFFFF000000000000;
  int8x16_t v23 = vandq_s8((int8x16_t)vdupq_n_s16(v21), v22);
  if (a8) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v24), v22);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  v28.i64[0] = -1;
  v28.i64[1] = -1;
  a13.i32[1] = 0;
  uint32x4_t v29 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v30.i64[0] = 0x800000008000;
  v30.i64[1] = 0x800000008000;
  while (1)
  {
    __int32 v31 = *(unsigned __int16 *)v20;
    if (!*(_WORD *)v20)
    {
      int64_t v42 = (int8x16_t *)&v20[v16];
      int64_t v43 = (int8x16_t *)v20;
      do
        uint64_t v44 = v43++;
      while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v44)) & 0x80) != 0);
      do
      {
        uint16x8_t v45 = v44;
        uint64_t v44 = (int8x16_t *)((char *)v44 + 4);
      }
      while (v44 <= v42 && !v45->i32[0]);
      if (v45 < v42)
      {
        while (!v45->i8[0])
        {
          uint16x8_t v45 = (int8x16_t *)((char *)v45 + 1);
          if (v45 >= v42)
          {
            uint16x8_t v45 = (int8x16_t *)&v20[v16];
            break;
          }
        }
      }
      int64_t v46 = (char *)v45 - v20;
      int64_t v47 = ((char *)v45 - v20) * a6;
      v17 += v47;
      v19 += v47;
      v20 += v47;
      v16 -= v46;
      goto LABEL_37;
    }
    if (v31 != 0xFFFF) {
      break;
    }
    int32x4_t v32 = (int8x16_t *)&v20[v16];
    __int32 v33 = (int8x16_t *)v20;
    do
      uint64_t v34 = v33++;
    while (v33 <= v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, v28)) & 0x80) != 0);
    do
    {
      uint64_t v35 = v34;
      uint64_t v34 = (int8x16_t *)((char *)v34 + 4);
    }
    while (v34 <= v32 && v35->i32[0] == -1);
    if (v35 < v32)
    {
      while (v35->u8[0] == 255)
      {
        uint64_t v35 = (int8x16_t *)((char *)v35 + 1);
        if (v35 >= v32)
        {
          uint64_t v35 = (int8x16_t *)&v20[v16];
          break;
        }
      }
    }
    uint64_t v36 = 0;
    int64_t v37 = (char *)v35 - v20;
    unint64_t v38 = (char *)v35 - v20;
    do
    {
      int8x16_t v39 = vorrq_s8(*(int8x16_t *)&v17->i8[v36], v23);
      int8x16_t v40 = vorrq_s8(*(int8x16_t *)&v19->i8[v36], v25);
      int8x16_t v15 = vqtbl1q_s8(v39, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v41 = (uint16x8_t)vqtbl1q_s8(v40, (int8x16_t)xmmword_1850CD880);
      *(uint16x8_t *)&v19->i8[v36] = vqsubq_u16(vqaddq_u16(v41, (uint16x8_t)v15), vqaddq_u16(vqsubq_u16((uint16x8_t)v15, (uint16x8_t)v39), vqsubq_u16(v41, (uint16x8_t)v40)));
      v20 += v26;
      v38 -= 2;
      v36 += v27;
    }
    while (v38 > 1);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v36);
    unint64_t v17 = (int8x8_t *)((char *)v17 + v36);
    unint64_t v16 = v16 - v37 + v38;
LABEL_37:
    if (v16 <= 1) {
      goto LABEL_40;
    }
  }
  uint64_t v48 = 0;
  while (1)
  {
    int8x16_t v49 = *(int8x16_t *)&v19->i8[v48];
    v15.i32[0] = v31;
    int16x8_t v50 = (int16x8_t)vqtbl1q_s8(v15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v51 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v17->i8[v48], v23);
    int8x16_t v52 = (int8x16_t)vceqzq_s16(v50);
    int8x16_t v53 = vorrq_s8(vbicq_s8(v25, v52), v49);
    uint32x4_t v54 = vmull_u16(*(uint16x4_t *)v51.i8, *(uint16x4_t *)v50.i8);
    uint32x4_t v55 = vmull_high_u16(v51, (uint16x8_t)v50);
    uint32x4_t v56 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v54, v29), v30);
    *(uint16x4_t *)v56.i8 = vqshrn_n_u32(vsraq_n_u32(v56, v56, 0x10uLL), 0x10uLL);
    uint32x4_t v57 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v55, v29), v30);
    uint32x4_t v58 = vsraq_n_u32(v57, v57, 0x10uLL);
    *(int16x4_t *)v59.i8 = vdup_lane_s16(*(int16x4_t *)v56.i8, 3);
    uint16x8_t v60 = vqshrn_high_n_u32(*(uint16x4_t *)v56.i8, v58, 0x10uLL);
    v59.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v58, 0x10uLL), 3);
    uint16x8_t v61 = (uint16x8_t)vqtbl1q_s8(v53, (int8x16_t)xmmword_1850CD880);
    int8x16_t v15 = (int8x16_t)vqsubq_u16(v59, v60);
    *(int8x16_t *)&v19->i8[v48] = vbslq_s8(v52, v49, (int8x16_t)vqsubq_u16(vqaddq_u16(v61, v59), vqaddq_u16((uint16x8_t)v15, vqsubq_u16(v61, (uint16x8_t)v53))));
    v20 += v26;
    v16 -= 2;
    if (v16 < 2) {
      break;
    }
    __int32 v31 = *(unsigned __int16 *)v20;
    v48 += v27;
    if ((unsigned __int16)(v31 - 1) >= 0xFFFEu)
    {
      unint64_t v17 = (int8x8_t *)((char *)v17 + v48);
      unint64_t v19 = (int8x8_t *)((char *)v19 + v48);
      goto LABEL_37;
    }
  }
  unint64_t v17 = (int8x8_t *)((char *)v17 + v27 + v48);
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v48);
LABEL_40:
  uint64_t v62 = v16 + a14;
  if (v62)
  {
    if (a7) {
      __int16 v63 = 0;
    }
    else {
      __int16 v63 = -1;
    }
    int8x8_t v64 = 0;
    v64.i16[3] = v63;
    int8x8_t v65 = 0;
    if (a8) {
      __int16 v66 = 0;
    }
    else {
      __int16 v66 = -1;
    }
    v65.i16[3] = v66;
    uint32x4_t v67 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v68.i64[0] = 0x800000008000;
    v68.i64[1] = 0x800000008000;
    do
    {
      if (*v20)
      {
        a13.i32[0] = *v20;
        int16x4_t v69 = (int16x4_t)vdup_lane_s8(a13, 0);
        int8x8_t v70 = (int8x8_t)vceqz_s16(v69);
        int16x4_t v71 = (int16x4_t)vorr_s8(*v19, vbic_s8(v65, v70));
        uint32x4_t v72 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v17, v64), (uint16x4_t)v69), v67), v68);
        *(uint16x4_t *)v72.i8 = vqshrn_n_u32(vsraq_n_u32(v72, v72, 0x10uLL), 0x10uLL);
        uint16x4_t v73 = (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v72.i8, 3);
        uint16x4_t v74 = (uint16x4_t)vdup_lane_s16(v71, 3);
        a13 = vbsl_s8(v70, *v19, (int8x8_t)vqsub_u16(vqadd_u16(v74, v73), vqadd_u16(vqsub_u16(v73, *(uint16x4_t *)v72.i8), vqsub_u16(v74, (uint16x4_t)v71))));
        *unint64_t v19 = a13;
      }
      uint32x4_t v75 = &v17[a6];
      v20 += a6;
      if ((unint64_t)v75 >= v18) {
        uint64_t v76 = -(uint64_t)a5;
      }
      else {
        uint64_t v76 = 0;
      }
      unint64_t v17 = &v75[v76];
      v19 += a6;
      --v62;
    }
    while (v62);
  }
  *size_t result = v17;
  *a3 = v18;
  *a2 = v19;
  *a4 = v20;
  return result;
}

uint16x4_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)10,_rgba16_t>(uint16x4_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, int32x4_t a9, double a10, double a11, double a12, int8x16_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a17 < 2) {
    goto LABEL_34;
  }
  uint64_t v22 = 2 * a6;
  uint64_t v23 = 16 * a6;
  uint32x4_t v24 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v25.i64[0] = 0x800000008000;
  v25.i64[1] = 0x800000008000;
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      uint16x8_t v41 = (int8x16_t *)&v21[v17];
      int64_t v42 = (int8x16_t *)v21;
      do
        int64_t v43 = v42++;
      while (v42 <= v41 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v43)) & 0x80) != 0);
      do
      {
        uint64_t v44 = v43;
        int64_t v43 = (int8x16_t *)((char *)v43 + 4);
      }
      while (v43 <= v41 && !v44->i32[0]);
      if (v44 < v41)
      {
        while (!v44->i8[0])
        {
          uint64_t v44 = (int8x16_t *)((char *)v44 + 1);
          if (v44 >= v41)
          {
            uint64_t v44 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v45 = (char *)v44 - v21;
      int64_t v46 = ((char *)v44 - v21) * a6;
      v18 += v46;
      v20 += v46;
      v21 += v46;
      v17 -= v45;
      goto LABEL_31;
    }
    if (v26 != 0xFFFF) {
      break;
    }
    uint64_t v27 = (int8x16_t *)&v21[v17];
    int8x16_t v28 = (int8x16_t *)v21;
    do
      uint32x4_t v29 = v28++;
    while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, (int8x16_t)a9)) & 0x80) != 0);
    do
    {
      int32x4_t v30 = v29;
      uint32x4_t v29 = (int8x16_t *)((char *)v29 + 4);
    }
    while (v29 <= v27 && v30->i32[0] == -1);
    if (v30 < v27)
    {
      while (v30->u8[0] == 255)
      {
        int32x4_t v30 = (int8x16_t *)((char *)v30 + 1);
        if (v30 >= v27)
        {
          int32x4_t v30 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v31 = 0;
    int64_t v32 = (char *)v30 - v21;
    unint64_t v33 = (char *)v30 - v21;
    do
    {
      int8x16_t v34 = *(int8x16_t *)&v18->i8[v31];
      int8x16_t v35 = *(int8x16_t *)&v20->i8[v31];
      a13 = vmvnq_s8(v35);
      uint16x8_t v36 = (uint16x8_t)vmvnq_s8(v34);
      uint32x4_t v37 = vqaddq_u32(vmull_lane_u16(*(uint16x4_t *)v34.i8, *(uint16x4_t *)a13.i8, 3), vmull_lane_u16(*(uint16x4_t *)v35.i8, *(uint16x4_t *)v36.i8, 3));
      uint32x4_t v38 = vqaddq_u32(vmull_high_laneq_u16((uint16x8_t)v34, (uint16x8_t)a13, 7), vmull_high_laneq_u16((uint16x8_t)v35, v36, 7));
      uint32x4_t v39 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v37, v24), v25);
      uint32x4_t v40 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v38, v24), v25);
      *(uint16x8_t *)&v20->i8[v31] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v39, v39, 0x10uLL), 0x10uLL), vsraq_n_u32(v40, v40, 0x10uLL), 0x10uLL);
      v21 += v22;
      v33 -= 2;
      v31 += v23;
    }
    while (v33 > 1);
    unint64_t v20 = (int8x8_t *)((char *)v20 + v31);
    unint64_t v18 = (uint16x4_t *)((char *)v18 + v31);
    unint64_t v17 = v17 - v32 + v33;
LABEL_31:
    if (v17 <= 1) {
      goto LABEL_34;
    }
  }
  uint64_t v47 = 0;
  while (1)
  {
    uint16x8_t v48 = *(uint16x8_t *)&v18->i8[v47];
    int8x16_t v49 = *(int8x16_t *)&v20->i8[v47];
    a13.i32[0] = v26;
    uint16x8_t v50 = (uint16x8_t)vqtbl1q_s8(a13, (int8x16_t)xmmword_1850CD890);
    uint32x4_t v51 = vmull_u16(*(uint16x4_t *)v48.i8, *(uint16x4_t *)v50.i8);
    uint32x4_t v52 = vmull_high_u16(v48, v50);
    uint32x4_t v53 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v51, v24), v25);
    *(uint16x4_t *)v53.i8 = vqshrn_n_u32(vsraq_n_u32(v53, v53, 0x10uLL), 0x10uLL);
    uint32x4_t v54 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v52, v24), v25);
    *(uint16x4_t *)v54.i8 = vqshrn_n_u32(vsraq_n_u32(v54, v54, 0x10uLL), 0x10uLL);
    uint16x8_t v55 = (uint16x8_t)vmvnq_s8(v49);
    a13 = (int8x16_t)vqaddq_u32(vmull_lane_u16(*(uint16x4_t *)v53.i8, *(uint16x4_t *)v55.i8, 3), vmull_u16(*(uint16x4_t *)v49.i8, (uint16x4_t)vmvn_s8((int8x8_t)vdup_lane_s16(*(int16x4_t *)v53.i8, 3))));
    uint32x4_t v56 = vqaddq_u32(vmull_laneq_u16(*(uint16x4_t *)v54.i8, v55, 7), vmull_u16((uint16x4_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL), (uint16x4_t)vmvn_s8((int8x8_t)vdup_lane_s16(*(int16x4_t *)v54.i8, 3))));
    uint32x4_t v57 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)a13, v24), v25);
    uint32x4_t v58 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v56, v24), v25);
    *(uint16x8_t *)&v20->i8[v47] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v57, v57, 0x10uLL), 0x10uLL), vsraq_n_u32(v58, v58, 0x10uLL), 0x10uLL);
    v21 += v22;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    v47 += v23;
    if ((unsigned __int16)(v26 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (uint16x4_t *)((char *)v18 + v47);
      unint64_t v20 = (int8x8_t *)((char *)v20 + v47);
      goto LABEL_31;
    }
  }
  unint64_t v18 = (uint16x4_t *)((char *)v18 + v23 + v47);
  unint64_t v20 = (int8x8_t *)((char *)v20 + v23 + v47);
LABEL_34:
  uint64_t v59 = v17 + a16;
  if (v59)
  {
    uint32x4_t v60 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v61.i64[0] = 0x800000008000;
    v61.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a9.i32[0] = *v21;
        uint32x4_t v62 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v18, (uint16x4_t)vdup_lane_s8(*(int8x8_t *)a9.i8, 0)), v60), v61);
        *(uint16x4_t *)v62.i8 = vqshrn_n_u32(vsraq_n_u32(v62, v62, 0x10uLL), 0x10uLL);
        a9 = vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_lane_u16(*(uint16x4_t *)v62.i8, (uint16x4_t)vmvn_s8(*v20), 3), vmull_lane_u16((uint16x4_t)*v20, (uint16x4_t)vmvn_s8(*(int8x8_t *)v62.i8), 3)), v60), v61);
        *(uint16x4_t *)a9.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a9, (uint32x4_t)a9, 0x10uLL), 0x10uLL);
        int8x8_t *v20 = *(int8x8_t *)a9.i8;
      }
      __int16 v63 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v63 >= v19) {
        uint64_t v64 = -(uint64_t)a5;
      }
      else {
        uint64_t v64 = 0;
      }
      unint64_t v18 = &v63[v64];
      v20 += a6;
      --v59;
    }
    while (v59);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

uint16x4_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)9,_rgba16_t>(uint16x4_t **result, int8x8_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, int32x4_t a9, double a10, double a11, double a12, uint32x4_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a17 < 2) {
    goto LABEL_34;
  }
  uint64_t v22 = 2 * a6;
  uint64_t v23 = 16 * a6;
  uint32x4_t v24 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v25.i64[0] = 0x800000008000;
  v25.i64[1] = 0x800000008000;
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      uint16x8_t v41 = (int8x16_t *)&v21[v17];
      int64_t v42 = (int8x16_t *)v21;
      do
        int64_t v43 = v42++;
      while (v42 <= v41 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v43)) & 0x80) != 0);
      do
      {
        uint64_t v44 = v43;
        int64_t v43 = (int8x16_t *)((char *)v43 + 4);
      }
      while (v43 <= v41 && !v44->i32[0]);
      if (v44 < v41)
      {
        while (!v44->i8[0])
        {
          uint64_t v44 = (int8x16_t *)((char *)v44 + 1);
          if (v44 >= v41)
          {
            uint64_t v44 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v45 = (char *)v44 - v21;
      int64_t v46 = ((char *)v44 - v21) * a6;
      v18 += v46;
      v20 += v46;
      v21 += v46;
      v17 -= v45;
      goto LABEL_31;
    }
    if (v26 != 0xFFFF) {
      break;
    }
    uint64_t v27 = (int8x16_t *)&v21[v17];
    int8x16_t v28 = (int8x16_t *)v21;
    do
      uint32x4_t v29 = v28++;
    while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, (int8x16_t)a9)) & 0x80) != 0);
    do
    {
      int32x4_t v30 = v29;
      uint32x4_t v29 = (int8x16_t *)((char *)v29 + 4);
    }
    while (v29 <= v27 && v30->i32[0] == -1);
    if (v30 < v27)
    {
      while (v30->u8[0] == 255)
      {
        int32x4_t v30 = (int8x16_t *)((char *)v30 + 1);
        if (v30 >= v27)
        {
          int32x4_t v30 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v31 = 0;
    int64_t v32 = (char *)v30 - v21;
    unint64_t v33 = (char *)v30 - v21;
    do
    {
      uint16x8_t v34 = *(uint16x8_t *)&v18->i8[v31];
      int8x16_t v35 = *(int8x16_t *)&v20->i8[v31];
      uint16x8_t v36 = (uint16x8_t)vmvnq_s8(v35);
      uint32x4_t v37 = vqaddq_u32(vmull_lane_u16(*(uint16x4_t *)v34.i8, *(uint16x4_t *)v36.i8, 3), vmull_lane_u16(*(uint16x4_t *)v35.i8, *(uint16x4_t *)v34.i8, 3));
      a13 = vmull_high_laneq_u16(v34, v36, 7);
      uint32x4_t v38 = vqaddq_u32(a13, vmull_high_laneq_u16((uint16x8_t)v35, v34, 7));
      uint32x4_t v39 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v37, v24), v25);
      uint32x4_t v40 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v38, v24), v25);
      *(uint16x8_t *)&v20->i8[v31] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v39, v39, 0x10uLL), 0x10uLL), vsraq_n_u32(v40, v40, 0x10uLL), 0x10uLL);
      v21 += v22;
      v33 -= 2;
      v31 += v23;
    }
    while (v33 > 1);
    unint64_t v20 = (int8x8_t *)((char *)v20 + v31);
    unint64_t v18 = (uint16x4_t *)((char *)v18 + v31);
    unint64_t v17 = v17 - v32 + v33;
LABEL_31:
    if (v17 <= 1) {
      goto LABEL_34;
    }
  }
  uint64_t v47 = 0;
  while (1)
  {
    uint16x8_t v48 = *(uint16x8_t *)&v18->i8[v47];
    int8x16_t v49 = *(int8x16_t *)&v20->i8[v47];
    a13.i32[0] = v26;
    int8x16_t v50 = vqtbl1q_s8((int8x16_t)a13, (int8x16_t)xmmword_1850CD890);
    uint32x4_t v51 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v48.i8, *(uint16x4_t *)v50.i8), v24), v25);
    *(uint16x4_t *)v51.i8 = vqshrn_n_u32(vsraq_n_u32(v51, v51, 0x10uLL), 0x10uLL);
    uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v48, (uint16x8_t)v50), v24), v25);
    *(uint16x4_t *)v52.i8 = vqshrn_n_u32(vsraq_n_u32(v52, v52, 0x10uLL), 0x10uLL);
    uint16x8_t v53 = (uint16x8_t)vmvnq_s8(v49);
    uint16x8_t v54 = (uint16x8_t)vmvnq_s8(v50);
    uint32x4_t v55 = vmull_u16(*(uint16x4_t *)v49.i8, *(uint16x4_t *)v54.i8);
    a13 = vqaddq_u32(vmull_laneq_u16(*(uint16x4_t *)v52.i8, v53, 7), vmull_high_u16((uint16x8_t)v49, v54));
    uint32x4_t v56 = vmull_high_lane_u16((uint16x8_t)v49, *(uint16x4_t *)v52.i8, 3);
    uint32x4_t v57 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vmull_lane_u16(*(uint16x4_t *)v51.i8, *(uint16x4_t *)v53.i8, 3), v55), vmull_lane_u16(*(uint16x4_t *)v49.i8, *(uint16x4_t *)v51.i8, 3)), v24), v25);
    uint32x4_t v58 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(a13, v56), v24), v25);
    *(uint16x8_t *)&v20->i8[v47] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v57, v57, 0x10uLL), 0x10uLL), vsraq_n_u32(v58, v58, 0x10uLL), 0x10uLL);
    v21 += v22;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    v47 += v23;
    if ((unsigned __int16)(v26 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (uint16x4_t *)((char *)v18 + v47);
      unint64_t v20 = (int8x8_t *)((char *)v20 + v47);
      goto LABEL_31;
    }
  }
  unint64_t v18 = (uint16x4_t *)((char *)v18 + v23 + v47);
  unint64_t v20 = (int8x8_t *)((char *)v20 + v23 + v47);
LABEL_34:
  uint64_t v59 = v17 + a16;
  if (v59)
  {
    uint32x4_t v60 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v61.i64[0] = 0x800000008000;
    v61.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a9.i32[0] = *v21;
        int8x8_t v62 = vdup_lane_s8(*(int8x8_t *)a9.i8, 0);
        uint32x4_t v63 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v18, (uint16x4_t)v62), v60), v61);
        *(uint16x4_t *)v63.i8 = vqshrn_n_u32(vsraq_n_u32(v63, v63, 0x10uLL), 0x10uLL);
        a9 = vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vmull_lane_u16(*(uint16x4_t *)v63.i8, (uint16x4_t)vmvn_s8(*v20), 3), vmull_u16((uint16x4_t)*v20, (uint16x4_t)vmvn_s8(v62))), vmull_lane_u16((uint16x4_t)*v20, *(uint16x4_t *)v63.i8, 3)), v60), v61);
        *(uint16x4_t *)a9.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a9, (uint32x4_t)a9, 0x10uLL), 0x10uLL);
        int8x8_t *v20 = *(int8x8_t *)a9.i8;
      }
      uint64_t v64 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v64 >= v19) {
        uint64_t v65 = -(uint64_t)a5;
      }
      else {
        uint64_t v65 = 0;
      }
      unint64_t v18 = &v64[v65];
      v20 += a6;
      --v59;
    }
    while (v59);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

uint16x4_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)8,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, int32x4_t a9, double a10, double a11, double a12, uint16x8_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a17 < 2) {
    goto LABEL_34;
  }
  uint64_t v22 = 2 * a6;
  uint64_t v23 = 16 * a6;
  uint32x4_t v24 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v25.i64[0] = 0x800000008000;
  v25.i64[1] = 0x800000008000;
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      uint32x4_t v38 = (int8x16_t *)&v21[v17];
      uint32x4_t v39 = (int8x16_t *)v21;
      do
        uint32x4_t v40 = v39++;
      while (v39 <= v38 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v40)) & 0x80) != 0);
      do
      {
        uint16x8_t v41 = v40;
        uint32x4_t v40 = (int8x16_t *)((char *)v40 + 4);
      }
      while (v40 <= v38 && !v41->i32[0]);
      if (v41 < v38)
      {
        while (!v41->i8[0])
        {
          uint16x8_t v41 = (int8x16_t *)((char *)v41 + 1);
          if (v41 >= v38)
          {
            uint16x8_t v41 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v42 = (char *)v41 - v21;
      int64_t v43 = ((char *)v41 - v21) * a6;
      v18 += v43;
      v20 += v43;
      v21 += v43;
      v17 -= v42;
      goto LABEL_31;
    }
    if (v26 != 0xFFFF) {
      break;
    }
    uint64_t v27 = (int8x16_t *)&v21[v17];
    int8x16_t v28 = (int8x16_t *)v21;
    do
      uint32x4_t v29 = v28++;
    while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, (int8x16_t)a9)) & 0x80) != 0);
    do
    {
      int32x4_t v30 = v29;
      uint32x4_t v29 = (int8x16_t *)((char *)v29 + 4);
    }
    while (v29 <= v27 && v30->i32[0] == -1);
    if (v30 < v27)
    {
      while (v30->u8[0] == 255)
      {
        int32x4_t v30 = (int8x16_t *)((char *)v30 + 1);
        if (v30 >= v27)
        {
          int32x4_t v30 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v31 = 0;
    int64_t v32 = (char *)v30 - v21;
    unint64_t v33 = (char *)v30 - v21;
    do
    {
      uint16x8_t v34 = *(uint16x8_t *)&v18->i8[v31];
      uint16x8_t v35 = *(uint16x8_t *)&v20->i8[v31];
      uint32x4_t v36 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v35.i8, *(uint16x4_t *)v34.i8, 3), v24), v25);
      uint32x4_t v37 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v35, v34, 7), v24), v25);
      a13 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v36, v36, 0x10uLL), 0x10uLL), vsraq_n_u32(v37, v37, 0x10uLL), 0x10uLL);
      *(uint16x8_t *)&v20->i8[v31] = vqsubq_u16(v35, a13);
      v21 += v22;
      v33 -= 2;
      v31 += v23;
    }
    while (v33 > 1);
    unint64_t v20 = (uint16x4_t *)((char *)v20 + v31);
    unint64_t v18 = (uint16x4_t *)((char *)v18 + v31);
    unint64_t v17 = v17 - v32 + v33;
LABEL_31:
    if (v17 <= 1) {
      goto LABEL_34;
    }
  }
  uint64_t v44 = 0;
  while (1)
  {
    uint16x8_t v45 = *(uint16x8_t *)&v18->i8[v44];
    int8x16_t v46 = *(int8x16_t *)&v20->i8[v44];
    a13.i32[0] = v26;
    uint16x8_t v47 = (uint16x8_t)vqtbl1q_s8((int8x16_t)a13, (int8x16_t)xmmword_1850CD890);
    uint32x4_t v48 = vmull_lane_u16(*(uint16x4_t *)v47.i8, *(uint16x4_t *)v45.i8, 3);
    uint32x4_t v49 = vmull_high_laneq_u16(v47, v45, 7);
    uint32x4_t v50 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v48, v24), v25);
    uint32x4_t v51 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v49, v24), v25);
    uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v46.i8, vqshrn_n_u32(vsraq_n_u32(v50, v50, 0x10uLL), 0x10uLL)), v24), v25);
    uint32x4_t v53 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)*(_OWORD *)&vextq_s8(v46, v46, 8uLL), vqshrn_n_u32(vsraq_n_u32(v51, v51, 0x10uLL), 0x10uLL)), v24), v25);
    a13 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v52, v52, 0x10uLL), 0x10uLL), vsraq_n_u32(v53, v53, 0x10uLL), 0x10uLL);
    *(uint16x8_t *)&v20->i8[v44] = vqsubq_u16((uint16x8_t)v46, a13);
    v21 += v22;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    v44 += v23;
    if ((unsigned __int16)(v26 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (uint16x4_t *)((char *)v18 + v44);
      unint64_t v20 = (uint16x4_t *)((char *)v20 + v44);
      goto LABEL_31;
    }
  }
  unint64_t v18 = (uint16x4_t *)((char *)v18 + v23 + v44);
  unint64_t v20 = (uint16x4_t *)((char *)v20 + v23 + v44);
LABEL_34:
  uint64_t v54 = v17 + a16;
  if (v54)
  {
    uint32x4_t v55 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v56.i64[0] = 0x800000008000;
    v56.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a9.i32[0] = *v21;
        uint32x4_t v57 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16((uint16x4_t)vdup_lane_s8(*(int8x8_t *)a9.i8, 0), *v18, 3), v55), v56);
        a9 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v20, vqshrn_n_u32(vsraq_n_u32(v57, v57, 0x10uLL), 0x10uLL)), v55), v56);
        *(uint16x4_t *)a9.i8 = vqsub_u16(*v20, vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a9, (uint32x4_t)a9, 0x10uLL), 0x10uLL));
        uint16x4_t *v20 = *(uint16x4_t *)a9.i8;
      }
      uint32x4_t v58 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v58 >= v19) {
        uint64_t v59 = -(uint64_t)a5;
      }
      else {
        uint64_t v59 = 0;
      }
      unint64_t v18 = &v58[v59];
      v20 += a6;
      --v54;
    }
    while (v54);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

uint16x4_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)7,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, int32x4_t a9, double a10, double a11, double a12, uint16x8_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  unsigned int v21 = *a4;
  if (a17 < 2) {
    goto LABEL_34;
  }
  uint64_t v22 = 2 * a6;
  uint64_t v23 = 16 * a6;
  uint32x4_t v24 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v25.i64[0] = 0x800000008000;
  v25.i64[1] = 0x800000008000;
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      uint32x4_t v39 = (int8x16_t *)&v21[v17];
      uint32x4_t v40 = (int8x16_t *)v21;
      do
        uint16x8_t v41 = v40++;
      while (v40 <= v39 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v41)) & 0x80) != 0);
      do
      {
        int64_t v42 = v41;
        uint16x8_t v41 = (int8x16_t *)((char *)v41 + 4);
      }
      while (v41 <= v39 && !v42->i32[0]);
      if (v42 < v39)
      {
        while (!v42->i8[0])
        {
          int64_t v42 = (int8x16_t *)((char *)v42 + 1);
          if (v42 >= v39)
          {
            int64_t v42 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v43 = (char *)v42 - v21;
      int64_t v44 = ((char *)v42 - v21) * a6;
      v18 += v44;
      v20 += v44;
      v21 += v44;
      v17 -= v43;
      goto LABEL_31;
    }
    if (v26 != 0xFFFF) {
      break;
    }
    uint64_t v27 = (int8x16_t *)&v21[v17];
    int8x16_t v28 = (int8x16_t *)v21;
    do
      uint32x4_t v29 = v28++;
    while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, (int8x16_t)a9)) & 0x80) != 0);
    do
    {
      int32x4_t v30 = v29;
      uint32x4_t v29 = (int8x16_t *)((char *)v29 + 4);
    }
    while (v29 <= v27 && v30->i32[0] == -1);
    if (v30 < v27)
    {
      while (v30->u8[0] == 255)
      {
        int32x4_t v30 = (int8x16_t *)((char *)v30 + 1);
        if (v30 >= v27)
        {
          int32x4_t v30 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v31 = 0;
    int64_t v32 = (char *)v30 - v21;
    unint64_t v33 = (char *)v30 - v21;
    do
    {
      uint16x8_t v34 = *(uint16x8_t *)&v18->i8[v31];
      uint16x8_t v35 = *(uint16x8_t *)&v20->i8[v31];
      a13 = (uint16x8_t)vmull_lane_u16(*(uint16x4_t *)v35.i8, *(uint16x4_t *)v34.i8, 3);
      uint32x4_t v36 = vmull_high_laneq_u16(v35, v34, 7);
      uint32x4_t v37 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)a13, v24), v25);
      uint32x4_t v38 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v36, v24), v25);
      *(uint16x8_t *)&v20->i8[v31] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v37, v37, 0x10uLL), 0x10uLL), vsraq_n_u32(v38, v38, 0x10uLL), 0x10uLL);
      v21 += v22;
      v33 -= 2;
      v31 += v23;
    }
    while (v33 > 1);
    unint64_t v20 = (uint16x4_t *)((char *)v20 + v31);
    unint64_t v18 = (uint16x4_t *)((char *)v18 + v31);
    unint64_t v17 = v17 - v32 + v33;
LABEL_31:
    if (v17 <= 1) {
      goto LABEL_34;
    }
  }
  uint64_t v45 = 0;
  while (1)
  {
    uint16x8_t v46 = *(uint16x8_t *)&v18->i8[v45];
    uint16x8_t v47 = *(uint16x8_t *)&v20->i8[v45];
    a13.i32[0] = v26;
    uint16x8_t v48 = (uint16x8_t)vqtbl1q_s8((int8x16_t)a13, (int8x16_t)xmmword_1850CD890);
    uint32x4_t v49 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v48.i8, *(uint16x4_t *)v46.i8, 3), v24), v25);
    uint32x4_t v50 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v48, v46, 7), v24), v25);
    uint16x8_t v51 = vqsubq_u16(v48, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v49, v49, 0x10uLL), 0x10uLL), vsraq_n_u32(v50, v50, 0x10uLL), 0x10uLL));
    uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v47.i8, *(uint16x4_t *)v51.i8), v24), v25);
    uint32x4_t v53 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v47, v51), v24), v25);
    a13 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v52, v52, 0x10uLL), 0x10uLL), vsraq_n_u32(v53, v53, 0x10uLL), 0x10uLL);
    *(uint16x8_t *)&v20->i8[v45] = vqsubq_u16(v47, a13);
    v21 += v22;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    v45 += v23;
    if ((unsigned __int16)(v26 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (uint16x4_t *)((char *)v18 + v45);
      unint64_t v20 = (uint16x4_t *)((char *)v20 + v45);
      goto LABEL_31;
    }
  }
  unint64_t v18 = (uint16x4_t *)((char *)v18 + v23 + v45);
  unint64_t v20 = (uint16x4_t *)((char *)v20 + v23 + v45);
LABEL_34:
  uint64_t v54 = v17 + a16;
  if (v54)
  {
    uint32x4_t v55 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v56.i64[0] = 0x800000008000;
    v56.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a9.i32[0] = *v21;
        uint16x4_t v57 = (uint16x4_t)vdup_lane_s8(*(int8x8_t *)a9.i8, 0);
        uint32x4_t v58 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(v57, *v18, 3), v55), v56);
        a9 = vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v20, vqsub_u16(v57, vqshrn_n_u32(vsraq_n_u32(v58, v58, 0x10uLL), 0x10uLL))), v55), v56);
        *(uint16x4_t *)a9.i8 = vqsub_u16(*v20, vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a9, (uint32x4_t)a9, 0x10uLL), 0x10uLL));
        uint16x4_t *v20 = *(uint16x4_t *)a9.i8;
      }
      uint64_t v59 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v59 >= v19) {
        uint64_t v60 = -(uint64_t)a5;
      }
      else {
        uint64_t v60 = 0;
      }
      unint64_t v18 = &v59[v60];
      v20 += a6;
      --v54;
    }
    while (v54);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)6,_rgba16_t>(int8x8_t **result, int16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, double a8, double a9, double a10, int32x4_t a11, uint64_t a12, uint64_t a13, unint64_t a14)
{
  unint64_t v15 = a14;
  unint64_t v16 = *result;
  unint64_t v17 = *a3;
  unint64_t v18 = *a2;
  unint64_t v19 = *a4;
  if (a14 < 2) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v20 = 0;
  }
  else {
    unsigned int v20 = -1;
  }
  v21.i64[0] = 0xFFFF000000000000;
  v21.i64[1] = 0xFFFF000000000000;
  int8x16_t v22 = vandq_s8((int8x16_t)vdupq_n_s16(v20), v21);
  uint64_t v23 = 2 * a6;
  uint64_t v24 = 16 * a6;
  uint32x4_t v25 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a11.i64[0] = 0x800000008000;
  a11.i64[1] = 0x800000008000;
  v26.i64[0] = -1;
  v26.i64[1] = -1;
  while (1)
  {
    __int32 v27 = *(unsigned __int16 *)v19;
    if (!*(_WORD *)v19)
    {
      int64_t v44 = (int8x16_t *)&v19[v15];
      uint64_t v45 = (int8x16_t *)v19;
      do
        uint16x8_t v46 = v45++;
      while (v45 <= v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
      do
      {
        uint16x8_t v47 = v46;
        uint16x8_t v46 = (int8x16_t *)((char *)v46 + 4);
      }
      while (v46 <= v44 && !v47->i32[0]);
      if (v47 < v44)
      {
        while (!v47->i8[0])
        {
          uint16x8_t v47 = (int8x16_t *)((char *)v47 + 1);
          if (v47 >= v44)
          {
            uint16x8_t v47 = (int8x16_t *)&v19[v15];
            break;
          }
        }
      }
      int64_t v48 = (char *)v47 - v19;
      int64_t v49 = ((char *)v47 - v19) * a6;
      v16 += v49;
      v18 += v49;
      v19 += v49;
      v15 -= v48;
      goto LABEL_34;
    }
    if (v27 != 0xFFFF) {
      break;
    }
    int8x16_t v28 = (int8x16_t *)&v19[v15];
    uint32x4_t v29 = (int8x16_t *)v19;
    do
      int32x4_t v30 = v29++;
    while (v29 <= v28 && (vminvq_u8((uint8x16_t)vceqq_s8(*v30, v26)) & 0x80) != 0);
    do
    {
      uint64_t v31 = v30;
      int32x4_t v30 = (int8x16_t *)((char *)v30 + 4);
    }
    while (v30 <= v28 && v31->i32[0] == -1);
    if (v31 < v28)
    {
      while (v31->u8[0] == 255)
      {
        uint64_t v31 = (int8x16_t *)((char *)v31 + 1);
        if (v31 >= v28)
        {
          uint64_t v31 = (int8x16_t *)&v19[v15];
          break;
        }
      }
    }
    uint64_t v32 = 0;
    int64_t v33 = (char *)v31 - v19;
    unint64_t v34 = (char *)v31 - v19;
    do
    {
      int8x16_t v35 = *(int8x16_t *)&v18->i8[v32];
      uint16x8_t v36 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v16->i8[v32], v22);
      int16x8_t v37 = (int16x8_t)vqtbl1q_s8(v35, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v38 = (uint16x8_t)vbicq_s8(v35, (int8x16_t)vceqzq_s16(v37));
      uint16x8_t v39 = (uint16x8_t)vmvnq_s8((int8x16_t)v37);
      uint32x4_t v40 = vmull_u16(*(uint16x4_t *)v36.i8, *(uint16x4_t *)v39.i8);
      uint32x4_t v41 = vmull_high_u16(v36, v39);
      uint32x4_t v42 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v40, v25), a11);
      uint32x4_t v43 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v41, v25), a11);
      int8x16_t v14 = (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v42, v42, 0x10uLL), 0x10uLL), vsraq_n_u32(v43, v43, 0x10uLL), 0x10uLL);
      *(uint16x8_t *)&v18->i8[v32] = vqaddq_u16(v38, (uint16x8_t)v14);
      v19 += v23;
      v34 -= 2;
      v32 += v24;
    }
    while (v34 > 1);
    unint64_t v18 = (int16x4_t *)((char *)v18 + v32);
    unint64_t v16 = (int8x8_t *)((char *)v16 + v32);
    unint64_t v15 = v15 - v33 + v34;
LABEL_34:
    if (v15 <= 1) {
      goto LABEL_37;
    }
  }
  uint64_t v50 = 0;
  while (1)
  {
    int8x16_t v51 = *(int8x16_t *)&v18->i8[v50];
    v14.i32[0] = v27;
    int16x8_t v52 = (int16x8_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v53 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v16->i8[v50], v22);
    uint32x4_t v54 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v53.i8, *(uint16x4_t *)v52.i8), v25), a11);
    uint32x4_t v55 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v53, (uint16x8_t)v52), v25), a11);
    int16x8_t v56 = (int16x8_t)vqtbl1q_s8(v51, (int8x16_t)xmmword_1850CD880);
    uint16x8_t v57 = (uint16x8_t)vbicq_s8(v51, (int8x16_t)vceqzq_s16(v56));
    int8x16_t v58 = vmvnq_s8((int8x16_t)v56);
    uint32x4_t v59 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(vqshrn_n_u32(vsraq_n_u32(v54, v54, 0x10uLL), 0x10uLL), *(uint16x4_t *)v58.i8), v25), a11);
    uint32x4_t v60 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(vqshrn_n_u32(vsraq_n_u32(v55, v55, 0x10uLL), 0x10uLL), (uint16x4_t)*(_OWORD *)&vextq_s8(v58, v58, 8uLL)), v25), a11);
    int8x16_t v14 = (int8x16_t)vceqzq_s16(v52);
    *(int8x16_t *)&v18->i8[v50] = vbslq_s8(v14, v51, (int8x16_t)vqaddq_u16(v57, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v59, v59, 0x10uLL), 0x10uLL), vsraq_n_u32(v60, v60, 0x10uLL), 0x10uLL)));
    v19 += v23;
    v15 -= 2;
    if (v15 < 2) {
      break;
    }
    __int32 v27 = *(unsigned __int16 *)v19;
    v50 += v24;
    if ((unsigned __int16)(v27 - 1) >= 0xFFFEu)
    {
      unint64_t v16 = (int8x8_t *)((char *)v16 + v50);
      unint64_t v18 = (int16x4_t *)((char *)v18 + v50);
      goto LABEL_34;
    }
  }
  unint64_t v16 = (int8x8_t *)((char *)v16 + v24 + v50);
  unint64_t v18 = (int16x4_t *)((char *)v18 + v24 + v50);
LABEL_37:
  uint64_t v61 = v15 + a13;
  if (v61)
  {
    int8x8_t v62 = 0;
    if (a7) {
      __int16 v63 = 0;
    }
    else {
      __int16 v63 = -1;
    }
    v62.i16[3] = v63;
    uint32x4_t v64 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v65.i64[0] = 0x800000008000;
    v65.i64[1] = 0x800000008000;
    do
    {
      if (*v19)
      {
        a11.i32[0] = *v19;
        int16x4_t v66 = (int16x4_t)vdup_lane_s8(*(int8x8_t *)a11.i8, 0);
        uint32x4_t v67 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v16, v62), (uint16x4_t)v66), v64), v65);
        int16x4_t v68 = vdup_lane_s16(*v18, 3);
        uint32x4_t v69 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(vqshrn_n_u32(vsraq_n_u32(v67, v67, 0x10uLL), 0x10uLL), (uint16x4_t)vmvn_s8((int8x8_t)v68)), v64), v65);
        *(int8x8_t *)a11.i8 = vbsl_s8((int8x8_t)vceqz_s16(v66), (int8x8_t)*v18, (int8x8_t)vqadd_u16((uint16x4_t)vbic_s8((int8x8_t)*v18, (int8x8_t)vceqz_s16(v68)), vqshrn_n_u32(vsraq_n_u32(v69, v69, 0x10uLL), 0x10uLL)));
        int16x4_t *v18 = *(int16x4_t *)a11.i8;
      }
      int8x8_t v70 = &v16[a6];
      v19 += a6;
      if ((unint64_t)v70 >= v17) {
        uint64_t v71 = -(uint64_t)a5;
      }
      else {
        uint64_t v71 = 0;
      }
      unint64_t v16 = &v70[v71];
      v18 += a6;
      --v61;
    }
    while (v61);
  }
  *size_t result = v16;
  *a3 = v17;
  *a2 = v18;
  *a4 = v19;
  return result;
}

uint16x4_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)5,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, int32x4_t a9, double a10, double a11, double a12, uint16x8_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unsigned int v20 = *a2;
  int8x16_t v21 = *a4;
  if (a17 < 2) {
    goto LABEL_34;
  }
  uint64_t v22 = 2 * a6;
  uint64_t v23 = 16 * a6;
  uint32x4_t v24 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v25.i64[0] = 0x800000008000;
  v25.i64[1] = 0x800000008000;
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      uint32x4_t v42 = (int8x16_t *)&v21[v17];
      uint32x4_t v43 = (int8x16_t *)v21;
      do
        int64_t v44 = v43++;
      while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v44)) & 0x80) != 0);
      do
      {
        uint64_t v45 = v44;
        int64_t v44 = (int8x16_t *)((char *)v44 + 4);
      }
      while (v44 <= v42 && !v45->i32[0]);
      if (v45 < v42)
      {
        while (!v45->i8[0])
        {
          uint64_t v45 = (int8x16_t *)((char *)v45 + 1);
          if (v45 >= v42)
          {
            uint64_t v45 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v46 = (char *)v45 - v21;
      int64_t v47 = ((char *)v45 - v21) * a6;
      v18 += v47;
      v20 += v47;
      v21 += v47;
      v17 -= v46;
      goto LABEL_31;
    }
    if (v26 != 0xFFFF) {
      break;
    }
    __int32 v27 = (int8x16_t *)&v21[v17];
    int8x16_t v28 = (int8x16_t *)v21;
    do
      uint32x4_t v29 = v28++;
    while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, (int8x16_t)a9)) & 0x80) != 0);
    do
    {
      int32x4_t v30 = v29;
      uint32x4_t v29 = (int8x16_t *)((char *)v29 + 4);
    }
    while (v29 <= v27 && v30->i32[0] == -1);
    if (v30 < v27)
    {
      while (v30->u8[0] == 255)
      {
        int32x4_t v30 = (int8x16_t *)((char *)v30 + 1);
        if (v30 >= v27)
        {
          int32x4_t v30 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v31 = 0;
    int64_t v32 = (char *)v30 - v21;
    unint64_t v33 = (char *)v30 - v21;
    do
    {
      uint16x8_t v34 = *(uint16x8_t *)&v18->i8[v31];
      uint16x8_t v35 = *(uint16x8_t *)&v20->i8[v31];
      uint32x4_t v36 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v35.i8, *(uint16x4_t *)v34.i8, 3), v24), v25);
      uint32x4_t v37 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v35, v34, 7), v24), v25);
      a13 = vqsubq_u16(v35, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v36, v36, 0x10uLL), 0x10uLL), vsraq_n_u32(v37, v37, 0x10uLL), 0x10uLL));
      uint32x4_t v38 = vmull_lane_u16(*(uint16x4_t *)v34.i8, *(uint16x4_t *)v35.i8, 3);
      uint32x4_t v39 = vmull_high_laneq_u16(v34, v35, 7);
      uint32x4_t v40 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v38, v24), v25);
      uint32x4_t v41 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v39, v24), v25);
      *(uint16x8_t *)&v20->i8[v31] = vqaddq_u16(a13, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v40, v40, 0x10uLL), 0x10uLL), vsraq_n_u32(v41, v41, 0x10uLL), 0x10uLL));
      v21 += v22;
      v33 -= 2;
      v31 += v23;
    }
    while (v33 > 1);
    unsigned int v20 = (uint16x4_t *)((char *)v20 + v31);
    unint64_t v18 = (uint16x4_t *)((char *)v18 + v31);
    unint64_t v17 = v17 - v32 + v33;
LABEL_31:
    if (v17 <= 1) {
      goto LABEL_34;
    }
  }
  uint64_t v48 = 0;
  while (1)
  {
    uint16x8_t v49 = *(uint16x8_t *)&v18->i8[v48];
    uint16x8_t v50 = *(uint16x8_t *)&v20->i8[v48];
    a13.i32[0] = v26;
    uint16x8_t v51 = (uint16x8_t)vqtbl1q_s8((int8x16_t)a13, (int8x16_t)xmmword_1850CD890);
    uint32x4_t v52 = vmull_u16(*(uint16x4_t *)v49.i8, *(uint16x4_t *)v51.i8);
    uint32x4_t v53 = vmull_high_u16(v49, v51);
    uint32x4_t v54 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v52, v24), v25);
    *(uint16x4_t *)v54.i8 = vqshrn_n_u32(vsraq_n_u32(v54, v54, 0x10uLL), 0x10uLL);
    uint32x4_t v55 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v53, v24), v25);
    *(uint16x4_t *)v55.i8 = vqshrn_n_u32(vsraq_n_u32(v55, v55, 0x10uLL), 0x10uLL);
    uint32x4_t v56 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v50.i8, *(uint16x4_t *)v54.i8, 3), v24), v25);
    uint32x4_t v57 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_lane_u16(v50, *(uint16x4_t *)v55.i8, 3), v24), v25);
    uint16x8_t v58 = vqsubq_u16(v50, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v56, v56, 0x10uLL), 0x10uLL), vsraq_n_u32(v57, v57, 0x10uLL), 0x10uLL));
    a13 = (uint16x8_t)vmull_lane_u16(*(uint16x4_t *)v54.i8, *(uint16x4_t *)v50.i8, 3);
    uint32x4_t v59 = vmull_laneq_u16(*(uint16x4_t *)v55.i8, v50, 7);
    uint32x4_t v60 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)a13, v24), v25);
    uint32x4_t v61 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v59, v24), v25);
    *(uint16x8_t *)&v20->i8[v48] = vqaddq_u16(v58, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v60, v60, 0x10uLL), 0x10uLL), vsraq_n_u32(v61, v61, 0x10uLL), 0x10uLL));
    v21 += v22;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    v48 += v23;
    if ((unsigned __int16)(v26 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (uint16x4_t *)((char *)v18 + v48);
      unsigned int v20 = (uint16x4_t *)((char *)v20 + v48);
      goto LABEL_31;
    }
  }
  unint64_t v18 = (uint16x4_t *)((char *)v18 + v23 + v48);
  unsigned int v20 = (uint16x4_t *)((char *)v20 + v23 + v48);
LABEL_34:
  uint64_t v62 = v17 + a16;
  if (v62)
  {
    uint32x4_t v63 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v64.i64[0] = 0x800000008000;
    v64.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a9.i32[0] = *v21;
        uint32x4_t v65 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v18, (uint16x4_t)vdup_lane_s8(*(int8x8_t *)a9.i8, 0)), v63), v64);
        *(uint16x4_t *)v65.i8 = vqshrn_n_u32(vsraq_n_u32(v65, v65, 0x10uLL), 0x10uLL);
        uint32x4_t v66 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v20, *(uint16x4_t *)v65.i8, 3), v63), v64);
        a9 = vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v65.i8, *v20, 3), v63), v64);
        *(uint16x4_t *)a9.i8 = vqadd_u16(vqsub_u16(*v20, vqshrn_n_u32(vsraq_n_u32(v66, v66, 0x10uLL), 0x10uLL)), vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a9, (uint32x4_t)a9, 0x10uLL), 0x10uLL));
        uint16x4_t *v20 = *(uint16x4_t *)a9.i8;
      }
      uint32x4_t v67 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v67 >= v19) {
        uint64_t v68 = -(uint64_t)a5;
      }
      else {
        uint64_t v68 = 0;
      }
      unint64_t v18 = &v67[v68];
      v20 += a6;
      --v62;
    }
    while (v62);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)4,_rgba16_t>(int8x8_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, double a8, double a9, double a10, int32x4_t a11, double a12, double a13, double a14, int8x16_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v18 = a18;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  int8x16_t v21 = *a2;
  uint64_t v22 = *a4;
  if (a18 < 2) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFFFF000000000000;
  v24.i64[1] = 0xFFFF000000000000;
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v23), v24);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v29.i64[0] = 0x800000008000;
  v29.i64[1] = 0x800000008000;
  a11.i64[0] = -1;
  a11.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v30 = *(unsigned __int16 *)v22;
    if (!*(_WORD *)v22)
    {
      uint32x4_t v42 = (int8x16_t *)&v22[v18];
      uint32x4_t v43 = (int8x16_t *)v22;
      do
        int64_t v44 = v43++;
      while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v44)) & 0x80) != 0);
      do
      {
        uint64_t v45 = v44;
        int64_t v44 = (int8x16_t *)((char *)v44 + 4);
      }
      while (v44 <= v42 && !v45->i32[0]);
      if (v45 < v42)
      {
        while (!v45->i8[0])
        {
          uint64_t v45 = (int8x16_t *)((char *)v45 + 1);
          if (v45 >= v42)
          {
            uint64_t v45 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      int64_t v46 = (char *)v45 - v22;
      int64_t v47 = ((char *)v45 - v22) * a6;
      v19 += v47;
      v21 += v47;
      v22 += v47;
      v18 -= v46;
      goto LABEL_34;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    uint64_t v31 = (int8x16_t *)&v22[v18];
    int64_t v32 = (int8x16_t *)v22;
    do
      unint64_t v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, (int8x16_t)a11)) & 0x80) != 0);
    do
    {
      uint16x8_t v34 = v33;
      unint64_t v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint16x8_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint16x8_t v34 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v22;
    unint64_t v37 = (char *)v34 - v22;
    do
    {
      uint16x8_t v38 = *(uint16x8_t *)&v21->i8[v35];
      uint16x8_t v39 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      uint32x4_t v40 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)v38.i8, 3), v28), v29);
      uint32x4_t v41 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v39, v38, 7), v28), v29);
      a15 = (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v40, v40, 0x10uLL), 0x10uLL), vsraq_n_u32(v41, v41, 0x10uLL), 0x10uLL);
      *(uint16x8_t *)&v21->i8[v35] = vqsubq_u16(v39, (uint16x8_t)a15);
      v22 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    int8x16_t v21 = (uint16x4_t *)((char *)v21 + v35);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    unint64_t v18 = v18 - v36 + v37;
LABEL_34:
    if (v18 <= 1) {
      goto LABEL_37;
    }
  }
  uint64_t v48 = 0;
  while (1)
  {
    int8x16_t v49 = *(int8x16_t *)&v21->i8[v48];
    a15.i32[0] = v30;
    int8x16_t v50 = vqtbl1q_s8(a15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v51 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v19->i8[v48], v25);
    uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v51.i8, *(uint16x4_t *)v50.i8), v28), v29);
    uint32x4_t v53 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v51, (uint16x8_t)v50), v28), v29);
    a15 = vmvnq_s8(v50);
    uint16x8_t v54 = (uint16x8_t)vmvnq_s8(v49);
    uint32x4_t v55 = vqaddq_u32(vmull_high_u16((uint16x8_t)v49, (uint16x8_t)a15), vmull_laneq_u16(vqshrn_n_u32(vsraq_n_u32(v53, v53, 0x10uLL), 0x10uLL), v54, 7));
    uint32x4_t v56 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_u16(*(uint16x4_t *)v49.i8, *(uint16x4_t *)a15.i8), vmull_lane_u16(vqshrn_n_u32(vsraq_n_u32(v52, v52, 0x10uLL), 0x10uLL), *(uint16x4_t *)v54.i8, 3)), v28), v29);
    uint32x4_t v57 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v55, v28), v29);
    *(uint16x8_t *)&v21->i8[v48] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v56, v56, 0x10uLL), 0x10uLL), vsraq_n_u32(v57, v57, 0x10uLL), 0x10uLL);
    v22 += v26;
    v18 -= 2;
    if (v18 < 2) {
      break;
    }
    unsigned __int32 v30 = *(unsigned __int16 *)v22;
    v48 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      unint64_t v19 = (int8x8_t *)((char *)v19 + v48);
      int8x16_t v21 = (uint16x4_t *)((char *)v21 + v48);
      goto LABEL_34;
    }
  }
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v48);
  int8x16_t v21 = (uint16x4_t *)((char *)v21 + v27 + v48);
LABEL_37:
  uint64_t v58 = v18 + a17;
  if (v58)
  {
    int8x8_t v59 = 0;
    if (a7) {
      __int16 v60 = 0;
    }
    else {
      __int16 v60 = -1;
    }
    v59.i16[3] = v60;
    uint32x4_t v61 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v62.i64[0] = 0x800000008000;
    v62.i64[1] = 0x800000008000;
    do
    {
      if (*v22)
      {
        a11.i32[0] = *v22;
        int8x8_t v63 = vdup_lane_s8(*(int8x8_t *)a11.i8, 0);
        uint32x4_t v64 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v19, v59), (uint16x4_t)v63), v61), v62);
        a11 = vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_u16(*v21, (uint16x4_t)vmvn_s8(v63)), vmull_lane_u16(vqshrn_n_u32(vsraq_n_u32(v64, v64, 0x10uLL), 0x10uLL), (uint16x4_t)vmvn_s8((int8x8_t)*v21), 3)), v61), v62);
        *(uint16x4_t *)a11.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a11, (uint32x4_t)a11, 0x10uLL), 0x10uLL);
        uint16x4_t *v21 = *(uint16x4_t *)a11.i8;
      }
      uint32x4_t v65 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v65 >= v20) {
        uint64_t v66 = -(uint64_t)a5;
      }
      else {
        uint64_t v66 = 0;
      }
      unint64_t v19 = &v65[v66];
      v21 += a6;
      --v58;
    }
    while (v58);
  }
  *size_t result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

int8x8_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)3,_rgba16_t>(int8x8_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, int a7, double a8, double a9, double a10, int32x4_t a11, double a12, double a13, double a14, uint32x4_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v18 = a18;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  int8x16_t v21 = *a2;
  uint64_t v22 = *a4;
  if (a18 < 2) {
    goto LABEL_37;
  }
  if (a7) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0xFFFF000000000000;
  v24.i64[1] = 0xFFFF000000000000;
  int8x16_t v25 = vandq_s8((int8x16_t)vdupq_n_s16(v23), v24);
  uint64_t v26 = 2 * a6;
  uint64_t v27 = 16 * a6;
  uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v29.i64[0] = 0x800000008000;
  v29.i64[1] = 0x800000008000;
  a11.i64[0] = -1;
  a11.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v30 = *(unsigned __int16 *)v22;
    if (!*(_WORD *)v22)
    {
      uint32x4_t v43 = (int8x16_t *)&v22[v18];
      int64_t v44 = (int8x16_t *)v22;
      do
        uint64_t v45 = v44++;
      while (v44 <= v43 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v45)) & 0x80) != 0);
      do
      {
        int64_t v46 = v45;
        uint64_t v45 = (int8x16_t *)((char *)v45 + 4);
      }
      while (v45 <= v43 && !v46->i32[0]);
      if (v46 < v43)
      {
        while (!v46->i8[0])
        {
          int64_t v46 = (int8x16_t *)((char *)v46 + 1);
          if (v46 >= v43)
          {
            int64_t v46 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      int64_t v47 = (char *)v46 - v22;
      int64_t v48 = ((char *)v46 - v22) * a6;
      v19 += v48;
      v21 += v48;
      v22 += v48;
      v18 -= v47;
      goto LABEL_34;
    }
    if (v30 != 0xFFFF) {
      break;
    }
    uint64_t v31 = (int8x16_t *)&v22[v18];
    int64_t v32 = (int8x16_t *)v22;
    do
      unint64_t v33 = v32++;
    while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, (int8x16_t)a11)) & 0x80) != 0);
    do
    {
      uint16x8_t v34 = v33;
      unint64_t v33 = (int8x16_t *)((char *)v33 + 4);
    }
    while (v33 <= v31 && v34->i32[0] == -1);
    if (v34 < v31)
    {
      while (v34->u8[0] == 255)
      {
        uint16x8_t v34 = (int8x16_t *)((char *)v34 + 1);
        if (v34 >= v31)
        {
          uint16x8_t v34 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    uint64_t v35 = 0;
    int64_t v36 = (char *)v34 - v22;
    unint64_t v37 = (char *)v34 - v22;
    do
    {
      uint16x8_t v38 = *(uint16x8_t *)&v21->i8[v35];
      uint16x8_t v39 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v19->i8[v35], v25);
      a15 = vmull_lane_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)v38.i8, 3);
      uint32x4_t v40 = vmull_high_laneq_u16(v39, v38, 7);
      uint32x4_t v41 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(a15, v28), v29);
      uint32x4_t v42 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v40, v28), v29);
      *(uint16x8_t *)&v21->i8[v35] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v41, v41, 0x10uLL), 0x10uLL), vsraq_n_u32(v42, v42, 0x10uLL), 0x10uLL);
      v22 += v26;
      v37 -= 2;
      v35 += v27;
    }
    while (v37 > 1);
    int8x16_t v21 = (uint16x4_t *)((char *)v21 + v35);
    unint64_t v19 = (int8x8_t *)((char *)v19 + v35);
    unint64_t v18 = v18 - v36 + v37;
LABEL_34:
    if (v18 <= 1) {
      goto LABEL_37;
    }
  }
  uint64_t v49 = 0;
  while (1)
  {
    uint16x8_t v50 = *(uint16x8_t *)&v21->i8[v49];
    a15.i32[0] = v30;
    int8x16_t v51 = vqtbl1q_s8((int8x16_t)a15, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v52 = (uint16x8_t)vorrq_s8(*(int8x16_t *)&v19->i8[v49], v25);
    uint32x4_t v53 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v52.i8, *(uint16x4_t *)v51.i8), v28), v29);
    uint32x4_t v54 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(v52, (uint16x8_t)v51), v28), v29);
    uint16x8_t v55 = (uint16x8_t)vmvnq_s8(v51);
    uint32x4_t v56 = vqaddq_u32(vmull_u16(*(uint16x4_t *)v50.i8, *(uint16x4_t *)v55.i8), vmull_lane_u16(vqshrn_n_u32(vsraq_n_u32(v53, v53, 0x10uLL), 0x10uLL), *(uint16x4_t *)v50.i8, 3));
    a15 = vmull_high_u16(v50, v55);
    uint32x4_t v57 = vqaddq_u32(a15, vmull_laneq_u16(vqshrn_n_u32(vsraq_n_u32(v54, v54, 0x10uLL), 0x10uLL), v50, 7));
    uint32x4_t v58 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v56, v28), v29);
    uint32x4_t v59 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v57, v28), v29);
    *(uint16x8_t *)&v21->i8[v49] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v58, v58, 0x10uLL), 0x10uLL), vsraq_n_u32(v59, v59, 0x10uLL), 0x10uLL);
    v22 += v26;
    v18 -= 2;
    if (v18 < 2) {
      break;
    }
    unsigned __int32 v30 = *(unsigned __int16 *)v22;
    v49 += v27;
    if ((unsigned __int16)(v30 - 1) >= 0xFFFEu)
    {
      unint64_t v19 = (int8x8_t *)((char *)v19 + v49);
      int8x16_t v21 = (uint16x4_t *)((char *)v21 + v49);
      goto LABEL_34;
    }
  }
  unint64_t v19 = (int8x8_t *)((char *)v19 + v27 + v49);
  int8x16_t v21 = (uint16x4_t *)((char *)v21 + v27 + v49);
LABEL_37:
  uint64_t v60 = v18 + a17;
  if (v60)
  {
    int8x8_t v61 = 0;
    if (a7) {
      __int16 v62 = 0;
    }
    else {
      __int16 v62 = -1;
    }
    v61.i16[3] = v62;
    uint32x4_t v63 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v64.i64[0] = 0x800000008000;
    v64.i64[1] = 0x800000008000;
    do
    {
      if (*v22)
      {
        a11.i32[0] = *v22;
        int8x8_t v65 = vdup_lane_s8(*(int8x8_t *)a11.i8, 0);
        uint32x4_t v66 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v19, v61), (uint16x4_t)v65), v63), v64);
        a11 = vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_u16(*v21, (uint16x4_t)vmvn_s8(v65)), vmull_lane_u16(vqshrn_n_u32(vsraq_n_u32(v66, v66, 0x10uLL), 0x10uLL), *v21, 3)), v63), v64);
        *(uint16x4_t *)a11.i8 = vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a11, (uint32x4_t)a11, 0x10uLL), 0x10uLL);
        uint16x4_t *v21 = *(uint16x4_t *)a11.i8;
      }
      uint32x4_t v67 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v67 >= v20) {
        uint64_t v68 = -(uint64_t)a5;
      }
      else {
        uint64_t v68 = 0;
      }
      unint64_t v19 = &v67[v68];
      v21 += a6;
      --v60;
    }
    while (v60);
  }
  *size_t result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

uint16x4_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)2,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, int32x4_t a9, double a10, double a11, double a12, double a13, int8x16_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v18 = a18;
  unint64_t v19 = *result;
  unint64_t v20 = *a3;
  int8x16_t v21 = *a2;
  uint64_t v22 = *a4;
  if (a18 < 2) {
    goto LABEL_34;
  }
  uint64_t v23 = 2 * a6;
  uint64_t v24 = 16 * a6;
  uint32x4_t v25 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  a9.i64[0] = 0x800000008000;
  a9.i64[1] = 0x800000008000;
  v26.i64[0] = -1;
  v26.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v27 = *(unsigned __int16 *)v22;
    if (!*(_WORD *)v22)
    {
      uint16x8_t v39 = (int8x16_t *)&v22[v18];
      uint32x4_t v40 = (int8x16_t *)v22;
      do
        uint32x4_t v41 = v40++;
      while (v40 <= v39 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v41)) & 0x80) != 0);
      do
      {
        uint32x4_t v42 = v41;
        uint32x4_t v41 = (int8x16_t *)((char *)v41 + 4);
      }
      while (v41 <= v39 && !v42->i32[0]);
      if (v42 < v39)
      {
        while (!v42->i8[0])
        {
          uint32x4_t v42 = (int8x16_t *)((char *)v42 + 1);
          if (v42 >= v39)
          {
            uint32x4_t v42 = (int8x16_t *)&v22[v18];
            break;
          }
        }
      }
      int64_t v43 = (char *)v42 - v22;
      int64_t v44 = ((char *)v42 - v22) * a6;
      v19 += v44;
      v21 += v44;
      v22 += v44;
      v18 -= v43;
      goto LABEL_31;
    }
    if (v27 != 0xFFFF) {
      break;
    }
    uint32x4_t v28 = (int8x16_t *)&v22[v18];
    int32x4_t v29 = (int8x16_t *)v22;
    do
      unsigned __int32 v30 = v29++;
    while (v29 <= v28 && (vminvq_u8((uint8x16_t)vceqq_s8(*v30, v26)) & 0x80) != 0);
    do
    {
      uint64_t v31 = v30;
      unsigned __int32 v30 = (int8x16_t *)((char *)v30 + 4);
    }
    while (v30 <= v28 && v31->i32[0] == -1);
    if (v31 < v28)
    {
      while (v31->u8[0] == 255)
      {
        uint64_t v31 = (int8x16_t *)((char *)v31 + 1);
        if (v31 >= v28)
        {
          uint64_t v31 = (int8x16_t *)&v22[v18];
          break;
        }
      }
    }
    uint64_t v32 = 0;
    int64_t v33 = (char *)v31 - v22;
    unint64_t v34 = (char *)v31 - v22;
    do
    {
      int8x16_t v35 = *(int8x16_t *)&v19->i8[v32];
      uint16x8_t v36 = *(uint16x8_t *)&v21->i8[v32];
      a14 = vbicq_s8(v35, (int8x16_t)vceqzq_s16((int16x8_t)vqtbl1q_s8(v35, (int8x16_t)xmmword_1850CD880)));
      uint32x4_t v37 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v36.i8, *(uint16x4_t *)v35.i8, 3), v25), a9);
      uint32x4_t v38 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v36, (uint16x8_t)v35, 7), v25), a9);
      *(uint16x8_t *)&v21->i8[v32] = vqaddq_u16((uint16x8_t)a14, vqsubq_u16(v36, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v37, v37, 0x10uLL), 0x10uLL), vsraq_n_u32(v38, v38, 0x10uLL), 0x10uLL)));
      v22 += v23;
      v34 -= 2;
      v32 += v24;
    }
    while (v34 > 1);
    int8x16_t v21 = (uint16x4_t *)((char *)v21 + v32);
    unint64_t v19 = (uint16x4_t *)((char *)v19 + v32);
    unint64_t v18 = v18 - v33 + v34;
LABEL_31:
    if (v18 <= 1) {
      goto LABEL_34;
    }
  }
  uint64_t v45 = 0;
  while (1)
  {
    uint16x8_t v46 = *(uint16x8_t *)&v19->i8[v45];
    uint16x8_t v47 = *(uint16x8_t *)&v21->i8[v45];
    a14.i32[0] = v27;
    uint16x8_t v48 = (uint16x8_t)vqtbl1q_s8(a14, (int8x16_t)xmmword_1850CD890);
    int16x8_t v49 = (int16x8_t)vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v48.i8);
    uint32x4_t v50 = vmull_high_u16(v46, v48);
    uint32x4_t v51 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)v49, v25), a9);
    *(uint16x4_t *)v51.i8 = vqshrn_n_u32(vsraq_n_u32(v51, v51, 0x10uLL), 0x10uLL);
    uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v50, v25), a9);
    uint32x4_t v53 = vsraq_n_u32(v52, v52, 0x10uLL);
    *(int16x4_t *)v49.i8 = vdup_lane_s16(*(int16x4_t *)v51.i8, 3);
    int16x4_t v54 = (int16x4_t)vqshrn_n_u32(v53, 0x10uLL);
    v49.i64[1] = vdupq_lane_s16(v54, 3).u64[0];
    uint16x8_t v55 = (uint16x8_t)vbicq_s8((int8x16_t)vqshrn_high_n_u32(*(uint16x4_t *)v51.i8, v53, 0x10uLL), (int8x16_t)vceqzq_s16(v49));
    uint32x4_t v56 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v47.i8, *(uint16x4_t *)v51.i8, 3), v25), a9);
    uint32x4_t v57 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_lane_u16(v47, (uint16x4_t)v54, 3), v25), a9);
    a14 = (int8x16_t)vsraq_n_u32(v57, v57, 0x10uLL);
    *(uint16x8_t *)&v21->i8[v45] = vqaddq_u16(v55, vqsubq_u16(v47, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v56, v56, 0x10uLL), 0x10uLL), (uint32x4_t)a14, 0x10uLL)));
    v22 += v23;
    v18 -= 2;
    if (v18 < 2) {
      break;
    }
    unsigned __int32 v27 = *(unsigned __int16 *)v22;
    v45 += v24;
    if ((unsigned __int16)(v27 - 1) >= 0xFFFEu)
    {
      unint64_t v19 = (uint16x4_t *)((char *)v19 + v45);
      int8x16_t v21 = (uint16x4_t *)((char *)v21 + v45);
      goto LABEL_31;
    }
  }
  unint64_t v19 = (uint16x4_t *)((char *)v19 + v24 + v45);
  int8x16_t v21 = (uint16x4_t *)((char *)v21 + v24 + v45);
LABEL_34:
  uint64_t v58 = v18 + a17;
  if (v58)
  {
    uint32x4_t v59 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v60.i64[0] = 0x800000008000;
    v60.i64[1] = 0x800000008000;
    do
    {
      if (*v22)
      {
        a9.i32[0] = *v22;
        uint32x4_t v61 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v19, (uint16x4_t)vdup_lane_s8(*(int8x8_t *)a9.i8, 0)), v59), v60);
        *(uint16x4_t *)v61.i8 = vqshrn_n_u32(vsraq_n_u32(v61, v61, 0x10uLL), 0x10uLL);
        uint16x4_t v62 = (uint16x4_t)vbic_s8(*(int8x8_t *)v61.i8, (int8x8_t)vceqz_s16(vdup_lane_s16(*(int16x4_t *)v61.i8, 3)));
        a9 = vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v21, *(uint16x4_t *)v61.i8, 3), v59), v60);
        *(uint16x4_t *)a9.i8 = vqadd_u16(v62, vqsub_u16(*v21, vqshrn_n_u32(vsraq_n_u32((uint32x4_t)a9, (uint32x4_t)a9, 0x10uLL), 0x10uLL)));
        uint16x4_t *v21 = *(uint16x4_t *)a9.i8;
      }
      uint32x4_t v63 = &v19[a6];
      v22 += a6;
      if ((unint64_t)v63 >= v20) {
        uint64_t v64 = -(uint64_t)a5;
      }
      else {
        uint64_t v64 = 0;
      }
      unint64_t v19 = &v63[v64];
      v21 += a6;
      --v58;
    }
    while (v58);
  }
  *size_t result = v19;
  *a3 = v20;
  *a2 = v21;
  *a4 = v22;
  return result;
}

uint16x4_t **VEC::template_mark_pixelmask_row<(CGCompositeOperation)1,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, uint32x4_t a9, double a10, double a11, double a12, int8x16_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  int8x16_t v21 = *a4;
  if (a17 < 2) {
    goto LABEL_34;
  }
  uint64_t v22 = 2 * a6;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  uint64_t v24 = 16 * a6;
  a9 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v25.i64[0] = 0x800000008000;
  v25.i64[1] = 0x800000008000;
  while (1)
  {
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      unint64_t v34 = (int8x16_t *)&v21[v17];
      int8x16_t v35 = (int8x16_t *)v21;
      do
        uint16x8_t v36 = v35++;
      while (v35 <= v34 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v36)) & 0x80) != 0);
      do
      {
        uint32x4_t v37 = v36;
        uint16x8_t v36 = (int8x16_t *)((char *)v36 + 4);
      }
      while (v36 <= v34 && !v37->i32[0]);
      if (v37 < v34)
      {
        while (!v37->i8[0])
        {
          uint32x4_t v37 = (int8x16_t *)((char *)v37 + 1);
          if (v37 >= v34)
          {
            uint32x4_t v37 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v38 = (char *)v37 - v21;
      int64_t v39 = ((char *)v37 - v21) * a6;
      v18 += v39;
      v20 += v39;
      v21 += v39;
      v17 -= v38;
      goto LABEL_31;
    }
    if (v26 != 0xFFFF) {
      break;
    }
    unsigned __int32 v27 = (int8x16_t *)&v21[v17];
    uint32x4_t v28 = (int8x16_t *)v21;
    do
      int32x4_t v29 = v28++;
    while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, v23)) & 0x80) != 0);
    do
    {
      unsigned __int32 v30 = v29;
      int32x4_t v29 = (int8x16_t *)((char *)v29 + 4);
    }
    while (v29 <= v27 && v30->i32[0] == -1);
    if (v30 < v27)
    {
      while (v30->u8[0] == 255)
      {
        unsigned __int32 v30 = (int8x16_t *)((char *)v30 + 1);
        if (v30 >= v27)
        {
          unsigned __int32 v30 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v31 = 0;
    int64_t v32 = (char *)v30 - v21;
    unint64_t v33 = (char *)v30 - v21;
    do
    {
      *(_OWORD *)&v20->i8[v31] = *(_OWORD *)&v18->i8[v31];
      v21 += v22;
      v33 -= 2;
      v31 += v24;
    }
    while (v33 > 1);
    unint64_t v20 = (uint16x4_t *)((char *)v20 + v31);
    unint64_t v18 = (uint16x4_t *)((char *)v18 + v31);
    unint64_t v17 = v17 - v32 + v33;
LABEL_31:
    if (v17 <= 1) {
      goto LABEL_34;
    }
  }
  uint64_t v40 = 0;
  while (1)
  {
    uint16x8_t v41 = *(uint16x8_t *)&v18->i8[v40];
    uint16x8_t v42 = *(uint16x8_t *)&v20->i8[v40];
    a13.i32[0] = v26;
    a13 = vqtbl1q_s8(a13, (int8x16_t)xmmword_1850CD890);
    uint16x8_t v43 = (uint16x8_t)vmvnq_s8(a13);
    uint32x4_t v44 = vqaddq_u32(vmull_u16(*(uint16x4_t *)v41.i8, *(uint16x4_t *)a13.i8), vmull_u16(*(uint16x4_t *)v42.i8, *(uint16x4_t *)v43.i8));
    uint32x4_t v45 = vqaddq_u32(vmull_high_u16(v41, (uint16x8_t)a13), vmull_high_u16(v42, v43));
    uint32x4_t v46 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v44, a9), v25);
    uint32x4_t v47 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v45, a9), v25);
    *(uint16x8_t *)&v20->i8[v40] = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v46, v46, 0x10uLL), 0x10uLL), vsraq_n_u32(v47, v47, 0x10uLL), 0x10uLL);
    v21 += v22;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    unsigned __int32 v26 = *(unsigned __int16 *)v21;
    v40 += v24;
    if ((unsigned __int16)(v26 - 1) >= 0xFFFEu)
    {
      unint64_t v18 = (uint16x4_t *)((char *)v18 + v40);
      unint64_t v20 = (uint16x4_t *)((char *)v20 + v40);
      goto LABEL_31;
    }
  }
  unint64_t v18 = (uint16x4_t *)((char *)v18 + v24 + v40);
  unint64_t v20 = (uint16x4_t *)((char *)v20 + v24 + v40);
LABEL_34:
  uint64_t v48 = v17 + a16;
  if (v48)
  {
    uint32x4_t v49 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v50.i64[0] = 0x800000008000;
    v50.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a9.i32[0] = *v21;
        int8x8_t v51 = vdup_lane_s8(*(int8x8_t *)a9.i8, 0);
        a9 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_u16(*v18, (uint16x4_t)v51), vmull_u16(*v20, (uint16x4_t)vmvn_s8(v51))), v49), v50);
        *(uint16x4_t *)a9.i8 = vqshrn_n_u32(vsraq_n_u32(a9, a9, 0x10uLL), 0x10uLL);
        uint16x4_t *v20 = *(uint16x4_t *)a9.i8;
      }
      uint32x4_t v52 = &v18[a6];
      v21 += a6;
      if ((unint64_t)v52 >= v19) {
        uint64_t v53 = -(uint64_t)a5;
      }
      else {
        uint64_t v53 = 0;
      }
      unint64_t v18 = &v52[v53];
      v20 += a6;
      --v48;
    }
    while (v48);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

uint64_t *VEC::template_mark_pixelmask_row<(CGCompositeOperation)0,_rgba16_t>(uint64_t *result, uint16x4_t **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, int8x8_t a9, double a10, double a11, double a12, uint32x4_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17)
{
  unint64_t v17 = a17;
  unint64_t v18 = *result;
  unint64_t v19 = *a3;
  unint64_t v20 = *a2;
  int8x16_t v21 = *a4;
  if (a17 < 2) {
    goto LABEL_33;
  }
  uint64_t v22 = 2 * a6;
  v23.i64[0] = -1;
  v23.i64[1] = -1;
  uint64_t v24 = 16 * a6;
  a9.i32[1] = 0;
  uint32x4_t v25 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
  v26.i64[0] = 0x800000008000;
  v26.i64[1] = 0x800000008000;
  while (1)
  {
    unsigned __int32 v27 = *(unsigned __int16 *)v21;
    if (!*(_WORD *)v21)
    {
      int64_t v38 = (int8x16_t *)&v21[v17];
      int64_t v39 = (int8x16_t *)v21;
      do
        uint64_t v40 = v39++;
      while (v39 <= v38 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v40)) & 0x80) != 0);
      do
      {
        uint16x8_t v41 = v40;
        uint64_t v40 = (int8x16_t *)((char *)v40 + 4);
      }
      while (v40 <= v38 && !v41->i32[0]);
      if (v41 < v38)
      {
        while (!v41->i8[0])
        {
          uint16x8_t v41 = (int8x16_t *)((char *)v41 + 1);
          if (v41 >= v38)
          {
            uint16x8_t v41 = (int8x16_t *)&v21[v17];
            break;
          }
        }
      }
      int64_t v42 = (char *)v41 - v21;
      int64_t v43 = ((char *)v41 - v21) * a6;
      v18 += 8 * v43;
      v20 += v43;
      v21 += v43;
      v17 -= v42;
      goto LABEL_30;
    }
    if (v27 != 0xFFFF) {
      break;
    }
    uint32x4_t v28 = (int8x16_t *)&v21[v17];
    int32x4_t v29 = (int8x16_t *)v21;
    do
      unsigned __int32 v30 = v29++;
    while (v29 <= v28 && (vminvq_u8((uint8x16_t)vceqq_s8(*v30, v23)) & 0x80) != 0);
    do
    {
      uint64_t v31 = v30;
      unsigned __int32 v30 = (int8x16_t *)((char *)v30 + 4);
    }
    while (v30 <= v28 && v31->i32[0] == -1);
    if (v31 < v28)
    {
      while (v31->u8[0] == 255)
      {
        uint64_t v31 = (int8x16_t *)((char *)v31 + 1);
        if (v31 >= v28)
        {
          uint64_t v31 = (int8x16_t *)&v21[v17];
          break;
        }
      }
    }
    uint64_t v32 = 0;
    int64_t v33 = (char *)v31 - v21;
    unint64_t v34 = (char *)v31 - v21;
    do
    {
      *(_OWORD *)&v20->i8[v32] = 0uLL;
      v21 += v22;
      v34 -= 2;
      v32 += v24;
    }
    while (v34 > 1);
    unint64_t v20 = (uint16x4_t *)((char *)v20 + v32);
    v18 += v32;
    unint64_t v17 = v17 - v33 + v34;
LABEL_30:
    if (v17 <= 1) {
      goto LABEL_33;
    }
  }
  while (1)
  {
    a13.i32[0] = v27;
    uint16x8_t v35 = (uint16x8_t)vqtbl1q_s8((int8x16_t)a13, (int8x16_t)xmmword_1850CD890);
    uint32x4_t v36 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v20, *(uint16x4_t *)v35.i8), v25), v26);
    uint32x4_t v37 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16(*(uint16x8_t *)v20->i8, v35), v25), v26);
    a13 = vsraq_n_u32(v37, v37, 0x10uLL);
    *(uint16x8_t *)v20->i8 = vqsubq_u16(*(uint16x8_t *)v20->i8, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v36, v36, 0x10uLL), 0x10uLL), a13, 0x10uLL));
    v21 += v22;
    v17 -= 2;
    if (v17 < 2) {
      break;
    }
    unsigned __int32 v27 = *(unsigned __int16 *)v21;
    v18 += v24;
    unint64_t v20 = (uint16x4_t *)((char *)v20 + v24);
    if ((unsigned __int16)(v27 - 1) >= 0xFFFEu) {
      goto LABEL_30;
    }
  }
  v18 += v24;
  unint64_t v20 = (uint16x4_t *)((char *)v20 + v24);
LABEL_33:
  uint64_t v44 = v17 + a16;
  if (v44)
  {
    uint32x4_t v45 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v46.i64[0] = 0x800000008000;
    v46.i64[1] = 0x800000008000;
    do
    {
      if (*v21)
      {
        a9.i32[0] = *v21;
        uint32x4_t v47 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*v20, (uint16x4_t)vdup_lane_s8(a9, 0)), v45), v46);
        a9 = (int8x8_t)vqsub_u16(*v20, vqshrn_n_u32(vsraq_n_u32(v47, v47, 0x10uLL), 0x10uLL));
        uint16x4_t *v20 = (uint16x4_t)a9;
      }
      unint64_t v48 = v18 + 8 * a6;
      v21 += a6;
      if (v48 >= v19) {
        uint64_t v49 = -(uint64_t)a5;
      }
      else {
        uint64_t v49 = 0;
      }
      unint64_t v18 = v48 + 8 * v49;
      v20 += a6;
      --v44;
    }
    while (v44);
  }
  *size_t result = v18;
  *a3 = v19;
  *a2 = v20;
  *a4 = v21;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)23,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  uint64_t v10 = *result;
  unint64_t v11 = *a3;
  uint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0xFFFFFFFFFFFFLL;
    v20.i64[1] = 0xFFFFFFFFFFFFLL;
    v21.i64[0] = 0x800000008000;
    v21.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v23 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      int16x8_t v25 = (int16x8_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v26 = vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      int8x16_t v27 = (int8x16_t)vminq_u16((uint16x8_t)v23, (uint16x8_t)v25);
      uint16x8_t v28 = (uint16x8_t)vmvnq_s8(v27);
      uint16x8_t v29 = (uint16x8_t)vandq_s8(v27, v20);
      int8x16_t v30 = (int8x16_t)vcgtq_u16(v29, v28);
      uint16x8_t v31 = vabdq_u16(v28, v29);
      uint32x4_t v32 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v31.i8);
      uint32x4_t v33 = vmull_high_u16(v26, v31);
      uint32x4_t v34 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v32, v19), v21);
      uint32x4_t v35 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v33, v19), v21);
      uint16x8_t v36 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v34, v34, 0x10uLL), 0x10uLL), vsraq_n_u32(v35, v35, 0x10uLL), 0x10uLL);
      int8x16_t v37 = vbslq_s8(v30, (int8x16_t)vqsubq_u16((uint16x8_t)v27, v36), (int8x16_t)vqaddq_u16((uint16x8_t)v27, v36));
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v24), v23, vbslq_s8((int8x16_t)vceqzq_s16(v25), v22, (int8x16_t)vminq_u16((uint16x8_t)v37, (uint16x8_t)vqtbl1q_s8(v37, (int8x16_t)xmmword_1850CD880))));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    uint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    uint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v38 = v9 + a8;
  if (v38)
  {
    if (a6) {
      __int16 v39 = 0;
    }
    else {
      __int16 v39 = -1;
    }
    int8x8_t v40 = 0;
    v40.i16[3] = v39;
    int8x8_t v41 = 0;
    if (a7) {
      __int16 v42 = 0;
    }
    else {
      __int16 v42 = -1;
    }
    v41.i16[3] = v42;
    uint32x4_t v43 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v44.i64[0] = 0x800000008000;
    v44.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v45 = (int16x4_t)vorr_s8(*v10, v40);
      int16x4_t v46 = (int16x4_t)vorr_s8(*v12, v41);
      int16x4_t v47 = vdup_lane_s16(v45, 3);
      int16x4_t v48 = vdup_lane_s16(v46, 3);
      int8x8_t v49 = (int8x8_t)vmin_u16((uint16x4_t)v46, (uint16x4_t)v48);
      uint16x4_t v50 = (uint16x4_t)vmvn_s8(v49);
      uint16x4_t v51 = (uint16x4_t)v49;
      v51.i16[3] = 0;
      uint32x4_t v52 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(vmin_u16((uint16x4_t)v45, (uint16x4_t)v47), vabd_u16(v50, v51)), v43), v44);
      *(uint16x4_t *)v52.i8 = vqshrn_n_u32(vsraq_n_u32(v52, v52, 0x10uLL), 0x10uLL);
      *(int8x8_t *)v52.i8 = vbsl_s8((int8x8_t)vcgt_u16(v51, v50), (int8x8_t)vqsub_u16((uint16x4_t)v49, *(uint16x4_t *)v52.i8), (int8x8_t)vqadd_u16((uint16x4_t)v49, *(uint16x4_t *)v52.i8));
      *uint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v47), (int8x8_t)v46, vbsl_s8((int8x8_t)vceqz_s16(v48), (int8x8_t)v45, (int8x8_t)vmin_u16(*(uint16x4_t *)v52.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v52.i8, 3))));
      uint64_t v53 = &v10[a5];
      if ((unint64_t)v53 >= v11) {
        uint64_t v54 = -(uint64_t)a4;
      }
      else {
        uint64_t v54 = 0;
      }
      uint64_t v10 = &v53[v54];
      v12 += a5;
      --v38;
    }
    while (v38);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)22,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  uint64_t v10 = *result;
  unint64_t v11 = *a3;
  uint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0x800000008000;
    v20.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v23 = (int16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v25 = vminq_u16((uint16x8_t)v21, (uint16x8_t)v23);
      uint16x8_t v26 = vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      uint32x4_t v27 = vmull_lane_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v21.i8, 3);
      uint32x4_t v28 = vmull_high_laneq_u16(v26, (uint16x8_t)v21, 7);
      v27.i32[3] = 0;
      uint32x4_t v29 = vabdq_u32(vmull_lane_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v22.i8, 3), v27);
      v28.i32[3] = 0;
      uint32x4_t v30 = vabdq_u32(vmull_high_laneq_u16(v25, (uint16x8_t)v22, 7), v28);
      uint16x8_t v31 = (uint16x8_t)vmvnq_s8((int8x16_t)v23);
      uint32x4_t v32 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v31.i8);
      uint32x4_t v33 = vqaddq_u32(v30, vmull_high_u16(v26, v31));
      uint16x8_t v34 = (uint16x8_t)vmvnq_s8((int8x16_t)v24);
      uint32x4_t v35 = vmull_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v34.i8);
      uint32x4_t v36 = vqaddq_u32(v33, vmull_high_u16(v25, v34));
      uint32x4_t v37 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(v29, v32), v35), v19), v20);
      *(uint16x4_t *)v37.i8 = vqshrn_n_u32(vsraq_n_u32(v37, v37, 0x10uLL), 0x10uLL);
      uint32x4_t v38 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v36, v19), v20);
      uint32x4_t v39 = vsraq_n_u32(v38, v38, 0x10uLL);
      *(int16x4_t *)v34.i8 = vdup_lane_s16(*(int16x4_t *)v37.i8, 3);
      v34.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v39, 0x10uLL), 3);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v23), v22, vbslq_s8((int8x16_t)vceqzq_s16(v24), v21, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v37.i8, v39, 0x10uLL), v34)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    uint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    uint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v40 = v9 + a8;
  if (v40)
  {
    if (a6) {
      __int16 v41 = 0;
    }
    else {
      __int16 v41 = -1;
    }
    int8x8_t v42 = 0;
    v42.i16[3] = v41;
    int8x8_t v43 = 0;
    if (a7) {
      __int16 v44 = 0;
    }
    else {
      __int16 v44 = -1;
    }
    v43.i16[3] = v44;
    uint32x4_t v45 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v46.i64[0] = 0x800000008000;
    v46.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v47 = (int16x4_t)vorr_s8(*v10, v42);
      int16x4_t v48 = (int16x4_t)vorr_s8(*v12, v43);
      int16x4_t v49 = vdup_lane_s16(v47, 3);
      int16x4_t v50 = vdup_lane_s16(v48, 3);
      uint16x4_t v51 = vmin_u16((uint16x4_t)v47, (uint16x4_t)v49);
      uint16x4_t v52 = vmin_u16((uint16x4_t)v48, (uint16x4_t)v50);
      uint32x4_t v53 = vmull_lane_u16(v52, (uint16x4_t)v47, 3);
      v53.i32[3] = 0;
      uint32x4_t v54 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vabdq_u32(vmull_lane_u16(v51, (uint16x4_t)v48, 3), v53), vmull_u16(v52, (uint16x4_t)vmvn_s8((int8x8_t)v49))), vmull_u16(v51, (uint16x4_t)vmvn_s8((int8x8_t)v50))), v45), v46);
      *(uint16x4_t *)v54.i8 = vqshrn_n_u32(vsraq_n_u32(v54, v54, 0x10uLL), 0x10uLL);
      *uint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v49), (int8x8_t)v48, vbsl_s8((int8x8_t)vceqz_s16(v50), (int8x8_t)v47, (int8x8_t)vmin_u16(*(uint16x4_t *)v54.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v54.i8, 3))));
      uint16x8_t v55 = &v10[a5];
      if ((unint64_t)v55 >= v11) {
        uint64_t v56 = -(uint64_t)a4;
      }
      else {
        uint64_t v56 = 0;
      }
      uint64_t v10 = &v55[v56];
      v12 += a5;
      --v40;
    }
    while (v40);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)21,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v10 = a9;
  unint64_t v11 = *result;
  unint64_t v12 = *a3;
  uint64_t v13 = *a2;
  if (a9 >= 2)
  {
    uint64_t v14 = 0;
    if (a6) {
      unsigned int v15 = 0;
    }
    else {
      unsigned int v15 = -1;
    }
    v16.i64[0] = 0xFFFF000000000000;
    v16.i64[1] = 0xFFFF000000000000;
    int8x16_t v17 = vandq_s8((int8x16_t)vdupq_n_s16(v15), v16);
    if (a7) {
      unsigned int v18 = 0;
    }
    else {
      unsigned int v18 = -1;
    }
    int8x16_t v19 = vandq_s8((int8x16_t)vdupq_n_s16(v18), v16);
    uint32x4_t v20 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v21.i64[0] = 0x800000008000;
    v21.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v11[v14].i8, v17);
      int16x8_t v23 = (int16x8_t)vorrq_s8(*(int8x16_t *)v13[v14].i8, v19);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      int16x8_t v25 = (int16x8_t)vqtbl1q_s8((int8x16_t)v23, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v26 = vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      uint16x8_t v27 = vminq_u16((uint16x8_t)v23, (uint16x8_t)v25);
      int16x8_t v28 = (int16x8_t)vcgeq_u16(vrhaddq_u16((uint16x8_t)v24, (uint16x8_t)0), v26);
      int8x16_t v29 = (int8x16_t)vzip1q_s16(v28, v28);
      uint32x4_t v30 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v27.i8);
      uint32x4_t v31 = vmull_high_u16(v26, v27);
      uint16x8_t v32 = vqsubq_u16((uint16x8_t)v25, v27);
      uint16x8_t v33 = vqsubq_u16((uint16x8_t)v24, v26);
      uint32x4_t v34 = vmull_u16(*(uint16x4_t *)v32.i8, *(uint16x4_t *)v33.i8);
      uint32x4_t v35 = vmull_high_u16(v32, v33);
      uint32x4_t v36 = (uint32x4_t)vbslq_s8((int8x16_t)vzip2q_s16(v28, v28), (int8x16_t)vqaddq_u32(v31, v31), (int8x16_t)vqsubq_u32(vmull_laneq_u16((uint16x4_t)vdup_laneq_s16(v23, 7), (uint16x8_t)v22, 7), vqaddq_u32(v35, v35)));
      uint16x8_t v37 = (uint16x8_t)vbslq_s8(v29, (int8x16_t)vqaddq_u32(v30, v30), (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.i8, 3), *(uint16x4_t *)v22.i8, 3), vqaddq_u32(v34, v34)));
      uint16x8_t v38 = (uint16x8_t)vmvnq_s8((int8x16_t)v24);
      uint32x4_t v39 = vmull_u16(*(uint16x4_t *)v27.i8, *(uint16x4_t *)v38.i8);
      uint32x4_t v40 = vqaddq_u32(v36, vmull_high_u16(v27, v38));
      uint16x8_t v41 = (uint16x8_t)vmvnq_s8((int8x16_t)v25);
      uint32x4_t v42 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v41.i8);
      uint32x4_t v43 = vqaddq_u32(v40, vmull_high_u16(v26, v41));
      uint32x4_t v44 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)v37, v39), v42), v20), v21);
      *(uint16x4_t *)v44.i8 = vqshrn_n_u32(vsraq_n_u32(v44, v44, 0x10uLL), 0x10uLL);
      uint32x4_t v45 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v43, v20), v21);
      uint32x4_t v46 = vsraq_n_u32(v45, v45, 0x10uLL);
      *(int16x4_t *)v37.i8 = vdup_lane_s16(*(int16x4_t *)v44.i8, 3);
      int16x8_t v9 = (int16x8_t)vqshrn_high_n_u32(*(uint16x4_t *)v44.i8, v46, 0x10uLL);
      v37.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v46, 0x10uLL), 3);
      *(int8x16_t *)v13[v14].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v24), (int8x16_t)v23, vbslq_s8((int8x16_t)vceqzq_s16(v25), v22, (int8x16_t)vminq_u16((uint16x8_t)v9, v37)));
      v10 -= 2;
      v14 += 2 * a5;
    }
    while (v10 > 1);
    uint64_t v13 = (int8x8_t *)((char *)v13 + v14 * 8);
    unint64_t v11 = (int8x8_t *)((char *)v11 + v14 * 8);
  }
  uint64_t v47 = v10 + a8;
  if (v47)
  {
    if (a6) {
      __int16 v48 = 0;
    }
    else {
      __int16 v48 = -1;
    }
    int8x8_t v49 = 0;
    v49.i16[3] = v48;
    if (a7) {
      __int16 v50 = 0;
    }
    else {
      __int16 v50 = -1;
    }
    int8x8_t v51 = 0;
    v51.i16[3] = v50;
    uint32x4_t v52 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v53.i64[0] = 0x800000008000;
    v53.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v54 = (int16x4_t)vorr_s8(*v11, v49);
      int16x4_t v55 = (int16x4_t)vorr_s8(*v13, v51);
      int16x4_t v56 = vdup_lane_s16(v54, 3);
      int16x4_t v57 = vdup_lane_s16(v55, 3);
      uint16x4_t v58 = vmin_u16((uint16x4_t)v54, (uint16x4_t)v56);
      uint16x4_t v59 = vmin_u16((uint16x4_t)v55, (uint16x4_t)v57);
      *(uint16x4_t *)v9.i8 = vcge_u16(vrhadd_u16((uint16x4_t)v56, 0), v58);
      uint32x4_t v60 = vmull_u16(v58, v59);
      uint32x4_t v61 = vmull_u16(vqsub_u16((uint16x4_t)v57, v59), vqsub_u16((uint16x4_t)v56, v58));
      int16x8_t v9 = (int16x8_t)vbslq_s8((int8x16_t)vzip1q_s16(v9, v9), (int8x16_t)vqaddq_u32(v60, v60), (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)v57, (uint16x4_t)v54, 3), vqaddq_u32(v61, v61)));
      uint32x4_t v62 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)v9, vmull_u16(v59, (uint16x4_t)vmvn_s8((int8x8_t)v56))), vmull_u16(v58, (uint16x4_t)vmvn_s8((int8x8_t)v57))), v52), v53);
      *(uint16x4_t *)v62.i8 = vqshrn_n_u32(vsraq_n_u32(v62, v62, 0x10uLL), 0x10uLL);
      int8x8_t *v13 = vbsl_s8((int8x8_t)vceqz_s16(v56), (int8x8_t)v55, vbsl_s8((int8x8_t)vceqz_s16(v57), (int8x8_t)v54, (int8x8_t)vmin_u16(*(uint16x4_t *)v62.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v62.i8, 3))));
      uint32x4_t v63 = &v11[a5];
      if ((unint64_t)v63 >= v12) {
        uint64_t v64 = -(uint64_t)a4;
      }
      else {
        uint64_t v64 = 0;
      }
      unint64_t v11 = &v63[v64];
      v13 += a5;
      --v47;
    }
    while (v47);
  }
  *size_t result = v11;
  *a3 = v12;
  *a2 = v13;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)20,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0x800000008000;
    v20.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v23 = (int16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v25 = vminq_u16((uint16x8_t)v21, (uint16x8_t)v23);
      uint16x8_t v26 = vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      int16x4_t v27 = vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v26.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v24.i8)))));
      int32x4_t v28 = vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_high_u16(v26, v26)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL)))));
      uint32x4_t v29 = vmull_lane_u16((uint16x4_t)v27, *(uint16x4_t *)v21.i8, 3);
      uint16x8_t v30 = vqsubq_u16(v26, (uint16x8_t)vqmovun_high_s32(v27, v28));
      uint32x4_t v31 = vmull_u16(*(uint16x4_t *)v30.i8, *(uint16x4_t *)v25.i8);
      uint32x4_t v32 = vmull_high_u16(v30, v25);
      uint32x4_t v33 = vqaddq_u32(v29, vqaddq_u32(v31, v31));
      uint32x4_t v34 = vqaddq_u32(vmull_laneq_u16((uint16x4_t)vqmovun_s32(v28), (uint16x8_t)v21, 7), vqaddq_u32(v32, v32));
      uint16x8_t v35 = (uint16x8_t)vmvnq_s8((int8x16_t)v23);
      uint32x4_t v36 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v35.i8);
      uint32x4_t v37 = vmull_high_u16(v26, v35);
      uint16x8_t v38 = (uint16x8_t)vqaddq_u32(v33, v36);
      uint32x4_t v39 = vqaddq_u32(v34, v37);
      uint16x8_t v40 = (uint16x8_t)vmvnq_s8((int8x16_t)v24);
      uint32x4_t v41 = vmull_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v40.i8);
      uint32x4_t v42 = vqaddq_u32(v39, vmull_high_u16(v25, v40));
      uint32x4_t v43 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32((uint32x4_t)v38, v41), v19), v20);
      *(uint16x4_t *)v43.i8 = vqshrn_n_u32(vsraq_n_u32(v43, v43, 0x10uLL), 0x10uLL);
      uint32x4_t v44 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v42, v19), v20);
      uint32x4_t v45 = vsraq_n_u32(v44, v44, 0x10uLL);
      *(int16x4_t *)v38.i8 = vdup_lane_s16(*(int16x4_t *)v43.i8, 3);
      v38.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v45, 0x10uLL), 3);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v23), v22, vbslq_s8((int8x16_t)vceqzq_s16(v24), v21, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v43.i8, v45, 0x10uLL), v38)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v46 = v9 + a8;
  if (v46)
  {
    if (a6) {
      __int16 v47 = 0;
    }
    else {
      __int16 v47 = -1;
    }
    int8x8_t v48 = 0;
    v48.i16[3] = v47;
    int8x8_t v49 = 0;
    if (a7) {
      __int16 v50 = 0;
    }
    else {
      __int16 v50 = -1;
    }
    v49.i16[3] = v50;
    uint32x4_t v51 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v52.i64[0] = 0x800000008000;
    v52.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v53 = (int16x4_t)vorr_s8(*v10, v48);
      int16x4_t v54 = (int16x4_t)vorr_s8(*v12, v49);
      int16x4_t v55 = vdup_lane_s16(v53, 3);
      int16x4_t v56 = vdup_lane_s16(v54, 3);
      uint16x4_t v57 = vmin_u16((uint16x4_t)v53, (uint16x4_t)v55);
      uint16x4_t v58 = vmin_u16((uint16x4_t)v54, (uint16x4_t)v56);
      uint16x4_t v59 = (uint16x4_t)vqmovun_s32(vcvtnq_s32_f32(vdivq_f32(vcvtq_f32_u32(vmull_u16(v58, v58)), vcvtq_f32_u32(vmovl_u16((uint16x4_t)v56)))));
      uint32x4_t v60 = vmull_lane_u16(v59, (uint16x4_t)v53, 3);
      uint32x4_t v61 = vmull_u16(vqsub_u16(v58, v59), v57);
      uint32x4_t v62 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vqaddq_u32(v60, vqaddq_u32(v61, v61)), vmull_u16(v58, (uint16x4_t)vmvn_s8((int8x8_t)v55))), vmull_u16(v57, (uint16x4_t)vmvn_s8((int8x8_t)v56))), v51), v52);
      *(uint16x4_t *)v62.i8 = vqshrn_n_u32(vsraq_n_u32(v62, v62, 0x10uLL), 0x10uLL);
      *unint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v55), (int8x8_t)v54, vbsl_s8((int8x8_t)vceqz_s16(v56), (int8x8_t)v53, (int8x8_t)vmin_u16(*(uint16x4_t *)v62.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v62.i8, 3))));
      uint32x4_t v63 = &v10[a5];
      if ((unint64_t)v63 >= v11) {
        uint64_t v64 = -(uint64_t)a4;
      }
      else {
        uint64_t v64 = 0;
      }
      unint64_t v10 = &v63[v64];
      v12 += a5;
      --v46;
    }
    while (v46);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)19,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      int16x8_t v20 = (int16x8_t)vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v22 = (int16x8_t)vqtbl1q_s8((int8x16_t)v20, (int8x16_t)xmmword_1850CD880);
      int16x8_t v23 = (int16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v24 = vminq_u16((uint16x8_t)v20, (uint16x8_t)v22);
      uint16x8_t v25 = vminq_u16((uint16x8_t)v21, (uint16x8_t)v23);
      uint16x8_t v26 = vqsubq_u16((uint16x8_t)v23, v25);
      float32x4_t v27 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v26.i8));
      float32x4_t v28 = vcvtq_f32_u32(vmovl_high_u16(v26));
      uint16x4_t v29 = (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v20.i8, 3);
      uint16x4_t v30 = (uint16x4_t)vdup_laneq_s16(v20, 7);
      float32x4_t v31 = vcvtq_f32_u32(vmovl_high_u16(v24));
      float32x4_t v32 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v24.i8));
      uint16x8_t v33 = (uint16x8_t)vmvnq_s8((int8x16_t)v22);
      uint32x4_t v34 = vmull_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v33.i8);
      uint32x4_t v35 = vmull_high_u16(v25, v33);
      uint16x8_t v36 = (uint16x8_t)vmvnq_s8((int8x16_t)v23);
      uint32x4_t v37 = vmull_u16(*(uint16x4_t *)v24.i8, *(uint16x4_t *)v36.i8);
      float32x4_t v38 = vaddq_f32(vcvtq_f32_u32(v35), vcvtq_f32_u32(vmull_high_u16(v24, v36)));
      *(int16x4_t *)v35.i8 = vqmovun_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(v34), vcvtq_f32_u32(v37)), vcvtq_f32_u32(vmull_lane_u16(v29, *(uint16x4_t *)v21.i8, 3))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v27, vcvtq_f32_u32(vmull_lane_u16(v29, *(uint16x4_t *)v20.i8, 3))), v32), (int8x16_t)vceqzq_f32(v27))), v19)));
      int32x4_t v39 = vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(v38, vcvtq_f32_u32(vmull_laneq_u16(v30, (uint16x8_t)v21, 7))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v28, vcvtq_f32_u32(vmull_laneq_u16(v30, (uint16x8_t)v20, 7))), v31), (int8x16_t)vceqzq_f32(v28))), v19));
      *(int16x4_t *)v27.f32 = vdup_lane_s16(*(int16x4_t *)v35.i8, 3);
      *(int16x4_t *)&v27.u32[2] = vdup_lane_s16(vqmovun_s32(v39), 3);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v22), v21, vbslq_s8((int8x16_t)vceqzq_s16(v23), (int8x16_t)v20, (int8x16_t)vminq_u16((uint16x8_t)vqmovun_high_s32(*(int16x4_t *)v35.i8, v39), (uint16x8_t)v27)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v40 = v9 + a8;
  if (v40)
  {
    int8x8_t v41 = 0;
    if (a6) {
      __int16 v42 = 0;
    }
    else {
      __int16 v42 = -1;
    }
    int8x8_t v43 = 0;
    v43.i16[3] = v42;
    if (a7) {
      __int16 v44 = 0;
    }
    else {
      __int16 v44 = -1;
    }
    v41.i16[3] = v44;
    float32x4_t v45 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      int16x4_t v46 = (int16x4_t)vorr_s8(*v10, v43);
      int16x4_t v47 = (int16x4_t)vorr_s8(*v12, v41);
      int16x4_t v48 = vdup_lane_s16(v46, 3);
      int16x4_t v49 = vdup_lane_s16(v47, 3);
      uint16x4_t v50 = vmin_u16((uint16x4_t)v46, (uint16x4_t)v48);
      uint16x4_t v51 = vmin_u16((uint16x4_t)v47, (uint16x4_t)v49);
      float32x4_t v52 = vcvtq_f32_u32(vmovl_u16(vqsub_u16((uint16x4_t)v49, v51)));
      int16x4_t v53 = vqmovun_s32(vcvtnq_s32_f32(vmulq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vcvtq_f32_u32(vmull_u16(v51, (uint16x4_t)vmvn_s8((int8x8_t)v48))), vcvtq_f32_u32(vmull_u16(v50, (uint16x4_t)vmvn_s8((int8x8_t)v49)))), vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v48, (uint16x4_t)v47, 3))), (float32x4_t)vbicq_s8((int8x16_t)vdivq_f32(vmulq_f32(v52, vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v48, (uint16x4_t)v46, 3))), vcvtq_f32_u32(vmovl_u16(v50))), (int8x16_t)vceqzq_f32(v52))), v45)));
      *unint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v48), (int8x8_t)v47, vbsl_s8((int8x8_t)vceqz_s16(v49), (int8x8_t)v46, (int8x8_t)vmin_u16((uint16x4_t)v53, (uint16x4_t)vdup_lane_s16(v53, 3))));
      int16x4_t v54 = &v10[a5];
      if ((unint64_t)v54 >= v11) {
        uint64_t v55 = -(uint64_t)a4;
      }
      else {
        uint64_t v55 = 0;
      }
      unint64_t v10 = &v54[v55];
      v12 += a5;
      --v40;
    }
    while (v40);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)18,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0xFFFFFFFFFFFFLL;
    v20.i64[1] = 0xFFFFFFFFFFFFLL;
    v21.i64[0] = 0x800000008000;
    v21.i64[1] = 0x800000008000;
    do
    {
      int16x8_t v22 = (int16x8_t)vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v23 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8((int8x16_t)v22, (int8x16_t)xmmword_1850CD880);
      int16x8_t v25 = (int16x8_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1850CD880);
      int8x16_t v26 = (int8x16_t)vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      int16x8_t v27 = (int16x8_t)vminq_u16((uint16x8_t)v23, (uint16x8_t)v25);
      uint16x8_t v28 = (uint16x8_t)vandq_s8(v26, v20);
      int16x8_t v29 = (int16x8_t)vbicq_s8((int8x16_t)vtstq_s16(v27, v27), (int8x16_t)vcgtq_u16((uint16x8_t)v24, v28));
      int8x16_t v30 = (int8x16_t)vmovl_high_s16(v29);
      uint16x8_t v31 = (uint16x8_t)vorrq_s8((int8x16_t)vqsubq_u16((uint16x8_t)v24, v28), (int8x16_t)vceqzq_s16(v27));
      uint16x8_t v32 = (uint16x8_t)vmvnq_s8((int8x16_t)v24);
      uint16x8_t v33 = (uint16x8_t)vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v27.i8)), vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v22.i8, 3), *(uint16x4_t *)v22.i8, 3))), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v31.i8)))), (int8x16_t)vmovl_s16(*(int16x4_t *)v29.i8)), vmull_u16(*(uint16x4_t *)v27.i8, *(uint16x4_t *)v32.i8));
      uint32x4_t v34 = vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_high_u16((uint16x8_t)v27)), vcvtq_f32_u32(vmull_laneq_u16((uint16x4_t)vdup_laneq_s16(v22, 7), (uint16x8_t)v22, 7))), vcvtq_f32_u32(vmovl_high_u16(v31)))), v30), vmull_high_u16((uint16x8_t)v27, v32));
      uint16x8_t v35 = (uint16x8_t)vmvnq_s8((int8x16_t)v25);
      uint32x4_t v36 = vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v35.i8);
      uint32x4_t v37 = vqaddq_u32(v34, vmull_high_u16((uint16x8_t)v26, v35));
      uint32x4_t v38 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32((uint32x4_t)v33, v36), v19), v21);
      *(uint16x4_t *)v38.i8 = vqshrn_n_u32(vsraq_n_u32(v38, v38, 0x10uLL), 0x10uLL);
      uint32x4_t v39 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v37, v19), v21);
      uint32x4_t v40 = vsraq_n_u32(v39, v39, 0x10uLL);
      *(int16x4_t *)v33.i8 = vdup_lane_s16(*(int16x4_t *)v38.i8, 3);
      v33.u64[1] = (unint64_t)vdup_lane_s16((int16x4_t)vqshrn_n_u32(v40, 0x10uLL), 3);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v24), v23, vbslq_s8((int8x16_t)vceqzq_s16(v25), (int8x16_t)v22, (int8x16_t)vminq_u16(vqshrn_high_n_u32(*(uint16x4_t *)v38.i8, v40, 0x10uLL), v33)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v41 = v9 + a8;
  if (v41)
  {
    if (a6) {
      __int16 v42 = 0;
    }
    else {
      __int16 v42 = -1;
    }
    int8x8_t v43 = 0;
    v43.i16[3] = v42;
    int8x8_t v44 = 0;
    if (a7) {
      __int16 v45 = 0;
    }
    else {
      __int16 v45 = -1;
    }
    v44.i16[3] = v45;
    uint32x4_t v46 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v47.i64[0] = 0x800000008000;
    v47.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v48 = (int16x4_t)vorr_s8(*v10, v43);
      int16x4_t v49 = (int16x4_t)vorr_s8(*v12, v44);
      int16x4_t v50 = vdup_lane_s16(v48, 3);
      int16x4_t v51 = vdup_lane_s16(v49, 3);
      uint16x4_t v52 = vmin_u16((uint16x4_t)v48, (uint16x4_t)v50);
      int16x4_t v53 = (int16x4_t)vmin_u16((uint16x4_t)v49, (uint16x4_t)v51);
      uint32x4_t v54 = vmull_u16(v52, (uint16x4_t)vmvn_s8((int8x8_t)v51));
      v52.i16[3] = 0;
      uint32x4_t v55 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcvtnq_u32_f32(vdivq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v53)), vcvtq_f32_u32(vmull_lane_u16((uint16x4_t)v50, (uint16x4_t)v48, 3))), vcvtq_f32_u32(vmovl_u16((uint16x4_t)vorr_s8((int8x8_t)vqsub_u16((uint16x4_t)v50, v52), (int8x8_t)vceqz_s16(v53)))))), (int8x16_t)vmovl_s16((int16x4_t)vbic_s8((int8x8_t)vtst_s16(v53, v53), (int8x8_t)vcgt_u16((uint16x4_t)v50, v52)))), vmull_u16((uint16x4_t)v53, (uint16x4_t)vmvn_s8((int8x8_t)v50))), v54),
                                       v46),
                          v47);
      *(uint16x4_t *)v55.i8 = vqshrn_n_u32(vsraq_n_u32(v55, v55, 0x10uLL), 0x10uLL);
      *unint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v50), (int8x8_t)v49, vbsl_s8((int8x8_t)vceqz_s16(v51), (int8x8_t)v48, (int8x8_t)vmin_u16(*(uint16x4_t *)v55.i8, (uint16x4_t)vdup_lane_s16(*(int16x4_t *)v55.i8, 3))));
      int16x4_t v56 = &v10[a5];
      if ((unint64_t)v56 >= v11) {
        uint64_t v57 = -(uint64_t)a4;
      }
      else {
        uint64_t v57 = 0;
      }
      unint64_t v10 = &v56[v57];
      v12 += a5;
      --v41;
    }
    while (v41);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)17,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0x800000008000;
    v20.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v23 = (int16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v25 = vminq_u16((uint16x8_t)v21, (uint16x8_t)v23);
      uint16x8_t v26 = vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      uint32x4_t v27 = vmull_lane_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v22.i8, 3);
      uint16x8_t v28 = (uint16x8_t)vmvnq_s8((int8x16_t)v24);
      uint32x4_t v29 = vmull_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v28.i8);
      uint16x8_t v30 = (uint16x8_t)vmvnq_s8((int8x16_t)v23);
      uint32x4_t v31 = vqaddq_u32(vqaddq_u32(vmaxq_u32(vmull_high_laneq_u16(v25, (uint16x8_t)v22, 7), vmull_high_laneq_u16(v26, (uint16x8_t)v21, 7)), vmull_high_u16(v25, v28)), vmull_high_u16(v26, v30));
      uint32x4_t v32 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vmaxq_u32(v27, vmull_lane_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v21.i8, 3)), v29), vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v30.i8)), v19), v20);
      uint32x4_t v33 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v31, v19), v20);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v23), v22, vbslq_s8((int8x16_t)vceqzq_s16(v24), v21, (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v32, v32, 0x10uLL), 0x10uLL), vsraq_n_u32(v33, v33, 0x10uLL), 0x10uLL)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v34 = v9 + a8;
  if (v34)
  {
    if (a6) {
      __int16 v35 = 0;
    }
    else {
      __int16 v35 = -1;
    }
    int8x8_t v36 = 0;
    v36.i16[3] = v35;
    int8x8_t v37 = 0;
    if (a7) {
      __int16 v38 = 0;
    }
    else {
      __int16 v38 = -1;
    }
    v37.i16[3] = v38;
    uint32x4_t v39 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v40.i64[0] = 0x800000008000;
    v40.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v41 = (int16x4_t)vorr_s8(*v10, v36);
      int16x4_t v42 = (int16x4_t)vorr_s8(*v12, v37);
      int16x4_t v43 = vdup_lane_s16(v41, 3);
      int16x4_t v44 = vdup_lane_s16(v42, 3);
      uint16x4_t v45 = vmin_u16((uint16x4_t)v41, (uint16x4_t)v43);
      uint16x4_t v46 = vmin_u16((uint16x4_t)v42, (uint16x4_t)v44);
      uint32x4_t v47 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vmaxq_u32(vmull_lane_u16(v45, (uint16x4_t)v42, 3), vmull_lane_u16(v46, (uint16x4_t)v41, 3)), vmull_u16(v45, (uint16x4_t)vmvn_s8((int8x8_t)v44))), vmull_u16(v46, (uint16x4_t)vmvn_s8((int8x8_t)v43))), v39), v40);
      *unint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v43), (int8x8_t)v42, vbsl_s8((int8x8_t)vceqz_s16(v44), (int8x8_t)v41, (int8x8_t)vqshrn_n_u32(vsraq_n_u32(v47, v47, 0x10uLL), 0x10uLL)));
      int16x4_t v48 = &v10[a5];
      if ((unint64_t)v48 >= v11) {
        uint64_t v49 = -(uint64_t)a4;
      }
      else {
        uint64_t v49 = 0;
      }
      unint64_t v10 = &v48[v49];
      v12 += a5;
      --v34;
    }
    while (v34);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)16,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0x800000008000;
    v20.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v23 = (int16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v25 = vminq_u16((uint16x8_t)v21, (uint16x8_t)v23);
      uint16x8_t v26 = vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      uint32x4_t v27 = vmull_lane_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v22.i8, 3);
      uint16x8_t v28 = (uint16x8_t)vmvnq_s8((int8x16_t)v24);
      uint32x4_t v29 = vmull_u16(*(uint16x4_t *)v25.i8, *(uint16x4_t *)v28.i8);
      uint16x8_t v30 = (uint16x8_t)vmvnq_s8((int8x16_t)v23);
      uint32x4_t v31 = vqaddq_u32(vqaddq_u32(vminq_u32(vmull_high_laneq_u16(v26, (uint16x8_t)v21, 7), vmull_high_laneq_u16(v25, (uint16x8_t)v22, 7)), vmull_high_u16(v25, v28)), vmull_high_u16(v26, v30));
      uint32x4_t v32 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vminq_u32(vmull_lane_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v21.i8, 3), v27), v29), vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v30.i8)), v19), v20);
      uint32x4_t v33 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v31, v19), v20);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v23), v22, vbslq_s8((int8x16_t)vceqzq_s16(v24), v21, (int8x16_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v32, v32, 0x10uLL), 0x10uLL), vsraq_n_u32(v33, v33, 0x10uLL), 0x10uLL)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v34 = v9 + a8;
  if (v34)
  {
    if (a6) {
      __int16 v35 = 0;
    }
    else {
      __int16 v35 = -1;
    }
    int8x8_t v36 = 0;
    v36.i16[3] = v35;
    int8x8_t v37 = 0;
    if (a7) {
      __int16 v38 = 0;
    }
    else {
      __int16 v38 = -1;
    }
    v37.i16[3] = v38;
    uint32x4_t v39 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v40.i64[0] = 0x800000008000;
    v40.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v41 = (int16x4_t)vorr_s8(*v10, v36);
      int16x4_t v42 = (int16x4_t)vorr_s8(*v12, v37);
      int16x4_t v43 = vdup_lane_s16(v41, 3);
      int16x4_t v44 = vdup_lane_s16(v42, 3);
      uint16x4_t v45 = vmin_u16((uint16x4_t)v41, (uint16x4_t)v43);
      uint16x4_t v46 = vmin_u16((uint16x4_t)v42, (uint16x4_t)v44);
      uint32x4_t v47 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vqaddq_u32(vminq_u32(vmull_lane_u16(v45, (uint16x4_t)v42, 3), vmull_lane_u16(v46, (uint16x4_t)v41, 3)), vmull_u16(v45, (uint16x4_t)vmvn_s8((int8x8_t)v44))), vmull_u16(v46, (uint16x4_t)vmvn_s8((int8x8_t)v43))), v39), v40);
      *unint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v43), (int8x8_t)v42, vbsl_s8((int8x8_t)vceqz_s16(v44), (int8x8_t)v41, (int8x8_t)vqshrn_n_u32(vsraq_n_u32(v47, v47, 0x10uLL), 0x10uLL)));
      int16x4_t v48 = &v10[a5];
      if ((unint64_t)v48 >= v11) {
        uint64_t v49 = -(uint64_t)a4;
      }
      else {
        uint64_t v49 = 0;
      }
      unint64_t v10 = &v48[v49];
      v12 += a5;
      --v34;
    }
    while (v34);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)15,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0x800000008000;
    v20.i64[1] = 0x800000008000;
    do
    {
      int16x8_t v21 = (int16x8_t)vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v23 = (int16x8_t)vqtbl1q_s8((int8x16_t)v21, (int8x16_t)xmmword_1850CD880);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      int16x8_t v25 = (int16x8_t)vminq_u16((uint16x8_t)v21, (uint16x8_t)v23);
      int16x8_t v26 = (int16x8_t)vminq_u16((uint16x8_t)v22, (uint16x8_t)v24);
      uint16x8_t v27 = (uint16x8_t)vsubq_s16(v23, v25);
      uint16x8_t v28 = (uint16x8_t)vsubq_s16(v24, v26);
      int16x8_t v29 = (int16x8_t)vcgtq_u16(vrhaddq_u16((uint16x8_t)v24, (uint16x8_t)0), (uint16x8_t)v26);
      int8x16_t v30 = (int8x16_t)vqaddq_u32(vmull_u16(*(uint16x4_t *)v27.i8, *(uint16x4_t *)v26.i8), vmull_u16(*(uint16x4_t *)v28.i8, *(uint16x4_t *)v25.i8));
      int8x16_t v31 = (int8x16_t)vqaddq_u32(vmull_high_u16(v27, (uint16x8_t)v26), vmull_high_u16(v28, (uint16x8_t)v25));
      uint32x4_t v32 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v29.i8), v30, (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v21.i8, 3), *(uint16x4_t *)v22.i8, 3), (uint32x4_t)v30)), v19), v20);
      uint32x4_t v33 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v29), v31, (int8x16_t)vqsubq_u32(vmull_laneq_u16((uint16x4_t)vdup_laneq_s16(v21, 7), (uint16x8_t)v22, 7), (uint32x4_t)v31)), v19), v20);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v23), v22, vbslq_s8((int8x16_t)vceqzq_s16(v24), (int8x16_t)v21, (int8x16_t)vsubq_s16(vaddq_s16(v26, v25), (int16x8_t)vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v32, v32, 0x10uLL), 0x10uLL), vsraq_n_u32(v33, v33, 0x10uLL), 0x10uLL))));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v34 = v9 + a8;
  if (v34)
  {
    if (a6) {
      __int16 v35 = 0;
    }
    else {
      __int16 v35 = -1;
    }
    int8x8_t v36 = 0;
    v36.i16[3] = v35;
    if (a7) {
      __int16 v37 = 0;
    }
    else {
      __int16 v37 = -1;
    }
    int8x8_t v38 = 0;
    v38.i16[3] = v37;
    uint32x4_t v39 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v40.i64[0] = 0x800000008000;
    v40.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v41 = (int16x4_t)vorr_s8(*v10, v36);
      int16x4_t v42 = (int16x4_t)vorr_s8(*v12, v38);
      int16x4_t v43 = vdup_lane_s16(v41, 3);
      int16x4_t v44 = vdup_lane_s16(v42, 3);
      int16x4_t v45 = (int16x4_t)vmin_u16((uint16x4_t)v41, (uint16x4_t)v43);
      int16x4_t v46 = (int16x4_t)vmin_u16((uint16x4_t)v42, (uint16x4_t)v44);
      int8x16_t v47 = (int8x16_t)vqaddq_u32(vmull_u16((uint16x4_t)vsub_s16(v43, v45), (uint16x4_t)v46), vmull_u16((uint16x4_t)vsub_s16(v44, v46), (uint16x4_t)v45));
      uint32x4_t v48 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32((uint32x4_t)vbslq_s8((int8x16_t)vmovl_s16((int16x4_t)vcgt_u16(vrhadd_u16((uint16x4_t)v44, 0), (uint16x4_t)v46)), v47, (int8x16_t)vqsubq_u32(vmull_lane_u16((uint16x4_t)v43, (uint16x4_t)v42, 3), (uint32x4_t)v47)), v39), v40);
      *unint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v43), (int8x8_t)v42, vbsl_s8((int8x8_t)vceqz_s16(v44), (int8x8_t)v41, (int8x8_t)vsub_s16(vadd_s16(v46, v45), (int16x4_t)vqshrn_n_u32(vsraq_n_u32(v48, v48, 0x10uLL), 0x10uLL))));
      uint64_t v49 = &v10[a5];
      if ((unint64_t)v49 >= v11) {
        uint64_t v50 = -(uint64_t)a4;
      }
      else {
        uint64_t v50 = 0;
      }
      unint64_t v10 = &v49[v50];
      v12 += a5;
      --v34;
    }
    while (v34);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)14,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0x800000008000;
    v20.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      uint16x8_t v23 = (uint16x8_t)vbicq_s8(v22, (int8x16_t)vceqzq_s16((int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880)));
      uint32x4_t v24 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v21.i8, *(uint16x4_t *)v23.i8), v19), v20);
      uint32x4_t v25 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16((uint16x8_t)v21, v23), v19), v20);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16((int16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880)), v22, (int8x16_t)vqaddq_u16(vqsubq_u16((uint16x8_t)v21, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v24, v24, 0x10uLL), 0x10uLL), vsraq_n_u32(v25, v25, 0x10uLL), 0x10uLL)), v23));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v26 = v9 + a8;
  if (v26)
  {
    if (a6) {
      __int16 v27 = 0;
    }
    else {
      __int16 v27 = -1;
    }
    int8x8_t v28 = 0;
    v28.i16[3] = v27;
    int8x8_t v29 = 0;
    if (a7) {
      __int16 v30 = 0;
    }
    else {
      __int16 v30 = -1;
    }
    v29.i16[3] = v30;
    uint32x4_t v31 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v32.i64[0] = 0x800000008000;
    v32.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v33 = (int16x4_t)vorr_s8(*v10, v28);
      int16x4_t v34 = (int16x4_t)vorr_s8(*v12, v29);
      uint16x4_t v35 = (uint16x4_t)vbic_s8((int8x8_t)v34, (int8x8_t)vdup_lane_s16(vceqz_s16(v34), 3));
      uint32x4_t v36 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)v33, v35), v31), v32);
      *unint64_t v12 = vbsl_s8((int8x8_t)vdup_lane_s16(vceqz_s16(v33), 3), (int8x8_t)v34, (int8x8_t)vqadd_u16(vqsub_u16((uint16x4_t)v33, vqshrn_n_u32(vsraq_n_u32(v36, v36, 0x10uLL), 0x10uLL)), v35));
      __int16 v37 = &v10[a5];
      if ((unint64_t)v37 >= v11) {
        uint64_t v38 = -(uint64_t)a4;
      }
      else {
        uint64_t v38 = 0;
      }
      unint64_t v10 = &v37[v38];
      v12 += a5;
      --v26;
    }
    while (v26);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)13,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v15);
    uint32x4_t v19 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v20.i64[0] = 0x800000008000;
    v20.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int8x16_t v22 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v18);
      int16x8_t v23 = (int16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880);
      int16x8_t v24 = (int16x8_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1850CD880);
      int8x16_t v25 = (int8x16_t)vceqzq_s16(v24);
      uint16x8_t v26 = (uint16x8_t)vbicq_s8(v22, v25);
      uint32x4_t v27 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16(*(uint16x4_t *)v21.i8, *(uint16x4_t *)v26.i8), v19), v20);
      uint32x4_t v28 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_u16((uint16x8_t)v21, v26), v19), v20);
      uint16x8_t v29 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v27, v27, 0x10uLL), 0x10uLL), vsraq_n_u32(v28, v28, 0x10uLL), 0x10uLL);
      uint16x8_t v30 = (uint16x8_t)vmvnq_s8((int8x16_t)v24);
      uint16x8_t v31 = (uint16x8_t)vmvnq_s8((int8x16_t)v23);
      uint32x4_t v32 = vqaddq_u32(vmull_u16(*(uint16x4_t *)v21.i8, *(uint16x4_t *)v30.i8), vmull_u16(*(uint16x4_t *)v26.i8, *(uint16x4_t *)v31.i8));
      uint32x4_t v33 = vqaddq_u32(vmull_high_u16((uint16x8_t)v21, v30), vmull_high_u16(v26, v31));
      uint32x4_t v34 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v32, v19), v20);
      uint32x4_t v35 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v33, v19), v20);
      *(int8x16_t *)v12[v13].i8 = vbslq_s8((int8x16_t)vceqzq_s16(v23), v22, vbslq_s8(v25, v21, (int8x16_t)vqaddq_u16(v29, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v34, v34, 0x10uLL), 0x10uLL), vsraq_n_u32(v35, v35, 0x10uLL), 0x10uLL))));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v36 = v9 + a8;
  if (v36)
  {
    if (a6) {
      __int16 v37 = 0;
    }
    else {
      __int16 v37 = -1;
    }
    int8x8_t v38 = 0;
    v38.i16[3] = v37;
    int8x8_t v39 = 0;
    if (a7) {
      __int16 v40 = 0;
    }
    else {
      __int16 v40 = -1;
    }
    v39.i16[3] = v40;
    uint32x4_t v41 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v42.i64[0] = 0x800000008000;
    v42.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v43 = (int16x4_t)vorr_s8(*v10, v38);
      int16x4_t v44 = vdup_lane_s16(v43, 3);
      int16x4_t v45 = (int16x4_t)vorr_s8(*v12, v39);
      int16x4_t v46 = vdup_lane_s16(v45, 3);
      int8x8_t v47 = (int8x8_t)vceqz_s16(v46);
      uint16x4_t v48 = (uint16x4_t)vbic_s8((int8x8_t)v45, v47);
      uint32x4_t v49 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)v43, v48), v41), v42);
      uint32x4_t v50 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_u16((uint16x4_t)v43, (uint16x4_t)vmvn_s8((int8x8_t)v46)), vmull_u16(v48, (uint16x4_t)vmvn_s8((int8x8_t)v44))), v41), v42);
      *unint64_t v12 = vbsl_s8((int8x8_t)vceqz_s16(v44), (int8x8_t)v45, vbsl_s8(v47, (int8x8_t)v43, (int8x8_t)vqadd_u16(vqshrn_n_u32(vsraq_n_u32(v49, v49, 0x10uLL), 0x10uLL), vqshrn_n_u32(vsraq_n_u32(v50, v50, 0x10uLL), 0x10uLL))));
      int16x4_t v51 = &v10[a5];
      if ((unint64_t)v51 >= v11) {
        uint64_t v52 = -(uint64_t)a4;
      }
      else {
        uint64_t v52 = 0;
      }
      unint64_t v10 = &v51[v52];
      v12 += a5;
      --v36;
    }
    while (v36);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)12,_rgba16_t>(int8x8_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    do
    {
      *(uint16x8_t *)v12[v13].i8 = vqaddq_u16(*(uint16x8_t *)v12[v13].i8, (uint16x8_t)vorrq_s8(*(int8x16_t *)v10[v13].i8, v16));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v17 = v9 + a8;
  if (v17)
  {
    int8x8_t v18 = 0;
    if (a6) {
      __int16 v19 = 0;
    }
    else {
      __int16 v19 = -1;
    }
    v18.i16[3] = v19;
    do
    {
      *unint64_t v12 = vqadd_u16(*v12, (uint16x4_t)vorr_s8(*v10, v18));
      int32x4_t v20 = &v10[a5];
      if ((unint64_t)v20 >= v11) {
        uint64_t v21 = -(uint64_t)a4;
      }
      else {
        uint64_t v21 = 0;
      }
      unint64_t v10 = &v20[v21];
      v12 += a5;
      --v17;
    }
    while (v17);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)11,_rgba16_t>(int8x8_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, int a6, int a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    int8x16_t v15 = (int8x16_t)vdupq_n_s16(v14);
    v16.i64[0] = 0xFFFF000000000000;
    v16.i64[1] = 0xFFFF000000000000;
    if (a7) {
      unsigned int v17 = 0;
    }
    else {
      unsigned int v17 = -1;
    }
    int8x16_t v18 = vandq_s8(v15, v16);
    int8x16_t v19 = vandq_s8((int8x16_t)vdupq_n_s16(v17), v16);
    do
    {
      int8x16_t v20 = vorrq_s8(*(int8x16_t *)v10[v13].i8, v18);
      int8x16_t v21 = vorrq_s8(*(int8x16_t *)v12[v13].i8, v19);
      uint16x8_t v22 = (uint16x8_t)vqtbl1q_s8(v20, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v23 = (uint16x8_t)vqtbl1q_s8(v21, (int8x16_t)xmmword_1850CD880);
      *(uint16x8_t *)v12[v13].i8 = vqsubq_u16(vqaddq_u16(v23, v22), vqaddq_u16(vqsubq_u16(v22, (uint16x8_t)v20), vqsubq_u16(v23, (uint16x8_t)v21)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v24 = v9 + a8;
  if (v24)
  {
    int8x8_t v25 = 0;
    if (a6) {
      __int16 v26 = 0;
    }
    else {
      __int16 v26 = -1;
    }
    int8x8_t v27 = 0;
    v27.i16[3] = v26;
    if (a7) {
      __int16 v28 = 0;
    }
    else {
      __int16 v28 = -1;
    }
    v25.i16[3] = v28;
    do
    {
      int16x4_t v29 = (int16x4_t)vorr_s8(*v10, v27);
      int16x4_t v30 = (int16x4_t)vorr_s8(*v12, v25);
      uint16x4_t v31 = (uint16x4_t)vdup_lane_s16(v29, 3);
      uint16x4_t v32 = (uint16x4_t)vdup_lane_s16(v30, 3);
      *unint64_t v12 = (int8x8_t)vqsub_u16(vqadd_u16(v32, v31), vqadd_u16(vqsub_u16(v31, (uint16x4_t)v29), vqsub_u16(v32, (uint16x4_t)v30)));
      uint32x4_t v33 = &v10[a5];
      if ((unint64_t)v33 >= v11) {
        uint64_t v34 = -(uint64_t)a4;
      }
      else {
        uint64_t v34 = 0;
      }
      unint64_t v10 = &v33[v34];
      v12 += a5;
      --v24;
    }
    while (v24);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint16x4_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)10,_rgba16_t>(uint16x4_t **result, int8x8_t **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    uint32x4_t v14 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v15.i64[0] = 0x800000008000;
    v15.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v16 = *(int8x16_t *)v10[v13].i8;
      int8x16_t v17 = *(int8x16_t *)v12[v13].i8;
      uint16x8_t v18 = (uint16x8_t)vmvnq_s8(v17);
      uint16x8_t v19 = (uint16x8_t)vmvnq_s8(v16);
      uint32x4_t v20 = vqaddq_u32(vmull_lane_u16(*(uint16x4_t *)v16.i8, *(uint16x4_t *)v18.i8, 3), vmull_lane_u16(*(uint16x4_t *)v17.i8, *(uint16x4_t *)v19.i8, 3));
      uint32x4_t v21 = vqaddq_u32(vmull_high_laneq_u16((uint16x8_t)v16, v18, 7), vmull_high_laneq_u16((uint16x8_t)v17, v19, 7));
      uint32x4_t v22 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v20, v14), v15);
      uint32x4_t v23 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v21, v14), v15);
      *(uint16x8_t *)v12[v13].i8 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v22, v22, 0x10uLL), 0x10uLL), vsraq_n_u32(v23, v23, 0x10uLL), 0x10uLL);
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int8x8_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (uint16x4_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v24 = v9 + a8;
  if (v24)
  {
    uint32x4_t v25 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v26.i64[0] = 0x800000008000;
    v26.i64[1] = 0x800000008000;
    do
    {
      uint32x4_t v27 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vqaddq_u32(vmull_lane_u16(*v10, (uint16x4_t)vmvn_s8(*v12), 3), vmull_lane_u16((uint16x4_t)*v12, (uint16x4_t)vmvn_s8((int8x8_t)*v10), 3)), v25), v26);
      *unint64_t v12 = (int8x8_t)vqshrn_n_u32(vsraq_n_u32(v27, v27, 0x10uLL), 0x10uLL);
      __int16 v28 = &v10[a5];
      if ((unint64_t)v28 >= v11) {
        uint64_t v29 = -(uint64_t)a4;
      }
      else {
        uint64_t v29 = 0;
      }
      unint64_t v10 = &v28[v29];
      v12 += a5;
      --v24;
    }
    while (v24);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint16x4_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)9,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    uint32x4_t v14 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v15.i64[0] = 0x800000008000;
    v15.i64[1] = 0x800000008000;
    do
    {
      uint16x8_t v16 = *(uint16x8_t *)v10[v13].i8;
      uint16x8_t v17 = *(uint16x8_t *)v12[v13].i8;
      uint32x4_t v18 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v16.i8, *(uint16x4_t *)v17.i8, 3), v14), v15);
      uint32x4_t v19 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v16, v17, 7), v14), v15);
      uint16x8_t v20 = vqsubq_u16(v16, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v18, v18, 0x10uLL), 0x10uLL), vsraq_n_u32(v19, v19, 0x10uLL), 0x10uLL));
      uint32x4_t v21 = vmull_lane_u16(*(uint16x4_t *)v17.i8, *(uint16x4_t *)v16.i8, 3);
      uint32x4_t v22 = vmull_high_laneq_u16(v17, v16, 7);
      uint32x4_t v23 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v21, v14), v15);
      uint32x4_t v24 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v22, v14), v15);
      *(uint16x8_t *)v12[v13].i8 = vqaddq_u16(v20, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v23, v23, 0x10uLL), 0x10uLL), vsraq_n_u32(v24, v24, 0x10uLL), 0x10uLL));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (uint16x4_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v25 = v9 + a8;
  if (v25)
  {
    uint32x4_t v26 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v27.i64[0] = 0x800000008000;
    v27.i64[1] = 0x800000008000;
    do
    {
      uint32x4_t v28 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v10, *v12, 3), v26), v27);
      uint32x4_t v29 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v12, *v10, 3), v26), v27);
      *unint64_t v12 = vqadd_u16(vqsub_u16(*v10, vqshrn_n_u32(vsraq_n_u32(v28, v28, 0x10uLL), 0x10uLL)), vqshrn_n_u32(vsraq_n_u32(v29, v29, 0x10uLL), 0x10uLL));
      int16x4_t v30 = &v10[a5];
      if ((unint64_t)v30 >= v11) {
        uint64_t v31 = -(uint64_t)a4;
      }
      else {
        uint64_t v31 = 0;
      }
      unint64_t v10 = &v30[v31];
      v12 += a5;
      --v25;
    }
    while (v25);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint16x4_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)8,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    uint32x4_t v14 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v15.i64[0] = 0x800000008000;
    v15.i64[1] = 0x800000008000;
    do
    {
      uint16x8_t v16 = *(uint16x8_t *)v10[v13].i8;
      uint16x8_t v17 = *(uint16x8_t *)v12[v13].i8;
      uint32x4_t v18 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v17.i8, *(uint16x4_t *)v16.i8, 3), v14), v15);
      uint32x4_t v19 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v17, v16, 7), v14), v15);
      *(uint16x8_t *)v12[v13].i8 = vqsubq_u16(v17, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v18, v18, 0x10uLL), 0x10uLL), vsraq_n_u32(v19, v19, 0x10uLL), 0x10uLL));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (uint16x4_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v20 = v9 + a8;
  if (v20)
  {
    uint32x4_t v21 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v22.i64[0] = 0x800000008000;
    v22.i64[1] = 0x800000008000;
    do
    {
      uint32x4_t v23 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v12, *v10, 3), v21), v22);
      *unint64_t v12 = vqsub_u16(*v12, vqshrn_n_u32(vsraq_n_u32(v23, v23, 0x10uLL), 0x10uLL));
      uint32x4_t v24 = &v10[a5];
      if ((unint64_t)v24 >= v11) {
        uint64_t v25 = -(uint64_t)a4;
      }
      else {
        uint64_t v25 = 0;
      }
      unint64_t v10 = &v24[v25];
      v12 += a5;
      --v20;
    }
    while (v20);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint16x4_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)7,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    uint32x4_t v14 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v15.i64[0] = 0x800000008000;
    v15.i64[1] = 0x800000008000;
    do
    {
      uint16x8_t v16 = *(uint16x8_t *)v10[v13].i8;
      uint16x8_t v17 = *(uint16x8_t *)v12[v13].i8;
      uint32x4_t v18 = vmull_lane_u16(*(uint16x4_t *)v17.i8, *(uint16x4_t *)v16.i8, 3);
      uint32x4_t v19 = vmull_high_laneq_u16(v17, v16, 7);
      uint32x4_t v20 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v18, v14), v15);
      uint32x4_t v21 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v19, v14), v15);
      *(uint16x8_t *)v12[v13].i8 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v20, v20, 0x10uLL), 0x10uLL), vsraq_n_u32(v21, v21, 0x10uLL), 0x10uLL);
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (uint16x4_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v22 = v9 + a8;
  if (v22)
  {
    uint32x4_t v23 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v24.i64[0] = 0x800000008000;
    v24.i64[1] = 0x800000008000;
    do
    {
      uint32x4_t v25 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v12, *v10, 3), v23), v24);
      *unint64_t v12 = vqshrn_n_u32(vsraq_n_u32(v25, v25, 0x10uLL), 0x10uLL);
      uint32x4_t v26 = &v10[a5];
      if ((unint64_t)v26 >= v11) {
        uint64_t v27 = -(uint64_t)a4;
      }
      else {
        uint64_t v27 = 0;
      }
      unint64_t v10 = &v26[v27];
      v12 += a5;
      --v22;
    }
    while (v22);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)6,_rgba16_t>(int8x8_t **result, int16x4_t **a2, unint64_t *a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    uint32x4_t v17 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v18.i64[0] = 0x800000008000;
    v18.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v19 = *(int8x16_t *)v12[v13].i8;
      uint16x8_t v20 = (uint16x8_t)vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      int16x8_t v21 = (int16x8_t)vqtbl1q_s8(v19, (int8x16_t)xmmword_1850CD880);
      uint16x8_t v22 = (uint16x8_t)vbicq_s8(v19, (int8x16_t)vceqzq_s16(v21));
      uint16x8_t v23 = (uint16x8_t)vmvnq_s8((int8x16_t)v21);
      uint32x4_t v24 = vmull_u16(*(uint16x4_t *)v20.i8, *(uint16x4_t *)v23.i8);
      uint32x4_t v25 = vmull_high_u16(v20, v23);
      uint32x4_t v26 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v24, v17), v18);
      uint32x4_t v27 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v25, v17), v18);
      *(uint16x8_t *)v12[v13].i8 = vqaddq_u16(v22, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v26, v26, 0x10uLL), 0x10uLL), vsraq_n_u32(v27, v27, 0x10uLL), 0x10uLL));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (int16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v28 = v9 + a8;
  if (v28)
  {
    int8x8_t v29 = 0;
    if (a6) {
      __int16 v30 = 0;
    }
    else {
      __int16 v30 = -1;
    }
    v29.i16[3] = v30;
    uint32x4_t v31 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v32.i64[0] = 0x800000008000;
    v32.i64[1] = 0x800000008000;
    do
    {
      int16x4_t v33 = vdup_lane_s16(*v12, 3);
      uint32x4_t v34 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_u16((uint16x4_t)vorr_s8(*v10, v29), (uint16x4_t)vmvn_s8((int8x8_t)v33)), v31), v32);
      *unint64_t v12 = (int16x4_t)vqadd_u16((uint16x4_t)vbic_s8((int8x8_t)*v12, (int8x8_t)vceqz_s16(v33)), vqshrn_n_u32(vsraq_n_u32(v34, v34, 0x10uLL), 0x10uLL));
      uint32x4_t v35 = &v10[a5];
      if ((unint64_t)v35 >= v11) {
        uint64_t v36 = -(uint64_t)a4;
      }
      else {
        uint64_t v36 = 0;
      }
      unint64_t v10 = &v35[v36];
      v12 += a5;
      --v28;
    }
    while (v28);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint16x4_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)5,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    uint32x4_t v14 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v15.i64[0] = 0x800000008000;
    v15.i64[1] = 0x800000008000;
    do
    {
      uint16x8_t v16 = *(uint16x8_t *)v10[v13].i8;
      uint16x8_t v17 = *(uint16x8_t *)v12[v13].i8;
      uint32x4_t v18 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v17.i8, *(uint16x4_t *)v16.i8, 3), v14), v15);
      uint32x4_t v19 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v17, v16, 7), v14), v15);
      uint16x8_t v20 = vqsubq_u16(v17, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v18, v18, 0x10uLL), 0x10uLL), vsraq_n_u32(v19, v19, 0x10uLL), 0x10uLL));
      uint32x4_t v21 = vmull_lane_u16(*(uint16x4_t *)v16.i8, *(uint16x4_t *)v17.i8, 3);
      uint32x4_t v22 = vmull_high_laneq_u16(v16, v17, 7);
      uint32x4_t v23 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v21, v14), v15);
      uint32x4_t v24 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v22, v14), v15);
      *(uint16x8_t *)v12[v13].i8 = vqaddq_u16(v20, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v23, v23, 0x10uLL), 0x10uLL), vsraq_n_u32(v24, v24, 0x10uLL), 0x10uLL));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (uint16x4_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v25 = v9 + a8;
  if (v25)
  {
    uint32x4_t v26 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v27.i64[0] = 0x800000008000;
    v27.i64[1] = 0x800000008000;
    do
    {
      uint32x4_t v28 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v12, *v10, 3), v26), v27);
      uint32x4_t v29 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v10, *v12, 3), v26), v27);
      *unint64_t v12 = vqadd_u16(vqsub_u16(*v12, vqshrn_n_u32(vsraq_n_u32(v28, v28, 0x10uLL), 0x10uLL)), vqshrn_n_u32(vsraq_n_u32(v29, v29, 0x10uLL), 0x10uLL));
      __int16 v30 = &v10[a5];
      if ((unint64_t)v30 >= v11) {
        uint64_t v31 = -(uint64_t)a4;
      }
      else {
        uint64_t v31 = 0;
      }
      unint64_t v10 = &v30[v31];
      v12 += a5;
      --v25;
    }
    while (v25);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)4,_rgba16_t>(int8x8_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    uint32x4_t v17 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v18.i64[0] = 0x800000008000;
    v18.i64[1] = 0x800000008000;
    do
    {
      uint16x8_t v19 = *(uint16x8_t *)v12[v13].i8;
      uint16x8_t v20 = (uint16x8_t)vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      uint32x4_t v21 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v20.i8, *(uint16x4_t *)v19.i8, 3), v17), v18);
      uint32x4_t v22 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v20, v19, 7), v17), v18);
      *(uint16x8_t *)v12[v13].i8 = vqsubq_u16(v20, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v21, v21, 0x10uLL), 0x10uLL), vsraq_n_u32(v22, v22, 0x10uLL), 0x10uLL));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v23 = v9 + a8;
  if (v23)
  {
    int8x8_t v24 = 0;
    if (a6) {
      __int16 v25 = 0;
    }
    else {
      __int16 v25 = -1;
    }
    v24.i16[3] = v25;
    uint32x4_t v26 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v27.i64[0] = 0x800000008000;
    v27.i64[1] = 0x800000008000;
    do
    {
      uint16x4_t v28 = (uint16x4_t)vorr_s8(*v10, v24);
      uint32x4_t v29 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(v28, *v12, 3), v26), v27);
      *unint64_t v12 = vqsub_u16(v28, vqshrn_n_u32(vsraq_n_u32(v29, v29, 0x10uLL), 0x10uLL));
      __int16 v30 = &v10[a5];
      if ((unint64_t)v30 >= v11) {
        uint64_t v31 = -(uint64_t)a4;
      }
      else {
        uint64_t v31 = 0;
      }
      unint64_t v10 = &v30[v31];
      v12 += a5;
      --v23;
    }
    while (v23);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

int8x8_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)3,_rgba16_t>(int8x8_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    if (a6) {
      unsigned int v14 = 0;
    }
    else {
      unsigned int v14 = -1;
    }
    v15.i64[0] = 0xFFFF000000000000;
    v15.i64[1] = 0xFFFF000000000000;
    int8x16_t v16 = vandq_s8((int8x16_t)vdupq_n_s16(v14), v15);
    uint32x4_t v17 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v18.i64[0] = 0x800000008000;
    v18.i64[1] = 0x800000008000;
    do
    {
      uint16x8_t v19 = *(uint16x8_t *)v12[v13].i8;
      uint16x8_t v20 = (uint16x8_t)vorrq_s8(*(int8x16_t *)v10[v13].i8, v16);
      uint32x4_t v21 = vmull_lane_u16(*(uint16x4_t *)v20.i8, *(uint16x4_t *)v19.i8, 3);
      uint32x4_t v22 = vmull_high_laneq_u16(v20, v19, 7);
      uint32x4_t v23 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v21, v17), v18);
      uint32x4_t v24 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(v22, v17), v18);
      *(uint16x8_t *)v12[v13].i8 = vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v23, v23, 0x10uLL), 0x10uLL), vsraq_n_u32(v24, v24, 0x10uLL), 0x10uLL);
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (int8x8_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v25 = v9 + a8;
  if (v25)
  {
    int8x8_t v26 = 0;
    if (a6) {
      __int16 v27 = 0;
    }
    else {
      __int16 v27 = -1;
    }
    v26.i16[3] = v27;
    uint32x4_t v28 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v29.i64[0] = 0x800000008000;
    v29.i64[1] = 0x800000008000;
    do
    {
      uint32x4_t v30 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16((uint16x4_t)vorr_s8(*v10, v26), *v12, 3), v28), v29);
      *unint64_t v12 = vqshrn_n_u32(vsraq_n_u32(v30, v30, 0x10uLL), 0x10uLL);
      uint64_t v31 = &v10[a5];
      if ((unint64_t)v31 >= v11) {
        uint64_t v32 = -(uint64_t)a4;
      }
      else {
        uint64_t v32 = 0;
      }
      unint64_t v10 = &v31[v32];
      v12 += a5;
      --v25;
    }
    while (v25);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint16x4_t **VEC::template_mark_pixelshape_row<(CGCompositeOperation)2,_rgba16_t>(uint16x4_t **result, uint16x4_t **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    uint32x4_t v14 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v15.i64[0] = 0x800000008000;
    v15.i64[1] = 0x800000008000;
    do
    {
      int8x16_t v16 = *(int8x16_t *)v10[v13].i8;
      uint16x8_t v17 = *(uint16x8_t *)v12[v13].i8;
      uint16x8_t v18 = (uint16x8_t)vbicq_s8(v16, (int8x16_t)vceqzq_s16((int16x8_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1850CD880)));
      uint32x4_t v19 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*(uint16x4_t *)v17.i8, *(uint16x4_t *)v16.i8, 3), v14), v15);
      uint32x4_t v20 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_high_laneq_u16(v17, (uint16x8_t)v16, 7), v14), v15);
      *(uint16x8_t *)v12[v13].i8 = vqaddq_u16(v18, vqsubq_u16(v17, vqshrn_high_n_u32(vqshrn_n_u32(vsraq_n_u32(v19, v19, 0x10uLL), 0x10uLL), vsraq_n_u32(v20, v20, 0x10uLL), 0x10uLL)));
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (uint16x4_t *)((char *)v12 + v13 * 8);
    unint64_t v10 = (uint16x4_t *)((char *)v10 + v13 * 8);
  }
  uint64_t v21 = v9 + a8;
  if (v21)
  {
    uint32x4_t v22 = (uint32x4_t)vdupq_n_s32(0xFFFE8000);
    v23.i64[0] = 0x800000008000;
    v23.i64[1] = 0x800000008000;
    do
    {
      uint32x4_t v24 = (uint32x4_t)vaddq_s32((int32x4_t)vminq_u32(vmull_lane_u16(*v12, *v10, 3), v22), v23);
      *unint64_t v12 = vqadd_u16((uint16x4_t)vbic_s8((int8x8_t)*v10, (int8x8_t)vceqz_s16(vdup_lane_s16((int16x4_t)*v10, 3))), vqsub_u16(*v12, vqshrn_n_u32(vsraq_n_u32(v24, v24, 0x10uLL), 0x10uLL)));
      uint64_t v25 = &v10[a5];
      if ((unint64_t)v25 >= v11) {
        uint64_t v26 = -(uint64_t)a4;
      }
      else {
        uint64_t v26 = 0;
      }
      unint64_t v10 = &v25[v26];
      v12 += a5;
      --v21;
    }
    while (v21);
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

void **VEC::template_mark_pixelshape_row<(CGCompositeOperation)1,_rgba16_t>(void **result, void **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    do
    {
      *(_OWORD *)&v12[v13] = *(_OWORD *)&v10[v13];
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (void *)((char *)v12 + v13 * 8);
    unint64_t v10 = (void *)((char *)v10 + v13 * 8);
  }
  for (uint64_t i = v9 + a8; i; --i)
  {
    *unint64_t v12 = *v10;
    int32x4_t v15 = &v10[a5];
    if ((unint64_t)v15 >= v11) {
      uint64_t v16 = -(uint64_t)a4;
    }
    else {
      uint64_t v16 = 0;
    }
    unint64_t v10 = &v15[v16];
    v12 += a5;
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

uint64_t *VEC::template_mark_pixelshape_row<(CGCompositeOperation)0,_rgba16_t>(uint64_t *result, void **a2, unint64_t *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
  unint64_t v9 = a9;
  unint64_t v10 = *result;
  unint64_t v11 = *a3;
  unint64_t v12 = *a2;
  if (a9 >= 2)
  {
    uint64_t v13 = 0;
    do
    {
      *(_OWORD *)&v12[v13] = 0uLL;
      v9 -= 2;
      v13 += 2 * a5;
    }
    while (v9 > 1);
    unint64_t v12 = (void *)((char *)v12 + v13 * 8);
    v10 += v13 * 8;
  }
  for (uint64_t i = v9 + a8; i; --i)
  {
    *unint64_t v12 = 0;
    unint64_t v15 = v10 + 8 * a5;
    if (v15 >= v11) {
      uint64_t v16 = -(uint64_t)a4;
    }
    else {
      uint64_t v16 = 0;
    }
    unint64_t v10 = v15 + 8 * v16;
    v12 += a5;
  }
  *size_t result = v10;
  *a3 = v11;
  *a2 = v12;
  return result;
}

void set_initial_group_gstate(uint64_t a1)
{
  if (a1)
  {
    CGColorSpaceRef v2 = *(const void **)(a1 + 264);
    if (v2)
    {
      CFRelease(v2);
      *(void *)(a1 + 264) = 0;
    }
    CGPDFGStateSetFillAlpha(a1, 1.0);
    CGPDFGStateSetStrokeAlpha(a1, 1.0);
    CFDataRef v3 = *(const void **)(a1 + 192);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 192) = 0;
    }
    *(_DWORD *)(a1 + 184) = 0;
  }
  else
  {
    CGPDFGStateSetFillAlpha(0, 1.0);
    CGPDFGStateSetStrokeAlpha(0, 1.0);
  }
}

char *CGPDFDrawingContextCreateWithContentStream(const void *a1, uint64_t a2)
{
  uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0xC8uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v4)
  {
    v4[8] = 0;
    *((void *)v4 + 13) = 0;
    v4[112] = 1;
    if (a1) {
      CFRetain(a1);
    }
    *(void *)uint64_t v4 = a1;
    *(_OWORD *)(v4 + ++*(_DWORD *)(result + 40) = xmmword_1850CD840;
    *((void *)v4 + 7) = malloc_type_malloc(0x40uLL, 0x2004093837F09uLL);
    if (a2) {
      CopCGFloat y = CGPDFGStateCreateCopy(*(long long **)(a2 + 32));
    }
    else {
      CopCGFloat y = CGPDFGStateCreate();
    }
    unint64_t v6 = *((void *)v4 + 6);
    **((void **)v4 + 7) = Copy;
    if (v6 >= 2)
    {
      for (unint64_t i = 1; i < v9; ++i)
      {
        uint64_t v8 = CGPDFGStateCreate();
        unint64_t v9 = *((void *)v4 + 6);
        *(void *)(*((void *)v4 + 7) + 8 * i) = v8;
      }
    }
    unint64_t v10 = (long long **)*((void *)v4 + 7);
    unint64_t v11 = *v10;
    *((void *)v4 + 4) = *v10;
    if (a2)
    {
      uint64_t v12 = *(void *)(a2 + 16);
      uint64_t v13 = *(void *)(a2 + 88);
      *(_OWORD *)(v4 + 184) = *(_OWORD *)(a2 + 184);
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
    }
    *((void *)v4 + 2) = v12;
    *((void *)v4 + 11) = v13;
    if (*(void *)v4 && v11)
    {
      *((void *)v4 + 3) = CGPDFGStateCreateCopy(v11);
    }
    else
    {
      CGPDFDrawingContextRelease(v4);
      return 0;
    }
  }
  return v4;
}

BOOL CGPDFDrawingContextShouldDrawOCG(uint64_t a1, uint64_t a2, unsigned __int16 a3)
{
  if (a1)
  {
    if (*(void *)(a1 + 104) && (a2 | a3) != 0)
    {
      unint64_t valuePtr = a3 | (unint64_t)(a2 << 36);
      CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
      CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), v6);
      CFRelease(v6);
      if (Value == (const void *)*MEMORY[0x1E4F1CFD0]) {
        return 1;
      }
      if (Value == (const void *)*MEMORY[0x1E4F1CFC8]) {
        return 0;
      }
    }
  }
  return *(unsigned char *)(a1 + 112) != 0;
}

char *CGPDFDrawingContextCreateWithStream(CGPDFStream *a1, CGPDFDictionary *a2, CGPDFContentStreamRef *a3)
{
  if (a3)
  {
    CGPDFContentStreamRef v4 = CGPDFContentStreamCreateWithStream(a1, a2, *a3);
    CGPDFContentStreamRef v5 = v4;
    uint64_t v6 = (uint64_t)a3;
  }
  else
  {
    CGPDFContentStreamRef v4 = CGPDFContentStreamCreateWithStream(a1, a2, 0);
    CGPDFContentStreamRef v5 = v4;
    uint64_t v6 = 0;
  }
  CFStringRef v7 = CGPDFDrawingContextCreateWithContentStream(v4, v6);
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

void CGPDFDrawingContextDraw(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!CGContextIsEmptyClipBoundingBox(a2, a2, a3, a4, a5, a6, a7, a8))
  {
    *(void *)(a1 + ++*(_DWORD *)(result + 88) = a2;
    uint64_t GStateMark = CGContextGetGStateMark(a2, v10, v11, v12, v13, v14, v15, v16);
    if (CGPDFDrawingContextGetOperatorTable_predicate != -1) {
      dispatch_once(&CGPDFDrawingContextGetOperatorTable_predicate, &__block_literal_global_7866);
    }
    uint16x8_t v18 = CGPDFScannerCreate(*(CGPDFContentStreamRef *)a1, (CGPDFOperatorTableRef)CGPDFDrawingContextGetOperatorTable_operator_table, (void *)a1);
    CGPDFScannerScan(v18);
    if (v18) {
      CFRelease(v18);
    }
    CGContextRestoreToGStateMark(a2, GStateMark, v19, v20, v21, v22, v23, v24);
  }
}

void CGPDFDrawingContextDrawWithContentTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!CGContextIsEmptyClipBoundingBox(a2, a2, a3, a4, a5, a6, a7, a8))
  {
    *(void *)(a1 + ++*(_DWORD *)(result + 88) = a2;
    uint64_t GStateMark = CGContextGetGStateMark(a2, v11, v12, v13, v14, v15, v16, v17);
    if (CGPDFDrawingContextGetOperatorTable_predicate != -1) {
      dispatch_once(&CGPDFDrawingContextGetOperatorTable_predicate, &__block_literal_global_7866);
    }
    if (a3 == 0xFFFFFFFFLL) {
      ContentTypesTable = (CGPDFOperatorTable *)CGPDFDrawingContextGetOperatorTable_operator_table;
    }
    else {
      ContentTypesTable = CGPDFDrawingContextCreateContentTypesTable(a3);
    }
    uint64_t v20 = CGPDFScannerCreate(*(CGPDFContentStreamRef *)a1, ContentTypesTable, (void *)a1);
    CGPDFScannerScan(v20);
    if (v20) {
      CFRelease(v20);
    }
    if (a3 != 0xFFFFFFFFLL && ContentTypesTable) {
      CFRelease(ContentTypesTable);
    }
    CGContextRestoreToGStateMark(a2, GStateMark, v21, v22, v23, v24, v25, v26);
  }
}

void CGPDFDrawingContextDrawStream(CGPDFContentStreamRef *a1, CGPDFStream *a2, CGPDFDictionary *a3, long long *a4, uint64_t a5)
{
  CFStringRef v7 = CGPDFDrawingContextCreateWithStream(a2, a3, a1);
  uint64_t v14 = (uint64_t)v7;
  if (a4)
  {
    uint64_t v15 = (void **)*((void *)v7 + 7);
    uint64_t v16 = *v15;
    if (*v15)
    {
      CGPDFGStateReleaseProperties(*v15);
      free(v16);
    }
    **(void **)(v14 + 56) = CGPDFGStateCreateCopy(a4);
    *(void *)(v14 + 32) = **(void **)(v14 + 56);
  }
  CGPDFDrawingContextDraw(v14, a5, v8, v9, v10, v11, v12, v13);

  CGPDFDrawingContextRelease((void *)v14);
}

void CGPDFDrawingContextDrawGlyphStream(CGPDFContentStreamRef *a1, CGPDFStream *a2, CGPDFDictionary *a3, uint64_t a4)
{
  CGPDFContentStreamRef v5 = CGPDFDrawingContextCreateWithStream(a2, a3, a1);
  v5[8] = 1;
  CGPDFDrawingContextDraw((uint64_t)v5, a4, v6, v7, v8, v9, v10, v11);

  CGPDFDrawingContextRelease(v5);
}

uint64_t CGApplyGainMapHeadRoom_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))CGApplyGainMapHeadRoom_ptr[0])(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t CGBufIsConstantValue_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CGBufIsConstantValue_ptr(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1850C38F8()
{
  return MEMORY[0x1F40E37E0]();
}

uint64_t sub_1850C3908()
{
  return MEMORY[0x1F40E3800]();
}

uint64_t sub_1850C3918()
{
  return MEMORY[0x1F40E3818]();
}

uint64_t sub_1850C3928()
{
  return MEMORY[0x1F40E4CD8]();
}

uint64_t sub_1850C3938()
{
  return MEMORY[0x1F41836A8]();
}

uint64_t sub_1850C3948()
{
  return MEMORY[0x1F41836E8]();
}

uint64_t sub_1850C3958()
{
  return MEMORY[0x1F4183730]();
}

uint64_t sub_1850C3968()
{
  return MEMORY[0x1F4183740]();
}

uint64_t sub_1850C3978()
{
  return MEMORY[0x1F4183748]();
}

uint64_t sub_1850C3988()
{
  return MEMORY[0x1F4183750]();
}

uint64_t sub_1850C3998()
{
  return MEMORY[0x1F4183758]();
}

uint64_t sub_1850C39A8()
{
  return MEMORY[0x1F4183760]();
}

uint64_t sub_1850C39B8()
{
  return MEMORY[0x1F4183768]();
}

uint64_t sub_1850C39C8()
{
  return MEMORY[0x1F4183838]();
}

uint64_t sub_1850C39D8()
{
  return MEMORY[0x1F41838B8]();
}

uint64_t sub_1850C39E8()
{
  return MEMORY[0x1F4183A38]();
}

uint64_t sub_1850C39F8()
{
  return MEMORY[0x1F4183BA8]();
}

uint64_t sub_1850C3A08()
{
  return MEMORY[0x1F4183BB0]();
}

uint64_t sub_1850C3A18()
{
  return MEMORY[0x1F4183BB8]();
}

uint64_t sub_1850C3A28()
{
  return MEMORY[0x1F4183BF8]();
}

uint64_t sub_1850C3A38()
{
  return MEMORY[0x1F4183C18]();
}

uint64_t sub_1850C3A48()
{
  return MEMORY[0x1F4183C68]();
}

uint64_t sub_1850C3A58()
{
  return MEMORY[0x1F4183D70]();
}

uint64_t sub_1850C3A68()
{
  return MEMORY[0x1F40E6348]();
}

uint64_t sub_1850C3A78()
{
  return MEMORY[0x1F4183F08]();
}

uint64_t sub_1850C3A88()
{
  return MEMORY[0x1F4184008]();
}

uint64_t sub_1850C3A98()
{
  return MEMORY[0x1F4184018]();
}

uint64_t sub_1850C3AA8()
{
  return MEMORY[0x1F41842A0]();
}

uint64_t sub_1850C3AB8()
{
  return MEMORY[0x1F41842D0]();
}

uint64_t sub_1850C3AC8()
{
  return MEMORY[0x1F4184300]();
}

uint64_t sub_1850C3AD8()
{
  return MEMORY[0x1F4184310]();
}

uint64_t sub_1850C3AE8()
{
  return MEMORY[0x1F4184328]();
}

uint64_t sub_1850C3AF8()
{
  return MEMORY[0x1F4184330]();
}

uint64_t sub_1850C3B08()
{
  return MEMORY[0x1F4184390]();
}

uint64_t sub_1850C3B18()
{
  return MEMORY[0x1F41843A0]();
}

uint64_t sub_1850C3B28()
{
  return MEMORY[0x1F41843A8]();
}

uint64_t sub_1850C3B38()
{
  return MEMORY[0x1F41843D0]();
}

uint64_t sub_1850C3B48()
{
  return MEMORY[0x1F4184410]();
}

uint64_t sub_1850C3B58()
{
  return MEMORY[0x1F4184430]();
}

uint64_t sub_1850C3B68()
{
  return MEMORY[0x1F4184440]();
}

uint64_t sub_1850C3B78()
{
  return MEMORY[0x1F41845B0]();
}

uint64_t sub_1850C3B88()
{
  return MEMORY[0x1F4184640]();
}

uint64_t sub_1850C3B98()
{
  return MEMORY[0x1F41846A8]();
}

uint64_t sub_1850C3BA8()
{
  return MEMORY[0x1F41846B8]();
}

uint64_t sub_1850C3BB8()
{
  return MEMORY[0x1F41846C8]();
}

uint64_t sub_1850C3BC8()
{
  return MEMORY[0x1F41847A0]();
}

uint64_t sub_1850C3BD8()
{
  return MEMORY[0x1F41848C0]();
}

uint64_t sub_1850C3BE8()
{
  return MEMORY[0x1F41848C8]();
}

uint64_t sub_1850C3BF8()
{
  return MEMORY[0x1F41848E0]();
}

uint64_t sub_1850C3C08()
{
  return MEMORY[0x1F41848F8]();
}

uint64_t sub_1850C3C18()
{
  return MEMORY[0x1F4184910]();
}

uint64_t sub_1850C3C28()
{
  return MEMORY[0x1F4184918]();
}

uint64_t sub_1850C3C38()
{
  return MEMORY[0x1F4184938]();
}

uint64_t sub_1850C3C48()
{
  return MEMORY[0x1F4184940]();
}

uint64_t sub_1850C3C58()
{
  return MEMORY[0x1F4184950]();
}

uint64_t sub_1850C3C78()
{
  return MEMORY[0x1F4184AD8]();
}

uint64_t sub_1850C3C88()
{
  return MEMORY[0x1F4184AE0]();
}

uint64_t sub_1850C3C98()
{
  return MEMORY[0x1F4184AE8]();
}

uint64_t sub_1850C3CA8()
{
  return MEMORY[0x1F4184AF0]();
}

uint64_t sub_1850C3CB8()
{
  return MEMORY[0x1F4184AF8]();
}

uint64_t sub_1850C3CC8()
{
  return MEMORY[0x1F4184B00]();
}

uint64_t sub_1850C3CE8()
{
  return MEMORY[0x1F4184CE8]();
}

uint64_t sub_1850C3CF8()
{
  return MEMORY[0x1F4184DC0]();
}

uint64_t sub_1850C3D08()
{
  return MEMORY[0x1F4184DF0]();
}

uint64_t sub_1850C3D18()
{
  return MEMORY[0x1F4185050]();
}

uint64_t sub_1850C3D28()
{
  return MEMORY[0x1F41852A0]();
}

uint64_t sub_1850C3D38()
{
  return MEMORY[0x1F4185598]();
}

uint64_t sub_1850C3D48()
{
  return MEMORY[0x1F41856C0]();
}

uint64_t sub_1850C3D58()
{
  return MEMORY[0x1F4185740]();
}

uint64_t sub_1850C3D68()
{
  return MEMORY[0x1F4185758]();
}

uint64_t sub_1850C3D78()
{
  return MEMORY[0x1F41857F0]();
}

uint64_t sub_1850C3D88()
{
  return MEMORY[0x1F4185818]();
}

uint64_t sub_1850C3D98()
{
  return MEMORY[0x1F4185898]();
}

uint64_t sub_1850C3DA8()
{
  return MEMORY[0x1F41858D8]();
}

uint64_t sub_1850C3DB8()
{
  return MEMORY[0x1F41859C8]();
}

uint64_t sub_1850C3DC8()
{
  return MEMORY[0x1F4185A20]();
}

uint64_t sub_1850C3DD8()
{
  return MEMORY[0x1F4185A40]();
}

uint64_t sub_1850C3DF8()
{
  return MEMORY[0x1F4185CF8]();
}

uint64_t sub_1850C3E08()
{
  return MEMORY[0x1F4185D58]();
}

uint64_t sub_1850C3E18()
{
  return MEMORY[0x1F4185E00]();
}

uint64_t sub_1850C3E28()
{
  return MEMORY[0x1F4185E08]();
}

uint64_t sub_1850C3E38()
{
  return MEMORY[0x1F4185E10]();
}

uint64_t sub_1850C3E48()
{
  return MEMORY[0x1F4185E18]();
}

uint64_t sub_1850C3E58()
{
  return MEMORY[0x1F4185EB0]();
}

uint64_t sub_1850C3E68()
{
  return MEMORY[0x1F4185EC8]();
}

uint64_t sub_1850C3E78()
{
  return MEMORY[0x1F4185EE8]();
}

uint64_t sub_1850C3E88()
{
  return MEMORY[0x1F4185EF0]();
}

uint64_t sub_1850C3E98()
{
  return MEMORY[0x1F4185EF8]();
}

uint64_t sub_1850C3EA8()
{
  return MEMORY[0x1F4185F00]();
}

uint64_t sub_1850C3EB8()
{
  return MEMORY[0x1F4185F28]();
}

uint64_t sub_1850C3EC8()
{
  return MEMORY[0x1F4185F38]();
}

uint64_t sub_1850C3ED8()
{
  return MEMORY[0x1F4185F50]();
}

uint64_t sub_1850C3EE8()
{
  return MEMORY[0x1F4185F60]();
}

uint64_t sub_1850C3EF8()
{
  return MEMORY[0x1F4185FB0]();
}

uint64_t sub_1850C3F08()
{
  return MEMORY[0x1F4185FC8]();
}

uint64_t sub_1850C3F18()
{
  return MEMORY[0x1F4185FD8]();
}

uint64_t sub_1850C3F28()
{
  return MEMORY[0x1F4185FF0]();
}

uint64_t sub_1850C3F58()
{
  return MEMORY[0x1F41862E0]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1F41138B0]();
}

CCCryptorStatus CCCryptorCreate(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x1F40C94B8](*(void *)&op, *(void *)&alg, *(void *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorFinal(CCCryptorRef cryptorRef, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x1F40C94C8](cryptorRef, dataOut, dataOutAvailable, dataOutMoved);
}

CCCryptorStatus CCCryptorRelease(CCCryptorRef cryptorRef)
{
  return MEMORY[0x1F40C9528](cryptorRef);
}

CCCryptorStatus CCCryptorReset(CCCryptorRef cryptorRef, const void *iv)
{
  return MEMORY[0x1F40C9530](cryptorRef, iv);
}

CCCryptorStatus CCCryptorUpdate(CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x1F40C9538](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9718](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9720](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9728](c, data, *(void *)&len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1F40C9778](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1F40C9780](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9788](c, data, *(void *)&len);
}

int CC_SHA384_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x1F40C9798](md, c);
}

int CC_SHA384_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x1F40C97A0](c);
}

int CC_SHA384_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C97A8](c, data, *(void *)&len);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x1F40C97B8](md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x1F40C97C0](c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C97C8](c, data, *(void *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return (CFAllocatorRef)MEMORY[0x1F40D70F8](allocator, context);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71C8](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x1F40D7240](alloc, str, attributes);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1F40D7250](alloc, maxLength);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFAttributedStringRef aStr)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1F40D7258](alloc, maxLength, aStr);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x1F40D7298](aStr);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  return (CFStringRef)MEMORY[0x1F40D72A0](aStr);
}

void CFAttributedStringReplaceAttributedString(CFMutableAttributedStringRef aStr, CFRange range, CFAttributedStringRef replacement)
{
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
}

void CFAttributedStringSetAttributes(CFMutableAttributedStringRef aStr, CFRange range, CFDictionaryRef replacement, Boolean clearOtherAttributes)
{
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1F40D72D8](arg);
}

CFMutableBitVectorRef CFBitVectorCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableBitVectorRef)MEMORY[0x1F40D73B8](allocator, capacity);
}

CFBit CFBitVectorGetBitAtIndex(CFBitVectorRef bv, CFIndex idx)
{
  return MEMORY[0x1F40D73C8](bv, idx);
}

void CFBitVectorSetBits(CFMutableBitVectorRef bv, CFRange range, CFBit value)
{
}

void CFBitVectorSetCount(CFMutableBitVectorRef bv, CFIndex count)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7450](bundle);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1F40D7568](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1F40D7598]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40D75D0](bundle, key);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1F40D7678](calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)MEMORY[0x1F40D7690](allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t v3 = va_arg(va, void);
  return MEMORY[0x1F40D7698](calendar, v3, at);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7740](theSetIdentifier);
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  return MEMORY[0x1F40D7778](theSet, *(void *)&theChar);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1F40D77B8]();
}

uint64_t CFCopySearchPathForDirectoriesInDomains()
{
  return MEMORY[0x1F40D77C0]();
}

uint64_t CFCopySystemVersionString()
{
  return MEMORY[0x1F40D77C8]();
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  return (CFStringRef)MEMORY[0x1F40D77D0](type_id);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1F40D77F8](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7810](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

CFDateFormatterRef CFDateFormatterCreateISO8601Formatter(CFAllocatorRef allocator, CFISO8601DateFormatOptions formatOptions)
{
  return (CFDateFormatterRef)MEMORY[0x1F40D78D0](allocator, formatOptions);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return (CFStringRef)MEMORY[0x1F40D78E0](allocator, formatter, date);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  MEMORY[0x1F40D7928](theDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1F40D7938]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1F40D7A18](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1F40D7A98](allocator, domain, code, userInfo);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7B60](cf);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B68](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFDataRef CFHTTPMessageCopyBody(CFHTTPMessageRef message)
{
  return (CFDataRef)MEMORY[0x1F40D5290](message);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  return (CFHTTPMessageRef)MEMORY[0x1F40D52D8](alloc, requestMethod, url, httpVersion);
}

CFIndex CFHTTPMessageGetResponseStatusCode(CFHTTPMessageRef response)
{
  return MEMORY[0x1F40D52E8](response);
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
}

void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef value)
{
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BE0](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7BE8](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(CFAllocatorRef allocator, uint32_t lcid)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C18](allocator, *(void *)&lcid);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C20](locale);
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)MEMORY[0x1F40D7C38]();
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x1F40D7C48](locale, key);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D20]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1F40D7D68]();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E08](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E30](number);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7ED0](key, applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D7F18](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1F40D7FA0](stream, propertyName);
}

CFReadStreamRef CFReadStreamCreateForHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef request)
{
  return (CFReadStreamRef)MEMORY[0x1F40D5380](alloc, request);
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FB0](alloc, bytes, length, bytesDeallocator);
}

CFReadStreamRef CFReadStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D5388](alloc, ftpURL);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FE0](stream);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8000](stream, buffer, bufferLength);
}

Boolean CFReadStreamSetProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  return MEMORY[0x1F40D8020](stream, propertyName, propertyValue);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  return (const void *)MEMORY[0x1F40D8238](theSet, value);
}

Boolean CFSetGetValueIfPresent(CFSetRef theSet, const void *candidate, const void **value)
{
  return MEMORY[0x1F40D8240](theSet, candidate, value);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1F40D83D0](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1F40D83E0](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1F40D83F8](alloc, theString, *(void *)&encoding, lossByte);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8458](alloc, cStr, *(void *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1F40D8460](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return (CFStringRef)MEMORY[0x1F40D8478](alloc, buffer);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1F40D8498](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D84D0](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1F40D8528](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x1F40D8548](str);
  return result;
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8558](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1F40D8568](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

uint64_t CFStringGetRangeOfCharacterClusterAtIndex()
{
  return MEMORY[0x1F40D85D0]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1F40D8608](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
}

void CFStringReplaceAll(CFMutableStringRef theString, CFStringRef replacement)
{
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x1F40D8698](alloc, string, range.location, range.length, options, locale);
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex v1 = MEMORY[0x1F40D86A8](tokenizer);
  result.length = v2;
  result.location = v1;
  return result;
}

CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(CFStringTokenizerRef tokenizer, CFIndex index)
{
  return MEMORY[0x1F40D86B0](tokenizer, index);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
}

CFTimeZoneRef CFTimeZoneCreateWithName(CFAllocatorRef allocator, CFStringRef name, Boolean tryAbbrev)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D8700](allocator, name, tryAbbrev);
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D8708](allocator, ti);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyFragment(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D8760](anURL, charactersToLeaveEscaped);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFStringRef CFURLCopyParameterString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D8780](anURL, charactersToLeaveEscaped);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8790](anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8798](url);
}

CFStringRef CFURLCopyQueryString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D87A0](anURL, charactersToLeaveEscaped);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1F40D87B0](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87C0](anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyAppendingPathExtension(CFAllocatorRef allocator, CFURLRef url, CFStringRef extension)
{
  return (CFURLRef)MEMORY[0x1F40D8800](allocator, url, extension);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8808](allocator, url);
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8810](allocator, url);
}

CFDataRef CFURLCreateData(CFAllocatorRef allocator, CFURLRef url, CFStringEncoding encoding, Boolean escapeWhitespace)
{
  return (CFDataRef)MEMORY[0x1F40D8820](allocator, url, *(void *)&encoding, escapeWhitespace);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D8848](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8870](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(void *)&encoding);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8888](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8918](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1F40D8988](alloc);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1F40D8A90](stream, propertyName);
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return (CFWriteStreamRef)MEMORY[0x1F40D8AA0](alloc, bufferAllocator);
}

CFWriteStreamRef CFWriteStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  return (CFWriteStreamRef)MEMORY[0x1F40D5520](alloc, ftpURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1F40D8AD0](stream);
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8B08](stream, buffer, bufferLength);
}

uint64_t FPFontCopyGlyphBitmap()
{
  return MEMORY[0x1F4119BC0]();
}

uint64_t FPFontCopyGlyphNameForGlyph()
{
  return MEMORY[0x1F4119BC8]();
}

uint64_t FPFontCopyPostScriptName()
{
  return MEMORY[0x1F4119BF0]();
}

uint64_t FPFontCreateCopyWithVariation()
{
  return MEMORY[0x1F4119C18]();
}

uint64_t FPFontCreateFontSubset()
{
  return MEMORY[0x1F4119C20]();
}

uint64_t FPFontCreateFontsFromData()
{
  return MEMORY[0x1F4119C28]();
}

uint64_t FPFontCreateFontsWithPath()
{
  return MEMORY[0x1F4119C30]();
}

uint64_t FPFontCreateWithDataAndExtra()
{
  return MEMORY[0x1F4119C58]();
}

uint64_t FPFontCreateWithPathAndName()
{
  return MEMORY[0x1F4119C60]();
}

uint64_t FPFontGetDefaultInstance()
{
  return MEMORY[0x1F4119C80]();
}

uint64_t FPFontGetFontInfo()
{
  return MEMORY[0x1F4119C88]();
}

uint64_t FPFontGetGlyphDeviceAdvance()
{
  return MEMORY[0x1F4119C98]();
}

uint64_t FPFontGetGlyphDeviceBounds()
{
  return MEMORY[0x1F4119CA0]();
}

uint64_t FPFontGetGlyphIdealAdvanceWidths()
{
  return MEMORY[0x1F4119CA8]();
}

uint64_t FPFontGetGlyphIdealBounds()
{
  return MEMORY[0x1F4119CB0]();
}

uint64_t FPFontGetGlyphIdealVerticalAdvanceWidth()
{
  return MEMORY[0x1F4119CB8]();
}

uint64_t FPFontGetGlyphVerticalTranslate()
{
  return MEMORY[0x1F4119CC8]();
}

uint64_t FPFontGetGlyphsForCharacters()
{
  return MEMORY[0x1F4119CE0]();
}

uint64_t FPFontGetNumberOfGlyphs()
{
  return MEMORY[0x1F4119D08]();
}

uint64_t FPFontGetStemH()
{
  return MEMORY[0x1F4119D20]();
}

uint64_t FPFontGetStemV()
{
  return MEMORY[0x1F4119D28]();
}

uint64_t FPFontGetUnicharsForGlyph()
{
  return MEMORY[0x1F4119D50]();
}

uint64_t FPFontGetUnitsPerEm()
{
  return MEMORY[0x1F4119D58]();
}

uint64_t FPFontGetVMetrics()
{
  return MEMORY[0x1F4119D60]();
}

uint64_t FPFontGetVariation()
{
  return MEMORY[0x1F4119D68]();
}

uint64_t FPFontIsBitmapOnly()
{
  return MEMORY[0x1F4119DB0]();
}

uint64_t FPFontIsNamedInstance()
{
  return MEMORY[0x1F4119DB8]();
}

uint64_t FPFontRelease()
{
  return MEMORY[0x1F4119DD0]();
}

uint64_t FPFontRetain()
{
  return MEMORY[0x1F4119DD8]();
}

CFTypeRef IOSurfaceCopyValue(IOSurfaceRef buffer, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40E9300](buffer, key);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1F40E9358](buffer);
}

size_t IOSurfaceGetBytesPerRow(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E93A8](buffer);
}

size_t IOSurfaceGetHeight(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9440](buffer);
}

OSType IOSurfaceGetPixelFormat(IOSurfaceRef buffer)
{
  return MEMORY[0x1F40E9480](buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9540](buffer, *(void *)&options, seed);
}

void IOSurfaceRemoveValue(IOSurfaceRef buffer, CFStringRef key)
{
}

void IOSurfaceSetValue(IOSurfaceRef buffer, CFStringRef key, CFTypeRef value)
{
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1F40E9630](buffer, *(void *)&options, seed);
}

id NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone)
{
  return (id)MEMORY[0x1F40E6FF0](aClass, extraBytes, zone);
}

NSRange NSIntersectionRange(NSRange range1, NSRange range2)
{
  NSUInteger v2 = MEMORY[0x1F40E7140](range1.location, range1.length, range2.location, range2.length);
  result.length = v3;
  result.location = v2;
  return result;
}

void NSLog(NSString *format, ...)
{
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1F40E7280](aClass);
}

void NSZoneFree(NSZone *zone, void *ptr)
{
}

NSZone *__cdecl NSZoneFromPointer(void *ptr)
{
  return (NSZone *)MEMORY[0x1F40E7308](ptr);
}

void *__cdecl NSZoneMalloc(NSZone *zone, NSUInteger size)
{
  return (void *)MEMORY[0x1F40E7310](zone, size);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1F40F7138](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1F40F7160](allocator);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFBundleGetMainBundleIfLooksLikeBundle()
{
  return MEMORY[0x1F40D8C68]();
}

uint64_t _CFDictionaryIsMutable()
{
  return MEMORY[0x1F40D8D50]();
}

uint64_t _CFExecutableLinkedOnOrAfter()
{
  return MEMORY[0x1F40D8DB8]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeGetClassWithTypeID()
{
  return MEMORY[0x1F40D90D8]();
}

uint64_t _CFRuntimeInitStaticInstance()
{
  return MEMORY[0x1F40D90E0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t PB::TextFormatter::beginObject(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x1F4147448](this, a2);
}

uint64_t PB::TextFormatter::format()
{
  return MEMORY[0x1F4147450]();
}

{
  return MEMORY[0x1F4147458]();
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x1F4147460](this, a2);
}

{
  return MEMORY[0x1F4147480](this, a2);
}

{
  return MEMORY[0x1F4147488](this, a2);
}

{
  return MEMORY[0x1F4147490](this, a2);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, double a3)
{
  return MEMORY[0x1F4147468](this, a2, a3);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, float a3)
{
  return MEMORY[0x1F4147470](this, a2, a3);
}

void PB::Base::~Base(PB::Base *this)
{
}

uint64_t PB::Data::Data(PB::Data *this, const unsigned __int8 *a2)
{
  return MEMORY[0x1F41474B0](this, a2);
}

uint64_t PB::Data::Data(PB::Data *this, const PB::Data *a2)
{
  return MEMORY[0x1F41474B8](this, a2);
}

uint64_t PB::Reader::recallMark()
{
  return MEMORY[0x1F41474C0]();
}

uint64_t PB::Reader::read(PB::Reader *this, PB::Data *a2)
{
  return MEMORY[0x1F41474C8](this, a2);
}

uint64_t PB::Reader::read()
{
  return MEMORY[0x1F41474D0]();
}

uint64_t PB::Reader::skip(PB::Reader *this)
{
  return MEMORY[0x1F41474E0](this);
}

uint64_t PB::Reader::placeMark()
{
  return MEMORY[0x1F41474E8]();
}

uint64_t PB::Reader::Reader(PB::Reader *this, const unsigned __int8 *a2)
{
  return MEMORY[0x1F41474F0](this, a2);
}

uint64_t PB::Writer::writeVarInt(PB::Writer *this)
{
  return MEMORY[0x1F4147518](this);
}

{
  return MEMORY[0x1F4147520](this);
}

{
  return MEMORY[0x1F4147528](this);
}

uint64_t PB::Writer::writeSubmessage(PB::Writer *this, const PB::Base *a2)
{
  return MEMORY[0x1F4147530](this, a2);
}

uint64_t PB::Writer::write()
{
  return MEMORY[0x1F4147540]();
}

uint64_t PB::Writer::write(PB::Writer *this)
{
  return MEMORY[0x1F4147550](this);
}

uint64_t PB::Writer::write(PB::Writer *this, double a2)
{
  return MEMORY[0x1F4147558](this, a2);
}

uint64_t PB::Writer::write(PB::Writer *this, float a2)
{
  return MEMORY[0x1F4147560](this, a2);
}

uint64_t PB::Writer::Writer(PB::Writer *this)
{
  return MEMORY[0x1F4147578](this);
}

void PB::Writer::~Writer(PB::Writer *this)
{
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1F417E380](this, __c, __pos);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1F417E3A8]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E438](this, a2);
}

{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E450](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::logic_error *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E458](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4B8](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x1F417E4D0](this, a2);
}

void std::invalid_argument::~invalid_argument(std::invalid_argument *this)
{
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E5B8](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E5D8](this, __s);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E620](this, __pos, __n1, __s);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E898]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

double std::stod(const std::string *__str, size_t *__idx)
{
  MEMORY[0x1F417EBD0](__str, __idx);
  return result;
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

uint64_t std::__sort<std::__less<double,double> &,double *>()
{
  return MEMORY[0x1F417EC38]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

uint64_t __CFSetLastAllocationEventName()
{
  return MEMORY[0x1F40D95A0]();
}

__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t a1, locale_t a2)
{
  return MEMORY[0x1F40C9B20](*(void *)&a1, a2);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

void __cxa_bad_cast(void)
{
}

void __cxa_bad_typeid(void)
{
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1F417EFA8](lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

int __maskrune_l(__darwin_ct_rune_t a1, unint64_t a2, locale_t a3)
{
  return MEMORY[0x1F40C9C20](*(void *)&a1, a2, a3);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x1F40C9C80](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x1F40C9C88](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return MEMORY[0x1F40C9CA0](a1, *(void *)&a2, a3, a4);
}

uint64_t __strcat_chk()
{
  return MEMORY[0x1F40C9CC0]();
}

uint64_t __strcpy_chk()
{
  return MEMORY[0x1F40C9CC8]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1F40C9CD0]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

uint64_t __strncat_chk()
{
  return MEMORY[0x1F40C9CE0]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

uint64_t _amkrtemp()
{
  return MEMORY[0x1F40C9D40]();
}

const mach_header *__cdecl _dyld_get_image_header(uint32_t image_index)
{
  return (const mach_header *)MEMORY[0x1F40C9E08](*(void *)&image_index);
}

const char *__cdecl _dyld_get_image_name(uint32_t image_index)
{
  return (const char *)MEMORY[0x1F40C9E10](*(void *)&image_index);
}

uint32_t _dyld_image_count(void)
{
  return MEMORY[0x1F40C9E60]();
}

uint64_t _objc_getClassForTag()
{
  return MEMORY[0x1F4181418]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

uint64_t _xpc_runtime_is_app_sandboxed()
{
  return MEMORY[0x1F40CA1D8]();
}

void abort(void)
{
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

long double acos(long double __x)
{
  MEMORY[0x1F40CA330](__x);
  return result;
}

float acosf(float a1)
{
  MEMORY[0x1F40CA340](a1);
  return result;
}

long double acosh(long double __x)
{
  MEMORY[0x1F40CA348](__x);
  return result;
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

long double asin(long double __x)
{
  MEMORY[0x1F40CA3D0](__x);
  return result;
}

long double asinh(long double __x)
{
  MEMORY[0x1F40CA3E0](__x);
  return result;
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

long double atan(long double __x)
{
  MEMORY[0x1F40CA450](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x1F40CA460](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x1F40CA468](a1, a2);
  return result;
}

long double atanh(long double __x)
{
  MEMORY[0x1F40CA478](__x);
  return result;
}

double atof(const char *a1)
{
  MEMORY[0x1F40CA498](a1);
  return result;
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1F40CA4F8](a1, *(void *)&a2);
}

void backtrace_image_offsets(void *const *array, image_offset *image_offsets, int size)
{
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CA520](a1, a2);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x1F40CA570](__key, __base, __nel, __width, __compar);
}

void *__cdecl bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, void *__compar)
{
  return (void *)MEMORY[0x1F40CA578](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
}

int cache_create(const char *name, const cache_attributes_t *attrs, cache_t **cache_out)
{
  return MEMORY[0x1F40CA5A8](name, attrs, cache_out);
}

int cache_get_and_retain(cache_t *cache, void *key, void **value_out)
{
  return MEMORY[0x1F40CA5C0](cache, key, value_out);
}

uintptr_t cache_hash_byte_string(const char *data, size_t bytes)
{
  return MEMORY[0x1F40CA5F8](data, bytes);
}

int cache_release_value(cache_t *cache, void *value)
{
  return MEMORY[0x1F40CA610](cache, value);
}

int cache_remove(cache_t *cache, void *key)
{
  return MEMORY[0x1F40CA618](cache, key);
}

int cache_remove_all(cache_t *cache)
{
  return MEMORY[0x1F40CA620](cache);
}

int cache_set_and_retain(cache_t *cache, void *key, void *value, cache_cost_t cost)
{
  return MEMORY[0x1F40CA630](cache, key, value, cost);
}

uint64_t cache_set_count_hint()
{
  return MEMORY[0x1F40CA640]();
}

long double cbrt(long double __x)
{
  MEMORY[0x1F40CA688](__x);
  return result;
}

Ivar *__cdecl class_copyIvarList(Class cls, unsigned int *outCount)
{
  return (Ivar *)MEMORY[0x1F41814E8](cls, outCount);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1F4181558](cls);
}

void clearerr(FILE *a1)
{
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1F40CB400](a1);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CB438](*(void *)&a1, a2, a3);
}

long double cos(long double __x)
{
  MEMORY[0x1F40CB8A8](__x);
  return result;
}

long double cosh(long double __x)
{
  MEMORY[0x1F40CB8B8](__x);
  return result;
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x1F4182BD0](strm, *(void *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x1F4182BE0](strm);
}

int deflateInit_(z_streamp strm, int level, const char *version, int stream_size)
{
  return MEMORY[0x1F4182BF0](strm, *(void *)&level, version, *(void *)&stream_size);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1F40CBDA0](a1, a2);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1F40CBEC8]();
}

long double erf(long double __x)
{
  MEMORY[0x1F40CBF50](__x);
  return result;
}

long double erfc(long double __x)
{
  MEMORY[0x1F40CBF58](__x);
  return result;
}

long double exp(long double __x)
{
  MEMORY[0x1F40CBFE0](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x1F40CBFE8](__x);
  return result;
}

float exp2f(float a1)
{
  MEMORY[0x1F40CBFF0](a1);
  return result;
}

float expf(float a1)
{
  MEMORY[0x1F40CBFF8](a1);
  return result;
}

long double expm1(long double __x)
{
  MEMORY[0x1F40CC000](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

long double fdim(long double __x, long double __y)
{
  MEMORY[0x1F40CC068](__x, __y);
  return result;
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return (FILE *)MEMORY[0x1F40CC070](*(void *)&a1, a2);
}

int ferror(FILE *a1)
{
  return MEMORY[0x1F40CC0A0](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

float fmodf(float a1, float a2)
{
  MEMORY[0x1F40CC1A8](a1, a2);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fprintf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  return MEMORY[0x1F40CC1E0](a1, a2, a3);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1F40CC1E8](*(void *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1F40CC1F0](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC200](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x1F40CC290](a1, a2, *(void *)&a3);
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return MEMORY[0x1F40CC298](__stream, a2, *(void *)&__whence);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1F40CC360](a1, a2, a3, a4, *(void *)&a5);
}

int getc(FILE *a1)
{
  return MEMORY[0x1F40CC388](a1);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

long double hypot(long double __x, long double __y)
{
  MEMORY[0x1F40CC630](__x, __y);
  return result;
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x1F4182CB0](strm, *(void *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x1F4182CB8](strm);
}

int inflateInit_(z_streamp strm, const char *version, int stream_size)
{
  return MEMORY[0x1F4182CD8](strm, version, *(void *)&stream_size);
}

int inflateReset(z_streamp strm)
{
  return MEMORY[0x1F4182CE0](strm);
}

ptrdiff_t ivar_getOffset(Ivar v)
{
  return MEMORY[0x1F41815C0](v);
}

const char *__cdecl ivar_getTypeEncoding(Ivar v)
{
  return (const char *)MEMORY[0x1F41815C8](v);
}

double j0(double a1)
{
  MEMORY[0x1F40CC6D8](a1);
  return result;
}

double j1(double a1)
{
  MEMORY[0x1F40CC6E0](a1);
  return result;
}

double lgamma_r(double a1, int *a2)
{
  MEMORY[0x1F40CC828](a2, a1);
  return result;
}

long double log(long double __x)
{
  MEMORY[0x1F40CC878](__x);
  return result;
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

long double log1p(long double __x)
{
  MEMORY[0x1F40CC890](__x);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x1F40CC8A8](__x);
  return result;
}

long double logb(long double __x)
{
  MEMORY[0x1F40CC8B8](__x);
  return result;
}

float logf(float a1)
{
  MEMORY[0x1F40CC8C0](a1);
  return result;
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1F40CCB10](__size);
}

malloc_zone_t *malloc_default_purgeable_zone(void)
{
  return (malloc_zone_t *)MEMORY[0x1F40CCB28]();
}

malloc_zone_t *malloc_default_zone(void)
{
  return (malloc_zone_t *)MEMORY[0x1F40CCB30]();
}

int malloc_make_nonpurgeable(void *ptr)
{
  return MEMORY[0x1F40CCB60](ptr);
}

void malloc_make_purgeable(void *ptr)
{
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1F40CCB80](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x1F40CCBA0](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBB8](zone, count, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
{
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return MEMORY[0x1F40CCD48](__base, __nel, __width, __compar);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1F40CCDD0](a1, a2);
}

int mkstemps(char *a1, int a2)
{
  return MEMORY[0x1F40CCE18](a1, *(void *)&a2);
}

char *__cdecl mktemp(char *a1)
{
  return (char *)MEMORY[0x1F40CCE28](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

long double modf(long double __x, long double *__y)
{
  MEMORY[0x1F40CCE48](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

double nan(const char *a1)
{
  MEMORY[0x1F40CCE90](a1);
  return result;
}

long double nextafter(long double __x, long double __y)
{
  MEMORY[0x1F40CCFF8](__x, __y);
  return result;
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyCppObjectAtomic(void *dest, const void *src, void (__cdecl *copyHelper)(void *, const void *))
{
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F4181798](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

uint64_t self
{
  return MEMORY[0x1F41817D0]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

void objc_terminate(void)
{
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181A40](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1F4181A58](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1F40CD120](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x1F40CD630]();
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1F40CD648]();
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x1F40CD828](a1, a2);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CD830](*(void *)&__fd, __buf, __nbyte, a4);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD918](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD930](a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD940](a1, *(void *)&a2);
}

int pthread_attr_setscope(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD960](a1, *(void *)&a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x1F40CD978](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1F40CD980](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1F40CD988](a1, a2);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1F40CD9A8](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

void *__cdecl pthread_get_stackaddr_np(pthread_t a1)
{
  return (void *)MEMORY[0x1F40CDA00](a1);
}

size_t pthread_get_stacksize_np(pthread_t a1)
{
  return MEMORY[0x1F40CDA08](a1);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1F40CDA20](a1);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1F40CDA40](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA78](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA0](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA8](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1F40CDAC0](a1, *(void *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1F40CDB70](a1, a2);
}

int putchar(int a1)
{
  return MEMORY[0x1F40CDBA8](*(void *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x1F40CDBB8](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
}

void qsort_r(void *__base, size_t __nel, size_t __width, void *a4, int (__cdecl *__compar)(void *, const void *, const void *))
{
}

int rand(void)
{
  return MEMORY[0x1F40CDC08]();
}

int rand_r(unsigned int *a1)
{
  return MEMORY[0x1F40CDC10](a1);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1F40CDC60](a1);
}

long double remquo(long double __x, long double __y, int *__z)
{
  MEMORY[0x1F40CDD50](__z, __x, __y);
  return result;
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

uint64_t rootless_trusted_by_self_token()
{
  return MEMORY[0x1F40CDDB8]();
}

uint64_t rootless_verify_trusted_by_self_token()
{
  return MEMORY[0x1F40CDDC0]();
}

long double sin(long double __x)
{
  MEMORY[0x1F40CE058](__x);
  return result;
}

long double sinh(long double __x)
{
  MEMORY[0x1F40CE068](__x);
  return result;
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1F40CE078](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  return MEMORY[0x1F40CE088](a1, a2, a3, a4);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CE0A0](a1, a2);
}

int sprintf_l(char *a1, locale_t a2, const char *a3, ...)
{
  return MEMORY[0x1F40CE0A8](a1, a2, a3);
}

void srandom(unsigned int a1)
{
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CE0D0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE148](__s1, __s2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE150](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1F40CE168](__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1A8](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1F40CE1D8](a1, a2, a3);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1E8](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return (char *)MEMORY[0x1F40CE200](__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE230](__s, *(void *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE258](__s1, __s2);
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  MEMORY[0x1F40CE268](a1, a2, a3);
  return result;
}

intmax_t strtoimax_l(const char *nptr, char **endptr, int base, locale_t a4)
{
  return MEMORY[0x1F40CE288](nptr, endptr, *(void *)&base, a4);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2A0](__str, __endptr, *(void *)&__base);
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1F40CE2A8](a1, a2, *(void *)&a3, a4);
}

uint64_t swift_allocError()
{
  return MEMORY[0x1F41863E0]();
}

uint64_t swift_allocObject()
{
  return MEMORY[0x1F41863E8]();
}

uint64_t swift_beginAccess()
{
  return MEMORY[0x1F4186430]();
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x1F4186440]();
}

uint64_t swift_bridgeObjectRelease_n()
{
  return MEMORY[0x1F4186448]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x1F4186450]();
}

uint64_t swift_bridgeObjectRetain_n()
{
  return MEMORY[0x1F4186458]();
}

uint64_t swift_checkMetadataState()
{
  return MEMORY[0x1F4186460]();
}

uint64_t swift_endAccess()
{
  return MEMORY[0x1F4186518]();
}

uint64_t swift_getAssociatedConformanceWitness()
{
  return MEMORY[0x1F4186538]();
}

uint64_t swift_getAssociatedTypeWitness()
{
  return MEMORY[0x1F4186540]();
}

uint64_t swift_getEnumCaseMultiPayload()
{
  return MEMORY[0x1F4186570]();
}

uint64_t swift_getForeignTypeMetadata()
{
  return MEMORY[0x1F41865A8]();
}

uint64_t swift_getGenericMetadata()
{
  return MEMORY[0x1F41865E0]();
}

uint64_t swift_getSingletonMetadata()
{
  return MEMORY[0x1F4186628]();
}

uint64_t swift_getTupleTypeLayout2()
{
  return MEMORY[0x1F4186638]();
}

uint64_t swift_getTupleTypeMetadata2()
{
  return MEMORY[0x1F4186650]();
}

uint64_t swift_getTupleTypeMetadata3()
{
  return MEMORY[0x1F4186658]();
}

uint64_t swift_getTypeByMangledNameInContext2()
{
  return MEMORY[0x1F4186668]();
}

uint64_t swift_getTypeByMangledNameInContextInMetadataState2()
{
  return MEMORY[0x1F4186670]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x1F4186680]();
}

uint64_t swift_initEnumMetadataMultiPayload()
{
  return MEMORY[0x1F4186690]();
}

uint64_t swift_initStructMetadata()
{
  return MEMORY[0x1F41866B8]();
}

uint64_t swift_isEscapingClosureAtFileLocation()
{
  return MEMORY[0x1F41866C8]();
}

uint64_t swift_isUniquelyReferenced_nonNull_native()
{
  return MEMORY[0x1F4186700]();
}

uint64_t swift_makeBoxUnique()
{
  return MEMORY[0x1F4186710]();
}

uint64_t swift_once()
{
  return MEMORY[0x1F4186728]();
}

uint64_t swift_release()
{
  return MEMORY[0x1F4186758]();
}

uint64_t swift_release_n()
{
  return MEMORY[0x1F4186760]();
}

uint64_t swift_retain()
{
  return MEMORY[0x1F4186770]();
}

uint64_t swift_retain_n()
{
  return MEMORY[0x1F4186778]();
}

uint64_t swift_slowAlloc()
{
  return MEMORY[0x1F4186798]();
}

uint64_t swift_slowDealloc()
{
  return MEMORY[0x1F41867A0]();
}

uint64_t swift_stdlib_isStackAllocationSafe()
{
  return MEMORY[0x1F41867A8]();
}

uint64_t swift_storeEnumTagMultiPayload()
{
  return MEMORY[0x1F41867B8]();
}

uint64_t swift_unknownObjectRelease()
{
  return MEMORY[0x1F41867E0]();
}

uint64_t swift_unknownObjectRetain()
{
  return MEMORY[0x1F41867F0]();
}

uint64_t swift_willThrow()
{
  return MEMORY[0x1F41868E0]();
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1F40CE3D0](a1, a2, a3, a4, a5);
}

long double tan(long double __x)
{
  MEMORY[0x1F40CE420](__x);
  return result;
}

long double tanh(long double __x)
{
  MEMORY[0x1F40CE430](__x);
  return result;
}

long double tgamma(long double __x)
{
  MEMORY[0x1F40CE508](__x);
  return result;
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

UCharDirection u_charDirection(UChar32 c)
{
  return MEMORY[0x1F417F700](*(void *)&c);
}

uint64_t ubidi_close()
{
  return MEMORY[0x1F417F970]();
}

uint64_t ubidi_countRuns()
{
  return MEMORY[0x1F417F978]();
}

uint64_t ubidi_getLength()
{
  return MEMORY[0x1F417F988]();
}

uint64_t ubidi_getProcessedLength()
{
  return MEMORY[0x1F417F9B8]();
}

uint64_t ubidi_getResultLength()
{
  return MEMORY[0x1F417F9C0]();
}

uint64_t ubidi_getVisualMap()
{
  return MEMORY[0x1F417F9C8]();
}

uint64_t ubidi_open()
{
  return MEMORY[0x1F417F9D0]();
}

uint64_t ubidi_setContext()
{
  return MEMORY[0x1F417F9E8]();
}

uint64_t ubidi_setPara()
{
  return MEMORY[0x1F417F9F8]();
}

uint64_t ubidi_setReorderingMode()
{
  return MEMORY[0x1F417FA08]();
}

uint64_t ubidi_writeReordered()
{
  return MEMORY[0x1F417FA18]();
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

vImage_Error vImageByteSwap_Planar16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D22D0](src, dest, *(void *)&flags);
}

uint64_t vImageCGCompositeConstMask_ARGB16F()
{
  return MEMORY[0x1F40D22D8]();
}

uint64_t vImageCGCompositeConstShape_ARGB16F()
{
  return MEMORY[0x1F40D22E0]();
}

uint64_t vImageCGCompositeImage_ARGB16F()
{
  return MEMORY[0x1F40D22E8]();
}

uint64_t vImageCGCompositeMarkConstDeepMaskARGB_ARGB16F()
{
  return MEMORY[0x1F40D22F0]();
}

uint64_t vImageCGCompositeMarkConstDeepMaskXRGB_ARGB16F()
{
  return MEMORY[0x1F40D22F8]();
}

uint64_t vImageCGCompositePixelMask_ARGB16F()
{
  return MEMORY[0x1F40D2300]();
}

uint64_t vImageCGCompositePixelShape_ARGB16F()
{
  return MEMORY[0x1F40D2308]();
}

vImage_Error vImageConvert_ARGB2101010ToARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, int32_t RGB101010RangeMin, int32_t RGB101010RangeMax, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1F40D24B0](src, dest, *(void *)&RGB101010RangeMin, *(void *)&RGB101010RangeMax, permuteMap, *(void *)&flags);
}

vImage_Error vImageConvert_ARGBFFFFToARGB2101010(const vImage_Buffer *src, const vImage_Buffer *dest, int32_t RGB101010RangeMin, int32_t RGB101010RangeMax, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1F40D2540](src, dest, *(void *)&RGB101010RangeMin, *(void *)&RGB101010RangeMax, permuteMap, *(void *)&flags);
}

vImage_Error vImageConvert_AnyToAny(const vImageConverterRef converter, const vImage_Buffer *srcs, const vImage_Buffer *dests, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1F40D2578](converter, srcs, dests, tempBuffer, *(void *)&flags);
}

vImage_Error vImageConvert_Planar1toPlanar8(const vImage_Buffer *src, const vImage_Buffer *dest, const vImage_Flags flags)
{
  return MEMORY[0x1F40D25D0](src, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8ToBGRX8888(const vImage_Buffer *blue, const vImage_Buffer *green, const vImage_Buffer *red, Pixel_8 alpha, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D25F0](blue, green, red, alpha, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8ToXRGB8888(Pixel_8 alpha, const vImage_Buffer *red, const vImage_Buffer *green, const vImage_Buffer *blue, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D25F8](alpha, red, green, blue, dest, *(void *)&flags);
}

vImage_Error vImageConvert_RGB888toARGB8888(const vImage_Buffer *a1, const vImage_Buffer *a2, Pixel_8 a3, const vImage_Buffer *a4, BOOL a5, vImage_Flags a6)
{
  return MEMORY[0x1F40D26B0](a1, a2, a3, a4, a5, *(void *)&a6);
}

vImage_Error vImageConvert_RGB888toBGRA8888(const vImage_Buffer *a1, const vImage_Buffer *a2, Pixel_8 a3, const vImage_Buffer *a4, BOOL a5, vImage_Flags a6)
{
  return MEMORY[0x1F40D26B8](a1, a2, a3, a4, a5, *(void *)&a6);
}

vImage_Error vImageConvert_RGB888toRGBA8888(const vImage_Buffer *a1, const vImage_Buffer *a2, Pixel_8 a3, const vImage_Buffer *a4, BOOL a5, vImage_Flags a6)
{
  return MEMORY[0x1F40D26D0](a1, a2, a3, a4, a5, *(void *)&a6);
}

vImage_Error vImageConvert_XRGB2101010ToARGB16F(const vImage_Buffer *src, Pixel_F alpha, const vImage_Buffer *dest, int32_t RGB101010RangeMin, int32_t RGB101010RangeMax, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1F40D2720](src, dest, *(void *)&RGB101010RangeMin, *(void *)&RGB101010RangeMax, permuteMap, *(void *)&flags, alpha);
}

vImageConverterRef vImageConverter_CreateWithCGColorConversionInfo(CGColorConversionInfoRef colorConversionInfoRef, const vImage_CGImageFormat *sFormat, const vImage_CGImageFormat *dFormat, const CGFloat *bg, vImage_Flags flags, vImage_Error *error)
{
  return (vImageConverterRef)MEMORY[0x1F40D27A0](colorConversionInfoRef, sFormat, dFormat, bg, *(void *)&flags, error);
}

vImageConverterRef vImageConverter_CreateWithCGImageFormat(const vImage_CGImageFormat *srcFormat, const vImage_CGImageFormat *destFormat, const CGFloat *backgroundColor, vImage_Flags flags, vImage_Error *error)
{
  return (vImageConverterRef)MEMORY[0x1F40D27A8](srcFormat, destFormat, backgroundColor, *(void *)&flags, error);
}

void vImageConverter_Release(vImageConverterRef converter)
{
}

vImage_Error vImageConvolve_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, const int16_t *kernel, uint32_t kernel_height, uint32_t kernel_width, int32_t divisor, const Pixel_8888 backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2828](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel, *(void *)&kernel_height, *(void *)&kernel_width);
}

vImage_Error vImageConvolve_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, const float *kernel, uint32_t kernel_height, uint32_t kernel_width, const Pixel_FFFF backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2830](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel, *(void *)&kernel_height, *(void *)&kernel_width);
}

vImage_Error vImageConvolve_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, const int16_t *kernel, uint32_t kernel_height, uint32_t kernel_width, int32_t divisor, Pixel_8 backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2848](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel, *(void *)&kernel_height, *(void *)&kernel_width);
}

vImage_Error vImageDilate_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, const unsigned __int8 *kernel, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags)
{
  return MEMORY[0x1F40D2888](src, dest, srcOffsetToROI_X, srcOffsetToROI_Y, kernel, kernel_height, kernel_width, *(void *)&flags);
}

vImage_Error vImageExtractChannel_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint64_t channelIndex, vImage_Flags flags)
{
  return MEMORY[0x1F40D28E0](src, dest, channelIndex, *(void *)&flags);
}

vImage_Error vImageMatrixMultiply_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const int16_t matrix[16], int32_t divisor, const int16_t *pre_bias, const int32_t *post_bias, vImage_Flags flags)
{
  return MEMORY[0x1F40D2A58](src, dest, matrix, *(void *)&divisor, pre_bias, post_bias, *(void *)&flags);
}

vImage_Error vImageMatrixMultiply_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, const float matrix[16], const float *pre_bias, const float *post_bias, vImage_Flags flags)
{
  return MEMORY[0x1F40D2A68](src, dest, matrix, pre_bias, post_bias, *(void *)&flags);
}

vImage_Error vImageMin_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags)
{
  return MEMORY[0x1F40D2AB8](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel_height, kernel_width, *(void *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_ARGB8888(Pixel_8 scalar, const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t copyMask, vImage_Flags flags)
{
  return MEMORY[0x1F40D2AF8](scalar, src, dest, copyMask, *(void *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_ARGBFFFF(Pixel_F scalar, const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t copyMask, vImage_Flags flags)
{
  return MEMORY[0x1F40D2B00](src, dest, copyMask, *(void *)&flags, scalar);
}

vImage_Error vImageOverwriteChannels_ARGB8888(const vImage_Buffer *newSrc, const vImage_Buffer *origSrc, const vImage_Buffer *dest, uint8_t copyMask, vImage_Flags flags)
{
  return MEMORY[0x1F40D2B30](newSrc, origSrc, dest, copyMask, *(void *)&flags);
}

vImage_Error vImagePermuteChannelsWithMaskedInsert_ARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], uint8_t copyMask, const Pixel_ARGB_16U backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2B40](src, dest, permuteMap, copyMask, backgroundColor, *(void *)&flags);
}

vImage_Error vImagePermuteChannelsWithMaskedInsert_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], uint8_t copyMask, const Pixel_8888 backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x1F40D2B48](src, dest, permuteMap, copyMask, backgroundColor, *(void *)&flags);
}

vImage_Error vImagePermuteChannels_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1F40D2B60](src, dest, permuteMap, *(void *)&flags);
}

vImage_Error vImagePremultipliedAlphaBlendWithPermute_ARGB8888(const vImage_Buffer *srcTop, const vImage_Buffer *srcBottom, const vImage_Buffer *dest, const uint8_t permuteMap[4], BOOL makeDestAlphaOpaque, vImage_Flags flags)
{
  return MEMORY[0x1F40D2BC0](srcTop, srcBottom, dest, permuteMap, makeDestAlphaOpaque, *(void *)&flags);
}

vImage_Error vImagePremultipliedAlphaBlendWithPermute_RGBA8888(const vImage_Buffer *srcTop, const vImage_Buffer *srcBottom, const vImage_Buffer *dest, const uint8_t permuteMap[4], BOOL makeDestAlphaOpaque, vImage_Flags flags)
{
  return MEMORY[0x1F40D2BC8](srcTop, srcBottom, dest, permuteMap, makeDestAlphaOpaque, *(void *)&flags);
}

vImage_Error vImagePremultiplyData_RGBA8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C20](src, dest, *(void *)&flags);
}

vImage_Error vImagePremultiplyData_RGBAFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2C28](src, dest, *(void *)&flags);
}

vImage_Error vImageScale_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1F40D2D08](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageUnpremultiplyData_RGBAFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1F40D2D80](src, dest, *(void *)&flags);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x1F40CE680](a1, a2, a3);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x1F40CE690](a1, a2, a3);
}

int vfprintf_l(FILE *a1, locale_t a2, const char *a3, va_list a4)
{
  return MEMORY[0x1F40CE698](a1, a2, a3, a4);
}

kern_return_t vm_copy(vm_map_t target_task, vm_address_t source_address, vm_size_t size, vm_address_t dest_address)
{
  return MEMORY[0x1F40CE6B8](*(void *)&target_task, source_address, size, dest_address);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1F40CE6C0](*(void *)&target_task, address, size);
}

kern_return_t vm_protect(vm_map_t target_task, vm_address_t address, vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return MEMORY[0x1F40CE6D8](*(void *)&target_task, address, size, *(void *)&set_maximum, *(void *)&new_protection);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}

int vsnprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, va_list a5)
{
  return MEMORY[0x1F40CE798](a1, a2, a3, a4, a5);
}

int vsscanf(const char *__str, const char *__format, va_list a3)
{
  return MEMORY[0x1F40CE7A8](__str, __format, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}

xmlBufferPtr xmlBufferCreate(void)
{
  return (xmlBufferPtr)MEMORY[0x1F41825E8]();
}

void xmlBufferFree(xmlBufferPtr buf)
{
}

xmlNodePtr xmlDocGetRootElement(const xmlDoc *doc)
{
  return (xmlNodePtr)MEMORY[0x1F4182678](doc);
}

void xmlFreeDoc(xmlDocPtr cur)
{
}

void xmlFreeTextWriter(xmlTextWriterPtr writer)
{
}

xmlTextWriterPtr xmlNewTextWriterMemory(xmlBufferPtr buf, int compression)
{
  return (xmlTextWriterPtr)MEMORY[0x1F4182790](buf, *(void *)&compression);
}

xmlChar *__cdecl xmlNodeListGetString(xmlDocPtr doc, const xmlNode *list, int inLine)
{
  return (xmlChar *)MEMORY[0x1F41827C0](doc, list, *(void *)&inLine);
}

xmlDocPtr xmlReadFile(const char *URL, const char *encoding, int options)
{
  return (xmlDocPtr)MEMORY[0x1F4182818](URL, encoding, *(void *)&options);
}

int xmlStrcmp(const xmlChar *str1, const xmlChar *str2)
{
  return MEMORY[0x1F4182938](str1, str2);
}

int xmlTextWriterEndDocument(xmlTextWriterPtr writer)
{
  return MEMORY[0x1F41829F0](writer);
}

int xmlTextWriterEndElement(xmlTextWriterPtr writer)
{
  return MEMORY[0x1F41829F8](writer);
}

int xmlTextWriterSetIndent(xmlTextWriterPtr writer, int indent)
{
  return MEMORY[0x1F4182A10](writer, *(void *)&indent);
}

int xmlTextWriterSetIndentString(xmlTextWriterPtr writer, const xmlChar *str)
{
  return MEMORY[0x1F4182A18](writer, str);
}

int xmlTextWriterStartDocument(xmlTextWriterPtr writer, const char *version, const char *encoding, const char *standalone)
{
  return MEMORY[0x1F4182A20](writer, version, encoding, standalone);
}

int xmlTextWriterStartElement(xmlTextWriterPtr writer, const xmlChar *name)
{
  return MEMORY[0x1F4182A28](writer, name);
}

int xmlTextWriterWriteAttribute(xmlTextWriterPtr writer, const xmlChar *name, const xmlChar *content)
{
  return MEMORY[0x1F4182A30](writer, name, content);
}

int xmlTextWriterWriteFormatAttribute(xmlTextWriterPtr writer, const xmlChar *name, const char *format, ...)
{
  return MEMORY[0x1F4182A40](writer, name, format);
}

int xmlTextWriterWriteFormatRaw(xmlTextWriterPtr writer, const char *format, ...)
{
  return MEMORY[0x1F4182A48](writer, format);
}

int xmlTextWriterWriteRaw(xmlTextWriterPtr writer, const xmlChar *content)
{
  return MEMORY[0x1F4182A50](writer, content);
}

xmlXPathObjectPtr xmlXPathEvalExpression(const xmlChar *str, xmlXPathContextPtr ctxt)
{
  return (xmlXPathObjectPtr)MEMORY[0x1F4182A78](str, ctxt);
}

void xmlXPathFreeContext(xmlXPathContextPtr ctxt)
{
}

void xmlXPathFreeObject(xmlXPathObjectPtr obj)
{
}

xmlXPathContextPtr xmlXPathNewContext(xmlDocPtr doc)
{
  return (xmlXPathContextPtr)MEMORY[0x1F4182A98](doc);
}

double y0(double a1)
{
  MEMORY[0x1F40CF378](a1);
  return result;
}

double y1(double a1)
{
  MEMORY[0x1F40CF380](a1);
  return result;
}

uint64_t sub_1850C73A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGApplyGainMapHeadRoom_ptr[0] = (uint64_t (*)())CGApplyGainMapHeadRoom();
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))CGApplyGainMapHeadRoom_ptr[0])(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1850C740C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGBufIsConstantValue_ptr = (uint64_t (*)())CGBufIsConstantValue();
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))CGBufIsConstantValue_ptr)(a1, a2, a3, a4, a5, a6, a7, a8);
}